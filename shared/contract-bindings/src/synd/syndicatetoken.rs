///Module containing a contract's types and functions.
/**

```solidity
library Checkpoints {
    struct Checkpoint208 { uint48 _key; uint208 _value; }
}
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod Checkpoints {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /**```solidity
struct Checkpoint208 { uint48 _key; uint208 _value; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Checkpoint208 {
        #[allow(missing_docs)]
        pub _key: alloy::sol_types::private::primitives::aliases::U48,
        #[allow(missing_docs)]
        pub _value: alloy::sol_types::private::primitives::aliases::U208,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<48>,
            alloy::sol_types::sol_data::Uint<208>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U48,
            alloy::sol_types::private::primitives::aliases::U208,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Checkpoint208> for UnderlyingRustTuple<'_> {
            fn from(value: Checkpoint208) -> Self {
                (value._key, value._value)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Checkpoint208 {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    _key: tuple.0,
                    _value: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Checkpoint208 {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Checkpoint208 {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(&self._key),
                    <alloy::sol_types::sol_data::Uint<
                        208,
                    > as alloy_sol_types::SolType>::tokenize(&self._value),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Checkpoint208 {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Checkpoint208 {
            const NAME: &'static str = "Checkpoint208";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Checkpoint208(uint48 _key,uint208 _value)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self._key)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        208,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self._value)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Checkpoint208 {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust._key)
                    + <alloy::sol_types::sol_data::Uint<
                        208,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust._value,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    48,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust._key,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    208,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust._value,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`Checkpoints`](self) contract instance.

See the [wrapper's documentation](`CheckpointsInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> CheckpointsInstance<T, P, N> {
        CheckpointsInstance::<T, P, N>::new(address, provider)
    }
    /**A [`Checkpoints`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`Checkpoints`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct CheckpointsInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for CheckpointsInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("CheckpointsInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > CheckpointsInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`Checkpoints`](self) contract instance.

See the [wrapper's documentation](`CheckpointsInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> CheckpointsInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> CheckpointsInstance<T, P, N> {
            CheckpointsInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > CheckpointsInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > CheckpointsInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
/**

Generated by the following Solidity interface...
```solidity
library Checkpoints {
    struct Checkpoint208 {
        uint48 _key;
        uint208 _value;
    }
}

interface SyndicateToken {
    error AccessControlBadConfirmation();
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
    error AllEmissionsCompleted();
    error BridgeNotAuthorized();
    error BridgeNotConfigured();
    error CheckpointUnorderedInsertion();
    error ECDSAInvalidSignature();
    error ECDSAInvalidSignatureLength(uint256 length);
    error ECDSAInvalidSignatureS(bytes32 s);
    error ERC20ExceededSafeSupply(uint256 increasedSupply, uint256 cap);
    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);
    error ERC20InvalidApprover(address approver);
    error ERC20InvalidReceiver(address receiver);
    error ERC20InvalidSender(address sender);
    error ERC20InvalidSpender(address spender);
    error ERC2612ExpiredSignature(uint256 deadline);
    error ERC2612InvalidSigner(address signer, address owner);
    error ERC5805FutureLookup(uint256 timepoint, uint48 clock);
    error ERC6372InconsistentClock();
    error EmissionsAlreadyStarted();
    error EmissionsNotActive();
    error EmissionsNotStarted();
    error EnforcedPause();
    error EpochAlreadyMinted();
    error ExceedsEmissionsSupply();
    error ExpectedPause();
    error InsufficientLimit();
    error InvalidAccountNonce(address account, uint256 currentNonce);
    error InvalidEpoch();
    error InvalidShortString();
    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);
    error StringTooLong(string str);
    error VotesExpiredSignature(uint256 expiry);
    error ZeroAddress();
    error ZeroAmount();
    error ZeroGasLimit();

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event BridgeAuthorized(address indexed bridge);
    event BridgeDataUpdated(bytes oldData, bytes newData);
    event BridgeDeauthorized(address indexed bridge);
    event BridgeLimitsSet(address indexed bridge, uint256 mintingLimit, uint256 burningLimit);
    event BridgeProxyUpdated(address indexed oldProxy, address indexed newProxy);
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    event DelegateVotesChanged(address indexed delegate, uint256 previousVotes, uint256 newVotes);
    event EIP712DomainChanged();
    event EmissionMinted(uint256 epoch, uint256 amount, address indexed destination);
    event EmissionsPaused();
    event EmissionsResumed();
    event EmissionsStarted(uint256 startTime);
    event Paused(address account);
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Unpaused(address account);

    constructor(address defaultAdmin, address syndFoundationAddress, address emissionsManager, address pauser);

    function BRIDGE_LIMIT_DURATION() external view returns (uint256);
    function BRIDGE_MANAGER_ROLE() external view returns (bytes32);
    function CLOCK_MODE() external view returns (string memory);
    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function EMISSIONS_MANAGER_ROLE() external view returns (bytes32);
    function EMISSIONS_SUPPLY() external view returns (uint256);
    function EPOCH_DURATION() external view returns (uint256);
    function INITIAL_MINT_SUPPLY() external view returns (uint256);
    function PAUSER_ROLE() external view returns (bytes32);
    function TOTAL_EPOCHS() external view returns (uint256);
    function TOTAL_SUPPLY() external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
    function authorizedBridges(address) external view returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function bridgeData() external view returns (bytes memory);
    function bridgeLimits(address) external view returns (uint256 mintingMaxLimit, uint256 mintingCurrentLimit, uint256 burningMaxLimit, uint256 burningCurrentLimit, uint256 lastUpdate);
    function bridgeProxy() external view returns (address);
    function burn(address _user, uint256 _amount) external;
    function burningCurrentLimitOf(address _bridge) external view returns (uint256);
    function burningMaxLimitOf(address _bridge) external view returns (uint256);
    function checkpoints(address account, uint32 pos) external view returns (Checkpoints.Checkpoint208 memory);
    function clock() external view returns (uint48);
    function currentEpoch() external view returns (uint256);
    function decimals() external view returns (uint8);
    function delegate(address delegatee) external;
    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;
    function delegates(address account) external view returns (address);
    function eip712Domain() external view returns (bytes1 fields, string memory name, string memory version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] memory extensions);
    function emissionSchedule(uint256) external view returns (uint256);
    function emissionsActive() external view returns (bool);
    function emissionsEnded() external view returns (bool);
    function emissionsStartTime() external view returns (uint256);
    function emissionsStarted() external view returns (bool);
    function getBridgeConfiguration() external view returns (address proxy, bytes memory data);
    function getBridgeInfo(address bridge) external view returns (bool authorized, uint256 mintingMax, uint256 mintingCurrent, uint256 burningMax, uint256 burningCurrent);
    function getBridgeUtilization(address bridge) external view returns (uint256 mintingUtilization, uint256 burningUtilization);
    function getCurrentEpochInfo() external view returns (uint256 epoch, uint256 nextEmissionTime, uint256 nextEmissionAmount, bool canMintEmission);
    function getCurrentTotalSupply() external view returns (uint256);
    function getEmissionSchedule() external view returns (uint256[48] memory);
    function getPastTotalSupply(uint256 timepoint) external view returns (uint256);
    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);
    function getPastVotingPower(address account, uint256 blockNumber) external view returns (uint256);
    function getRemainingEmissions() external view returns (uint256);
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function getVotes(address account) external view returns (uint256);
    function getVotingPower(address account) external view returns (uint256);
    function grantRole(bytes32 role, address account) external;
    function hasRole(bytes32 role, address account) external view returns (bool);
    function isBridge(address bridge) external view returns (bool);
    function mint(address _user, uint256 _amount) external;
    function mintEmission() external;
    function mintingCurrentLimitOf(address _bridge) external view returns (uint256);
    function mintingMaxLimitOf(address _bridge) external view returns (uint256);
    function name() external view returns (string memory);
    function nonces(address owner) external view returns (uint256);
    function numCheckpoints(address account) external view returns (uint32);
    function pause() external;
    function pauseEmissions() external;
    function paused() external view returns (bool);
    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
    function renounceRole(bytes32 role, address callerConfirmation) external;
    function resumeEmissions() external;
    function revokeRole(bytes32 role, address account) external;
    function setBridgeData(bytes memory _bridgeData) external;
    function setBridgeProxy(address _bridgeProxy) external;
    function setLimits(address _bridge, uint256 _mintingLimit, uint256 _burningLimit) external;
    function startEmissions() external;
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
    function symbol() external view returns (string memory);
    function totalEmissionsMinted() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
    function unpause() external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "defaultAdmin",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "syndFoundationAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "emissionsManager",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "pauser",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "BRIDGE_LIMIT_DURATION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "BRIDGE_MANAGER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "CLOCK_MODE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DEFAULT_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DOMAIN_SEPARATOR",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSIONS_MANAGER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSIONS_SUPPLY",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EPOCH_DURATION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "INITIAL_MINT_SUPPLY",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "PAUSER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "TOTAL_EPOCHS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "TOTAL_SUPPLY",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "allowance",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "approve",
    "inputs": [
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "authorizedBridges",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "balanceOf",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeData",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeLimits",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "mintingMaxLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "mintingCurrentLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "burningMaxLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "burningCurrentLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "lastUpdate",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeProxy",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "burn",
    "inputs": [
      {
        "name": "_user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "burningCurrentLimitOf",
    "inputs": [
      {
        "name": "_bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "burningMaxLimitOf",
    "inputs": [
      {
        "name": "_bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "checkpoints",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "pos",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct Checkpoints.Checkpoint208",
        "components": [
          {
            "name": "_key",
            "type": "uint48",
            "internalType": "uint48"
          },
          {
            "name": "_value",
            "type": "uint208",
            "internalType": "uint208"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "clock",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint48",
        "internalType": "uint48"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "currentEpoch",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "decimals",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "uint8"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "delegate",
    "inputs": [
      {
        "name": "delegatee",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "delegateBySig",
    "inputs": [
      {
        "name": "delegatee",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "nonce",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "expiry",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "v",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "r",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "delegates",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "eip712Domain",
    "inputs": [],
    "outputs": [
      {
        "name": "fields",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "version",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "verifyingContract",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "salt",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "extensions",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionSchedule",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionsActive",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionsEnded",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionsStartTime",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionsStarted",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBridgeConfiguration",
    "inputs": [],
    "outputs": [
      {
        "name": "proxy",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBridgeInfo",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "authorized",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "mintingMax",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "mintingCurrent",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "burningMax",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "burningCurrent",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBridgeUtilization",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "mintingUtilization",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "burningUtilization",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCurrentEpochInfo",
    "inputs": [],
    "outputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nextEmissionTime",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nextEmissionAmount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "canMintEmission",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCurrentTotalSupply",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getEmissionSchedule",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256[48]",
        "internalType": "uint256[48]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPastTotalSupply",
    "inputs": [
      {
        "name": "timepoint",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPastVotes",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "timepoint",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPastVotingPower",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "blockNumber",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRemainingEmissions",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleAdmin",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getVotes",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getVotingPower",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "grantRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "hasRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isBridge",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "mint",
    "inputs": [
      {
        "name": "_user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "mintEmission",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "mintingCurrentLimitOf",
    "inputs": [
      {
        "name": "_bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "mintingMaxLimitOf",
    "inputs": [
      {
        "name": "_bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "name",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "nonces",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "numCheckpoints",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "pauseEmissions",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "paused",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "permit",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "deadline",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "v",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "r",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "callerConfirmation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "resumeEmissions",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBridgeData",
    "inputs": [
      {
        "name": "_bridgeData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBridgeProxy",
    "inputs": [
      {
        "name": "_bridgeProxy",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setLimits",
    "inputs": [
      {
        "name": "_bridge",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_mintingLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "_burningLimit",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "startEmissions",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "symbol",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "totalEmissionsMinted",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "totalSupply",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "transfer",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferFrom",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "unpause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "Approval",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "spender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeAuthorized",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeDataUpdated",
    "inputs": [
      {
        "name": "oldData",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      },
      {
        "name": "newData",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeDeauthorized",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeLimitsSet",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "mintingLimit",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "burningLimit",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeProxyUpdated",
    "inputs": [
      {
        "name": "oldProxy",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newProxy",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DelegateChanged",
    "inputs": [
      {
        "name": "delegator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "fromDelegate",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "toDelegate",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DelegateVotesChanged",
    "inputs": [
      {
        "name": "delegate",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "previousVotes",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "newVotes",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EIP712DomainChanged",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EmissionMinted",
    "inputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "destination",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EmissionsPaused",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EmissionsResumed",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EmissionsStarted",
    "inputs": [
      {
        "name": "startTime",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Paused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleAdminChanged",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "previousAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleGranted",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleRevoked",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Transfer",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Unpaused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AccessControlBadConfirmation",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AccessControlUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "neededRole",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "AllEmissionsCompleted",
    "inputs": []
  },
  {
    "type": "error",
    "name": "BridgeNotAuthorized",
    "inputs": []
  },
  {
    "type": "error",
    "name": "BridgeNotConfigured",
    "inputs": []
  },
  {
    "type": "error",
    "name": "CheckpointUnorderedInsertion",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignature",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureLength",
    "inputs": [
      {
        "name": "length",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureS",
    "inputs": [
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20ExceededSafeSupply",
    "inputs": [
      {
        "name": "increasedSupply",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "cap",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InsufficientAllowance",
    "inputs": [
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "allowance",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "needed",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InsufficientBalance",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "balance",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "needed",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidApprover",
    "inputs": [
      {
        "name": "approver",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidReceiver",
    "inputs": [
      {
        "name": "receiver",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidSender",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidSpender",
    "inputs": [
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC2612ExpiredSignature",
    "inputs": [
      {
        "name": "deadline",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC2612InvalidSigner",
    "inputs": [
      {
        "name": "signer",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC5805FutureLookup",
    "inputs": [
      {
        "name": "timepoint",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "clock",
        "type": "uint48",
        "internalType": "uint48"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC6372InconsistentClock",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmissionsAlreadyStarted",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmissionsNotActive",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmissionsNotStarted",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EnforcedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EpochAlreadyMinted",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ExceedsEmissionsSupply",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ExpectedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientLimit",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidAccountNonce",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "currentNonce",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidEpoch",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidShortString",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SafeCastOverflowedUintDowncast",
    "inputs": [
      {
        "name": "bits",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "StringTooLong",
    "inputs": [
      {
        "name": "str",
        "type": "string",
        "internalType": "string"
      }
    ]
  },
  {
    "type": "error",
    "name": "VotesExpiredSignature",
    "inputs": [
      {
        "name": "expiry",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ZeroAddress",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroAmount",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroGasLimit",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod SyndicateToken {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x610160604052346100765761001e610015610163565b9291909161035d565b61002661007b565b616f9461208d823960805181614bcc015260a05181614c03015260c05181614b93015260e05181615793015261010051816157b801526101205181615345015261014051816153850152616f9490f35b610081565b60405190565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b906100ad90610085565b810190811060018060401b038211176100c557604052565b61008f565b906100dd6100d661007b565b92836100a3565b565b5f80fd5b60018060a01b031690565b6100f7906100e3565b90565b610103816100ee565b0361010a57565b5f80fd5b9050519061011b826100fa565b565b60808183031261015e57610133825f830161010e565b9261015b610144846020850161010e565b93610152816040860161010e565b9360600161010e565b90565b6100df565b61018161902180380380610176816100ca565b92833981019061011d565b90919293565b60018060401b0381116101a35761019f602091610085565b0190565b61008f565b906101ba6101b583610187565b6100ca565b918252565b5f7f53796e6469636174650000000000000000000000000000000000000000000000910152565b6101f060096101a8565b906101fd602083016101bf565b565b6102076101e6565b90565b5f7f53594e4400000000000000000000000000000000000000000000000000000000910152565b61023b60046101a8565b906102486020830161020a565b565b610252610231565b90565b90565b90565b61026f61026a61027492610255565b610258565b6100e3565b90565b6102809061025b565b90565b5f0190565b90565b5f1b90565b6102a461029f6102a992610255565b61028b565b610288565b90565b6102b55f610290565b90565b7f6b9725f740f94b91b78060a1b17d1774656d381421a529ec98cdb013f4d9c25e90565b7fcce296b040332a080e6df13515a3ec2869e21cd20f7344af0987ddb938d8bd2190565b7f65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a90565b90565b90565b61033e61033961034392610324565b610258565b610327565b90565b61035a6a4a723dc6b40b8a9a00000061032a565b90565b90919261037961036b6101ff565b61037361024a565b90610516565b8161039461038e6103895f610277565b6100ee565b916100ee565b146104b057826103b46103ae6103a95f610277565b6100ee565b916100ee565b1461049457836103d46103ce6103c95f610277565b6100ee565b916100ee565b1461047857806103f46103ee6103e95f610277565b6100ee565b916100ee565b1461045c5761043561044392610427610452966104196104126102ac565b84906109b9565b506104226102b8565b6109b9565b506104306102dc565b6109b9565b5061043e610300565b6109b9565b5061044c610346565b90610a87565b61045a610d8f565b565b5f63d92e233d60e01b81528061047460048201610283565b0390fd5b5f63d92e233d60e01b81528061049060048201610283565b0390fd5b5f63d92e233d60e01b8152806104ac60048201610283565b0390fd5b5f63d92e233d60e01b8152806104c860048201610283565b0390fd5b906104d860ff9161028b565b9181191691161790565b151590565b6104f0906104e2565b90565b90565b9061050b610506610512926104e7565b6104f3565b82546104cc565b9055565b906105209161052d565b61052b5f600e6104f6565b565b6105399181909161053b565b565b906105469291610548565b565b906105539291610555565b565b906105609291610562565b565b9061056d929161056f565b565b9061057a929161057c565b565b9061058792916105d4565b565b5f7f3100000000000000000000000000000000000000000000000000000000000000910152565b6105ba60016101a8565b906105c760208301610589565b565b6105d16105b0565b90565b906105e892916105e26105c9565b906105ea565b565b906105f693929161063c565b565b90565b90565b60200190565b5190565b61061c610617610621926100e3565b610258565b6100e3565b90565b61062d90610608565b90565b61063990610624565b90565b61064d61069d9461068293946106d1565b6106618161065b60066105f8565b90610fb9565b610120526106798361067360076105f8565b90610fb9565b610140526105fb565b61069461068e82610604565b916105fe565b2060e0526105fb565b6106af6106a982610604565b916105fe565b20610100524660a0526106c06110be565b6080526106cc30610630565b60c052565b906106db916106dd565b565b906106e7916106e9565b565b906106f391610959565b565b634e487b7160e01b5f525f60045260245ffd5b5190565b634e487b7160e01b5f52602260045260245ffd5b9060016002830492168015610740575b602083101461073b57565b61070c565b91607f1691610730565b5f5260205f2090565b601f602091010490565b1b90565b9190600861077c9102916107765f198461075d565b9261075d565b9181191691161790565b61079a61079561079f92610327565b610258565b610327565b90565b90565b91906107bb6107b66107c393610786565b6107a2565b908354610761565b9055565b5f90565b6107dd916107d76107c7565b916107a5565b565b5b8181106107eb575050565b806107f85f6001936107cb565b016107e0565b9190601f811161080e575b505050565b61081a61083f9361074a565b90602061082684610753565b83019310610847575b61083890610753565b01906107df565b5f8080610809565b91506108388192905061082f565b1c90565b90610869905f1990600802610855565b191690565b8161087891610859565b906002021790565b9061088a81610708565b9060018060401b038211610948576108ac826108a68554610720565b856107fe565b602090601f83116001146108e0579180916108cf935f926108d4575b505061086e565b90555b565b90915001515f806108c8565b601f198316916108ef8561074a565b925f5b81811061093057509160029391856001969410610916575b505050020190556108d2565b610926910151601f841690610859565b90555f808061090a565b919360206001819287870151815501950192016108f2565b61008f565b9061095791610880565b565b9061096861096f92600361094d565b600461094d565b565b5f90565b61097e90610288565b90565b9061098b90610975565b5f5260205260405f2090565b6109a090610624565b90565b906109ad90610997565b5f5260205260405f2090565b6109c1610971565b506109d66109d082849061115b565b156104e2565b5f14610a5f576109fe60016109f95f6109f160058690610981565b0185906109a3565b6104f6565b90610a07611189565b90610a44610a3e610a387f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d95610975565b92610997565b92610997565b92610a4d61007b565b80610a5781610283565b0390a4600190565b50505f90565b610a6e906100ee565b9052565b9190610a85905f60208501940190610a65565b565b80610aa2610a9c610a975f610277565b6100ee565b916100ee565b14610abe57610abc91610ab45f610277565b919091611196565b565b610ae1610aca5f610277565b5f91829163ec442f0560e01b835260048301610a72565b0390fd5b60018060401b038111610af85760200290565b61008f565b610b09610b0e91610ae5565b6100ca565b90565b90565b610b28610b23610b2d92610b11565b610258565b610327565b90565b90610b3a90610327565b9052565b90565b610b55610b50610b5a92610b3e565b610258565b610327565b90565b90565b610b74610b6f610b7992610b5d565b610258565b610327565b90565b90565b610b93610b8e610b9892610b7c565b610258565b610327565b90565b90565b610bb2610bad610bb792610b9b565b610258565b610327565b90565b90565b610bd1610bcc610bd692610bba565b610258565b610327565b90565b90565b610bf0610beb610bf592610bd9565b610258565b610327565b90565b90565b610c0f610c0a610c1492610bf8565b610258565b610327565b90565b610c2b610c26610c3092610255565b610258565b610327565b90565b6001610c3f9101610327565b90565b90565b610c59610c54610c5e92610c42565b610258565b610327565b90565b90565b610c78610c73610c7d92610c61565b610258565b610327565b90565b634e487b7160e01b5f52601160045260245ffd5b610ca3610ca991939293610327565b92610327565b91610cb5838202610327565b928184041490151715610cc457565b610c80565b610cd8610cde91939293610327565b92610327565b8201809211610ce957565b610c80565b90565b610d05610d00610d0a92610cee565b610258565b610327565b90565b610d176030610cf1565b90565b634e487b7160e01b5f52603260045260245ffd5b50600890565b90610d3e82610d2e565b811015610d4c576020020190565b610d1a565b610d5b9051610327565b90565b50603090565b90565b610d7081610d5e565b821015610d8a57610d82600191610d64565b910201905f90565b610d1a565b610d996008610afd565b610db7610daf698f956f697aa4923c0000610b14565b5f8301610b30565b610dd6610dcd695626760c1662be240000610b41565b60208301610b30565b610df5610dec6933b0b000fec593900000610b60565b60408301610b30565b610e14610e0b691f039ccd65a9bef00000610b7f565b60608301610b30565b610e33610e2a69129bc47b3cff72900000610b9e565b60808301610b30565b610e52610e49690b2a483d6dadee180000610bbd565b60a08301610b30565b610e71610e686906b2efd13a962a6c0000610bdc565b60c08301610b30565b610e90610e87690404f64a565a19740000610bfb565b60e08301610b30565b610e995f610c17565b915b82610eaf610ea96008610c45565b91610327565b1015610f6557610ebe5f610c17565b5b80610ed3610ecd6006610c64565b91610327565b1015610f5457610f2190610efb610ef486610eee6006610c64565b90610c94565b8290610cc9565b80610f15610f0f610f0a610d0d565b610327565b91610327565b10610f26575b50610c33565b610ebf565b610f4e90610f48610f40610f3b888a90610d34565b610d51565b91600f610d67565b906107a5565b5f610f1b565b5091610f5f90610c33565b91610e9b565b915050565b5f90565b90565b610f85610f80610f8a92610f6e565b610258565b610327565b90565b90565b610fa4610f9f610fa992610f8d565b61028b565b610288565b90565b610fb660ff610f90565b90565b90610fc2610f6a565b50610fd4610fcf836105fb565b610604565b610fe7610fe16020610f71565b91610327565b105f14610ffb5750610ff890611295565b90565b5f61100961100f93926111a5565b0161094d565b61101f61101a610fac565b610975565b90565b5f90565b7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f90565b6110549051610288565b90565b61106090610288565b9052565b61106d90610327565b9052565b909594926110bc946110ab6110b5926110a160809661109760a088019c5f890190611057565b6020870190611057565b6040850190611057565b6060830190611064565b0190610a65565b565b6110c6611022565b506110cf611026565b6111196110dc60e061104a565b9161110a6110eb61010061104a565b466110f530610630565b916110fe61007b565b96879560208701611071565b602082018103825203826100a3565b61112b61112582610604565b916105fe565b2090565b5f1c90565b60ff1690565b61114661114b9161112f565b611134565b90565b611158905461113a565b90565b611182915f61117761117d9361116f610971565b506005610981565b016109a3565b61114e565b90565b5f90565b611191611185565b503390565b916111a392919091611342565b565b90565b90565b6111bf6111ba6111c4926111a8565b610258565b610327565b90565b60209181520190565b90825f9392825e0152565b6111fa611203602093611208936111f181610708565b938480936111c7565b958691016111d0565b610085565b0190565b6112219160208201915f8184039101526111db565b90565b61123e61123961123383610604565b926105fe565b61104a565b906020811061124c575b5090565b61125e905f199060200360080261075d565b165f611248565b6112716112769161112f565b610786565b90565b61128d61128861129292610327565b61028b565b610288565b90565b61129d610f6a565b506112a7816105fb565b906112b182610604565b6112c46112be601f6111ab565b91610327565b116112f957506112f1816112eb6112e56112e06112f695611224565b611265565b91610604565b17611279565b610975565b90565b61131b9061130561007b565b91829163305a27a960e01b83526004830161120c565b0390fd5b91602061134092949361133960408201965f830190611064565b0190611064565b565b9291611350848383916114a5565b8361136b6113656113605f610277565b6100ee565b916100ee565b14611380575b61137e9293919091611672565b565b611388611614565b93611391611651565b94806113a561139f88610327565b91610327565b116113b257509350611371565b85906113ce5f928392630e58ae9360e11b84526004840161131f565b0390fd5b906113dc90610997565b5f5260205260405f2090565b90565b6113f76113fc9161112f565b6113e8565b90565b61140990546113eb565b90565b60409061143561143c949695939661142b60608401985f850190610a65565b6020830190611064565b0190611064565b565b906114499103610327565b90565b906114585f199161028b565b9181191691161790565b9061147761147261147e92610786565b6107a2565b825461144c565b9055565b9061148d9101610327565b90565b91906114a3905f60208501940190611064565b565b919091806114c36114bd6114b85f610277565b6100ee565b916100ee565b145f146115a4576114e76114e0836114db60026113ff565b610cc9565b6002611462565b5b826115036114fd6114f85f610277565b6100ee565b916100ee565b145f14611578576115276115208361151b60026113ff565b61143e565b6002611462565b5b91909161157361156161155b7fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef93610997565b93610997565b9361156a61007b565b91829182611490565b0390a3565b61159f8261159961158a5f87906113d2565b91611594836113ff565b611482565b90611462565b611528565b6115b76115b25f83906113d2565b6113ff565b806115ca6115c485610327565b91610327565b106115f2576115dd6115ed91849061143e565b6115e85f84906113d2565b611462565b6114e8565b906116109091925f93849363391434e360e21b85526004850161140c565b0390fd5b61161c6107c7565b5061162760026113ff565b90565b60018060d01b031690565b61164961164461164e9261162a565b610258565b610327565b90565b6116596107c7565b5061166960018060d01b03611635565b90565b90565b90565b916116ca6116c46116d1948061169861169261168d5f610277565b6100ee565b916100ee565b14611702575b846116b96116b36116ae5f610277565b6100ee565b916100ee565b146116d3575b6118fa565b926118fa565b909161192f565b565b6116fb600b60026116f56116ef6116e9896117e4565b9361166c565b9161166f565b90611837565b50506116bf565b61172a600b600161172461171e611718896117e4565b9361166c565b9161166f565b90611837565b505061169e565b5f90565b6117416117479161162a565b9161162a565b019060018060d01b03821161175857565b610c80565b906117709161176a611731565b50611735565b90565b90565b60ff1690565b61179061178b61179592611773565b610258565b611776565b90565b6117a19061177c565b9052565b9160206117c69294936117bf60408201965f830190611798565b0190611064565b565b6117dc6117d76117e192610327565b610258565b61162a565b90565b6117ec611731565b508061180661180060018060d01b03611635565b91610327565b1161181757611814906117c8565b90565b60d06118335f9283926306dfcc6560e41b8452600484016117a5565b0390fd5b9061186d6118739392611848611731565b50611851611731565b50809361186661185f611ae1565b9492611b8e565b909161205d565b91611c03565b91909190565b61188561188b9161162a565b9161162a565b90039060018060d01b03821161189d57565b610c80565b906118b5916118af611731565b50611879565b90565b906118c290610997565b5f5260205260405f2090565b60018060a01b031690565b6118e56118ea9161112f565b6118ce565b90565b6118f790546118d9565b90565b61191161191691611909611185565b5060096118b8565b6118ed565b90565b9061192390610997565b5f5260205260405f2090565b9190918061194561193f856100ee565b916100ee565b141580611ac3575b611957575b505050565b8061197261196c6119675f610277565b6100ee565b916100ee565b03611a33575b508161199461198e6119895f610277565b6100ee565b916100ee565b036119a0575b80611952565b6119e76119da6119e1926119b6600a8690611919565b906119d46119ce6119c86001936117e4565b9361166c565b9161166f565b90611837565b9290611635565b91611635565b919091611a147fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a72492610997565b92611a29611a2061007b565b9283928361131f565b0390a25f8061199a565b611a72611a78611a6b611a48600a8590611919565b6002611a65611a5f611a59896117e4565b9361166c565b9161166f565b90611837565b9290611635565b91611635565b919091611aa57fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a72492610997565b92611aba611ab161007b565b9283928361131f565b0390a25f611978565b5081611ad7611ad15f610c17565b91610327565b1161194d565b5f90565b611ae9611add565b50611af2611c32565b90565b5490565b90565b611b10611b0b611b1592611af9565b610258565b610327565b90565b611b27611b2d91939293610327565b92610327565b8203918211611b3857565b610c80565b90565b60301c90565b60018060d01b031690565b611b5d611b6291611b40565b611b46565b90565b611b6f9054611b51565b90565b611b86611b81611b8b92610255565b610258565b61162a565b90565b611b96611731565b50611ba25f8201611af5565b80611bb5611baf5f610c17565b91610327565b145f14611bcb575050611bc75f611b72565b5b90565b611bf85f91611bf3611bed84611bfe960192611be76001611afc565b90611b18565b91611b3d565b611c47565b01611b65565b611bc8565b91611c275f611c2c94611c14611731565b50611c1d611731565b5001929192611b3d565b611e38565b91909190565b611c3a611add565b50611c4443611ff6565b90565b5f5260205f200190565b5490565b611c5f60406100ca565b90565b65ffffffffffff1690565b90611c7790611c62565b9052565b90611c859061162a565b9052565b5f5260205f2090565b611c9b81611c51565b821015611cb557611cad600191611c89565b910201905f90565b610d1a565b611cc49051611c62565b90565b90611cd865ffffffffffff9161028b565b9181191691161790565b611cf6611cf1611cfb92611c62565b610258565b611c62565b90565b90565b90611d16611d11611d1d92611ce2565b611cfe565b8254611cc7565b9055565b611d2b905161162a565b90565b60301b90565b90611d4665ffffffffffff1991611d2e565b9181191691161790565b611d64611d5f611d699261162a565b610258565b61162a565b90565b90565b90611d84611d7f611d8b92611d50565b611d6c565b8254611d34565b9055565b90611db960205f611dbf94611db1828201611dab848801611cba565b90611d01565b019201611d21565b90611d6f565b565b9190611dd257611dd091611d8f565b565b6106f5565b9081549168010000000000000000831015611e075782611dff916001611e0595018155611c92565b90611dc1565b565b61008f565b65ffffffffffff1690565b611e23611e289161112f565b611e0c565b90565b611e359054611e17565b90565b90929192611e44611731565b50611e4d611731565b50611e5782611c51565b80611e6a611e645f610c17565b91610327565b115f14611f3a57611e9090611e8a8491611e846001611afc565b90611b18565b90611c47565b90611e9c5f8301611e2b565b92611ea85f8401611b65565b9380611ebc611eb685611c62565b91611c62565b11611f1e57611ed3611ecd84611c62565b91611c62565b145f14611eee575050611ee9905f859101611d6f565b5b9190565b611f199250611f1486611f0b611f02611c55565b945f8601611c6d565b60208401611c7b565b611dd7565b611eea565b5f632520601d60e01b815280611f3660048201610283565b0390fd5b50611f6591611f6085611f57611f4e611c55565b945f8601611c6d565b60208401611c7b565b611dd7565b611f6e5f611b72565b9190565b611f86611f81611f8b92611c62565b610258565b610327565b90565b611fa2611f9d611fa792610cee565b610258565b611776565b90565b611fb390611f8e565b9052565b916020611fd8929493611fd160408201965f830190611faa565b0190611064565b565b611fee611fe9611ff392610327565b610258565b611c62565b90565b611ffe611add565b508061201861201265ffffffffffff611f72565b91610327565b116120295761202690611fda565b90565b60306120455f9283926306dfcc6560e41b845260048401611fb7565b0390fd5b634e487b7160e01b5f52605160045260245ffd5b9190918060011461207c5760020361204957612078916118a2565b905b565b506120869161175d565b9061207a56fe60806040526004361015610013575b612382565b61001d5f356104dc565b806301ffc9a7146104d757806306fdde03146104d257806307a1d5fa146104cd578063095ea7b3146104c85780630c05f82c146104c357806313beaa5b146104be57806318160ddd146104b95780631b02f845146104b457806322a97d9c146104af57806323b872dd146104aa57806323e460d2146104a55780632481bb5c146104a0578063248a9ca31461049b578063284e1333146104965780632f2ff15d14610491578063313ce5671461048c578063334d0bbd14610487578063359b76fe146104825780633644e5151461047d57806336568abe146104785780633a46b1a8146104735780633f4ba83a1461046e57806340c10f191461046957806344e181aa1461046457806348b0daa61461045f5780634bdd36ce1461045a5780634bf5d7e914610455578063587cde1e146104505780635adf00211461044b5780635c19a95c146104465780635c975abb146104415780635f15c3c91461043c578063651fd268146104375780636c33bced146104325780636cf016251461042d5780636fc063be146104285780636fcfff451461042357806370a082311461041e578063726600ce1461041957806376671808146104145780637c790cab1461040f5780637ecebe001461040a5780638456cb591461040557806384b0196e146104005780638e539e8c146103fb578063902d55a5146103f657806391d14854146103f157806391ddadf4146103ec57806395d89b41146103e757806399127d9b146103e2578063998955d3146103dd5780639ab24eb0146103d85780639b7ef64b146103d35780639dc29fac146103ce578063a08d5654146103c9578063a217fddf146103c4578063a3d4485b146103bf578063a4d7e31d146103ba578063a571e184146103b5578063a70b9f0c146103b0578063a9059cbb146103ab578063af2aa63b146103a6578063b0ca253e146103a1578063babc394f1461039c578063bb4d443614610397578063c02ae75414610392578063c1eb71371461038d578063c3cda52014610388578063d505accf14610383578063d547741f1461037e578063dd62ed3e14610379578063e3abdfcb14610374578063e63ab1e91461036f578063f1127ed81461036a578063f508e19d146103655763f75e85120361000e5761234d565b6122e9565b6122a4565b6121c1565b61215d565b6120f8565b612097565b61205d565b611fb3565b611ef7565b611ec2565b611e8d565b611e54565b611de0565b611dab565b611d00565b611ccb565b611c5f565b611c2a565b611bf5565b611b80565b611b11565b611aa3565b611a6e565b6119f8565b6119c3565b61198e565b611920565b6118eb565b611888565b611853565b6117dd565b6117a1565b61165c565b611627565b6115ee565b61156c565b611528565b6114f3565b6114be565b61145e565b6113fa565b611386565b611351565b61131c565b6112b0565b61127d565b611248565b611213565b6111c9565b611194565b61115f565b611117565b610fd7565b610fa4565b610f6e565b610f3a565b610f05565b610ed2565b610e9d565b610db0565b610d54565b610cf4565b610cbf565b610c24565b610a54565b6109fb565b61098c565b61091a565b6108e5565b6108b1565b6107f6565b610780565b6106d4565b610617565b610568565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b63ffffffff60e01b1690565b610509816104f4565b0361051057565b5f80fd5b9050359061052182610500565b565b9060208282031261053c57610539915f01610514565b90565b6104ec565b151590565b61054f90610541565b9052565b9190610566905f60208501940190610546565b565b346105985761059461058361057e366004610523565b61241f565b61058b6104e2565b91829182610553565b0390f35b6104e8565b5f9103126105a757565b6104ec565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b6105ed6105f66020936105fb936105e4816105ac565b938480936105b0565b958691016105b9565b6105c4565b0190565b6106149160208201915f8184039101526105ce565b90565b346106475761062736600461059d565b61064361063261253d565b61063a6104e2565b918291826105ff565b0390f35b6104e8565b60018060a01b031690565b6106609061064c565b90565b61066c90610657565b9052565b5190565b60209181520190565b61069c6106a56020936106aa9361069381610670565b93848093610674565b958691016105b9565b6105c4565b0190565b916106d1926106c460408201935f830190610663565b602081840391015261067d565b90565b34610705576106e436600461059d565b6106ec612589565b906107016106f86104e2565b928392836106ae565b0390f35b6104e8565b61071381610657565b0361071a57565b5f80fd5b9050359061072b8261070a565b565b90565b6107398161072d565b0361074057565b5f80fd5b9050359061075182610730565b565b919060408382031261077b578061076f610778925f860161071e565b93602001610744565b90565b6104ec565b346107b1576107ad61079c610796366004610753565b906125b3565b6107a46104e2565b91829182610553565b0390f35b6104e8565b906020828203126107cf576107cc915f0161071e565b90565b6104ec565b6107dd9061072d565b9052565b91906107f4905f602085019401906107d4565b565b346108265761082261081161080c3660046107b6565b6125d9565b6108196104e2565b918291826107e1565b0390f35b6104e8565b5f80fd5b5f80fd5b5f80fd5b909182601f830112156108715781359167ffffffffffffffff831161086c57602001926001830284011161086757565b610833565b61082f565b61082b565b906020828203126108a7575f82013567ffffffffffffffff81116108a25761089e9201610837565b9091565b6104f0565b6104ec565b5f0190565b346108e0576108ca6108c4366004610876565b906128ca565b6108d26104e2565b806108dc816108ac565b0390f35b6104e8565b34610915576108f536600461059d565b6109116109006128d6565b6109086104e2565b918291826107e1565b0390f35b6104e8565b346109485761092a36600461059d565b610932612a9a565b61093a6104e2565b80610944816108ac565b0390f35b6104e8565b1c90565b60ff1690565b61096790600861096c930261094d565b610951565b90565b9061097a9154610957565b90565b610989603f5f9061096f565b90565b346109bc5761099c36600461059d565b6109b86109a761097d565b6109af6104e2565b91829182610553565b0390f35b6104e8565b90916060828403126109f6576109f36109dc845f850161071e565b936109ea816020860161071e565b93604001610744565b90565b6104ec565b34610a2c57610a28610a17610a113660046109c1565b91612aa4565b610a1f6104e2565b91829182610553565b0390f35b6104e8565b916020610a52929493610a4b60408201965f8301906107d4565b01906107d4565b565b34610a8557610a6c610a673660046107b6565b612bd5565b90610a81610a786104e2565b92839283610a31565b0390f35b6104e8565b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52602260045260245ffd5b9060016002830492168015610ad1575b6020831014610acc57565b610a9d565b91607f1691610ac1565b60209181520190565b5f5260205f2090565b905f9291805490610b07610b0083610ab1565b8094610adb565b916001811690815f14610b5e5750600114610b22575b505050565b610b2f9192939450610ae4565b915f925b818410610b4657505001905f8080610b1d565b60018160209295939554848601520191019290610b33565b92949550505060ff19168252151560200201905f8080610b1d565b90610b8391610aed565b90565b634e487b7160e01b5f52604160045260245ffd5b90610ba4906105c4565b810190811067ffffffffffffffff821117610bbe57604052565b610b86565b90610be3610bdc92610bd36104e2565b93848092610b79565b0383610b9a565b565b905f10610bf857610bf590610bc3565b90565b610a8a565b610c0960445f90610be5565b90565b610c219160208201915f81840391015261067d565b90565b34610c5457610c3436600461059d565b610c50610c3f610bfd565b610c476104e2565b91829182610c0c565b0390f35b6104e8565b90565b610c6581610c59565b03610c6c57565b5f80fd5b90503590610c7d82610c5c565b565b90602082820312610c9857610c95915f01610c70565b90565b6104ec565b610ca690610c59565b9052565b9190610cbd905f60208501940190610c9d565b565b34610cef57610ceb610cda610cd5366004610c7f565b612df6565b610ce26104e2565b91829182610caa565b0390f35b6104e8565b34610d2257610d0436600461059d565b610d0c6132cd565b610d146104e2565b80610d1e816108ac565b0390f35b6104e8565b9190604083820312610d4f5780610d43610d4c925f8601610c70565b9360200161071e565b90565b6104ec565b34610d8357610d6d610d67366004610d27565b90613301565b610d756104e2565b80610d7f816108ac565b0390f35b6104e8565b60ff1690565b610d9790610d88565b9052565b9190610dae905f60208501940190610d8e565b565b34610de057610dc036600461059d565b610ddc610dcb613330565b610dd36104e2565b91829182610d9b565b0390f35b6104e8565b90602082820312610dfe57610dfb915f01610744565b90565b6104ec565b634e487b7160e01b5f52603260045260245ffd5b50603090565b90565b610e2981610e17565b821015610e4357610e3b600191610e1d565b910201905f90565b610e03565b90565b610e5b906008610e60930261094d565b610e48565b90565b90610e6e9154610e4b565b90565b600f610e7c81610e17565b821015610e9957610e9691610e9091610e20565b90610e63565b90565b5f80fd5b34610ecd57610ec9610eb8610eb3366004610de5565b610e71565b610ec06104e2565b918291826107e1565b0390f35b6104e8565b34610f0057610ee236600461059d565b610eea6133e1565b610ef26104e2565b80610efc816108ac565b0390f35b6104e8565b34610f3557610f1536600461059d565b610f31610f206133eb565b610f286104e2565b91829182610caa565b0390f35b6104e8565b34610f6957610f53610f4d366004610d27565b906133ff565b610f5b6104e2565b80610f65816108ac565b0390f35b6104e8565b34610f9f57610f9b610f8a610f84366004610753565b9061347c565b610f926104e2565b918291826107e1565b0390f35b6104e8565b34610fd257610fb436600461059d565b610fbc6134da565b610fc46104e2565b80610fce816108ac565b0390f35b6104e8565b3461100657610ff0610fea366004610753565b906134e4565b610ff86104e2565b80611002816108ac565b0390f35b6104e8565b90565b61102261101d6110279261064c565b61100b565b61064c565b90565b6110339061100e565b90565b61103f9061102a565b90565b9061104c90611036565b5f5260205260405f2090565b5f1c90565b61106961106e91611058565b610e48565b90565b61107b905461105d565b90565b61108990600c611042565b6110945f8201611071565b916110a160018301611071565b916110ae60028201611071565b916110c760046110c060038501611071565b9301611071565b90565b909594926111159461110461110e926110fa6080966110f060a088019c5f8901906107d4565b60208701906107d4565b60408501906107d4565b60608301906107d4565b01906107d4565b565b3461114b5761114761113261112d3660046107b6565b61107e565b9161113e9593956104e2565b958695866110ca565b0390f35b6104e8565b61115c60405f90610e63565b90565b3461118f5761116f36600461059d565b61118b61117a611150565b6111826104e2565b918291826107e1565b0390f35b6104e8565b346111c4576111a436600461059d565b6111c06111af61361b565b6111b76104e2565b918291826107e1565b0390f35b6104e8565b346111f9576111d936600461059d565b6111f56111e46136dc565b6111ec6104e2565b918291826105ff565b0390f35b6104e8565b9190611211905f60208501940190610663565b565b346112435761123f61122e6112293660046107b6565b613748565b6112366104e2565b918291826111fe565b0390f35b6104e8565b346112785761125836600461059d565b611274611263613767565b61126b6104e2565b91829182610553565b0390f35b6104e8565b346112ab576112956112903660046107b6565b613790565b61129d6104e2565b806112a7816108ac565b0390f35b6104e8565b346112e0576112c036600461059d565b6112dc6112cb6137a3565b6112d36104e2565b91829182610553565b0390f35b6104e8565b90565b6112fc6112f7611301926112e5565b61100b565b61072d565b90565b61130e60306112e8565b90565b611319611304565b90565b3461134c5761132c36600461059d565b611348611337611311565b61133f6104e2565b918291826107e1565b0390f35b6104e8565b346113815761137d61136c6113673660046107b6565b6137b9565b6113746104e2565b918291826107e1565b0390f35b6104e8565b346113b45761139636600461059d565b61139e613870565b6113a66104e2565b806113b0816108ac565b0390f35b6104e8565b90565b6113d06113cb6113d5926113b9565b61100b565b61072d565b90565b6113ec6a084595161401484a0000006113bc565b90565b6113f76113d8565b90565b3461142a5761140a36600461059d565b6114266114156113ef565b61141d6104e2565b918291826107e1565b0390f35b6104e8565b9061143990611036565b5f5260205260405f2090565b61145b90611456600d915f9261142f565b61096f565b90565b3461148e5761148a6114796114743660046107b6565b611445565b6114816104e2565b91829182610553565b0390f35b6104e8565b63ffffffff1690565b6114a590611493565b9052565b91906114bc905f6020850194019061149c565b565b346114ee576114ea6114d96114d43660046107b6565b61387e565b6114e16104e2565b918291826114a9565b0390f35b6104e8565b346115235761151f61150e6115093660046107b6565b6138a9565b6115166104e2565b918291826107e1565b0390f35b6104e8565b346115585761155461154361153e3660046107b6565b6138c7565b61154b6104e2565b91829182610553565b0390f35b6104e8565b61156960415f90610e63565b90565b3461159c5761157c36600461059d565b61159861158761155d565b61158f6104e2565b918291826107e1565b0390f35b6104e8565b909594926115ec946115db6115e5926115d16080966115c760a088019c5f890190610546565b60208701906107d4565b60408501906107d4565b60608301906107d4565b01906107d4565b565b346116225761161e6116096116043660046107b6565b6138e6565b916116159593956104e2565b958695866115a1565b0390f35b6104e8565b346116575761165361164261163d3660046107b6565b613a56565b61164a6104e2565b918291826107e1565b0390f35b6104e8565b3461168a5761166c36600461059d565b611674613a8f565b61167c6104e2565b80611686816108ac565b0390f35b6104e8565b60ff60f81b1690565b6116a19061168f565b9052565b5190565b60209181520190565b60200190565b6116c19061072d565b9052565b906116d2816020936116b8565b0190565b60200190565b906116f96116f36116ec846116a5565b80936116a9565b926116b2565b905f5b8181106117095750505090565b90919261172261171c60019286516116c5565b946116d6565b91019190916116fc565b9395919461177d611772611791956117646117879561179e9c9a61175760e08c01925f8d0190611698565b8a820360208c01526105ce565b9088820360408a01526105ce565b9760608701906107d4565b6080850190610663565b60a0830190610c9d565b60c08184039101526116dc565b90565b346117d8576117b136600461059d565b6117d46117bc613b16565b936117cb9795979391936104e2565b9788978861172c565b0390f35b6104e8565b3461180d576118096117f86117f3366004610de5565b613ba0565b6118006104e2565b918291826107e1565b0390f35b6104e8565b90565b61182961182461182e92611812565b61100b565b61072d565b90565b6118456a52b7d2dcc80cd2e4000000611815565b90565b611850611831565b90565b346118835761186336600461059d565b61187f61186e611848565b6118766104e2565b918291826107e1565b0390f35b6104e8565b346118b9576118b56118a461189e366004610d27565b90613bd1565b6118ac6104e2565b91829182610553565b0390f35b6104e8565b65ffffffffffff1690565b6118d2906118be565b9052565b91906118e9905f602085019401906118c9565b565b3461191b576118fb36600461059d565b611917611906613bff565b61190e6104e2565b918291826118d6565b0390f35b6104e8565b346119505761193036600461059d565b61194c61193b613c13565b6119436104e2565b918291826105ff565b0390f35b6104e8565b90565b61196c61196761197192611955565b61100b565b61072d565b90565b61198062015180611958565b90565b61198b611974565b90565b346119be5761199e36600461059d565b6119ba6119a9611983565b6119b16104e2565b918291826107e1565b0390f35b6104e8565b346119f3576119ef6119de6119d93660046107b6565b613c29565b6119e66104e2565b918291826107e1565b0390f35b6104e8565b34611a2857611a24611a13611a0e3660046107b6565b613c84565b611a1b6104e2565b918291826107e1565b0390f35b6104e8565b90565b611a44611a3f611a4992611a2d565b61100b565b61072d565b90565b611a606a4a723dc6b40b8a9a000000611a30565b90565b611a6b611a4c565b90565b34611a9e57611a7e36600461059d565b611a9a611a89611a63565b611a916104e2565b918291826107e1565b0390f35b6104e8565b34611ad257611abc611ab6366004610753565b90613cb3565b611ac46104e2565b80611ace816108ac565b0390f35b6104e8565b9091606082840312611b0c57611b09611af2845f850161071e565b93611b008160208601610744565b93604001610744565b90565b6104ec565b34611b4057611b2a611b24366004611ad7565b91614064565b611b326104e2565b80611b3c816108ac565b0390f35b6104e8565b90565b5f1b90565b611b61611b5c611b6692611b45565b611b48565b610c59565b90565b611b725f611b4d565b90565b611b7d611b69565b90565b34611bb057611b9036600461059d565b611bac611b9b611b75565b611ba36104e2565b91829182610caa565b0390f35b6104e8565b60018060a01b031690565b611bd0906008611bd5930261094d565b611bb5565b90565b90611be39154611bc0565b90565b611bf260435f90611bd8565b90565b34611c2557611c0536600461059d565b611c21611c10611be6565b611c186104e2565b918291826111fe565b0390f35b6104e8565b34611c5a57611c3a36600461059d565b611c56611c45614071565b611c4d6104e2565b91829182610553565b0390f35b6104e8565b34611c8d57611c77611c723660046107b6565b614198565b611c7f6104e2565b80611c89816108ac565b0390f35b6104e8565b90565b611ca9611ca4611cae92611c92565b61100b565b61072d565b90565b611cbd62278d00611c95565b90565b611cc8611cb1565b90565b34611cfb57611cdb36600461059d565b611cf7611ce6611cc0565b611cee6104e2565b918291826107e1565b0390f35b6104e8565b34611d3157611d2d611d1c611d16366004610753565b906141a3565b611d246104e2565b91829182610553565b0390f35b6104e8565b50603090565b905090565b90565b60200190565b611d66611d60611d5983611d36565b8094611d3c565b91611d41565b5f915b838310611d765750505050565b611d8c611d8660019284516116c5565b92611d44565b92019190611d69565b9190611da9905f6106008501940190611d4a565b565b34611ddb57611dbb36600461059d565b611dd7611dc66142ca565b611dce6104e2565b91829182611d95565b0390f35b6104e8565b34611e1157611e0d611dfc611df6366004610753565b906142e0565b611e046104e2565b918291826107e1565b0390f35b6104e8565b611e4b611e5294611e41606094989795611e37608086019a5f8701906107d4565b60208501906107d4565b60408301906107d4565b0190610546565b565b34611e8857611e6436600461059d565b611e84611e6f614315565b90611e7b9492946104e2565b94859485611e16565b0390f35b6104e8565b34611ebd57611eb9611ea8611ea33660046107b6565b6144ba565b611eb06104e2565b918291826107e1565b0390f35b6104e8565b34611ef257611ed236600461059d565b611eee611edd6144cf565b611ee56104e2565b918291826107e1565b0390f35b6104e8565b34611f2757611f23611f12611f0d3660046107b6565b6144e3565b611f1a6104e2565b918291826107e1565b0390f35b6104e8565b611f3581610d88565b03611f3c57565b5f80fd5b90503590611f4d82611f2c565b565b909160c082840312611fae57611f67835f840161071e565b92611f758160208501610744565b92611f838260408301610744565b92611fab611f948460608501611f40565b93611fa28160808601610c70565b9360a001610c70565b90565b6104ec565b34611fe857611fd2611fc6366004611f4f565b9493909392919261456d565b611fda6104e2565b80611fe4816108ac565b0390f35b6104e8565b60e08183031261205857612003825f830161071e565b92612011836020840161071e565b9261201f8160408501610744565b9261202d8260608301610744565b9261205561203e8460808501611f40565b9361204c8160a08601610c70565b9360c001610c70565b90565b6104ec565b346120925761207c612070366004611fed565b959490949391936146c1565b6120846104e2565b8061208e816108ac565b0390f35b6104e8565b346120c6576120b06120aa366004610d27565b906147df565b6120b86104e2565b806120c2816108ac565b0390f35b6104e8565b91906040838203126120f357806120e76120f0925f860161071e565b9360200161071e565b90565b6104ec565b346121295761212561211461210e3660046120cb565b90614801565b61211c6104e2565b918291826107e1565b0390f35b6104e8565b7f6b9725f740f94b91b78060a1b17d1774656d381421a529ec98cdb013f4d9c25e90565b61215a61212e565b90565b3461218d5761216d36600461059d565b612189612178612152565b6121806104e2565b91829182610caa565b0390f35b6104e8565b7f65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a90565b6121be612192565b90565b346121f1576121d136600461059d565b6121ed6121dc6121b6565b6121e46104e2565b91829182610caa565b0390f35b6104e8565b6121ff81611493565b0361220657565b5f80fd5b90503590612217826121f6565b565b9190604083820312612241578061223561223e925f860161071e565b9360200161220a565b90565b6104ec565b61224f906118be565b9052565b60018060d01b031690565b61226790612253565b9052565b9060208061228d936122835f8201515f860190612246565b015191019061225e565b565b91906122a2905f6040850194019061226b565b565b346122d5576122d16122c06122ba366004612219565b9061486f565b6122c86104e2565b9182918261228f565b0390f35b6104e8565b6122e660425f90610e63565b90565b34612319576122f936600461059d565b6123156123046122da565b61230c6104e2565b918291826107e1565b0390f35b6104e8565b7fcce296b040332a080e6df13515a3ec2869e21cd20f7344af0987ddb938d8bd2190565b61234a61231e565b90565b3461237d5761235d36600461059d565b612379612368612342565b6123706104e2565b91829182610caa565b0390f35b6104e8565b5f80fd5b5f90565b634e487b7160e01b5f52601160045260245ffd5b6123aa6123b091612253565b91612253565b019060018060d01b0382116123c157565b61238a565b906123d9916123d3612386565b5061239e565b90565b6123e86123ee91612253565b91612253565b90039060018060d01b03821161240057565b61238a565b9061241891612412612386565b506123dc565b90565b5f90565b61242761241b565b508061244261243c637965db0b60e01b6104f4565b916104f4565b1490811561244f575b5090565b6124599150614885565b5f61244b565b606090565b60209181520190565b5f5260205f2090565b905f929180549061249061248983610ab1565b8094612464565b916001811690815f146124e757506001146124ab575b505050565b6124b8919293945061246d565b915f925b8184106124cf57505001905f80806124a6565b600181602092959395548486015201910192906124bc565b92949550505060ff19168252151560200201905f80806124a6565b9061250c91612476565b90565b9061252f6125289261251f6104e2565b93848092612502565b0383610b9a565b565b61253a9061250f565b90565b61254561245f565b506125506003612531565b90565b5f90565b606090565b61256861256d91611058565b611bb5565b90565b61257a905461255c565b90565b61258690610bc3565b90565b612591612553565b5061259a612557565b506125a56043612570565b906125b0604461257d565b90565b6125d0916125bf61241b565b506125c86148ab565b9190916148b8565b600190565b5f90565b5f6125f16125f7926125e96125d5565b50600c611042565b01611071565b90565b906126149161260f61260a61231e565b6148c8565b612874565b565b5090565b601f602091010490565b1b90565b9190600861264391029161263d5f1984612624565b92612624565b9181191691161790565b61266161265c6126669261072d565b61100b565b61072d565b90565b90565b919061268261267d61268a9361264d565b612669565b908354612628565b9055565b6126a09161269a6125d5565b9161266c565b565b5b8181106126ae575050565b806126bb5f60019361268e565b016126a3565b9190601f81116126d1575b505050565b6126dd61270293610ae4565b9060206126e98461261a565b8301931061270a575b6126fb9061261a565b01906126a2565b5f80806126cc565b91506126fb819290506126f2565b90612728905f199060080261094d565b191690565b8161273791612718565b906002021790565b9161274a9082612616565b9067ffffffffffffffff82116128095761276e826127688554610ab1565b856126c1565b5f90601f83116001146127a157918091612790935f92612795575b505061272d565b90555b565b90915001355f80612789565b601f198316916127b085610ae4565b925f5b8181106127f1575091600293918560019694106127d7575b50505002019055612793565b6127e7910135601f841690612718565b90555f80806127cb565b919360206001819287870135815501950192016127b3565b610b86565b90612819929161273f565b565b90825f939282370152565b9190612840816128398161284595610674565b809561281b565b6105c4565b0190565b91612863612871949260408501908582035f87015261067d565b926020818503910152612826565b90565b9061287f604461257d565b61288c838390604461280e565b9190916128c57fb9a2088426f03b30a81c06428094fbfa9e2692739b3241af6b9ab1da4b5546be936128bc6104e2565b93849384612849565b0390a1565b906128d4916125fa565b565b6128de6125d5565b506128e96002611071565b90565b6128fc6128f761212e565b6148c8565b6129046129c5565b565b61291a61291561291f92611b45565b61100b565b61072d565b90565b61293661293161293b92611b45565b61100b565b61064c565b90565b61294790612922565b90565b9061295660ff91611b48565b9181191691161790565b61296990610541565b90565b90565b9061298461297f61298b92612960565b61296c565b825461294a565b9055565b9061299b5f1991611b48565b9181191691161790565b906129ba6129b56129c19261264d565b612669565b825461298f565b9055565b6129cf6040611071565b6129e16129db5f612906565b9161072d565b03612a7e576129f06043612570565b612a0a612a046129ff5f61293e565b610657565b91610657565b14612a6257612a1b6001603f61296f565b612a264260406129a5565b42612a5d7f1194b034cfa9ab5807494a1d5c667d8b0e6e97f38888742aa3871a322034116091612a546104e2565b918291826107e1565b0390a1565b5f633b0a48bd60e11b815280612a7a600482016108ac565b0390fd5b5f6338e93dbd60e11b815280612a96600482016108ac565b0390fd5b612aa26128ec565b565b91612ace92612ab161241b565b50612ac6612abd6148ab565b8290849161491c565b9190916149a8565b600190565b612adc9061102a565b90565b5f80fd5b60e01b90565b90505190612af682610730565b565b90602082820312612b1157612b0e915f01612ae9565b90565b6104ec565b612b1e6104e2565b3d5f823e3d90fd5b612b35612b3b9193929361072d565b9261072d565b8203918211612b4657565b61238a565b90565b612b62612b5d612b6792612b4b565b61100b565b61072d565b90565b612b79612b7f9193929361072d565b9261072d565b91612b8b83820261072d565b928184041490151715612b9a57565b61238a565b634e487b7160e01b5f52601260045260245ffd5b612bbf612bc59161072d565b9161072d565b908115612bd0570490565b612b9f565b612bdd6125d5565b91612be66125d5565b91612bfd5f612bf7600c8490611042565b01611071565b90612c156002612c0f600c8490611042565b01611071565b91612c4e6020612c2430612ad3565b63651fd26890612c438692612c376104e2565b95869485938493612ae3565b8352600483016111fe565b03915afa908115612da757612c99916020915f91612d7a575b5093612c7230612ad3565b612c8e63998955d3612c826104e2565b95869485938493612ae3565b8352600483016111fe565b03915afa908115612d75575f91612d47575b509181612cc0612cba5f612906565b9161072d565b11612d16575b505081612cdb612cd55f612906565b9161072d565b11612ce5575b5050565b612d0e929350612cf8612d099183612b26565b612d03612710612b4e565b90612b6a565b612bb3565b905f80612ce1565b612d3f929650612d29612d3a9183612b26565b612d34612710612b4e565b90612b6a565b612bb3565b935f80612cc6565b612d68915060203d8111612d6e575b612d608183610b9a565b810190612af8565b5f612cab565b503d612d56565b612b16565b612d9a9150823d8111612da0575b612d928183610b9a565b810190612af8565b5f612c67565b503d612d88565b612b16565b5f90565b612db990610c59565b90565b90612dc690612db0565b5f5260205260405f2090565b90565b612de1612de691611058565b612dd2565b90565b612df39054612dd5565b90565b6001612e0f612e1592612e07612dac565b506005612dbc565b01612de9565b90565b612e20614a45565b612e28612f7e565b565b612e36612e3b91611058565b610951565b90565b612e489054612e2a565b90565b6001612e57910161072d565b90565b612e69612e6f9193929361072d565b9261072d565b8201809211612e7a57565b61238a565b612e889061102a565b90565b612e949061100e565b90565b612ea090612e8b565b90565b612eac9061102a565b90565b5f910312612eb957565b6104ec565b905f9291805490612ed8612ed183610ab1565b8094610674565b916001811690815f14612f2f5750600114612ef3575b505050565b612f009192939450610ae4565b915f925b818410612f1757505001905f8080612eee565b60018160209295939554848601520191019290612f04565b92949550505060ff19168252151560200201905f8080612eee565b612f6e612f7b949293612f6460608401955f850190610663565b60208301906107d4565b6040818403910152612ebe565b90565b612f91612f8b603f612e3e565b15610541565b6132b157612f9d614071565b61329557612fc6612fb842612fb26040611071565b90612b26565b612fc0611cb1565b90612bb3565b80612fe2612fdc612fd76041611071565b61072d565b9161072d565b111561327957612ffc90612ff66041611071565b90612b26565b908161302a61302461301f61300f611304565b6130196041611071565b90612b26565b61072d565b9161072d565b11613256575b6130395f612906565b906130435f612906565b915b826130586130528661072d565b9161072d565b101561309f576130936130999161308d613087600f61308161307a6041611071565b8990612e5a565b90610e20565b90610e63565b90612e5a565b92612e4b565b91613045565b9150916130b66130af6042611071565b8390612e5a565b6130cf6130c96130c46113d8565b61072d565b9161072d565b1161323a576130ea6130f1916130e56041611071565b612e5a565b60416129a5565b61310e613107826131026042611071565b612e5a565b60426129a5565b61312161311a30612e7f565b8290614a6f565b61313e61312d30612e7f565b6131376043612570565b83916148b8565b61315861315361314e6043612570565b612e97565b612ea3565b6318b68b8c61316630612e7f565b8392604492813b15613235575f6131909161319b82966131846104e2565b98899788968795612ae3565b855260048501612f4a565b03925af1801561323057613204575b506131b56041611071565b906131bf5f61293e565b906131ea7f34b73d0c96e9ff4d5311434817c8ecc930e7d2782c5bde2e79dc44b0596755bb92611036565b926131ff6131f66104e2565b92839283610a31565b0390a2565b613223905f3d8111613229575b61321b8183610b9a565b810190612eaf565b5f6131aa565b503d613211565b612b16565b612adf565b5f6323064ebd60e01b815280613252600482016108ac565b0390fd5b9050613273613263611304565b61326d6041611071565b90612b26565b90613030565b5f63e085d22b60e01b815280613291600482016108ac565b0390fd5b5f631155624b60e21b8152806132ad600482016108ac565b0390fd5b5f6319afc99d60e21b8152806132c9600482016108ac565b0390fd5b6132d5612e18565b565b906132f2916132ed6132e882612df6565b6148c8565b6132f4565b565b906132fe91614acd565b50565b9061330b916132d7565b565b5f90565b90565b61332861332361332d92613311565b61100b565b610d88565b90565b61333861330d565b506133436012613314565b90565b61335661335161212e565b6148c8565b61335e613360565b565b61336a6040611071565b61337c6133765f612906565b9161072d565b146133c55761338d6001603f61296f565b7f4a792a0be42b5672faa40129fc6469072490775ca8d3c34e852d4d55d3a735a96133b66104e2565b806133c0816108ac565b0390a1565b5f638f98404160e01b8152806133dd600482016108ac565b0390fd5b6133e9613346565b565b6133f3612dac565b506133fc614b79565b90565b908061341a61341461340f6148ab565b610657565b91610657565b0361342b5761342891614c33565b50565b5f63334bd91960e11b815280613443600482016108ac565b0390fd5b9061345190611036565b5f5260205260405f2090565b90565b61347461346f61347992612253565b61100b565b61072d565b90565b6134b3916134a86134a261349d6134ae946134956125d5565b50600a613447565b61345d565b91614d14565b90614e0a565b613460565b90565b6134c66134c1611b69565b6148c8565b6134ce6134d0565b565b6134d8614f91565b565b6134e26134b6565b565b90816135006134fa6134f55f61293e565b610657565b91610657565b146135ff57806135186135125f612906565b9161072d565b146135e35761353a61353461352f600d339061142f565b612e3e565b15610541565b6135c75761354733614f9e565b61355e6001613558600c3390611042565b01611071565b61357061356a8361072d565b9161072d565b106135ab576135a9916135a48261359e600161358e600c3390611042565b019161359983611071565b612b26565b906129a5565b614a6f565b565b5f631c959ed960e21b8152806135c3600482016108ac565b0390fd5b5f634417760960e11b8152806135df600482016108ac565b0390fd5b5f631f2a200560e01b8152806135fb600482016108ac565b0390fd5b5f63d92e233d60e01b815280613617600482016108ac565b0390fd5b6136236125d5565b5061363f61362f6113d8565b6136396042611071565b90612b26565b90565b9061365561364e6104e2565b9283610b9a565b565b67ffffffffffffffff8111613675576136716020916105c4565b0190565b610b86565b9061368c61368783613657565b613642565b918252565b5f7f6d6f64653d626c6f636b6e756d6265722666726f6d3d64656661756c74000000910152565b6136c2601d61367a565b906136cf60208301613691565b565b6136d96136b8565b90565b6136e461245f565b506136ed613bff565b6137066137006136fb615139565b6118be565b916118be565b03613716576137136136d1565b90565b5f6301bfc1c560e61b81528061372e600482016108ac565b0390fd5b9061373c90611036565b5f5260205260405f2090565b61375f61376491613757612553565b506009613732565b612570565b90565b61376f61241b565b5061377a6040611071565b61378c6137865f612906565b9161072d565b1190565b6137a19061379c6148ab565b61514e565b565b6137ab61241b565b506137b6600e612e3e565b90565b613810906137c56125d5565b506137dd60016137d7600c8490611042565b01611071565b9061380a60046138046137fc5f6137f6600c8790611042565b01611071565b93600c611042565b01611071565b916151d9565b90565b61382361381e612192565b6148c8565b61382b61382d565b565b6138385f603f61296f565b7f73a5fc60aafeec8f139af22d98e62140e2ce914d1f155c692b427757c3e4014c6138616104e2565b8061386b816108ac565b0390a1565b613878613813565b565b5f90565b6138909061388a61387a565b50615285565b90565b9061389d90611036565b5f5260205260405f2090565b6138bf6138c4916138b86125d5565b505f613893565b611071565b90565b6138de6138e3916138d661241b565b50600d61142f565b612e3e565b90565b906138ef61241b565b506138f86125d5565b506139016125d5565b5061390a6125d5565b506139136125d5565b50613928613923600d849061142f565b612e3e565b9161393f5f613939600c8490611042565b01611071565b916139576002613951600c8590611042565b01611071565b90613990602061396630612ad3565b63651fd2689061398587926139796104e2565b95869485938493612ae3565b8352600483016111fe565b03915afa908115613a51576139db916020915f91613a24575b50946139b430612ad3565b6139d063998955d36139c46104e2565b95869485938493612ae3565b8352600483016111fe565b03915afa908115613a1f575f916139f1575b5090565b613a12915060203d8111613a18575b613a0a8183610b9a565b810190612af8565b5f6139ed565b503d613a00565b612b16565b613a449150823d8111613a4a575b613a3c8183610b9a565b810190612af8565b5f6139a9565b503d613a32565b612b16565b613a6890613a626125d5565b506152b4565b90565b613a7b613a76612192565b6148c8565b613a83613a85565b565b613a8d61532a565b565b613a97613a6b565b565b5f90565b606090565b613aab9061102a565b90565b67ffffffffffffffff8111613ac65760208091020190565b610b86565b90613add613ad883613aae565b613642565b918252565b369037565b90613b0c613af483613acb565b92602080613b028693613aae565b9201910390613ae2565b565b600f60f81b90565b613b1e613a99565b50613b2761245f565b50613b3061245f565b50613b396125d5565b50613b42612553565b50613b4b612dac565b50613b54613a9d565b50613b5d615337565b90613b66615377565b904690613b7230613aa2565b90613b7c5f611b4d565b90613b8e613b895f612906565b613ae7565b90613b97613b0e565b96959493929190565b613bc9613bce91613baf6125d5565b50613bc3613bbd600b61345d565b91614d14565b90614e0a565b613460565b90565b613bf8915f613bed613bf393613be561241b565b506005612dbc565b0161142f565b612e3e565b90565b5f90565b613c07613bfb565b50613c10615139565b90565b613c1b61245f565b50613c266004612531565b90565b613c8190613c356125d5565b50613c4d6003613c47600c8490611042565b01611071565b90613c7b6004613c75613c6d6002613c67600c8790611042565b01611071565b93600c611042565b01611071565b916151d9565b90565b613cab613ca6613ca1613cb093613c996125d5565b50600a613447565b61345d565b6153b7565b613460565b90565b9081613ccf613cc9613cc45f61293e565b610657565b91610657565b14613dce5780613ce7613ce15f612906565b9161072d565b14613db257613d09613d03613cfe600d339061142f565b612e3e565b15610541565b613d9657613d1633614f9e565b613d2d6003613d27600c3390611042565b01611071565b613d3f613d398361072d565b9161072d565b10613d7a57613d7891613d7382613d6d6003613d5d600c3390611042565b0191613d6883611071565b612b26565b906129a5565b61542c565b565b5f631c959ed960e21b815280613d92600482016108ac565b0390fd5b5f634417760960e11b815280613dae600482016108ac565b0390fd5b5f631f2a200560e01b815280613dca600482016108ac565b0390fd5b5f63d92e233d60e01b815280613de6600482016108ac565b0390fd5b90613e059291613e00613dfb61231e565b6148c8565b613e07565b565b80613e22613e1c613e175f61293e565b610657565b91610657565b1461404857613e44613e3e613e39600d849061142f565b612e3e565b15610541565b8061400d575b613fb1575b81613e62613e5c5f612906565b9161072d565b1480613f97575b80613f7d575b613f22575b613e7d81614f9e565b613e94825f613e8e600c8590611042565b016129a5565b613eac836002613ea6600c8590611042565b016129a5565b613ec4826001613ebe600c8590611042565b016129a5565b613edc836003613ed6600c8590611042565b016129a5565b9091613f087faa807d0abf30d91968c7478c66b6d82521a106af13eda036e2036da9af16895892611036565b92613f1d613f146104e2565b92839283610a31565b0390a2565b613f375f613f32600d849061142f565b61296f565b80613f627f02c2f0ba15b03f88b18f4832609a18cf35fc6b3f4546a9992076d7453d1334a891611036565b90613f6b6104e2565b80613f75816108ac565b0390a2613e74565b50613f92613f8d600d839061142f565b612e3e565b613e6f565b5082613fab613fa55f612906565b9161072d565b14613e69565b613fc76001613fc2600d849061142f565b61296f565b80613ff27f6cf28439a2daab1b265097227212a5b71e0a76f9ed85e3f815b5a6c3e218eb7f91611036565b90613ffb6104e2565b80614005816108ac565b0390a2613e4f565b508161402161401b5f612906565b9161072d565b11801561402e575b613e4a565b508261404261403c5f612906565b9161072d565b11614029565b5f63d92e233d60e01b815280614060600482016108ac565b0390fd5b9061406f9291613dea565b565b61407961241b565b506140846041611071565b61409d614097614092611304565b61072d565b9161072d565b101590565b6140bb906140b66140b161231e565b6148c8565b6140fb565b565b906140ce60018060a01b0391611b48565b9181191691161790565b90565b906140f06140eb6140f792611036565b6140d8565b82546140bd565b9055565b8061411661411061410b5f61293e565b610657565b91610657565b1461417c576141256043612570565b6141308260436140db565b9061416461415e7f07015b6a9f05913148fd5faddf2acc9708f305937f3072ca2b4b46faa5d0898b93611036565b91611036565b9161416d6104e2565b80614177816108ac565b0390a3565b5f63d92e233d60e01b815280614194600482016108ac565b0390fd5b6141a1906140a2565b565b6141c0916141af61241b565b506141b86148ab565b9190916149a8565b600190565b67ffffffffffffffff81116141da5760200290565b610b86565b6141eb6141f0916141c5565b613642565b90565b90614211614200836141df565b9261420b84916141c5565b90613ae2565b565b61421d60306141f3565b90565b905090565b61422f905461105d565b90565b60010190565b61425461424e61424783610e17565b8094614220565b91610e1d565b5f915b8383106142645750505050565b61428161427b60019261427685614225565b6116c5565b92614232565b92019190614257565b906142988161060093614238565b0190565b906142bc6142b5926142ac6104e2565b9384809261428a565b0383610b9a565b565b6142c79061429c565b90565b6142d2614213565b506142dd600f6142be565b90565b906142f3916142ed6125d5565b5061347c565b90565b90565b61430d614308614312926142f6565b61100b565b61072d565b90565b61431d6125d5565b506143266125d5565b5061432f6125d5565b5061433861241b565b506143436040611071565b61435561434f5f612906565b9161072d565b146144945761437f6143714261436b6040611071565b90612b26565b614379611cb1565b90612bb3565b906143c161438d6040611071565b6143bb6143ad61439d6041611071565b6143a760016142f9565b90612e5a565b6143b5611cb1565b90612b6a565b90612e5a565b6143cb6041611071565b6143e46143de6143d9611304565b61072d565b9161072d565b105f1461448657614409614403600f6143fd6041611071565b90610e20565b90610e63565b5b92614415603f612e3e565b9081614462575b5080614438575b9161442e6041611071565b9193929193929190565b506144436041611071565b61445c614456614451611304565b61072d565b9161072d565b10614423565b905061447f6144796144746041611071565b61072d565b9161072d565b115f61441c565b61448f5f612906565b61440a565b5f905f915f916144b66144b06144aa5f94612906565b95612906565b93612906565b9190565b6144cc906144c66125d5565b50613c84565b90565b6144d76125d5565b506144e06128d6565b90565b60026144fc614502926144f46125d5565b50600c611042565b01611071565b90565b7fe48329057bfd03d55e49b547132e39cffd9c1820ad7b9d4c5307691425d15adf90565b61455e6145659461455460609498979561454a608086019a5f870190610c9d565b6020850190610663565b60408301906107d4565b01906107d4565b565b60200190565b93959490929195426145876145818961072d565b9161072d565b1161460057916145f2916145f9936145e96145fe98996145d16145a8614505565b6145c28b938b6145b66104e2565b95869460208601614529565b60208201810382520382610b9a565b6145e36145dd82610670565b91614567565b2061548b565b929091926154a8565b91826154f2565b61514e565b565b61461b875f918291632341d78760e11b8352600483016107e1565b0390fd5b7f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c990565b919461468b6146959298979561468160a09661467761469c9a61466d60c08a019e5f8b0190610c9d565b6020890190610663565b6040870190610663565b60608501906107d4565b60808301906107d4565b01906107d4565b565b9160206146bf9294936146b860408201965f830190610663565b0190610663565b565b9695919392949094426146dc6146d68361072d565b9161072d565b11614796579061474561474e94939261472d6146f661461f565b61471e8c80948c916147088d91615535565b91926147126104e2565b97889660208801614643565b60208201810382520382610b9a565b61473f61473982610670565b91614567565b2061548b565b929091926154a8565b8061476161475b87610657565b91610657565b03614776575061477492939190916148b8565b565b84906147925f9283926325c0072360e11b84526004840161469e565b0390fd5b6147b1905f91829163313c898160e11b8352600483016107e1565b0390fd5b906147d0916147cb6147c682612df6565b6148c8565b6147d2565b565b906147dc91614c33565b50565b906147e9916147b5565b565b906147f590611036565b5f5260205260405f2090565b6148269161481c614821926148146125d5565b5060016147eb565b613893565b611071565b90565b6148336040613642565b90565b5f90565b5f90565b614846614829565b9060208083614853614836565b81520161485e61483a565b81525050565b61486c61483e565b90565b906148829161487c614864565b50615568565b90565b61488d61241b565b506148a76148a16301ffc9a760e01b6104f4565b916104f4565b1490565b6148b3612553565b503390565b916148c69291600192615590565b565b6148da906148d46148ab565b906156c2565b565b60409061490561490c94969593966148fb60608401985f850190610663565b60208301906107d4565b01906107d4565b565b90614919910361072d565b90565b92919261492a818390614801565b908161493f6149395f1961072d565b9161072d565b1061494c575b5050509050565b8161495f6149598761072d565b9161072d565b106149855761497c939461497491939261490e565b905f92615590565b805f8080614945565b506149a4849291925f938493637dc7a0d960e11b8552600485016148dc565b0390fd5b91826149c46149be6149b95f61293e565b610657565b91610657565b14614a1e57816149e46149de6149d95f61293e565b610657565b91610657565b146149f7576149f5929190916156fd565b565b614a1a614a035f61293e565b5f91829163ec442f0560e01b8352600483016111fe565b0390fd5b614a41614a2a5f61293e565b5f918291634b637e8f60e11b8352600483016111fe565b0390fd5b614a4d6137a3565b614a5357565b5f63d93c066560e01b815280614a6b600482016108ac565b0390fd5b80614a8a614a84614a7f5f61293e565b610657565b91610657565b14614aa657614aa491614a9c5f61293e565b9190916156fd565b565b614ac9614ab25f61293e565b5f91829163ec442f0560e01b8352600483016111fe565b0390fd5b614ad561241b565b50614aea614ae4828490613bd1565b15610541565b5f14614b7357614b126001614b0d5f614b0560058690612dbc565b01859061142f565b61296f565b90614b1b6148ab565b90614b58614b52614b4c7f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d95612db0565b92611036565b92611036565b92614b616104e2565b80614b6b816108ac565b0390a4600190565b50505f90565b614b81612dac565b50614b8b30613aa2565b614bbd614bb77f0000000000000000000000000000000000000000000000000000000000000000610657565b91610657565b1480614bf9575b5f14614bee577f000000000000000000000000000000000000000000000000000000000000000090565b614bf661577d565b90565b5046614c2d614c277f000000000000000000000000000000000000000000000000000000000000000061072d565b9161072d565b14614bc4565b614c3b61241b565b50614c47818390613bd1565b5f14614ccf57614c6e5f614c695f614c6160058690612dbc565b01859061142f565b61296f565b90614c776148ab565b90614cb4614cae614ca87ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b95612db0565b92611036565b92611036565b92614cbd6104e2565b80614cc7816108ac565b0390a4600190565b50505f90565b614ce9614ce4614cee926118be565b61100b565b61072d565b90565b916020614d12929493614d0b60408201965f8301906107d4565b01906118c9565b565b614d1c613bfb565b50614d25613bff565b81614d38614d3283614cd5565b9161072d565b1015614d4b5750614d4890615883565b90565b90614d665f928392637669fc0f60e11b845260048401614cf1565b0390fd5b5490565b90565b614d85614d80614d8a92614d6e565b61100b565b61072d565b90565b90565b65ffffffffffff1690565b614da7614dac91611058565b614d90565b90565b614db99054614d9b565b90565b60301c90565b60018060d01b031690565b614dd9614dde91614dbc565b614dc2565b90565b614deb9054614dcd565b90565b614e02614dfd614e0792611b45565b61100b565b612253565b90565b90614e5e90614e17612386565b50614e235f8401614d6a565b614e2c5f612906565b908080614e42614e3c6005614d71565b9161072d565b11614ebf575b5090614e595f860193919293614d8d565b615ebe565b80614e71614e6b5f612906565b9161072d565b145f14614e87575050614e835f614dee565b5b90565b614eb45f91614eaf614ea984614eba960192614ea360016142f9565b90612b26565b91614d8d565b615eb4565b01614de1565b614e84565b80614ecd614ed39291615b49565b90612b26565b9083614f05614eff614efa5f614ef4818c01614eef8991614d8d565b615eb4565b01614daf565b6118be565b916118be565b105f14614f165750905b905f614e48565b9150614f2c90614f2660016142f9565b90612e5a565b614f0f565b614f39615f4d565b614f41614f43565b565b614f4e5f600e61296f565b614f566148ab565b614f8c7f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa91614f836104e2565b918291826111fe565b0390a1565b614f99614f31565b565b90565b614fac614fb191600c611042565b614f9b565b614fbd60048201611071565b614fcf614fc95f612906565b9161072d565b146151295761504b90614fee42614fe860048401611071565b90612b26565b80615008615002614ffd611974565b61072d565b9161072d565b10155f1461504d575061502861501f5f8301611071565b600183016129a5565b61504061503760028301611071565b600383016129a5565b5b60044291016129a5565b565b8061506061505a5f612906565b9161072d565b1161506c575b50615041565b61511a615108615123926150f76150ee6150dd6150cb6150bd6150ab61509d6150965f8d01611071565b8890612b6a565b6150a5611974565b90612bb3565b956150b860028c01611071565b612b6a565b6150c5611974565b90612bb3565b936150d860018a01611071565b612e5a565b6150e85f8901611071565b90615f80565b600187016129a5565b61510360038601611071565b612e5a565b61511460028501611071565b90615f80565b600383016129a5565b5f615066565b6151379060044291016129a5565b565b615141613bfb565b5061514b43615883565b90565b906151d7916151d161515f82613748565b6151748461516f60098690613732565b6140db565b828185906151b46151ae6151a87f3134e8a2e6d97e929a7e54011ea5485d7d196dd5f0ba4d4ef95803e8e3fc257f95611036565b92611036565b92611036565b926151bd6104e2565b806151c7816108ac565b0390a49291615fb0565b91615fc8565b565b90916151e36125d5565b50806151f76151f15f612906565b9161072d565b14615276576152069042612b26565b908161522161521b615216611974565b61072d565b9161072d565b10156152715761524561523761524b9385612b6a565b61523f611974565b90612bb3565b90612e5a565b8061525e6152588461072d565b9161072d565b115f1461526a57505b90565b9050615267565b505090565b5050506152825f612906565b90565b6152ac6152a76152a26152b19361529a61387a565b50600a613447565b61345d565b616176565b6161f5565b90565b6152c6906152c06125d5565b50616246565b90565b6152d1614a45565b6152d96152db565b565b6152e76001600e61296f565b6152ef6148ab565b6153257f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2589161531c6104e2565b918291826111fe565b0390a1565b6153326152c9565b565b90565b61533f61245f565b506153747f000000000000000000000000000000000000000000000000000000000000000061536e6006615334565b90616361565b90565b61537f61245f565b506153b47f00000000000000000000000000000000000000000000000000000000000000006153ae6007615334565b90616361565b90565b6153bf612386565b506153cb5f8201614d6a565b806153de6153d85f612906565b9161072d565b145f146153f45750506153f05f614dee565b5b90565b6154215f9161541c6154168461542796019261541060016142f9565b90612b26565b91614d8d565b615eb4565b01614de1565b6153f1565b908161544861544261543d5f61293e565b610657565b91610657565b1461546457615462919061545b5f61293e565b90916156fd565b565b6154876154705f61293e565b5f918291634b637e8f60e11b8352600483016111fe565b0390fd5b6154a590615497612dac565b506154a0614b79565b6163af565b90565b926154c3926154cc946154b9612553565b5092909192616465565b90929192616590565b90565b9160206154f09294936154e960408201965f830190610663565b01906107d4565b565b6154fb81615535565b9161550e6155088461072d565b9161072d565b03615517575050565b6155315f9283926301d4b62360e61b8452600484016154cf565b0390fd5b615549906155416125d5565b506008613893565b61556561555582611071565b9161555f83612e4b565b906129a5565b90565b9061558861558361558d9361557b614864565b50600a613447565b61345d565b6166f2565b90565b9092816155ad6155a76155a25f61293e565b610657565b91610657565b1461567857836155cd6155c76155c25f61293e565b610657565b91610657565b14615651576155f1836155ec6155e5600186906147eb565b8790613893565b6129a5565b6155fb575b505050565b91909161564661563461562e7f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92593611036565b93611036565b9361563d6104e2565b918291826107e1565b0390a35f80806155f6565b61567461565d5f61293e565b5f918291634a1406b160e11b8352600483016111fe565b0390fd5b61569b6156845f61293e565b5f91829163e602df0560e01b8352600483016111fe565b0390fd5b9160206156c09294936156b960408201965f830190610663565b0190610c9d565b565b906156d76156d1838390613bd1565b15610541565b6156df575050565b6156f95f92839263e2517d3f60e01b84526004840161569f565b0390fd5b9161570a92919091616713565b565b7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f90565b9095949261577b9461576a6157749261576060809661575660a088019c5f890190610c9d565b6020870190610c9d565b6040850190610c9d565b60608301906107d4565b0190610663565b565b615785612dac565b5061578e61570c565b6158057f0000000000000000000000000000000000000000000000000000000000000000916157f67f0000000000000000000000000000000000000000000000000000000000000000466157e130613aa2565b916157ea6104e2565b96879560208701615730565b60208201810382520382610b9a565b61581761581182610670565b91614567565b2090565b61582f61582a615834926112e5565b61100b565b610d88565b90565b6158409061581b565b9052565b91602061586592949361585e60408201965f830190615837565b01906107d4565b565b61587b6158766158809261072d565b61100b565b6118be565b90565b61588b613bfb565b50806158a561589f65ffffffffffff614cd5565b9161072d565b116158b6576158b390615867565b90565b60306158d25f9283926306dfcc6560e41b845260048401615844565b0390fd5b90565b6158ed6158e86158f2926158d6565b61100b565b61072d565b90565b90565b61590c615907615911926158f5565b61100b565b610d88565b90565b6159339061592d61592761593894610d88565b9161072d565b9061094d565b61072d565b90565b90565b61595261594d6159579261593b565b61100b565b610d88565b90565b6159799061597361596d61597e94610d88565b9161072d565b90612624565b61072d565b90565b90565b61599861599361599d92615981565b61100b565b61072d565b90565b90565b6159b76159b26159bc926159a0565b61100b565b610d88565b90565b90565b6159d66159d16159db926159bf565b61100b565b61072d565b90565b90565b6159f56159f06159fa926159de565b61100b565b610d88565b90565b90565b615a14615a0f615a19926159fd565b61100b565b61072d565b90565b90565b615a33615a2e615a3892615a1c565b61100b565b610d88565b90565b90565b615a52615a4d615a5792615a3b565b61100b565b61072d565b90565b90565b615a71615a6c615a7692615a5a565b61100b565b610d88565b90565b615a8d615a88615a92926159de565b61100b565b61072d565b90565b90565b615aac615aa7615ab192615a95565b61100b565b610d88565b90565b615ac8615ac3615acd92615a5a565b61100b565b61072d565b90565b615ae4615adf615ae9926142f6565b61100b565b610d88565b90565b90565b615b03615afe615b0892615aec565b61100b565b61072d565b90565b90615b16910261072d565b90565b615b25615b2b9161072d565b9161072d565b908115615b36570490565b612b9f565b90615b46910161072d565b90565b615b516125d5565b5080615b66615b6060016142f9565b9161072d565b1115615eb15780615d7b615d58615d48615d38615d28615d18615d08615cf8615ce8615cd8615cc88b615cc2615cbb615d819f615c9b615c8b615cab92615bad60016142f9565b9080615bc5615bbf600160801b6158d9565b9161072d565b1015615e83575b80615be8615be268010000000000000000615984565b9161072d565b1015615e55575b80615c07615c016401000000006159c2565b9161072d565b1015615e27575b80615c24615c1e62010000615a00565b9161072d565b1015615df9575b80615c40615c3a610100615a3e565b9161072d565b1015615dcb575b80615c5b615c556010615a79565b9161072d565b1015615d9d575b615c75615c6f6004615ab4565b9161072d565b1015615d84575b615c866003615aef565b615b0b565b615c956001615ad0565b90615914565b615ca58186615b19565b90615b3b565b615cb56001615ad0565b90615914565b8092615b19565b90615b3b565b615cd26001615ad0565b90615914565b615ce2818c615b19565b90615b3b565b615cf26001615ad0565b90615914565b615d02818a615b19565b90615b3b565b615d126001615ad0565b90615914565b615d228188615b19565b90615b3b565b615d326001615ad0565b90615914565b615d428186615b19565b90615b3b565b615d526001615ad0565b90615914565b91615d75615d6f615d6a858094615b19565b61072d565b9161072d565b116167a3565b9061490e565b90565b615d9890615d926001615ad0565b9061595a565b615c7c565b615db4615dc591615dae6004615a5d565b90615914565b91615dbf6002615a98565b9061595a565b90615c62565b615de2615df391615ddc6008615a1f565b90615914565b91615ded6004615a5d565b9061595a565b90615c47565b615e10615e2191615e0a60106159e1565b90615914565b91615e1b6008615a1f565b9061595a565b90615c2b565b615e3e615e4f91615e3860206159a3565b90615914565b91615e4960106159e1565b9061595a565b90615c0e565b615e6c615e7d91615e66604061593e565b90615914565b91615e7760206159a3565b9061595a565b90615bef565b615e9a615eab91615e9460806158f8565b90615914565b91615ea5604061593e565b9061595a565b90615bcc565b90565b5f5260205f200190565b93919092615eca6125d5565b505b81615edf615ed98361072d565b9161072d565b1015615f4557615ef08282906167cd565b90615f065f615f00888590615eb4565b01614daf565b615f18615f12876118be565b916118be565b115f14615f285750915b91615ecc565b929150615f3f90615f3960016142f9565b90612e5a565b90615f22565b925050915090565b615f5e615f586137a3565b15610541565b615f6457565b5f638dfc202b60e01b815280615f7c600482016108ac565b0390fd5b90615f896125d5565b5081615f9d615f978361072d565b9161072d565b105f14615fa957505b90565b9050615fa6565b615fc290615fbc6125d5565b506138a9565b90565b90565b91909180615fde615fd885610657565b91610657565b14158061615c575b615ff0575b505050565b8061600b6160056160005f61293e565b610657565b91610657565b036160cc575b508161602d6160276160225f61293e565b610657565b91610657565b03616039575b80615feb565b61608061607361607a9261604f600a8690613447565b9061606d616067616061600193616866565b9361345d565b91615fc5565b906168b9565b9290613460565b91613460565b9190916160ad7fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a72492611036565b926160c26160b96104e2565b92839283610a31565b0390a25f80616033565b61610b6161116161046160e1600a8590613447565b60026160fe6160f86160f289616866565b9361345d565b91615fc5565b906168b9565b9290613460565b91613460565b91909161613e7fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a72492611036565b9261615361614a6104e2565b92839283610a31565b0390a25f616011565b508161617061616a5f612906565b9161072d565b11615fe6565b5f61618a916161836125d5565b5001614d6a565b90565b6161a161619c6161a692611493565b61100b565b61072d565b90565b6161b2906159a3565b9052565b9160206161d79294936161d060408201965f8301906161a9565b01906107d4565b565b6161ed6161e86161f29261072d565b61100b565b611493565b90565b6161fd61387a565b508061621561620f63ffffffff61618d565b9161072d565b1161622657616223906161d9565b90565b60206162425f9283926306dfcc6560e41b8452600484016161b6565b0390fd5b61625d616262916162556125d5565b506008613893565b611071565b90565b90565b61627c61627761628192616265565b611b48565b610c59565b90565b61628e60ff616268565b90565b5f5260205f2090565b905f92918054906162b46162ad83610ab1565b8094612464565b916001811690815f1461630b57506001146162cf575b505050565b6162dc9192939450616291565b915f925b8184106162f357505001905f80806162ca565b600181602092959395548486015201910192906162e0565b92949550505060ff19168252151560200201905f80806162ca565b906163309161629a565b90565b9061635361634c926163436104e2565b93848092616326565b0383610b9a565b565b61635e90616333565b90565b9061636a61245f565b5061637482612db0565b61638d616387616382616284565b610c59565b91610c59565b14155f146163a2575061639f90616943565b90565b6163ac9150616355565b90565b6042916163ba612dac565b50604051917f19010000000000000000000000000000000000000000000000000000000000008352600283015260228201522090565b5f90565b61640061640591611058565b61264d565b90565b90565b61641f61641a61642492616408565b61100b565b61072d565b90565b61645c61646394616452606094989795616448608086019a5f870190610c9d565b6020850190610d8e565b6040830190610c9d565b0190610c9d565b565b939293616470612553565b506164796163f0565b50616482612dac565b5061648c856163f4565b6164be6164b87f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a061640b565b9161072d565b1161654b57906164e1602094955f949392936164d86104e2565b94859485616427565b838052039060015afa15616546576164f95f51611b48565b8061651461650e6165095f61293e565b610657565b91610657565b1461652a575f916165245f611b4d565b91929190565b506165345f61293e565b6001916165405f611b4d565b91929190565b612b16565b5050506165575f61293e565b9060039291929190565b634e487b7160e01b5f52602160045260245ffd5b6004111561657f57565b616561565b9061658e82616575565b565b806165a361659d5f616584565b91616584565b145f146165ae575050565b806165c26165bc6001616584565b91616584565b145f146165e5575f63f645eedf60e01b8152806165e1600482016108ac565b0390fd5b806165f96165f36002616584565b91616584565b145f146166275761662361660c836163f4565b5f91829163fce698f760e01b8352600483016107e1565b0390fd5b61663a6166346003616584565b91616584565b146166425750565b61665d905f9182916335e2f38360e21b835260048301610caa565b0390fd5b5f5260205f2090565b61667381614d6a565b82101561668d57616685600191616661565b910201905f90565b610e03565b9061669c906118be565b9052565b906166aa90612253565b9052565b906166e46166db5f6166be614829565b946166d56166cd838301614daf565b838801616692565b01614de1565b602084016166a0565b565b6166ef906166ae565b90565b616710915f61670a92616703614864565b500161666a565b506166e6565b90565b929161672184838391616973565b8361673c6167366167315f61293e565b610657565b91610657565b14616751575b61674f9293919091616afd565b565b6167596128d6565b93616762616ae2565b94806167766167708861072d565b9161072d565b1161678357509350616742565b859061679f5f928392630e58ae9360e11b845260048401610a31565b0390fd5b6167ab6125d5565b50151590565b6167c56167c06167ca92615a95565b61100b565b61072d565b90565b6167f26167f8926167dc6125d5565b5082811692186167ec60026167b1565b90612bb3565b90612e5a565b90565b90565b61681261680d616817926167fb565b61100b565b610d88565b90565b616823906167fe565b9052565b91602061684892949361684160408201965f83019061681a565b01906107d4565b565b61685e6168596168639261072d565b61100b565b612253565b90565b61686e612386565b508061688861688260018060d01b03613460565b9161072d565b11616899576168969061684a565b90565b60d06168b55f9283926306dfcc6560e41b845260048401616827565b0390fd5b906168ef6168f593926168ca612386565b506168d3612386565b5080936168e86168e1613bff565b94926153b7565b9091616f65565b91616bbc565b91909190565b61690f61690a616914926159a0565b61100b565b61072d565b90565b369037565b906169416169298361367a565b926020806169378693613657565b9201910390616917565b565b61694b61245f565b5061695581616c26565b9061696861696360206168fb565b61691c565b918252602082015290565b9190918061699161698b6169865f61293e565b610657565b91610657565b145f14616a72576169b56169ae836169a96002611071565b612e5a565b60026129a5565b5b826169d16169cb6169c65f61293e565b610657565b91610657565b145f14616a46576169f56169ee836169e96002611071565b61490e565b60026129a5565b5b919091616a41616a2f616a297fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef93611036565b93611036565b93616a386104e2565b918291826107e1565b0390a3565b616a6d82616a67616a585f8790613893565b91616a6283611071565b615b3b565b906129a5565b6169f6565b616a85616a805f8390613893565b611071565b80616a98616a928561072d565b9161072d565b10616ac057616aab616abb91849061490e565b616ab65f8490613893565b6129a5565b6169b6565b90616ade9091925f93849363391434e360e21b8552600485016148dc565b0390fd5b616aea6125d5565b50616afa60018060d01b03613460565b90565b91616b55616b4f616b5c9480616b23616b1d616b185f61293e565b610657565b91610657565b14616b8d575b84616b44616b3e616b395f61293e565b610657565b91610657565b14616b5e575b613748565b92613748565b9091615fc8565b565b616b86600b6002616b80616b7a616b7489616866565b9361345d565b91615fc5565b906168b9565b5050616b4a565b616bb5600b6001616baf616ba9616ba389616866565b9361345d565b91615fc5565b906168b9565b5050616b29565b91616be05f616be594616bcd612386565b50616bd6612386565b5001929192614d8d565b616e17565b91909190565b616bff616bfa616c0492616265565b61100b565b61072d565b90565b90565b616c1e616c19616c2392616c07565b61100b565b61072d565b90565b616c3b616c4091616c356125d5565b50612db0565b6163f4565b616c4a60ff616beb565b1680616c5f616c59601f616c0a565b9161072d565b11616c675790565b5f632cd44ac360e21b815280616c7f600482016108ac565b0390fd5b5490565b616c916040613642565b90565b5f5260205f2090565b616ca681616c83565b821015616cc057616cb8600191616c94565b910201905f90565b610e03565b616ccf90516118be565b90565b90616ce365ffffffffffff91611b48565b9181191691161790565b616d01616cfc616d06926118be565b61100b565b6118be565b90565b90565b90616d21616d1c616d2892616ced565b616d09565b8254616cd2565b9055565b616d369051612253565b90565b60301b90565b90616d5165ffffffffffff1991616d39565b9181191691161790565b616d6f616d6a616d7492612253565b61100b565b612253565b90565b90565b90616d8f616d8a616d9692616d5b565b616d77565b8254616d3f565b9055565b90616dc460205f616dca94616dbc828201616db6848801616cc5565b90616d0c565b019201616d2c565b90616d7a565b565b9190616ddd57616ddb91616d9a565b565b610a8a565b9081549168010000000000000000831015616e125782616e0a916001616e1095018155616c9d565b90616dcc565b565b610b86565b90929192616e23612386565b50616e2c612386565b50616e3682616c83565b80616e49616e435f612906565b9161072d565b115f14616f1957616e6f90616e698491616e6360016142f9565b90612b26565b90615eb4565b90616e7b5f8301614daf565b92616e875f8401614de1565b9380616e9b616e95856118be565b916118be565b11616efd57616eb2616eac846118be565b916118be565b145f14616ecd575050616ec8905f859101616d7a565b5b9190565b616ef89250616ef386616eea616ee1616c87565b945f8601616692565b602084016166a0565b616de2565b616ec9565b5f632520601d60e01b815280616f15600482016108ac565b0390fd5b50616f4491616f3f85616f36616f2d616c87565b945f8601616692565b602084016166a0565b616de2565b616f4d5f614dee565b9190565b634e487b7160e01b5f52605160045260245ffd5b91909180600114616f8457600203616f5157616f8091612405565b905b565b50616f8e916123c6565b90616f8256
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"a\x01``@R4a\0vWa\0\x1Ea\0\x15a\x01cV[\x92\x91\x90\x91a\x03]V[a\0&a\0{V[ao\x94a \x8D\x829`\x80Q\x81aK\xCC\x01R`\xA0Q\x81aL\x03\x01R`\xC0Q\x81aK\x93\x01R`\xE0Q\x81aW\x93\x01Ra\x01\0Q\x81aW\xB8\x01Ra\x01 Q\x81aSE\x01Ra\x01@Q\x81aS\x85\x01Rao\x94\x90\xF3[a\0\x81V[`@Q\x90V[_\x80\xFD[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\0\xAD\x90a\0\x85V[\x81\x01\x90\x81\x10`\x01\x80`@\x1B\x03\x82\x11\x17a\0\xC5W`@RV[a\0\x8FV[\x90a\0\xDDa\0\xD6a\0{V[\x92\x83a\0\xA3V[V[_\x80\xFD[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\0\xF7\x90a\0\xE3V[\x90V[a\x01\x03\x81a\0\xEEV[\x03a\x01\nWV[_\x80\xFD[\x90PQ\x90a\x01\x1B\x82a\0\xFAV[V[`\x80\x81\x83\x03\x12a\x01^Wa\x013\x82_\x83\x01a\x01\x0EV[\x92a\x01[a\x01D\x84` \x85\x01a\x01\x0EV[\x93a\x01R\x81`@\x86\x01a\x01\x0EV[\x93``\x01a\x01\x0EV[\x90V[a\0\xDFV[a\x01\x81a\x90!\x808\x03\x80a\x01v\x81a\0\xCAV[\x92\x839\x81\x01\x90a\x01\x1DV[\x90\x91\x92\x93V[`\x01\x80`@\x1B\x03\x81\x11a\x01\xA3Wa\x01\x9F` \x91a\0\x85V[\x01\x90V[a\0\x8FV[\x90a\x01\xBAa\x01\xB5\x83a\x01\x87V[a\0\xCAV[\x91\x82RV[_\x7FSyndicate\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x01\xF0`\ta\x01\xA8V[\x90a\x01\xFD` \x83\x01a\x01\xBFV[V[a\x02\x07a\x01\xE6V[\x90V[_\x7FSYND\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x02;`\x04a\x01\xA8V[\x90a\x02H` \x83\x01a\x02\nV[V[a\x02Ra\x021V[\x90V[\x90V[\x90V[a\x02oa\x02ja\x02t\x92a\x02UV[a\x02XV[a\0\xE3V[\x90V[a\x02\x80\x90a\x02[V[\x90V[_\x01\x90V[\x90V[_\x1B\x90V[a\x02\xA4a\x02\x9Fa\x02\xA9\x92a\x02UV[a\x02\x8BV[a\x02\x88V[\x90V[a\x02\xB5_a\x02\x90V[\x90V[\x7Fk\x97%\xF7@\xF9K\x91\xB7\x80`\xA1\xB1}\x17tem8\x14!\xA5)\xEC\x98\xCD\xB0\x13\xF4\xD9\xC2^\x90V[\x7F\xCC\xE2\x96\xB0@3*\x08\x0Em\xF15\x15\xA3\xEC(i\xE2\x1C\xD2\x0FsD\xAF\t\x87\xDD\xB98\xD8\xBD!\x90V[\x7Fe\xD7\xA2\x8E2e\xB3zdt\x92\x9F3e!\xB32\xC1h\x1B\x93?l\xB9\xF37fsD\r\x86*\x90V[\x90V[\x90V[a\x03>a\x039a\x03C\x92a\x03$V[a\x02XV[a\x03'V[\x90V[a\x03ZjJr=\xC6\xB4\x0B\x8A\x9A\0\0\0a\x03*V[\x90V[\x90\x91\x92a\x03ya\x03ka\x01\xFFV[a\x03sa\x02JV[\x90a\x05\x16V[\x81a\x03\x94a\x03\x8Ea\x03\x89_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x04\xB0W\x82a\x03\xB4a\x03\xAEa\x03\xA9_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x04\x94W\x83a\x03\xD4a\x03\xCEa\x03\xC9_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x04xW\x80a\x03\xF4a\x03\xEEa\x03\xE9_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x04\\Wa\x045a\x04C\x92a\x04'a\x04R\x96a\x04\x19a\x04\x12a\x02\xACV[\x84\x90a\t\xB9V[Pa\x04\"a\x02\xB8V[a\t\xB9V[Pa\x040a\x02\xDCV[a\t\xB9V[Pa\x04>a\x03\0V[a\t\xB9V[Pa\x04La\x03FV[\x90a\n\x87V[a\x04Za\r\x8FV[V[_c\xD9.#=`\xE0\x1B\x81R\x80a\x04t`\x04\x82\x01a\x02\x83V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a\x04\x90`\x04\x82\x01a\x02\x83V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a\x04\xAC`\x04\x82\x01a\x02\x83V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a\x04\xC8`\x04\x82\x01a\x02\x83V[\x03\x90\xFD[\x90a\x04\xD8`\xFF\x91a\x02\x8BV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x15\x15\x90V[a\x04\xF0\x90a\x04\xE2V[\x90V[\x90V[\x90a\x05\x0Ba\x05\x06a\x05\x12\x92a\x04\xE7V[a\x04\xF3V[\x82Ta\x04\xCCV[\x90UV[\x90a\x05 \x91a\x05-V[a\x05+_`\x0Ea\x04\xF6V[V[a\x059\x91\x81\x90\x91a\x05;V[V[\x90a\x05F\x92\x91a\x05HV[V[\x90a\x05S\x92\x91a\x05UV[V[\x90a\x05`\x92\x91a\x05bV[V[\x90a\x05m\x92\x91a\x05oV[V[\x90a\x05z\x92\x91a\x05|V[V[\x90a\x05\x87\x92\x91a\x05\xD4V[V[_\x7F1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x05\xBA`\x01a\x01\xA8V[\x90a\x05\xC7` \x83\x01a\x05\x89V[V[a\x05\xD1a\x05\xB0V[\x90V[\x90a\x05\xE8\x92\x91a\x05\xE2a\x05\xC9V[\x90a\x05\xEAV[V[\x90a\x05\xF6\x93\x92\x91a\x06<V[V[\x90V[\x90V[` \x01\x90V[Q\x90V[a\x06\x1Ca\x06\x17a\x06!\x92a\0\xE3V[a\x02XV[a\0\xE3V[\x90V[a\x06-\x90a\x06\x08V[\x90V[a\x069\x90a\x06$V[\x90V[a\x06Ma\x06\x9D\x94a\x06\x82\x93\x94a\x06\xD1V[a\x06a\x81a\x06[`\x06a\x05\xF8V[\x90a\x0F\xB9V[a\x01 Ra\x06y\x83a\x06s`\x07a\x05\xF8V[\x90a\x0F\xB9V[a\x01@Ra\x05\xFBV[a\x06\x94a\x06\x8E\x82a\x06\x04V[\x91a\x05\xFEV[ `\xE0Ra\x05\xFBV[a\x06\xAFa\x06\xA9\x82a\x06\x04V[\x91a\x05\xFEV[ a\x01\0RF`\xA0Ra\x06\xC0a\x10\xBEV[`\x80Ra\x06\xCC0a\x060V[`\xC0RV[\x90a\x06\xDB\x91a\x06\xDDV[V[\x90a\x06\xE7\x91a\x06\xE9V[V[\x90a\x06\xF3\x91a\tYV[V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[Q\x90V[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x07@W[` \x83\x10\x14a\x07;WV[a\x07\x0CV[\x91`\x7F\x16\x91a\x070V[_R` _ \x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a\x07|\x91\x02\x91a\x07v_\x19\x84a\x07]V[\x92a\x07]V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x07\x9Aa\x07\x95a\x07\x9F\x92a\x03'V[a\x02XV[a\x03'V[\x90V[\x90V[\x91\x90a\x07\xBBa\x07\xB6a\x07\xC3\x93a\x07\x86V[a\x07\xA2V[\x90\x83Ta\x07aV[\x90UV[_\x90V[a\x07\xDD\x91a\x07\xD7a\x07\xC7V[\x91a\x07\xA5V[V[[\x81\x81\x10a\x07\xEBWPPV[\x80a\x07\xF8_`\x01\x93a\x07\xCBV[\x01a\x07\xE0V[\x91\x90`\x1F\x81\x11a\x08\x0EW[PPPV[a\x08\x1Aa\x08?\x93a\x07JV[\x90` a\x08&\x84a\x07SV[\x83\x01\x93\x10a\x08GW[a\x088\x90a\x07SV[\x01\x90a\x07\xDFV[_\x80\x80a\x08\tV[\x91Pa\x088\x81\x92\x90Pa\x08/V[\x1C\x90V[\x90a\x08i\x90_\x19\x90`\x08\x02a\x08UV[\x19\x16\x90V[\x81a\x08x\x91a\x08YV[\x90`\x02\x02\x17\x90V[\x90a\x08\x8A\x81a\x07\x08V[\x90`\x01\x80`@\x1B\x03\x82\x11a\tHWa\x08\xAC\x82a\x08\xA6\x85Ta\x07 V[\x85a\x07\xFEV[` \x90`\x1F\x83\x11`\x01\x14a\x08\xE0W\x91\x80\x91a\x08\xCF\x93_\x92a\x08\xD4W[PPa\x08nV[\x90U[V[\x90\x91P\x01Q_\x80a\x08\xC8V[`\x1F\x19\x83\x16\x91a\x08\xEF\x85a\x07JV[\x92_[\x81\x81\x10a\t0WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\t\x16W[PPP\x02\x01\x90Ua\x08\xD2V[a\t&\x91\x01Q`\x1F\x84\x16\x90a\x08YV[\x90U_\x80\x80a\t\nV[\x91\x93` `\x01\x81\x92\x87\x87\x01Q\x81U\x01\x95\x01\x92\x01a\x08\xF2V[a\0\x8FV[\x90a\tW\x91a\x08\x80V[V[\x90a\tha\to\x92`\x03a\tMV[`\x04a\tMV[V[_\x90V[a\t~\x90a\x02\x88V[\x90V[\x90a\t\x8B\x90a\tuV[_R` R`@_ \x90V[a\t\xA0\x90a\x06$V[\x90V[\x90a\t\xAD\x90a\t\x97V[_R` R`@_ \x90V[a\t\xC1a\tqV[Pa\t\xD6a\t\xD0\x82\x84\x90a\x11[V[\x15a\x04\xE2V[_\x14a\n_Wa\t\xFE`\x01a\t\xF9_a\t\xF1`\x05\x86\x90a\t\x81V[\x01\x85\x90a\t\xA3V[a\x04\xF6V[\x90a\n\x07a\x11\x89V[\x90a\nDa\n>a\n8\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a\tuV[\x92a\t\x97V[\x92a\t\x97V[\x92a\nMa\0{V[\x80a\nW\x81a\x02\x83V[\x03\x90\xA4`\x01\x90V[PP_\x90V[a\nn\x90a\0\xEEV[\x90RV[\x91\x90a\n\x85\x90_` \x85\x01\x94\x01\x90a\neV[V[\x80a\n\xA2a\n\x9Ca\n\x97_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\n\xBEWa\n\xBC\x91a\n\xB4_a\x02wV[\x91\x90\x91a\x11\x96V[V[a\n\xE1a\n\xCA_a\x02wV[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\nrV[\x03\x90\xFD[`\x01\x80`@\x1B\x03\x81\x11a\n\xF8W` \x02\x90V[a\0\x8FV[a\x0B\ta\x0B\x0E\x91a\n\xE5V[a\0\xCAV[\x90V[\x90V[a\x0B(a\x0B#a\x0B-\x92a\x0B\x11V[a\x02XV[a\x03'V[\x90V[\x90a\x0B:\x90a\x03'V[\x90RV[\x90V[a\x0BUa\x0BPa\x0BZ\x92a\x0B>V[a\x02XV[a\x03'V[\x90V[\x90V[a\x0Bta\x0Boa\x0By\x92a\x0B]V[a\x02XV[a\x03'V[\x90V[\x90V[a\x0B\x93a\x0B\x8Ea\x0B\x98\x92a\x0B|V[a\x02XV[a\x03'V[\x90V[\x90V[a\x0B\xB2a\x0B\xADa\x0B\xB7\x92a\x0B\x9BV[a\x02XV[a\x03'V[\x90V[\x90V[a\x0B\xD1a\x0B\xCCa\x0B\xD6\x92a\x0B\xBAV[a\x02XV[a\x03'V[\x90V[\x90V[a\x0B\xF0a\x0B\xEBa\x0B\xF5\x92a\x0B\xD9V[a\x02XV[a\x03'V[\x90V[\x90V[a\x0C\x0Fa\x0C\na\x0C\x14\x92a\x0B\xF8V[a\x02XV[a\x03'V[\x90V[a\x0C+a\x0C&a\x0C0\x92a\x02UV[a\x02XV[a\x03'V[\x90V[`\x01a\x0C?\x91\x01a\x03'V[\x90V[\x90V[a\x0CYa\x0CTa\x0C^\x92a\x0CBV[a\x02XV[a\x03'V[\x90V[\x90V[a\x0Cxa\x0Csa\x0C}\x92a\x0CaV[a\x02XV[a\x03'V[\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\x0C\xA3a\x0C\xA9\x91\x93\x92\x93a\x03'V[\x92a\x03'V[\x91a\x0C\xB5\x83\x82\x02a\x03'V[\x92\x81\x84\x04\x14\x90\x15\x17\x15a\x0C\xC4WV[a\x0C\x80V[a\x0C\xD8a\x0C\xDE\x91\x93\x92\x93a\x03'V[\x92a\x03'V[\x82\x01\x80\x92\x11a\x0C\xE9WV[a\x0C\x80V[\x90V[a\r\x05a\r\0a\r\n\x92a\x0C\xEEV[a\x02XV[a\x03'V[\x90V[a\r\x17`0a\x0C\xF1V[\x90V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[P`\x08\x90V[\x90a\r>\x82a\r.V[\x81\x10\x15a\rLW` \x02\x01\x90V[a\r\x1AV[a\r[\x90Qa\x03'V[\x90V[P`0\x90V[\x90V[a\rp\x81a\r^V[\x82\x10\x15a\r\x8AWa\r\x82`\x01\x91a\rdV[\x91\x02\x01\x90_\x90V[a\r\x1AV[a\r\x99`\x08a\n\xFDV[a\r\xB7a\r\xAFi\x8F\x95oiz\xA4\x92<\0\0a\x0B\x14V[_\x83\x01a\x0B0V[a\r\xD6a\r\xCDiV&v\x0C\x16b\xBE$\0\0a\x0BAV[` \x83\x01a\x0B0V[a\r\xF5a\r\xECi3\xB0\xB0\0\xFE\xC5\x93\x90\0\0a\x0B`V[`@\x83\x01a\x0B0V[a\x0E\x14a\x0E\x0Bi\x1F\x03\x9C\xCDe\xA9\xBE\xF0\0\0a\x0B\x7FV[``\x83\x01a\x0B0V[a\x0E3a\x0E*i\x12\x9B\xC4{<\xFFr\x90\0\0a\x0B\x9EV[`\x80\x83\x01a\x0B0V[a\x0ERa\x0EIi\x0B*H=m\xAD\xEE\x18\0\0a\x0B\xBDV[`\xA0\x83\x01a\x0B0V[a\x0Eqa\x0Ehi\x06\xB2\xEF\xD1:\x96*l\0\0a\x0B\xDCV[`\xC0\x83\x01a\x0B0V[a\x0E\x90a\x0E\x87i\x04\x04\xF6JVZ\x19t\0\0a\x0B\xFBV[`\xE0\x83\x01a\x0B0V[a\x0E\x99_a\x0C\x17V[\x91[\x82a\x0E\xAFa\x0E\xA9`\x08a\x0CEV[\x91a\x03'V[\x10\x15a\x0FeWa\x0E\xBE_a\x0C\x17V[[\x80a\x0E\xD3a\x0E\xCD`\x06a\x0CdV[\x91a\x03'V[\x10\x15a\x0FTWa\x0F!\x90a\x0E\xFBa\x0E\xF4\x86a\x0E\xEE`\x06a\x0CdV[\x90a\x0C\x94V[\x82\x90a\x0C\xC9V[\x80a\x0F\x15a\x0F\x0Fa\x0F\na\r\rV[a\x03'V[\x91a\x03'V[\x10a\x0F&W[Pa\x0C3V[a\x0E\xBFV[a\x0FN\x90a\x0FHa\x0F@a\x0F;\x88\x8A\x90a\r4V[a\rQV[\x91`\x0Fa\rgV[\x90a\x07\xA5V[_a\x0F\x1BV[P\x91a\x0F_\x90a\x0C3V[\x91a\x0E\x9BV[\x91PPV[_\x90V[\x90V[a\x0F\x85a\x0F\x80a\x0F\x8A\x92a\x0FnV[a\x02XV[a\x03'V[\x90V[\x90V[a\x0F\xA4a\x0F\x9Fa\x0F\xA9\x92a\x0F\x8DV[a\x02\x8BV[a\x02\x88V[\x90V[a\x0F\xB6`\xFFa\x0F\x90V[\x90V[\x90a\x0F\xC2a\x0FjV[Pa\x0F\xD4a\x0F\xCF\x83a\x05\xFBV[a\x06\x04V[a\x0F\xE7a\x0F\xE1` a\x0FqV[\x91a\x03'V[\x10_\x14a\x0F\xFBWPa\x0F\xF8\x90a\x12\x95V[\x90V[_a\x10\ta\x10\x0F\x93\x92a\x11\xA5V[\x01a\tMV[a\x10\x1Fa\x10\x1Aa\x0F\xACV[a\tuV[\x90V[_\x90V[\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x90V[a\x10T\x90Qa\x02\x88V[\x90V[a\x10`\x90a\x02\x88V[\x90RV[a\x10m\x90a\x03'V[\x90RV[\x90\x95\x94\x92a\x10\xBC\x94a\x10\xABa\x10\xB5\x92a\x10\xA1`\x80\x96a\x10\x97`\xA0\x88\x01\x9C_\x89\x01\x90a\x10WV[` \x87\x01\x90a\x10WV[`@\x85\x01\x90a\x10WV[``\x83\x01\x90a\x10dV[\x01\x90a\neV[V[a\x10\xC6a\x10\"V[Pa\x10\xCFa\x10&V[a\x11\x19a\x10\xDC`\xE0a\x10JV[\x91a\x11\na\x10\xEBa\x01\0a\x10JV[Fa\x10\xF50a\x060V[\x91a\x10\xFEa\0{V[\x96\x87\x95` \x87\x01a\x10qV[` \x82\x01\x81\x03\x82R\x03\x82a\0\xA3V[a\x11+a\x11%\x82a\x06\x04V[\x91a\x05\xFEV[ \x90V[_\x1C\x90V[`\xFF\x16\x90V[a\x11Fa\x11K\x91a\x11/V[a\x114V[\x90V[a\x11X\x90Ta\x11:V[\x90V[a\x11\x82\x91_a\x11wa\x11}\x93a\x11oa\tqV[P`\x05a\t\x81V[\x01a\t\xA3V[a\x11NV[\x90V[_\x90V[a\x11\x91a\x11\x85V[P3\x90V[\x91a\x11\xA3\x92\x91\x90\x91a\x13BV[V[\x90V[\x90V[a\x11\xBFa\x11\xBAa\x11\xC4\x92a\x11\xA8V[a\x02XV[a\x03'V[\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[a\x11\xFAa\x12\x03` \x93a\x12\x08\x93a\x11\xF1\x81a\x07\x08V[\x93\x84\x80\x93a\x11\xC7V[\x95\x86\x91\x01a\x11\xD0V[a\0\x85V[\x01\x90V[a\x12!\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x11\xDBV[\x90V[a\x12>a\x129a\x123\x83a\x06\x04V[\x92a\x05\xFEV[a\x10JV[\x90` \x81\x10a\x12LW[P\x90V[a\x12^\x90_\x19\x90` \x03`\x08\x02a\x07]V[\x16_a\x12HV[a\x12qa\x12v\x91a\x11/V[a\x07\x86V[\x90V[a\x12\x8Da\x12\x88a\x12\x92\x92a\x03'V[a\x02\x8BV[a\x02\x88V[\x90V[a\x12\x9Da\x0FjV[Pa\x12\xA7\x81a\x05\xFBV[\x90a\x12\xB1\x82a\x06\x04V[a\x12\xC4a\x12\xBE`\x1Fa\x11\xABV[\x91a\x03'V[\x11a\x12\xF9WPa\x12\xF1\x81a\x12\xEBa\x12\xE5a\x12\xE0a\x12\xF6\x95a\x12$V[a\x12eV[\x91a\x06\x04V[\x17a\x12yV[a\tuV[\x90V[a\x13\x1B\x90a\x13\x05a\0{V[\x91\x82\x91c0Z'\xA9`\xE0\x1B\x83R`\x04\x83\x01a\x12\x0CV[\x03\x90\xFD[\x91` a\x13@\x92\x94\x93a\x139`@\x82\x01\x96_\x83\x01\x90a\x10dV[\x01\x90a\x10dV[V[\x92\x91a\x13P\x84\x83\x83\x91a\x14\xA5V[\x83a\x13ka\x13ea\x13`_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x13\x80W[a\x13~\x92\x93\x91\x90\x91a\x16rV[V[a\x13\x88a\x16\x14V[\x93a\x13\x91a\x16QV[\x94\x80a\x13\xA5a\x13\x9F\x88a\x03'V[\x91a\x03'V[\x11a\x13\xB2WP\x93Pa\x13qV[\x85\x90a\x13\xCE_\x92\x83\x92c\x0EX\xAE\x93`\xE1\x1B\x84R`\x04\x84\x01a\x13\x1FV[\x03\x90\xFD[\x90a\x13\xDC\x90a\t\x97V[_R` R`@_ \x90V[\x90V[a\x13\xF7a\x13\xFC\x91a\x11/V[a\x13\xE8V[\x90V[a\x14\t\x90Ta\x13\xEBV[\x90V[`@\x90a\x145a\x14<\x94\x96\x95\x93\x96a\x14+``\x84\x01\x98_\x85\x01\x90a\neV[` \x83\x01\x90a\x10dV[\x01\x90a\x10dV[V[\x90a\x14I\x91\x03a\x03'V[\x90V[\x90a\x14X_\x19\x91a\x02\x8BV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a\x14wa\x14ra\x14~\x92a\x07\x86V[a\x07\xA2V[\x82Ta\x14LV[\x90UV[\x90a\x14\x8D\x91\x01a\x03'V[\x90V[\x91\x90a\x14\xA3\x90_` \x85\x01\x94\x01\x90a\x10dV[V[\x91\x90\x91\x80a\x14\xC3a\x14\xBDa\x14\xB8_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14_\x14a\x15\xA4Wa\x14\xE7a\x14\xE0\x83a\x14\xDB`\x02a\x13\xFFV[a\x0C\xC9V[`\x02a\x14bV[[\x82a\x15\x03a\x14\xFDa\x14\xF8_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14_\x14a\x15xWa\x15'a\x15 \x83a\x15\x1B`\x02a\x13\xFFV[a\x14>V[`\x02a\x14bV[[\x91\x90\x91a\x15sa\x15aa\x15[\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x93a\t\x97V[\x93a\t\x97V[\x93a\x15ja\0{V[\x91\x82\x91\x82a\x14\x90V[\x03\x90\xA3V[a\x15\x9F\x82a\x15\x99a\x15\x8A_\x87\x90a\x13\xD2V[\x91a\x15\x94\x83a\x13\xFFV[a\x14\x82V[\x90a\x14bV[a\x15(V[a\x15\xB7a\x15\xB2_\x83\x90a\x13\xD2V[a\x13\xFFV[\x80a\x15\xCAa\x15\xC4\x85a\x03'V[\x91a\x03'V[\x10a\x15\xF2Wa\x15\xDDa\x15\xED\x91\x84\x90a\x14>V[a\x15\xE8_\x84\x90a\x13\xD2V[a\x14bV[a\x14\xE8V[\x90a\x16\x10\x90\x91\x92_\x93\x84\x93c9\x144\xE3`\xE2\x1B\x85R`\x04\x85\x01a\x14\x0CV[\x03\x90\xFD[a\x16\x1Ca\x07\xC7V[Pa\x16'`\x02a\x13\xFFV[\x90V[`\x01\x80`\xD0\x1B\x03\x16\x90V[a\x16Ia\x16Da\x16N\x92a\x16*V[a\x02XV[a\x03'V[\x90V[a\x16Ya\x07\xC7V[Pa\x16i`\x01\x80`\xD0\x1B\x03a\x165V[\x90V[\x90V[\x90V[\x91a\x16\xCAa\x16\xC4a\x16\xD1\x94\x80a\x16\x98a\x16\x92a\x16\x8D_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x17\x02W[\x84a\x16\xB9a\x16\xB3a\x16\xAE_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x16\xD3W[a\x18\xFAV[\x92a\x18\xFAV[\x90\x91a\x19/V[V[a\x16\xFB`\x0B`\x02a\x16\xF5a\x16\xEFa\x16\xE9\x89a\x17\xE4V[\x93a\x16lV[\x91a\x16oV[\x90a\x187V[PPa\x16\xBFV[a\x17*`\x0B`\x01a\x17$a\x17\x1Ea\x17\x18\x89a\x17\xE4V[\x93a\x16lV[\x91a\x16oV[\x90a\x187V[PPa\x16\x9EV[_\x90V[a\x17Aa\x17G\x91a\x16*V[\x91a\x16*V[\x01\x90`\x01\x80`\xD0\x1B\x03\x82\x11a\x17XWV[a\x0C\x80V[\x90a\x17p\x91a\x17ja\x171V[Pa\x175V[\x90V[\x90V[`\xFF\x16\x90V[a\x17\x90a\x17\x8Ba\x17\x95\x92a\x17sV[a\x02XV[a\x17vV[\x90V[a\x17\xA1\x90a\x17|V[\x90RV[\x91` a\x17\xC6\x92\x94\x93a\x17\xBF`@\x82\x01\x96_\x83\x01\x90a\x17\x98V[\x01\x90a\x10dV[V[a\x17\xDCa\x17\xD7a\x17\xE1\x92a\x03'V[a\x02XV[a\x16*V[\x90V[a\x17\xECa\x171V[P\x80a\x18\x06a\x18\0`\x01\x80`\xD0\x1B\x03a\x165V[\x91a\x03'V[\x11a\x18\x17Wa\x18\x14\x90a\x17\xC8V[\x90V[`\xD0a\x183_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01a\x17\xA5V[\x03\x90\xFD[\x90a\x18ma\x18s\x93\x92a\x18Ha\x171V[Pa\x18Qa\x171V[P\x80\x93a\x18fa\x18_a\x1A\xE1V[\x94\x92a\x1B\x8EV[\x90\x91a ]V[\x91a\x1C\x03V[\x91\x90\x91\x90V[a\x18\x85a\x18\x8B\x91a\x16*V[\x91a\x16*V[\x90\x03\x90`\x01\x80`\xD0\x1B\x03\x82\x11a\x18\x9DWV[a\x0C\x80V[\x90a\x18\xB5\x91a\x18\xAFa\x171V[Pa\x18yV[\x90V[\x90a\x18\xC2\x90a\t\x97V[_R` R`@_ \x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x18\xE5a\x18\xEA\x91a\x11/V[a\x18\xCEV[\x90V[a\x18\xF7\x90Ta\x18\xD9V[\x90V[a\x19\x11a\x19\x16\x91a\x19\ta\x11\x85V[P`\ta\x18\xB8V[a\x18\xEDV[\x90V[\x90a\x19#\x90a\t\x97V[_R` R`@_ \x90V[\x91\x90\x91\x80a\x19Ea\x19?\x85a\0\xEEV[\x91a\0\xEEV[\x14\x15\x80a\x1A\xC3W[a\x19WW[PPPV[\x80a\x19ra\x19la\x19g_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x03a\x1A3W[P\x81a\x19\x94a\x19\x8Ea\x19\x89_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x03a\x19\xA0W[\x80a\x19RV[a\x19\xE7a\x19\xDAa\x19\xE1\x92a\x19\xB6`\n\x86\x90a\x19\x19V[\x90a\x19\xD4a\x19\xCEa\x19\xC8`\x01\x93a\x17\xE4V[\x93a\x16lV[\x91a\x16oV[\x90a\x187V[\x92\x90a\x165V[\x91a\x165V[\x91\x90\x91a\x1A\x14\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\t\x97V[\x92a\x1A)a\x1A a\0{V[\x92\x83\x92\x83a\x13\x1FV[\x03\x90\xA2_\x80a\x19\x9AV[a\x1Ara\x1Axa\x1Aka\x1AH`\n\x85\x90a\x19\x19V[`\x02a\x1Aea\x1A_a\x1AY\x89a\x17\xE4V[\x93a\x16lV[\x91a\x16oV[\x90a\x187V[\x92\x90a\x165V[\x91a\x165V[\x91\x90\x91a\x1A\xA5\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\t\x97V[\x92a\x1A\xBAa\x1A\xB1a\0{V[\x92\x83\x92\x83a\x13\x1FV[\x03\x90\xA2_a\x19xV[P\x81a\x1A\xD7a\x1A\xD1_a\x0C\x17V[\x91a\x03'V[\x11a\x19MV[_\x90V[a\x1A\xE9a\x1A\xDDV[Pa\x1A\xF2a\x1C2V[\x90V[T\x90V[\x90V[a\x1B\x10a\x1B\x0Ba\x1B\x15\x92a\x1A\xF9V[a\x02XV[a\x03'V[\x90V[a\x1B'a\x1B-\x91\x93\x92\x93a\x03'V[\x92a\x03'V[\x82\x03\x91\x82\x11a\x1B8WV[a\x0C\x80V[\x90V[`0\x1C\x90V[`\x01\x80`\xD0\x1B\x03\x16\x90V[a\x1B]a\x1Bb\x91a\x1B@V[a\x1BFV[\x90V[a\x1Bo\x90Ta\x1BQV[\x90V[a\x1B\x86a\x1B\x81a\x1B\x8B\x92a\x02UV[a\x02XV[a\x16*V[\x90V[a\x1B\x96a\x171V[Pa\x1B\xA2_\x82\x01a\x1A\xF5V[\x80a\x1B\xB5a\x1B\xAF_a\x0C\x17V[\x91a\x03'V[\x14_\x14a\x1B\xCBWPPa\x1B\xC7_a\x1BrV[[\x90V[a\x1B\xF8_\x91a\x1B\xF3a\x1B\xED\x84a\x1B\xFE\x96\x01\x92a\x1B\xE7`\x01a\x1A\xFCV[\x90a\x1B\x18V[\x91a\x1B=V[a\x1CGV[\x01a\x1BeV[a\x1B\xC8V[\x91a\x1C'_a\x1C,\x94a\x1C\x14a\x171V[Pa\x1C\x1Da\x171V[P\x01\x92\x91\x92a\x1B=V[a\x1E8V[\x91\x90\x91\x90V[a\x1C:a\x1A\xDDV[Pa\x1CDCa\x1F\xF6V[\x90V[_R` _ \x01\x90V[T\x90V[a\x1C_`@a\0\xCAV[\x90V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[\x90a\x1Cw\x90a\x1CbV[\x90RV[\x90a\x1C\x85\x90a\x16*V[\x90RV[_R` _ \x90V[a\x1C\x9B\x81a\x1CQV[\x82\x10\x15a\x1C\xB5Wa\x1C\xAD`\x01\x91a\x1C\x89V[\x91\x02\x01\x90_\x90V[a\r\x1AV[a\x1C\xC4\x90Qa\x1CbV[\x90V[\x90a\x1C\xD8e\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x02\x8BV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x1C\xF6a\x1C\xF1a\x1C\xFB\x92a\x1CbV[a\x02XV[a\x1CbV[\x90V[\x90V[\x90a\x1D\x16a\x1D\x11a\x1D\x1D\x92a\x1C\xE2V[a\x1C\xFEV[\x82Ta\x1C\xC7V[\x90UV[a\x1D+\x90Qa\x16*V[\x90V[`0\x1B\x90V[\x90a\x1DFe\xFF\xFF\xFF\xFF\xFF\xFF\x19\x91a\x1D.V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x1Dda\x1D_a\x1Di\x92a\x16*V[a\x02XV[a\x16*V[\x90V[\x90V[\x90a\x1D\x84a\x1D\x7Fa\x1D\x8B\x92a\x1DPV[a\x1DlV[\x82Ta\x1D4V[\x90UV[\x90a\x1D\xB9` _a\x1D\xBF\x94a\x1D\xB1\x82\x82\x01a\x1D\xAB\x84\x88\x01a\x1C\xBAV[\x90a\x1D\x01V[\x01\x92\x01a\x1D!V[\x90a\x1DoV[V[\x91\x90a\x1D\xD2Wa\x1D\xD0\x91a\x1D\x8FV[V[a\x06\xF5V[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15a\x1E\x07W\x82a\x1D\xFF\x91`\x01a\x1E\x05\x95\x01\x81Ua\x1C\x92V[\x90a\x1D\xC1V[V[a\0\x8FV[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x1E#a\x1E(\x91a\x11/V[a\x1E\x0CV[\x90V[a\x1E5\x90Ta\x1E\x17V[\x90V[\x90\x92\x91\x92a\x1EDa\x171V[Pa\x1EMa\x171V[Pa\x1EW\x82a\x1CQV[\x80a\x1Eja\x1Ed_a\x0C\x17V[\x91a\x03'V[\x11_\x14a\x1F:Wa\x1E\x90\x90a\x1E\x8A\x84\x91a\x1E\x84`\x01a\x1A\xFCV[\x90a\x1B\x18V[\x90a\x1CGV[\x90a\x1E\x9C_\x83\x01a\x1E+V[\x92a\x1E\xA8_\x84\x01a\x1BeV[\x93\x80a\x1E\xBCa\x1E\xB6\x85a\x1CbV[\x91a\x1CbV[\x11a\x1F\x1EWa\x1E\xD3a\x1E\xCD\x84a\x1CbV[\x91a\x1CbV[\x14_\x14a\x1E\xEEWPPa\x1E\xE9\x90_\x85\x91\x01a\x1DoV[[\x91\x90V[a\x1F\x19\x92Pa\x1F\x14\x86a\x1F\x0Ba\x1F\x02a\x1CUV[\x94_\x86\x01a\x1CmV[` \x84\x01a\x1C{V[a\x1D\xD7V[a\x1E\xEAV[_c% `\x1D`\xE0\x1B\x81R\x80a\x1F6`\x04\x82\x01a\x02\x83V[\x03\x90\xFD[Pa\x1Fe\x91a\x1F`\x85a\x1FWa\x1FNa\x1CUV[\x94_\x86\x01a\x1CmV[` \x84\x01a\x1C{V[a\x1D\xD7V[a\x1Fn_a\x1BrV[\x91\x90V[a\x1F\x86a\x1F\x81a\x1F\x8B\x92a\x1CbV[a\x02XV[a\x03'V[\x90V[a\x1F\xA2a\x1F\x9Da\x1F\xA7\x92a\x0C\xEEV[a\x02XV[a\x17vV[\x90V[a\x1F\xB3\x90a\x1F\x8EV[\x90RV[\x91` a\x1F\xD8\x92\x94\x93a\x1F\xD1`@\x82\x01\x96_\x83\x01\x90a\x1F\xAAV[\x01\x90a\x10dV[V[a\x1F\xEEa\x1F\xE9a\x1F\xF3\x92a\x03'V[a\x02XV[a\x1CbV[\x90V[a\x1F\xFEa\x1A\xDDV[P\x80a \x18a \x12e\xFF\xFF\xFF\xFF\xFF\xFFa\x1FrV[\x91a\x03'V[\x11a )Wa &\x90a\x1F\xDAV[\x90V[`0a E_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01a\x1F\xB7V[\x03\x90\xFD[cNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[\x91\x90\x91\x80`\x01\x14a |W`\x02\x03a IWa x\x91a\x18\xA2V[\x90[V[Pa \x86\x91a\x17]V[\x90a zV\xFE`\x80`@R`\x046\x10\x15a\0\x13W[a#\x82V[a\0\x1D_5a\x04\xDCV[\x80c\x01\xFF\xC9\xA7\x14a\x04\xD7W\x80c\x06\xFD\xDE\x03\x14a\x04\xD2W\x80c\x07\xA1\xD5\xFA\x14a\x04\xCDW\x80c\t^\xA7\xB3\x14a\x04\xC8W\x80c\x0C\x05\xF8,\x14a\x04\xC3W\x80c\x13\xBE\xAA[\x14a\x04\xBEW\x80c\x18\x16\r\xDD\x14a\x04\xB9W\x80c\x1B\x02\xF8E\x14a\x04\xB4W\x80c\"\xA9}\x9C\x14a\x04\xAFW\x80c#\xB8r\xDD\x14a\x04\xAAW\x80c#\xE4`\xD2\x14a\x04\xA5W\x80c$\x81\xBB\\\x14a\x04\xA0W\x80c$\x8A\x9C\xA3\x14a\x04\x9BW\x80c(N\x133\x14a\x04\x96W\x80c//\xF1]\x14a\x04\x91W\x80c1<\xE5g\x14a\x04\x8CW\x80c3M\x0B\xBD\x14a\x04\x87W\x80c5\x9Bv\xFE\x14a\x04\x82W\x80c6D\xE5\x15\x14a\x04}W\x80c6V\x8A\xBE\x14a\x04xW\x80c:F\xB1\xA8\x14a\x04sW\x80c?K\xA8:\x14a\x04nW\x80c@\xC1\x0F\x19\x14a\x04iW\x80cD\xE1\x81\xAA\x14a\x04dW\x80cH\xB0\xDA\xA6\x14a\x04_W\x80cK\xDD6\xCE\x14a\x04ZW\x80cK\xF5\xD7\xE9\x14a\x04UW\x80cX|\xDE\x1E\x14a\x04PW\x80cZ\xDF\0!\x14a\x04KW\x80c\\\x19\xA9\\\x14a\x04FW\x80c\\\x97Z\xBB\x14a\x04AW\x80c_\x15\xC3\xC9\x14a\x04<W\x80ce\x1F\xD2h\x14a\x047W\x80cl3\xBC\xED\x14a\x042W\x80cl\xF0\x16%\x14a\x04-W\x80co\xC0c\xBE\x14a\x04(W\x80co\xCF\xFFE\x14a\x04#W\x80cp\xA0\x821\x14a\x04\x1EW\x80crf\0\xCE\x14a\x04\x19W\x80cvg\x18\x08\x14a\x04\x14W\x80c|y\x0C\xAB\x14a\x04\x0FW\x80c~\xCE\xBE\0\x14a\x04\nW\x80c\x84V\xCBY\x14a\x04\x05W\x80c\x84\xB0\x19n\x14a\x04\0W\x80c\x8ES\x9E\x8C\x14a\x03\xFBW\x80c\x90-U\xA5\x14a\x03\xF6W\x80c\x91\xD1HT\x14a\x03\xF1W\x80c\x91\xDD\xAD\xF4\x14a\x03\xECW\x80c\x95\xD8\x9BA\x14a\x03\xE7W\x80c\x99\x12}\x9B\x14a\x03\xE2W\x80c\x99\x89U\xD3\x14a\x03\xDDW\x80c\x9A\xB2N\xB0\x14a\x03\xD8W\x80c\x9B~\xF6K\x14a\x03\xD3W\x80c\x9D\xC2\x9F\xAC\x14a\x03\xCEW\x80c\xA0\x8DVT\x14a\x03\xC9W\x80c\xA2\x17\xFD\xDF\x14a\x03\xC4W\x80c\xA3\xD4H[\x14a\x03\xBFW\x80c\xA4\xD7\xE3\x1D\x14a\x03\xBAW\x80c\xA5q\xE1\x84\x14a\x03\xB5W\x80c\xA7\x0B\x9F\x0C\x14a\x03\xB0W\x80c\xA9\x05\x9C\xBB\x14a\x03\xABW\x80c\xAF*\xA6;\x14a\x03\xA6W\x80c\xB0\xCA%>\x14a\x03\xA1W\x80c\xBA\xBC9O\x14a\x03\x9CW\x80c\xBBMD6\x14a\x03\x97W\x80c\xC0*\xE7T\x14a\x03\x92W\x80c\xC1\xEBq7\x14a\x03\x8DW\x80c\xC3\xCD\xA5 \x14a\x03\x88W\x80c\xD5\x05\xAC\xCF\x14a\x03\x83W\x80c\xD5Gt\x1F\x14a\x03~W\x80c\xDDb\xED>\x14a\x03yW\x80c\xE3\xAB\xDF\xCB\x14a\x03tW\x80c\xE6:\xB1\xE9\x14a\x03oW\x80c\xF1\x12~\xD8\x14a\x03jW\x80c\xF5\x08\xE1\x9D\x14a\x03eWc\xF7^\x85\x12\x03a\0\x0EWa#MV[a\"\xE9V[a\"\xA4V[a!\xC1V[a!]V[a \xF8V[a \x97V[a ]V[a\x1F\xB3V[a\x1E\xF7V[a\x1E\xC2V[a\x1E\x8DV[a\x1ETV[a\x1D\xE0V[a\x1D\xABV[a\x1D\0V[a\x1C\xCBV[a\x1C_V[a\x1C*V[a\x1B\xF5V[a\x1B\x80V[a\x1B\x11V[a\x1A\xA3V[a\x1AnV[a\x19\xF8V[a\x19\xC3V[a\x19\x8EV[a\x19 V[a\x18\xEBV[a\x18\x88V[a\x18SV[a\x17\xDDV[a\x17\xA1V[a\x16\\V[a\x16'V[a\x15\xEEV[a\x15lV[a\x15(V[a\x14\xF3V[a\x14\xBEV[a\x14^V[a\x13\xFAV[a\x13\x86V[a\x13QV[a\x13\x1CV[a\x12\xB0V[a\x12}V[a\x12HV[a\x12\x13V[a\x11\xC9V[a\x11\x94V[a\x11_V[a\x11\x17V[a\x0F\xD7V[a\x0F\xA4V[a\x0FnV[a\x0F:V[a\x0F\x05V[a\x0E\xD2V[a\x0E\x9DV[a\r\xB0V[a\rTV[a\x0C\xF4V[a\x0C\xBFV[a\x0C$V[a\nTV[a\t\xFBV[a\t\x8CV[a\t\x1AV[a\x08\xE5V[a\x08\xB1V[a\x07\xF6V[a\x07\x80V[a\x06\xD4V[a\x06\x17V[a\x05hV[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x80\xFD[c\xFF\xFF\xFF\xFF`\xE0\x1B\x16\x90V[a\x05\t\x81a\x04\xF4V[\x03a\x05\x10WV[_\x80\xFD[\x90P5\x90a\x05!\x82a\x05\0V[V[\x90` \x82\x82\x03\x12a\x05<Wa\x059\x91_\x01a\x05\x14V[\x90V[a\x04\xECV[\x15\x15\x90V[a\x05O\x90a\x05AV[\x90RV[\x91\x90a\x05f\x90_` \x85\x01\x94\x01\x90a\x05FV[V[4a\x05\x98Wa\x05\x94a\x05\x83a\x05~6`\x04a\x05#V[a$\x1FV[a\x05\x8Ba\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[_\x91\x03\x12a\x05\xA7WV[a\x04\xECV[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[`\x1F\x80\x19\x91\x01\x16\x90V[a\x05\xEDa\x05\xF6` \x93a\x05\xFB\x93a\x05\xE4\x81a\x05\xACV[\x93\x84\x80\x93a\x05\xB0V[\x95\x86\x91\x01a\x05\xB9V[a\x05\xC4V[\x01\x90V[a\x06\x14\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x05\xCEV[\x90V[4a\x06GWa\x06'6`\x04a\x05\x9DV[a\x06Ca\x062a%=V[a\x06:a\x04\xE2V[\x91\x82\x91\x82a\x05\xFFV[\x03\x90\xF3[a\x04\xE8V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x06`\x90a\x06LV[\x90V[a\x06l\x90a\x06WV[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[a\x06\x9Ca\x06\xA5` \x93a\x06\xAA\x93a\x06\x93\x81a\x06pV[\x93\x84\x80\x93a\x06tV[\x95\x86\x91\x01a\x05\xB9V[a\x05\xC4V[\x01\x90V[\x91a\x06\xD1\x92a\x06\xC4`@\x82\x01\x93_\x83\x01\x90a\x06cV[` \x81\x84\x03\x91\x01Ra\x06}V[\x90V[4a\x07\x05Wa\x06\xE46`\x04a\x05\x9DV[a\x06\xECa%\x89V[\x90a\x07\x01a\x06\xF8a\x04\xE2V[\x92\x83\x92\x83a\x06\xAEV[\x03\x90\xF3[a\x04\xE8V[a\x07\x13\x81a\x06WV[\x03a\x07\x1AWV[_\x80\xFD[\x90P5\x90a\x07+\x82a\x07\nV[V[\x90V[a\x079\x81a\x07-V[\x03a\x07@WV[_\x80\xFD[\x90P5\x90a\x07Q\x82a\x070V[V[\x91\x90`@\x83\x82\x03\x12a\x07{W\x80a\x07oa\x07x\x92_\x86\x01a\x07\x1EV[\x93` \x01a\x07DV[\x90V[a\x04\xECV[4a\x07\xB1Wa\x07\xADa\x07\x9Ca\x07\x966`\x04a\x07SV[\x90a%\xB3V[a\x07\xA4a\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[\x90` \x82\x82\x03\x12a\x07\xCFWa\x07\xCC\x91_\x01a\x07\x1EV[\x90V[a\x04\xECV[a\x07\xDD\x90a\x07-V[\x90RV[\x91\x90a\x07\xF4\x90_` \x85\x01\x94\x01\x90a\x07\xD4V[V[4a\x08&Wa\x08\"a\x08\x11a\x08\x0C6`\x04a\x07\xB6V[a%\xD9V[a\x08\x19a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x08qW\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x08lW` \x01\x92`\x01\x83\x02\x84\x01\x11a\x08gWV[a\x083V[a\x08/V[a\x08+V[\x90` \x82\x82\x03\x12a\x08\xA7W_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x08\xA2Wa\x08\x9E\x92\x01a\x087V[\x90\x91V[a\x04\xF0V[a\x04\xECV[_\x01\x90V[4a\x08\xE0Wa\x08\xCAa\x08\xC46`\x04a\x08vV[\x90a(\xCAV[a\x08\xD2a\x04\xE2V[\x80a\x08\xDC\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[4a\t\x15Wa\x08\xF56`\x04a\x05\x9DV[a\t\x11a\t\0a(\xD6V[a\t\x08a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\tHWa\t*6`\x04a\x05\x9DV[a\t2a*\x9AV[a\t:a\x04\xE2V[\x80a\tD\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x1C\x90V[`\xFF\x16\x90V[a\tg\x90`\x08a\tl\x93\x02a\tMV[a\tQV[\x90V[\x90a\tz\x91Ta\tWV[\x90V[a\t\x89`?_\x90a\toV[\x90V[4a\t\xBCWa\t\x9C6`\x04a\x05\x9DV[a\t\xB8a\t\xA7a\t}V[a\t\xAFa\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[\x90\x91``\x82\x84\x03\x12a\t\xF6Wa\t\xF3a\t\xDC\x84_\x85\x01a\x07\x1EV[\x93a\t\xEA\x81` \x86\x01a\x07\x1EV[\x93`@\x01a\x07DV[\x90V[a\x04\xECV[4a\n,Wa\n(a\n\x17a\n\x116`\x04a\t\xC1V[\x91a*\xA4V[a\n\x1Fa\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[\x91` a\nR\x92\x94\x93a\nK`@\x82\x01\x96_\x83\x01\x90a\x07\xD4V[\x01\x90a\x07\xD4V[V[4a\n\x85Wa\nla\ng6`\x04a\x07\xB6V[a+\xD5V[\x90a\n\x81a\nxa\x04\xE2V[\x92\x83\x92\x83a\n1V[\x03\x90\xF3[a\x04\xE8V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\n\xD1W[` \x83\x10\x14a\n\xCCWV[a\n\x9DV[\x91`\x7F\x16\x91a\n\xC1V[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x0B\x07a\x0B\0\x83a\n\xB1V[\x80\x94a\n\xDBV[\x91`\x01\x81\x16\x90\x81_\x14a\x0B^WP`\x01\x14a\x0B\"W[PPPV[a\x0B/\x91\x92\x93\x94Pa\n\xE4V[\x91_\x92[\x81\x84\x10a\x0BFWPP\x01\x90_\x80\x80a\x0B\x1DV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x0B3V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x0B\x1DV[\x90a\x0B\x83\x91a\n\xEDV[\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x0B\xA4\x90a\x05\xC4V[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x0B\xBEW`@RV[a\x0B\x86V[\x90a\x0B\xE3a\x0B\xDC\x92a\x0B\xD3a\x04\xE2V[\x93\x84\x80\x92a\x0ByV[\x03\x83a\x0B\x9AV[V[\x90_\x10a\x0B\xF8Wa\x0B\xF5\x90a\x0B\xC3V[\x90V[a\n\x8AV[a\x0C\t`D_\x90a\x0B\xE5V[\x90V[a\x0C!\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x06}V[\x90V[4a\x0CTWa\x0C46`\x04a\x05\x9DV[a\x0CPa\x0C?a\x0B\xFDV[a\x0CGa\x04\xE2V[\x91\x82\x91\x82a\x0C\x0CV[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x0Ce\x81a\x0CYV[\x03a\x0ClWV[_\x80\xFD[\x90P5\x90a\x0C}\x82a\x0C\\V[V[\x90` \x82\x82\x03\x12a\x0C\x98Wa\x0C\x95\x91_\x01a\x0CpV[\x90V[a\x04\xECV[a\x0C\xA6\x90a\x0CYV[\x90RV[\x91\x90a\x0C\xBD\x90_` \x85\x01\x94\x01\x90a\x0C\x9DV[V[4a\x0C\xEFWa\x0C\xEBa\x0C\xDAa\x0C\xD56`\x04a\x0C\x7FV[a-\xF6V[a\x0C\xE2a\x04\xE2V[\x91\x82\x91\x82a\x0C\xAAV[\x03\x90\xF3[a\x04\xE8V[4a\r\"Wa\r\x046`\x04a\x05\x9DV[a\r\x0Ca2\xCDV[a\r\x14a\x04\xE2V[\x80a\r\x1E\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x91\x90`@\x83\x82\x03\x12a\rOW\x80a\rCa\rL\x92_\x86\x01a\x0CpV[\x93` \x01a\x07\x1EV[\x90V[a\x04\xECV[4a\r\x83Wa\rma\rg6`\x04a\r'V[\x90a3\x01V[a\rua\x04\xE2V[\x80a\r\x7F\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[`\xFF\x16\x90V[a\r\x97\x90a\r\x88V[\x90RV[\x91\x90a\r\xAE\x90_` \x85\x01\x94\x01\x90a\r\x8EV[V[4a\r\xE0Wa\r\xC06`\x04a\x05\x9DV[a\r\xDCa\r\xCBa30V[a\r\xD3a\x04\xE2V[\x91\x82\x91\x82a\r\x9BV[\x03\x90\xF3[a\x04\xE8V[\x90` \x82\x82\x03\x12a\r\xFEWa\r\xFB\x91_\x01a\x07DV[\x90V[a\x04\xECV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[P`0\x90V[\x90V[a\x0E)\x81a\x0E\x17V[\x82\x10\x15a\x0ECWa\x0E;`\x01\x91a\x0E\x1DV[\x91\x02\x01\x90_\x90V[a\x0E\x03V[\x90V[a\x0E[\x90`\x08a\x0E`\x93\x02a\tMV[a\x0EHV[\x90V[\x90a\x0En\x91Ta\x0EKV[\x90V[`\x0Fa\x0E|\x81a\x0E\x17V[\x82\x10\x15a\x0E\x99Wa\x0E\x96\x91a\x0E\x90\x91a\x0E V[\x90a\x0EcV[\x90V[_\x80\xFD[4a\x0E\xCDWa\x0E\xC9a\x0E\xB8a\x0E\xB36`\x04a\r\xE5V[a\x0EqV[a\x0E\xC0a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x0F\0Wa\x0E\xE26`\x04a\x05\x9DV[a\x0E\xEAa3\xE1V[a\x0E\xF2a\x04\xE2V[\x80a\x0E\xFC\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[4a\x0F5Wa\x0F\x156`\x04a\x05\x9DV[a\x0F1a\x0F a3\xEBV[a\x0F(a\x04\xE2V[\x91\x82\x91\x82a\x0C\xAAV[\x03\x90\xF3[a\x04\xE8V[4a\x0FiWa\x0FSa\x0FM6`\x04a\r'V[\x90a3\xFFV[a\x0F[a\x04\xE2V[\x80a\x0Fe\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[4a\x0F\x9FWa\x0F\x9Ba\x0F\x8Aa\x0F\x846`\x04a\x07SV[\x90a4|V[a\x0F\x92a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x0F\xD2Wa\x0F\xB46`\x04a\x05\x9DV[a\x0F\xBCa4\xDAV[a\x0F\xC4a\x04\xE2V[\x80a\x0F\xCE\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[4a\x10\x06Wa\x0F\xF0a\x0F\xEA6`\x04a\x07SV[\x90a4\xE4V[a\x0F\xF8a\x04\xE2V[\x80a\x10\x02\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x10\"a\x10\x1Da\x10'\x92a\x06LV[a\x10\x0BV[a\x06LV[\x90V[a\x103\x90a\x10\x0EV[\x90V[a\x10?\x90a\x10*V[\x90V[\x90a\x10L\x90a\x106V[_R` R`@_ \x90V[_\x1C\x90V[a\x10ia\x10n\x91a\x10XV[a\x0EHV[\x90V[a\x10{\x90Ta\x10]V[\x90V[a\x10\x89\x90`\x0Ca\x10BV[a\x10\x94_\x82\x01a\x10qV[\x91a\x10\xA1`\x01\x83\x01a\x10qV[\x91a\x10\xAE`\x02\x82\x01a\x10qV[\x91a\x10\xC7`\x04a\x10\xC0`\x03\x85\x01a\x10qV[\x93\x01a\x10qV[\x90V[\x90\x95\x94\x92a\x11\x15\x94a\x11\x04a\x11\x0E\x92a\x10\xFA`\x80\x96a\x10\xF0`\xA0\x88\x01\x9C_\x89\x01\x90a\x07\xD4V[` \x87\x01\x90a\x07\xD4V[`@\x85\x01\x90a\x07\xD4V[``\x83\x01\x90a\x07\xD4V[\x01\x90a\x07\xD4V[V[4a\x11KWa\x11Ga\x112a\x11-6`\x04a\x07\xB6V[a\x10~V[\x91a\x11>\x95\x93\x95a\x04\xE2V[\x95\x86\x95\x86a\x10\xCAV[\x03\x90\xF3[a\x04\xE8V[a\x11\\`@_\x90a\x0EcV[\x90V[4a\x11\x8FWa\x11o6`\x04a\x05\x9DV[a\x11\x8Ba\x11za\x11PV[a\x11\x82a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x11\xC4Wa\x11\xA46`\x04a\x05\x9DV[a\x11\xC0a\x11\xAFa6\x1BV[a\x11\xB7a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x11\xF9Wa\x11\xD96`\x04a\x05\x9DV[a\x11\xF5a\x11\xE4a6\xDCV[a\x11\xECa\x04\xE2V[\x91\x82\x91\x82a\x05\xFFV[\x03\x90\xF3[a\x04\xE8V[\x91\x90a\x12\x11\x90_` \x85\x01\x94\x01\x90a\x06cV[V[4a\x12CWa\x12?a\x12.a\x12)6`\x04a\x07\xB6V[a7HV[a\x126a\x04\xE2V[\x91\x82\x91\x82a\x11\xFEV[\x03\x90\xF3[a\x04\xE8V[4a\x12xWa\x12X6`\x04a\x05\x9DV[a\x12ta\x12ca7gV[a\x12ka\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[4a\x12\xABWa\x12\x95a\x12\x906`\x04a\x07\xB6V[a7\x90V[a\x12\x9Da\x04\xE2V[\x80a\x12\xA7\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[4a\x12\xE0Wa\x12\xC06`\x04a\x05\x9DV[a\x12\xDCa\x12\xCBa7\xA3V[a\x12\xD3a\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x12\xFCa\x12\xF7a\x13\x01\x92a\x12\xE5V[a\x10\x0BV[a\x07-V[\x90V[a\x13\x0E`0a\x12\xE8V[\x90V[a\x13\x19a\x13\x04V[\x90V[4a\x13LWa\x13,6`\x04a\x05\x9DV[a\x13Ha\x137a\x13\x11V[a\x13?a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x13\x81Wa\x13}a\x13la\x13g6`\x04a\x07\xB6V[a7\xB9V[a\x13ta\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x13\xB4Wa\x13\x966`\x04a\x05\x9DV[a\x13\x9Ea8pV[a\x13\xA6a\x04\xE2V[\x80a\x13\xB0\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x13\xD0a\x13\xCBa\x13\xD5\x92a\x13\xB9V[a\x10\x0BV[a\x07-V[\x90V[a\x13\xECj\x08E\x95\x16\x14\x01HJ\0\0\0a\x13\xBCV[\x90V[a\x13\xF7a\x13\xD8V[\x90V[4a\x14*Wa\x14\n6`\x04a\x05\x9DV[a\x14&a\x14\x15a\x13\xEFV[a\x14\x1Da\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[\x90a\x149\x90a\x106V[_R` R`@_ \x90V[a\x14[\x90a\x14V`\r\x91_\x92a\x14/V[a\toV[\x90V[4a\x14\x8EWa\x14\x8Aa\x14ya\x14t6`\x04a\x07\xB6V[a\x14EV[a\x14\x81a\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[c\xFF\xFF\xFF\xFF\x16\x90V[a\x14\xA5\x90a\x14\x93V[\x90RV[\x91\x90a\x14\xBC\x90_` \x85\x01\x94\x01\x90a\x14\x9CV[V[4a\x14\xEEWa\x14\xEAa\x14\xD9a\x14\xD46`\x04a\x07\xB6V[a8~V[a\x14\xE1a\x04\xE2V[\x91\x82\x91\x82a\x14\xA9V[\x03\x90\xF3[a\x04\xE8V[4a\x15#Wa\x15\x1Fa\x15\x0Ea\x15\t6`\x04a\x07\xB6V[a8\xA9V[a\x15\x16a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x15XWa\x15Ta\x15Ca\x15>6`\x04a\x07\xB6V[a8\xC7V[a\x15Ka\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[a\x15i`A_\x90a\x0EcV[\x90V[4a\x15\x9CWa\x15|6`\x04a\x05\x9DV[a\x15\x98a\x15\x87a\x15]V[a\x15\x8Fa\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[\x90\x95\x94\x92a\x15\xEC\x94a\x15\xDBa\x15\xE5\x92a\x15\xD1`\x80\x96a\x15\xC7`\xA0\x88\x01\x9C_\x89\x01\x90a\x05FV[` \x87\x01\x90a\x07\xD4V[`@\x85\x01\x90a\x07\xD4V[``\x83\x01\x90a\x07\xD4V[\x01\x90a\x07\xD4V[V[4a\x16\"Wa\x16\x1Ea\x16\ta\x16\x046`\x04a\x07\xB6V[a8\xE6V[\x91a\x16\x15\x95\x93\x95a\x04\xE2V[\x95\x86\x95\x86a\x15\xA1V[\x03\x90\xF3[a\x04\xE8V[4a\x16WWa\x16Sa\x16Ba\x16=6`\x04a\x07\xB6V[a:VV[a\x16Ja\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x16\x8AWa\x16l6`\x04a\x05\x9DV[a\x16ta:\x8FV[a\x16|a\x04\xE2V[\x80a\x16\x86\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[`\xFF`\xF8\x1B\x16\x90V[a\x16\xA1\x90a\x16\x8FV[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[` \x01\x90V[a\x16\xC1\x90a\x07-V[\x90RV[\x90a\x16\xD2\x81` \x93a\x16\xB8V[\x01\x90V[` \x01\x90V[\x90a\x16\xF9a\x16\xF3a\x16\xEC\x84a\x16\xA5V[\x80\x93a\x16\xA9V[\x92a\x16\xB2V[\x90_[\x81\x81\x10a\x17\tWPPP\x90V[\x90\x91\x92a\x17\"a\x17\x1C`\x01\x92\x86Qa\x16\xC5V[\x94a\x16\xD6V[\x91\x01\x91\x90\x91a\x16\xFCV[\x93\x95\x91\x94a\x17}a\x17ra\x17\x91\x95a\x17da\x17\x87\x95a\x17\x9E\x9C\x9Aa\x17W`\xE0\x8C\x01\x92_\x8D\x01\x90a\x16\x98V[\x8A\x82\x03` \x8C\x01Ra\x05\xCEV[\x90\x88\x82\x03`@\x8A\x01Ra\x05\xCEV[\x97``\x87\x01\x90a\x07\xD4V[`\x80\x85\x01\x90a\x06cV[`\xA0\x83\x01\x90a\x0C\x9DV[`\xC0\x81\x84\x03\x91\x01Ra\x16\xDCV[\x90V[4a\x17\xD8Wa\x17\xB16`\x04a\x05\x9DV[a\x17\xD4a\x17\xBCa;\x16V[\x93a\x17\xCB\x97\x95\x97\x93\x91\x93a\x04\xE2V[\x97\x88\x97\x88a\x17,V[\x03\x90\xF3[a\x04\xE8V[4a\x18\rWa\x18\ta\x17\xF8a\x17\xF36`\x04a\r\xE5V[a;\xA0V[a\x18\0a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x18)a\x18$a\x18.\x92a\x18\x12V[a\x10\x0BV[a\x07-V[\x90V[a\x18EjR\xB7\xD2\xDC\xC8\x0C\xD2\xE4\0\0\0a\x18\x15V[\x90V[a\x18Pa\x181V[\x90V[4a\x18\x83Wa\x18c6`\x04a\x05\x9DV[a\x18\x7Fa\x18na\x18HV[a\x18va\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x18\xB9Wa\x18\xB5a\x18\xA4a\x18\x9E6`\x04a\r'V[\x90a;\xD1V[a\x18\xACa\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x18\xD2\x90a\x18\xBEV[\x90RV[\x91\x90a\x18\xE9\x90_` \x85\x01\x94\x01\x90a\x18\xC9V[V[4a\x19\x1BWa\x18\xFB6`\x04a\x05\x9DV[a\x19\x17a\x19\x06a;\xFFV[a\x19\x0Ea\x04\xE2V[\x91\x82\x91\x82a\x18\xD6V[\x03\x90\xF3[a\x04\xE8V[4a\x19PWa\x1906`\x04a\x05\x9DV[a\x19La\x19;a<\x13V[a\x19Ca\x04\xE2V[\x91\x82\x91\x82a\x05\xFFV[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x19la\x19ga\x19q\x92a\x19UV[a\x10\x0BV[a\x07-V[\x90V[a\x19\x80b\x01Q\x80a\x19XV[\x90V[a\x19\x8Ba\x19tV[\x90V[4a\x19\xBEWa\x19\x9E6`\x04a\x05\x9DV[a\x19\xBAa\x19\xA9a\x19\x83V[a\x19\xB1a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x19\xF3Wa\x19\xEFa\x19\xDEa\x19\xD96`\x04a\x07\xB6V[a<)V[a\x19\xE6a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x1A(Wa\x1A$a\x1A\x13a\x1A\x0E6`\x04a\x07\xB6V[a<\x84V[a\x1A\x1Ba\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x1ADa\x1A?a\x1AI\x92a\x1A-V[a\x10\x0BV[a\x07-V[\x90V[a\x1A`jJr=\xC6\xB4\x0B\x8A\x9A\0\0\0a\x1A0V[\x90V[a\x1Aka\x1ALV[\x90V[4a\x1A\x9EWa\x1A~6`\x04a\x05\x9DV[a\x1A\x9Aa\x1A\x89a\x1AcV[a\x1A\x91a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x1A\xD2Wa\x1A\xBCa\x1A\xB66`\x04a\x07SV[\x90a<\xB3V[a\x1A\xC4a\x04\xE2V[\x80a\x1A\xCE\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x90\x91``\x82\x84\x03\x12a\x1B\x0CWa\x1B\ta\x1A\xF2\x84_\x85\x01a\x07\x1EV[\x93a\x1B\0\x81` \x86\x01a\x07DV[\x93`@\x01a\x07DV[\x90V[a\x04\xECV[4a\x1B@Wa\x1B*a\x1B$6`\x04a\x1A\xD7V[\x91a@dV[a\x1B2a\x04\xE2V[\x80a\x1B<\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x90V[_\x1B\x90V[a\x1Baa\x1B\\a\x1Bf\x92a\x1BEV[a\x1BHV[a\x0CYV[\x90V[a\x1Br_a\x1BMV[\x90V[a\x1B}a\x1BiV[\x90V[4a\x1B\xB0Wa\x1B\x906`\x04a\x05\x9DV[a\x1B\xACa\x1B\x9Ba\x1BuV[a\x1B\xA3a\x04\xE2V[\x91\x82\x91\x82a\x0C\xAAV[\x03\x90\xF3[a\x04\xE8V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x1B\xD0\x90`\x08a\x1B\xD5\x93\x02a\tMV[a\x1B\xB5V[\x90V[\x90a\x1B\xE3\x91Ta\x1B\xC0V[\x90V[a\x1B\xF2`C_\x90a\x1B\xD8V[\x90V[4a\x1C%Wa\x1C\x056`\x04a\x05\x9DV[a\x1C!a\x1C\x10a\x1B\xE6V[a\x1C\x18a\x04\xE2V[\x91\x82\x91\x82a\x11\xFEV[\x03\x90\xF3[a\x04\xE8V[4a\x1CZWa\x1C:6`\x04a\x05\x9DV[a\x1CVa\x1CEa@qV[a\x1CMa\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[4a\x1C\x8DWa\x1Cwa\x1Cr6`\x04a\x07\xB6V[aA\x98V[a\x1C\x7Fa\x04\xE2V[\x80a\x1C\x89\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x1C\xA9a\x1C\xA4a\x1C\xAE\x92a\x1C\x92V[a\x10\x0BV[a\x07-V[\x90V[a\x1C\xBDb'\x8D\0a\x1C\x95V[\x90V[a\x1C\xC8a\x1C\xB1V[\x90V[4a\x1C\xFBWa\x1C\xDB6`\x04a\x05\x9DV[a\x1C\xF7a\x1C\xE6a\x1C\xC0V[a\x1C\xEEa\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x1D1Wa\x1D-a\x1D\x1Ca\x1D\x166`\x04a\x07SV[\x90aA\xA3V[a\x1D$a\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[P`0\x90V[\x90P\x90V[\x90V[` \x01\x90V[a\x1Dfa\x1D`a\x1DY\x83a\x1D6V[\x80\x94a\x1D<V[\x91a\x1DAV[_\x91[\x83\x83\x10a\x1DvWPPPPV[a\x1D\x8Ca\x1D\x86`\x01\x92\x84Qa\x16\xC5V[\x92a\x1DDV[\x92\x01\x91\x90a\x1DiV[\x91\x90a\x1D\xA9\x90_a\x06\0\x85\x01\x94\x01\x90a\x1DJV[V[4a\x1D\xDBWa\x1D\xBB6`\x04a\x05\x9DV[a\x1D\xD7a\x1D\xC6aB\xCAV[a\x1D\xCEa\x04\xE2V[\x91\x82\x91\x82a\x1D\x95V[\x03\x90\xF3[a\x04\xE8V[4a\x1E\x11Wa\x1E\ra\x1D\xFCa\x1D\xF66`\x04a\x07SV[\x90aB\xE0V[a\x1E\x04a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[a\x1EKa\x1ER\x94a\x1EA``\x94\x98\x97\x95a\x1E7`\x80\x86\x01\x9A_\x87\x01\x90a\x07\xD4V[` \x85\x01\x90a\x07\xD4V[`@\x83\x01\x90a\x07\xD4V[\x01\x90a\x05FV[V[4a\x1E\x88Wa\x1Ed6`\x04a\x05\x9DV[a\x1E\x84a\x1EoaC\x15V[\x90a\x1E{\x94\x92\x94a\x04\xE2V[\x94\x85\x94\x85a\x1E\x16V[\x03\x90\xF3[a\x04\xE8V[4a\x1E\xBDWa\x1E\xB9a\x1E\xA8a\x1E\xA36`\x04a\x07\xB6V[aD\xBAV[a\x1E\xB0a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x1E\xF2Wa\x1E\xD26`\x04a\x05\x9DV[a\x1E\xEEa\x1E\xDDaD\xCFV[a\x1E\xE5a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x1F'Wa\x1F#a\x1F\x12a\x1F\r6`\x04a\x07\xB6V[aD\xE3V[a\x1F\x1Aa\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[a\x1F5\x81a\r\x88V[\x03a\x1F<WV[_\x80\xFD[\x90P5\x90a\x1FM\x82a\x1F,V[V[\x90\x91`\xC0\x82\x84\x03\x12a\x1F\xAEWa\x1Fg\x83_\x84\x01a\x07\x1EV[\x92a\x1Fu\x81` \x85\x01a\x07DV[\x92a\x1F\x83\x82`@\x83\x01a\x07DV[\x92a\x1F\xABa\x1F\x94\x84``\x85\x01a\x1F@V[\x93a\x1F\xA2\x81`\x80\x86\x01a\x0CpV[\x93`\xA0\x01a\x0CpV[\x90V[a\x04\xECV[4a\x1F\xE8Wa\x1F\xD2a\x1F\xC66`\x04a\x1FOV[\x94\x93\x90\x93\x92\x91\x92aEmV[a\x1F\xDAa\x04\xE2V[\x80a\x1F\xE4\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[`\xE0\x81\x83\x03\x12a XWa \x03\x82_\x83\x01a\x07\x1EV[\x92a \x11\x83` \x84\x01a\x07\x1EV[\x92a \x1F\x81`@\x85\x01a\x07DV[\x92a -\x82``\x83\x01a\x07DV[\x92a Ua >\x84`\x80\x85\x01a\x1F@V[\x93a L\x81`\xA0\x86\x01a\x0CpV[\x93`\xC0\x01a\x0CpV[\x90V[a\x04\xECV[4a \x92Wa |a p6`\x04a\x1F\xEDV[\x95\x94\x90\x94\x93\x91\x93aF\xC1V[a \x84a\x04\xE2V[\x80a \x8E\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[4a \xC6Wa \xB0a \xAA6`\x04a\r'V[\x90aG\xDFV[a \xB8a\x04\xE2V[\x80a \xC2\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x91\x90`@\x83\x82\x03\x12a \xF3W\x80a \xE7a \xF0\x92_\x86\x01a\x07\x1EV[\x93` \x01a\x07\x1EV[\x90V[a\x04\xECV[4a!)Wa!%a!\x14a!\x0E6`\x04a \xCBV[\x90aH\x01V[a!\x1Ca\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[\x7Fk\x97%\xF7@\xF9K\x91\xB7\x80`\xA1\xB1}\x17tem8\x14!\xA5)\xEC\x98\xCD\xB0\x13\xF4\xD9\xC2^\x90V[a!Za!.V[\x90V[4a!\x8DWa!m6`\x04a\x05\x9DV[a!\x89a!xa!RV[a!\x80a\x04\xE2V[\x91\x82\x91\x82a\x0C\xAAV[\x03\x90\xF3[a\x04\xE8V[\x7Fe\xD7\xA2\x8E2e\xB3zdt\x92\x9F3e!\xB32\xC1h\x1B\x93?l\xB9\xF37fsD\r\x86*\x90V[a!\xBEa!\x92V[\x90V[4a!\xF1Wa!\xD16`\x04a\x05\x9DV[a!\xEDa!\xDCa!\xB6V[a!\xE4a\x04\xE2V[\x91\x82\x91\x82a\x0C\xAAV[\x03\x90\xF3[a\x04\xE8V[a!\xFF\x81a\x14\x93V[\x03a\"\x06WV[_\x80\xFD[\x90P5\x90a\"\x17\x82a!\xF6V[V[\x91\x90`@\x83\x82\x03\x12a\"AW\x80a\"5a\">\x92_\x86\x01a\x07\x1EV[\x93` \x01a\"\nV[\x90V[a\x04\xECV[a\"O\x90a\x18\xBEV[\x90RV[`\x01\x80`\xD0\x1B\x03\x16\x90V[a\"g\x90a\"SV[\x90RV[\x90` \x80a\"\x8D\x93a\"\x83_\x82\x01Q_\x86\x01\x90a\"FV[\x01Q\x91\x01\x90a\"^V[V[\x91\x90a\"\xA2\x90_`@\x85\x01\x94\x01\x90a\"kV[V[4a\"\xD5Wa\"\xD1a\"\xC0a\"\xBA6`\x04a\"\x19V[\x90aHoV[a\"\xC8a\x04\xE2V[\x91\x82\x91\x82a\"\x8FV[\x03\x90\xF3[a\x04\xE8V[a\"\xE6`B_\x90a\x0EcV[\x90V[4a#\x19Wa\"\xF96`\x04a\x05\x9DV[a#\x15a#\x04a\"\xDAV[a#\x0Ca\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[\x7F\xCC\xE2\x96\xB0@3*\x08\x0Em\xF15\x15\xA3\xEC(i\xE2\x1C\xD2\x0FsD\xAF\t\x87\xDD\xB98\xD8\xBD!\x90V[a#Ja#\x1EV[\x90V[4a#}Wa#]6`\x04a\x05\x9DV[a#ya#ha#BV[a#pa\x04\xE2V[\x91\x82\x91\x82a\x0C\xAAV[\x03\x90\xF3[a\x04\xE8V[_\x80\xFD[_\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a#\xAAa#\xB0\x91a\"SV[\x91a\"SV[\x01\x90`\x01\x80`\xD0\x1B\x03\x82\x11a#\xC1WV[a#\x8AV[\x90a#\xD9\x91a#\xD3a#\x86V[Pa#\x9EV[\x90V[a#\xE8a#\xEE\x91a\"SV[\x91a\"SV[\x90\x03\x90`\x01\x80`\xD0\x1B\x03\x82\x11a$\0WV[a#\x8AV[\x90a$\x18\x91a$\x12a#\x86V[Pa#\xDCV[\x90V[_\x90V[a$'a$\x1BV[P\x80a$Ba$<cye\xDB\x0B`\xE0\x1Ba\x04\xF4V[\x91a\x04\xF4V[\x14\x90\x81\x15a$OW[P\x90V[a$Y\x91PaH\x85V[_a$KV[``\x90V[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a$\x90a$\x89\x83a\n\xB1V[\x80\x94a$dV[\x91`\x01\x81\x16\x90\x81_\x14a$\xE7WP`\x01\x14a$\xABW[PPPV[a$\xB8\x91\x92\x93\x94Pa$mV[\x91_\x92[\x81\x84\x10a$\xCFWPP\x01\x90_\x80\x80a$\xA6V[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a$\xBCV[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a$\xA6V[\x90a%\x0C\x91a$vV[\x90V[\x90a%/a%(\x92a%\x1Fa\x04\xE2V[\x93\x84\x80\x92a%\x02V[\x03\x83a\x0B\x9AV[V[a%:\x90a%\x0FV[\x90V[a%Ea$_V[Pa%P`\x03a%1V[\x90V[_\x90V[``\x90V[a%ha%m\x91a\x10XV[a\x1B\xB5V[\x90V[a%z\x90Ta%\\V[\x90V[a%\x86\x90a\x0B\xC3V[\x90V[a%\x91a%SV[Pa%\x9Aa%WV[Pa%\xA5`Ca%pV[\x90a%\xB0`Da%}V[\x90V[a%\xD0\x91a%\xBFa$\x1BV[Pa%\xC8aH\xABV[\x91\x90\x91aH\xB8V[`\x01\x90V[_\x90V[_a%\xF1a%\xF7\x92a%\xE9a%\xD5V[P`\x0Ca\x10BV[\x01a\x10qV[\x90V[\x90a&\x14\x91a&\x0Fa&\na#\x1EV[aH\xC8V[a(tV[V[P\x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a&C\x91\x02\x91a&=_\x19\x84a&$V[\x92a&$V[\x91\x81\x19\x16\x91\x16\x17\x90V[a&aa&\\a&f\x92a\x07-V[a\x10\x0BV[a\x07-V[\x90V[\x90V[\x91\x90a&\x82a&}a&\x8A\x93a&MV[a&iV[\x90\x83Ta&(V[\x90UV[a&\xA0\x91a&\x9Aa%\xD5V[\x91a&lV[V[[\x81\x81\x10a&\xAEWPPV[\x80a&\xBB_`\x01\x93a&\x8EV[\x01a&\xA3V[\x91\x90`\x1F\x81\x11a&\xD1W[PPPV[a&\xDDa'\x02\x93a\n\xE4V[\x90` a&\xE9\x84a&\x1AV[\x83\x01\x93\x10a'\nW[a&\xFB\x90a&\x1AV[\x01\x90a&\xA2V[_\x80\x80a&\xCCV[\x91Pa&\xFB\x81\x92\x90Pa&\xF2V[\x90a'(\x90_\x19\x90`\x08\x02a\tMV[\x19\x16\x90V[\x81a'7\x91a'\x18V[\x90`\x02\x02\x17\x90V[\x91a'J\x90\x82a&\x16V[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a(\tWa'n\x82a'h\x85Ta\n\xB1V[\x85a&\xC1V[_\x90`\x1F\x83\x11`\x01\x14a'\xA1W\x91\x80\x91a'\x90\x93_\x92a'\x95W[PPa'-V[\x90U[V[\x90\x91P\x015_\x80a'\x89V[`\x1F\x19\x83\x16\x91a'\xB0\x85a\n\xE4V[\x92_[\x81\x81\x10a'\xF1WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a'\xD7W[PPP\x02\x01\x90Ua'\x93V[a'\xE7\x91\x015`\x1F\x84\x16\x90a'\x18V[\x90U_\x80\x80a'\xCBV[\x91\x93` `\x01\x81\x92\x87\x87\x015\x81U\x01\x95\x01\x92\x01a'\xB3V[a\x0B\x86V[\x90a(\x19\x92\x91a'?V[V[\x90\x82_\x93\x92\x827\x01RV[\x91\x90a(@\x81a(9\x81a(E\x95a\x06tV[\x80\x95a(\x1BV[a\x05\xC4V[\x01\x90V[\x91a(ca(q\x94\x92`@\x85\x01\x90\x85\x82\x03_\x87\x01Ra\x06}V[\x92` \x81\x85\x03\x91\x01Ra(&V[\x90V[\x90a(\x7F`Da%}V[a(\x8C\x83\x83\x90`Da(\x0EV[\x91\x90\x91a(\xC5\x7F\xB9\xA2\x08\x84&\xF0;0\xA8\x1C\x06B\x80\x94\xFB\xFA\x9E&\x92s\x9B2A\xAFk\x9A\xB1\xDAKUF\xBE\x93a(\xBCa\x04\xE2V[\x93\x84\x93\x84a(IV[\x03\x90\xA1V[\x90a(\xD4\x91a%\xFAV[V[a(\xDEa%\xD5V[Pa(\xE9`\x02a\x10qV[\x90V[a(\xFCa(\xF7a!.V[aH\xC8V[a)\x04a)\xC5V[V[a)\x1Aa)\x15a)\x1F\x92a\x1BEV[a\x10\x0BV[a\x07-V[\x90V[a)6a)1a);\x92a\x1BEV[a\x10\x0BV[a\x06LV[\x90V[a)G\x90a)\"V[\x90V[\x90a)V`\xFF\x91a\x1BHV[\x91\x81\x19\x16\x91\x16\x17\x90V[a)i\x90a\x05AV[\x90V[\x90V[\x90a)\x84a)\x7Fa)\x8B\x92a)`V[a)lV[\x82Ta)JV[\x90UV[\x90a)\x9B_\x19\x91a\x1BHV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a)\xBAa)\xB5a)\xC1\x92a&MV[a&iV[\x82Ta)\x8FV[\x90UV[a)\xCF`@a\x10qV[a)\xE1a)\xDB_a)\x06V[\x91a\x07-V[\x03a*~Wa)\xF0`Ca%pV[a*\na*\x04a)\xFF_a)>V[a\x06WV[\x91a\x06WV[\x14a*bWa*\x1B`\x01`?a)oV[a*&B`@a)\xA5V[Ba*]\x7F\x11\x94\xB04\xCF\xA9\xABX\x07IJ\x1D\\f}\x8B\x0En\x97\xF3\x88\x88t*\xA3\x87\x1A2 4\x11`\x91a*Ta\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xA1V[_c;\nH\xBD`\xE1\x1B\x81R\x80a*z`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c8\xE9=\xBD`\xE1\x1B\x81R\x80a*\x96`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[a*\xA2a(\xECV[V[\x91a*\xCE\x92a*\xB1a$\x1BV[Pa*\xC6a*\xBDaH\xABV[\x82\x90\x84\x91aI\x1CV[\x91\x90\x91aI\xA8V[`\x01\x90V[a*\xDC\x90a\x10*V[\x90V[_\x80\xFD[`\xE0\x1B\x90V[\x90PQ\x90a*\xF6\x82a\x070V[V[\x90` \x82\x82\x03\x12a+\x11Wa+\x0E\x91_\x01a*\xE9V[\x90V[a\x04\xECV[a+\x1Ea\x04\xE2V[=_\x82>=\x90\xFD[a+5a+;\x91\x93\x92\x93a\x07-V[\x92a\x07-V[\x82\x03\x91\x82\x11a+FWV[a#\x8AV[\x90V[a+ba+]a+g\x92a+KV[a\x10\x0BV[a\x07-V[\x90V[a+ya+\x7F\x91\x93\x92\x93a\x07-V[\x92a\x07-V[\x91a+\x8B\x83\x82\x02a\x07-V[\x92\x81\x84\x04\x14\x90\x15\x17\x15a+\x9AWV[a#\x8AV[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[a+\xBFa+\xC5\x91a\x07-V[\x91a\x07-V[\x90\x81\x15a+\xD0W\x04\x90V[a+\x9FV[a+\xDDa%\xD5V[\x91a+\xE6a%\xD5V[\x91a+\xFD_a+\xF7`\x0C\x84\x90a\x10BV[\x01a\x10qV[\x90a,\x15`\x02a,\x0F`\x0C\x84\x90a\x10BV[\x01a\x10qV[\x91a,N` a,$0a*\xD3V[ce\x1F\xD2h\x90a,C\x86\x92a,7a\x04\xE2V[\x95\x86\x94\x85\x93\x84\x93a*\xE3V[\x83R`\x04\x83\x01a\x11\xFEV[\x03\x91Z\xFA\x90\x81\x15a-\xA7Wa,\x99\x91` \x91_\x91a-zW[P\x93a,r0a*\xD3V[a,\x8Ec\x99\x89U\xD3a,\x82a\x04\xE2V[\x95\x86\x94\x85\x93\x84\x93a*\xE3V[\x83R`\x04\x83\x01a\x11\xFEV[\x03\x91Z\xFA\x90\x81\x15a-uW_\x91a-GW[P\x91\x81a,\xC0a,\xBA_a)\x06V[\x91a\x07-V[\x11a-\x16W[PP\x81a,\xDBa,\xD5_a)\x06V[\x91a\x07-V[\x11a,\xE5W[PPV[a-\x0E\x92\x93Pa,\xF8a-\t\x91\x83a+&V[a-\x03a'\x10a+NV[\x90a+jV[a+\xB3V[\x90_\x80a,\xE1V[a-?\x92\x96Pa-)a-:\x91\x83a+&V[a-4a'\x10a+NV[\x90a+jV[a+\xB3V[\x93_\x80a,\xC6V[a-h\x91P` =\x81\x11a-nW[a-`\x81\x83a\x0B\x9AV[\x81\x01\x90a*\xF8V[_a,\xABV[P=a-VV[a+\x16V[a-\x9A\x91P\x82=\x81\x11a-\xA0W[a-\x92\x81\x83a\x0B\x9AV[\x81\x01\x90a*\xF8V[_a,gV[P=a-\x88V[a+\x16V[_\x90V[a-\xB9\x90a\x0CYV[\x90V[\x90a-\xC6\x90a-\xB0V[_R` R`@_ \x90V[\x90V[a-\xE1a-\xE6\x91a\x10XV[a-\xD2V[\x90V[a-\xF3\x90Ta-\xD5V[\x90V[`\x01a.\x0Fa.\x15\x92a.\x07a-\xACV[P`\x05a-\xBCV[\x01a-\xE9V[\x90V[a. aJEV[a.(a/~V[V[a.6a.;\x91a\x10XV[a\tQV[\x90V[a.H\x90Ta.*V[\x90V[`\x01a.W\x91\x01a\x07-V[\x90V[a.ia.o\x91\x93\x92\x93a\x07-V[\x92a\x07-V[\x82\x01\x80\x92\x11a.zWV[a#\x8AV[a.\x88\x90a\x10*V[\x90V[a.\x94\x90a\x10\x0EV[\x90V[a.\xA0\x90a.\x8BV[\x90V[a.\xAC\x90a\x10*V[\x90V[_\x91\x03\x12a.\xB9WV[a\x04\xECV[\x90_\x92\x91\x80T\x90a.\xD8a.\xD1\x83a\n\xB1V[\x80\x94a\x06tV[\x91`\x01\x81\x16\x90\x81_\x14a//WP`\x01\x14a.\xF3W[PPPV[a/\0\x91\x92\x93\x94Pa\n\xE4V[\x91_\x92[\x81\x84\x10a/\x17WPP\x01\x90_\x80\x80a.\xEEV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a/\x04V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a.\xEEV[a/na/{\x94\x92\x93a/d``\x84\x01\x95_\x85\x01\x90a\x06cV[` \x83\x01\x90a\x07\xD4V[`@\x81\x84\x03\x91\x01Ra.\xBEV[\x90V[a/\x91a/\x8B`?a.>V[\x15a\x05AV[a2\xB1Wa/\x9Da@qV[a2\x95Wa/\xC6a/\xB8Ba/\xB2`@a\x10qV[\x90a+&V[a/\xC0a\x1C\xB1V[\x90a+\xB3V[\x80a/\xE2a/\xDCa/\xD7`Aa\x10qV[a\x07-V[\x91a\x07-V[\x11\x15a2yWa/\xFC\x90a/\xF6`Aa\x10qV[\x90a+&V[\x90\x81a0*a0$a0\x1Fa0\x0Fa\x13\x04V[a0\x19`Aa\x10qV[\x90a+&V[a\x07-V[\x91a\x07-V[\x11a2VW[a09_a)\x06V[\x90a0C_a)\x06V[\x91[\x82a0Xa0R\x86a\x07-V[\x91a\x07-V[\x10\x15a0\x9FWa0\x93a0\x99\x91a0\x8Da0\x87`\x0Fa0\x81a0z`Aa\x10qV[\x89\x90a.ZV[\x90a\x0E V[\x90a\x0EcV[\x90a.ZV[\x92a.KV[\x91a0EV[\x91P\x91a0\xB6a0\xAF`Ba\x10qV[\x83\x90a.ZV[a0\xCFa0\xC9a0\xC4a\x13\xD8V[a\x07-V[\x91a\x07-V[\x11a2:Wa0\xEAa0\xF1\x91a0\xE5`Aa\x10qV[a.ZV[`Aa)\xA5V[a1\x0Ea1\x07\x82a1\x02`Ba\x10qV[a.ZV[`Ba)\xA5V[a1!a1\x1A0a.\x7FV[\x82\x90aJoV[a1>a1-0a.\x7FV[a17`Ca%pV[\x83\x91aH\xB8V[a1Xa1Sa1N`Ca%pV[a.\x97V[a.\xA3V[c\x18\xB6\x8B\x8Ca1f0a.\x7FV[\x83\x92`D\x92\x81;\x15a25W_a1\x90\x91a1\x9B\x82\x96a1\x84a\x04\xE2V[\x98\x89\x97\x88\x96\x87\x95a*\xE3V[\x85R`\x04\x85\x01a/JV[\x03\x92Z\xF1\x80\x15a20Wa2\x04W[Pa1\xB5`Aa\x10qV[\x90a1\xBF_a)>V[\x90a1\xEA\x7F4\xB7=\x0C\x96\xE9\xFFMS\x11CH\x17\xC8\xEC\xC90\xE7\xD2x,[\xDE.y\xDCD\xB0YgU\xBB\x92a\x106V[\x92a1\xFFa1\xF6a\x04\xE2V[\x92\x83\x92\x83a\n1V[\x03\x90\xA2V[a2#\x90_=\x81\x11a2)W[a2\x1B\x81\x83a\x0B\x9AV[\x81\x01\x90a.\xAFV[_a1\xAAV[P=a2\x11V[a+\x16V[a*\xDFV[_c#\x06N\xBD`\xE0\x1B\x81R\x80a2R`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x90Pa2sa2ca\x13\x04V[a2m`Aa\x10qV[\x90a+&V[\x90a00V[_c\xE0\x85\xD2+`\xE0\x1B\x81R\x80a2\x91`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c\x11UbK`\xE2\x1B\x81R\x80a2\xAD`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c\x19\xAF\xC9\x9D`\xE2\x1B\x81R\x80a2\xC9`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[a2\xD5a.\x18V[V[\x90a2\xF2\x91a2\xEDa2\xE8\x82a-\xF6V[aH\xC8V[a2\xF4V[V[\x90a2\xFE\x91aJ\xCDV[PV[\x90a3\x0B\x91a2\xD7V[V[_\x90V[\x90V[a3(a3#a3-\x92a3\x11V[a\x10\x0BV[a\r\x88V[\x90V[a38a3\rV[Pa3C`\x12a3\x14V[\x90V[a3Va3Qa!.V[aH\xC8V[a3^a3`V[V[a3j`@a\x10qV[a3|a3v_a)\x06V[\x91a\x07-V[\x14a3\xC5Wa3\x8D`\x01`?a)oV[\x7FJy*\x0B\xE4+Vr\xFA\xA4\x01)\xFCdi\x07$\x90w\\\xA8\xD3\xC3N\x85-MU\xD3\xA75\xA9a3\xB6a\x04\xE2V[\x80a3\xC0\x81a\x08\xACV[\x03\x90\xA1V[_c\x8F\x98@A`\xE0\x1B\x81R\x80a3\xDD`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[a3\xE9a3FV[V[a3\xF3a-\xACV[Pa3\xFCaKyV[\x90V[\x90\x80a4\x1Aa4\x14a4\x0FaH\xABV[a\x06WV[\x91a\x06WV[\x03a4+Wa4(\x91aL3V[PV[_c3K\xD9\x19`\xE1\x1B\x81R\x80a4C`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x90a4Q\x90a\x106V[_R` R`@_ \x90V[\x90V[a4ta4oa4y\x92a\"SV[a\x10\x0BV[a\x07-V[\x90V[a4\xB3\x91a4\xA8a4\xA2a4\x9Da4\xAE\x94a4\x95a%\xD5V[P`\na4GV[a4]V[\x91aM\x14V[\x90aN\nV[a4`V[\x90V[a4\xC6a4\xC1a\x1BiV[aH\xC8V[a4\xCEa4\xD0V[V[a4\xD8aO\x91V[V[a4\xE2a4\xB6V[V[\x90\x81a5\0a4\xFAa4\xF5_a)>V[a\x06WV[\x91a\x06WV[\x14a5\xFFW\x80a5\x18a5\x12_a)\x06V[\x91a\x07-V[\x14a5\xE3Wa5:a54a5/`\r3\x90a\x14/V[a.>V[\x15a\x05AV[a5\xC7Wa5G3aO\x9EV[a5^`\x01a5X`\x0C3\x90a\x10BV[\x01a\x10qV[a5pa5j\x83a\x07-V[\x91a\x07-V[\x10a5\xABWa5\xA9\x91a5\xA4\x82a5\x9E`\x01a5\x8E`\x0C3\x90a\x10BV[\x01\x91a5\x99\x83a\x10qV[a+&V[\x90a)\xA5V[aJoV[V[_c\x1C\x95\x9E\xD9`\xE2\x1B\x81R\x80a5\xC3`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_cD\x17v\t`\xE1\x1B\x81R\x80a5\xDF`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a5\xFB`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a6\x17`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[a6#a%\xD5V[Pa6?a6/a\x13\xD8V[a69`Ba\x10qV[\x90a+&V[\x90V[\x90a6Ua6Na\x04\xE2V[\x92\x83a\x0B\x9AV[V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a6uWa6q` \x91a\x05\xC4V[\x01\x90V[a\x0B\x86V[\x90a6\x8Ca6\x87\x83a6WV[a6BV[\x91\x82RV[_\x7Fmode=blocknumber&from=default\0\0\0\x91\x01RV[a6\xC2`\x1Da6zV[\x90a6\xCF` \x83\x01a6\x91V[V[a6\xD9a6\xB8V[\x90V[a6\xE4a$_V[Pa6\xEDa;\xFFV[a7\x06a7\0a6\xFBaQ9V[a\x18\xBEV[\x91a\x18\xBEV[\x03a7\x16Wa7\x13a6\xD1V[\x90V[_c\x01\xBF\xC1\xC5`\xE6\x1B\x81R\x80a7.`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x90a7<\x90a\x106V[_R` R`@_ \x90V[a7_a7d\x91a7Wa%SV[P`\ta72V[a%pV[\x90V[a7oa$\x1BV[Pa7z`@a\x10qV[a7\x8Ca7\x86_a)\x06V[\x91a\x07-V[\x11\x90V[a7\xA1\x90a7\x9CaH\xABV[aQNV[V[a7\xABa$\x1BV[Pa7\xB6`\x0Ea.>V[\x90V[a8\x10\x90a7\xC5a%\xD5V[Pa7\xDD`\x01a7\xD7`\x0C\x84\x90a\x10BV[\x01a\x10qV[\x90a8\n`\x04a8\x04a7\xFC_a7\xF6`\x0C\x87\x90a\x10BV[\x01a\x10qV[\x93`\x0Ca\x10BV[\x01a\x10qV[\x91aQ\xD9V[\x90V[a8#a8\x1Ea!\x92V[aH\xC8V[a8+a8-V[V[a88_`?a)oV[\x7Fs\xA5\xFC`\xAA\xFE\xEC\x8F\x13\x9A\xF2-\x98\xE6!@\xE2\xCE\x91M\x1F\x15\\i+BwW\xC3\xE4\x01La8aa\x04\xE2V[\x80a8k\x81a\x08\xACV[\x03\x90\xA1V[a8xa8\x13V[V[_\x90V[a8\x90\x90a8\x8Aa8zV[PaR\x85V[\x90V[\x90a8\x9D\x90a\x106V[_R` R`@_ \x90V[a8\xBFa8\xC4\x91a8\xB8a%\xD5V[P_a8\x93V[a\x10qV[\x90V[a8\xDEa8\xE3\x91a8\xD6a$\x1BV[P`\ra\x14/V[a.>V[\x90V[\x90a8\xEFa$\x1BV[Pa8\xF8a%\xD5V[Pa9\x01a%\xD5V[Pa9\na%\xD5V[Pa9\x13a%\xD5V[Pa9(a9#`\r\x84\x90a\x14/V[a.>V[\x91a9?_a99`\x0C\x84\x90a\x10BV[\x01a\x10qV[\x91a9W`\x02a9Q`\x0C\x85\x90a\x10BV[\x01a\x10qV[\x90a9\x90` a9f0a*\xD3V[ce\x1F\xD2h\x90a9\x85\x87\x92a9ya\x04\xE2V[\x95\x86\x94\x85\x93\x84\x93a*\xE3V[\x83R`\x04\x83\x01a\x11\xFEV[\x03\x91Z\xFA\x90\x81\x15a:QWa9\xDB\x91` \x91_\x91a:$W[P\x94a9\xB40a*\xD3V[a9\xD0c\x99\x89U\xD3a9\xC4a\x04\xE2V[\x95\x86\x94\x85\x93\x84\x93a*\xE3V[\x83R`\x04\x83\x01a\x11\xFEV[\x03\x91Z\xFA\x90\x81\x15a:\x1FW_\x91a9\xF1W[P\x90V[a:\x12\x91P` =\x81\x11a:\x18W[a:\n\x81\x83a\x0B\x9AV[\x81\x01\x90a*\xF8V[_a9\xEDV[P=a:\0V[a+\x16V[a:D\x91P\x82=\x81\x11a:JW[a:<\x81\x83a\x0B\x9AV[\x81\x01\x90a*\xF8V[_a9\xA9V[P=a:2V[a+\x16V[a:h\x90a:ba%\xD5V[PaR\xB4V[\x90V[a:{a:va!\x92V[aH\xC8V[a:\x83a:\x85V[V[a:\x8DaS*V[V[a:\x97a:kV[V[_\x90V[``\x90V[a:\xAB\x90a\x10*V[\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a:\xC6W` \x80\x91\x02\x01\x90V[a\x0B\x86V[\x90a:\xDDa:\xD8\x83a:\xAEV[a6BV[\x91\x82RV[6\x907V[\x90a;\x0Ca:\xF4\x83a:\xCBV[\x92` \x80a;\x02\x86\x93a:\xAEV[\x92\x01\x91\x03\x90a:\xE2V[V[`\x0F`\xF8\x1B\x90V[a;\x1Ea:\x99V[Pa;'a$_V[Pa;0a$_V[Pa;9a%\xD5V[Pa;Ba%SV[Pa;Ka-\xACV[Pa;Ta:\x9DV[Pa;]aS7V[\x90a;faSwV[\x90F\x90a;r0a:\xA2V[\x90a;|_a\x1BMV[\x90a;\x8Ea;\x89_a)\x06V[a:\xE7V[\x90a;\x97a;\x0EV[\x96\x95\x94\x93\x92\x91\x90V[a;\xC9a;\xCE\x91a;\xAFa%\xD5V[Pa;\xC3a;\xBD`\x0Ba4]V[\x91aM\x14V[\x90aN\nV[a4`V[\x90V[a;\xF8\x91_a;\xEDa;\xF3\x93a;\xE5a$\x1BV[P`\x05a-\xBCV[\x01a\x14/V[a.>V[\x90V[_\x90V[a<\x07a;\xFBV[Pa<\x10aQ9V[\x90V[a<\x1Ba$_V[Pa<&`\x04a%1V[\x90V[a<\x81\x90a<5a%\xD5V[Pa<M`\x03a<G`\x0C\x84\x90a\x10BV[\x01a\x10qV[\x90a<{`\x04a<ua<m`\x02a<g`\x0C\x87\x90a\x10BV[\x01a\x10qV[\x93`\x0Ca\x10BV[\x01a\x10qV[\x91aQ\xD9V[\x90V[a<\xABa<\xA6a<\xA1a<\xB0\x93a<\x99a%\xD5V[P`\na4GV[a4]V[aS\xB7V[a4`V[\x90V[\x90\x81a<\xCFa<\xC9a<\xC4_a)>V[a\x06WV[\x91a\x06WV[\x14a=\xCEW\x80a<\xE7a<\xE1_a)\x06V[\x91a\x07-V[\x14a=\xB2Wa=\ta=\x03a<\xFE`\r3\x90a\x14/V[a.>V[\x15a\x05AV[a=\x96Wa=\x163aO\x9EV[a=-`\x03a='`\x0C3\x90a\x10BV[\x01a\x10qV[a=?a=9\x83a\x07-V[\x91a\x07-V[\x10a=zWa=x\x91a=s\x82a=m`\x03a=]`\x0C3\x90a\x10BV[\x01\x91a=h\x83a\x10qV[a+&V[\x90a)\xA5V[aT,V[V[_c\x1C\x95\x9E\xD9`\xE2\x1B\x81R\x80a=\x92`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_cD\x17v\t`\xE1\x1B\x81R\x80a=\xAE`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a=\xCA`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a=\xE6`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x90a>\x05\x92\x91a>\0a=\xFBa#\x1EV[aH\xC8V[a>\x07V[V[\x80a>\"a>\x1Ca>\x17_a)>V[a\x06WV[\x91a\x06WV[\x14a@HWa>Da>>a>9`\r\x84\x90a\x14/V[a.>V[\x15a\x05AV[\x80a@\rW[a?\xB1W[\x81a>ba>\\_a)\x06V[\x91a\x07-V[\x14\x80a?\x97W[\x80a?}W[a?\"W[a>}\x81aO\x9EV[a>\x94\x82_a>\x8E`\x0C\x85\x90a\x10BV[\x01a)\xA5V[a>\xAC\x83`\x02a>\xA6`\x0C\x85\x90a\x10BV[\x01a)\xA5V[a>\xC4\x82`\x01a>\xBE`\x0C\x85\x90a\x10BV[\x01a)\xA5V[a>\xDC\x83`\x03a>\xD6`\x0C\x85\x90a\x10BV[\x01a)\xA5V[\x90\x91a?\x08\x7F\xAA\x80}\n\xBF0\xD9\x19h\xC7G\x8Cf\xB6\xD8%!\xA1\x06\xAF\x13\xED\xA06\xE2\x03m\xA9\xAF\x16\x89X\x92a\x106V[\x92a?\x1Da?\x14a\x04\xE2V[\x92\x83\x92\x83a\n1V[\x03\x90\xA2V[a?7_a?2`\r\x84\x90a\x14/V[a)oV[\x80a?b\x7F\x02\xC2\xF0\xBA\x15\xB0?\x88\xB1\x8FH2`\x9A\x18\xCF5\xFCk?EF\xA9\x99 v\xD7E=\x134\xA8\x91a\x106V[\x90a?ka\x04\xE2V[\x80a?u\x81a\x08\xACV[\x03\x90\xA2a>tV[Pa?\x92a?\x8D`\r\x83\x90a\x14/V[a.>V[a>oV[P\x82a?\xABa?\xA5_a)\x06V[\x91a\x07-V[\x14a>iV[a?\xC7`\x01a?\xC2`\r\x84\x90a\x14/V[a)oV[\x80a?\xF2\x7Fl\xF2\x849\xA2\xDA\xAB\x1B&P\x97\"r\x12\xA5\xB7\x1E\nv\xF9\xED\x85\xE3\xF8\x15\xB5\xA6\xC3\xE2\x18\xEB\x7F\x91a\x106V[\x90a?\xFBa\x04\xE2V[\x80a@\x05\x81a\x08\xACV[\x03\x90\xA2a>OV[P\x81a@!a@\x1B_a)\x06V[\x91a\x07-V[\x11\x80\x15a@.W[a>JV[P\x82a@Ba@<_a)\x06V[\x91a\x07-V[\x11a@)V[_c\xD9.#=`\xE0\x1B\x81R\x80a@``\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x90a@o\x92\x91a=\xEAV[V[a@ya$\x1BV[Pa@\x84`Aa\x10qV[a@\x9Da@\x97a@\x92a\x13\x04V[a\x07-V[\x91a\x07-V[\x10\x15\x90V[a@\xBB\x90a@\xB6a@\xB1a#\x1EV[aH\xC8V[a@\xFBV[V[\x90a@\xCE`\x01\x80`\xA0\x1B\x03\x91a\x1BHV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90V[\x90a@\xF0a@\xEBa@\xF7\x92a\x106V[a@\xD8V[\x82Ta@\xBDV[\x90UV[\x80aA\x16aA\x10aA\x0B_a)>V[a\x06WV[\x91a\x06WV[\x14aA|WaA%`Ca%pV[aA0\x82`Ca@\xDBV[\x90aAdaA^\x7F\x07\x01[j\x9F\x05\x911H\xFD_\xAD\xDF*\xCC\x97\x08\xF3\x05\x93\x7F0r\xCA+KF\xFA\xA5\xD0\x89\x8B\x93a\x106V[\x91a\x106V[\x91aAma\x04\xE2V[\x80aAw\x81a\x08\xACV[\x03\x90\xA3V[_c\xD9.#=`\xE0\x1B\x81R\x80aA\x94`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[aA\xA1\x90a@\xA2V[V[aA\xC0\x91aA\xAFa$\x1BV[PaA\xB8aH\xABV[\x91\x90\x91aI\xA8V[`\x01\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11aA\xDAW` \x02\x90V[a\x0B\x86V[aA\xEBaA\xF0\x91aA\xC5V[a6BV[\x90V[\x90aB\x11aB\0\x83aA\xDFV[\x92aB\x0B\x84\x91aA\xC5V[\x90a:\xE2V[V[aB\x1D`0aA\xF3V[\x90V[\x90P\x90V[aB/\x90Ta\x10]V[\x90V[`\x01\x01\x90V[aBTaBNaBG\x83a\x0E\x17V[\x80\x94aB V[\x91a\x0E\x1DV[_\x91[\x83\x83\x10aBdWPPPPV[aB\x81aB{`\x01\x92aBv\x85aB%V[a\x16\xC5V[\x92aB2V[\x92\x01\x91\x90aBWV[\x90aB\x98\x81a\x06\0\x93aB8V[\x01\x90V[\x90aB\xBCaB\xB5\x92aB\xACa\x04\xE2V[\x93\x84\x80\x92aB\x8AV[\x03\x83a\x0B\x9AV[V[aB\xC7\x90aB\x9CV[\x90V[aB\xD2aB\x13V[PaB\xDD`\x0FaB\xBEV[\x90V[\x90aB\xF3\x91aB\xEDa%\xD5V[Pa4|V[\x90V[\x90V[aC\raC\x08aC\x12\x92aB\xF6V[a\x10\x0BV[a\x07-V[\x90V[aC\x1Da%\xD5V[PaC&a%\xD5V[PaC/a%\xD5V[PaC8a$\x1BV[PaCC`@a\x10qV[aCUaCO_a)\x06V[\x91a\x07-V[\x14aD\x94WaC\x7FaCqBaCk`@a\x10qV[\x90a+&V[aCya\x1C\xB1V[\x90a+\xB3V[\x90aC\xC1aC\x8D`@a\x10qV[aC\xBBaC\xADaC\x9D`Aa\x10qV[aC\xA7`\x01aB\xF9V[\x90a.ZV[aC\xB5a\x1C\xB1V[\x90a+jV[\x90a.ZV[aC\xCB`Aa\x10qV[aC\xE4aC\xDEaC\xD9a\x13\x04V[a\x07-V[\x91a\x07-V[\x10_\x14aD\x86WaD\taD\x03`\x0FaC\xFD`Aa\x10qV[\x90a\x0E V[\x90a\x0EcV[[\x92aD\x15`?a.>V[\x90\x81aDbW[P\x80aD8W[\x91aD.`Aa\x10qV[\x91\x93\x92\x91\x93\x92\x91\x90V[PaDC`Aa\x10qV[aD\\aDVaDQa\x13\x04V[a\x07-V[\x91a\x07-V[\x10aD#V[\x90PaD\x7FaDyaDt`Aa\x10qV[a\x07-V[\x91a\x07-V[\x11_aD\x1CV[aD\x8F_a)\x06V[aD\nV[_\x90_\x91_\x91aD\xB6aD\xB0aD\xAA_\x94a)\x06V[\x95a)\x06V[\x93a)\x06V[\x91\x90V[aD\xCC\x90aD\xC6a%\xD5V[Pa<\x84V[\x90V[aD\xD7a%\xD5V[PaD\xE0a(\xD6V[\x90V[`\x02aD\xFCaE\x02\x92aD\xF4a%\xD5V[P`\x0Ca\x10BV[\x01a\x10qV[\x90V[\x7F\xE4\x83)\x05{\xFD\x03\xD5^I\xB5G\x13.9\xCF\xFD\x9C\x18 \xAD{\x9DLS\x07i\x14%\xD1Z\xDF\x90V[aE^aEe\x94aET``\x94\x98\x97\x95aEJ`\x80\x86\x01\x9A_\x87\x01\x90a\x0C\x9DV[` \x85\x01\x90a\x06cV[`@\x83\x01\x90a\x07\xD4V[\x01\x90a\x07\xD4V[V[` \x01\x90V[\x93\x95\x94\x90\x92\x91\x95BaE\x87aE\x81\x89a\x07-V[\x91a\x07-V[\x11aF\0W\x91aE\xF2\x91aE\xF9\x93aE\xE9aE\xFE\x98\x99aE\xD1aE\xA8aE\x05V[aE\xC2\x8B\x93\x8BaE\xB6a\x04\xE2V[\x95\x86\x94` \x86\x01aE)V[` \x82\x01\x81\x03\x82R\x03\x82a\x0B\x9AV[aE\xE3aE\xDD\x82a\x06pV[\x91aEgV[ aT\x8BV[\x92\x90\x91\x92aT\xA8V[\x91\x82aT\xF2V[aQNV[V[aF\x1B\x87_\x91\x82\x91c#A\xD7\x87`\xE1\x1B\x83R`\x04\x83\x01a\x07\xE1V[\x03\x90\xFD[\x7Fnq\xED\xAE\x12\xB1\xB9\x7FM\x1F`7\x0F\xEF\x10\x10_\xA2\xFA\xAE\x01&\x11J\x16\x9Cd\x84]a&\xC9\x90V[\x91\x94aF\x8BaF\x95\x92\x98\x97\x95aF\x81`\xA0\x96aFwaF\x9C\x9AaFm`\xC0\x8A\x01\x9E_\x8B\x01\x90a\x0C\x9DV[` \x89\x01\x90a\x06cV[`@\x87\x01\x90a\x06cV[``\x85\x01\x90a\x07\xD4V[`\x80\x83\x01\x90a\x07\xD4V[\x01\x90a\x07\xD4V[V[\x91` aF\xBF\x92\x94\x93aF\xB8`@\x82\x01\x96_\x83\x01\x90a\x06cV[\x01\x90a\x06cV[V[\x96\x95\x91\x93\x92\x94\x90\x94BaF\xDCaF\xD6\x83a\x07-V[\x91a\x07-V[\x11aG\x96W\x90aGEaGN\x94\x93\x92aG-aF\xF6aF\x1FV[aG\x1E\x8C\x80\x94\x8C\x91aG\x08\x8D\x91aU5V[\x91\x92aG\x12a\x04\xE2V[\x97\x88\x96` \x88\x01aFCV[` \x82\x01\x81\x03\x82R\x03\x82a\x0B\x9AV[aG?aG9\x82a\x06pV[\x91aEgV[ aT\x8BV[\x92\x90\x91\x92aT\xA8V[\x80aGaaG[\x87a\x06WV[\x91a\x06WV[\x03aGvWPaGt\x92\x93\x91\x90\x91aH\xB8V[V[\x84\x90aG\x92_\x92\x83\x92c%\xC0\x07#`\xE1\x1B\x84R`\x04\x84\x01aF\x9EV[\x03\x90\xFD[aG\xB1\x90_\x91\x82\x91c1<\x89\x81`\xE1\x1B\x83R`\x04\x83\x01a\x07\xE1V[\x03\x90\xFD[\x90aG\xD0\x91aG\xCBaG\xC6\x82a-\xF6V[aH\xC8V[aG\xD2V[V[\x90aG\xDC\x91aL3V[PV[\x90aG\xE9\x91aG\xB5V[V[\x90aG\xF5\x90a\x106V[_R` R`@_ \x90V[aH&\x91aH\x1CaH!\x92aH\x14a%\xD5V[P`\x01aG\xEBV[a8\x93V[a\x10qV[\x90V[aH3`@a6BV[\x90V[_\x90V[_\x90V[aHFaH)V[\x90` \x80\x83aHSaH6V[\x81R\x01aH^aH:V[\x81RPPV[aHlaH>V[\x90V[\x90aH\x82\x91aH|aHdV[PaUhV[\x90V[aH\x8Da$\x1BV[PaH\xA7aH\xA1c\x01\xFF\xC9\xA7`\xE0\x1Ba\x04\xF4V[\x91a\x04\xF4V[\x14\x90V[aH\xB3a%SV[P3\x90V[\x91aH\xC6\x92\x91`\x01\x92aU\x90V[V[aH\xDA\x90aH\xD4aH\xABV[\x90aV\xC2V[V[`@\x90aI\x05aI\x0C\x94\x96\x95\x93\x96aH\xFB``\x84\x01\x98_\x85\x01\x90a\x06cV[` \x83\x01\x90a\x07\xD4V[\x01\x90a\x07\xD4V[V[\x90aI\x19\x91\x03a\x07-V[\x90V[\x92\x91\x92aI*\x81\x83\x90aH\x01V[\x90\x81aI?aI9_\x19a\x07-V[\x91a\x07-V[\x10aILW[PPP\x90PV[\x81aI_aIY\x87a\x07-V[\x91a\x07-V[\x10aI\x85WaI|\x93\x94aIt\x91\x93\x92aI\x0EV[\x90_\x92aU\x90V[\x80_\x80\x80aIEV[PaI\xA4\x84\x92\x91\x92_\x93\x84\x93c}\xC7\xA0\xD9`\xE1\x1B\x85R`\x04\x85\x01aH\xDCV[\x03\x90\xFD[\x91\x82aI\xC4aI\xBEaI\xB9_a)>V[a\x06WV[\x91a\x06WV[\x14aJ\x1EW\x81aI\xE4aI\xDEaI\xD9_a)>V[a\x06WV[\x91a\x06WV[\x14aI\xF7WaI\xF5\x92\x91\x90\x91aV\xFDV[V[aJ\x1AaJ\x03_a)>V[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x11\xFEV[\x03\x90\xFD[aJAaJ*_a)>V[_\x91\x82\x91cKc~\x8F`\xE1\x1B\x83R`\x04\x83\x01a\x11\xFEV[\x03\x90\xFD[aJMa7\xA3V[aJSWV[_c\xD9<\x06e`\xE0\x1B\x81R\x80aJk`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x80aJ\x8AaJ\x84aJ\x7F_a)>V[a\x06WV[\x91a\x06WV[\x14aJ\xA6WaJ\xA4\x91aJ\x9C_a)>V[\x91\x90\x91aV\xFDV[V[aJ\xC9aJ\xB2_a)>V[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x11\xFEV[\x03\x90\xFD[aJ\xD5a$\x1BV[PaJ\xEAaJ\xE4\x82\x84\x90a;\xD1V[\x15a\x05AV[_\x14aKsWaK\x12`\x01aK\r_aK\x05`\x05\x86\x90a-\xBCV[\x01\x85\x90a\x14/V[a)oV[\x90aK\x1BaH\xABV[\x90aKXaKRaKL\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a-\xB0V[\x92a\x106V[\x92a\x106V[\x92aKaa\x04\xE2V[\x80aKk\x81a\x08\xACV[\x03\x90\xA4`\x01\x90V[PP_\x90V[aK\x81a-\xACV[PaK\x8B0a:\xA2V[aK\xBDaK\xB7\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x06WV[\x91a\x06WV[\x14\x80aK\xF9W[_\x14aK\xEEW\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[aK\xF6aW}V[\x90V[PFaL-aL'\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x07-V[\x91a\x07-V[\x14aK\xC4V[aL;a$\x1BV[PaLG\x81\x83\x90a;\xD1V[_\x14aL\xCFWaLn_aLi_aLa`\x05\x86\x90a-\xBCV[\x01\x85\x90a\x14/V[a)oV[\x90aLwaH\xABV[\x90aL\xB4aL\xAEaL\xA8\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x95a-\xB0V[\x92a\x106V[\x92a\x106V[\x92aL\xBDa\x04\xE2V[\x80aL\xC7\x81a\x08\xACV[\x03\x90\xA4`\x01\x90V[PP_\x90V[aL\xE9aL\xE4aL\xEE\x92a\x18\xBEV[a\x10\x0BV[a\x07-V[\x90V[\x91` aM\x12\x92\x94\x93aM\x0B`@\x82\x01\x96_\x83\x01\x90a\x07\xD4V[\x01\x90a\x18\xC9V[V[aM\x1Ca;\xFBV[PaM%a;\xFFV[\x81aM8aM2\x83aL\xD5V[\x91a\x07-V[\x10\x15aMKWPaMH\x90aX\x83V[\x90V[\x90aMf_\x92\x83\x92cvi\xFC\x0F`\xE1\x1B\x84R`\x04\x84\x01aL\xF1V[\x03\x90\xFD[T\x90V[\x90V[aM\x85aM\x80aM\x8A\x92aMnV[a\x10\x0BV[a\x07-V[\x90V[\x90V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[aM\xA7aM\xAC\x91a\x10XV[aM\x90V[\x90V[aM\xB9\x90TaM\x9BV[\x90V[`0\x1C\x90V[`\x01\x80`\xD0\x1B\x03\x16\x90V[aM\xD9aM\xDE\x91aM\xBCV[aM\xC2V[\x90V[aM\xEB\x90TaM\xCDV[\x90V[aN\x02aM\xFDaN\x07\x92a\x1BEV[a\x10\x0BV[a\"SV[\x90V[\x90aN^\x90aN\x17a#\x86V[PaN#_\x84\x01aMjV[aN,_a)\x06V[\x90\x80\x80aNBaN<`\x05aMqV[\x91a\x07-V[\x11aN\xBFW[P\x90aNY_\x86\x01\x93\x91\x92\x93aM\x8DV[a^\xBEV[\x80aNqaNk_a)\x06V[\x91a\x07-V[\x14_\x14aN\x87WPPaN\x83_aM\xEEV[[\x90V[aN\xB4_\x91aN\xAFaN\xA9\x84aN\xBA\x96\x01\x92aN\xA3`\x01aB\xF9V[\x90a+&V[\x91aM\x8DV[a^\xB4V[\x01aM\xE1V[aN\x84V[\x80aN\xCDaN\xD3\x92\x91a[IV[\x90a+&V[\x90\x83aO\x05aN\xFFaN\xFA_aN\xF4\x81\x8C\x01aN\xEF\x89\x91aM\x8DV[a^\xB4V[\x01aM\xAFV[a\x18\xBEV[\x91a\x18\xBEV[\x10_\x14aO\x16WP\x90[\x90_aNHV[\x91PaO,\x90aO&`\x01aB\xF9V[\x90a.ZV[aO\x0FV[aO9a_MV[aOAaOCV[V[aON_`\x0Ea)oV[aOVaH\xABV[aO\x8C\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA\x91aO\x83a\x04\xE2V[\x91\x82\x91\x82a\x11\xFEV[\x03\x90\xA1V[aO\x99aO1V[V[\x90V[aO\xACaO\xB1\x91`\x0Ca\x10BV[aO\x9BV[aO\xBD`\x04\x82\x01a\x10qV[aO\xCFaO\xC9_a)\x06V[\x91a\x07-V[\x14aQ)WaPK\x90aO\xEEBaO\xE8`\x04\x84\x01a\x10qV[\x90a+&V[\x80aP\x08aP\x02aO\xFDa\x19tV[a\x07-V[\x91a\x07-V[\x10\x15_\x14aPMWPaP(aP\x1F_\x83\x01a\x10qV[`\x01\x83\x01a)\xA5V[aP@aP7`\x02\x83\x01a\x10qV[`\x03\x83\x01a)\xA5V[[`\x04B\x91\x01a)\xA5V[V[\x80aP`aPZ_a)\x06V[\x91a\x07-V[\x11aPlW[PaPAV[aQ\x1AaQ\x08aQ#\x92aP\xF7aP\xEEaP\xDDaP\xCBaP\xBDaP\xABaP\x9DaP\x96_\x8D\x01a\x10qV[\x88\x90a+jV[aP\xA5a\x19tV[\x90a+\xB3V[\x95aP\xB8`\x02\x8C\x01a\x10qV[a+jV[aP\xC5a\x19tV[\x90a+\xB3V[\x93aP\xD8`\x01\x8A\x01a\x10qV[a.ZV[aP\xE8_\x89\x01a\x10qV[\x90a_\x80V[`\x01\x87\x01a)\xA5V[aQ\x03`\x03\x86\x01a\x10qV[a.ZV[aQ\x14`\x02\x85\x01a\x10qV[\x90a_\x80V[`\x03\x83\x01a)\xA5V[_aPfV[aQ7\x90`\x04B\x91\x01a)\xA5V[V[aQAa;\xFBV[PaQKCaX\x83V[\x90V[\x90aQ\xD7\x91aQ\xD1aQ_\x82a7HV[aQt\x84aQo`\t\x86\x90a72V[a@\xDBV[\x82\x81\x85\x90aQ\xB4aQ\xAEaQ\xA8\x7F14\xE8\xA2\xE6\xD9~\x92\x9A~T\x01\x1E\xA5H]}\x19m\xD5\xF0\xBAMN\xF9X\x03\xE8\xE3\xFC%\x7F\x95a\x106V[\x92a\x106V[\x92a\x106V[\x92aQ\xBDa\x04\xE2V[\x80aQ\xC7\x81a\x08\xACV[\x03\x90\xA4\x92\x91a_\xB0V[\x91a_\xC8V[V[\x90\x91aQ\xE3a%\xD5V[P\x80aQ\xF7aQ\xF1_a)\x06V[\x91a\x07-V[\x14aRvWaR\x06\x90Ba+&V[\x90\x81aR!aR\x1BaR\x16a\x19tV[a\x07-V[\x91a\x07-V[\x10\x15aRqWaREaR7aRK\x93\x85a+jV[aR?a\x19tV[\x90a+\xB3V[\x90a.ZV[\x80aR^aRX\x84a\x07-V[\x91a\x07-V[\x11_\x14aRjWP[\x90V[\x90PaRgV[PP\x90V[PPPaR\x82_a)\x06V[\x90V[aR\xACaR\xA7aR\xA2aR\xB1\x93aR\x9Aa8zV[P`\na4GV[a4]V[aavV[aa\xF5V[\x90V[aR\xC6\x90aR\xC0a%\xD5V[PabFV[\x90V[aR\xD1aJEV[aR\xD9aR\xDBV[V[aR\xE7`\x01`\x0Ea)oV[aR\xEFaH\xABV[aS%\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2X\x91aS\x1Ca\x04\xE2V[\x91\x82\x91\x82a\x11\xFEV[\x03\x90\xA1V[aS2aR\xC9V[V[\x90V[aS?a$_V[PaSt\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0aSn`\x06aS4V[\x90acaV[\x90V[aS\x7Fa$_V[PaS\xB4\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0aS\xAE`\x07aS4V[\x90acaV[\x90V[aS\xBFa#\x86V[PaS\xCB_\x82\x01aMjV[\x80aS\xDEaS\xD8_a)\x06V[\x91a\x07-V[\x14_\x14aS\xF4WPPaS\xF0_aM\xEEV[[\x90V[aT!_\x91aT\x1CaT\x16\x84aT'\x96\x01\x92aT\x10`\x01aB\xF9V[\x90a+&V[\x91aM\x8DV[a^\xB4V[\x01aM\xE1V[aS\xF1V[\x90\x81aTHaTBaT=_a)>V[a\x06WV[\x91a\x06WV[\x14aTdWaTb\x91\x90aT[_a)>V[\x90\x91aV\xFDV[V[aT\x87aTp_a)>V[_\x91\x82\x91cKc~\x8F`\xE1\x1B\x83R`\x04\x83\x01a\x11\xFEV[\x03\x90\xFD[aT\xA5\x90aT\x97a-\xACV[PaT\xA0aKyV[ac\xAFV[\x90V[\x92aT\xC3\x92aT\xCC\x94aT\xB9a%SV[P\x92\x90\x91\x92adeV[\x90\x92\x91\x92ae\x90V[\x90V[\x91` aT\xF0\x92\x94\x93aT\xE9`@\x82\x01\x96_\x83\x01\x90a\x06cV[\x01\x90a\x07\xD4V[V[aT\xFB\x81aU5V[\x91aU\x0EaU\x08\x84a\x07-V[\x91a\x07-V[\x03aU\x17WPPV[aU1_\x92\x83\x92c\x01\xD4\xB6#`\xE6\x1B\x84R`\x04\x84\x01aT\xCFV[\x03\x90\xFD[aUI\x90aUAa%\xD5V[P`\x08a8\x93V[aUeaUU\x82a\x10qV[\x91aU_\x83a.KV[\x90a)\xA5V[\x90V[\x90aU\x88aU\x83aU\x8D\x93aU{aHdV[P`\na4GV[a4]V[af\xF2V[\x90V[\x90\x92\x81aU\xADaU\xA7aU\xA2_a)>V[a\x06WV[\x91a\x06WV[\x14aVxW\x83aU\xCDaU\xC7aU\xC2_a)>V[a\x06WV[\x91a\x06WV[\x14aVQWaU\xF1\x83aU\xECaU\xE5`\x01\x86\x90aG\xEBV[\x87\x90a8\x93V[a)\xA5V[aU\xFBW[PPPV[\x91\x90\x91aVFaV4aV.\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%\x93a\x106V[\x93a\x106V[\x93aV=a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xA3_\x80\x80aU\xF6V[aVtaV]_a)>V[_\x91\x82\x91cJ\x14\x06\xB1`\xE1\x1B\x83R`\x04\x83\x01a\x11\xFEV[\x03\x90\xFD[aV\x9BaV\x84_a)>V[_\x91\x82\x91c\xE6\x02\xDF\x05`\xE0\x1B\x83R`\x04\x83\x01a\x11\xFEV[\x03\x90\xFD[\x91` aV\xC0\x92\x94\x93aV\xB9`@\x82\x01\x96_\x83\x01\x90a\x06cV[\x01\x90a\x0C\x9DV[V[\x90aV\xD7aV\xD1\x83\x83\x90a;\xD1V[\x15a\x05AV[aV\xDFWPPV[aV\xF9_\x92\x83\x92c\xE2Q}?`\xE0\x1B\x84R`\x04\x84\x01aV\x9FV[\x03\x90\xFD[\x91aW\n\x92\x91\x90\x91ag\x13V[V[\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x90V[\x90\x95\x94\x92aW{\x94aWjaWt\x92aW``\x80\x96aWV`\xA0\x88\x01\x9C_\x89\x01\x90a\x0C\x9DV[` \x87\x01\x90a\x0C\x9DV[`@\x85\x01\x90a\x0C\x9DV[``\x83\x01\x90a\x07\xD4V[\x01\x90a\x06cV[V[aW\x85a-\xACV[PaW\x8EaW\x0CV[aX\x05\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91aW\xF6\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0FaW\xE10a:\xA2V[\x91aW\xEAa\x04\xE2V[\x96\x87\x95` \x87\x01aW0V[` \x82\x01\x81\x03\x82R\x03\x82a\x0B\x9AV[aX\x17aX\x11\x82a\x06pV[\x91aEgV[ \x90V[aX/aX*aX4\x92a\x12\xE5V[a\x10\x0BV[a\r\x88V[\x90V[aX@\x90aX\x1BV[\x90RV[\x91` aXe\x92\x94\x93aX^`@\x82\x01\x96_\x83\x01\x90aX7V[\x01\x90a\x07\xD4V[V[aX{aXvaX\x80\x92a\x07-V[a\x10\x0BV[a\x18\xBEV[\x90V[aX\x8Ba;\xFBV[P\x80aX\xA5aX\x9Fe\xFF\xFF\xFF\xFF\xFF\xFFaL\xD5V[\x91a\x07-V[\x11aX\xB6WaX\xB3\x90aXgV[\x90V[`0aX\xD2_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01aXDV[\x03\x90\xFD[\x90V[aX\xEDaX\xE8aX\xF2\x92aX\xD6V[a\x10\x0BV[a\x07-V[\x90V[\x90V[aY\x0CaY\x07aY\x11\x92aX\xF5V[a\x10\x0BV[a\r\x88V[\x90V[aY3\x90aY-aY'aY8\x94a\r\x88V[\x91a\x07-V[\x90a\tMV[a\x07-V[\x90V[\x90V[aYRaYMaYW\x92aY;V[a\x10\x0BV[a\r\x88V[\x90V[aYy\x90aYsaYmaY~\x94a\r\x88V[\x91a\x07-V[\x90a&$V[a\x07-V[\x90V[\x90V[aY\x98aY\x93aY\x9D\x92aY\x81V[a\x10\x0BV[a\x07-V[\x90V[\x90V[aY\xB7aY\xB2aY\xBC\x92aY\xA0V[a\x10\x0BV[a\r\x88V[\x90V[\x90V[aY\xD6aY\xD1aY\xDB\x92aY\xBFV[a\x10\x0BV[a\x07-V[\x90V[\x90V[aY\xF5aY\xF0aY\xFA\x92aY\xDEV[a\x10\x0BV[a\r\x88V[\x90V[\x90V[aZ\x14aZ\x0FaZ\x19\x92aY\xFDV[a\x10\x0BV[a\x07-V[\x90V[\x90V[aZ3aZ.aZ8\x92aZ\x1CV[a\x10\x0BV[a\r\x88V[\x90V[\x90V[aZRaZMaZW\x92aZ;V[a\x10\x0BV[a\x07-V[\x90V[\x90V[aZqaZlaZv\x92aZZV[a\x10\x0BV[a\r\x88V[\x90V[aZ\x8DaZ\x88aZ\x92\x92aY\xDEV[a\x10\x0BV[a\x07-V[\x90V[\x90V[aZ\xACaZ\xA7aZ\xB1\x92aZ\x95V[a\x10\x0BV[a\r\x88V[\x90V[aZ\xC8aZ\xC3aZ\xCD\x92aZZV[a\x10\x0BV[a\x07-V[\x90V[aZ\xE4aZ\xDFaZ\xE9\x92aB\xF6V[a\x10\x0BV[a\r\x88V[\x90V[\x90V[a[\x03aZ\xFEa[\x08\x92aZ\xECV[a\x10\x0BV[a\x07-V[\x90V[\x90a[\x16\x91\x02a\x07-V[\x90V[a[%a[+\x91a\x07-V[\x91a\x07-V[\x90\x81\x15a[6W\x04\x90V[a+\x9FV[\x90a[F\x91\x01a\x07-V[\x90V[a[Qa%\xD5V[P\x80a[fa[``\x01aB\xF9V[\x91a\x07-V[\x11\x15a^\xB1W\x80a]{a]Xa]Ha]8a](a]\x18a]\x08a\\\xF8a\\\xE8a\\\xD8a\\\xC8\x8Ba\\\xC2a\\\xBBa]\x81\x9Fa\\\x9Ba\\\x8Ba\\\xAB\x92a[\xAD`\x01aB\xF9V[\x90\x80a[\xC5a[\xBF`\x01`\x80\x1BaX\xD9V[\x91a\x07-V[\x10\x15a^\x83W[\x80a[\xE8a[\xE2h\x01\0\0\0\0\0\0\0\0aY\x84V[\x91a\x07-V[\x10\x15a^UW[\x80a\\\x07a\\\x01d\x01\0\0\0\0aY\xC2V[\x91a\x07-V[\x10\x15a^'W[\x80a\\$a\\\x1Eb\x01\0\0aZ\0V[\x91a\x07-V[\x10\x15a]\xF9W[\x80a\\@a\\:a\x01\0aZ>V[\x91a\x07-V[\x10\x15a]\xCBW[\x80a\\[a\\U`\x10aZyV[\x91a\x07-V[\x10\x15a]\x9DW[a\\ua\\o`\x04aZ\xB4V[\x91a\x07-V[\x10\x15a]\x84W[a\\\x86`\x03aZ\xEFV[a[\x0BV[a\\\x95`\x01aZ\xD0V[\x90aY\x14V[a\\\xA5\x81\x86a[\x19V[\x90a[;V[a\\\xB5`\x01aZ\xD0V[\x90aY\x14V[\x80\x92a[\x19V[\x90a[;V[a\\\xD2`\x01aZ\xD0V[\x90aY\x14V[a\\\xE2\x81\x8Ca[\x19V[\x90a[;V[a\\\xF2`\x01aZ\xD0V[\x90aY\x14V[a]\x02\x81\x8Aa[\x19V[\x90a[;V[a]\x12`\x01aZ\xD0V[\x90aY\x14V[a]\"\x81\x88a[\x19V[\x90a[;V[a]2`\x01aZ\xD0V[\x90aY\x14V[a]B\x81\x86a[\x19V[\x90a[;V[a]R`\x01aZ\xD0V[\x90aY\x14V[\x91a]ua]oa]j\x85\x80\x94a[\x19V[a\x07-V[\x91a\x07-V[\x11ag\xA3V[\x90aI\x0EV[\x90V[a]\x98\x90a]\x92`\x01aZ\xD0V[\x90aYZV[a\\|V[a]\xB4a]\xC5\x91a]\xAE`\x04aZ]V[\x90aY\x14V[\x91a]\xBF`\x02aZ\x98V[\x90aYZV[\x90a\\bV[a]\xE2a]\xF3\x91a]\xDC`\x08aZ\x1FV[\x90aY\x14V[\x91a]\xED`\x04aZ]V[\x90aYZV[\x90a\\GV[a^\x10a^!\x91a^\n`\x10aY\xE1V[\x90aY\x14V[\x91a^\x1B`\x08aZ\x1FV[\x90aYZV[\x90a\\+V[a^>a^O\x91a^8` aY\xA3V[\x90aY\x14V[\x91a^I`\x10aY\xE1V[\x90aYZV[\x90a\\\x0EV[a^la^}\x91a^f`@aY>V[\x90aY\x14V[\x91a^w` aY\xA3V[\x90aYZV[\x90a[\xEFV[a^\x9Aa^\xAB\x91a^\x94`\x80aX\xF8V[\x90aY\x14V[\x91a^\xA5`@aY>V[\x90aYZV[\x90a[\xCCV[\x90V[_R` _ \x01\x90V[\x93\x91\x90\x92a^\xCAa%\xD5V[P[\x81a^\xDFa^\xD9\x83a\x07-V[\x91a\x07-V[\x10\x15a_EWa^\xF0\x82\x82\x90ag\xCDV[\x90a_\x06_a_\0\x88\x85\x90a^\xB4V[\x01aM\xAFV[a_\x18a_\x12\x87a\x18\xBEV[\x91a\x18\xBEV[\x11_\x14a_(WP\x91[\x91a^\xCCV[\x92\x91Pa_?\x90a_9`\x01aB\xF9V[\x90a.ZV[\x90a_\"V[\x92PP\x91P\x90V[a_^a_Xa7\xA3V[\x15a\x05AV[a_dWV[_c\x8D\xFC +`\xE0\x1B\x81R\x80a_|`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x90a_\x89a%\xD5V[P\x81a_\x9Da_\x97\x83a\x07-V[\x91a\x07-V[\x10_\x14a_\xA9WP[\x90V[\x90Pa_\xA6V[a_\xC2\x90a_\xBCa%\xD5V[Pa8\xA9V[\x90V[\x90V[\x91\x90\x91\x80a_\xDEa_\xD8\x85a\x06WV[\x91a\x06WV[\x14\x15\x80aa\\W[a_\xF0W[PPPV[\x80a`\x0Ba`\x05a`\0_a)>V[a\x06WV[\x91a\x06WV[\x03a`\xCCW[P\x81a`-a`'a`\"_a)>V[a\x06WV[\x91a\x06WV[\x03a`9W[\x80a_\xEBV[a`\x80a`sa`z\x92a`O`\n\x86\x90a4GV[\x90a`ma`ga`a`\x01\x93ahfV[\x93a4]V[\x91a_\xC5V[\x90ah\xB9V[\x92\x90a4`V[\x91a4`V[\x91\x90\x91a`\xAD\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\x106V[\x92a`\xC2a`\xB9a\x04\xE2V[\x92\x83\x92\x83a\n1V[\x03\x90\xA2_\x80a`3V[aa\x0Baa\x11aa\x04a`\xE1`\n\x85\x90a4GV[`\x02a`\xFEa`\xF8a`\xF2\x89ahfV[\x93a4]V[\x91a_\xC5V[\x90ah\xB9V[\x92\x90a4`V[\x91a4`V[\x91\x90\x91aa>\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\x106V[\x92aaSaaJa\x04\xE2V[\x92\x83\x92\x83a\n1V[\x03\x90\xA2_a`\x11V[P\x81aapaaj_a)\x06V[\x91a\x07-V[\x11a_\xE6V[_aa\x8A\x91aa\x83a%\xD5V[P\x01aMjV[\x90V[aa\xA1aa\x9Caa\xA6\x92a\x14\x93V[a\x10\x0BV[a\x07-V[\x90V[aa\xB2\x90aY\xA3V[\x90RV[\x91` aa\xD7\x92\x94\x93aa\xD0`@\x82\x01\x96_\x83\x01\x90aa\xA9V[\x01\x90a\x07\xD4V[V[aa\xEDaa\xE8aa\xF2\x92a\x07-V[a\x10\x0BV[a\x14\x93V[\x90V[aa\xFDa8zV[P\x80ab\x15ab\x0Fc\xFF\xFF\xFF\xFFaa\x8DV[\x91a\x07-V[\x11ab&Wab#\x90aa\xD9V[\x90V[` abB_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01aa\xB6V[\x03\x90\xFD[ab]abb\x91abUa%\xD5V[P`\x08a8\x93V[a\x10qV[\x90V[\x90V[ab|abwab\x81\x92abeV[a\x1BHV[a\x0CYV[\x90V[ab\x8E`\xFFabhV[\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90ab\xB4ab\xAD\x83a\n\xB1V[\x80\x94a$dV[\x91`\x01\x81\x16\x90\x81_\x14ac\x0BWP`\x01\x14ab\xCFW[PPPV[ab\xDC\x91\x92\x93\x94Pab\x91V[\x91_\x92[\x81\x84\x10ab\xF3WPP\x01\x90_\x80\x80ab\xCAV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90ab\xE0V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80ab\xCAV[\x90ac0\x91ab\x9AV[\x90V[\x90acSacL\x92acCa\x04\xE2V[\x93\x84\x80\x92ac&V[\x03\x83a\x0B\x9AV[V[ac^\x90ac3V[\x90V[\x90acja$_V[Pact\x82a-\xB0V[ac\x8Dac\x87ac\x82ab\x84V[a\x0CYV[\x91a\x0CYV[\x14\x15_\x14ac\xA2WPac\x9F\x90aiCV[\x90V[ac\xAC\x91PacUV[\x90V[`B\x91ac\xBAa-\xACV[P`@Q\x91\x7F\x19\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83R`\x02\x83\x01R`\"\x82\x01R \x90V[_\x90V[ad\0ad\x05\x91a\x10XV[a&MV[\x90V[\x90V[ad\x1Fad\x1Aad$\x92ad\x08V[a\x10\x0BV[a\x07-V[\x90V[ad\\adc\x94adR``\x94\x98\x97\x95adH`\x80\x86\x01\x9A_\x87\x01\x90a\x0C\x9DV[` \x85\x01\x90a\r\x8EV[`@\x83\x01\x90a\x0C\x9DV[\x01\x90a\x0C\x9DV[V[\x93\x92\x93adpa%SV[Padyac\xF0V[Pad\x82a-\xACV[Pad\x8C\x85ac\xF4V[ad\xBEad\xB8\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0ad\x0BV[\x91a\x07-V[\x11aeKW\x90ad\xE1` \x94\x95_\x94\x93\x92\x93ad\xD8a\x04\xE2V[\x94\x85\x94\x85ad'V[\x83\x80R\x03\x90`\x01Z\xFA\x15aeFWad\xF9_Qa\x1BHV[\x80ae\x14ae\x0Eae\t_a)>V[a\x06WV[\x91a\x06WV[\x14ae*W_\x91ae$_a\x1BMV[\x91\x92\x91\x90V[Pae4_a)>V[`\x01\x91ae@_a\x1BMV[\x91\x92\x91\x90V[a+\x16V[PPPaeW_a)>V[\x90`\x03\x92\x91\x92\x91\x90V[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x04\x11\x15ae\x7FWV[aeaV[\x90ae\x8E\x82aeuV[V[\x80ae\xA3ae\x9D_ae\x84V[\x91ae\x84V[\x14_\x14ae\xAEWPPV[\x80ae\xC2ae\xBC`\x01ae\x84V[\x91ae\x84V[\x14_\x14ae\xE5W_c\xF6E\xEE\xDF`\xE0\x1B\x81R\x80ae\xE1`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x80ae\xF9ae\xF3`\x02ae\x84V[\x91ae\x84V[\x14_\x14af'Waf#af\x0C\x83ac\xF4V[_\x91\x82\x91c\xFC\xE6\x98\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x07\xE1V[\x03\x90\xFD[af:af4`\x03ae\x84V[\x91ae\x84V[\x14afBWPV[af]\x90_\x91\x82\x91c5\xE2\xF3\x83`\xE2\x1B\x83R`\x04\x83\x01a\x0C\xAAV[\x03\x90\xFD[_R` _ \x90V[afs\x81aMjV[\x82\x10\x15af\x8DWaf\x85`\x01\x91afaV[\x91\x02\x01\x90_\x90V[a\x0E\x03V[\x90af\x9C\x90a\x18\xBEV[\x90RV[\x90af\xAA\x90a\"SV[\x90RV[\x90af\xE4af\xDB_af\xBEaH)V[\x94af\xD5af\xCD\x83\x83\x01aM\xAFV[\x83\x88\x01af\x92V[\x01aM\xE1V[` \x84\x01af\xA0V[V[af\xEF\x90af\xAEV[\x90V[ag\x10\x91_ag\n\x92ag\x03aHdV[P\x01afjV[Paf\xE6V[\x90V[\x92\x91ag!\x84\x83\x83\x91aisV[\x83ag<ag6ag1_a)>V[a\x06WV[\x91a\x06WV[\x14agQW[agO\x92\x93\x91\x90\x91aj\xFDV[V[agYa(\xD6V[\x93agbaj\xE2V[\x94\x80agvagp\x88a\x07-V[\x91a\x07-V[\x11ag\x83WP\x93PagBV[\x85\x90ag\x9F_\x92\x83\x92c\x0EX\xAE\x93`\xE1\x1B\x84R`\x04\x84\x01a\n1V[\x03\x90\xFD[ag\xABa%\xD5V[P\x15\x15\x90V[ag\xC5ag\xC0ag\xCA\x92aZ\x95V[a\x10\x0BV[a\x07-V[\x90V[ag\xF2ag\xF8\x92ag\xDCa%\xD5V[P\x82\x81\x16\x92\x18ag\xEC`\x02ag\xB1V[\x90a+\xB3V[\x90a.ZV[\x90V[\x90V[ah\x12ah\rah\x17\x92ag\xFBV[a\x10\x0BV[a\r\x88V[\x90V[ah#\x90ag\xFEV[\x90RV[\x91` ahH\x92\x94\x93ahA`@\x82\x01\x96_\x83\x01\x90ah\x1AV[\x01\x90a\x07\xD4V[V[ah^ahYahc\x92a\x07-V[a\x10\x0BV[a\"SV[\x90V[ahna#\x86V[P\x80ah\x88ah\x82`\x01\x80`\xD0\x1B\x03a4`V[\x91a\x07-V[\x11ah\x99Wah\x96\x90ahJV[\x90V[`\xD0ah\xB5_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01ah'V[\x03\x90\xFD[\x90ah\xEFah\xF5\x93\x92ah\xCAa#\x86V[Pah\xD3a#\x86V[P\x80\x93ah\xE8ah\xE1a;\xFFV[\x94\x92aS\xB7V[\x90\x91aoeV[\x91ak\xBCV[\x91\x90\x91\x90V[ai\x0Fai\nai\x14\x92aY\xA0V[a\x10\x0BV[a\x07-V[\x90V[6\x907V[\x90aiAai)\x83a6zV[\x92` \x80ai7\x86\x93a6WV[\x92\x01\x91\x03\x90ai\x17V[V[aiKa$_V[PaiU\x81al&V[\x90aihaic` ah\xFBV[ai\x1CV[\x91\x82R` \x82\x01R\x90V[\x91\x90\x91\x80ai\x91ai\x8Bai\x86_a)>V[a\x06WV[\x91a\x06WV[\x14_\x14ajrWai\xB5ai\xAE\x83ai\xA9`\x02a\x10qV[a.ZV[`\x02a)\xA5V[[\x82ai\xD1ai\xCBai\xC6_a)>V[a\x06WV[\x91a\x06WV[\x14_\x14ajFWai\xF5ai\xEE\x83ai\xE9`\x02a\x10qV[aI\x0EV[`\x02a)\xA5V[[\x91\x90\x91ajAaj/aj)\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x93a\x106V[\x93a\x106V[\x93aj8a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xA3V[ajm\x82ajgajX_\x87\x90a8\x93V[\x91ajb\x83a\x10qV[a[;V[\x90a)\xA5V[ai\xF6V[aj\x85aj\x80_\x83\x90a8\x93V[a\x10qV[\x80aj\x98aj\x92\x85a\x07-V[\x91a\x07-V[\x10aj\xC0Waj\xABaj\xBB\x91\x84\x90aI\x0EV[aj\xB6_\x84\x90a8\x93V[a)\xA5V[ai\xB6V[\x90aj\xDE\x90\x91\x92_\x93\x84\x93c9\x144\xE3`\xE2\x1B\x85R`\x04\x85\x01aH\xDCV[\x03\x90\xFD[aj\xEAa%\xD5V[Paj\xFA`\x01\x80`\xD0\x1B\x03a4`V[\x90V[\x91akUakOak\\\x94\x80ak#ak\x1Dak\x18_a)>V[a\x06WV[\x91a\x06WV[\x14ak\x8DW[\x84akDak>ak9_a)>V[a\x06WV[\x91a\x06WV[\x14ak^W[a7HV[\x92a7HV[\x90\x91a_\xC8V[V[ak\x86`\x0B`\x02ak\x80akzakt\x89ahfV[\x93a4]V[\x91a_\xC5V[\x90ah\xB9V[PPakJV[ak\xB5`\x0B`\x01ak\xAFak\xA9ak\xA3\x89ahfV[\x93a4]V[\x91a_\xC5V[\x90ah\xB9V[PPak)V[\x91ak\xE0_ak\xE5\x94ak\xCDa#\x86V[Pak\xD6a#\x86V[P\x01\x92\x91\x92aM\x8DV[an\x17V[\x91\x90\x91\x90V[ak\xFFak\xFAal\x04\x92abeV[a\x10\x0BV[a\x07-V[\x90V[\x90V[al\x1Eal\x19al#\x92al\x07V[a\x10\x0BV[a\x07-V[\x90V[al;al@\x91al5a%\xD5V[Pa-\xB0V[ac\xF4V[alJ`\xFFak\xEBV[\x16\x80al_alY`\x1Fal\nV[\x91a\x07-V[\x11algW\x90V[_c,\xD4J\xC3`\xE2\x1B\x81R\x80al\x7F`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[T\x90V[al\x91`@a6BV[\x90V[_R` _ \x90V[al\xA6\x81al\x83V[\x82\x10\x15al\xC0Wal\xB8`\x01\x91al\x94V[\x91\x02\x01\x90_\x90V[a\x0E\x03V[al\xCF\x90Qa\x18\xBEV[\x90V[\x90al\xE3e\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x1BHV[\x91\x81\x19\x16\x91\x16\x17\x90V[am\x01al\xFCam\x06\x92a\x18\xBEV[a\x10\x0BV[a\x18\xBEV[\x90V[\x90V[\x90am!am\x1Cam(\x92al\xEDV[am\tV[\x82Tal\xD2V[\x90UV[am6\x90Qa\"SV[\x90V[`0\x1B\x90V[\x90amQe\xFF\xFF\xFF\xFF\xFF\xFF\x19\x91am9V[\x91\x81\x19\x16\x91\x16\x17\x90V[amoamjamt\x92a\"SV[a\x10\x0BV[a\"SV[\x90V[\x90V[\x90am\x8Fam\x8Aam\x96\x92am[V[amwV[\x82Tam?V[\x90UV[\x90am\xC4` _am\xCA\x94am\xBC\x82\x82\x01am\xB6\x84\x88\x01al\xC5V[\x90am\x0CV[\x01\x92\x01am,V[\x90amzV[V[\x91\x90am\xDDWam\xDB\x91am\x9AV[V[a\n\x8AV[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15an\x12W\x82an\n\x91`\x01an\x10\x95\x01\x81Ual\x9DV[\x90am\xCCV[V[a\x0B\x86V[\x90\x92\x91\x92an#a#\x86V[Pan,a#\x86V[Pan6\x82al\x83V[\x80anIanC_a)\x06V[\x91a\x07-V[\x11_\x14ao\x19Wano\x90ani\x84\x91anc`\x01aB\xF9V[\x90a+&V[\x90a^\xB4V[\x90an{_\x83\x01aM\xAFV[\x92an\x87_\x84\x01aM\xE1V[\x93\x80an\x9Ban\x95\x85a\x18\xBEV[\x91a\x18\xBEV[\x11an\xFDWan\xB2an\xAC\x84a\x18\xBEV[\x91a\x18\xBEV[\x14_\x14an\xCDWPPan\xC8\x90_\x85\x91\x01amzV[[\x91\x90V[an\xF8\x92Pan\xF3\x86an\xEAan\xE1al\x87V[\x94_\x86\x01af\x92V[` \x84\x01af\xA0V[am\xE2V[an\xC9V[_c% `\x1D`\xE0\x1B\x81R\x80ao\x15`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[PaoD\x91ao?\x85ao6ao-al\x87V[\x94_\x86\x01af\x92V[` \x84\x01af\xA0V[am\xE2V[aoM_aM\xEEV[\x91\x90V[cNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[\x91\x90\x91\x80`\x01\x14ao\x84W`\x02\x03aoQWao\x80\x91a$\x05V[\x90[V[Pao\x8E\x91a#\xC6V[\x90ao\x82V",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361015610013575b612382565b61001d5f356104dc565b806301ffc9a7146104d757806306fdde03146104d257806307a1d5fa146104cd578063095ea7b3146104c85780630c05f82c146104c357806313beaa5b146104be57806318160ddd146104b95780631b02f845146104b457806322a97d9c146104af57806323b872dd146104aa57806323e460d2146104a55780632481bb5c146104a0578063248a9ca31461049b578063284e1333146104965780632f2ff15d14610491578063313ce5671461048c578063334d0bbd14610487578063359b76fe146104825780633644e5151461047d57806336568abe146104785780633a46b1a8146104735780633f4ba83a1461046e57806340c10f191461046957806344e181aa1461046457806348b0daa61461045f5780634bdd36ce1461045a5780634bf5d7e914610455578063587cde1e146104505780635adf00211461044b5780635c19a95c146104465780635c975abb146104415780635f15c3c91461043c578063651fd268146104375780636c33bced146104325780636cf016251461042d5780636fc063be146104285780636fcfff451461042357806370a082311461041e578063726600ce1461041957806376671808146104145780637c790cab1461040f5780637ecebe001461040a5780638456cb591461040557806384b0196e146104005780638e539e8c146103fb578063902d55a5146103f657806391d14854146103f157806391ddadf4146103ec57806395d89b41146103e757806399127d9b146103e2578063998955d3146103dd5780639ab24eb0146103d85780639b7ef64b146103d35780639dc29fac146103ce578063a08d5654146103c9578063a217fddf146103c4578063a3d4485b146103bf578063a4d7e31d146103ba578063a571e184146103b5578063a70b9f0c146103b0578063a9059cbb146103ab578063af2aa63b146103a6578063b0ca253e146103a1578063babc394f1461039c578063bb4d443614610397578063c02ae75414610392578063c1eb71371461038d578063c3cda52014610388578063d505accf14610383578063d547741f1461037e578063dd62ed3e14610379578063e3abdfcb14610374578063e63ab1e91461036f578063f1127ed81461036a578063f508e19d146103655763f75e85120361000e5761234d565b6122e9565b6122a4565b6121c1565b61215d565b6120f8565b612097565b61205d565b611fb3565b611ef7565b611ec2565b611e8d565b611e54565b611de0565b611dab565b611d00565b611ccb565b611c5f565b611c2a565b611bf5565b611b80565b611b11565b611aa3565b611a6e565b6119f8565b6119c3565b61198e565b611920565b6118eb565b611888565b611853565b6117dd565b6117a1565b61165c565b611627565b6115ee565b61156c565b611528565b6114f3565b6114be565b61145e565b6113fa565b611386565b611351565b61131c565b6112b0565b61127d565b611248565b611213565b6111c9565b611194565b61115f565b611117565b610fd7565b610fa4565b610f6e565b610f3a565b610f05565b610ed2565b610e9d565b610db0565b610d54565b610cf4565b610cbf565b610c24565b610a54565b6109fb565b61098c565b61091a565b6108e5565b6108b1565b6107f6565b610780565b6106d4565b610617565b610568565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b63ffffffff60e01b1690565b610509816104f4565b0361051057565b5f80fd5b9050359061052182610500565b565b9060208282031261053c57610539915f01610514565b90565b6104ec565b151590565b61054f90610541565b9052565b9190610566905f60208501940190610546565b565b346105985761059461058361057e366004610523565b61241f565b61058b6104e2565b91829182610553565b0390f35b6104e8565b5f9103126105a757565b6104ec565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b6105ed6105f66020936105fb936105e4816105ac565b938480936105b0565b958691016105b9565b6105c4565b0190565b6106149160208201915f8184039101526105ce565b90565b346106475761062736600461059d565b61064361063261253d565b61063a6104e2565b918291826105ff565b0390f35b6104e8565b60018060a01b031690565b6106609061064c565b90565b61066c90610657565b9052565b5190565b60209181520190565b61069c6106a56020936106aa9361069381610670565b93848093610674565b958691016105b9565b6105c4565b0190565b916106d1926106c460408201935f830190610663565b602081840391015261067d565b90565b34610705576106e436600461059d565b6106ec612589565b906107016106f86104e2565b928392836106ae565b0390f35b6104e8565b61071381610657565b0361071a57565b5f80fd5b9050359061072b8261070a565b565b90565b6107398161072d565b0361074057565b5f80fd5b9050359061075182610730565b565b919060408382031261077b578061076f610778925f860161071e565b93602001610744565b90565b6104ec565b346107b1576107ad61079c610796366004610753565b906125b3565b6107a46104e2565b91829182610553565b0390f35b6104e8565b906020828203126107cf576107cc915f0161071e565b90565b6104ec565b6107dd9061072d565b9052565b91906107f4905f602085019401906107d4565b565b346108265761082261081161080c3660046107b6565b6125d9565b6108196104e2565b918291826107e1565b0390f35b6104e8565b5f80fd5b5f80fd5b5f80fd5b909182601f830112156108715781359167ffffffffffffffff831161086c57602001926001830284011161086757565b610833565b61082f565b61082b565b906020828203126108a7575f82013567ffffffffffffffff81116108a25761089e9201610837565b9091565b6104f0565b6104ec565b5f0190565b346108e0576108ca6108c4366004610876565b906128ca565b6108d26104e2565b806108dc816108ac565b0390f35b6104e8565b34610915576108f536600461059d565b6109116109006128d6565b6109086104e2565b918291826107e1565b0390f35b6104e8565b346109485761092a36600461059d565b610932612a9a565b61093a6104e2565b80610944816108ac565b0390f35b6104e8565b1c90565b60ff1690565b61096790600861096c930261094d565b610951565b90565b9061097a9154610957565b90565b610989603f5f9061096f565b90565b346109bc5761099c36600461059d565b6109b86109a761097d565b6109af6104e2565b91829182610553565b0390f35b6104e8565b90916060828403126109f6576109f36109dc845f850161071e565b936109ea816020860161071e565b93604001610744565b90565b6104ec565b34610a2c57610a28610a17610a113660046109c1565b91612aa4565b610a1f6104e2565b91829182610553565b0390f35b6104e8565b916020610a52929493610a4b60408201965f8301906107d4565b01906107d4565b565b34610a8557610a6c610a673660046107b6565b612bd5565b90610a81610a786104e2565b92839283610a31565b0390f35b6104e8565b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52602260045260245ffd5b9060016002830492168015610ad1575b6020831014610acc57565b610a9d565b91607f1691610ac1565b60209181520190565b5f5260205f2090565b905f9291805490610b07610b0083610ab1565b8094610adb565b916001811690815f14610b5e5750600114610b22575b505050565b610b2f9192939450610ae4565b915f925b818410610b4657505001905f8080610b1d565b60018160209295939554848601520191019290610b33565b92949550505060ff19168252151560200201905f8080610b1d565b90610b8391610aed565b90565b634e487b7160e01b5f52604160045260245ffd5b90610ba4906105c4565b810190811067ffffffffffffffff821117610bbe57604052565b610b86565b90610be3610bdc92610bd36104e2565b93848092610b79565b0383610b9a565b565b905f10610bf857610bf590610bc3565b90565b610a8a565b610c0960445f90610be5565b90565b610c219160208201915f81840391015261067d565b90565b34610c5457610c3436600461059d565b610c50610c3f610bfd565b610c476104e2565b91829182610c0c565b0390f35b6104e8565b90565b610c6581610c59565b03610c6c57565b5f80fd5b90503590610c7d82610c5c565b565b90602082820312610c9857610c95915f01610c70565b90565b6104ec565b610ca690610c59565b9052565b9190610cbd905f60208501940190610c9d565b565b34610cef57610ceb610cda610cd5366004610c7f565b612df6565b610ce26104e2565b91829182610caa565b0390f35b6104e8565b34610d2257610d0436600461059d565b610d0c6132cd565b610d146104e2565b80610d1e816108ac565b0390f35b6104e8565b9190604083820312610d4f5780610d43610d4c925f8601610c70565b9360200161071e565b90565b6104ec565b34610d8357610d6d610d67366004610d27565b90613301565b610d756104e2565b80610d7f816108ac565b0390f35b6104e8565b60ff1690565b610d9790610d88565b9052565b9190610dae905f60208501940190610d8e565b565b34610de057610dc036600461059d565b610ddc610dcb613330565b610dd36104e2565b91829182610d9b565b0390f35b6104e8565b90602082820312610dfe57610dfb915f01610744565b90565b6104ec565b634e487b7160e01b5f52603260045260245ffd5b50603090565b90565b610e2981610e17565b821015610e4357610e3b600191610e1d565b910201905f90565b610e03565b90565b610e5b906008610e60930261094d565b610e48565b90565b90610e6e9154610e4b565b90565b600f610e7c81610e17565b821015610e9957610e9691610e9091610e20565b90610e63565b90565b5f80fd5b34610ecd57610ec9610eb8610eb3366004610de5565b610e71565b610ec06104e2565b918291826107e1565b0390f35b6104e8565b34610f0057610ee236600461059d565b610eea6133e1565b610ef26104e2565b80610efc816108ac565b0390f35b6104e8565b34610f3557610f1536600461059d565b610f31610f206133eb565b610f286104e2565b91829182610caa565b0390f35b6104e8565b34610f6957610f53610f4d366004610d27565b906133ff565b610f5b6104e2565b80610f65816108ac565b0390f35b6104e8565b34610f9f57610f9b610f8a610f84366004610753565b9061347c565b610f926104e2565b918291826107e1565b0390f35b6104e8565b34610fd257610fb436600461059d565b610fbc6134da565b610fc46104e2565b80610fce816108ac565b0390f35b6104e8565b3461100657610ff0610fea366004610753565b906134e4565b610ff86104e2565b80611002816108ac565b0390f35b6104e8565b90565b61102261101d6110279261064c565b61100b565b61064c565b90565b6110339061100e565b90565b61103f9061102a565b90565b9061104c90611036565b5f5260205260405f2090565b5f1c90565b61106961106e91611058565b610e48565b90565b61107b905461105d565b90565b61108990600c611042565b6110945f8201611071565b916110a160018301611071565b916110ae60028201611071565b916110c760046110c060038501611071565b9301611071565b90565b909594926111159461110461110e926110fa6080966110f060a088019c5f8901906107d4565b60208701906107d4565b60408501906107d4565b60608301906107d4565b01906107d4565b565b3461114b5761114761113261112d3660046107b6565b61107e565b9161113e9593956104e2565b958695866110ca565b0390f35b6104e8565b61115c60405f90610e63565b90565b3461118f5761116f36600461059d565b61118b61117a611150565b6111826104e2565b918291826107e1565b0390f35b6104e8565b346111c4576111a436600461059d565b6111c06111af61361b565b6111b76104e2565b918291826107e1565b0390f35b6104e8565b346111f9576111d936600461059d565b6111f56111e46136dc565b6111ec6104e2565b918291826105ff565b0390f35b6104e8565b9190611211905f60208501940190610663565b565b346112435761123f61122e6112293660046107b6565b613748565b6112366104e2565b918291826111fe565b0390f35b6104e8565b346112785761125836600461059d565b611274611263613767565b61126b6104e2565b91829182610553565b0390f35b6104e8565b346112ab576112956112903660046107b6565b613790565b61129d6104e2565b806112a7816108ac565b0390f35b6104e8565b346112e0576112c036600461059d565b6112dc6112cb6137a3565b6112d36104e2565b91829182610553565b0390f35b6104e8565b90565b6112fc6112f7611301926112e5565b61100b565b61072d565b90565b61130e60306112e8565b90565b611319611304565b90565b3461134c5761132c36600461059d565b611348611337611311565b61133f6104e2565b918291826107e1565b0390f35b6104e8565b346113815761137d61136c6113673660046107b6565b6137b9565b6113746104e2565b918291826107e1565b0390f35b6104e8565b346113b45761139636600461059d565b61139e613870565b6113a66104e2565b806113b0816108ac565b0390f35b6104e8565b90565b6113d06113cb6113d5926113b9565b61100b565b61072d565b90565b6113ec6a084595161401484a0000006113bc565b90565b6113f76113d8565b90565b3461142a5761140a36600461059d565b6114266114156113ef565b61141d6104e2565b918291826107e1565b0390f35b6104e8565b9061143990611036565b5f5260205260405f2090565b61145b90611456600d915f9261142f565b61096f565b90565b3461148e5761148a6114796114743660046107b6565b611445565b6114816104e2565b91829182610553565b0390f35b6104e8565b63ffffffff1690565b6114a590611493565b9052565b91906114bc905f6020850194019061149c565b565b346114ee576114ea6114d96114d43660046107b6565b61387e565b6114e16104e2565b918291826114a9565b0390f35b6104e8565b346115235761151f61150e6115093660046107b6565b6138a9565b6115166104e2565b918291826107e1565b0390f35b6104e8565b346115585761155461154361153e3660046107b6565b6138c7565b61154b6104e2565b91829182610553565b0390f35b6104e8565b61156960415f90610e63565b90565b3461159c5761157c36600461059d565b61159861158761155d565b61158f6104e2565b918291826107e1565b0390f35b6104e8565b909594926115ec946115db6115e5926115d16080966115c760a088019c5f890190610546565b60208701906107d4565b60408501906107d4565b60608301906107d4565b01906107d4565b565b346116225761161e6116096116043660046107b6565b6138e6565b916116159593956104e2565b958695866115a1565b0390f35b6104e8565b346116575761165361164261163d3660046107b6565b613a56565b61164a6104e2565b918291826107e1565b0390f35b6104e8565b3461168a5761166c36600461059d565b611674613a8f565b61167c6104e2565b80611686816108ac565b0390f35b6104e8565b60ff60f81b1690565b6116a19061168f565b9052565b5190565b60209181520190565b60200190565b6116c19061072d565b9052565b906116d2816020936116b8565b0190565b60200190565b906116f96116f36116ec846116a5565b80936116a9565b926116b2565b905f5b8181106117095750505090565b90919261172261171c60019286516116c5565b946116d6565b91019190916116fc565b9395919461177d611772611791956117646117879561179e9c9a61175760e08c01925f8d0190611698565b8a820360208c01526105ce565b9088820360408a01526105ce565b9760608701906107d4565b6080850190610663565b60a0830190610c9d565b60c08184039101526116dc565b90565b346117d8576117b136600461059d565b6117d46117bc613b16565b936117cb9795979391936104e2565b9788978861172c565b0390f35b6104e8565b3461180d576118096117f86117f3366004610de5565b613ba0565b6118006104e2565b918291826107e1565b0390f35b6104e8565b90565b61182961182461182e92611812565b61100b565b61072d565b90565b6118456a52b7d2dcc80cd2e4000000611815565b90565b611850611831565b90565b346118835761186336600461059d565b61187f61186e611848565b6118766104e2565b918291826107e1565b0390f35b6104e8565b346118b9576118b56118a461189e366004610d27565b90613bd1565b6118ac6104e2565b91829182610553565b0390f35b6104e8565b65ffffffffffff1690565b6118d2906118be565b9052565b91906118e9905f602085019401906118c9565b565b3461191b576118fb36600461059d565b611917611906613bff565b61190e6104e2565b918291826118d6565b0390f35b6104e8565b346119505761193036600461059d565b61194c61193b613c13565b6119436104e2565b918291826105ff565b0390f35b6104e8565b90565b61196c61196761197192611955565b61100b565b61072d565b90565b61198062015180611958565b90565b61198b611974565b90565b346119be5761199e36600461059d565b6119ba6119a9611983565b6119b16104e2565b918291826107e1565b0390f35b6104e8565b346119f3576119ef6119de6119d93660046107b6565b613c29565b6119e66104e2565b918291826107e1565b0390f35b6104e8565b34611a2857611a24611a13611a0e3660046107b6565b613c84565b611a1b6104e2565b918291826107e1565b0390f35b6104e8565b90565b611a44611a3f611a4992611a2d565b61100b565b61072d565b90565b611a606a4a723dc6b40b8a9a000000611a30565b90565b611a6b611a4c565b90565b34611a9e57611a7e36600461059d565b611a9a611a89611a63565b611a916104e2565b918291826107e1565b0390f35b6104e8565b34611ad257611abc611ab6366004610753565b90613cb3565b611ac46104e2565b80611ace816108ac565b0390f35b6104e8565b9091606082840312611b0c57611b09611af2845f850161071e565b93611b008160208601610744565b93604001610744565b90565b6104ec565b34611b4057611b2a611b24366004611ad7565b91614064565b611b326104e2565b80611b3c816108ac565b0390f35b6104e8565b90565b5f1b90565b611b61611b5c611b6692611b45565b611b48565b610c59565b90565b611b725f611b4d565b90565b611b7d611b69565b90565b34611bb057611b9036600461059d565b611bac611b9b611b75565b611ba36104e2565b91829182610caa565b0390f35b6104e8565b60018060a01b031690565b611bd0906008611bd5930261094d565b611bb5565b90565b90611be39154611bc0565b90565b611bf260435f90611bd8565b90565b34611c2557611c0536600461059d565b611c21611c10611be6565b611c186104e2565b918291826111fe565b0390f35b6104e8565b34611c5a57611c3a36600461059d565b611c56611c45614071565b611c4d6104e2565b91829182610553565b0390f35b6104e8565b34611c8d57611c77611c723660046107b6565b614198565b611c7f6104e2565b80611c89816108ac565b0390f35b6104e8565b90565b611ca9611ca4611cae92611c92565b61100b565b61072d565b90565b611cbd62278d00611c95565b90565b611cc8611cb1565b90565b34611cfb57611cdb36600461059d565b611cf7611ce6611cc0565b611cee6104e2565b918291826107e1565b0390f35b6104e8565b34611d3157611d2d611d1c611d16366004610753565b906141a3565b611d246104e2565b91829182610553565b0390f35b6104e8565b50603090565b905090565b90565b60200190565b611d66611d60611d5983611d36565b8094611d3c565b91611d41565b5f915b838310611d765750505050565b611d8c611d8660019284516116c5565b92611d44565b92019190611d69565b9190611da9905f6106008501940190611d4a565b565b34611ddb57611dbb36600461059d565b611dd7611dc66142ca565b611dce6104e2565b91829182611d95565b0390f35b6104e8565b34611e1157611e0d611dfc611df6366004610753565b906142e0565b611e046104e2565b918291826107e1565b0390f35b6104e8565b611e4b611e5294611e41606094989795611e37608086019a5f8701906107d4565b60208501906107d4565b60408301906107d4565b0190610546565b565b34611e8857611e6436600461059d565b611e84611e6f614315565b90611e7b9492946104e2565b94859485611e16565b0390f35b6104e8565b34611ebd57611eb9611ea8611ea33660046107b6565b6144ba565b611eb06104e2565b918291826107e1565b0390f35b6104e8565b34611ef257611ed236600461059d565b611eee611edd6144cf565b611ee56104e2565b918291826107e1565b0390f35b6104e8565b34611f2757611f23611f12611f0d3660046107b6565b6144e3565b611f1a6104e2565b918291826107e1565b0390f35b6104e8565b611f3581610d88565b03611f3c57565b5f80fd5b90503590611f4d82611f2c565b565b909160c082840312611fae57611f67835f840161071e565b92611f758160208501610744565b92611f838260408301610744565b92611fab611f948460608501611f40565b93611fa28160808601610c70565b9360a001610c70565b90565b6104ec565b34611fe857611fd2611fc6366004611f4f565b9493909392919261456d565b611fda6104e2565b80611fe4816108ac565b0390f35b6104e8565b60e08183031261205857612003825f830161071e565b92612011836020840161071e565b9261201f8160408501610744565b9261202d8260608301610744565b9261205561203e8460808501611f40565b9361204c8160a08601610c70565b9360c001610c70565b90565b6104ec565b346120925761207c612070366004611fed565b959490949391936146c1565b6120846104e2565b8061208e816108ac565b0390f35b6104e8565b346120c6576120b06120aa366004610d27565b906147df565b6120b86104e2565b806120c2816108ac565b0390f35b6104e8565b91906040838203126120f357806120e76120f0925f860161071e565b9360200161071e565b90565b6104ec565b346121295761212561211461210e3660046120cb565b90614801565b61211c6104e2565b918291826107e1565b0390f35b6104e8565b7f6b9725f740f94b91b78060a1b17d1774656d381421a529ec98cdb013f4d9c25e90565b61215a61212e565b90565b3461218d5761216d36600461059d565b612189612178612152565b6121806104e2565b91829182610caa565b0390f35b6104e8565b7f65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a90565b6121be612192565b90565b346121f1576121d136600461059d565b6121ed6121dc6121b6565b6121e46104e2565b91829182610caa565b0390f35b6104e8565b6121ff81611493565b0361220657565b5f80fd5b90503590612217826121f6565b565b9190604083820312612241578061223561223e925f860161071e565b9360200161220a565b90565b6104ec565b61224f906118be565b9052565b60018060d01b031690565b61226790612253565b9052565b9060208061228d936122835f8201515f860190612246565b015191019061225e565b565b91906122a2905f6040850194019061226b565b565b346122d5576122d16122c06122ba366004612219565b9061486f565b6122c86104e2565b9182918261228f565b0390f35b6104e8565b6122e660425f90610e63565b90565b34612319576122f936600461059d565b6123156123046122da565b61230c6104e2565b918291826107e1565b0390f35b6104e8565b7fcce296b040332a080e6df13515a3ec2869e21cd20f7344af0987ddb938d8bd2190565b61234a61231e565b90565b3461237d5761235d36600461059d565b612379612368612342565b6123706104e2565b91829182610caa565b0390f35b6104e8565b5f80fd5b5f90565b634e487b7160e01b5f52601160045260245ffd5b6123aa6123b091612253565b91612253565b019060018060d01b0382116123c157565b61238a565b906123d9916123d3612386565b5061239e565b90565b6123e86123ee91612253565b91612253565b90039060018060d01b03821161240057565b61238a565b9061241891612412612386565b506123dc565b90565b5f90565b61242761241b565b508061244261243c637965db0b60e01b6104f4565b916104f4565b1490811561244f575b5090565b6124599150614885565b5f61244b565b606090565b60209181520190565b5f5260205f2090565b905f929180549061249061248983610ab1565b8094612464565b916001811690815f146124e757506001146124ab575b505050565b6124b8919293945061246d565b915f925b8184106124cf57505001905f80806124a6565b600181602092959395548486015201910192906124bc565b92949550505060ff19168252151560200201905f80806124a6565b9061250c91612476565b90565b9061252f6125289261251f6104e2565b93848092612502565b0383610b9a565b565b61253a9061250f565b90565b61254561245f565b506125506003612531565b90565b5f90565b606090565b61256861256d91611058565b611bb5565b90565b61257a905461255c565b90565b61258690610bc3565b90565b612591612553565b5061259a612557565b506125a56043612570565b906125b0604461257d565b90565b6125d0916125bf61241b565b506125c86148ab565b9190916148b8565b600190565b5f90565b5f6125f16125f7926125e96125d5565b50600c611042565b01611071565b90565b906126149161260f61260a61231e565b6148c8565b612874565b565b5090565b601f602091010490565b1b90565b9190600861264391029161263d5f1984612624565b92612624565b9181191691161790565b61266161265c6126669261072d565b61100b565b61072d565b90565b90565b919061268261267d61268a9361264d565b612669565b908354612628565b9055565b6126a09161269a6125d5565b9161266c565b565b5b8181106126ae575050565b806126bb5f60019361268e565b016126a3565b9190601f81116126d1575b505050565b6126dd61270293610ae4565b9060206126e98461261a565b8301931061270a575b6126fb9061261a565b01906126a2565b5f80806126cc565b91506126fb819290506126f2565b90612728905f199060080261094d565b191690565b8161273791612718565b906002021790565b9161274a9082612616565b9067ffffffffffffffff82116128095761276e826127688554610ab1565b856126c1565b5f90601f83116001146127a157918091612790935f92612795575b505061272d565b90555b565b90915001355f80612789565b601f198316916127b085610ae4565b925f5b8181106127f1575091600293918560019694106127d7575b50505002019055612793565b6127e7910135601f841690612718565b90555f80806127cb565b919360206001819287870135815501950192016127b3565b610b86565b90612819929161273f565b565b90825f939282370152565b9190612840816128398161284595610674565b809561281b565b6105c4565b0190565b91612863612871949260408501908582035f87015261067d565b926020818503910152612826565b90565b9061287f604461257d565b61288c838390604461280e565b9190916128c57fb9a2088426f03b30a81c06428094fbfa9e2692739b3241af6b9ab1da4b5546be936128bc6104e2565b93849384612849565b0390a1565b906128d4916125fa565b565b6128de6125d5565b506128e96002611071565b90565b6128fc6128f761212e565b6148c8565b6129046129c5565b565b61291a61291561291f92611b45565b61100b565b61072d565b90565b61293661293161293b92611b45565b61100b565b61064c565b90565b61294790612922565b90565b9061295660ff91611b48565b9181191691161790565b61296990610541565b90565b90565b9061298461297f61298b92612960565b61296c565b825461294a565b9055565b9061299b5f1991611b48565b9181191691161790565b906129ba6129b56129c19261264d565b612669565b825461298f565b9055565b6129cf6040611071565b6129e16129db5f612906565b9161072d565b03612a7e576129f06043612570565b612a0a612a046129ff5f61293e565b610657565b91610657565b14612a6257612a1b6001603f61296f565b612a264260406129a5565b42612a5d7f1194b034cfa9ab5807494a1d5c667d8b0e6e97f38888742aa3871a322034116091612a546104e2565b918291826107e1565b0390a1565b5f633b0a48bd60e11b815280612a7a600482016108ac565b0390fd5b5f6338e93dbd60e11b815280612a96600482016108ac565b0390fd5b612aa26128ec565b565b91612ace92612ab161241b565b50612ac6612abd6148ab565b8290849161491c565b9190916149a8565b600190565b612adc9061102a565b90565b5f80fd5b60e01b90565b90505190612af682610730565b565b90602082820312612b1157612b0e915f01612ae9565b90565b6104ec565b612b1e6104e2565b3d5f823e3d90fd5b612b35612b3b9193929361072d565b9261072d565b8203918211612b4657565b61238a565b90565b612b62612b5d612b6792612b4b565b61100b565b61072d565b90565b612b79612b7f9193929361072d565b9261072d565b91612b8b83820261072d565b928184041490151715612b9a57565b61238a565b634e487b7160e01b5f52601260045260245ffd5b612bbf612bc59161072d565b9161072d565b908115612bd0570490565b612b9f565b612bdd6125d5565b91612be66125d5565b91612bfd5f612bf7600c8490611042565b01611071565b90612c156002612c0f600c8490611042565b01611071565b91612c4e6020612c2430612ad3565b63651fd26890612c438692612c376104e2565b95869485938493612ae3565b8352600483016111fe565b03915afa908115612da757612c99916020915f91612d7a575b5093612c7230612ad3565b612c8e63998955d3612c826104e2565b95869485938493612ae3565b8352600483016111fe565b03915afa908115612d75575f91612d47575b509181612cc0612cba5f612906565b9161072d565b11612d16575b505081612cdb612cd55f612906565b9161072d565b11612ce5575b5050565b612d0e929350612cf8612d099183612b26565b612d03612710612b4e565b90612b6a565b612bb3565b905f80612ce1565b612d3f929650612d29612d3a9183612b26565b612d34612710612b4e565b90612b6a565b612bb3565b935f80612cc6565b612d68915060203d8111612d6e575b612d608183610b9a565b810190612af8565b5f612cab565b503d612d56565b612b16565b612d9a9150823d8111612da0575b612d928183610b9a565b810190612af8565b5f612c67565b503d612d88565b612b16565b5f90565b612db990610c59565b90565b90612dc690612db0565b5f5260205260405f2090565b90565b612de1612de691611058565b612dd2565b90565b612df39054612dd5565b90565b6001612e0f612e1592612e07612dac565b506005612dbc565b01612de9565b90565b612e20614a45565b612e28612f7e565b565b612e36612e3b91611058565b610951565b90565b612e489054612e2a565b90565b6001612e57910161072d565b90565b612e69612e6f9193929361072d565b9261072d565b8201809211612e7a57565b61238a565b612e889061102a565b90565b612e949061100e565b90565b612ea090612e8b565b90565b612eac9061102a565b90565b5f910312612eb957565b6104ec565b905f9291805490612ed8612ed183610ab1565b8094610674565b916001811690815f14612f2f5750600114612ef3575b505050565b612f009192939450610ae4565b915f925b818410612f1757505001905f8080612eee565b60018160209295939554848601520191019290612f04565b92949550505060ff19168252151560200201905f8080612eee565b612f6e612f7b949293612f6460608401955f850190610663565b60208301906107d4565b6040818403910152612ebe565b90565b612f91612f8b603f612e3e565b15610541565b6132b157612f9d614071565b61329557612fc6612fb842612fb26040611071565b90612b26565b612fc0611cb1565b90612bb3565b80612fe2612fdc612fd76041611071565b61072d565b9161072d565b111561327957612ffc90612ff66041611071565b90612b26565b908161302a61302461301f61300f611304565b6130196041611071565b90612b26565b61072d565b9161072d565b11613256575b6130395f612906565b906130435f612906565b915b826130586130528661072d565b9161072d565b101561309f576130936130999161308d613087600f61308161307a6041611071565b8990612e5a565b90610e20565b90610e63565b90612e5a565b92612e4b565b91613045565b9150916130b66130af6042611071565b8390612e5a565b6130cf6130c96130c46113d8565b61072d565b9161072d565b1161323a576130ea6130f1916130e56041611071565b612e5a565b60416129a5565b61310e613107826131026042611071565b612e5a565b60426129a5565b61312161311a30612e7f565b8290614a6f565b61313e61312d30612e7f565b6131376043612570565b83916148b8565b61315861315361314e6043612570565b612e97565b612ea3565b6318b68b8c61316630612e7f565b8392604492813b15613235575f6131909161319b82966131846104e2565b98899788968795612ae3565b855260048501612f4a565b03925af1801561323057613204575b506131b56041611071565b906131bf5f61293e565b906131ea7f34b73d0c96e9ff4d5311434817c8ecc930e7d2782c5bde2e79dc44b0596755bb92611036565b926131ff6131f66104e2565b92839283610a31565b0390a2565b613223905f3d8111613229575b61321b8183610b9a565b810190612eaf565b5f6131aa565b503d613211565b612b16565b612adf565b5f6323064ebd60e01b815280613252600482016108ac565b0390fd5b9050613273613263611304565b61326d6041611071565b90612b26565b90613030565b5f63e085d22b60e01b815280613291600482016108ac565b0390fd5b5f631155624b60e21b8152806132ad600482016108ac565b0390fd5b5f6319afc99d60e21b8152806132c9600482016108ac565b0390fd5b6132d5612e18565b565b906132f2916132ed6132e882612df6565b6148c8565b6132f4565b565b906132fe91614acd565b50565b9061330b916132d7565b565b5f90565b90565b61332861332361332d92613311565b61100b565b610d88565b90565b61333861330d565b506133436012613314565b90565b61335661335161212e565b6148c8565b61335e613360565b565b61336a6040611071565b61337c6133765f612906565b9161072d565b146133c55761338d6001603f61296f565b7f4a792a0be42b5672faa40129fc6469072490775ca8d3c34e852d4d55d3a735a96133b66104e2565b806133c0816108ac565b0390a1565b5f638f98404160e01b8152806133dd600482016108ac565b0390fd5b6133e9613346565b565b6133f3612dac565b506133fc614b79565b90565b908061341a61341461340f6148ab565b610657565b91610657565b0361342b5761342891614c33565b50565b5f63334bd91960e11b815280613443600482016108ac565b0390fd5b9061345190611036565b5f5260205260405f2090565b90565b61347461346f61347992612253565b61100b565b61072d565b90565b6134b3916134a86134a261349d6134ae946134956125d5565b50600a613447565b61345d565b91614d14565b90614e0a565b613460565b90565b6134c66134c1611b69565b6148c8565b6134ce6134d0565b565b6134d8614f91565b565b6134e26134b6565b565b90816135006134fa6134f55f61293e565b610657565b91610657565b146135ff57806135186135125f612906565b9161072d565b146135e35761353a61353461352f600d339061142f565b612e3e565b15610541565b6135c75761354733614f9e565b61355e6001613558600c3390611042565b01611071565b61357061356a8361072d565b9161072d565b106135ab576135a9916135a48261359e600161358e600c3390611042565b019161359983611071565b612b26565b906129a5565b614a6f565b565b5f631c959ed960e21b8152806135c3600482016108ac565b0390fd5b5f634417760960e11b8152806135df600482016108ac565b0390fd5b5f631f2a200560e01b8152806135fb600482016108ac565b0390fd5b5f63d92e233d60e01b815280613617600482016108ac565b0390fd5b6136236125d5565b5061363f61362f6113d8565b6136396042611071565b90612b26565b90565b9061365561364e6104e2565b9283610b9a565b565b67ffffffffffffffff8111613675576136716020916105c4565b0190565b610b86565b9061368c61368783613657565b613642565b918252565b5f7f6d6f64653d626c6f636b6e756d6265722666726f6d3d64656661756c74000000910152565b6136c2601d61367a565b906136cf60208301613691565b565b6136d96136b8565b90565b6136e461245f565b506136ed613bff565b6137066137006136fb615139565b6118be565b916118be565b03613716576137136136d1565b90565b5f6301bfc1c560e61b81528061372e600482016108ac565b0390fd5b9061373c90611036565b5f5260205260405f2090565b61375f61376491613757612553565b506009613732565b612570565b90565b61376f61241b565b5061377a6040611071565b61378c6137865f612906565b9161072d565b1190565b6137a19061379c6148ab565b61514e565b565b6137ab61241b565b506137b6600e612e3e565b90565b613810906137c56125d5565b506137dd60016137d7600c8490611042565b01611071565b9061380a60046138046137fc5f6137f6600c8790611042565b01611071565b93600c611042565b01611071565b916151d9565b90565b61382361381e612192565b6148c8565b61382b61382d565b565b6138385f603f61296f565b7f73a5fc60aafeec8f139af22d98e62140e2ce914d1f155c692b427757c3e4014c6138616104e2565b8061386b816108ac565b0390a1565b613878613813565b565b5f90565b6138909061388a61387a565b50615285565b90565b9061389d90611036565b5f5260205260405f2090565b6138bf6138c4916138b86125d5565b505f613893565b611071565b90565b6138de6138e3916138d661241b565b50600d61142f565b612e3e565b90565b906138ef61241b565b506138f86125d5565b506139016125d5565b5061390a6125d5565b506139136125d5565b50613928613923600d849061142f565b612e3e565b9161393f5f613939600c8490611042565b01611071565b916139576002613951600c8590611042565b01611071565b90613990602061396630612ad3565b63651fd2689061398587926139796104e2565b95869485938493612ae3565b8352600483016111fe565b03915afa908115613a51576139db916020915f91613a24575b50946139b430612ad3565b6139d063998955d36139c46104e2565b95869485938493612ae3565b8352600483016111fe565b03915afa908115613a1f575f916139f1575b5090565b613a12915060203d8111613a18575b613a0a8183610b9a565b810190612af8565b5f6139ed565b503d613a00565b612b16565b613a449150823d8111613a4a575b613a3c8183610b9a565b810190612af8565b5f6139a9565b503d613a32565b612b16565b613a6890613a626125d5565b506152b4565b90565b613a7b613a76612192565b6148c8565b613a83613a85565b565b613a8d61532a565b565b613a97613a6b565b565b5f90565b606090565b613aab9061102a565b90565b67ffffffffffffffff8111613ac65760208091020190565b610b86565b90613add613ad883613aae565b613642565b918252565b369037565b90613b0c613af483613acb565b92602080613b028693613aae565b9201910390613ae2565b565b600f60f81b90565b613b1e613a99565b50613b2761245f565b50613b3061245f565b50613b396125d5565b50613b42612553565b50613b4b612dac565b50613b54613a9d565b50613b5d615337565b90613b66615377565b904690613b7230613aa2565b90613b7c5f611b4d565b90613b8e613b895f612906565b613ae7565b90613b97613b0e565b96959493929190565b613bc9613bce91613baf6125d5565b50613bc3613bbd600b61345d565b91614d14565b90614e0a565b613460565b90565b613bf8915f613bed613bf393613be561241b565b506005612dbc565b0161142f565b612e3e565b90565b5f90565b613c07613bfb565b50613c10615139565b90565b613c1b61245f565b50613c266004612531565b90565b613c8190613c356125d5565b50613c4d6003613c47600c8490611042565b01611071565b90613c7b6004613c75613c6d6002613c67600c8790611042565b01611071565b93600c611042565b01611071565b916151d9565b90565b613cab613ca6613ca1613cb093613c996125d5565b50600a613447565b61345d565b6153b7565b613460565b90565b9081613ccf613cc9613cc45f61293e565b610657565b91610657565b14613dce5780613ce7613ce15f612906565b9161072d565b14613db257613d09613d03613cfe600d339061142f565b612e3e565b15610541565b613d9657613d1633614f9e565b613d2d6003613d27600c3390611042565b01611071565b613d3f613d398361072d565b9161072d565b10613d7a57613d7891613d7382613d6d6003613d5d600c3390611042565b0191613d6883611071565b612b26565b906129a5565b61542c565b565b5f631c959ed960e21b815280613d92600482016108ac565b0390fd5b5f634417760960e11b815280613dae600482016108ac565b0390fd5b5f631f2a200560e01b815280613dca600482016108ac565b0390fd5b5f63d92e233d60e01b815280613de6600482016108ac565b0390fd5b90613e059291613e00613dfb61231e565b6148c8565b613e07565b565b80613e22613e1c613e175f61293e565b610657565b91610657565b1461404857613e44613e3e613e39600d849061142f565b612e3e565b15610541565b8061400d575b613fb1575b81613e62613e5c5f612906565b9161072d565b1480613f97575b80613f7d575b613f22575b613e7d81614f9e565b613e94825f613e8e600c8590611042565b016129a5565b613eac836002613ea6600c8590611042565b016129a5565b613ec4826001613ebe600c8590611042565b016129a5565b613edc836003613ed6600c8590611042565b016129a5565b9091613f087faa807d0abf30d91968c7478c66b6d82521a106af13eda036e2036da9af16895892611036565b92613f1d613f146104e2565b92839283610a31565b0390a2565b613f375f613f32600d849061142f565b61296f565b80613f627f02c2f0ba15b03f88b18f4832609a18cf35fc6b3f4546a9992076d7453d1334a891611036565b90613f6b6104e2565b80613f75816108ac565b0390a2613e74565b50613f92613f8d600d839061142f565b612e3e565b613e6f565b5082613fab613fa55f612906565b9161072d565b14613e69565b613fc76001613fc2600d849061142f565b61296f565b80613ff27f6cf28439a2daab1b265097227212a5b71e0a76f9ed85e3f815b5a6c3e218eb7f91611036565b90613ffb6104e2565b80614005816108ac565b0390a2613e4f565b508161402161401b5f612906565b9161072d565b11801561402e575b613e4a565b508261404261403c5f612906565b9161072d565b11614029565b5f63d92e233d60e01b815280614060600482016108ac565b0390fd5b9061406f9291613dea565b565b61407961241b565b506140846041611071565b61409d614097614092611304565b61072d565b9161072d565b101590565b6140bb906140b66140b161231e565b6148c8565b6140fb565b565b906140ce60018060a01b0391611b48565b9181191691161790565b90565b906140f06140eb6140f792611036565b6140d8565b82546140bd565b9055565b8061411661411061410b5f61293e565b610657565b91610657565b1461417c576141256043612570565b6141308260436140db565b9061416461415e7f07015b6a9f05913148fd5faddf2acc9708f305937f3072ca2b4b46faa5d0898b93611036565b91611036565b9161416d6104e2565b80614177816108ac565b0390a3565b5f63d92e233d60e01b815280614194600482016108ac565b0390fd5b6141a1906140a2565b565b6141c0916141af61241b565b506141b86148ab565b9190916149a8565b600190565b67ffffffffffffffff81116141da5760200290565b610b86565b6141eb6141f0916141c5565b613642565b90565b90614211614200836141df565b9261420b84916141c5565b90613ae2565b565b61421d60306141f3565b90565b905090565b61422f905461105d565b90565b60010190565b61425461424e61424783610e17565b8094614220565b91610e1d565b5f915b8383106142645750505050565b61428161427b60019261427685614225565b6116c5565b92614232565b92019190614257565b906142988161060093614238565b0190565b906142bc6142b5926142ac6104e2565b9384809261428a565b0383610b9a565b565b6142c79061429c565b90565b6142d2614213565b506142dd600f6142be565b90565b906142f3916142ed6125d5565b5061347c565b90565b90565b61430d614308614312926142f6565b61100b565b61072d565b90565b61431d6125d5565b506143266125d5565b5061432f6125d5565b5061433861241b565b506143436040611071565b61435561434f5f612906565b9161072d565b146144945761437f6143714261436b6040611071565b90612b26565b614379611cb1565b90612bb3565b906143c161438d6040611071565b6143bb6143ad61439d6041611071565b6143a760016142f9565b90612e5a565b6143b5611cb1565b90612b6a565b90612e5a565b6143cb6041611071565b6143e46143de6143d9611304565b61072d565b9161072d565b105f1461448657614409614403600f6143fd6041611071565b90610e20565b90610e63565b5b92614415603f612e3e565b9081614462575b5080614438575b9161442e6041611071565b9193929193929190565b506144436041611071565b61445c614456614451611304565b61072d565b9161072d565b10614423565b905061447f6144796144746041611071565b61072d565b9161072d565b115f61441c565b61448f5f612906565b61440a565b5f905f915f916144b66144b06144aa5f94612906565b95612906565b93612906565b9190565b6144cc906144c66125d5565b50613c84565b90565b6144d76125d5565b506144e06128d6565b90565b60026144fc614502926144f46125d5565b50600c611042565b01611071565b90565b7fe48329057bfd03d55e49b547132e39cffd9c1820ad7b9d4c5307691425d15adf90565b61455e6145659461455460609498979561454a608086019a5f870190610c9d565b6020850190610663565b60408301906107d4565b01906107d4565b565b60200190565b93959490929195426145876145818961072d565b9161072d565b1161460057916145f2916145f9936145e96145fe98996145d16145a8614505565b6145c28b938b6145b66104e2565b95869460208601614529565b60208201810382520382610b9a565b6145e36145dd82610670565b91614567565b2061548b565b929091926154a8565b91826154f2565b61514e565b565b61461b875f918291632341d78760e11b8352600483016107e1565b0390fd5b7f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c990565b919461468b6146959298979561468160a09661467761469c9a61466d60c08a019e5f8b0190610c9d565b6020890190610663565b6040870190610663565b60608501906107d4565b60808301906107d4565b01906107d4565b565b9160206146bf9294936146b860408201965f830190610663565b0190610663565b565b9695919392949094426146dc6146d68361072d565b9161072d565b11614796579061474561474e94939261472d6146f661461f565b61471e8c80948c916147088d91615535565b91926147126104e2565b97889660208801614643565b60208201810382520382610b9a565b61473f61473982610670565b91614567565b2061548b565b929091926154a8565b8061476161475b87610657565b91610657565b03614776575061477492939190916148b8565b565b84906147925f9283926325c0072360e11b84526004840161469e565b0390fd5b6147b1905f91829163313c898160e11b8352600483016107e1565b0390fd5b906147d0916147cb6147c682612df6565b6148c8565b6147d2565b565b906147dc91614c33565b50565b906147e9916147b5565b565b906147f590611036565b5f5260205260405f2090565b6148269161481c614821926148146125d5565b5060016147eb565b613893565b611071565b90565b6148336040613642565b90565b5f90565b5f90565b614846614829565b9060208083614853614836565b81520161485e61483a565b81525050565b61486c61483e565b90565b906148829161487c614864565b50615568565b90565b61488d61241b565b506148a76148a16301ffc9a760e01b6104f4565b916104f4565b1490565b6148b3612553565b503390565b916148c69291600192615590565b565b6148da906148d46148ab565b906156c2565b565b60409061490561490c94969593966148fb60608401985f850190610663565b60208301906107d4565b01906107d4565b565b90614919910361072d565b90565b92919261492a818390614801565b908161493f6149395f1961072d565b9161072d565b1061494c575b5050509050565b8161495f6149598761072d565b9161072d565b106149855761497c939461497491939261490e565b905f92615590565b805f8080614945565b506149a4849291925f938493637dc7a0d960e11b8552600485016148dc565b0390fd5b91826149c46149be6149b95f61293e565b610657565b91610657565b14614a1e57816149e46149de6149d95f61293e565b610657565b91610657565b146149f7576149f5929190916156fd565b565b614a1a614a035f61293e565b5f91829163ec442f0560e01b8352600483016111fe565b0390fd5b614a41614a2a5f61293e565b5f918291634b637e8f60e11b8352600483016111fe565b0390fd5b614a4d6137a3565b614a5357565b5f63d93c066560e01b815280614a6b600482016108ac565b0390fd5b80614a8a614a84614a7f5f61293e565b610657565b91610657565b14614aa657614aa491614a9c5f61293e565b9190916156fd565b565b614ac9614ab25f61293e565b5f91829163ec442f0560e01b8352600483016111fe565b0390fd5b614ad561241b565b50614aea614ae4828490613bd1565b15610541565b5f14614b7357614b126001614b0d5f614b0560058690612dbc565b01859061142f565b61296f565b90614b1b6148ab565b90614b58614b52614b4c7f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d95612db0565b92611036565b92611036565b92614b616104e2565b80614b6b816108ac565b0390a4600190565b50505f90565b614b81612dac565b50614b8b30613aa2565b614bbd614bb77f0000000000000000000000000000000000000000000000000000000000000000610657565b91610657565b1480614bf9575b5f14614bee577f000000000000000000000000000000000000000000000000000000000000000090565b614bf661577d565b90565b5046614c2d614c277f000000000000000000000000000000000000000000000000000000000000000061072d565b9161072d565b14614bc4565b614c3b61241b565b50614c47818390613bd1565b5f14614ccf57614c6e5f614c695f614c6160058690612dbc565b01859061142f565b61296f565b90614c776148ab565b90614cb4614cae614ca87ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b95612db0565b92611036565b92611036565b92614cbd6104e2565b80614cc7816108ac565b0390a4600190565b50505f90565b614ce9614ce4614cee926118be565b61100b565b61072d565b90565b916020614d12929493614d0b60408201965f8301906107d4565b01906118c9565b565b614d1c613bfb565b50614d25613bff565b81614d38614d3283614cd5565b9161072d565b1015614d4b5750614d4890615883565b90565b90614d665f928392637669fc0f60e11b845260048401614cf1565b0390fd5b5490565b90565b614d85614d80614d8a92614d6e565b61100b565b61072d565b90565b90565b65ffffffffffff1690565b614da7614dac91611058565b614d90565b90565b614db99054614d9b565b90565b60301c90565b60018060d01b031690565b614dd9614dde91614dbc565b614dc2565b90565b614deb9054614dcd565b90565b614e02614dfd614e0792611b45565b61100b565b612253565b90565b90614e5e90614e17612386565b50614e235f8401614d6a565b614e2c5f612906565b908080614e42614e3c6005614d71565b9161072d565b11614ebf575b5090614e595f860193919293614d8d565b615ebe565b80614e71614e6b5f612906565b9161072d565b145f14614e87575050614e835f614dee565b5b90565b614eb45f91614eaf614ea984614eba960192614ea360016142f9565b90612b26565b91614d8d565b615eb4565b01614de1565b614e84565b80614ecd614ed39291615b49565b90612b26565b9083614f05614eff614efa5f614ef4818c01614eef8991614d8d565b615eb4565b01614daf565b6118be565b916118be565b105f14614f165750905b905f614e48565b9150614f2c90614f2660016142f9565b90612e5a565b614f0f565b614f39615f4d565b614f41614f43565b565b614f4e5f600e61296f565b614f566148ab565b614f8c7f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa91614f836104e2565b918291826111fe565b0390a1565b614f99614f31565b565b90565b614fac614fb191600c611042565b614f9b565b614fbd60048201611071565b614fcf614fc95f612906565b9161072d565b146151295761504b90614fee42614fe860048401611071565b90612b26565b80615008615002614ffd611974565b61072d565b9161072d565b10155f1461504d575061502861501f5f8301611071565b600183016129a5565b61504061503760028301611071565b600383016129a5565b5b60044291016129a5565b565b8061506061505a5f612906565b9161072d565b1161506c575b50615041565b61511a615108615123926150f76150ee6150dd6150cb6150bd6150ab61509d6150965f8d01611071565b8890612b6a565b6150a5611974565b90612bb3565b956150b860028c01611071565b612b6a565b6150c5611974565b90612bb3565b936150d860018a01611071565b612e5a565b6150e85f8901611071565b90615f80565b600187016129a5565b61510360038601611071565b612e5a565b61511460028501611071565b90615f80565b600383016129a5565b5f615066565b6151379060044291016129a5565b565b615141613bfb565b5061514b43615883565b90565b906151d7916151d161515f82613748565b6151748461516f60098690613732565b6140db565b828185906151b46151ae6151a87f3134e8a2e6d97e929a7e54011ea5485d7d196dd5f0ba4d4ef95803e8e3fc257f95611036565b92611036565b92611036565b926151bd6104e2565b806151c7816108ac565b0390a49291615fb0565b91615fc8565b565b90916151e36125d5565b50806151f76151f15f612906565b9161072d565b14615276576152069042612b26565b908161522161521b615216611974565b61072d565b9161072d565b10156152715761524561523761524b9385612b6a565b61523f611974565b90612bb3565b90612e5a565b8061525e6152588461072d565b9161072d565b115f1461526a57505b90565b9050615267565b505090565b5050506152825f612906565b90565b6152ac6152a76152a26152b19361529a61387a565b50600a613447565b61345d565b616176565b6161f5565b90565b6152c6906152c06125d5565b50616246565b90565b6152d1614a45565b6152d96152db565b565b6152e76001600e61296f565b6152ef6148ab565b6153257f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2589161531c6104e2565b918291826111fe565b0390a1565b6153326152c9565b565b90565b61533f61245f565b506153747f000000000000000000000000000000000000000000000000000000000000000061536e6006615334565b90616361565b90565b61537f61245f565b506153b47f00000000000000000000000000000000000000000000000000000000000000006153ae6007615334565b90616361565b90565b6153bf612386565b506153cb5f8201614d6a565b806153de6153d85f612906565b9161072d565b145f146153f45750506153f05f614dee565b5b90565b6154215f9161541c6154168461542796019261541060016142f9565b90612b26565b91614d8d565b615eb4565b01614de1565b6153f1565b908161544861544261543d5f61293e565b610657565b91610657565b1461546457615462919061545b5f61293e565b90916156fd565b565b6154876154705f61293e565b5f918291634b637e8f60e11b8352600483016111fe565b0390fd5b6154a590615497612dac565b506154a0614b79565b6163af565b90565b926154c3926154cc946154b9612553565b5092909192616465565b90929192616590565b90565b9160206154f09294936154e960408201965f830190610663565b01906107d4565b565b6154fb81615535565b9161550e6155088461072d565b9161072d565b03615517575050565b6155315f9283926301d4b62360e61b8452600484016154cf565b0390fd5b615549906155416125d5565b506008613893565b61556561555582611071565b9161555f83612e4b565b906129a5565b90565b9061558861558361558d9361557b614864565b50600a613447565b61345d565b6166f2565b90565b9092816155ad6155a76155a25f61293e565b610657565b91610657565b1461567857836155cd6155c76155c25f61293e565b610657565b91610657565b14615651576155f1836155ec6155e5600186906147eb565b8790613893565b6129a5565b6155fb575b505050565b91909161564661563461562e7f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92593611036565b93611036565b9361563d6104e2565b918291826107e1565b0390a35f80806155f6565b61567461565d5f61293e565b5f918291634a1406b160e11b8352600483016111fe565b0390fd5b61569b6156845f61293e565b5f91829163e602df0560e01b8352600483016111fe565b0390fd5b9160206156c09294936156b960408201965f830190610663565b0190610c9d565b565b906156d76156d1838390613bd1565b15610541565b6156df575050565b6156f95f92839263e2517d3f60e01b84526004840161569f565b0390fd5b9161570a92919091616713565b565b7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f90565b9095949261577b9461576a6157749261576060809661575660a088019c5f890190610c9d565b6020870190610c9d565b6040850190610c9d565b60608301906107d4565b0190610663565b565b615785612dac565b5061578e61570c565b6158057f0000000000000000000000000000000000000000000000000000000000000000916157f67f0000000000000000000000000000000000000000000000000000000000000000466157e130613aa2565b916157ea6104e2565b96879560208701615730565b60208201810382520382610b9a565b61581761581182610670565b91614567565b2090565b61582f61582a615834926112e5565b61100b565b610d88565b90565b6158409061581b565b9052565b91602061586592949361585e60408201965f830190615837565b01906107d4565b565b61587b6158766158809261072d565b61100b565b6118be565b90565b61588b613bfb565b50806158a561589f65ffffffffffff614cd5565b9161072d565b116158b6576158b390615867565b90565b60306158d25f9283926306dfcc6560e41b845260048401615844565b0390fd5b90565b6158ed6158e86158f2926158d6565b61100b565b61072d565b90565b90565b61590c615907615911926158f5565b61100b565b610d88565b90565b6159339061592d61592761593894610d88565b9161072d565b9061094d565b61072d565b90565b90565b61595261594d6159579261593b565b61100b565b610d88565b90565b6159799061597361596d61597e94610d88565b9161072d565b90612624565b61072d565b90565b90565b61599861599361599d92615981565b61100b565b61072d565b90565b90565b6159b76159b26159bc926159a0565b61100b565b610d88565b90565b90565b6159d66159d16159db926159bf565b61100b565b61072d565b90565b90565b6159f56159f06159fa926159de565b61100b565b610d88565b90565b90565b615a14615a0f615a19926159fd565b61100b565b61072d565b90565b90565b615a33615a2e615a3892615a1c565b61100b565b610d88565b90565b90565b615a52615a4d615a5792615a3b565b61100b565b61072d565b90565b90565b615a71615a6c615a7692615a5a565b61100b565b610d88565b90565b615a8d615a88615a92926159de565b61100b565b61072d565b90565b90565b615aac615aa7615ab192615a95565b61100b565b610d88565b90565b615ac8615ac3615acd92615a5a565b61100b565b61072d565b90565b615ae4615adf615ae9926142f6565b61100b565b610d88565b90565b90565b615b03615afe615b0892615aec565b61100b565b61072d565b90565b90615b16910261072d565b90565b615b25615b2b9161072d565b9161072d565b908115615b36570490565b612b9f565b90615b46910161072d565b90565b615b516125d5565b5080615b66615b6060016142f9565b9161072d565b1115615eb15780615d7b615d58615d48615d38615d28615d18615d08615cf8615ce8615cd8615cc88b615cc2615cbb615d819f615c9b615c8b615cab92615bad60016142f9565b9080615bc5615bbf600160801b6158d9565b9161072d565b1015615e83575b80615be8615be268010000000000000000615984565b9161072d565b1015615e55575b80615c07615c016401000000006159c2565b9161072d565b1015615e27575b80615c24615c1e62010000615a00565b9161072d565b1015615df9575b80615c40615c3a610100615a3e565b9161072d565b1015615dcb575b80615c5b615c556010615a79565b9161072d565b1015615d9d575b615c75615c6f6004615ab4565b9161072d565b1015615d84575b615c866003615aef565b615b0b565b615c956001615ad0565b90615914565b615ca58186615b19565b90615b3b565b615cb56001615ad0565b90615914565b8092615b19565b90615b3b565b615cd26001615ad0565b90615914565b615ce2818c615b19565b90615b3b565b615cf26001615ad0565b90615914565b615d02818a615b19565b90615b3b565b615d126001615ad0565b90615914565b615d228188615b19565b90615b3b565b615d326001615ad0565b90615914565b615d428186615b19565b90615b3b565b615d526001615ad0565b90615914565b91615d75615d6f615d6a858094615b19565b61072d565b9161072d565b116167a3565b9061490e565b90565b615d9890615d926001615ad0565b9061595a565b615c7c565b615db4615dc591615dae6004615a5d565b90615914565b91615dbf6002615a98565b9061595a565b90615c62565b615de2615df391615ddc6008615a1f565b90615914565b91615ded6004615a5d565b9061595a565b90615c47565b615e10615e2191615e0a60106159e1565b90615914565b91615e1b6008615a1f565b9061595a565b90615c2b565b615e3e615e4f91615e3860206159a3565b90615914565b91615e4960106159e1565b9061595a565b90615c0e565b615e6c615e7d91615e66604061593e565b90615914565b91615e7760206159a3565b9061595a565b90615bef565b615e9a615eab91615e9460806158f8565b90615914565b91615ea5604061593e565b9061595a565b90615bcc565b90565b5f5260205f200190565b93919092615eca6125d5565b505b81615edf615ed98361072d565b9161072d565b1015615f4557615ef08282906167cd565b90615f065f615f00888590615eb4565b01614daf565b615f18615f12876118be565b916118be565b115f14615f285750915b91615ecc565b929150615f3f90615f3960016142f9565b90612e5a565b90615f22565b925050915090565b615f5e615f586137a3565b15610541565b615f6457565b5f638dfc202b60e01b815280615f7c600482016108ac565b0390fd5b90615f896125d5565b5081615f9d615f978361072d565b9161072d565b105f14615fa957505b90565b9050615fa6565b615fc290615fbc6125d5565b506138a9565b90565b90565b91909180615fde615fd885610657565b91610657565b14158061615c575b615ff0575b505050565b8061600b6160056160005f61293e565b610657565b91610657565b036160cc575b508161602d6160276160225f61293e565b610657565b91610657565b03616039575b80615feb565b61608061607361607a9261604f600a8690613447565b9061606d616067616061600193616866565b9361345d565b91615fc5565b906168b9565b9290613460565b91613460565b9190916160ad7fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a72492611036565b926160c26160b96104e2565b92839283610a31565b0390a25f80616033565b61610b6161116161046160e1600a8590613447565b60026160fe6160f86160f289616866565b9361345d565b91615fc5565b906168b9565b9290613460565b91613460565b91909161613e7fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a72492611036565b9261615361614a6104e2565b92839283610a31565b0390a25f616011565b508161617061616a5f612906565b9161072d565b11615fe6565b5f61618a916161836125d5565b5001614d6a565b90565b6161a161619c6161a692611493565b61100b565b61072d565b90565b6161b2906159a3565b9052565b9160206161d79294936161d060408201965f8301906161a9565b01906107d4565b565b6161ed6161e86161f29261072d565b61100b565b611493565b90565b6161fd61387a565b508061621561620f63ffffffff61618d565b9161072d565b1161622657616223906161d9565b90565b60206162425f9283926306dfcc6560e41b8452600484016161b6565b0390fd5b61625d616262916162556125d5565b506008613893565b611071565b90565b90565b61627c61627761628192616265565b611b48565b610c59565b90565b61628e60ff616268565b90565b5f5260205f2090565b905f92918054906162b46162ad83610ab1565b8094612464565b916001811690815f1461630b57506001146162cf575b505050565b6162dc9192939450616291565b915f925b8184106162f357505001905f80806162ca565b600181602092959395548486015201910192906162e0565b92949550505060ff19168252151560200201905f80806162ca565b906163309161629a565b90565b9061635361634c926163436104e2565b93848092616326565b0383610b9a565b565b61635e90616333565b90565b9061636a61245f565b5061637482612db0565b61638d616387616382616284565b610c59565b91610c59565b14155f146163a2575061639f90616943565b90565b6163ac9150616355565b90565b6042916163ba612dac565b50604051917f19010000000000000000000000000000000000000000000000000000000000008352600283015260228201522090565b5f90565b61640061640591611058565b61264d565b90565b90565b61641f61641a61642492616408565b61100b565b61072d565b90565b61645c61646394616452606094989795616448608086019a5f870190610c9d565b6020850190610d8e565b6040830190610c9d565b0190610c9d565b565b939293616470612553565b506164796163f0565b50616482612dac565b5061648c856163f4565b6164be6164b87f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a061640b565b9161072d565b1161654b57906164e1602094955f949392936164d86104e2565b94859485616427565b838052039060015afa15616546576164f95f51611b48565b8061651461650e6165095f61293e565b610657565b91610657565b1461652a575f916165245f611b4d565b91929190565b506165345f61293e565b6001916165405f611b4d565b91929190565b612b16565b5050506165575f61293e565b9060039291929190565b634e487b7160e01b5f52602160045260245ffd5b6004111561657f57565b616561565b9061658e82616575565b565b806165a361659d5f616584565b91616584565b145f146165ae575050565b806165c26165bc6001616584565b91616584565b145f146165e5575f63f645eedf60e01b8152806165e1600482016108ac565b0390fd5b806165f96165f36002616584565b91616584565b145f146166275761662361660c836163f4565b5f91829163fce698f760e01b8352600483016107e1565b0390fd5b61663a6166346003616584565b91616584565b146166425750565b61665d905f9182916335e2f38360e21b835260048301610caa565b0390fd5b5f5260205f2090565b61667381614d6a565b82101561668d57616685600191616661565b910201905f90565b610e03565b9061669c906118be565b9052565b906166aa90612253565b9052565b906166e46166db5f6166be614829565b946166d56166cd838301614daf565b838801616692565b01614de1565b602084016166a0565b565b6166ef906166ae565b90565b616710915f61670a92616703614864565b500161666a565b506166e6565b90565b929161672184838391616973565b8361673c6167366167315f61293e565b610657565b91610657565b14616751575b61674f9293919091616afd565b565b6167596128d6565b93616762616ae2565b94806167766167708861072d565b9161072d565b1161678357509350616742565b859061679f5f928392630e58ae9360e11b845260048401610a31565b0390fd5b6167ab6125d5565b50151590565b6167c56167c06167ca92615a95565b61100b565b61072d565b90565b6167f26167f8926167dc6125d5565b5082811692186167ec60026167b1565b90612bb3565b90612e5a565b90565b90565b61681261680d616817926167fb565b61100b565b610d88565b90565b616823906167fe565b9052565b91602061684892949361684160408201965f83019061681a565b01906107d4565b565b61685e6168596168639261072d565b61100b565b612253565b90565b61686e612386565b508061688861688260018060d01b03613460565b9161072d565b11616899576168969061684a565b90565b60d06168b55f9283926306dfcc6560e41b845260048401616827565b0390fd5b906168ef6168f593926168ca612386565b506168d3612386565b5080936168e86168e1613bff565b94926153b7565b9091616f65565b91616bbc565b91909190565b61690f61690a616914926159a0565b61100b565b61072d565b90565b369037565b906169416169298361367a565b926020806169378693613657565b9201910390616917565b565b61694b61245f565b5061695581616c26565b9061696861696360206168fb565b61691c565b918252602082015290565b9190918061699161698b6169865f61293e565b610657565b91610657565b145f14616a72576169b56169ae836169a96002611071565b612e5a565b60026129a5565b5b826169d16169cb6169c65f61293e565b610657565b91610657565b145f14616a46576169f56169ee836169e96002611071565b61490e565b60026129a5565b5b919091616a41616a2f616a297fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef93611036565b93611036565b93616a386104e2565b918291826107e1565b0390a3565b616a6d82616a67616a585f8790613893565b91616a6283611071565b615b3b565b906129a5565b6169f6565b616a85616a805f8390613893565b611071565b80616a98616a928561072d565b9161072d565b10616ac057616aab616abb91849061490e565b616ab65f8490613893565b6129a5565b6169b6565b90616ade9091925f93849363391434e360e21b8552600485016148dc565b0390fd5b616aea6125d5565b50616afa60018060d01b03613460565b90565b91616b55616b4f616b5c9480616b23616b1d616b185f61293e565b610657565b91610657565b14616b8d575b84616b44616b3e616b395f61293e565b610657565b91610657565b14616b5e575b613748565b92613748565b9091615fc8565b565b616b86600b6002616b80616b7a616b7489616866565b9361345d565b91615fc5565b906168b9565b5050616b4a565b616bb5600b6001616baf616ba9616ba389616866565b9361345d565b91615fc5565b906168b9565b5050616b29565b91616be05f616be594616bcd612386565b50616bd6612386565b5001929192614d8d565b616e17565b91909190565b616bff616bfa616c0492616265565b61100b565b61072d565b90565b90565b616c1e616c19616c2392616c07565b61100b565b61072d565b90565b616c3b616c4091616c356125d5565b50612db0565b6163f4565b616c4a60ff616beb565b1680616c5f616c59601f616c0a565b9161072d565b11616c675790565b5f632cd44ac360e21b815280616c7f600482016108ac565b0390fd5b5490565b616c916040613642565b90565b5f5260205f2090565b616ca681616c83565b821015616cc057616cb8600191616c94565b910201905f90565b610e03565b616ccf90516118be565b90565b90616ce365ffffffffffff91611b48565b9181191691161790565b616d01616cfc616d06926118be565b61100b565b6118be565b90565b90565b90616d21616d1c616d2892616ced565b616d09565b8254616cd2565b9055565b616d369051612253565b90565b60301b90565b90616d5165ffffffffffff1991616d39565b9181191691161790565b616d6f616d6a616d7492612253565b61100b565b612253565b90565b90565b90616d8f616d8a616d9692616d5b565b616d77565b8254616d3f565b9055565b90616dc460205f616dca94616dbc828201616db6848801616cc5565b90616d0c565b019201616d2c565b90616d7a565b565b9190616ddd57616ddb91616d9a565b565b610a8a565b9081549168010000000000000000831015616e125782616e0a916001616e1095018155616c9d565b90616dcc565b565b610b86565b90929192616e23612386565b50616e2c612386565b50616e3682616c83565b80616e49616e435f612906565b9161072d565b115f14616f1957616e6f90616e698491616e6360016142f9565b90612b26565b90615eb4565b90616e7b5f8301614daf565b92616e875f8401614de1565b9380616e9b616e95856118be565b916118be565b11616efd57616eb2616eac846118be565b916118be565b145f14616ecd575050616ec8905f859101616d7a565b5b9190565b616ef89250616ef386616eea616ee1616c87565b945f8601616692565b602084016166a0565b616de2565b616ec9565b5f632520601d60e01b815280616f15600482016108ac565b0390fd5b50616f4491616f3f85616f36616f2d616c87565b945f8601616692565b602084016166a0565b616de2565b616f4d5f614dee565b9190565b634e487b7160e01b5f52605160045260245ffd5b91909180600114616f8457600203616f5157616f8091612405565b905b565b50616f8e916123c6565b90616f8256
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x13W[a#\x82V[a\0\x1D_5a\x04\xDCV[\x80c\x01\xFF\xC9\xA7\x14a\x04\xD7W\x80c\x06\xFD\xDE\x03\x14a\x04\xD2W\x80c\x07\xA1\xD5\xFA\x14a\x04\xCDW\x80c\t^\xA7\xB3\x14a\x04\xC8W\x80c\x0C\x05\xF8,\x14a\x04\xC3W\x80c\x13\xBE\xAA[\x14a\x04\xBEW\x80c\x18\x16\r\xDD\x14a\x04\xB9W\x80c\x1B\x02\xF8E\x14a\x04\xB4W\x80c\"\xA9}\x9C\x14a\x04\xAFW\x80c#\xB8r\xDD\x14a\x04\xAAW\x80c#\xE4`\xD2\x14a\x04\xA5W\x80c$\x81\xBB\\\x14a\x04\xA0W\x80c$\x8A\x9C\xA3\x14a\x04\x9BW\x80c(N\x133\x14a\x04\x96W\x80c//\xF1]\x14a\x04\x91W\x80c1<\xE5g\x14a\x04\x8CW\x80c3M\x0B\xBD\x14a\x04\x87W\x80c5\x9Bv\xFE\x14a\x04\x82W\x80c6D\xE5\x15\x14a\x04}W\x80c6V\x8A\xBE\x14a\x04xW\x80c:F\xB1\xA8\x14a\x04sW\x80c?K\xA8:\x14a\x04nW\x80c@\xC1\x0F\x19\x14a\x04iW\x80cD\xE1\x81\xAA\x14a\x04dW\x80cH\xB0\xDA\xA6\x14a\x04_W\x80cK\xDD6\xCE\x14a\x04ZW\x80cK\xF5\xD7\xE9\x14a\x04UW\x80cX|\xDE\x1E\x14a\x04PW\x80cZ\xDF\0!\x14a\x04KW\x80c\\\x19\xA9\\\x14a\x04FW\x80c\\\x97Z\xBB\x14a\x04AW\x80c_\x15\xC3\xC9\x14a\x04<W\x80ce\x1F\xD2h\x14a\x047W\x80cl3\xBC\xED\x14a\x042W\x80cl\xF0\x16%\x14a\x04-W\x80co\xC0c\xBE\x14a\x04(W\x80co\xCF\xFFE\x14a\x04#W\x80cp\xA0\x821\x14a\x04\x1EW\x80crf\0\xCE\x14a\x04\x19W\x80cvg\x18\x08\x14a\x04\x14W\x80c|y\x0C\xAB\x14a\x04\x0FW\x80c~\xCE\xBE\0\x14a\x04\nW\x80c\x84V\xCBY\x14a\x04\x05W\x80c\x84\xB0\x19n\x14a\x04\0W\x80c\x8ES\x9E\x8C\x14a\x03\xFBW\x80c\x90-U\xA5\x14a\x03\xF6W\x80c\x91\xD1HT\x14a\x03\xF1W\x80c\x91\xDD\xAD\xF4\x14a\x03\xECW\x80c\x95\xD8\x9BA\x14a\x03\xE7W\x80c\x99\x12}\x9B\x14a\x03\xE2W\x80c\x99\x89U\xD3\x14a\x03\xDDW\x80c\x9A\xB2N\xB0\x14a\x03\xD8W\x80c\x9B~\xF6K\x14a\x03\xD3W\x80c\x9D\xC2\x9F\xAC\x14a\x03\xCEW\x80c\xA0\x8DVT\x14a\x03\xC9W\x80c\xA2\x17\xFD\xDF\x14a\x03\xC4W\x80c\xA3\xD4H[\x14a\x03\xBFW\x80c\xA4\xD7\xE3\x1D\x14a\x03\xBAW\x80c\xA5q\xE1\x84\x14a\x03\xB5W\x80c\xA7\x0B\x9F\x0C\x14a\x03\xB0W\x80c\xA9\x05\x9C\xBB\x14a\x03\xABW\x80c\xAF*\xA6;\x14a\x03\xA6W\x80c\xB0\xCA%>\x14a\x03\xA1W\x80c\xBA\xBC9O\x14a\x03\x9CW\x80c\xBBMD6\x14a\x03\x97W\x80c\xC0*\xE7T\x14a\x03\x92W\x80c\xC1\xEBq7\x14a\x03\x8DW\x80c\xC3\xCD\xA5 \x14a\x03\x88W\x80c\xD5\x05\xAC\xCF\x14a\x03\x83W\x80c\xD5Gt\x1F\x14a\x03~W\x80c\xDDb\xED>\x14a\x03yW\x80c\xE3\xAB\xDF\xCB\x14a\x03tW\x80c\xE6:\xB1\xE9\x14a\x03oW\x80c\xF1\x12~\xD8\x14a\x03jW\x80c\xF5\x08\xE1\x9D\x14a\x03eWc\xF7^\x85\x12\x03a\0\x0EWa#MV[a\"\xE9V[a\"\xA4V[a!\xC1V[a!]V[a \xF8V[a \x97V[a ]V[a\x1F\xB3V[a\x1E\xF7V[a\x1E\xC2V[a\x1E\x8DV[a\x1ETV[a\x1D\xE0V[a\x1D\xABV[a\x1D\0V[a\x1C\xCBV[a\x1C_V[a\x1C*V[a\x1B\xF5V[a\x1B\x80V[a\x1B\x11V[a\x1A\xA3V[a\x1AnV[a\x19\xF8V[a\x19\xC3V[a\x19\x8EV[a\x19 V[a\x18\xEBV[a\x18\x88V[a\x18SV[a\x17\xDDV[a\x17\xA1V[a\x16\\V[a\x16'V[a\x15\xEEV[a\x15lV[a\x15(V[a\x14\xF3V[a\x14\xBEV[a\x14^V[a\x13\xFAV[a\x13\x86V[a\x13QV[a\x13\x1CV[a\x12\xB0V[a\x12}V[a\x12HV[a\x12\x13V[a\x11\xC9V[a\x11\x94V[a\x11_V[a\x11\x17V[a\x0F\xD7V[a\x0F\xA4V[a\x0FnV[a\x0F:V[a\x0F\x05V[a\x0E\xD2V[a\x0E\x9DV[a\r\xB0V[a\rTV[a\x0C\xF4V[a\x0C\xBFV[a\x0C$V[a\nTV[a\t\xFBV[a\t\x8CV[a\t\x1AV[a\x08\xE5V[a\x08\xB1V[a\x07\xF6V[a\x07\x80V[a\x06\xD4V[a\x06\x17V[a\x05hV[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x80\xFD[c\xFF\xFF\xFF\xFF`\xE0\x1B\x16\x90V[a\x05\t\x81a\x04\xF4V[\x03a\x05\x10WV[_\x80\xFD[\x90P5\x90a\x05!\x82a\x05\0V[V[\x90` \x82\x82\x03\x12a\x05<Wa\x059\x91_\x01a\x05\x14V[\x90V[a\x04\xECV[\x15\x15\x90V[a\x05O\x90a\x05AV[\x90RV[\x91\x90a\x05f\x90_` \x85\x01\x94\x01\x90a\x05FV[V[4a\x05\x98Wa\x05\x94a\x05\x83a\x05~6`\x04a\x05#V[a$\x1FV[a\x05\x8Ba\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[_\x91\x03\x12a\x05\xA7WV[a\x04\xECV[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[`\x1F\x80\x19\x91\x01\x16\x90V[a\x05\xEDa\x05\xF6` \x93a\x05\xFB\x93a\x05\xE4\x81a\x05\xACV[\x93\x84\x80\x93a\x05\xB0V[\x95\x86\x91\x01a\x05\xB9V[a\x05\xC4V[\x01\x90V[a\x06\x14\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x05\xCEV[\x90V[4a\x06GWa\x06'6`\x04a\x05\x9DV[a\x06Ca\x062a%=V[a\x06:a\x04\xE2V[\x91\x82\x91\x82a\x05\xFFV[\x03\x90\xF3[a\x04\xE8V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x06`\x90a\x06LV[\x90V[a\x06l\x90a\x06WV[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[a\x06\x9Ca\x06\xA5` \x93a\x06\xAA\x93a\x06\x93\x81a\x06pV[\x93\x84\x80\x93a\x06tV[\x95\x86\x91\x01a\x05\xB9V[a\x05\xC4V[\x01\x90V[\x91a\x06\xD1\x92a\x06\xC4`@\x82\x01\x93_\x83\x01\x90a\x06cV[` \x81\x84\x03\x91\x01Ra\x06}V[\x90V[4a\x07\x05Wa\x06\xE46`\x04a\x05\x9DV[a\x06\xECa%\x89V[\x90a\x07\x01a\x06\xF8a\x04\xE2V[\x92\x83\x92\x83a\x06\xAEV[\x03\x90\xF3[a\x04\xE8V[a\x07\x13\x81a\x06WV[\x03a\x07\x1AWV[_\x80\xFD[\x90P5\x90a\x07+\x82a\x07\nV[V[\x90V[a\x079\x81a\x07-V[\x03a\x07@WV[_\x80\xFD[\x90P5\x90a\x07Q\x82a\x070V[V[\x91\x90`@\x83\x82\x03\x12a\x07{W\x80a\x07oa\x07x\x92_\x86\x01a\x07\x1EV[\x93` \x01a\x07DV[\x90V[a\x04\xECV[4a\x07\xB1Wa\x07\xADa\x07\x9Ca\x07\x966`\x04a\x07SV[\x90a%\xB3V[a\x07\xA4a\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[\x90` \x82\x82\x03\x12a\x07\xCFWa\x07\xCC\x91_\x01a\x07\x1EV[\x90V[a\x04\xECV[a\x07\xDD\x90a\x07-V[\x90RV[\x91\x90a\x07\xF4\x90_` \x85\x01\x94\x01\x90a\x07\xD4V[V[4a\x08&Wa\x08\"a\x08\x11a\x08\x0C6`\x04a\x07\xB6V[a%\xD9V[a\x08\x19a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x08qW\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x08lW` \x01\x92`\x01\x83\x02\x84\x01\x11a\x08gWV[a\x083V[a\x08/V[a\x08+V[\x90` \x82\x82\x03\x12a\x08\xA7W_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x08\xA2Wa\x08\x9E\x92\x01a\x087V[\x90\x91V[a\x04\xF0V[a\x04\xECV[_\x01\x90V[4a\x08\xE0Wa\x08\xCAa\x08\xC46`\x04a\x08vV[\x90a(\xCAV[a\x08\xD2a\x04\xE2V[\x80a\x08\xDC\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[4a\t\x15Wa\x08\xF56`\x04a\x05\x9DV[a\t\x11a\t\0a(\xD6V[a\t\x08a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\tHWa\t*6`\x04a\x05\x9DV[a\t2a*\x9AV[a\t:a\x04\xE2V[\x80a\tD\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x1C\x90V[`\xFF\x16\x90V[a\tg\x90`\x08a\tl\x93\x02a\tMV[a\tQV[\x90V[\x90a\tz\x91Ta\tWV[\x90V[a\t\x89`?_\x90a\toV[\x90V[4a\t\xBCWa\t\x9C6`\x04a\x05\x9DV[a\t\xB8a\t\xA7a\t}V[a\t\xAFa\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[\x90\x91``\x82\x84\x03\x12a\t\xF6Wa\t\xF3a\t\xDC\x84_\x85\x01a\x07\x1EV[\x93a\t\xEA\x81` \x86\x01a\x07\x1EV[\x93`@\x01a\x07DV[\x90V[a\x04\xECV[4a\n,Wa\n(a\n\x17a\n\x116`\x04a\t\xC1V[\x91a*\xA4V[a\n\x1Fa\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[\x91` a\nR\x92\x94\x93a\nK`@\x82\x01\x96_\x83\x01\x90a\x07\xD4V[\x01\x90a\x07\xD4V[V[4a\n\x85Wa\nla\ng6`\x04a\x07\xB6V[a+\xD5V[\x90a\n\x81a\nxa\x04\xE2V[\x92\x83\x92\x83a\n1V[\x03\x90\xF3[a\x04\xE8V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\n\xD1W[` \x83\x10\x14a\n\xCCWV[a\n\x9DV[\x91`\x7F\x16\x91a\n\xC1V[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x0B\x07a\x0B\0\x83a\n\xB1V[\x80\x94a\n\xDBV[\x91`\x01\x81\x16\x90\x81_\x14a\x0B^WP`\x01\x14a\x0B\"W[PPPV[a\x0B/\x91\x92\x93\x94Pa\n\xE4V[\x91_\x92[\x81\x84\x10a\x0BFWPP\x01\x90_\x80\x80a\x0B\x1DV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x0B3V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x0B\x1DV[\x90a\x0B\x83\x91a\n\xEDV[\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x0B\xA4\x90a\x05\xC4V[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x0B\xBEW`@RV[a\x0B\x86V[\x90a\x0B\xE3a\x0B\xDC\x92a\x0B\xD3a\x04\xE2V[\x93\x84\x80\x92a\x0ByV[\x03\x83a\x0B\x9AV[V[\x90_\x10a\x0B\xF8Wa\x0B\xF5\x90a\x0B\xC3V[\x90V[a\n\x8AV[a\x0C\t`D_\x90a\x0B\xE5V[\x90V[a\x0C!\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x06}V[\x90V[4a\x0CTWa\x0C46`\x04a\x05\x9DV[a\x0CPa\x0C?a\x0B\xFDV[a\x0CGa\x04\xE2V[\x91\x82\x91\x82a\x0C\x0CV[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x0Ce\x81a\x0CYV[\x03a\x0ClWV[_\x80\xFD[\x90P5\x90a\x0C}\x82a\x0C\\V[V[\x90` \x82\x82\x03\x12a\x0C\x98Wa\x0C\x95\x91_\x01a\x0CpV[\x90V[a\x04\xECV[a\x0C\xA6\x90a\x0CYV[\x90RV[\x91\x90a\x0C\xBD\x90_` \x85\x01\x94\x01\x90a\x0C\x9DV[V[4a\x0C\xEFWa\x0C\xEBa\x0C\xDAa\x0C\xD56`\x04a\x0C\x7FV[a-\xF6V[a\x0C\xE2a\x04\xE2V[\x91\x82\x91\x82a\x0C\xAAV[\x03\x90\xF3[a\x04\xE8V[4a\r\"Wa\r\x046`\x04a\x05\x9DV[a\r\x0Ca2\xCDV[a\r\x14a\x04\xE2V[\x80a\r\x1E\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x91\x90`@\x83\x82\x03\x12a\rOW\x80a\rCa\rL\x92_\x86\x01a\x0CpV[\x93` \x01a\x07\x1EV[\x90V[a\x04\xECV[4a\r\x83Wa\rma\rg6`\x04a\r'V[\x90a3\x01V[a\rua\x04\xE2V[\x80a\r\x7F\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[`\xFF\x16\x90V[a\r\x97\x90a\r\x88V[\x90RV[\x91\x90a\r\xAE\x90_` \x85\x01\x94\x01\x90a\r\x8EV[V[4a\r\xE0Wa\r\xC06`\x04a\x05\x9DV[a\r\xDCa\r\xCBa30V[a\r\xD3a\x04\xE2V[\x91\x82\x91\x82a\r\x9BV[\x03\x90\xF3[a\x04\xE8V[\x90` \x82\x82\x03\x12a\r\xFEWa\r\xFB\x91_\x01a\x07DV[\x90V[a\x04\xECV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[P`0\x90V[\x90V[a\x0E)\x81a\x0E\x17V[\x82\x10\x15a\x0ECWa\x0E;`\x01\x91a\x0E\x1DV[\x91\x02\x01\x90_\x90V[a\x0E\x03V[\x90V[a\x0E[\x90`\x08a\x0E`\x93\x02a\tMV[a\x0EHV[\x90V[\x90a\x0En\x91Ta\x0EKV[\x90V[`\x0Fa\x0E|\x81a\x0E\x17V[\x82\x10\x15a\x0E\x99Wa\x0E\x96\x91a\x0E\x90\x91a\x0E V[\x90a\x0EcV[\x90V[_\x80\xFD[4a\x0E\xCDWa\x0E\xC9a\x0E\xB8a\x0E\xB36`\x04a\r\xE5V[a\x0EqV[a\x0E\xC0a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x0F\0Wa\x0E\xE26`\x04a\x05\x9DV[a\x0E\xEAa3\xE1V[a\x0E\xF2a\x04\xE2V[\x80a\x0E\xFC\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[4a\x0F5Wa\x0F\x156`\x04a\x05\x9DV[a\x0F1a\x0F a3\xEBV[a\x0F(a\x04\xE2V[\x91\x82\x91\x82a\x0C\xAAV[\x03\x90\xF3[a\x04\xE8V[4a\x0FiWa\x0FSa\x0FM6`\x04a\r'V[\x90a3\xFFV[a\x0F[a\x04\xE2V[\x80a\x0Fe\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[4a\x0F\x9FWa\x0F\x9Ba\x0F\x8Aa\x0F\x846`\x04a\x07SV[\x90a4|V[a\x0F\x92a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x0F\xD2Wa\x0F\xB46`\x04a\x05\x9DV[a\x0F\xBCa4\xDAV[a\x0F\xC4a\x04\xE2V[\x80a\x0F\xCE\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[4a\x10\x06Wa\x0F\xF0a\x0F\xEA6`\x04a\x07SV[\x90a4\xE4V[a\x0F\xF8a\x04\xE2V[\x80a\x10\x02\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x10\"a\x10\x1Da\x10'\x92a\x06LV[a\x10\x0BV[a\x06LV[\x90V[a\x103\x90a\x10\x0EV[\x90V[a\x10?\x90a\x10*V[\x90V[\x90a\x10L\x90a\x106V[_R` R`@_ \x90V[_\x1C\x90V[a\x10ia\x10n\x91a\x10XV[a\x0EHV[\x90V[a\x10{\x90Ta\x10]V[\x90V[a\x10\x89\x90`\x0Ca\x10BV[a\x10\x94_\x82\x01a\x10qV[\x91a\x10\xA1`\x01\x83\x01a\x10qV[\x91a\x10\xAE`\x02\x82\x01a\x10qV[\x91a\x10\xC7`\x04a\x10\xC0`\x03\x85\x01a\x10qV[\x93\x01a\x10qV[\x90V[\x90\x95\x94\x92a\x11\x15\x94a\x11\x04a\x11\x0E\x92a\x10\xFA`\x80\x96a\x10\xF0`\xA0\x88\x01\x9C_\x89\x01\x90a\x07\xD4V[` \x87\x01\x90a\x07\xD4V[`@\x85\x01\x90a\x07\xD4V[``\x83\x01\x90a\x07\xD4V[\x01\x90a\x07\xD4V[V[4a\x11KWa\x11Ga\x112a\x11-6`\x04a\x07\xB6V[a\x10~V[\x91a\x11>\x95\x93\x95a\x04\xE2V[\x95\x86\x95\x86a\x10\xCAV[\x03\x90\xF3[a\x04\xE8V[a\x11\\`@_\x90a\x0EcV[\x90V[4a\x11\x8FWa\x11o6`\x04a\x05\x9DV[a\x11\x8Ba\x11za\x11PV[a\x11\x82a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x11\xC4Wa\x11\xA46`\x04a\x05\x9DV[a\x11\xC0a\x11\xAFa6\x1BV[a\x11\xB7a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x11\xF9Wa\x11\xD96`\x04a\x05\x9DV[a\x11\xF5a\x11\xE4a6\xDCV[a\x11\xECa\x04\xE2V[\x91\x82\x91\x82a\x05\xFFV[\x03\x90\xF3[a\x04\xE8V[\x91\x90a\x12\x11\x90_` \x85\x01\x94\x01\x90a\x06cV[V[4a\x12CWa\x12?a\x12.a\x12)6`\x04a\x07\xB6V[a7HV[a\x126a\x04\xE2V[\x91\x82\x91\x82a\x11\xFEV[\x03\x90\xF3[a\x04\xE8V[4a\x12xWa\x12X6`\x04a\x05\x9DV[a\x12ta\x12ca7gV[a\x12ka\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[4a\x12\xABWa\x12\x95a\x12\x906`\x04a\x07\xB6V[a7\x90V[a\x12\x9Da\x04\xE2V[\x80a\x12\xA7\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[4a\x12\xE0Wa\x12\xC06`\x04a\x05\x9DV[a\x12\xDCa\x12\xCBa7\xA3V[a\x12\xD3a\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x12\xFCa\x12\xF7a\x13\x01\x92a\x12\xE5V[a\x10\x0BV[a\x07-V[\x90V[a\x13\x0E`0a\x12\xE8V[\x90V[a\x13\x19a\x13\x04V[\x90V[4a\x13LWa\x13,6`\x04a\x05\x9DV[a\x13Ha\x137a\x13\x11V[a\x13?a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x13\x81Wa\x13}a\x13la\x13g6`\x04a\x07\xB6V[a7\xB9V[a\x13ta\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x13\xB4Wa\x13\x966`\x04a\x05\x9DV[a\x13\x9Ea8pV[a\x13\xA6a\x04\xE2V[\x80a\x13\xB0\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x13\xD0a\x13\xCBa\x13\xD5\x92a\x13\xB9V[a\x10\x0BV[a\x07-V[\x90V[a\x13\xECj\x08E\x95\x16\x14\x01HJ\0\0\0a\x13\xBCV[\x90V[a\x13\xF7a\x13\xD8V[\x90V[4a\x14*Wa\x14\n6`\x04a\x05\x9DV[a\x14&a\x14\x15a\x13\xEFV[a\x14\x1Da\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[\x90a\x149\x90a\x106V[_R` R`@_ \x90V[a\x14[\x90a\x14V`\r\x91_\x92a\x14/V[a\toV[\x90V[4a\x14\x8EWa\x14\x8Aa\x14ya\x14t6`\x04a\x07\xB6V[a\x14EV[a\x14\x81a\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[c\xFF\xFF\xFF\xFF\x16\x90V[a\x14\xA5\x90a\x14\x93V[\x90RV[\x91\x90a\x14\xBC\x90_` \x85\x01\x94\x01\x90a\x14\x9CV[V[4a\x14\xEEWa\x14\xEAa\x14\xD9a\x14\xD46`\x04a\x07\xB6V[a8~V[a\x14\xE1a\x04\xE2V[\x91\x82\x91\x82a\x14\xA9V[\x03\x90\xF3[a\x04\xE8V[4a\x15#Wa\x15\x1Fa\x15\x0Ea\x15\t6`\x04a\x07\xB6V[a8\xA9V[a\x15\x16a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x15XWa\x15Ta\x15Ca\x15>6`\x04a\x07\xB6V[a8\xC7V[a\x15Ka\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[a\x15i`A_\x90a\x0EcV[\x90V[4a\x15\x9CWa\x15|6`\x04a\x05\x9DV[a\x15\x98a\x15\x87a\x15]V[a\x15\x8Fa\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[\x90\x95\x94\x92a\x15\xEC\x94a\x15\xDBa\x15\xE5\x92a\x15\xD1`\x80\x96a\x15\xC7`\xA0\x88\x01\x9C_\x89\x01\x90a\x05FV[` \x87\x01\x90a\x07\xD4V[`@\x85\x01\x90a\x07\xD4V[``\x83\x01\x90a\x07\xD4V[\x01\x90a\x07\xD4V[V[4a\x16\"Wa\x16\x1Ea\x16\ta\x16\x046`\x04a\x07\xB6V[a8\xE6V[\x91a\x16\x15\x95\x93\x95a\x04\xE2V[\x95\x86\x95\x86a\x15\xA1V[\x03\x90\xF3[a\x04\xE8V[4a\x16WWa\x16Sa\x16Ba\x16=6`\x04a\x07\xB6V[a:VV[a\x16Ja\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x16\x8AWa\x16l6`\x04a\x05\x9DV[a\x16ta:\x8FV[a\x16|a\x04\xE2V[\x80a\x16\x86\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[`\xFF`\xF8\x1B\x16\x90V[a\x16\xA1\x90a\x16\x8FV[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[` \x01\x90V[a\x16\xC1\x90a\x07-V[\x90RV[\x90a\x16\xD2\x81` \x93a\x16\xB8V[\x01\x90V[` \x01\x90V[\x90a\x16\xF9a\x16\xF3a\x16\xEC\x84a\x16\xA5V[\x80\x93a\x16\xA9V[\x92a\x16\xB2V[\x90_[\x81\x81\x10a\x17\tWPPP\x90V[\x90\x91\x92a\x17\"a\x17\x1C`\x01\x92\x86Qa\x16\xC5V[\x94a\x16\xD6V[\x91\x01\x91\x90\x91a\x16\xFCV[\x93\x95\x91\x94a\x17}a\x17ra\x17\x91\x95a\x17da\x17\x87\x95a\x17\x9E\x9C\x9Aa\x17W`\xE0\x8C\x01\x92_\x8D\x01\x90a\x16\x98V[\x8A\x82\x03` \x8C\x01Ra\x05\xCEV[\x90\x88\x82\x03`@\x8A\x01Ra\x05\xCEV[\x97``\x87\x01\x90a\x07\xD4V[`\x80\x85\x01\x90a\x06cV[`\xA0\x83\x01\x90a\x0C\x9DV[`\xC0\x81\x84\x03\x91\x01Ra\x16\xDCV[\x90V[4a\x17\xD8Wa\x17\xB16`\x04a\x05\x9DV[a\x17\xD4a\x17\xBCa;\x16V[\x93a\x17\xCB\x97\x95\x97\x93\x91\x93a\x04\xE2V[\x97\x88\x97\x88a\x17,V[\x03\x90\xF3[a\x04\xE8V[4a\x18\rWa\x18\ta\x17\xF8a\x17\xF36`\x04a\r\xE5V[a;\xA0V[a\x18\0a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x18)a\x18$a\x18.\x92a\x18\x12V[a\x10\x0BV[a\x07-V[\x90V[a\x18EjR\xB7\xD2\xDC\xC8\x0C\xD2\xE4\0\0\0a\x18\x15V[\x90V[a\x18Pa\x181V[\x90V[4a\x18\x83Wa\x18c6`\x04a\x05\x9DV[a\x18\x7Fa\x18na\x18HV[a\x18va\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x18\xB9Wa\x18\xB5a\x18\xA4a\x18\x9E6`\x04a\r'V[\x90a;\xD1V[a\x18\xACa\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x18\xD2\x90a\x18\xBEV[\x90RV[\x91\x90a\x18\xE9\x90_` \x85\x01\x94\x01\x90a\x18\xC9V[V[4a\x19\x1BWa\x18\xFB6`\x04a\x05\x9DV[a\x19\x17a\x19\x06a;\xFFV[a\x19\x0Ea\x04\xE2V[\x91\x82\x91\x82a\x18\xD6V[\x03\x90\xF3[a\x04\xE8V[4a\x19PWa\x1906`\x04a\x05\x9DV[a\x19La\x19;a<\x13V[a\x19Ca\x04\xE2V[\x91\x82\x91\x82a\x05\xFFV[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x19la\x19ga\x19q\x92a\x19UV[a\x10\x0BV[a\x07-V[\x90V[a\x19\x80b\x01Q\x80a\x19XV[\x90V[a\x19\x8Ba\x19tV[\x90V[4a\x19\xBEWa\x19\x9E6`\x04a\x05\x9DV[a\x19\xBAa\x19\xA9a\x19\x83V[a\x19\xB1a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x19\xF3Wa\x19\xEFa\x19\xDEa\x19\xD96`\x04a\x07\xB6V[a<)V[a\x19\xE6a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x1A(Wa\x1A$a\x1A\x13a\x1A\x0E6`\x04a\x07\xB6V[a<\x84V[a\x1A\x1Ba\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x1ADa\x1A?a\x1AI\x92a\x1A-V[a\x10\x0BV[a\x07-V[\x90V[a\x1A`jJr=\xC6\xB4\x0B\x8A\x9A\0\0\0a\x1A0V[\x90V[a\x1Aka\x1ALV[\x90V[4a\x1A\x9EWa\x1A~6`\x04a\x05\x9DV[a\x1A\x9Aa\x1A\x89a\x1AcV[a\x1A\x91a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x1A\xD2Wa\x1A\xBCa\x1A\xB66`\x04a\x07SV[\x90a<\xB3V[a\x1A\xC4a\x04\xE2V[\x80a\x1A\xCE\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x90\x91``\x82\x84\x03\x12a\x1B\x0CWa\x1B\ta\x1A\xF2\x84_\x85\x01a\x07\x1EV[\x93a\x1B\0\x81` \x86\x01a\x07DV[\x93`@\x01a\x07DV[\x90V[a\x04\xECV[4a\x1B@Wa\x1B*a\x1B$6`\x04a\x1A\xD7V[\x91a@dV[a\x1B2a\x04\xE2V[\x80a\x1B<\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x90V[_\x1B\x90V[a\x1Baa\x1B\\a\x1Bf\x92a\x1BEV[a\x1BHV[a\x0CYV[\x90V[a\x1Br_a\x1BMV[\x90V[a\x1B}a\x1BiV[\x90V[4a\x1B\xB0Wa\x1B\x906`\x04a\x05\x9DV[a\x1B\xACa\x1B\x9Ba\x1BuV[a\x1B\xA3a\x04\xE2V[\x91\x82\x91\x82a\x0C\xAAV[\x03\x90\xF3[a\x04\xE8V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x1B\xD0\x90`\x08a\x1B\xD5\x93\x02a\tMV[a\x1B\xB5V[\x90V[\x90a\x1B\xE3\x91Ta\x1B\xC0V[\x90V[a\x1B\xF2`C_\x90a\x1B\xD8V[\x90V[4a\x1C%Wa\x1C\x056`\x04a\x05\x9DV[a\x1C!a\x1C\x10a\x1B\xE6V[a\x1C\x18a\x04\xE2V[\x91\x82\x91\x82a\x11\xFEV[\x03\x90\xF3[a\x04\xE8V[4a\x1CZWa\x1C:6`\x04a\x05\x9DV[a\x1CVa\x1CEa@qV[a\x1CMa\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[4a\x1C\x8DWa\x1Cwa\x1Cr6`\x04a\x07\xB6V[aA\x98V[a\x1C\x7Fa\x04\xE2V[\x80a\x1C\x89\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x90V[a\x1C\xA9a\x1C\xA4a\x1C\xAE\x92a\x1C\x92V[a\x10\x0BV[a\x07-V[\x90V[a\x1C\xBDb'\x8D\0a\x1C\x95V[\x90V[a\x1C\xC8a\x1C\xB1V[\x90V[4a\x1C\xFBWa\x1C\xDB6`\x04a\x05\x9DV[a\x1C\xF7a\x1C\xE6a\x1C\xC0V[a\x1C\xEEa\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x1D1Wa\x1D-a\x1D\x1Ca\x1D\x166`\x04a\x07SV[\x90aA\xA3V[a\x1D$a\x04\xE2V[\x91\x82\x91\x82a\x05SV[\x03\x90\xF3[a\x04\xE8V[P`0\x90V[\x90P\x90V[\x90V[` \x01\x90V[a\x1Dfa\x1D`a\x1DY\x83a\x1D6V[\x80\x94a\x1D<V[\x91a\x1DAV[_\x91[\x83\x83\x10a\x1DvWPPPPV[a\x1D\x8Ca\x1D\x86`\x01\x92\x84Qa\x16\xC5V[\x92a\x1DDV[\x92\x01\x91\x90a\x1DiV[\x91\x90a\x1D\xA9\x90_a\x06\0\x85\x01\x94\x01\x90a\x1DJV[V[4a\x1D\xDBWa\x1D\xBB6`\x04a\x05\x9DV[a\x1D\xD7a\x1D\xC6aB\xCAV[a\x1D\xCEa\x04\xE2V[\x91\x82\x91\x82a\x1D\x95V[\x03\x90\xF3[a\x04\xE8V[4a\x1E\x11Wa\x1E\ra\x1D\xFCa\x1D\xF66`\x04a\x07SV[\x90aB\xE0V[a\x1E\x04a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[a\x1EKa\x1ER\x94a\x1EA``\x94\x98\x97\x95a\x1E7`\x80\x86\x01\x9A_\x87\x01\x90a\x07\xD4V[` \x85\x01\x90a\x07\xD4V[`@\x83\x01\x90a\x07\xD4V[\x01\x90a\x05FV[V[4a\x1E\x88Wa\x1Ed6`\x04a\x05\x9DV[a\x1E\x84a\x1EoaC\x15V[\x90a\x1E{\x94\x92\x94a\x04\xE2V[\x94\x85\x94\x85a\x1E\x16V[\x03\x90\xF3[a\x04\xE8V[4a\x1E\xBDWa\x1E\xB9a\x1E\xA8a\x1E\xA36`\x04a\x07\xB6V[aD\xBAV[a\x1E\xB0a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x1E\xF2Wa\x1E\xD26`\x04a\x05\x9DV[a\x1E\xEEa\x1E\xDDaD\xCFV[a\x1E\xE5a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[4a\x1F'Wa\x1F#a\x1F\x12a\x1F\r6`\x04a\x07\xB6V[aD\xE3V[a\x1F\x1Aa\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[a\x1F5\x81a\r\x88V[\x03a\x1F<WV[_\x80\xFD[\x90P5\x90a\x1FM\x82a\x1F,V[V[\x90\x91`\xC0\x82\x84\x03\x12a\x1F\xAEWa\x1Fg\x83_\x84\x01a\x07\x1EV[\x92a\x1Fu\x81` \x85\x01a\x07DV[\x92a\x1F\x83\x82`@\x83\x01a\x07DV[\x92a\x1F\xABa\x1F\x94\x84``\x85\x01a\x1F@V[\x93a\x1F\xA2\x81`\x80\x86\x01a\x0CpV[\x93`\xA0\x01a\x0CpV[\x90V[a\x04\xECV[4a\x1F\xE8Wa\x1F\xD2a\x1F\xC66`\x04a\x1FOV[\x94\x93\x90\x93\x92\x91\x92aEmV[a\x1F\xDAa\x04\xE2V[\x80a\x1F\xE4\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[`\xE0\x81\x83\x03\x12a XWa \x03\x82_\x83\x01a\x07\x1EV[\x92a \x11\x83` \x84\x01a\x07\x1EV[\x92a \x1F\x81`@\x85\x01a\x07DV[\x92a -\x82``\x83\x01a\x07DV[\x92a Ua >\x84`\x80\x85\x01a\x1F@V[\x93a L\x81`\xA0\x86\x01a\x0CpV[\x93`\xC0\x01a\x0CpV[\x90V[a\x04\xECV[4a \x92Wa |a p6`\x04a\x1F\xEDV[\x95\x94\x90\x94\x93\x91\x93aF\xC1V[a \x84a\x04\xE2V[\x80a \x8E\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[4a \xC6Wa \xB0a \xAA6`\x04a\r'V[\x90aG\xDFV[a \xB8a\x04\xE2V[\x80a \xC2\x81a\x08\xACV[\x03\x90\xF3[a\x04\xE8V[\x91\x90`@\x83\x82\x03\x12a \xF3W\x80a \xE7a \xF0\x92_\x86\x01a\x07\x1EV[\x93` \x01a\x07\x1EV[\x90V[a\x04\xECV[4a!)Wa!%a!\x14a!\x0E6`\x04a \xCBV[\x90aH\x01V[a!\x1Ca\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[\x7Fk\x97%\xF7@\xF9K\x91\xB7\x80`\xA1\xB1}\x17tem8\x14!\xA5)\xEC\x98\xCD\xB0\x13\xF4\xD9\xC2^\x90V[a!Za!.V[\x90V[4a!\x8DWa!m6`\x04a\x05\x9DV[a!\x89a!xa!RV[a!\x80a\x04\xE2V[\x91\x82\x91\x82a\x0C\xAAV[\x03\x90\xF3[a\x04\xE8V[\x7Fe\xD7\xA2\x8E2e\xB3zdt\x92\x9F3e!\xB32\xC1h\x1B\x93?l\xB9\xF37fsD\r\x86*\x90V[a!\xBEa!\x92V[\x90V[4a!\xF1Wa!\xD16`\x04a\x05\x9DV[a!\xEDa!\xDCa!\xB6V[a!\xE4a\x04\xE2V[\x91\x82\x91\x82a\x0C\xAAV[\x03\x90\xF3[a\x04\xE8V[a!\xFF\x81a\x14\x93V[\x03a\"\x06WV[_\x80\xFD[\x90P5\x90a\"\x17\x82a!\xF6V[V[\x91\x90`@\x83\x82\x03\x12a\"AW\x80a\"5a\">\x92_\x86\x01a\x07\x1EV[\x93` \x01a\"\nV[\x90V[a\x04\xECV[a\"O\x90a\x18\xBEV[\x90RV[`\x01\x80`\xD0\x1B\x03\x16\x90V[a\"g\x90a\"SV[\x90RV[\x90` \x80a\"\x8D\x93a\"\x83_\x82\x01Q_\x86\x01\x90a\"FV[\x01Q\x91\x01\x90a\"^V[V[\x91\x90a\"\xA2\x90_`@\x85\x01\x94\x01\x90a\"kV[V[4a\"\xD5Wa\"\xD1a\"\xC0a\"\xBA6`\x04a\"\x19V[\x90aHoV[a\"\xC8a\x04\xE2V[\x91\x82\x91\x82a\"\x8FV[\x03\x90\xF3[a\x04\xE8V[a\"\xE6`B_\x90a\x0EcV[\x90V[4a#\x19Wa\"\xF96`\x04a\x05\x9DV[a#\x15a#\x04a\"\xDAV[a#\x0Ca\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xF3[a\x04\xE8V[\x7F\xCC\xE2\x96\xB0@3*\x08\x0Em\xF15\x15\xA3\xEC(i\xE2\x1C\xD2\x0FsD\xAF\t\x87\xDD\xB98\xD8\xBD!\x90V[a#Ja#\x1EV[\x90V[4a#}Wa#]6`\x04a\x05\x9DV[a#ya#ha#BV[a#pa\x04\xE2V[\x91\x82\x91\x82a\x0C\xAAV[\x03\x90\xF3[a\x04\xE8V[_\x80\xFD[_\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a#\xAAa#\xB0\x91a\"SV[\x91a\"SV[\x01\x90`\x01\x80`\xD0\x1B\x03\x82\x11a#\xC1WV[a#\x8AV[\x90a#\xD9\x91a#\xD3a#\x86V[Pa#\x9EV[\x90V[a#\xE8a#\xEE\x91a\"SV[\x91a\"SV[\x90\x03\x90`\x01\x80`\xD0\x1B\x03\x82\x11a$\0WV[a#\x8AV[\x90a$\x18\x91a$\x12a#\x86V[Pa#\xDCV[\x90V[_\x90V[a$'a$\x1BV[P\x80a$Ba$<cye\xDB\x0B`\xE0\x1Ba\x04\xF4V[\x91a\x04\xF4V[\x14\x90\x81\x15a$OW[P\x90V[a$Y\x91PaH\x85V[_a$KV[``\x90V[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a$\x90a$\x89\x83a\n\xB1V[\x80\x94a$dV[\x91`\x01\x81\x16\x90\x81_\x14a$\xE7WP`\x01\x14a$\xABW[PPPV[a$\xB8\x91\x92\x93\x94Pa$mV[\x91_\x92[\x81\x84\x10a$\xCFWPP\x01\x90_\x80\x80a$\xA6V[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a$\xBCV[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a$\xA6V[\x90a%\x0C\x91a$vV[\x90V[\x90a%/a%(\x92a%\x1Fa\x04\xE2V[\x93\x84\x80\x92a%\x02V[\x03\x83a\x0B\x9AV[V[a%:\x90a%\x0FV[\x90V[a%Ea$_V[Pa%P`\x03a%1V[\x90V[_\x90V[``\x90V[a%ha%m\x91a\x10XV[a\x1B\xB5V[\x90V[a%z\x90Ta%\\V[\x90V[a%\x86\x90a\x0B\xC3V[\x90V[a%\x91a%SV[Pa%\x9Aa%WV[Pa%\xA5`Ca%pV[\x90a%\xB0`Da%}V[\x90V[a%\xD0\x91a%\xBFa$\x1BV[Pa%\xC8aH\xABV[\x91\x90\x91aH\xB8V[`\x01\x90V[_\x90V[_a%\xF1a%\xF7\x92a%\xE9a%\xD5V[P`\x0Ca\x10BV[\x01a\x10qV[\x90V[\x90a&\x14\x91a&\x0Fa&\na#\x1EV[aH\xC8V[a(tV[V[P\x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a&C\x91\x02\x91a&=_\x19\x84a&$V[\x92a&$V[\x91\x81\x19\x16\x91\x16\x17\x90V[a&aa&\\a&f\x92a\x07-V[a\x10\x0BV[a\x07-V[\x90V[\x90V[\x91\x90a&\x82a&}a&\x8A\x93a&MV[a&iV[\x90\x83Ta&(V[\x90UV[a&\xA0\x91a&\x9Aa%\xD5V[\x91a&lV[V[[\x81\x81\x10a&\xAEWPPV[\x80a&\xBB_`\x01\x93a&\x8EV[\x01a&\xA3V[\x91\x90`\x1F\x81\x11a&\xD1W[PPPV[a&\xDDa'\x02\x93a\n\xE4V[\x90` a&\xE9\x84a&\x1AV[\x83\x01\x93\x10a'\nW[a&\xFB\x90a&\x1AV[\x01\x90a&\xA2V[_\x80\x80a&\xCCV[\x91Pa&\xFB\x81\x92\x90Pa&\xF2V[\x90a'(\x90_\x19\x90`\x08\x02a\tMV[\x19\x16\x90V[\x81a'7\x91a'\x18V[\x90`\x02\x02\x17\x90V[\x91a'J\x90\x82a&\x16V[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a(\tWa'n\x82a'h\x85Ta\n\xB1V[\x85a&\xC1V[_\x90`\x1F\x83\x11`\x01\x14a'\xA1W\x91\x80\x91a'\x90\x93_\x92a'\x95W[PPa'-V[\x90U[V[\x90\x91P\x015_\x80a'\x89V[`\x1F\x19\x83\x16\x91a'\xB0\x85a\n\xE4V[\x92_[\x81\x81\x10a'\xF1WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a'\xD7W[PPP\x02\x01\x90Ua'\x93V[a'\xE7\x91\x015`\x1F\x84\x16\x90a'\x18V[\x90U_\x80\x80a'\xCBV[\x91\x93` `\x01\x81\x92\x87\x87\x015\x81U\x01\x95\x01\x92\x01a'\xB3V[a\x0B\x86V[\x90a(\x19\x92\x91a'?V[V[\x90\x82_\x93\x92\x827\x01RV[\x91\x90a(@\x81a(9\x81a(E\x95a\x06tV[\x80\x95a(\x1BV[a\x05\xC4V[\x01\x90V[\x91a(ca(q\x94\x92`@\x85\x01\x90\x85\x82\x03_\x87\x01Ra\x06}V[\x92` \x81\x85\x03\x91\x01Ra(&V[\x90V[\x90a(\x7F`Da%}V[a(\x8C\x83\x83\x90`Da(\x0EV[\x91\x90\x91a(\xC5\x7F\xB9\xA2\x08\x84&\xF0;0\xA8\x1C\x06B\x80\x94\xFB\xFA\x9E&\x92s\x9B2A\xAFk\x9A\xB1\xDAKUF\xBE\x93a(\xBCa\x04\xE2V[\x93\x84\x93\x84a(IV[\x03\x90\xA1V[\x90a(\xD4\x91a%\xFAV[V[a(\xDEa%\xD5V[Pa(\xE9`\x02a\x10qV[\x90V[a(\xFCa(\xF7a!.V[aH\xC8V[a)\x04a)\xC5V[V[a)\x1Aa)\x15a)\x1F\x92a\x1BEV[a\x10\x0BV[a\x07-V[\x90V[a)6a)1a);\x92a\x1BEV[a\x10\x0BV[a\x06LV[\x90V[a)G\x90a)\"V[\x90V[\x90a)V`\xFF\x91a\x1BHV[\x91\x81\x19\x16\x91\x16\x17\x90V[a)i\x90a\x05AV[\x90V[\x90V[\x90a)\x84a)\x7Fa)\x8B\x92a)`V[a)lV[\x82Ta)JV[\x90UV[\x90a)\x9B_\x19\x91a\x1BHV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a)\xBAa)\xB5a)\xC1\x92a&MV[a&iV[\x82Ta)\x8FV[\x90UV[a)\xCF`@a\x10qV[a)\xE1a)\xDB_a)\x06V[\x91a\x07-V[\x03a*~Wa)\xF0`Ca%pV[a*\na*\x04a)\xFF_a)>V[a\x06WV[\x91a\x06WV[\x14a*bWa*\x1B`\x01`?a)oV[a*&B`@a)\xA5V[Ba*]\x7F\x11\x94\xB04\xCF\xA9\xABX\x07IJ\x1D\\f}\x8B\x0En\x97\xF3\x88\x88t*\xA3\x87\x1A2 4\x11`\x91a*Ta\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xA1V[_c;\nH\xBD`\xE1\x1B\x81R\x80a*z`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c8\xE9=\xBD`\xE1\x1B\x81R\x80a*\x96`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[a*\xA2a(\xECV[V[\x91a*\xCE\x92a*\xB1a$\x1BV[Pa*\xC6a*\xBDaH\xABV[\x82\x90\x84\x91aI\x1CV[\x91\x90\x91aI\xA8V[`\x01\x90V[a*\xDC\x90a\x10*V[\x90V[_\x80\xFD[`\xE0\x1B\x90V[\x90PQ\x90a*\xF6\x82a\x070V[V[\x90` \x82\x82\x03\x12a+\x11Wa+\x0E\x91_\x01a*\xE9V[\x90V[a\x04\xECV[a+\x1Ea\x04\xE2V[=_\x82>=\x90\xFD[a+5a+;\x91\x93\x92\x93a\x07-V[\x92a\x07-V[\x82\x03\x91\x82\x11a+FWV[a#\x8AV[\x90V[a+ba+]a+g\x92a+KV[a\x10\x0BV[a\x07-V[\x90V[a+ya+\x7F\x91\x93\x92\x93a\x07-V[\x92a\x07-V[\x91a+\x8B\x83\x82\x02a\x07-V[\x92\x81\x84\x04\x14\x90\x15\x17\x15a+\x9AWV[a#\x8AV[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[a+\xBFa+\xC5\x91a\x07-V[\x91a\x07-V[\x90\x81\x15a+\xD0W\x04\x90V[a+\x9FV[a+\xDDa%\xD5V[\x91a+\xE6a%\xD5V[\x91a+\xFD_a+\xF7`\x0C\x84\x90a\x10BV[\x01a\x10qV[\x90a,\x15`\x02a,\x0F`\x0C\x84\x90a\x10BV[\x01a\x10qV[\x91a,N` a,$0a*\xD3V[ce\x1F\xD2h\x90a,C\x86\x92a,7a\x04\xE2V[\x95\x86\x94\x85\x93\x84\x93a*\xE3V[\x83R`\x04\x83\x01a\x11\xFEV[\x03\x91Z\xFA\x90\x81\x15a-\xA7Wa,\x99\x91` \x91_\x91a-zW[P\x93a,r0a*\xD3V[a,\x8Ec\x99\x89U\xD3a,\x82a\x04\xE2V[\x95\x86\x94\x85\x93\x84\x93a*\xE3V[\x83R`\x04\x83\x01a\x11\xFEV[\x03\x91Z\xFA\x90\x81\x15a-uW_\x91a-GW[P\x91\x81a,\xC0a,\xBA_a)\x06V[\x91a\x07-V[\x11a-\x16W[PP\x81a,\xDBa,\xD5_a)\x06V[\x91a\x07-V[\x11a,\xE5W[PPV[a-\x0E\x92\x93Pa,\xF8a-\t\x91\x83a+&V[a-\x03a'\x10a+NV[\x90a+jV[a+\xB3V[\x90_\x80a,\xE1V[a-?\x92\x96Pa-)a-:\x91\x83a+&V[a-4a'\x10a+NV[\x90a+jV[a+\xB3V[\x93_\x80a,\xC6V[a-h\x91P` =\x81\x11a-nW[a-`\x81\x83a\x0B\x9AV[\x81\x01\x90a*\xF8V[_a,\xABV[P=a-VV[a+\x16V[a-\x9A\x91P\x82=\x81\x11a-\xA0W[a-\x92\x81\x83a\x0B\x9AV[\x81\x01\x90a*\xF8V[_a,gV[P=a-\x88V[a+\x16V[_\x90V[a-\xB9\x90a\x0CYV[\x90V[\x90a-\xC6\x90a-\xB0V[_R` R`@_ \x90V[\x90V[a-\xE1a-\xE6\x91a\x10XV[a-\xD2V[\x90V[a-\xF3\x90Ta-\xD5V[\x90V[`\x01a.\x0Fa.\x15\x92a.\x07a-\xACV[P`\x05a-\xBCV[\x01a-\xE9V[\x90V[a. aJEV[a.(a/~V[V[a.6a.;\x91a\x10XV[a\tQV[\x90V[a.H\x90Ta.*V[\x90V[`\x01a.W\x91\x01a\x07-V[\x90V[a.ia.o\x91\x93\x92\x93a\x07-V[\x92a\x07-V[\x82\x01\x80\x92\x11a.zWV[a#\x8AV[a.\x88\x90a\x10*V[\x90V[a.\x94\x90a\x10\x0EV[\x90V[a.\xA0\x90a.\x8BV[\x90V[a.\xAC\x90a\x10*V[\x90V[_\x91\x03\x12a.\xB9WV[a\x04\xECV[\x90_\x92\x91\x80T\x90a.\xD8a.\xD1\x83a\n\xB1V[\x80\x94a\x06tV[\x91`\x01\x81\x16\x90\x81_\x14a//WP`\x01\x14a.\xF3W[PPPV[a/\0\x91\x92\x93\x94Pa\n\xE4V[\x91_\x92[\x81\x84\x10a/\x17WPP\x01\x90_\x80\x80a.\xEEV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a/\x04V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a.\xEEV[a/na/{\x94\x92\x93a/d``\x84\x01\x95_\x85\x01\x90a\x06cV[` \x83\x01\x90a\x07\xD4V[`@\x81\x84\x03\x91\x01Ra.\xBEV[\x90V[a/\x91a/\x8B`?a.>V[\x15a\x05AV[a2\xB1Wa/\x9Da@qV[a2\x95Wa/\xC6a/\xB8Ba/\xB2`@a\x10qV[\x90a+&V[a/\xC0a\x1C\xB1V[\x90a+\xB3V[\x80a/\xE2a/\xDCa/\xD7`Aa\x10qV[a\x07-V[\x91a\x07-V[\x11\x15a2yWa/\xFC\x90a/\xF6`Aa\x10qV[\x90a+&V[\x90\x81a0*a0$a0\x1Fa0\x0Fa\x13\x04V[a0\x19`Aa\x10qV[\x90a+&V[a\x07-V[\x91a\x07-V[\x11a2VW[a09_a)\x06V[\x90a0C_a)\x06V[\x91[\x82a0Xa0R\x86a\x07-V[\x91a\x07-V[\x10\x15a0\x9FWa0\x93a0\x99\x91a0\x8Da0\x87`\x0Fa0\x81a0z`Aa\x10qV[\x89\x90a.ZV[\x90a\x0E V[\x90a\x0EcV[\x90a.ZV[\x92a.KV[\x91a0EV[\x91P\x91a0\xB6a0\xAF`Ba\x10qV[\x83\x90a.ZV[a0\xCFa0\xC9a0\xC4a\x13\xD8V[a\x07-V[\x91a\x07-V[\x11a2:Wa0\xEAa0\xF1\x91a0\xE5`Aa\x10qV[a.ZV[`Aa)\xA5V[a1\x0Ea1\x07\x82a1\x02`Ba\x10qV[a.ZV[`Ba)\xA5V[a1!a1\x1A0a.\x7FV[\x82\x90aJoV[a1>a1-0a.\x7FV[a17`Ca%pV[\x83\x91aH\xB8V[a1Xa1Sa1N`Ca%pV[a.\x97V[a.\xA3V[c\x18\xB6\x8B\x8Ca1f0a.\x7FV[\x83\x92`D\x92\x81;\x15a25W_a1\x90\x91a1\x9B\x82\x96a1\x84a\x04\xE2V[\x98\x89\x97\x88\x96\x87\x95a*\xE3V[\x85R`\x04\x85\x01a/JV[\x03\x92Z\xF1\x80\x15a20Wa2\x04W[Pa1\xB5`Aa\x10qV[\x90a1\xBF_a)>V[\x90a1\xEA\x7F4\xB7=\x0C\x96\xE9\xFFMS\x11CH\x17\xC8\xEC\xC90\xE7\xD2x,[\xDE.y\xDCD\xB0YgU\xBB\x92a\x106V[\x92a1\xFFa1\xF6a\x04\xE2V[\x92\x83\x92\x83a\n1V[\x03\x90\xA2V[a2#\x90_=\x81\x11a2)W[a2\x1B\x81\x83a\x0B\x9AV[\x81\x01\x90a.\xAFV[_a1\xAAV[P=a2\x11V[a+\x16V[a*\xDFV[_c#\x06N\xBD`\xE0\x1B\x81R\x80a2R`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x90Pa2sa2ca\x13\x04V[a2m`Aa\x10qV[\x90a+&V[\x90a00V[_c\xE0\x85\xD2+`\xE0\x1B\x81R\x80a2\x91`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c\x11UbK`\xE2\x1B\x81R\x80a2\xAD`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c\x19\xAF\xC9\x9D`\xE2\x1B\x81R\x80a2\xC9`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[a2\xD5a.\x18V[V[\x90a2\xF2\x91a2\xEDa2\xE8\x82a-\xF6V[aH\xC8V[a2\xF4V[V[\x90a2\xFE\x91aJ\xCDV[PV[\x90a3\x0B\x91a2\xD7V[V[_\x90V[\x90V[a3(a3#a3-\x92a3\x11V[a\x10\x0BV[a\r\x88V[\x90V[a38a3\rV[Pa3C`\x12a3\x14V[\x90V[a3Va3Qa!.V[aH\xC8V[a3^a3`V[V[a3j`@a\x10qV[a3|a3v_a)\x06V[\x91a\x07-V[\x14a3\xC5Wa3\x8D`\x01`?a)oV[\x7FJy*\x0B\xE4+Vr\xFA\xA4\x01)\xFCdi\x07$\x90w\\\xA8\xD3\xC3N\x85-MU\xD3\xA75\xA9a3\xB6a\x04\xE2V[\x80a3\xC0\x81a\x08\xACV[\x03\x90\xA1V[_c\x8F\x98@A`\xE0\x1B\x81R\x80a3\xDD`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[a3\xE9a3FV[V[a3\xF3a-\xACV[Pa3\xFCaKyV[\x90V[\x90\x80a4\x1Aa4\x14a4\x0FaH\xABV[a\x06WV[\x91a\x06WV[\x03a4+Wa4(\x91aL3V[PV[_c3K\xD9\x19`\xE1\x1B\x81R\x80a4C`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x90a4Q\x90a\x106V[_R` R`@_ \x90V[\x90V[a4ta4oa4y\x92a\"SV[a\x10\x0BV[a\x07-V[\x90V[a4\xB3\x91a4\xA8a4\xA2a4\x9Da4\xAE\x94a4\x95a%\xD5V[P`\na4GV[a4]V[\x91aM\x14V[\x90aN\nV[a4`V[\x90V[a4\xC6a4\xC1a\x1BiV[aH\xC8V[a4\xCEa4\xD0V[V[a4\xD8aO\x91V[V[a4\xE2a4\xB6V[V[\x90\x81a5\0a4\xFAa4\xF5_a)>V[a\x06WV[\x91a\x06WV[\x14a5\xFFW\x80a5\x18a5\x12_a)\x06V[\x91a\x07-V[\x14a5\xE3Wa5:a54a5/`\r3\x90a\x14/V[a.>V[\x15a\x05AV[a5\xC7Wa5G3aO\x9EV[a5^`\x01a5X`\x0C3\x90a\x10BV[\x01a\x10qV[a5pa5j\x83a\x07-V[\x91a\x07-V[\x10a5\xABWa5\xA9\x91a5\xA4\x82a5\x9E`\x01a5\x8E`\x0C3\x90a\x10BV[\x01\x91a5\x99\x83a\x10qV[a+&V[\x90a)\xA5V[aJoV[V[_c\x1C\x95\x9E\xD9`\xE2\x1B\x81R\x80a5\xC3`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_cD\x17v\t`\xE1\x1B\x81R\x80a5\xDF`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a5\xFB`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a6\x17`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[a6#a%\xD5V[Pa6?a6/a\x13\xD8V[a69`Ba\x10qV[\x90a+&V[\x90V[\x90a6Ua6Na\x04\xE2V[\x92\x83a\x0B\x9AV[V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a6uWa6q` \x91a\x05\xC4V[\x01\x90V[a\x0B\x86V[\x90a6\x8Ca6\x87\x83a6WV[a6BV[\x91\x82RV[_\x7Fmode=blocknumber&from=default\0\0\0\x91\x01RV[a6\xC2`\x1Da6zV[\x90a6\xCF` \x83\x01a6\x91V[V[a6\xD9a6\xB8V[\x90V[a6\xE4a$_V[Pa6\xEDa;\xFFV[a7\x06a7\0a6\xFBaQ9V[a\x18\xBEV[\x91a\x18\xBEV[\x03a7\x16Wa7\x13a6\xD1V[\x90V[_c\x01\xBF\xC1\xC5`\xE6\x1B\x81R\x80a7.`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x90a7<\x90a\x106V[_R` R`@_ \x90V[a7_a7d\x91a7Wa%SV[P`\ta72V[a%pV[\x90V[a7oa$\x1BV[Pa7z`@a\x10qV[a7\x8Ca7\x86_a)\x06V[\x91a\x07-V[\x11\x90V[a7\xA1\x90a7\x9CaH\xABV[aQNV[V[a7\xABa$\x1BV[Pa7\xB6`\x0Ea.>V[\x90V[a8\x10\x90a7\xC5a%\xD5V[Pa7\xDD`\x01a7\xD7`\x0C\x84\x90a\x10BV[\x01a\x10qV[\x90a8\n`\x04a8\x04a7\xFC_a7\xF6`\x0C\x87\x90a\x10BV[\x01a\x10qV[\x93`\x0Ca\x10BV[\x01a\x10qV[\x91aQ\xD9V[\x90V[a8#a8\x1Ea!\x92V[aH\xC8V[a8+a8-V[V[a88_`?a)oV[\x7Fs\xA5\xFC`\xAA\xFE\xEC\x8F\x13\x9A\xF2-\x98\xE6!@\xE2\xCE\x91M\x1F\x15\\i+BwW\xC3\xE4\x01La8aa\x04\xE2V[\x80a8k\x81a\x08\xACV[\x03\x90\xA1V[a8xa8\x13V[V[_\x90V[a8\x90\x90a8\x8Aa8zV[PaR\x85V[\x90V[\x90a8\x9D\x90a\x106V[_R` R`@_ \x90V[a8\xBFa8\xC4\x91a8\xB8a%\xD5V[P_a8\x93V[a\x10qV[\x90V[a8\xDEa8\xE3\x91a8\xD6a$\x1BV[P`\ra\x14/V[a.>V[\x90V[\x90a8\xEFa$\x1BV[Pa8\xF8a%\xD5V[Pa9\x01a%\xD5V[Pa9\na%\xD5V[Pa9\x13a%\xD5V[Pa9(a9#`\r\x84\x90a\x14/V[a.>V[\x91a9?_a99`\x0C\x84\x90a\x10BV[\x01a\x10qV[\x91a9W`\x02a9Q`\x0C\x85\x90a\x10BV[\x01a\x10qV[\x90a9\x90` a9f0a*\xD3V[ce\x1F\xD2h\x90a9\x85\x87\x92a9ya\x04\xE2V[\x95\x86\x94\x85\x93\x84\x93a*\xE3V[\x83R`\x04\x83\x01a\x11\xFEV[\x03\x91Z\xFA\x90\x81\x15a:QWa9\xDB\x91` \x91_\x91a:$W[P\x94a9\xB40a*\xD3V[a9\xD0c\x99\x89U\xD3a9\xC4a\x04\xE2V[\x95\x86\x94\x85\x93\x84\x93a*\xE3V[\x83R`\x04\x83\x01a\x11\xFEV[\x03\x91Z\xFA\x90\x81\x15a:\x1FW_\x91a9\xF1W[P\x90V[a:\x12\x91P` =\x81\x11a:\x18W[a:\n\x81\x83a\x0B\x9AV[\x81\x01\x90a*\xF8V[_a9\xEDV[P=a:\0V[a+\x16V[a:D\x91P\x82=\x81\x11a:JW[a:<\x81\x83a\x0B\x9AV[\x81\x01\x90a*\xF8V[_a9\xA9V[P=a:2V[a+\x16V[a:h\x90a:ba%\xD5V[PaR\xB4V[\x90V[a:{a:va!\x92V[aH\xC8V[a:\x83a:\x85V[V[a:\x8DaS*V[V[a:\x97a:kV[V[_\x90V[``\x90V[a:\xAB\x90a\x10*V[\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a:\xC6W` \x80\x91\x02\x01\x90V[a\x0B\x86V[\x90a:\xDDa:\xD8\x83a:\xAEV[a6BV[\x91\x82RV[6\x907V[\x90a;\x0Ca:\xF4\x83a:\xCBV[\x92` \x80a;\x02\x86\x93a:\xAEV[\x92\x01\x91\x03\x90a:\xE2V[V[`\x0F`\xF8\x1B\x90V[a;\x1Ea:\x99V[Pa;'a$_V[Pa;0a$_V[Pa;9a%\xD5V[Pa;Ba%SV[Pa;Ka-\xACV[Pa;Ta:\x9DV[Pa;]aS7V[\x90a;faSwV[\x90F\x90a;r0a:\xA2V[\x90a;|_a\x1BMV[\x90a;\x8Ea;\x89_a)\x06V[a:\xE7V[\x90a;\x97a;\x0EV[\x96\x95\x94\x93\x92\x91\x90V[a;\xC9a;\xCE\x91a;\xAFa%\xD5V[Pa;\xC3a;\xBD`\x0Ba4]V[\x91aM\x14V[\x90aN\nV[a4`V[\x90V[a;\xF8\x91_a;\xEDa;\xF3\x93a;\xE5a$\x1BV[P`\x05a-\xBCV[\x01a\x14/V[a.>V[\x90V[_\x90V[a<\x07a;\xFBV[Pa<\x10aQ9V[\x90V[a<\x1Ba$_V[Pa<&`\x04a%1V[\x90V[a<\x81\x90a<5a%\xD5V[Pa<M`\x03a<G`\x0C\x84\x90a\x10BV[\x01a\x10qV[\x90a<{`\x04a<ua<m`\x02a<g`\x0C\x87\x90a\x10BV[\x01a\x10qV[\x93`\x0Ca\x10BV[\x01a\x10qV[\x91aQ\xD9V[\x90V[a<\xABa<\xA6a<\xA1a<\xB0\x93a<\x99a%\xD5V[P`\na4GV[a4]V[aS\xB7V[a4`V[\x90V[\x90\x81a<\xCFa<\xC9a<\xC4_a)>V[a\x06WV[\x91a\x06WV[\x14a=\xCEW\x80a<\xE7a<\xE1_a)\x06V[\x91a\x07-V[\x14a=\xB2Wa=\ta=\x03a<\xFE`\r3\x90a\x14/V[a.>V[\x15a\x05AV[a=\x96Wa=\x163aO\x9EV[a=-`\x03a='`\x0C3\x90a\x10BV[\x01a\x10qV[a=?a=9\x83a\x07-V[\x91a\x07-V[\x10a=zWa=x\x91a=s\x82a=m`\x03a=]`\x0C3\x90a\x10BV[\x01\x91a=h\x83a\x10qV[a+&V[\x90a)\xA5V[aT,V[V[_c\x1C\x95\x9E\xD9`\xE2\x1B\x81R\x80a=\x92`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_cD\x17v\t`\xE1\x1B\x81R\x80a=\xAE`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a=\xCA`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a=\xE6`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x90a>\x05\x92\x91a>\0a=\xFBa#\x1EV[aH\xC8V[a>\x07V[V[\x80a>\"a>\x1Ca>\x17_a)>V[a\x06WV[\x91a\x06WV[\x14a@HWa>Da>>a>9`\r\x84\x90a\x14/V[a.>V[\x15a\x05AV[\x80a@\rW[a?\xB1W[\x81a>ba>\\_a)\x06V[\x91a\x07-V[\x14\x80a?\x97W[\x80a?}W[a?\"W[a>}\x81aO\x9EV[a>\x94\x82_a>\x8E`\x0C\x85\x90a\x10BV[\x01a)\xA5V[a>\xAC\x83`\x02a>\xA6`\x0C\x85\x90a\x10BV[\x01a)\xA5V[a>\xC4\x82`\x01a>\xBE`\x0C\x85\x90a\x10BV[\x01a)\xA5V[a>\xDC\x83`\x03a>\xD6`\x0C\x85\x90a\x10BV[\x01a)\xA5V[\x90\x91a?\x08\x7F\xAA\x80}\n\xBF0\xD9\x19h\xC7G\x8Cf\xB6\xD8%!\xA1\x06\xAF\x13\xED\xA06\xE2\x03m\xA9\xAF\x16\x89X\x92a\x106V[\x92a?\x1Da?\x14a\x04\xE2V[\x92\x83\x92\x83a\n1V[\x03\x90\xA2V[a?7_a?2`\r\x84\x90a\x14/V[a)oV[\x80a?b\x7F\x02\xC2\xF0\xBA\x15\xB0?\x88\xB1\x8FH2`\x9A\x18\xCF5\xFCk?EF\xA9\x99 v\xD7E=\x134\xA8\x91a\x106V[\x90a?ka\x04\xE2V[\x80a?u\x81a\x08\xACV[\x03\x90\xA2a>tV[Pa?\x92a?\x8D`\r\x83\x90a\x14/V[a.>V[a>oV[P\x82a?\xABa?\xA5_a)\x06V[\x91a\x07-V[\x14a>iV[a?\xC7`\x01a?\xC2`\r\x84\x90a\x14/V[a)oV[\x80a?\xF2\x7Fl\xF2\x849\xA2\xDA\xAB\x1B&P\x97\"r\x12\xA5\xB7\x1E\nv\xF9\xED\x85\xE3\xF8\x15\xB5\xA6\xC3\xE2\x18\xEB\x7F\x91a\x106V[\x90a?\xFBa\x04\xE2V[\x80a@\x05\x81a\x08\xACV[\x03\x90\xA2a>OV[P\x81a@!a@\x1B_a)\x06V[\x91a\x07-V[\x11\x80\x15a@.W[a>JV[P\x82a@Ba@<_a)\x06V[\x91a\x07-V[\x11a@)V[_c\xD9.#=`\xE0\x1B\x81R\x80a@``\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x90a@o\x92\x91a=\xEAV[V[a@ya$\x1BV[Pa@\x84`Aa\x10qV[a@\x9Da@\x97a@\x92a\x13\x04V[a\x07-V[\x91a\x07-V[\x10\x15\x90V[a@\xBB\x90a@\xB6a@\xB1a#\x1EV[aH\xC8V[a@\xFBV[V[\x90a@\xCE`\x01\x80`\xA0\x1B\x03\x91a\x1BHV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90V[\x90a@\xF0a@\xEBa@\xF7\x92a\x106V[a@\xD8V[\x82Ta@\xBDV[\x90UV[\x80aA\x16aA\x10aA\x0B_a)>V[a\x06WV[\x91a\x06WV[\x14aA|WaA%`Ca%pV[aA0\x82`Ca@\xDBV[\x90aAdaA^\x7F\x07\x01[j\x9F\x05\x911H\xFD_\xAD\xDF*\xCC\x97\x08\xF3\x05\x93\x7F0r\xCA+KF\xFA\xA5\xD0\x89\x8B\x93a\x106V[\x91a\x106V[\x91aAma\x04\xE2V[\x80aAw\x81a\x08\xACV[\x03\x90\xA3V[_c\xD9.#=`\xE0\x1B\x81R\x80aA\x94`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[aA\xA1\x90a@\xA2V[V[aA\xC0\x91aA\xAFa$\x1BV[PaA\xB8aH\xABV[\x91\x90\x91aI\xA8V[`\x01\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11aA\xDAW` \x02\x90V[a\x0B\x86V[aA\xEBaA\xF0\x91aA\xC5V[a6BV[\x90V[\x90aB\x11aB\0\x83aA\xDFV[\x92aB\x0B\x84\x91aA\xC5V[\x90a:\xE2V[V[aB\x1D`0aA\xF3V[\x90V[\x90P\x90V[aB/\x90Ta\x10]V[\x90V[`\x01\x01\x90V[aBTaBNaBG\x83a\x0E\x17V[\x80\x94aB V[\x91a\x0E\x1DV[_\x91[\x83\x83\x10aBdWPPPPV[aB\x81aB{`\x01\x92aBv\x85aB%V[a\x16\xC5V[\x92aB2V[\x92\x01\x91\x90aBWV[\x90aB\x98\x81a\x06\0\x93aB8V[\x01\x90V[\x90aB\xBCaB\xB5\x92aB\xACa\x04\xE2V[\x93\x84\x80\x92aB\x8AV[\x03\x83a\x0B\x9AV[V[aB\xC7\x90aB\x9CV[\x90V[aB\xD2aB\x13V[PaB\xDD`\x0FaB\xBEV[\x90V[\x90aB\xF3\x91aB\xEDa%\xD5V[Pa4|V[\x90V[\x90V[aC\raC\x08aC\x12\x92aB\xF6V[a\x10\x0BV[a\x07-V[\x90V[aC\x1Da%\xD5V[PaC&a%\xD5V[PaC/a%\xD5V[PaC8a$\x1BV[PaCC`@a\x10qV[aCUaCO_a)\x06V[\x91a\x07-V[\x14aD\x94WaC\x7FaCqBaCk`@a\x10qV[\x90a+&V[aCya\x1C\xB1V[\x90a+\xB3V[\x90aC\xC1aC\x8D`@a\x10qV[aC\xBBaC\xADaC\x9D`Aa\x10qV[aC\xA7`\x01aB\xF9V[\x90a.ZV[aC\xB5a\x1C\xB1V[\x90a+jV[\x90a.ZV[aC\xCB`Aa\x10qV[aC\xE4aC\xDEaC\xD9a\x13\x04V[a\x07-V[\x91a\x07-V[\x10_\x14aD\x86WaD\taD\x03`\x0FaC\xFD`Aa\x10qV[\x90a\x0E V[\x90a\x0EcV[[\x92aD\x15`?a.>V[\x90\x81aDbW[P\x80aD8W[\x91aD.`Aa\x10qV[\x91\x93\x92\x91\x93\x92\x91\x90V[PaDC`Aa\x10qV[aD\\aDVaDQa\x13\x04V[a\x07-V[\x91a\x07-V[\x10aD#V[\x90PaD\x7FaDyaDt`Aa\x10qV[a\x07-V[\x91a\x07-V[\x11_aD\x1CV[aD\x8F_a)\x06V[aD\nV[_\x90_\x91_\x91aD\xB6aD\xB0aD\xAA_\x94a)\x06V[\x95a)\x06V[\x93a)\x06V[\x91\x90V[aD\xCC\x90aD\xC6a%\xD5V[Pa<\x84V[\x90V[aD\xD7a%\xD5V[PaD\xE0a(\xD6V[\x90V[`\x02aD\xFCaE\x02\x92aD\xF4a%\xD5V[P`\x0Ca\x10BV[\x01a\x10qV[\x90V[\x7F\xE4\x83)\x05{\xFD\x03\xD5^I\xB5G\x13.9\xCF\xFD\x9C\x18 \xAD{\x9DLS\x07i\x14%\xD1Z\xDF\x90V[aE^aEe\x94aET``\x94\x98\x97\x95aEJ`\x80\x86\x01\x9A_\x87\x01\x90a\x0C\x9DV[` \x85\x01\x90a\x06cV[`@\x83\x01\x90a\x07\xD4V[\x01\x90a\x07\xD4V[V[` \x01\x90V[\x93\x95\x94\x90\x92\x91\x95BaE\x87aE\x81\x89a\x07-V[\x91a\x07-V[\x11aF\0W\x91aE\xF2\x91aE\xF9\x93aE\xE9aE\xFE\x98\x99aE\xD1aE\xA8aE\x05V[aE\xC2\x8B\x93\x8BaE\xB6a\x04\xE2V[\x95\x86\x94` \x86\x01aE)V[` \x82\x01\x81\x03\x82R\x03\x82a\x0B\x9AV[aE\xE3aE\xDD\x82a\x06pV[\x91aEgV[ aT\x8BV[\x92\x90\x91\x92aT\xA8V[\x91\x82aT\xF2V[aQNV[V[aF\x1B\x87_\x91\x82\x91c#A\xD7\x87`\xE1\x1B\x83R`\x04\x83\x01a\x07\xE1V[\x03\x90\xFD[\x7Fnq\xED\xAE\x12\xB1\xB9\x7FM\x1F`7\x0F\xEF\x10\x10_\xA2\xFA\xAE\x01&\x11J\x16\x9Cd\x84]a&\xC9\x90V[\x91\x94aF\x8BaF\x95\x92\x98\x97\x95aF\x81`\xA0\x96aFwaF\x9C\x9AaFm`\xC0\x8A\x01\x9E_\x8B\x01\x90a\x0C\x9DV[` \x89\x01\x90a\x06cV[`@\x87\x01\x90a\x06cV[``\x85\x01\x90a\x07\xD4V[`\x80\x83\x01\x90a\x07\xD4V[\x01\x90a\x07\xD4V[V[\x91` aF\xBF\x92\x94\x93aF\xB8`@\x82\x01\x96_\x83\x01\x90a\x06cV[\x01\x90a\x06cV[V[\x96\x95\x91\x93\x92\x94\x90\x94BaF\xDCaF\xD6\x83a\x07-V[\x91a\x07-V[\x11aG\x96W\x90aGEaGN\x94\x93\x92aG-aF\xF6aF\x1FV[aG\x1E\x8C\x80\x94\x8C\x91aG\x08\x8D\x91aU5V[\x91\x92aG\x12a\x04\xE2V[\x97\x88\x96` \x88\x01aFCV[` \x82\x01\x81\x03\x82R\x03\x82a\x0B\x9AV[aG?aG9\x82a\x06pV[\x91aEgV[ aT\x8BV[\x92\x90\x91\x92aT\xA8V[\x80aGaaG[\x87a\x06WV[\x91a\x06WV[\x03aGvWPaGt\x92\x93\x91\x90\x91aH\xB8V[V[\x84\x90aG\x92_\x92\x83\x92c%\xC0\x07#`\xE1\x1B\x84R`\x04\x84\x01aF\x9EV[\x03\x90\xFD[aG\xB1\x90_\x91\x82\x91c1<\x89\x81`\xE1\x1B\x83R`\x04\x83\x01a\x07\xE1V[\x03\x90\xFD[\x90aG\xD0\x91aG\xCBaG\xC6\x82a-\xF6V[aH\xC8V[aG\xD2V[V[\x90aG\xDC\x91aL3V[PV[\x90aG\xE9\x91aG\xB5V[V[\x90aG\xF5\x90a\x106V[_R` R`@_ \x90V[aH&\x91aH\x1CaH!\x92aH\x14a%\xD5V[P`\x01aG\xEBV[a8\x93V[a\x10qV[\x90V[aH3`@a6BV[\x90V[_\x90V[_\x90V[aHFaH)V[\x90` \x80\x83aHSaH6V[\x81R\x01aH^aH:V[\x81RPPV[aHlaH>V[\x90V[\x90aH\x82\x91aH|aHdV[PaUhV[\x90V[aH\x8Da$\x1BV[PaH\xA7aH\xA1c\x01\xFF\xC9\xA7`\xE0\x1Ba\x04\xF4V[\x91a\x04\xF4V[\x14\x90V[aH\xB3a%SV[P3\x90V[\x91aH\xC6\x92\x91`\x01\x92aU\x90V[V[aH\xDA\x90aH\xD4aH\xABV[\x90aV\xC2V[V[`@\x90aI\x05aI\x0C\x94\x96\x95\x93\x96aH\xFB``\x84\x01\x98_\x85\x01\x90a\x06cV[` \x83\x01\x90a\x07\xD4V[\x01\x90a\x07\xD4V[V[\x90aI\x19\x91\x03a\x07-V[\x90V[\x92\x91\x92aI*\x81\x83\x90aH\x01V[\x90\x81aI?aI9_\x19a\x07-V[\x91a\x07-V[\x10aILW[PPP\x90PV[\x81aI_aIY\x87a\x07-V[\x91a\x07-V[\x10aI\x85WaI|\x93\x94aIt\x91\x93\x92aI\x0EV[\x90_\x92aU\x90V[\x80_\x80\x80aIEV[PaI\xA4\x84\x92\x91\x92_\x93\x84\x93c}\xC7\xA0\xD9`\xE1\x1B\x85R`\x04\x85\x01aH\xDCV[\x03\x90\xFD[\x91\x82aI\xC4aI\xBEaI\xB9_a)>V[a\x06WV[\x91a\x06WV[\x14aJ\x1EW\x81aI\xE4aI\xDEaI\xD9_a)>V[a\x06WV[\x91a\x06WV[\x14aI\xF7WaI\xF5\x92\x91\x90\x91aV\xFDV[V[aJ\x1AaJ\x03_a)>V[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x11\xFEV[\x03\x90\xFD[aJAaJ*_a)>V[_\x91\x82\x91cKc~\x8F`\xE1\x1B\x83R`\x04\x83\x01a\x11\xFEV[\x03\x90\xFD[aJMa7\xA3V[aJSWV[_c\xD9<\x06e`\xE0\x1B\x81R\x80aJk`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x80aJ\x8AaJ\x84aJ\x7F_a)>V[a\x06WV[\x91a\x06WV[\x14aJ\xA6WaJ\xA4\x91aJ\x9C_a)>V[\x91\x90\x91aV\xFDV[V[aJ\xC9aJ\xB2_a)>V[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x11\xFEV[\x03\x90\xFD[aJ\xD5a$\x1BV[PaJ\xEAaJ\xE4\x82\x84\x90a;\xD1V[\x15a\x05AV[_\x14aKsWaK\x12`\x01aK\r_aK\x05`\x05\x86\x90a-\xBCV[\x01\x85\x90a\x14/V[a)oV[\x90aK\x1BaH\xABV[\x90aKXaKRaKL\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a-\xB0V[\x92a\x106V[\x92a\x106V[\x92aKaa\x04\xE2V[\x80aKk\x81a\x08\xACV[\x03\x90\xA4`\x01\x90V[PP_\x90V[aK\x81a-\xACV[PaK\x8B0a:\xA2V[aK\xBDaK\xB7\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x06WV[\x91a\x06WV[\x14\x80aK\xF9W[_\x14aK\xEEW\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[aK\xF6aW}V[\x90V[PFaL-aL'\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x07-V[\x91a\x07-V[\x14aK\xC4V[aL;a$\x1BV[PaLG\x81\x83\x90a;\xD1V[_\x14aL\xCFWaLn_aLi_aLa`\x05\x86\x90a-\xBCV[\x01\x85\x90a\x14/V[a)oV[\x90aLwaH\xABV[\x90aL\xB4aL\xAEaL\xA8\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x95a-\xB0V[\x92a\x106V[\x92a\x106V[\x92aL\xBDa\x04\xE2V[\x80aL\xC7\x81a\x08\xACV[\x03\x90\xA4`\x01\x90V[PP_\x90V[aL\xE9aL\xE4aL\xEE\x92a\x18\xBEV[a\x10\x0BV[a\x07-V[\x90V[\x91` aM\x12\x92\x94\x93aM\x0B`@\x82\x01\x96_\x83\x01\x90a\x07\xD4V[\x01\x90a\x18\xC9V[V[aM\x1Ca;\xFBV[PaM%a;\xFFV[\x81aM8aM2\x83aL\xD5V[\x91a\x07-V[\x10\x15aMKWPaMH\x90aX\x83V[\x90V[\x90aMf_\x92\x83\x92cvi\xFC\x0F`\xE1\x1B\x84R`\x04\x84\x01aL\xF1V[\x03\x90\xFD[T\x90V[\x90V[aM\x85aM\x80aM\x8A\x92aMnV[a\x10\x0BV[a\x07-V[\x90V[\x90V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[aM\xA7aM\xAC\x91a\x10XV[aM\x90V[\x90V[aM\xB9\x90TaM\x9BV[\x90V[`0\x1C\x90V[`\x01\x80`\xD0\x1B\x03\x16\x90V[aM\xD9aM\xDE\x91aM\xBCV[aM\xC2V[\x90V[aM\xEB\x90TaM\xCDV[\x90V[aN\x02aM\xFDaN\x07\x92a\x1BEV[a\x10\x0BV[a\"SV[\x90V[\x90aN^\x90aN\x17a#\x86V[PaN#_\x84\x01aMjV[aN,_a)\x06V[\x90\x80\x80aNBaN<`\x05aMqV[\x91a\x07-V[\x11aN\xBFW[P\x90aNY_\x86\x01\x93\x91\x92\x93aM\x8DV[a^\xBEV[\x80aNqaNk_a)\x06V[\x91a\x07-V[\x14_\x14aN\x87WPPaN\x83_aM\xEEV[[\x90V[aN\xB4_\x91aN\xAFaN\xA9\x84aN\xBA\x96\x01\x92aN\xA3`\x01aB\xF9V[\x90a+&V[\x91aM\x8DV[a^\xB4V[\x01aM\xE1V[aN\x84V[\x80aN\xCDaN\xD3\x92\x91a[IV[\x90a+&V[\x90\x83aO\x05aN\xFFaN\xFA_aN\xF4\x81\x8C\x01aN\xEF\x89\x91aM\x8DV[a^\xB4V[\x01aM\xAFV[a\x18\xBEV[\x91a\x18\xBEV[\x10_\x14aO\x16WP\x90[\x90_aNHV[\x91PaO,\x90aO&`\x01aB\xF9V[\x90a.ZV[aO\x0FV[aO9a_MV[aOAaOCV[V[aON_`\x0Ea)oV[aOVaH\xABV[aO\x8C\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA\x91aO\x83a\x04\xE2V[\x91\x82\x91\x82a\x11\xFEV[\x03\x90\xA1V[aO\x99aO1V[V[\x90V[aO\xACaO\xB1\x91`\x0Ca\x10BV[aO\x9BV[aO\xBD`\x04\x82\x01a\x10qV[aO\xCFaO\xC9_a)\x06V[\x91a\x07-V[\x14aQ)WaPK\x90aO\xEEBaO\xE8`\x04\x84\x01a\x10qV[\x90a+&V[\x80aP\x08aP\x02aO\xFDa\x19tV[a\x07-V[\x91a\x07-V[\x10\x15_\x14aPMWPaP(aP\x1F_\x83\x01a\x10qV[`\x01\x83\x01a)\xA5V[aP@aP7`\x02\x83\x01a\x10qV[`\x03\x83\x01a)\xA5V[[`\x04B\x91\x01a)\xA5V[V[\x80aP`aPZ_a)\x06V[\x91a\x07-V[\x11aPlW[PaPAV[aQ\x1AaQ\x08aQ#\x92aP\xF7aP\xEEaP\xDDaP\xCBaP\xBDaP\xABaP\x9DaP\x96_\x8D\x01a\x10qV[\x88\x90a+jV[aP\xA5a\x19tV[\x90a+\xB3V[\x95aP\xB8`\x02\x8C\x01a\x10qV[a+jV[aP\xC5a\x19tV[\x90a+\xB3V[\x93aP\xD8`\x01\x8A\x01a\x10qV[a.ZV[aP\xE8_\x89\x01a\x10qV[\x90a_\x80V[`\x01\x87\x01a)\xA5V[aQ\x03`\x03\x86\x01a\x10qV[a.ZV[aQ\x14`\x02\x85\x01a\x10qV[\x90a_\x80V[`\x03\x83\x01a)\xA5V[_aPfV[aQ7\x90`\x04B\x91\x01a)\xA5V[V[aQAa;\xFBV[PaQKCaX\x83V[\x90V[\x90aQ\xD7\x91aQ\xD1aQ_\x82a7HV[aQt\x84aQo`\t\x86\x90a72V[a@\xDBV[\x82\x81\x85\x90aQ\xB4aQ\xAEaQ\xA8\x7F14\xE8\xA2\xE6\xD9~\x92\x9A~T\x01\x1E\xA5H]}\x19m\xD5\xF0\xBAMN\xF9X\x03\xE8\xE3\xFC%\x7F\x95a\x106V[\x92a\x106V[\x92a\x106V[\x92aQ\xBDa\x04\xE2V[\x80aQ\xC7\x81a\x08\xACV[\x03\x90\xA4\x92\x91a_\xB0V[\x91a_\xC8V[V[\x90\x91aQ\xE3a%\xD5V[P\x80aQ\xF7aQ\xF1_a)\x06V[\x91a\x07-V[\x14aRvWaR\x06\x90Ba+&V[\x90\x81aR!aR\x1BaR\x16a\x19tV[a\x07-V[\x91a\x07-V[\x10\x15aRqWaREaR7aRK\x93\x85a+jV[aR?a\x19tV[\x90a+\xB3V[\x90a.ZV[\x80aR^aRX\x84a\x07-V[\x91a\x07-V[\x11_\x14aRjWP[\x90V[\x90PaRgV[PP\x90V[PPPaR\x82_a)\x06V[\x90V[aR\xACaR\xA7aR\xA2aR\xB1\x93aR\x9Aa8zV[P`\na4GV[a4]V[aavV[aa\xF5V[\x90V[aR\xC6\x90aR\xC0a%\xD5V[PabFV[\x90V[aR\xD1aJEV[aR\xD9aR\xDBV[V[aR\xE7`\x01`\x0Ea)oV[aR\xEFaH\xABV[aS%\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2X\x91aS\x1Ca\x04\xE2V[\x91\x82\x91\x82a\x11\xFEV[\x03\x90\xA1V[aS2aR\xC9V[V[\x90V[aS?a$_V[PaSt\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0aSn`\x06aS4V[\x90acaV[\x90V[aS\x7Fa$_V[PaS\xB4\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0aS\xAE`\x07aS4V[\x90acaV[\x90V[aS\xBFa#\x86V[PaS\xCB_\x82\x01aMjV[\x80aS\xDEaS\xD8_a)\x06V[\x91a\x07-V[\x14_\x14aS\xF4WPPaS\xF0_aM\xEEV[[\x90V[aT!_\x91aT\x1CaT\x16\x84aT'\x96\x01\x92aT\x10`\x01aB\xF9V[\x90a+&V[\x91aM\x8DV[a^\xB4V[\x01aM\xE1V[aS\xF1V[\x90\x81aTHaTBaT=_a)>V[a\x06WV[\x91a\x06WV[\x14aTdWaTb\x91\x90aT[_a)>V[\x90\x91aV\xFDV[V[aT\x87aTp_a)>V[_\x91\x82\x91cKc~\x8F`\xE1\x1B\x83R`\x04\x83\x01a\x11\xFEV[\x03\x90\xFD[aT\xA5\x90aT\x97a-\xACV[PaT\xA0aKyV[ac\xAFV[\x90V[\x92aT\xC3\x92aT\xCC\x94aT\xB9a%SV[P\x92\x90\x91\x92adeV[\x90\x92\x91\x92ae\x90V[\x90V[\x91` aT\xF0\x92\x94\x93aT\xE9`@\x82\x01\x96_\x83\x01\x90a\x06cV[\x01\x90a\x07\xD4V[V[aT\xFB\x81aU5V[\x91aU\x0EaU\x08\x84a\x07-V[\x91a\x07-V[\x03aU\x17WPPV[aU1_\x92\x83\x92c\x01\xD4\xB6#`\xE6\x1B\x84R`\x04\x84\x01aT\xCFV[\x03\x90\xFD[aUI\x90aUAa%\xD5V[P`\x08a8\x93V[aUeaUU\x82a\x10qV[\x91aU_\x83a.KV[\x90a)\xA5V[\x90V[\x90aU\x88aU\x83aU\x8D\x93aU{aHdV[P`\na4GV[a4]V[af\xF2V[\x90V[\x90\x92\x81aU\xADaU\xA7aU\xA2_a)>V[a\x06WV[\x91a\x06WV[\x14aVxW\x83aU\xCDaU\xC7aU\xC2_a)>V[a\x06WV[\x91a\x06WV[\x14aVQWaU\xF1\x83aU\xECaU\xE5`\x01\x86\x90aG\xEBV[\x87\x90a8\x93V[a)\xA5V[aU\xFBW[PPPV[\x91\x90\x91aVFaV4aV.\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%\x93a\x106V[\x93a\x106V[\x93aV=a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xA3_\x80\x80aU\xF6V[aVtaV]_a)>V[_\x91\x82\x91cJ\x14\x06\xB1`\xE1\x1B\x83R`\x04\x83\x01a\x11\xFEV[\x03\x90\xFD[aV\x9BaV\x84_a)>V[_\x91\x82\x91c\xE6\x02\xDF\x05`\xE0\x1B\x83R`\x04\x83\x01a\x11\xFEV[\x03\x90\xFD[\x91` aV\xC0\x92\x94\x93aV\xB9`@\x82\x01\x96_\x83\x01\x90a\x06cV[\x01\x90a\x0C\x9DV[V[\x90aV\xD7aV\xD1\x83\x83\x90a;\xD1V[\x15a\x05AV[aV\xDFWPPV[aV\xF9_\x92\x83\x92c\xE2Q}?`\xE0\x1B\x84R`\x04\x84\x01aV\x9FV[\x03\x90\xFD[\x91aW\n\x92\x91\x90\x91ag\x13V[V[\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x90V[\x90\x95\x94\x92aW{\x94aWjaWt\x92aW``\x80\x96aWV`\xA0\x88\x01\x9C_\x89\x01\x90a\x0C\x9DV[` \x87\x01\x90a\x0C\x9DV[`@\x85\x01\x90a\x0C\x9DV[``\x83\x01\x90a\x07\xD4V[\x01\x90a\x06cV[V[aW\x85a-\xACV[PaW\x8EaW\x0CV[aX\x05\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91aW\xF6\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0FaW\xE10a:\xA2V[\x91aW\xEAa\x04\xE2V[\x96\x87\x95` \x87\x01aW0V[` \x82\x01\x81\x03\x82R\x03\x82a\x0B\x9AV[aX\x17aX\x11\x82a\x06pV[\x91aEgV[ \x90V[aX/aX*aX4\x92a\x12\xE5V[a\x10\x0BV[a\r\x88V[\x90V[aX@\x90aX\x1BV[\x90RV[\x91` aXe\x92\x94\x93aX^`@\x82\x01\x96_\x83\x01\x90aX7V[\x01\x90a\x07\xD4V[V[aX{aXvaX\x80\x92a\x07-V[a\x10\x0BV[a\x18\xBEV[\x90V[aX\x8Ba;\xFBV[P\x80aX\xA5aX\x9Fe\xFF\xFF\xFF\xFF\xFF\xFFaL\xD5V[\x91a\x07-V[\x11aX\xB6WaX\xB3\x90aXgV[\x90V[`0aX\xD2_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01aXDV[\x03\x90\xFD[\x90V[aX\xEDaX\xE8aX\xF2\x92aX\xD6V[a\x10\x0BV[a\x07-V[\x90V[\x90V[aY\x0CaY\x07aY\x11\x92aX\xF5V[a\x10\x0BV[a\r\x88V[\x90V[aY3\x90aY-aY'aY8\x94a\r\x88V[\x91a\x07-V[\x90a\tMV[a\x07-V[\x90V[\x90V[aYRaYMaYW\x92aY;V[a\x10\x0BV[a\r\x88V[\x90V[aYy\x90aYsaYmaY~\x94a\r\x88V[\x91a\x07-V[\x90a&$V[a\x07-V[\x90V[\x90V[aY\x98aY\x93aY\x9D\x92aY\x81V[a\x10\x0BV[a\x07-V[\x90V[\x90V[aY\xB7aY\xB2aY\xBC\x92aY\xA0V[a\x10\x0BV[a\r\x88V[\x90V[\x90V[aY\xD6aY\xD1aY\xDB\x92aY\xBFV[a\x10\x0BV[a\x07-V[\x90V[\x90V[aY\xF5aY\xF0aY\xFA\x92aY\xDEV[a\x10\x0BV[a\r\x88V[\x90V[\x90V[aZ\x14aZ\x0FaZ\x19\x92aY\xFDV[a\x10\x0BV[a\x07-V[\x90V[\x90V[aZ3aZ.aZ8\x92aZ\x1CV[a\x10\x0BV[a\r\x88V[\x90V[\x90V[aZRaZMaZW\x92aZ;V[a\x10\x0BV[a\x07-V[\x90V[\x90V[aZqaZlaZv\x92aZZV[a\x10\x0BV[a\r\x88V[\x90V[aZ\x8DaZ\x88aZ\x92\x92aY\xDEV[a\x10\x0BV[a\x07-V[\x90V[\x90V[aZ\xACaZ\xA7aZ\xB1\x92aZ\x95V[a\x10\x0BV[a\r\x88V[\x90V[aZ\xC8aZ\xC3aZ\xCD\x92aZZV[a\x10\x0BV[a\x07-V[\x90V[aZ\xE4aZ\xDFaZ\xE9\x92aB\xF6V[a\x10\x0BV[a\r\x88V[\x90V[\x90V[a[\x03aZ\xFEa[\x08\x92aZ\xECV[a\x10\x0BV[a\x07-V[\x90V[\x90a[\x16\x91\x02a\x07-V[\x90V[a[%a[+\x91a\x07-V[\x91a\x07-V[\x90\x81\x15a[6W\x04\x90V[a+\x9FV[\x90a[F\x91\x01a\x07-V[\x90V[a[Qa%\xD5V[P\x80a[fa[``\x01aB\xF9V[\x91a\x07-V[\x11\x15a^\xB1W\x80a]{a]Xa]Ha]8a](a]\x18a]\x08a\\\xF8a\\\xE8a\\\xD8a\\\xC8\x8Ba\\\xC2a\\\xBBa]\x81\x9Fa\\\x9Ba\\\x8Ba\\\xAB\x92a[\xAD`\x01aB\xF9V[\x90\x80a[\xC5a[\xBF`\x01`\x80\x1BaX\xD9V[\x91a\x07-V[\x10\x15a^\x83W[\x80a[\xE8a[\xE2h\x01\0\0\0\0\0\0\0\0aY\x84V[\x91a\x07-V[\x10\x15a^UW[\x80a\\\x07a\\\x01d\x01\0\0\0\0aY\xC2V[\x91a\x07-V[\x10\x15a^'W[\x80a\\$a\\\x1Eb\x01\0\0aZ\0V[\x91a\x07-V[\x10\x15a]\xF9W[\x80a\\@a\\:a\x01\0aZ>V[\x91a\x07-V[\x10\x15a]\xCBW[\x80a\\[a\\U`\x10aZyV[\x91a\x07-V[\x10\x15a]\x9DW[a\\ua\\o`\x04aZ\xB4V[\x91a\x07-V[\x10\x15a]\x84W[a\\\x86`\x03aZ\xEFV[a[\x0BV[a\\\x95`\x01aZ\xD0V[\x90aY\x14V[a\\\xA5\x81\x86a[\x19V[\x90a[;V[a\\\xB5`\x01aZ\xD0V[\x90aY\x14V[\x80\x92a[\x19V[\x90a[;V[a\\\xD2`\x01aZ\xD0V[\x90aY\x14V[a\\\xE2\x81\x8Ca[\x19V[\x90a[;V[a\\\xF2`\x01aZ\xD0V[\x90aY\x14V[a]\x02\x81\x8Aa[\x19V[\x90a[;V[a]\x12`\x01aZ\xD0V[\x90aY\x14V[a]\"\x81\x88a[\x19V[\x90a[;V[a]2`\x01aZ\xD0V[\x90aY\x14V[a]B\x81\x86a[\x19V[\x90a[;V[a]R`\x01aZ\xD0V[\x90aY\x14V[\x91a]ua]oa]j\x85\x80\x94a[\x19V[a\x07-V[\x91a\x07-V[\x11ag\xA3V[\x90aI\x0EV[\x90V[a]\x98\x90a]\x92`\x01aZ\xD0V[\x90aYZV[a\\|V[a]\xB4a]\xC5\x91a]\xAE`\x04aZ]V[\x90aY\x14V[\x91a]\xBF`\x02aZ\x98V[\x90aYZV[\x90a\\bV[a]\xE2a]\xF3\x91a]\xDC`\x08aZ\x1FV[\x90aY\x14V[\x91a]\xED`\x04aZ]V[\x90aYZV[\x90a\\GV[a^\x10a^!\x91a^\n`\x10aY\xE1V[\x90aY\x14V[\x91a^\x1B`\x08aZ\x1FV[\x90aYZV[\x90a\\+V[a^>a^O\x91a^8` aY\xA3V[\x90aY\x14V[\x91a^I`\x10aY\xE1V[\x90aYZV[\x90a\\\x0EV[a^la^}\x91a^f`@aY>V[\x90aY\x14V[\x91a^w` aY\xA3V[\x90aYZV[\x90a[\xEFV[a^\x9Aa^\xAB\x91a^\x94`\x80aX\xF8V[\x90aY\x14V[\x91a^\xA5`@aY>V[\x90aYZV[\x90a[\xCCV[\x90V[_R` _ \x01\x90V[\x93\x91\x90\x92a^\xCAa%\xD5V[P[\x81a^\xDFa^\xD9\x83a\x07-V[\x91a\x07-V[\x10\x15a_EWa^\xF0\x82\x82\x90ag\xCDV[\x90a_\x06_a_\0\x88\x85\x90a^\xB4V[\x01aM\xAFV[a_\x18a_\x12\x87a\x18\xBEV[\x91a\x18\xBEV[\x11_\x14a_(WP\x91[\x91a^\xCCV[\x92\x91Pa_?\x90a_9`\x01aB\xF9V[\x90a.ZV[\x90a_\"V[\x92PP\x91P\x90V[a_^a_Xa7\xA3V[\x15a\x05AV[a_dWV[_c\x8D\xFC +`\xE0\x1B\x81R\x80a_|`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x90a_\x89a%\xD5V[P\x81a_\x9Da_\x97\x83a\x07-V[\x91a\x07-V[\x10_\x14a_\xA9WP[\x90V[\x90Pa_\xA6V[a_\xC2\x90a_\xBCa%\xD5V[Pa8\xA9V[\x90V[\x90V[\x91\x90\x91\x80a_\xDEa_\xD8\x85a\x06WV[\x91a\x06WV[\x14\x15\x80aa\\W[a_\xF0W[PPPV[\x80a`\x0Ba`\x05a`\0_a)>V[a\x06WV[\x91a\x06WV[\x03a`\xCCW[P\x81a`-a`'a`\"_a)>V[a\x06WV[\x91a\x06WV[\x03a`9W[\x80a_\xEBV[a`\x80a`sa`z\x92a`O`\n\x86\x90a4GV[\x90a`ma`ga`a`\x01\x93ahfV[\x93a4]V[\x91a_\xC5V[\x90ah\xB9V[\x92\x90a4`V[\x91a4`V[\x91\x90\x91a`\xAD\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\x106V[\x92a`\xC2a`\xB9a\x04\xE2V[\x92\x83\x92\x83a\n1V[\x03\x90\xA2_\x80a`3V[aa\x0Baa\x11aa\x04a`\xE1`\n\x85\x90a4GV[`\x02a`\xFEa`\xF8a`\xF2\x89ahfV[\x93a4]V[\x91a_\xC5V[\x90ah\xB9V[\x92\x90a4`V[\x91a4`V[\x91\x90\x91aa>\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\x106V[\x92aaSaaJa\x04\xE2V[\x92\x83\x92\x83a\n1V[\x03\x90\xA2_a`\x11V[P\x81aapaaj_a)\x06V[\x91a\x07-V[\x11a_\xE6V[_aa\x8A\x91aa\x83a%\xD5V[P\x01aMjV[\x90V[aa\xA1aa\x9Caa\xA6\x92a\x14\x93V[a\x10\x0BV[a\x07-V[\x90V[aa\xB2\x90aY\xA3V[\x90RV[\x91` aa\xD7\x92\x94\x93aa\xD0`@\x82\x01\x96_\x83\x01\x90aa\xA9V[\x01\x90a\x07\xD4V[V[aa\xEDaa\xE8aa\xF2\x92a\x07-V[a\x10\x0BV[a\x14\x93V[\x90V[aa\xFDa8zV[P\x80ab\x15ab\x0Fc\xFF\xFF\xFF\xFFaa\x8DV[\x91a\x07-V[\x11ab&Wab#\x90aa\xD9V[\x90V[` abB_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01aa\xB6V[\x03\x90\xFD[ab]abb\x91abUa%\xD5V[P`\x08a8\x93V[a\x10qV[\x90V[\x90V[ab|abwab\x81\x92abeV[a\x1BHV[a\x0CYV[\x90V[ab\x8E`\xFFabhV[\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90ab\xB4ab\xAD\x83a\n\xB1V[\x80\x94a$dV[\x91`\x01\x81\x16\x90\x81_\x14ac\x0BWP`\x01\x14ab\xCFW[PPPV[ab\xDC\x91\x92\x93\x94Pab\x91V[\x91_\x92[\x81\x84\x10ab\xF3WPP\x01\x90_\x80\x80ab\xCAV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90ab\xE0V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80ab\xCAV[\x90ac0\x91ab\x9AV[\x90V[\x90acSacL\x92acCa\x04\xE2V[\x93\x84\x80\x92ac&V[\x03\x83a\x0B\x9AV[V[ac^\x90ac3V[\x90V[\x90acja$_V[Pact\x82a-\xB0V[ac\x8Dac\x87ac\x82ab\x84V[a\x0CYV[\x91a\x0CYV[\x14\x15_\x14ac\xA2WPac\x9F\x90aiCV[\x90V[ac\xAC\x91PacUV[\x90V[`B\x91ac\xBAa-\xACV[P`@Q\x91\x7F\x19\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83R`\x02\x83\x01R`\"\x82\x01R \x90V[_\x90V[ad\0ad\x05\x91a\x10XV[a&MV[\x90V[\x90V[ad\x1Fad\x1Aad$\x92ad\x08V[a\x10\x0BV[a\x07-V[\x90V[ad\\adc\x94adR``\x94\x98\x97\x95adH`\x80\x86\x01\x9A_\x87\x01\x90a\x0C\x9DV[` \x85\x01\x90a\r\x8EV[`@\x83\x01\x90a\x0C\x9DV[\x01\x90a\x0C\x9DV[V[\x93\x92\x93adpa%SV[Padyac\xF0V[Pad\x82a-\xACV[Pad\x8C\x85ac\xF4V[ad\xBEad\xB8\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0ad\x0BV[\x91a\x07-V[\x11aeKW\x90ad\xE1` \x94\x95_\x94\x93\x92\x93ad\xD8a\x04\xE2V[\x94\x85\x94\x85ad'V[\x83\x80R\x03\x90`\x01Z\xFA\x15aeFWad\xF9_Qa\x1BHV[\x80ae\x14ae\x0Eae\t_a)>V[a\x06WV[\x91a\x06WV[\x14ae*W_\x91ae$_a\x1BMV[\x91\x92\x91\x90V[Pae4_a)>V[`\x01\x91ae@_a\x1BMV[\x91\x92\x91\x90V[a+\x16V[PPPaeW_a)>V[\x90`\x03\x92\x91\x92\x91\x90V[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x04\x11\x15ae\x7FWV[aeaV[\x90ae\x8E\x82aeuV[V[\x80ae\xA3ae\x9D_ae\x84V[\x91ae\x84V[\x14_\x14ae\xAEWPPV[\x80ae\xC2ae\xBC`\x01ae\x84V[\x91ae\x84V[\x14_\x14ae\xE5W_c\xF6E\xEE\xDF`\xE0\x1B\x81R\x80ae\xE1`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[\x80ae\xF9ae\xF3`\x02ae\x84V[\x91ae\x84V[\x14_\x14af'Waf#af\x0C\x83ac\xF4V[_\x91\x82\x91c\xFC\xE6\x98\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x07\xE1V[\x03\x90\xFD[af:af4`\x03ae\x84V[\x91ae\x84V[\x14afBWPV[af]\x90_\x91\x82\x91c5\xE2\xF3\x83`\xE2\x1B\x83R`\x04\x83\x01a\x0C\xAAV[\x03\x90\xFD[_R` _ \x90V[afs\x81aMjV[\x82\x10\x15af\x8DWaf\x85`\x01\x91afaV[\x91\x02\x01\x90_\x90V[a\x0E\x03V[\x90af\x9C\x90a\x18\xBEV[\x90RV[\x90af\xAA\x90a\"SV[\x90RV[\x90af\xE4af\xDB_af\xBEaH)V[\x94af\xD5af\xCD\x83\x83\x01aM\xAFV[\x83\x88\x01af\x92V[\x01aM\xE1V[` \x84\x01af\xA0V[V[af\xEF\x90af\xAEV[\x90V[ag\x10\x91_ag\n\x92ag\x03aHdV[P\x01afjV[Paf\xE6V[\x90V[\x92\x91ag!\x84\x83\x83\x91aisV[\x83ag<ag6ag1_a)>V[a\x06WV[\x91a\x06WV[\x14agQW[agO\x92\x93\x91\x90\x91aj\xFDV[V[agYa(\xD6V[\x93agbaj\xE2V[\x94\x80agvagp\x88a\x07-V[\x91a\x07-V[\x11ag\x83WP\x93PagBV[\x85\x90ag\x9F_\x92\x83\x92c\x0EX\xAE\x93`\xE1\x1B\x84R`\x04\x84\x01a\n1V[\x03\x90\xFD[ag\xABa%\xD5V[P\x15\x15\x90V[ag\xC5ag\xC0ag\xCA\x92aZ\x95V[a\x10\x0BV[a\x07-V[\x90V[ag\xF2ag\xF8\x92ag\xDCa%\xD5V[P\x82\x81\x16\x92\x18ag\xEC`\x02ag\xB1V[\x90a+\xB3V[\x90a.ZV[\x90V[\x90V[ah\x12ah\rah\x17\x92ag\xFBV[a\x10\x0BV[a\r\x88V[\x90V[ah#\x90ag\xFEV[\x90RV[\x91` ahH\x92\x94\x93ahA`@\x82\x01\x96_\x83\x01\x90ah\x1AV[\x01\x90a\x07\xD4V[V[ah^ahYahc\x92a\x07-V[a\x10\x0BV[a\"SV[\x90V[ahna#\x86V[P\x80ah\x88ah\x82`\x01\x80`\xD0\x1B\x03a4`V[\x91a\x07-V[\x11ah\x99Wah\x96\x90ahJV[\x90V[`\xD0ah\xB5_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01ah'V[\x03\x90\xFD[\x90ah\xEFah\xF5\x93\x92ah\xCAa#\x86V[Pah\xD3a#\x86V[P\x80\x93ah\xE8ah\xE1a;\xFFV[\x94\x92aS\xB7V[\x90\x91aoeV[\x91ak\xBCV[\x91\x90\x91\x90V[ai\x0Fai\nai\x14\x92aY\xA0V[a\x10\x0BV[a\x07-V[\x90V[6\x907V[\x90aiAai)\x83a6zV[\x92` \x80ai7\x86\x93a6WV[\x92\x01\x91\x03\x90ai\x17V[V[aiKa$_V[PaiU\x81al&V[\x90aihaic` ah\xFBV[ai\x1CV[\x91\x82R` \x82\x01R\x90V[\x91\x90\x91\x80ai\x91ai\x8Bai\x86_a)>V[a\x06WV[\x91a\x06WV[\x14_\x14ajrWai\xB5ai\xAE\x83ai\xA9`\x02a\x10qV[a.ZV[`\x02a)\xA5V[[\x82ai\xD1ai\xCBai\xC6_a)>V[a\x06WV[\x91a\x06WV[\x14_\x14ajFWai\xF5ai\xEE\x83ai\xE9`\x02a\x10qV[aI\x0EV[`\x02a)\xA5V[[\x91\x90\x91ajAaj/aj)\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x93a\x106V[\x93a\x106V[\x93aj8a\x04\xE2V[\x91\x82\x91\x82a\x07\xE1V[\x03\x90\xA3V[ajm\x82ajgajX_\x87\x90a8\x93V[\x91ajb\x83a\x10qV[a[;V[\x90a)\xA5V[ai\xF6V[aj\x85aj\x80_\x83\x90a8\x93V[a\x10qV[\x80aj\x98aj\x92\x85a\x07-V[\x91a\x07-V[\x10aj\xC0Waj\xABaj\xBB\x91\x84\x90aI\x0EV[aj\xB6_\x84\x90a8\x93V[a)\xA5V[ai\xB6V[\x90aj\xDE\x90\x91\x92_\x93\x84\x93c9\x144\xE3`\xE2\x1B\x85R`\x04\x85\x01aH\xDCV[\x03\x90\xFD[aj\xEAa%\xD5V[Paj\xFA`\x01\x80`\xD0\x1B\x03a4`V[\x90V[\x91akUakOak\\\x94\x80ak#ak\x1Dak\x18_a)>V[a\x06WV[\x91a\x06WV[\x14ak\x8DW[\x84akDak>ak9_a)>V[a\x06WV[\x91a\x06WV[\x14ak^W[a7HV[\x92a7HV[\x90\x91a_\xC8V[V[ak\x86`\x0B`\x02ak\x80akzakt\x89ahfV[\x93a4]V[\x91a_\xC5V[\x90ah\xB9V[PPakJV[ak\xB5`\x0B`\x01ak\xAFak\xA9ak\xA3\x89ahfV[\x93a4]V[\x91a_\xC5V[\x90ah\xB9V[PPak)V[\x91ak\xE0_ak\xE5\x94ak\xCDa#\x86V[Pak\xD6a#\x86V[P\x01\x92\x91\x92aM\x8DV[an\x17V[\x91\x90\x91\x90V[ak\xFFak\xFAal\x04\x92abeV[a\x10\x0BV[a\x07-V[\x90V[\x90V[al\x1Eal\x19al#\x92al\x07V[a\x10\x0BV[a\x07-V[\x90V[al;al@\x91al5a%\xD5V[Pa-\xB0V[ac\xF4V[alJ`\xFFak\xEBV[\x16\x80al_alY`\x1Fal\nV[\x91a\x07-V[\x11algW\x90V[_c,\xD4J\xC3`\xE2\x1B\x81R\x80al\x7F`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[T\x90V[al\x91`@a6BV[\x90V[_R` _ \x90V[al\xA6\x81al\x83V[\x82\x10\x15al\xC0Wal\xB8`\x01\x91al\x94V[\x91\x02\x01\x90_\x90V[a\x0E\x03V[al\xCF\x90Qa\x18\xBEV[\x90V[\x90al\xE3e\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x1BHV[\x91\x81\x19\x16\x91\x16\x17\x90V[am\x01al\xFCam\x06\x92a\x18\xBEV[a\x10\x0BV[a\x18\xBEV[\x90V[\x90V[\x90am!am\x1Cam(\x92al\xEDV[am\tV[\x82Tal\xD2V[\x90UV[am6\x90Qa\"SV[\x90V[`0\x1B\x90V[\x90amQe\xFF\xFF\xFF\xFF\xFF\xFF\x19\x91am9V[\x91\x81\x19\x16\x91\x16\x17\x90V[amoamjamt\x92a\"SV[a\x10\x0BV[a\"SV[\x90V[\x90V[\x90am\x8Fam\x8Aam\x96\x92am[V[amwV[\x82Tam?V[\x90UV[\x90am\xC4` _am\xCA\x94am\xBC\x82\x82\x01am\xB6\x84\x88\x01al\xC5V[\x90am\x0CV[\x01\x92\x01am,V[\x90amzV[V[\x91\x90am\xDDWam\xDB\x91am\x9AV[V[a\n\x8AV[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15an\x12W\x82an\n\x91`\x01an\x10\x95\x01\x81Ual\x9DV[\x90am\xCCV[V[a\x0B\x86V[\x90\x92\x91\x92an#a#\x86V[Pan,a#\x86V[Pan6\x82al\x83V[\x80anIanC_a)\x06V[\x91a\x07-V[\x11_\x14ao\x19Wano\x90ani\x84\x91anc`\x01aB\xF9V[\x90a+&V[\x90a^\xB4V[\x90an{_\x83\x01aM\xAFV[\x92an\x87_\x84\x01aM\xE1V[\x93\x80an\x9Ban\x95\x85a\x18\xBEV[\x91a\x18\xBEV[\x11an\xFDWan\xB2an\xAC\x84a\x18\xBEV[\x91a\x18\xBEV[\x14_\x14an\xCDWPPan\xC8\x90_\x85\x91\x01amzV[[\x91\x90V[an\xF8\x92Pan\xF3\x86an\xEAan\xE1al\x87V[\x94_\x86\x01af\x92V[` \x84\x01af\xA0V[am\xE2V[an\xC9V[_c% `\x1D`\xE0\x1B\x81R\x80ao\x15`\x04\x82\x01a\x08\xACV[\x03\x90\xFD[PaoD\x91ao?\x85ao6ao-al\x87V[\x94_\x86\x01af\x92V[` \x84\x01af\xA0V[am\xE2V[aoM_aM\xEEV[\x91\x90V[cNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[\x91\x90\x91\x80`\x01\x14ao\x84W`\x02\x03aoQWao\x80\x91a$\x05V[\x90[V[Pao\x8E\x91a#\xC6V[\x90ao\x82V",
    );
    /**Custom error with signature `AccessControlBadConfirmation()` and selector `0x6697b232`.
```solidity
error AccessControlBadConfirmation();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlBadConfirmation {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlBadConfirmation>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlBadConfirmation) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlBadConfirmation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlBadConfirmation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlBadConfirmation()";
            const SELECTOR: [u8; 4] = [102u8, 151u8, 178u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `AccessControlUnauthorizedAccount(address,bytes32)` and selector `0xe2517d3f`.
```solidity
error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub neededRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlUnauthorizedAccount) -> Self {
                (value.account, value.neededRole)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    neededRole: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlUnauthorizedAccount(address,bytes32)";
            const SELECTOR: [u8; 4] = [226u8, 81u8, 125u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.neededRole),
                )
            }
        }
    };
    /**Custom error with signature `AllEmissionsCompleted()` and selector `0x4555892c`.
```solidity
error AllEmissionsCompleted();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AllEmissionsCompleted {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AllEmissionsCompleted> for UnderlyingRustTuple<'_> {
            fn from(value: AllEmissionsCompleted) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AllEmissionsCompleted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AllEmissionsCompleted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AllEmissionsCompleted()";
            const SELECTOR: [u8; 4] = [69u8, 85u8, 137u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `BridgeNotAuthorized()` and selector `0x882eec12`.
```solidity
error BridgeNotAuthorized();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BridgeNotAuthorized {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BridgeNotAuthorized> for UnderlyingRustTuple<'_> {
            fn from(value: BridgeNotAuthorized) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BridgeNotAuthorized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BridgeNotAuthorized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BridgeNotAuthorized()";
            const SELECTOR: [u8; 4] = [136u8, 46u8, 236u8, 18u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `BridgeNotConfigured()` and selector `0x7614917a`.
```solidity
error BridgeNotConfigured();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BridgeNotConfigured {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BridgeNotConfigured> for UnderlyingRustTuple<'_> {
            fn from(value: BridgeNotConfigured) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BridgeNotConfigured {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BridgeNotConfigured {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BridgeNotConfigured()";
            const SELECTOR: [u8; 4] = [118u8, 20u8, 145u8, 122u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `CheckpointUnorderedInsertion()` and selector `0x2520601d`.
```solidity
error CheckpointUnorderedInsertion();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CheckpointUnorderedInsertion {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CheckpointUnorderedInsertion>
        for UnderlyingRustTuple<'_> {
            fn from(value: CheckpointUnorderedInsertion) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for CheckpointUnorderedInsertion {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CheckpointUnorderedInsertion {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CheckpointUnorderedInsertion()";
            const SELECTOR: [u8; 4] = [37u8, 32u8, 96u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignature()` and selector `0xf645eedf`.
```solidity
error ECDSAInvalidSignature();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignature {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignature> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignature) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignature()";
            const SELECTOR: [u8; 4] = [246u8, 69u8, 238u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureLength(uint256)` and selector `0xfce698f7`.
```solidity
error ECDSAInvalidSignatureLength(uint256 length);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureLength {
        #[allow(missing_docs)]
        pub length: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureLength>
        for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureLength) -> Self {
                (value.length,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ECDSAInvalidSignatureLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { length: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureLength(uint256)";
            const SELECTOR: [u8; 4] = [252u8, 230u8, 152u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.length),
                )
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureS(bytes32)` and selector `0xd78bce0c`.
```solidity
error ECDSAInvalidSignatureS(bytes32 s);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureS {
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureS> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureS) -> Self {
                (value.s,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignatureS {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { s: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureS {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureS(bytes32)";
            const SELECTOR: [u8; 4] = [215u8, 139u8, 206u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
        }
    };
    /**Custom error with signature `ERC20ExceededSafeSupply(uint256,uint256)` and selector `0x1cb15d26`.
```solidity
error ERC20ExceededSafeSupply(uint256 increasedSupply, uint256 cap);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20ExceededSafeSupply {
        #[allow(missing_docs)]
        pub increasedSupply: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub cap: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20ExceededSafeSupply> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20ExceededSafeSupply) -> Self {
                (value.increasedSupply, value.cap)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20ExceededSafeSupply {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    increasedSupply: tuple.0,
                    cap: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20ExceededSafeSupply {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20ExceededSafeSupply(uint256,uint256)";
            const SELECTOR: [u8; 4] = [28u8, 177u8, 93u8, 38u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.increasedSupply),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.cap),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InsufficientAllowance(address,uint256,uint256)` and selector `0xfb8f41b2`.
```solidity
error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InsufficientAllowance {
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub allowance: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub needed: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InsufficientAllowance>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InsufficientAllowance) -> Self {
                (value.spender, value.allowance, value.needed)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC20InsufficientAllowance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    spender: tuple.0,
                    allowance: tuple.1,
                    needed: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InsufficientAllowance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InsufficientAllowance(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [251u8, 143u8, 65u8, 178u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allowance),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.needed),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InsufficientBalance(address,uint256,uint256)` and selector `0xe450d38c`.
```solidity
error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InsufficientBalance {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub balance: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub needed: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InsufficientBalance>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InsufficientBalance) -> Self {
                (value.sender, value.balance, value.needed)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC20InsufficientBalance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    sender: tuple.0,
                    balance: tuple.1,
                    needed: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InsufficientBalance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InsufficientBalance(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [228u8, 80u8, 211u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.balance),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.needed),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidApprover(address)` and selector `0xe602df05`.
```solidity
error ERC20InvalidApprover(address approver);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidApprover {
        #[allow(missing_docs)]
        pub approver: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidApprover> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidApprover) -> Self {
                (value.approver,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidApprover {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { approver: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidApprover {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidApprover(address)";
            const SELECTOR: [u8; 4] = [230u8, 2u8, 223u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.approver,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidReceiver(address)` and selector `0xec442f05`.
```solidity
error ERC20InvalidReceiver(address receiver);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidReceiver {
        #[allow(missing_docs)]
        pub receiver: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidReceiver> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidReceiver) -> Self {
                (value.receiver,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidReceiver {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { receiver: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidReceiver {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidReceiver(address)";
            const SELECTOR: [u8; 4] = [236u8, 68u8, 47u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.receiver,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidSender(address)` and selector `0x96c6fd1e`.
```solidity
error ERC20InvalidSender(address sender);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidSender {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidSender> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidSender) -> Self {
                (value.sender,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidSender {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { sender: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidSender {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidSender(address)";
            const SELECTOR: [u8; 4] = [150u8, 198u8, 253u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidSpender(address)` and selector `0x94280d62`.
```solidity
error ERC20InvalidSpender(address spender);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidSpender {
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidSpender> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidSpender) -> Self {
                (value.spender,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidSpender {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { spender: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidSpender {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidSpender(address)";
            const SELECTOR: [u8; 4] = [148u8, 40u8, 13u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC2612ExpiredSignature(uint256)` and selector `0x62791302`.
```solidity
error ERC2612ExpiredSignature(uint256 deadline);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC2612ExpiredSignature {
        #[allow(missing_docs)]
        pub deadline: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC2612ExpiredSignature> for UnderlyingRustTuple<'_> {
            fn from(value: ERC2612ExpiredSignature) -> Self {
                (value.deadline,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC2612ExpiredSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { deadline: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC2612ExpiredSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC2612ExpiredSignature(uint256)";
            const SELECTOR: [u8; 4] = [98u8, 121u8, 19u8, 2u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.deadline),
                )
            }
        }
    };
    /**Custom error with signature `ERC2612InvalidSigner(address,address)` and selector `0x4b800e46`.
```solidity
error ERC2612InvalidSigner(address signer, address owner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC2612InvalidSigner {
        #[allow(missing_docs)]
        pub signer: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC2612InvalidSigner> for UnderlyingRustTuple<'_> {
            fn from(value: ERC2612InvalidSigner) -> Self {
                (value.signer, value.owner)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC2612InvalidSigner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    signer: tuple.0,
                    owner: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC2612InvalidSigner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC2612InvalidSigner(address,address)";
            const SELECTOR: [u8; 4] = [75u8, 128u8, 14u8, 70u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signer,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC5805FutureLookup(uint256,uint48)` and selector `0xecd3f81e`.
```solidity
error ERC5805FutureLookup(uint256 timepoint, uint48 clock);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC5805FutureLookup {
        #[allow(missing_docs)]
        pub timepoint: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub clock: alloy::sol_types::private::primitives::aliases::U48,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<48>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U48,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC5805FutureLookup> for UnderlyingRustTuple<'_> {
            fn from(value: ERC5805FutureLookup) -> Self {
                (value.timepoint, value.clock)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC5805FutureLookup {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    timepoint: tuple.0,
                    clock: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC5805FutureLookup {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC5805FutureLookup(uint256,uint48)";
            const SELECTOR: [u8; 4] = [236u8, 211u8, 248u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.timepoint),
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(&self.clock),
                )
            }
        }
    };
    /**Custom error with signature `ERC6372InconsistentClock()` and selector `0x6ff07140`.
```solidity
error ERC6372InconsistentClock();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC6372InconsistentClock {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC6372InconsistentClock>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC6372InconsistentClock) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC6372InconsistentClock {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC6372InconsistentClock {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC6372InconsistentClock()";
            const SELECTOR: [u8; 4] = [111u8, 240u8, 113u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmissionsAlreadyStarted()` and selector `0x71d27b7a`.
```solidity
error EmissionsAlreadyStarted();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmissionsAlreadyStarted {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmissionsAlreadyStarted> for UnderlyingRustTuple<'_> {
            fn from(value: EmissionsAlreadyStarted) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmissionsAlreadyStarted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmissionsAlreadyStarted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmissionsAlreadyStarted()";
            const SELECTOR: [u8; 4] = [113u8, 210u8, 123u8, 122u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmissionsNotActive()` and selector `0x66bf2674`.
```solidity
error EmissionsNotActive();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmissionsNotActive {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmissionsNotActive> for UnderlyingRustTuple<'_> {
            fn from(value: EmissionsNotActive) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmissionsNotActive {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmissionsNotActive {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmissionsNotActive()";
            const SELECTOR: [u8; 4] = [102u8, 191u8, 38u8, 116u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmissionsNotStarted()` and selector `0x8f984041`.
```solidity
error EmissionsNotStarted();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmissionsNotStarted {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmissionsNotStarted> for UnderlyingRustTuple<'_> {
            fn from(value: EmissionsNotStarted) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmissionsNotStarted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmissionsNotStarted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmissionsNotStarted()";
            const SELECTOR: [u8; 4] = [143u8, 152u8, 64u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EnforcedPause()` and selector `0xd93c0665`.
```solidity
error EnforcedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EnforcedPause {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EnforcedPause> for UnderlyingRustTuple<'_> {
            fn from(value: EnforcedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EnforcedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EnforcedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EnforcedPause()";
            const SELECTOR: [u8; 4] = [217u8, 60u8, 6u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EpochAlreadyMinted()` and selector `0xe085d22b`.
```solidity
error EpochAlreadyMinted();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EpochAlreadyMinted {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EpochAlreadyMinted> for UnderlyingRustTuple<'_> {
            fn from(value: EpochAlreadyMinted) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EpochAlreadyMinted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EpochAlreadyMinted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EpochAlreadyMinted()";
            const SELECTOR: [u8; 4] = [224u8, 133u8, 210u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ExceedsEmissionsSupply()` and selector `0x23064ebd`.
```solidity
error ExceedsEmissionsSupply();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExceedsEmissionsSupply {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExceedsEmissionsSupply> for UnderlyingRustTuple<'_> {
            fn from(value: ExceedsEmissionsSupply) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ExceedsEmissionsSupply {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ExceedsEmissionsSupply {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ExceedsEmissionsSupply()";
            const SELECTOR: [u8; 4] = [35u8, 6u8, 78u8, 189u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ExpectedPause()` and selector `0x8dfc202b`.
```solidity
error ExpectedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExpectedPause {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExpectedPause> for UnderlyingRustTuple<'_> {
            fn from(value: ExpectedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ExpectedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ExpectedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ExpectedPause()";
            const SELECTOR: [u8; 4] = [141u8, 252u8, 32u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InsufficientLimit()` and selector `0x72567b64`.
```solidity
error InsufficientLimit();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientLimit {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientLimit> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientLimit) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientLimit {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientLimit {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientLimit()";
            const SELECTOR: [u8; 4] = [114u8, 86u8, 123u8, 100u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidAccountNonce(address,uint256)` and selector `0x752d88c0`.
```solidity
error InvalidAccountNonce(address account, uint256 currentNonce);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidAccountNonce {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub currentNonce: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidAccountNonce> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidAccountNonce) -> Self {
                (value.account, value.currentNonce)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidAccountNonce {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    currentNonce: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidAccountNonce {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidAccountNonce(address,uint256)";
            const SELECTOR: [u8; 4] = [117u8, 45u8, 136u8, 192u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.currentNonce),
                )
            }
        }
    };
    /**Custom error with signature `InvalidEpoch()` and selector `0xd5b25b63`.
```solidity
error InvalidEpoch();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidEpoch {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidEpoch> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidEpoch) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidEpoch {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidEpoch {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidEpoch()";
            const SELECTOR: [u8; 4] = [213u8, 178u8, 91u8, 99u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidShortString()` and selector `0xb3512b0c`.
```solidity
error InvalidShortString();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidShortString {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidShortString> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidShortString) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidShortString {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidShortString {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidShortString()";
            const SELECTOR: [u8; 4] = [179u8, 81u8, 43u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `SafeCastOverflowedUintDowncast(uint8,uint256)` and selector `0x6dfcc650`.
```solidity
error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SafeCastOverflowedUintDowncast {
        #[allow(missing_docs)]
        pub bits: u8,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            u8,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SafeCastOverflowedUintDowncast>
        for UnderlyingRustTuple<'_> {
            fn from(value: SafeCastOverflowedUintDowncast) -> Self {
                (value.bits, value.value)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SafeCastOverflowedUintDowncast {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    bits: tuple.0,
                    value: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SafeCastOverflowedUintDowncast {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SafeCastOverflowedUintDowncast(uint8,uint256)";
            const SELECTOR: [u8; 4] = [109u8, 252u8, 198u8, 80u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.bits),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
        }
    };
    /**Custom error with signature `StringTooLong(string)` and selector `0x305a27a9`.
```solidity
error StringTooLong(string str);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct StringTooLong {
        #[allow(missing_docs)]
        pub str: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<StringTooLong> for UnderlyingRustTuple<'_> {
            fn from(value: StringTooLong) -> Self {
                (value.str,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for StringTooLong {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { str: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for StringTooLong {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "StringTooLong(string)";
            const SELECTOR: [u8; 4] = [48u8, 90u8, 39u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.str,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `VotesExpiredSignature(uint256)` and selector `0x4683af0e`.
```solidity
error VotesExpiredSignature(uint256 expiry);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct VotesExpiredSignature {
        #[allow(missing_docs)]
        pub expiry: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<VotesExpiredSignature> for UnderlyingRustTuple<'_> {
            fn from(value: VotesExpiredSignature) -> Self {
                (value.expiry,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for VotesExpiredSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { expiry: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for VotesExpiredSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "VotesExpiredSignature(uint256)";
            const SELECTOR: [u8; 4] = [70u8, 131u8, 175u8, 14u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expiry),
                )
            }
        }
    };
    /**Custom error with signature `ZeroAddress()` and selector `0xd92e233d`.
```solidity
error ZeroAddress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAddress {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAddress> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAddress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAddress()";
            const SELECTOR: [u8; 4] = [217u8, 46u8, 35u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ZeroAmount()` and selector `0x1f2a2005`.
```solidity
error ZeroAmount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAmount {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAmount> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAmount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAmount()";
            const SELECTOR: [u8; 4] = [31u8, 42u8, 32u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ZeroGasLimit()` and selector `0x3e267f95`.
```solidity
error ZeroGasLimit();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroGasLimit {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroGasLimit> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroGasLimit) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroGasLimit {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroGasLimit {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroGasLimit()";
            const SELECTOR: [u8; 4] = [62u8, 38u8, 127u8, 149u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Event with signature `Approval(address,address,uint256)` and selector `0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925`.
```solidity
event Approval(address indexed owner, address indexed spender, uint256 value);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Approval {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Approval {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Approval(address,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                140u8,
                91u8,
                225u8,
                229u8,
                235u8,
                236u8,
                125u8,
                91u8,
                209u8,
                79u8,
                113u8,
                66u8,
                125u8,
                30u8,
                132u8,
                243u8,
                221u8,
                3u8,
                20u8,
                192u8,
                247u8,
                178u8,
                41u8,
                30u8,
                91u8,
                32u8,
                10u8,
                200u8,
                199u8,
                195u8,
                185u8,
                37u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    owner: topics.1,
                    spender: topics.2,
                    value: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.owner.clone(), self.spender.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.owner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.spender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Approval {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Approval> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Approval) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeAuthorized(address)` and selector `0x6cf28439a2daab1b265097227212a5b71e0a76f9ed85e3f815b5a6c3e218eb7f`.
```solidity
event BridgeAuthorized(address indexed bridge);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeAuthorized {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeAuthorized {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeAuthorized(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                108u8,
                242u8,
                132u8,
                57u8,
                162u8,
                218u8,
                171u8,
                27u8,
                38u8,
                80u8,
                151u8,
                34u8,
                114u8,
                18u8,
                165u8,
                183u8,
                30u8,
                10u8,
                118u8,
                249u8,
                237u8,
                133u8,
                227u8,
                248u8,
                21u8,
                181u8,
                166u8,
                195u8,
                226u8,
                24u8,
                235u8,
                127u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { bridge: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.bridge.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridge,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeAuthorized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeAuthorized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeAuthorized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeDataUpdated(bytes,bytes)` and selector `0xb9a2088426f03b30a81c06428094fbfa9e2692739b3241af6b9ab1da4b5546be`.
```solidity
event BridgeDataUpdated(bytes oldData, bytes newData);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeDataUpdated {
        #[allow(missing_docs)]
        pub oldData: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub newData: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeDataUpdated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Bytes,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "BridgeDataUpdated(bytes,bytes)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                185u8,
                162u8,
                8u8,
                132u8,
                38u8,
                240u8,
                59u8,
                48u8,
                168u8,
                28u8,
                6u8,
                66u8,
                128u8,
                148u8,
                251u8,
                250u8,
                158u8,
                38u8,
                146u8,
                115u8,
                155u8,
                50u8,
                65u8,
                175u8,
                107u8,
                154u8,
                177u8,
                218u8,
                75u8,
                85u8,
                70u8,
                190u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldData: data.0,
                    newData: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.oldData,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.newData,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeDataUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeDataUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeDataUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeDeauthorized(address)` and selector `0x02c2f0ba15b03f88b18f4832609a18cf35fc6b3f4546a9992076d7453d1334a8`.
```solidity
event BridgeDeauthorized(address indexed bridge);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeDeauthorized {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeDeauthorized {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeDeauthorized(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                2u8,
                194u8,
                240u8,
                186u8,
                21u8,
                176u8,
                63u8,
                136u8,
                177u8,
                143u8,
                72u8,
                50u8,
                96u8,
                154u8,
                24u8,
                207u8,
                53u8,
                252u8,
                107u8,
                63u8,
                69u8,
                70u8,
                169u8,
                153u8,
                32u8,
                118u8,
                215u8,
                69u8,
                61u8,
                19u8,
                52u8,
                168u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { bridge: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.bridge.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridge,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeDeauthorized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeDeauthorized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeDeauthorized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeLimitsSet(address,uint256,uint256)` and selector `0xaa807d0abf30d91968c7478c66b6d82521a106af13eda036e2036da9af168958`.
```solidity
event BridgeLimitsSet(address indexed bridge, uint256 mintingLimit, uint256 burningLimit);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeLimitsSet {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub mintingLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub burningLimit: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeLimitsSet {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeLimitsSet(address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                170u8,
                128u8,
                125u8,
                10u8,
                191u8,
                48u8,
                217u8,
                25u8,
                104u8,
                199u8,
                71u8,
                140u8,
                102u8,
                182u8,
                216u8,
                37u8,
                33u8,
                161u8,
                6u8,
                175u8,
                19u8,
                237u8,
                160u8,
                54u8,
                226u8,
                3u8,
                109u8,
                169u8,
                175u8,
                22u8,
                137u8,
                88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    bridge: topics.1,
                    mintingLimit: data.0,
                    burningLimit: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.mintingLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.burningLimit),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.bridge.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridge,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeLimitsSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeLimitsSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeLimitsSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeProxyUpdated(address,address)` and selector `0x07015b6a9f05913148fd5faddf2acc9708f305937f3072ca2b4b46faa5d0898b`.
```solidity
event BridgeProxyUpdated(address indexed oldProxy, address indexed newProxy);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeProxyUpdated {
        #[allow(missing_docs)]
        pub oldProxy: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newProxy: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeProxyUpdated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeProxyUpdated(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                7u8,
                1u8,
                91u8,
                106u8,
                159u8,
                5u8,
                145u8,
                49u8,
                72u8,
                253u8,
                95u8,
                173u8,
                223u8,
                42u8,
                204u8,
                151u8,
                8u8,
                243u8,
                5u8,
                147u8,
                127u8,
                48u8,
                114u8,
                202u8,
                43u8,
                75u8,
                70u8,
                250u8,
                165u8,
                208u8,
                137u8,
                139u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldProxy: topics.1,
                    newProxy: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.oldProxy.clone(),
                    self.newProxy.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.oldProxy,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newProxy,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeProxyUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeProxyUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeProxyUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `DelegateChanged(address,address,address)` and selector `0x3134e8a2e6d97e929a7e54011ea5485d7d196dd5f0ba4d4ef95803e8e3fc257f`.
```solidity
event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DelegateChanged {
        #[allow(missing_docs)]
        pub delegator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub fromDelegate: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub toDelegate: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DelegateChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "DelegateChanged(address,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                49u8,
                52u8,
                232u8,
                162u8,
                230u8,
                217u8,
                126u8,
                146u8,
                154u8,
                126u8,
                84u8,
                1u8,
                30u8,
                165u8,
                72u8,
                93u8,
                125u8,
                25u8,
                109u8,
                213u8,
                240u8,
                186u8,
                77u8,
                78u8,
                249u8,
                88u8,
                3u8,
                232u8,
                227u8,
                252u8,
                37u8,
                127u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    delegator: topics.1,
                    fromDelegate: topics.2,
                    toDelegate: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.delegator.clone(),
                    self.fromDelegate.clone(),
                    self.toDelegate.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.delegator,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.fromDelegate,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.toDelegate,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DelegateChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DelegateChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &DelegateChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `DelegateVotesChanged(address,uint256,uint256)` and selector `0xdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a724`.
```solidity
event DelegateVotesChanged(address indexed delegate, uint256 previousVotes, uint256 newVotes);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DelegateVotesChanged {
        #[allow(missing_docs)]
        pub delegate: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub previousVotes: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub newVotes: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DelegateVotesChanged {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "DelegateVotesChanged(address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                222u8,
                194u8,
                186u8,
                205u8,
                210u8,
                240u8,
                91u8,
                89u8,
                222u8,
                52u8,
                218u8,
                155u8,
                82u8,
                61u8,
                255u8,
                139u8,
                228u8,
                46u8,
                94u8,
                56u8,
                232u8,
                24u8,
                200u8,
                47u8,
                219u8,
                11u8,
                174u8,
                119u8,
                67u8,
                135u8,
                167u8,
                36u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    delegate: topics.1,
                    previousVotes: data.0,
                    newVotes: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.previousVotes),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newVotes),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.delegate.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.delegate,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DelegateVotesChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DelegateVotesChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &DelegateVotesChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EIP712DomainChanged()` and selector `0x0a6387c9ea3628b88a633bb4f3b151770f70085117a15f9bf3787cda53f13d31`.
```solidity
event EIP712DomainChanged();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EIP712DomainChanged {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EIP712DomainChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "EIP712DomainChanged()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                10u8,
                99u8,
                135u8,
                201u8,
                234u8,
                54u8,
                40u8,
                184u8,
                138u8,
                99u8,
                59u8,
                180u8,
                243u8,
                177u8,
                81u8,
                119u8,
                15u8,
                112u8,
                8u8,
                81u8,
                23u8,
                161u8,
                95u8,
                155u8,
                243u8,
                120u8,
                124u8,
                218u8,
                83u8,
                241u8,
                61u8,
                49u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EIP712DomainChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EIP712DomainChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EIP712DomainChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EmissionMinted(uint256,uint256,address)` and selector `0x34b73d0c96e9ff4d5311434817c8ecc930e7d2782c5bde2e79dc44b0596755bb`.
```solidity
event EmissionMinted(uint256 epoch, uint256 amount, address indexed destination);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EmissionMinted {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub destination: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EmissionMinted {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "EmissionMinted(uint256,uint256,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                52u8,
                183u8,
                61u8,
                12u8,
                150u8,
                233u8,
                255u8,
                77u8,
                83u8,
                17u8,
                67u8,
                72u8,
                23u8,
                200u8,
                236u8,
                201u8,
                48u8,
                231u8,
                210u8,
                120u8,
                44u8,
                91u8,
                222u8,
                46u8,
                121u8,
                220u8,
                68u8,
                176u8,
                89u8,
                103u8,
                85u8,
                187u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    epoch: data.0,
                    amount: data.1,
                    destination: topics.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epoch),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.destination.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.destination,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EmissionMinted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EmissionMinted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EmissionMinted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EmissionsPaused()` and selector `0x73a5fc60aafeec8f139af22d98e62140e2ce914d1f155c692b427757c3e4014c`.
```solidity
event EmissionsPaused();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EmissionsPaused {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EmissionsPaused {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "EmissionsPaused()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                115u8,
                165u8,
                252u8,
                96u8,
                170u8,
                254u8,
                236u8,
                143u8,
                19u8,
                154u8,
                242u8,
                45u8,
                152u8,
                230u8,
                33u8,
                64u8,
                226u8,
                206u8,
                145u8,
                77u8,
                31u8,
                21u8,
                92u8,
                105u8,
                43u8,
                66u8,
                119u8,
                87u8,
                195u8,
                228u8,
                1u8,
                76u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EmissionsPaused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EmissionsPaused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EmissionsPaused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EmissionsResumed()` and selector `0x4a792a0be42b5672faa40129fc6469072490775ca8d3c34e852d4d55d3a735a9`.
```solidity
event EmissionsResumed();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EmissionsResumed {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EmissionsResumed {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "EmissionsResumed()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                74u8,
                121u8,
                42u8,
                11u8,
                228u8,
                43u8,
                86u8,
                114u8,
                250u8,
                164u8,
                1u8,
                41u8,
                252u8,
                100u8,
                105u8,
                7u8,
                36u8,
                144u8,
                119u8,
                92u8,
                168u8,
                211u8,
                195u8,
                78u8,
                133u8,
                45u8,
                77u8,
                85u8,
                211u8,
                167u8,
                53u8,
                169u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EmissionsResumed {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EmissionsResumed> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EmissionsResumed) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EmissionsStarted(uint256)` and selector `0x1194b034cfa9ab5807494a1d5c667d8b0e6e97f38888742aa3871a3220341160`.
```solidity
event EmissionsStarted(uint256 startTime);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EmissionsStarted {
        #[allow(missing_docs)]
        pub startTime: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EmissionsStarted {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "EmissionsStarted(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                17u8,
                148u8,
                176u8,
                52u8,
                207u8,
                169u8,
                171u8,
                88u8,
                7u8,
                73u8,
                74u8,
                29u8,
                92u8,
                102u8,
                125u8,
                139u8,
                14u8,
                110u8,
                151u8,
                243u8,
                136u8,
                136u8,
                116u8,
                42u8,
                163u8,
                135u8,
                26u8,
                50u8,
                32u8,
                52u8,
                17u8,
                96u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { startTime: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.startTime),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EmissionsStarted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EmissionsStarted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EmissionsStarted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Paused(address)` and selector `0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258`.
```solidity
event Paused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Paused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Paused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Paused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                98u8,
                231u8,
                140u8,
                234u8,
                1u8,
                190u8,
                227u8,
                32u8,
                205u8,
                78u8,
                66u8,
                2u8,
                112u8,
                181u8,
                234u8,
                116u8,
                0u8,
                13u8,
                17u8,
                176u8,
                201u8,
                247u8,
                71u8,
                84u8,
                235u8,
                219u8,
                252u8,
                84u8,
                75u8,
                5u8,
                162u8,
                88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Paused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Paused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Paused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleAdminChanged(bytes32,bytes32,bytes32)` and selector `0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff`.
```solidity
event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleAdminChanged {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub previousAdminRole: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newAdminRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleAdminChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "RoleAdminChanged(bytes32,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    previousAdminRole: topics.2,
                    newAdminRole: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.previousAdminRole.clone(),
                    self.newAdminRole.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.previousAdminRole);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newAdminRole);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleAdminChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleAdminChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleAdminChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleGranted(bytes32,address,address)` and selector `0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d`.
```solidity
event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleGranted {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleGranted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleGranted(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleGranted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleGranted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleGranted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleRevoked(bytes32,address,address)` and selector `0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b`.
```solidity
event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleRevoked {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleRevoked(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Transfer(address,address,uint256)` and selector `0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef`.
```solidity
event Transfer(address indexed from, address indexed to, uint256 value);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Transfer {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Transfer {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Transfer(address,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                221u8,
                242u8,
                82u8,
                173u8,
                27u8,
                226u8,
                200u8,
                155u8,
                105u8,
                194u8,
                176u8,
                104u8,
                252u8,
                55u8,
                141u8,
                170u8,
                149u8,
                43u8,
                167u8,
                241u8,
                99u8,
                196u8,
                161u8,
                22u8,
                40u8,
                245u8,
                90u8,
                77u8,
                245u8,
                35u8,
                179u8,
                239u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    from: topics.1,
                    to: topics.2,
                    value: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.from.clone(), self.to.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.from,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.to,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Transfer {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Transfer> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Transfer) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Unpaused(address)` and selector `0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa`.
```solidity
event Unpaused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Unpaused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Unpaused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Unpaused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                93u8,
                185u8,
                238u8,
                10u8,
                73u8,
                91u8,
                242u8,
                230u8,
                255u8,
                156u8,
                145u8,
                167u8,
                131u8,
                76u8,
                27u8,
                164u8,
                253u8,
                210u8,
                68u8,
                165u8,
                232u8,
                170u8,
                78u8,
                83u8,
                123u8,
                211u8,
                138u8,
                234u8,
                228u8,
                176u8,
                115u8,
                170u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Unpaused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Unpaused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Unpaused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address defaultAdmin, address syndFoundationAddress, address emissionsManager, address pauser);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub defaultAdmin: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub syndFoundationAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub emissionsManager: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub pauser: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (
                        value.defaultAdmin,
                        value.syndFoundationAddress,
                        value.emissionsManager,
                        value.pauser,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        defaultAdmin: tuple.0,
                        syndFoundationAddress: tuple.1,
                        emissionsManager: tuple.2,
                        pauser: tuple.3,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.defaultAdmin,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.syndFoundationAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.emissionsManager,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.pauser,
                    ),
                )
            }
        }
    };
    /**Function with signature `BRIDGE_LIMIT_DURATION()` and selector `0x99127d9b`.
```solidity
function BRIDGE_LIMIT_DURATION() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_LIMIT_DURATIONCall {}
    ///Container type for the return parameters of the [`BRIDGE_LIMIT_DURATION()`](BRIDGE_LIMIT_DURATIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_LIMIT_DURATIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_LIMIT_DURATIONCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_LIMIT_DURATIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_LIMIT_DURATIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_LIMIT_DURATIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_LIMIT_DURATIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_LIMIT_DURATIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for BRIDGE_LIMIT_DURATIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = BRIDGE_LIMIT_DURATIONReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BRIDGE_LIMIT_DURATION()";
            const SELECTOR: [u8; 4] = [153u8, 18u8, 125u8, 155u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `BRIDGE_MANAGER_ROLE()` and selector `0xf75e8512`.
```solidity
function BRIDGE_MANAGER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_MANAGER_ROLECall {}
    ///Container type for the return parameters of the [`BRIDGE_MANAGER_ROLE()`](BRIDGE_MANAGER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_MANAGER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_MANAGER_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_MANAGER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_MANAGER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_MANAGER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_MANAGER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_MANAGER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for BRIDGE_MANAGER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = BRIDGE_MANAGER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BRIDGE_MANAGER_ROLE()";
            const SELECTOR: [u8; 4] = [247u8, 94u8, 133u8, 18u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `CLOCK_MODE()` and selector `0x4bf5d7e9`.
```solidity
function CLOCK_MODE() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CLOCK_MODECall {}
    ///Container type for the return parameters of the [`CLOCK_MODE()`](CLOCK_MODECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CLOCK_MODEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CLOCK_MODECall> for UnderlyingRustTuple<'_> {
                fn from(value: CLOCK_MODECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for CLOCK_MODECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CLOCK_MODEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: CLOCK_MODEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for CLOCK_MODEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for CLOCK_MODECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = CLOCK_MODEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CLOCK_MODE()";
            const SELECTOR: [u8; 4] = [75u8, 245u8, 215u8, 233u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `DEFAULT_ADMIN_ROLE()` and selector `0xa217fddf`.
```solidity
function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLECall {}
    ///Container type for the return parameters of the [`DEFAULT_ADMIN_ROLE()`](DEFAULT_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEFAULT_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DEFAULT_ADMIN_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEFAULT_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [162u8, 23u8, 253u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `DOMAIN_SEPARATOR()` and selector `0x3644e515`.
```solidity
function DOMAIN_SEPARATOR() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DOMAIN_SEPARATORCall {}
    ///Container type for the return parameters of the [`DOMAIN_SEPARATOR()`](DOMAIN_SEPARATORCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DOMAIN_SEPARATORReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DOMAIN_SEPARATORCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DOMAIN_SEPARATORCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DOMAIN_SEPARATORCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DOMAIN_SEPARATORReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DOMAIN_SEPARATORReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DOMAIN_SEPARATORReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DOMAIN_SEPARATORCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DOMAIN_SEPARATORReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DOMAIN_SEPARATOR()";
            const SELECTOR: [u8; 4] = [54u8, 68u8, 229u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSIONS_MANAGER_ROLE()` and selector `0xe3abdfcb`.
```solidity
function EMISSIONS_MANAGER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_MANAGER_ROLECall {}
    ///Container type for the return parameters of the [`EMISSIONS_MANAGER_ROLE()`](EMISSIONS_MANAGER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_MANAGER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_MANAGER_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_MANAGER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSIONS_MANAGER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_MANAGER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_MANAGER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSIONS_MANAGER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSIONS_MANAGER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSIONS_MANAGER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSIONS_MANAGER_ROLE()";
            const SELECTOR: [u8; 4] = [227u8, 171u8, 223u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSIONS_SUPPLY()` and selector `0x6cf01625`.
```solidity
function EMISSIONS_SUPPLY() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_SUPPLYCall {}
    ///Container type for the return parameters of the [`EMISSIONS_SUPPLY()`](EMISSIONS_SUPPLYCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_SUPPLYReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_SUPPLYCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_SUPPLYCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSIONS_SUPPLYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_SUPPLYReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_SUPPLYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSIONS_SUPPLYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSIONS_SUPPLYCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSIONS_SUPPLYReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSIONS_SUPPLY()";
            const SELECTOR: [u8; 4] = [108u8, 240u8, 22u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EPOCH_DURATION()` and selector `0xa70b9f0c`.
```solidity
function EPOCH_DURATION() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EPOCH_DURATIONCall {}
    ///Container type for the return parameters of the [`EPOCH_DURATION()`](EPOCH_DURATIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EPOCH_DURATIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EPOCH_DURATIONCall> for UnderlyingRustTuple<'_> {
                fn from(value: EPOCH_DURATIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for EPOCH_DURATIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EPOCH_DURATIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EPOCH_DURATIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EPOCH_DURATIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EPOCH_DURATIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EPOCH_DURATIONReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EPOCH_DURATION()";
            const SELECTOR: [u8; 4] = [167u8, 11u8, 159u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `INITIAL_MINT_SUPPLY()` and selector `0x9b7ef64b`.
```solidity
function INITIAL_MINT_SUPPLY() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct INITIAL_MINT_SUPPLYCall {}
    ///Container type for the return parameters of the [`INITIAL_MINT_SUPPLY()`](INITIAL_MINT_SUPPLYCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct INITIAL_MINT_SUPPLYReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<INITIAL_MINT_SUPPLYCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: INITIAL_MINT_SUPPLYCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for INITIAL_MINT_SUPPLYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<INITIAL_MINT_SUPPLYReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: INITIAL_MINT_SUPPLYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for INITIAL_MINT_SUPPLYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for INITIAL_MINT_SUPPLYCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = INITIAL_MINT_SUPPLYReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "INITIAL_MINT_SUPPLY()";
            const SELECTOR: [u8; 4] = [155u8, 126u8, 246u8, 75u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `PAUSER_ROLE()` and selector `0xe63ab1e9`.
```solidity
function PAUSER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PAUSER_ROLECall {}
    ///Container type for the return parameters of the [`PAUSER_ROLE()`](PAUSER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PAUSER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PAUSER_ROLECall> for UnderlyingRustTuple<'_> {
                fn from(value: PAUSER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for PAUSER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PAUSER_ROLEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: PAUSER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for PAUSER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for PAUSER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = PAUSER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PAUSER_ROLE()";
            const SELECTOR: [u8; 4] = [230u8, 58u8, 177u8, 233u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `TOTAL_EPOCHS()` and selector `0x5f15c3c9`.
```solidity
function TOTAL_EPOCHS() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_EPOCHSCall {}
    ///Container type for the return parameters of the [`TOTAL_EPOCHS()`](TOTAL_EPOCHSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_EPOCHSReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_EPOCHSCall> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_EPOCHSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_EPOCHSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_EPOCHSReturn> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_EPOCHSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_EPOCHSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for TOTAL_EPOCHSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = TOTAL_EPOCHSReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TOTAL_EPOCHS()";
            const SELECTOR: [u8; 4] = [95u8, 21u8, 195u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `TOTAL_SUPPLY()` and selector `0x902d55a5`.
```solidity
function TOTAL_SUPPLY() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_SUPPLYCall {}
    ///Container type for the return parameters of the [`TOTAL_SUPPLY()`](TOTAL_SUPPLYCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_SUPPLYReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_SUPPLYCall> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_SUPPLYCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_SUPPLYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_SUPPLYReturn> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_SUPPLYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_SUPPLYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for TOTAL_SUPPLYCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = TOTAL_SUPPLYReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TOTAL_SUPPLY()";
            const SELECTOR: [u8; 4] = [144u8, 45u8, 85u8, 165u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `allowance(address,address)` and selector `0xdd62ed3e`.
```solidity
function allowance(address owner, address spender) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allowanceCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`allowance(address,address)`](allowanceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allowanceReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowanceCall> for UnderlyingRustTuple<'_> {
                fn from(value: allowanceCall) -> Self {
                    (value.owner, value.spender)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for allowanceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        spender: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowanceReturn> for UnderlyingRustTuple<'_> {
                fn from(value: allowanceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for allowanceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for allowanceCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = allowanceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "allowance(address,address)";
            const SELECTOR: [u8; 4] = [221u8, 98u8, 237u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `approve(address,uint256)` and selector `0x095ea7b3`.
```solidity
function approve(address spender, uint256 value) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveCall {
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`approve(address,uint256)`](approveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveCall> for UnderlyingRustTuple<'_> {
                fn from(value: approveCall) -> Self {
                    (value.spender, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        spender: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveReturn> for UnderlyingRustTuple<'_> {
                fn from(value: approveReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for approveCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = approveReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "approve(address,uint256)";
            const SELECTOR: [u8; 4] = [9u8, 94u8, 167u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `authorizedBridges(address)` and selector `0x6fc063be`.
```solidity
function authorizedBridges(address) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct authorizedBridgesCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`authorizedBridges(address)`](authorizedBridgesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct authorizedBridgesReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<authorizedBridgesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: authorizedBridgesCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for authorizedBridgesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<authorizedBridgesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: authorizedBridgesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for authorizedBridgesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for authorizedBridgesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = authorizedBridgesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "authorizedBridges(address)";
            const SELECTOR: [u8; 4] = [111u8, 192u8, 99u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `balanceOf(address)` and selector `0x70a08231`.
```solidity
function balanceOf(address account) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`balanceOf(address)`](balanceOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfCall> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfReturn> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for balanceOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = balanceOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "balanceOf(address)";
            const SELECTOR: [u8; 4] = [112u8, 160u8, 130u8, 49u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeData()` and selector `0x2481bb5c`.
```solidity
function bridgeData() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeDataCall {}
    ///Container type for the return parameters of the [`bridgeData()`](bridgeDataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeDataReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeDataCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeDataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeDataReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeDataReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeDataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeDataReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeData()";
            const SELECTOR: [u8; 4] = [36u8, 129u8, 187u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeLimits(address)` and selector `0x44e181aa`.
```solidity
function bridgeLimits(address) external view returns (uint256 mintingMaxLimit, uint256 mintingCurrentLimit, uint256 burningMaxLimit, uint256 burningCurrentLimit, uint256 lastUpdate);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeLimitsCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`bridgeLimits(address)`](bridgeLimitsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeLimitsReturn {
        #[allow(missing_docs)]
        pub mintingMaxLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub mintingCurrentLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub burningMaxLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub burningCurrentLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub lastUpdate: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeLimitsCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeLimitsCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeLimitsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeLimitsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeLimitsReturn) -> Self {
                    (
                        value.mintingMaxLimit,
                        value.mintingCurrentLimit,
                        value.burningMaxLimit,
                        value.burningCurrentLimit,
                        value.lastUpdate,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeLimitsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        mintingMaxLimit: tuple.0,
                        mintingCurrentLimit: tuple.1,
                        burningMaxLimit: tuple.2,
                        burningCurrentLimit: tuple.3,
                        lastUpdate: tuple.4,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeLimitsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeLimitsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeLimits(address)";
            const SELECTOR: [u8; 4] = [68u8, 225u8, 129u8, 170u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeProxy()` and selector `0xa3d4485b`.
```solidity
function bridgeProxy() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeProxyCall {}
    ///Container type for the return parameters of the [`bridgeProxy()`](bridgeProxyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeProxyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeProxyCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeProxyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeProxyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeProxyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeProxyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeProxyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeProxyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeProxyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeProxy()";
            const SELECTOR: [u8; 4] = [163u8, 212u8, 72u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `burn(address,uint256)` and selector `0x9dc29fac`.
```solidity
function burn(address _user, uint256 _amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burnCall {
        #[allow(missing_docs)]
        pub _user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`burn(address,uint256)`](burnCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burnReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burnCall> for UnderlyingRustTuple<'_> {
                fn from(value: burnCall) -> Self {
                    (value._user, value._amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for burnCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _user: tuple.0,
                        _amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burnReturn> for UnderlyingRustTuple<'_> {
                fn from(value: burnReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for burnReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for burnCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = burnReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "burn(address,uint256)";
            const SELECTOR: [u8; 4] = [157u8, 194u8, 159u8, 172u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `burningCurrentLimitOf(address)` and selector `0x998955d3`.
```solidity
function burningCurrentLimitOf(address _bridge) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burningCurrentLimitOfCall {
        #[allow(missing_docs)]
        pub _bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`burningCurrentLimitOf(address)`](burningCurrentLimitOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burningCurrentLimitOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burningCurrentLimitOfCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: burningCurrentLimitOfCall) -> Self {
                    (value._bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for burningCurrentLimitOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burningCurrentLimitOfReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: burningCurrentLimitOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for burningCurrentLimitOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for burningCurrentLimitOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = burningCurrentLimitOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "burningCurrentLimitOf(address)";
            const SELECTOR: [u8; 4] = [153u8, 137u8, 85u8, 211u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `burningMaxLimitOf(address)` and selector `0xc1eb7137`.
```solidity
function burningMaxLimitOf(address _bridge) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burningMaxLimitOfCall {
        #[allow(missing_docs)]
        pub _bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`burningMaxLimitOf(address)`](burningMaxLimitOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burningMaxLimitOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burningMaxLimitOfCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: burningMaxLimitOfCall) -> Self {
                    (value._bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for burningMaxLimitOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burningMaxLimitOfReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: burningMaxLimitOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for burningMaxLimitOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for burningMaxLimitOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = burningMaxLimitOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "burningMaxLimitOf(address)";
            const SELECTOR: [u8; 4] = [193u8, 235u8, 113u8, 55u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `checkpoints(address,uint32)` and selector `0xf1127ed8`.
```solidity
function checkpoints(address account, uint32 pos) external view returns (Checkpoints.Checkpoint208 memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkpointsCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub pos: u32,
    }
    ///Container type for the return parameters of the [`checkpoints(address,uint32)`](checkpointsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkpointsReturn {
        #[allow(missing_docs)]
        pub _0: <Checkpoints::Checkpoint208 as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, u32);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkpointsCall> for UnderlyingRustTuple<'_> {
                fn from(value: checkpointsCall) -> Self {
                    (value.account, value.pos)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for checkpointsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        account: tuple.0,
                        pos: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Checkpoints::Checkpoint208,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Checkpoints::Checkpoint208 as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkpointsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: checkpointsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for checkpointsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkpointsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkpointsReturn;
            type ReturnTuple<'a> = (Checkpoints::Checkpoint208,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkpoints(address,uint32)";
            const SELECTOR: [u8; 4] = [241u8, 18u8, 126u8, 216u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.pos),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `clock()` and selector `0x91ddadf4`.
```solidity
function clock() external view returns (uint48);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct clockCall {}
    ///Container type for the return parameters of the [`clock()`](clockCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct clockReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U48,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<clockCall> for UnderlyingRustTuple<'_> {
                fn from(value: clockCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for clockCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U48,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<clockReturn> for UnderlyingRustTuple<'_> {
                fn from(value: clockReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for clockReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for clockCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = clockReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "clock()";
            const SELECTOR: [u8; 4] = [145u8, 221u8, 173u8, 244u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `currentEpoch()` and selector `0x76671808`.
```solidity
function currentEpoch() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct currentEpochCall {}
    ///Container type for the return parameters of the [`currentEpoch()`](currentEpochCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct currentEpochReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<currentEpochCall> for UnderlyingRustTuple<'_> {
                fn from(value: currentEpochCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for currentEpochCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<currentEpochReturn> for UnderlyingRustTuple<'_> {
                fn from(value: currentEpochReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for currentEpochReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for currentEpochCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = currentEpochReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "currentEpoch()";
            const SELECTOR: [u8; 4] = [118u8, 103u8, 24u8, 8u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `decimals()` and selector `0x313ce567`.
```solidity
function decimals() external view returns (uint8);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decimalsCall {}
    ///Container type for the return parameters of the [`decimals()`](decimalsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decimalsReturn {
        #[allow(missing_docs)]
        pub _0: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decimalsCall> for UnderlyingRustTuple<'_> {
                fn from(value: decimalsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for decimalsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decimalsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: decimalsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for decimalsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for decimalsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = decimalsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "decimals()";
            const SELECTOR: [u8; 4] = [49u8, 60u8, 229u8, 103u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `delegate(address)` and selector `0x5c19a95c`.
```solidity
function delegate(address delegatee) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateCall {
        #[allow(missing_docs)]
        pub delegatee: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`delegate(address)`](delegateCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateCall> for UnderlyingRustTuple<'_> {
                fn from(value: delegateCall) -> Self {
                    (value.delegatee,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegateCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { delegatee: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateReturn> for UnderlyingRustTuple<'_> {
                fn from(value: delegateReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegateReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for delegateCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = delegateReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "delegate(address)";
            const SELECTOR: [u8; 4] = [92u8, 25u8, 169u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.delegatee,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)` and selector `0xc3cda520`.
```solidity
function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateBySigCall {
        #[allow(missing_docs)]
        pub delegatee: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub expiry: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub v: u8,
        #[allow(missing_docs)]
        pub r: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)`](delegateBySigCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateBySigReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                u8,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateBySigCall> for UnderlyingRustTuple<'_> {
                fn from(value: delegateBySigCall) -> Self {
                    (
                        value.delegatee,
                        value.nonce,
                        value.expiry,
                        value.v,
                        value.r,
                        value.s,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegateBySigCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        delegatee: tuple.0,
                        nonce: tuple.1,
                        expiry: tuple.2,
                        v: tuple.3,
                        r: tuple.4,
                        s: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateBySigReturn> for UnderlyingRustTuple<'_> {
                fn from(value: delegateBySigReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegateBySigReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for delegateBySigCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = delegateBySigReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [195u8, 205u8, 165u8, 32u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.delegatee,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expiry),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.v),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.r),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `delegates(address)` and selector `0x587cde1e`.
```solidity
function delegates(address account) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegatesCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`delegates(address)`](delegatesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegatesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegatesCall> for UnderlyingRustTuple<'_> {
                fn from(value: delegatesCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegatesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegatesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: delegatesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegatesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for delegatesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = delegatesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "delegates(address)";
            const SELECTOR: [u8; 4] = [88u8, 124u8, 222u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `eip712Domain()` and selector `0x84b0196e`.
```solidity
function eip712Domain() external view returns (bytes1 fields, string memory name, string memory version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] memory extensions);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eip712DomainCall {}
    ///Container type for the return parameters of the [`eip712Domain()`](eip712DomainCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eip712DomainReturn {
        #[allow(missing_docs)]
        pub fields: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub name: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub version: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub verifyingContract: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub salt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub extensions: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eip712DomainCall> for UnderlyingRustTuple<'_> {
                fn from(value: eip712DomainCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eip712DomainCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eip712DomainReturn> for UnderlyingRustTuple<'_> {
                fn from(value: eip712DomainReturn) -> Self {
                    (
                        value.fields,
                        value.name,
                        value.version,
                        value.chainId,
                        value.verifyingContract,
                        value.salt,
                        value.extensions,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eip712DomainReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        fields: tuple.0,
                        name: tuple.1,
                        version: tuple.2,
                        chainId: tuple.3,
                        verifyingContract: tuple.4,
                        salt: tuple.5,
                        extensions: tuple.6,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for eip712DomainCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = eip712DomainReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "eip712Domain()";
            const SELECTOR: [u8; 4] = [132u8, 176u8, 25u8, 110u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionSchedule(uint256)` and selector `0x334d0bbd`.
```solidity
function emissionSchedule(uint256) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionScheduleCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`emissionSchedule(uint256)`](emissionScheduleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionScheduleReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionScheduleCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionScheduleCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionScheduleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionScheduleReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionScheduleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionScheduleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionScheduleCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionScheduleReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionSchedule(uint256)";
            const SELECTOR: [u8; 4] = [51u8, 77u8, 11u8, 189u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionsActive()` and selector `0x22a97d9c`.
```solidity
function emissionsActive() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsActiveCall {}
    ///Container type for the return parameters of the [`emissionsActive()`](emissionsActiveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsActiveReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsActiveCall> for UnderlyingRustTuple<'_> {
                fn from(value: emissionsActiveCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for emissionsActiveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsActiveReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsActiveReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsActiveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionsActiveCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionsActiveReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionsActive()";
            const SELECTOR: [u8; 4] = [34u8, 169u8, 125u8, 156u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionsEnded()` and selector `0xa4d7e31d`.
```solidity
function emissionsEnded() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsEndedCall {}
    ///Container type for the return parameters of the [`emissionsEnded()`](emissionsEndedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsEndedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsEndedCall> for UnderlyingRustTuple<'_> {
                fn from(value: emissionsEndedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for emissionsEndedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsEndedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsEndedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsEndedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionsEndedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionsEndedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionsEnded()";
            const SELECTOR: [u8; 4] = [164u8, 215u8, 227u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionsStartTime()` and selector `0x48b0daa6`.
```solidity
function emissionsStartTime() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartTimeCall {}
    ///Container type for the return parameters of the [`emissionsStartTime()`](emissionsStartTimeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartTimeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartTimeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartTimeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartTimeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartTimeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartTimeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartTimeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionsStartTimeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionsStartTimeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionsStartTime()";
            const SELECTOR: [u8; 4] = [72u8, 176u8, 218u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionsStarted()` and selector `0x5adf0021`.
```solidity
function emissionsStarted() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartedCall {}
    ///Container type for the return parameters of the [`emissionsStarted()`](emissionsStartedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionsStartedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionsStartedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionsStarted()";
            const SELECTOR: [u8; 4] = [90u8, 223u8, 0u8, 33u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBridgeConfiguration()` and selector `0x07a1d5fa`.
```solidity
function getBridgeConfiguration() external view returns (address proxy, bytes memory data);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeConfigurationCall {}
    ///Container type for the return parameters of the [`getBridgeConfiguration()`](getBridgeConfigurationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeConfigurationReturn {
        #[allow(missing_docs)]
        pub proxy: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeConfigurationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeConfigurationCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeConfigurationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeConfigurationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeConfigurationReturn) -> Self {
                    (value.proxy, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeConfigurationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        proxy: tuple.0,
                        data: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBridgeConfigurationCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBridgeConfigurationReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBridgeConfiguration()";
            const SELECTOR: [u8; 4] = [7u8, 161u8, 213u8, 250u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBridgeInfo(address)` and selector `0x7c790cab`.
```solidity
function getBridgeInfo(address bridge) external view returns (bool authorized, uint256 mintingMax, uint256 mintingCurrent, uint256 burningMax, uint256 burningCurrent);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeInfoCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getBridgeInfo(address)`](getBridgeInfoCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeInfoReturn {
        #[allow(missing_docs)]
        pub authorized: bool,
        #[allow(missing_docs)]
        pub mintingMax: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub mintingCurrent: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub burningMax: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub burningCurrent: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeInfoCall> for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeInfoCall) -> Self {
                    (value.bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBridgeInfoCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                bool,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeInfoReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeInfoReturn) -> Self {
                    (
                        value.authorized,
                        value.mintingMax,
                        value.mintingCurrent,
                        value.burningMax,
                        value.burningCurrent,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBridgeInfoReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        authorized: tuple.0,
                        mintingMax: tuple.1,
                        mintingCurrent: tuple.2,
                        burningMax: tuple.3,
                        burningCurrent: tuple.4,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBridgeInfoCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBridgeInfoReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBridgeInfo(address)";
            const SELECTOR: [u8; 4] = [124u8, 121u8, 12u8, 171u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBridgeUtilization(address)` and selector `0x23e460d2`.
```solidity
function getBridgeUtilization(address bridge) external view returns (uint256 mintingUtilization, uint256 burningUtilization);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeUtilizationCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getBridgeUtilization(address)`](getBridgeUtilizationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeUtilizationReturn {
        #[allow(missing_docs)]
        pub mintingUtilization: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub burningUtilization: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeUtilizationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeUtilizationCall) -> Self {
                    (value.bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeUtilizationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeUtilizationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeUtilizationReturn) -> Self {
                    (value.mintingUtilization, value.burningUtilization)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeUtilizationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        mintingUtilization: tuple.0,
                        burningUtilization: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBridgeUtilizationCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBridgeUtilizationReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBridgeUtilization(address)";
            const SELECTOR: [u8; 4] = [35u8, 228u8, 96u8, 210u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getCurrentEpochInfo()` and selector `0xbabc394f`.
```solidity
function getCurrentEpochInfo() external view returns (uint256 epoch, uint256 nextEmissionTime, uint256 nextEmissionAmount, bool canMintEmission);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentEpochInfoCall {}
    ///Container type for the return parameters of the [`getCurrentEpochInfo()`](getCurrentEpochInfoCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentEpochInfoReturn {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nextEmissionTime: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nextEmissionAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub canMintEmission: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentEpochInfoCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentEpochInfoCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentEpochInfoCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                bool,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentEpochInfoReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentEpochInfoReturn) -> Self {
                    (
                        value.epoch,
                        value.nextEmissionTime,
                        value.nextEmissionAmount,
                        value.canMintEmission,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentEpochInfoReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epoch: tuple.0,
                        nextEmissionTime: tuple.1,
                        nextEmissionAmount: tuple.2,
                        canMintEmission: tuple.3,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCurrentEpochInfoCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getCurrentEpochInfoReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bool,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCurrentEpochInfo()";
            const SELECTOR: [u8; 4] = [186u8, 188u8, 57u8, 79u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getCurrentTotalSupply()` and selector `0xc02ae754`.
```solidity
function getCurrentTotalSupply() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentTotalSupplyCall {}
    ///Container type for the return parameters of the [`getCurrentTotalSupply()`](getCurrentTotalSupplyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentTotalSupplyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentTotalSupplyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentTotalSupplyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentTotalSupplyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentTotalSupplyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentTotalSupplyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentTotalSupplyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCurrentTotalSupplyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getCurrentTotalSupplyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCurrentTotalSupply()";
            const SELECTOR: [u8; 4] = [192u8, 42u8, 231u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getEmissionSchedule()` and selector `0xaf2aa63b`.
```solidity
function getEmissionSchedule() external view returns (uint256[48] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEmissionScheduleCall {}
    ///Container type for the return parameters of the [`getEmissionSchedule()`](getEmissionScheduleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEmissionScheduleReturn {
        #[allow(missing_docs)]
        pub _0: [alloy::sol_types::private::primitives::aliases::U256; 48usize],
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEmissionScheduleCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getEmissionScheduleCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getEmissionScheduleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    48usize,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                [alloy::sol_types::private::primitives::aliases::U256; 48usize],
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEmissionScheduleReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getEmissionScheduleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getEmissionScheduleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getEmissionScheduleCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getEmissionScheduleReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    48usize,
                >,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getEmissionSchedule()";
            const SELECTOR: [u8; 4] = [175u8, 42u8, 166u8, 59u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getPastTotalSupply(uint256)` and selector `0x8e539e8c`.
```solidity
function getPastTotalSupply(uint256 timepoint) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastTotalSupplyCall {
        #[allow(missing_docs)]
        pub timepoint: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getPastTotalSupply(uint256)`](getPastTotalSupplyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastTotalSupplyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastTotalSupplyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPastTotalSupplyCall) -> Self {
                    (value.timepoint,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPastTotalSupplyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { timepoint: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastTotalSupplyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPastTotalSupplyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPastTotalSupplyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPastTotalSupplyCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPastTotalSupplyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPastTotalSupply(uint256)";
            const SELECTOR: [u8; 4] = [142u8, 83u8, 158u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.timepoint),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getPastVotes(address,uint256)` and selector `0x3a46b1a8`.
```solidity
function getPastVotes(address account, uint256 timepoint) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastVotesCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub timepoint: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getPastVotes(address,uint256)`](getPastVotesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastVotesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastVotesCall> for UnderlyingRustTuple<'_> {
                fn from(value: getPastVotesCall) -> Self {
                    (value.account, value.timepoint)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getPastVotesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        account: tuple.0,
                        timepoint: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastVotesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getPastVotesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getPastVotesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPastVotesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPastVotesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPastVotes(address,uint256)";
            const SELECTOR: [u8; 4] = [58u8, 70u8, 177u8, 168u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.timepoint),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getPastVotingPower(address,uint256)` and selector `0xb0ca253e`.
```solidity
function getPastVotingPower(address account, uint256 blockNumber) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastVotingPowerCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub blockNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getPastVotingPower(address,uint256)`](getPastVotingPowerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastVotingPowerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastVotingPowerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPastVotingPowerCall) -> Self {
                    (value.account, value.blockNumber)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPastVotingPowerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        account: tuple.0,
                        blockNumber: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastVotingPowerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPastVotingPowerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPastVotingPowerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPastVotingPowerCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPastVotingPowerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPastVotingPower(address,uint256)";
            const SELECTOR: [u8; 4] = [176u8, 202u8, 37u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNumber),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRemainingEmissions()` and selector `0x4bdd36ce`.
```solidity
function getRemainingEmissions() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRemainingEmissionsCall {}
    ///Container type for the return parameters of the [`getRemainingEmissions()`](getRemainingEmissionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRemainingEmissionsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRemainingEmissionsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRemainingEmissionsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRemainingEmissionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRemainingEmissionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRemainingEmissionsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRemainingEmissionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRemainingEmissionsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRemainingEmissionsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRemainingEmissions()";
            const SELECTOR: [u8; 4] = [75u8, 221u8, 54u8, 206u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRoleAdmin(bytes32)` and selector `0x248a9ca3`.
```solidity
function getRoleAdmin(bytes32 role) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getRoleAdmin(bytes32)`](getRoleAdminCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleAdminCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRoleAdminReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleAdmin(bytes32)";
            const SELECTOR: [u8; 4] = [36u8, 138u8, 156u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getVotes(address)` and selector `0x9ab24eb0`.
```solidity
function getVotes(address account) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVotesCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getVotes(address)`](getVotesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVotesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVotesCall> for UnderlyingRustTuple<'_> {
                fn from(value: getVotesCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVotesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVotesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getVotesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVotesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getVotesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getVotesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getVotes(address)";
            const SELECTOR: [u8; 4] = [154u8, 178u8, 78u8, 176u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getVotingPower(address)` and selector `0xbb4d4436`.
```solidity
function getVotingPower(address account) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVotingPowerCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getVotingPower(address)`](getVotingPowerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVotingPowerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVotingPowerCall> for UnderlyingRustTuple<'_> {
                fn from(value: getVotingPowerCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVotingPowerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVotingPowerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getVotingPowerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getVotingPowerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getVotingPowerCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getVotingPowerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getVotingPower(address)";
            const SELECTOR: [u8; 4] = [187u8, 77u8, 68u8, 54u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `grantRole(bytes32,address)` and selector `0x2f2ff15d`.
```solidity
function grantRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`grantRole(bytes32,address)`](grantRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for grantRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = grantRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "grantRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [47u8, 47u8, 241u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `hasRole(bytes32,address)` and selector `0x91d14854`.
```solidity
function hasRole(bytes32 role, address account) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`hasRole(bytes32,address)`](hasRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = hasRoleReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [145u8, 209u8, 72u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isBridge(address)` and selector `0x726600ce`.
```solidity
function isBridge(address bridge) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isBridgeCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`isBridge(address)`](isBridgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isBridgeReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isBridgeCall> for UnderlyingRustTuple<'_> {
                fn from(value: isBridgeCall) -> Self {
                    (value.bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isBridgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isBridgeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isBridgeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isBridgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isBridgeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isBridgeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isBridge(address)";
            const SELECTOR: [u8; 4] = [114u8, 102u8, 0u8, 206u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `mint(address,uint256)` and selector `0x40c10f19`.
```solidity
function mint(address _user, uint256 _amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintCall {
        #[allow(missing_docs)]
        pub _user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`mint(address,uint256)`](mintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintCall> for UnderlyingRustTuple<'_> {
                fn from(value: mintCall) -> Self {
                    (value._user, value._amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _user: tuple.0,
                        _amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintReturn> for UnderlyingRustTuple<'_> {
                fn from(value: mintReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mintCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mintReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mint(address,uint256)";
            const SELECTOR: [u8; 4] = [64u8, 193u8, 15u8, 25u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `mintEmission()` and selector `0x284e1333`.
```solidity
function mintEmission() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintEmissionCall {}
    ///Container type for the return parameters of the [`mintEmission()`](mintEmissionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintEmissionReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintEmissionCall> for UnderlyingRustTuple<'_> {
                fn from(value: mintEmissionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintEmissionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintEmissionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: mintEmissionReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintEmissionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mintEmissionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mintEmissionReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mintEmission()";
            const SELECTOR: [u8; 4] = [40u8, 78u8, 19u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `mintingCurrentLimitOf(address)` and selector `0x651fd268`.
```solidity
function mintingCurrentLimitOf(address _bridge) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintingCurrentLimitOfCall {
        #[allow(missing_docs)]
        pub _bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`mintingCurrentLimitOf(address)`](mintingCurrentLimitOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintingCurrentLimitOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintingCurrentLimitOfCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: mintingCurrentLimitOfCall) -> Self {
                    (value._bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for mintingCurrentLimitOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintingCurrentLimitOfReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: mintingCurrentLimitOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for mintingCurrentLimitOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mintingCurrentLimitOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mintingCurrentLimitOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mintingCurrentLimitOf(address)";
            const SELECTOR: [u8; 4] = [101u8, 31u8, 210u8, 104u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `mintingMaxLimitOf(address)` and selector `0x0c05f82c`.
```solidity
function mintingMaxLimitOf(address _bridge) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintingMaxLimitOfCall {
        #[allow(missing_docs)]
        pub _bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`mintingMaxLimitOf(address)`](mintingMaxLimitOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintingMaxLimitOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintingMaxLimitOfCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: mintingMaxLimitOfCall) -> Self {
                    (value._bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for mintingMaxLimitOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintingMaxLimitOfReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: mintingMaxLimitOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for mintingMaxLimitOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mintingMaxLimitOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mintingMaxLimitOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mintingMaxLimitOf(address)";
            const SELECTOR: [u8; 4] = [12u8, 5u8, 248u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `name()` and selector `0x06fdde03`.
```solidity
function name() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nameCall {}
    ///Container type for the return parameters of the [`name()`](nameCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nameReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nameCall> for UnderlyingRustTuple<'_> {
                fn from(value: nameCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nameCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nameReturn> for UnderlyingRustTuple<'_> {
                fn from(value: nameReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nameReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for nameCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = nameReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "name()";
            const SELECTOR: [u8; 4] = [6u8, 253u8, 222u8, 3u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `nonces(address)` and selector `0x7ecebe00`.
```solidity
function nonces(address owner) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct noncesCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`nonces(address)`](noncesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct noncesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<noncesCall> for UnderlyingRustTuple<'_> {
                fn from(value: noncesCall) -> Self {
                    (value.owner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for noncesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { owner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<noncesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: noncesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for noncesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for noncesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = noncesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "nonces(address)";
            const SELECTOR: [u8; 4] = [126u8, 206u8, 190u8, 0u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `numCheckpoints(address)` and selector `0x6fcfff45`.
```solidity
function numCheckpoints(address account) external view returns (uint32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct numCheckpointsCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`numCheckpoints(address)`](numCheckpointsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct numCheckpointsReturn {
        #[allow(missing_docs)]
        pub _0: u32,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<numCheckpointsCall> for UnderlyingRustTuple<'_> {
                fn from(value: numCheckpointsCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for numCheckpointsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<numCheckpointsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: numCheckpointsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for numCheckpointsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for numCheckpointsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = numCheckpointsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "numCheckpoints(address)";
            const SELECTOR: [u8; 4] = [111u8, 207u8, 255u8, 69u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `pause()` and selector `0x8456cb59`.
```solidity
function pause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseCall {}
    ///Container type for the return parameters of the [`pause()`](pauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pause()";
            const SELECTOR: [u8; 4] = [132u8, 86u8, 203u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `pauseEmissions()` and selector `0x6c33bced`.
```solidity
function pauseEmissions() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseEmissionsCall {}
    ///Container type for the return parameters of the [`pauseEmissions()`](pauseEmissionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseEmissionsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseEmissionsCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseEmissionsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseEmissionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseEmissionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: pauseEmissionsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for pauseEmissionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseEmissionsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseEmissionsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pauseEmissions()";
            const SELECTOR: [u8; 4] = [108u8, 51u8, 188u8, 237u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `paused()` and selector `0x5c975abb`.
```solidity
function paused() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedCall {}
    ///Container type for the return parameters of the [`paused()`](pausedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedCall> for UnderlyingRustTuple<'_> {
                fn from(value: pausedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pausedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pausedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pausedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "paused()";
            const SELECTOR: [u8; 4] = [92u8, 151u8, 90u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `permit(address,address,uint256,uint256,uint8,bytes32,bytes32)` and selector `0xd505accf`.
```solidity
function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct permitCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub deadline: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub v: u8,
        #[allow(missing_docs)]
        pub r: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`permit(address,address,uint256,uint256,uint8,bytes32,bytes32)`](permitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct permitReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                u8,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<permitCall> for UnderlyingRustTuple<'_> {
                fn from(value: permitCall) -> Self {
                    (
                        value.owner,
                        value.spender,
                        value.value,
                        value.deadline,
                        value.v,
                        value.r,
                        value.s,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for permitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        spender: tuple.1,
                        value: tuple.2,
                        deadline: tuple.3,
                        v: tuple.4,
                        r: tuple.5,
                        s: tuple.6,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<permitReturn> for UnderlyingRustTuple<'_> {
                fn from(value: permitReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for permitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for permitCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = permitReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [213u8, 5u8, 172u8, 207u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.deadline),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.v),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.r),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `renounceRole(bytes32,address)` and selector `0x36568abe`.
```solidity
function renounceRole(bytes32 role, address callerConfirmation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub callerConfirmation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`renounceRole(bytes32,address)`](renounceRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleCall) -> Self {
                    (value.role, value.callerConfirmation)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        callerConfirmation: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [54u8, 86u8, 138u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callerConfirmation,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `resumeEmissions()` and selector `0x359b76fe`.
```solidity
function resumeEmissions() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resumeEmissionsCall {}
    ///Container type for the return parameters of the [`resumeEmissions()`](resumeEmissionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resumeEmissionsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resumeEmissionsCall> for UnderlyingRustTuple<'_> {
                fn from(value: resumeEmissionsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for resumeEmissionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resumeEmissionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: resumeEmissionsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for resumeEmissionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for resumeEmissionsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = resumeEmissionsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "resumeEmissions()";
            const SELECTOR: [u8; 4] = [53u8, 155u8, 118u8, 254u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `revokeRole(bytes32,address)` and selector `0xd547741f`.
```solidity
function revokeRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeRole(bytes32,address)`](revokeRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [213u8, 71u8, 116u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBridgeData(bytes)` and selector `0x13beaa5b`.
```solidity
function setBridgeData(bytes memory _bridgeData) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeDataCall {
        #[allow(missing_docs)]
        pub _bridgeData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`setBridgeData(bytes)`](setBridgeDataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeDataReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeDataCall> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeDataCall) -> Self {
                    (value._bridgeData,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgeDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridgeData: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeDataReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeDataReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgeDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBridgeDataCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBridgeDataReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBridgeData(bytes)";
            const SELECTOR: [u8; 4] = [19u8, 190u8, 170u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self._bridgeData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBridgeProxy(address)` and selector `0xa571e184`.
```solidity
function setBridgeProxy(address _bridgeProxy) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeProxyCall {
        #[allow(missing_docs)]
        pub _bridgeProxy: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setBridgeProxy(address)`](setBridgeProxyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeProxyReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeProxyCall> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeProxyCall) -> Self {
                    (value._bridgeProxy,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgeProxyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridgeProxy: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeProxyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeProxyReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setBridgeProxyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBridgeProxyCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBridgeProxyReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBridgeProxy(address)";
            const SELECTOR: [u8; 4] = [165u8, 113u8, 225u8, 132u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridgeProxy,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setLimits(address,uint256,uint256)` and selector `0xa08d5654`.
```solidity
function setLimits(address _bridge, uint256 _mintingLimit, uint256 _burningLimit) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setLimitsCall {
        #[allow(missing_docs)]
        pub _bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _mintingLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _burningLimit: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setLimits(address,uint256,uint256)`](setLimitsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setLimitsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setLimitsCall> for UnderlyingRustTuple<'_> {
                fn from(value: setLimitsCall) -> Self {
                    (value._bridge, value._mintingLimit, value._burningLimit)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setLimitsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _bridge: tuple.0,
                        _mintingLimit: tuple.1,
                        _burningLimit: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setLimitsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setLimitsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setLimitsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setLimitsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setLimitsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setLimits(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [160u8, 141u8, 86u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridge,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._mintingLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._burningLimit),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `startEmissions()` and selector `0x1b02f845`.
```solidity
function startEmissions() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startEmissionsCall {}
    ///Container type for the return parameters of the [`startEmissions()`](startEmissionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startEmissionsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startEmissionsCall> for UnderlyingRustTuple<'_> {
                fn from(value: startEmissionsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for startEmissionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startEmissionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: startEmissionsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for startEmissionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for startEmissionsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = startEmissionsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "startEmissions()";
            const SELECTOR: [u8; 4] = [27u8, 2u8, 248u8, 69u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
```solidity
function supportsInterface(bytes4 interfaceId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceCall {
        #[allow(missing_docs)]
        pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
    }
    ///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceCall) -> Self {
                    (value.interfaceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { interfaceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportsInterfaceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = supportsInterfaceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportsInterface(bytes4)";
            const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.interfaceId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `symbol()` and selector `0x95d89b41`.
```solidity
function symbol() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct symbolCall {}
    ///Container type for the return parameters of the [`symbol()`](symbolCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct symbolReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<symbolCall> for UnderlyingRustTuple<'_> {
                fn from(value: symbolCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for symbolCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<symbolReturn> for UnderlyingRustTuple<'_> {
                fn from(value: symbolReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for symbolReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for symbolCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = symbolReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "symbol()";
            const SELECTOR: [u8; 4] = [149u8, 216u8, 155u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `totalEmissionsMinted()` and selector `0xf508e19d`.
```solidity
function totalEmissionsMinted() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalEmissionsMintedCall {}
    ///Container type for the return parameters of the [`totalEmissionsMinted()`](totalEmissionsMintedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalEmissionsMintedReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalEmissionsMintedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: totalEmissionsMintedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for totalEmissionsMintedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalEmissionsMintedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: totalEmissionsMintedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for totalEmissionsMintedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for totalEmissionsMintedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = totalEmissionsMintedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "totalEmissionsMinted()";
            const SELECTOR: [u8; 4] = [245u8, 8u8, 225u8, 157u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `totalSupply()` and selector `0x18160ddd`.
```solidity
function totalSupply() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalSupplyCall {}
    ///Container type for the return parameters of the [`totalSupply()`](totalSupplyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalSupplyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalSupplyCall> for UnderlyingRustTuple<'_> {
                fn from(value: totalSupplyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalSupplyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalSupplyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: totalSupplyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalSupplyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for totalSupplyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = totalSupplyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "totalSupply()";
            const SELECTOR: [u8; 4] = [24u8, 22u8, 13u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transfer(address,uint256)` and selector `0xa9059cbb`.
```solidity
function transfer(address to, uint256 value) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferCall {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`transfer(address,uint256)`](transferCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferCall> for UnderlyingRustTuple<'_> {
                fn from(value: transferCall) -> Self {
                    (value.to, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferReturn> for UnderlyingRustTuple<'_> {
                fn from(value: transferReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transfer(address,uint256)";
            const SELECTOR: [u8; 4] = [169u8, 5u8, 156u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transferFrom(address,address,uint256)` and selector `0x23b872dd`.
```solidity
function transferFrom(address from, address to, uint256 value) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferFromCall {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`transferFrom(address,address,uint256)`](transferFromCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferFromReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferFromCall> for UnderlyingRustTuple<'_> {
                fn from(value: transferFromCall) -> Self {
                    (value.from, value.to, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        from: tuple.0,
                        to: tuple.1,
                        value: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferFromReturn> for UnderlyingRustTuple<'_> {
                fn from(value: transferFromReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferFromCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferFromReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferFrom(address,address,uint256)";
            const SELECTOR: [u8; 4] = [35u8, 184u8, 114u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `unpause()` and selector `0x3f4ba83a`.
```solidity
function unpause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseCall {}
    ///Container type for the return parameters of the [`unpause()`](unpauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unpauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = unpauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unpause()";
            const SELECTOR: [u8; 4] = [63u8, 75u8, 168u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`SyndicateToken`](self) function calls.
    pub enum SyndicateTokenCalls {
        #[allow(missing_docs)]
        BRIDGE_LIMIT_DURATION(BRIDGE_LIMIT_DURATIONCall),
        #[allow(missing_docs)]
        BRIDGE_MANAGER_ROLE(BRIDGE_MANAGER_ROLECall),
        #[allow(missing_docs)]
        CLOCK_MODE(CLOCK_MODECall),
        #[allow(missing_docs)]
        DEFAULT_ADMIN_ROLE(DEFAULT_ADMIN_ROLECall),
        #[allow(missing_docs)]
        DOMAIN_SEPARATOR(DOMAIN_SEPARATORCall),
        #[allow(missing_docs)]
        EMISSIONS_MANAGER_ROLE(EMISSIONS_MANAGER_ROLECall),
        #[allow(missing_docs)]
        EMISSIONS_SUPPLY(EMISSIONS_SUPPLYCall),
        #[allow(missing_docs)]
        EPOCH_DURATION(EPOCH_DURATIONCall),
        #[allow(missing_docs)]
        INITIAL_MINT_SUPPLY(INITIAL_MINT_SUPPLYCall),
        #[allow(missing_docs)]
        PAUSER_ROLE(PAUSER_ROLECall),
        #[allow(missing_docs)]
        TOTAL_EPOCHS(TOTAL_EPOCHSCall),
        #[allow(missing_docs)]
        TOTAL_SUPPLY(TOTAL_SUPPLYCall),
        #[allow(missing_docs)]
        allowance(allowanceCall),
        #[allow(missing_docs)]
        approve(approveCall),
        #[allow(missing_docs)]
        authorizedBridges(authorizedBridgesCall),
        #[allow(missing_docs)]
        balanceOf(balanceOfCall),
        #[allow(missing_docs)]
        bridgeData(bridgeDataCall),
        #[allow(missing_docs)]
        bridgeLimits(bridgeLimitsCall),
        #[allow(missing_docs)]
        bridgeProxy(bridgeProxyCall),
        #[allow(missing_docs)]
        burn(burnCall),
        #[allow(missing_docs)]
        burningCurrentLimitOf(burningCurrentLimitOfCall),
        #[allow(missing_docs)]
        burningMaxLimitOf(burningMaxLimitOfCall),
        #[allow(missing_docs)]
        checkpoints(checkpointsCall),
        #[allow(missing_docs)]
        clock(clockCall),
        #[allow(missing_docs)]
        currentEpoch(currentEpochCall),
        #[allow(missing_docs)]
        decimals(decimalsCall),
        #[allow(missing_docs)]
        delegate(delegateCall),
        #[allow(missing_docs)]
        delegateBySig(delegateBySigCall),
        #[allow(missing_docs)]
        delegates(delegatesCall),
        #[allow(missing_docs)]
        eip712Domain(eip712DomainCall),
        #[allow(missing_docs)]
        emissionSchedule(emissionScheduleCall),
        #[allow(missing_docs)]
        emissionsActive(emissionsActiveCall),
        #[allow(missing_docs)]
        emissionsEnded(emissionsEndedCall),
        #[allow(missing_docs)]
        emissionsStartTime(emissionsStartTimeCall),
        #[allow(missing_docs)]
        emissionsStarted(emissionsStartedCall),
        #[allow(missing_docs)]
        getBridgeConfiguration(getBridgeConfigurationCall),
        #[allow(missing_docs)]
        getBridgeInfo(getBridgeInfoCall),
        #[allow(missing_docs)]
        getBridgeUtilization(getBridgeUtilizationCall),
        #[allow(missing_docs)]
        getCurrentEpochInfo(getCurrentEpochInfoCall),
        #[allow(missing_docs)]
        getCurrentTotalSupply(getCurrentTotalSupplyCall),
        #[allow(missing_docs)]
        getEmissionSchedule(getEmissionScheduleCall),
        #[allow(missing_docs)]
        getPastTotalSupply(getPastTotalSupplyCall),
        #[allow(missing_docs)]
        getPastVotes(getPastVotesCall),
        #[allow(missing_docs)]
        getPastVotingPower(getPastVotingPowerCall),
        #[allow(missing_docs)]
        getRemainingEmissions(getRemainingEmissionsCall),
        #[allow(missing_docs)]
        getRoleAdmin(getRoleAdminCall),
        #[allow(missing_docs)]
        getVotes(getVotesCall),
        #[allow(missing_docs)]
        getVotingPower(getVotingPowerCall),
        #[allow(missing_docs)]
        grantRole(grantRoleCall),
        #[allow(missing_docs)]
        hasRole(hasRoleCall),
        #[allow(missing_docs)]
        isBridge(isBridgeCall),
        #[allow(missing_docs)]
        mint(mintCall),
        #[allow(missing_docs)]
        mintEmission(mintEmissionCall),
        #[allow(missing_docs)]
        mintingCurrentLimitOf(mintingCurrentLimitOfCall),
        #[allow(missing_docs)]
        mintingMaxLimitOf(mintingMaxLimitOfCall),
        #[allow(missing_docs)]
        name(nameCall),
        #[allow(missing_docs)]
        nonces(noncesCall),
        #[allow(missing_docs)]
        numCheckpoints(numCheckpointsCall),
        #[allow(missing_docs)]
        pause(pauseCall),
        #[allow(missing_docs)]
        pauseEmissions(pauseEmissionsCall),
        #[allow(missing_docs)]
        paused(pausedCall),
        #[allow(missing_docs)]
        permit(permitCall),
        #[allow(missing_docs)]
        renounceRole(renounceRoleCall),
        #[allow(missing_docs)]
        resumeEmissions(resumeEmissionsCall),
        #[allow(missing_docs)]
        revokeRole(revokeRoleCall),
        #[allow(missing_docs)]
        setBridgeData(setBridgeDataCall),
        #[allow(missing_docs)]
        setBridgeProxy(setBridgeProxyCall),
        #[allow(missing_docs)]
        setLimits(setLimitsCall),
        #[allow(missing_docs)]
        startEmissions(startEmissionsCall),
        #[allow(missing_docs)]
        supportsInterface(supportsInterfaceCall),
        #[allow(missing_docs)]
        symbol(symbolCall),
        #[allow(missing_docs)]
        totalEmissionsMinted(totalEmissionsMintedCall),
        #[allow(missing_docs)]
        totalSupply(totalSupplyCall),
        #[allow(missing_docs)]
        transfer(transferCall),
        #[allow(missing_docs)]
        transferFrom(transferFromCall),
        #[allow(missing_docs)]
        unpause(unpauseCall),
    }
    #[automatically_derived]
    impl SyndicateTokenCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 255u8, 201u8, 167u8],
            [6u8, 253u8, 222u8, 3u8],
            [7u8, 161u8, 213u8, 250u8],
            [9u8, 94u8, 167u8, 179u8],
            [12u8, 5u8, 248u8, 44u8],
            [19u8, 190u8, 170u8, 91u8],
            [24u8, 22u8, 13u8, 221u8],
            [27u8, 2u8, 248u8, 69u8],
            [34u8, 169u8, 125u8, 156u8],
            [35u8, 184u8, 114u8, 221u8],
            [35u8, 228u8, 96u8, 210u8],
            [36u8, 129u8, 187u8, 92u8],
            [36u8, 138u8, 156u8, 163u8],
            [40u8, 78u8, 19u8, 51u8],
            [47u8, 47u8, 241u8, 93u8],
            [49u8, 60u8, 229u8, 103u8],
            [51u8, 77u8, 11u8, 189u8],
            [53u8, 155u8, 118u8, 254u8],
            [54u8, 68u8, 229u8, 21u8],
            [54u8, 86u8, 138u8, 190u8],
            [58u8, 70u8, 177u8, 168u8],
            [63u8, 75u8, 168u8, 58u8],
            [64u8, 193u8, 15u8, 25u8],
            [68u8, 225u8, 129u8, 170u8],
            [72u8, 176u8, 218u8, 166u8],
            [75u8, 221u8, 54u8, 206u8],
            [75u8, 245u8, 215u8, 233u8],
            [88u8, 124u8, 222u8, 30u8],
            [90u8, 223u8, 0u8, 33u8],
            [92u8, 25u8, 169u8, 92u8],
            [92u8, 151u8, 90u8, 187u8],
            [95u8, 21u8, 195u8, 201u8],
            [101u8, 31u8, 210u8, 104u8],
            [108u8, 51u8, 188u8, 237u8],
            [108u8, 240u8, 22u8, 37u8],
            [111u8, 192u8, 99u8, 190u8],
            [111u8, 207u8, 255u8, 69u8],
            [112u8, 160u8, 130u8, 49u8],
            [114u8, 102u8, 0u8, 206u8],
            [118u8, 103u8, 24u8, 8u8],
            [124u8, 121u8, 12u8, 171u8],
            [126u8, 206u8, 190u8, 0u8],
            [132u8, 86u8, 203u8, 89u8],
            [132u8, 176u8, 25u8, 110u8],
            [142u8, 83u8, 158u8, 140u8],
            [144u8, 45u8, 85u8, 165u8],
            [145u8, 209u8, 72u8, 84u8],
            [145u8, 221u8, 173u8, 244u8],
            [149u8, 216u8, 155u8, 65u8],
            [153u8, 18u8, 125u8, 155u8],
            [153u8, 137u8, 85u8, 211u8],
            [154u8, 178u8, 78u8, 176u8],
            [155u8, 126u8, 246u8, 75u8],
            [157u8, 194u8, 159u8, 172u8],
            [160u8, 141u8, 86u8, 84u8],
            [162u8, 23u8, 253u8, 223u8],
            [163u8, 212u8, 72u8, 91u8],
            [164u8, 215u8, 227u8, 29u8],
            [165u8, 113u8, 225u8, 132u8],
            [167u8, 11u8, 159u8, 12u8],
            [169u8, 5u8, 156u8, 187u8],
            [175u8, 42u8, 166u8, 59u8],
            [176u8, 202u8, 37u8, 62u8],
            [186u8, 188u8, 57u8, 79u8],
            [187u8, 77u8, 68u8, 54u8],
            [192u8, 42u8, 231u8, 84u8],
            [193u8, 235u8, 113u8, 55u8],
            [195u8, 205u8, 165u8, 32u8],
            [213u8, 5u8, 172u8, 207u8],
            [213u8, 71u8, 116u8, 31u8],
            [221u8, 98u8, 237u8, 62u8],
            [227u8, 171u8, 223u8, 203u8],
            [230u8, 58u8, 177u8, 233u8],
            [241u8, 18u8, 126u8, 216u8],
            [245u8, 8u8, 225u8, 157u8],
            [247u8, 94u8, 133u8, 18u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndicateTokenCalls {
        const NAME: &'static str = "SyndicateTokenCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 76usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::BRIDGE_LIMIT_DURATION(_) => {
                    <BRIDGE_LIMIT_DURATIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::BRIDGE_MANAGER_ROLE(_) => {
                    <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::CLOCK_MODE(_) => {
                    <CLOCK_MODECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DEFAULT_ADMIN_ROLE(_) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DOMAIN_SEPARATOR(_) => {
                    <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSIONS_MANAGER_ROLE(_) => {
                    <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSIONS_SUPPLY(_) => {
                    <EMISSIONS_SUPPLYCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EPOCH_DURATION(_) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::INITIAL_MINT_SUPPLY(_) => {
                    <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::PAUSER_ROLE(_) => {
                    <PAUSER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::TOTAL_EPOCHS(_) => {
                    <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::TOTAL_SUPPLY(_) => {
                    <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::allowance(_) => {
                    <allowanceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::approve(_) => <approveCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::authorizedBridges(_) => {
                    <authorizedBridgesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::balanceOf(_) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeData(_) => {
                    <bridgeDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeLimits(_) => {
                    <bridgeLimitsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeProxy(_) => {
                    <bridgeProxyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::burn(_) => <burnCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::burningCurrentLimitOf(_) => {
                    <burningCurrentLimitOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::burningMaxLimitOf(_) => {
                    <burningMaxLimitOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkpoints(_) => {
                    <checkpointsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::clock(_) => <clockCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::currentEpoch(_) => {
                    <currentEpochCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::decimals(_) => <decimalsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::delegate(_) => <delegateCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::delegateBySig(_) => {
                    <delegateBySigCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::delegates(_) => {
                    <delegatesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::eip712Domain(_) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionSchedule(_) => {
                    <emissionScheduleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionsActive(_) => {
                    <emissionsActiveCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionsEnded(_) => {
                    <emissionsEndedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionsStartTime(_) => {
                    <emissionsStartTimeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionsStarted(_) => {
                    <emissionsStartedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBridgeConfiguration(_) => {
                    <getBridgeConfigurationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBridgeInfo(_) => {
                    <getBridgeInfoCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBridgeUtilization(_) => {
                    <getBridgeUtilizationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCurrentEpochInfo(_) => {
                    <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCurrentTotalSupply(_) => {
                    <getCurrentTotalSupplyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getEmissionSchedule(_) => {
                    <getEmissionScheduleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPastTotalSupply(_) => {
                    <getPastTotalSupplyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPastVotes(_) => {
                    <getPastVotesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPastVotingPower(_) => {
                    <getPastVotingPowerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRemainingEmissions(_) => {
                    <getRemainingEmissionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleAdmin(_) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getVotes(_) => <getVotesCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getVotingPower(_) => {
                    <getVotingPowerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::grantRole(_) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasRole(_) => <hasRoleCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::isBridge(_) => <isBridgeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::mint(_) => <mintCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::mintEmission(_) => {
                    <mintEmissionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::mintingCurrentLimitOf(_) => {
                    <mintingCurrentLimitOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::mintingMaxLimitOf(_) => {
                    <mintingMaxLimitOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::name(_) => <nameCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::nonces(_) => <noncesCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::numCheckpoints(_) => {
                    <numCheckpointsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::pause(_) => <pauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pauseEmissions(_) => {
                    <pauseEmissionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::paused(_) => <pausedCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::permit(_) => <permitCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::renounceRole(_) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::resumeEmissions(_) => {
                    <resumeEmissionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeRole(_) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBridgeData(_) => {
                    <setBridgeDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBridgeProxy(_) => {
                    <setBridgeProxyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setLimits(_) => {
                    <setLimitsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::startEmissions(_) => {
                    <startEmissionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::supportsInterface(_) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::symbol(_) => <symbolCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::totalEmissionsMinted(_) => {
                    <totalEmissionsMintedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::totalSupply(_) => {
                    <totalSupplyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transfer(_) => <transferCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::transferFrom(_) => {
                    <transferFromCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::unpause(_) => <unpauseCall as alloy_sol_types::SolCall>::SELECTOR,
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<SyndicateTokenCalls>] = &[
                {
                    fn supportsInterface(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn name(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <nameCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::name)
                    }
                    name
                },
                {
                    fn getBridgeConfiguration(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getBridgeConfigurationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getBridgeConfiguration)
                    }
                    getBridgeConfiguration
                },
                {
                    fn approve(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <approveCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::approve)
                    }
                    approve
                },
                {
                    fn mintingMaxLimitOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <mintingMaxLimitOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::mintingMaxLimitOf)
                    }
                    mintingMaxLimitOf
                },
                {
                    fn setBridgeData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <setBridgeDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::setBridgeData)
                    }
                    setBridgeData
                },
                {
                    fn totalSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <totalSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::totalSupply)
                    }
                    totalSupply
                },
                {
                    fn startEmissions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <startEmissionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::startEmissions)
                    }
                    startEmissions
                },
                {
                    fn emissionsActive(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <emissionsActiveCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::emissionsActive)
                    }
                    emissionsActive
                },
                {
                    fn transferFrom(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <transferFromCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::transferFrom)
                    }
                    transferFrom
                },
                {
                    fn getBridgeUtilization(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getBridgeUtilizationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getBridgeUtilization)
                    }
                    getBridgeUtilization
                },
                {
                    fn bridgeData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <bridgeDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::bridgeData)
                    }
                    bridgeData
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn mintEmission(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <mintEmissionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::mintEmission)
                    }
                    mintEmission
                },
                {
                    fn grantRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn decimals(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <decimalsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::decimals)
                    }
                    decimals
                },
                {
                    fn emissionSchedule(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <emissionScheduleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::emissionSchedule)
                    }
                    emissionSchedule
                },
                {
                    fn resumeEmissions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <resumeEmissionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::resumeEmissions)
                    }
                    resumeEmissions
                },
                {
                    fn DOMAIN_SEPARATOR(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::DOMAIN_SEPARATOR)
                    }
                    DOMAIN_SEPARATOR
                },
                {
                    fn renounceRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn getPastVotes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getPastVotesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getPastVotes)
                    }
                    getPastVotes
                },
                {
                    fn unpause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <unpauseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::unpause)
                    }
                    unpause
                },
                {
                    fn mint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <mintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::mint)
                    }
                    mint
                },
                {
                    fn bridgeLimits(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <bridgeLimitsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::bridgeLimits)
                    }
                    bridgeLimits
                },
                {
                    fn emissionsStartTime(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <emissionsStartTimeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::emissionsStartTime)
                    }
                    emissionsStartTime
                },
                {
                    fn getRemainingEmissions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getRemainingEmissionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getRemainingEmissions)
                    }
                    getRemainingEmissions
                },
                {
                    fn CLOCK_MODE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <CLOCK_MODECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::CLOCK_MODE)
                    }
                    CLOCK_MODE
                },
                {
                    fn delegates(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <delegatesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::delegates)
                    }
                    delegates
                },
                {
                    fn emissionsStarted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <emissionsStartedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::emissionsStarted)
                    }
                    emissionsStarted
                },
                {
                    fn delegate(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <delegateCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::delegate)
                    }
                    delegate
                },
                {
                    fn paused(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <pausedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::paused)
                    }
                    paused
                },
                {
                    fn TOTAL_EPOCHS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::TOTAL_EPOCHS)
                    }
                    TOTAL_EPOCHS
                },
                {
                    fn mintingCurrentLimitOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <mintingCurrentLimitOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::mintingCurrentLimitOf)
                    }
                    mintingCurrentLimitOf
                },
                {
                    fn pauseEmissions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <pauseEmissionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::pauseEmissions)
                    }
                    pauseEmissions
                },
                {
                    fn EMISSIONS_SUPPLY(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <EMISSIONS_SUPPLYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::EMISSIONS_SUPPLY)
                    }
                    EMISSIONS_SUPPLY
                },
                {
                    fn authorizedBridges(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <authorizedBridgesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::authorizedBridges)
                    }
                    authorizedBridges
                },
                {
                    fn numCheckpoints(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <numCheckpointsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::numCheckpoints)
                    }
                    numCheckpoints
                },
                {
                    fn balanceOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <balanceOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::balanceOf)
                    }
                    balanceOf
                },
                {
                    fn isBridge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <isBridgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::isBridge)
                    }
                    isBridge
                },
                {
                    fn currentEpoch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <currentEpochCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::currentEpoch)
                    }
                    currentEpoch
                },
                {
                    fn getBridgeInfo(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getBridgeInfoCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getBridgeInfo)
                    }
                    getBridgeInfo
                },
                {
                    fn nonces(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <noncesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::nonces)
                    }
                    nonces
                },
                {
                    fn pause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <pauseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::pause)
                    }
                    pause
                },
                {
                    fn eip712Domain(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <eip712DomainCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::eip712Domain)
                    }
                    eip712Domain
                },
                {
                    fn getPastTotalSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getPastTotalSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getPastTotalSupply)
                    }
                    getPastTotalSupply
                },
                {
                    fn TOTAL_SUPPLY(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::TOTAL_SUPPLY)
                    }
                    TOTAL_SUPPLY
                },
                {
                    fn hasRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn clock(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <clockCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::clock)
                    }
                    clock
                },
                {
                    fn symbol(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <symbolCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::symbol)
                    }
                    symbol
                },
                {
                    fn BRIDGE_LIMIT_DURATION(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <BRIDGE_LIMIT_DURATIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::BRIDGE_LIMIT_DURATION)
                    }
                    BRIDGE_LIMIT_DURATION
                },
                {
                    fn burningCurrentLimitOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <burningCurrentLimitOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::burningCurrentLimitOf)
                    }
                    burningCurrentLimitOf
                },
                {
                    fn getVotes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getVotesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getVotes)
                    }
                    getVotes
                },
                {
                    fn INITIAL_MINT_SUPPLY(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::INITIAL_MINT_SUPPLY)
                    }
                    INITIAL_MINT_SUPPLY
                },
                {
                    fn burn(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <burnCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::burn)
                    }
                    burn
                },
                {
                    fn setLimits(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <setLimitsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::setLimits)
                    }
                    setLimits
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn bridgeProxy(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <bridgeProxyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::bridgeProxy)
                    }
                    bridgeProxy
                },
                {
                    fn emissionsEnded(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <emissionsEndedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::emissionsEnded)
                    }
                    emissionsEnded
                },
                {
                    fn setBridgeProxy(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <setBridgeProxyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::setBridgeProxy)
                    }
                    setBridgeProxy
                },
                {
                    fn EPOCH_DURATION(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::EPOCH_DURATION)
                    }
                    EPOCH_DURATION
                },
                {
                    fn transfer(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <transferCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::transfer)
                    }
                    transfer
                },
                {
                    fn getEmissionSchedule(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getEmissionScheduleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getEmissionSchedule)
                    }
                    getEmissionSchedule
                },
                {
                    fn getPastVotingPower(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getPastVotingPowerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getPastVotingPower)
                    }
                    getPastVotingPower
                },
                {
                    fn getCurrentEpochInfo(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getCurrentEpochInfo)
                    }
                    getCurrentEpochInfo
                },
                {
                    fn getVotingPower(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getVotingPowerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getVotingPower)
                    }
                    getVotingPower
                },
                {
                    fn getCurrentTotalSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getCurrentTotalSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getCurrentTotalSupply)
                    }
                    getCurrentTotalSupply
                },
                {
                    fn burningMaxLimitOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <burningMaxLimitOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::burningMaxLimitOf)
                    }
                    burningMaxLimitOf
                },
                {
                    fn delegateBySig(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <delegateBySigCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::delegateBySig)
                    }
                    delegateBySig
                },
                {
                    fn permit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <permitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::permit)
                    }
                    permit
                },
                {
                    fn revokeRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn allowance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <allowanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::allowance)
                    }
                    allowance
                },
                {
                    fn EMISSIONS_MANAGER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::EMISSIONS_MANAGER_ROLE)
                    }
                    EMISSIONS_MANAGER_ROLE
                },
                {
                    fn PAUSER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <PAUSER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::PAUSER_ROLE)
                    }
                    PAUSER_ROLE
                },
                {
                    fn checkpoints(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <checkpointsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::checkpoints)
                    }
                    checkpoints
                },
                {
                    fn totalEmissionsMinted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <totalEmissionsMintedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::totalEmissionsMinted)
                    }
                    totalEmissionsMinted
                },
                {
                    fn BRIDGE_MANAGER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::BRIDGE_MANAGER_ROLE)
                    }
                    BRIDGE_MANAGER_ROLE
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::BRIDGE_LIMIT_DURATION(inner) => {
                    <BRIDGE_LIMIT_DURATIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BRIDGE_MANAGER_ROLE(inner) => {
                    <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CLOCK_MODE(inner) => {
                    <CLOCK_MODECall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DOMAIN_SEPARATOR(inner) => {
                    <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSIONS_MANAGER_ROLE(inner) => {
                    <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSIONS_SUPPLY(inner) => {
                    <EMISSIONS_SUPPLYCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EPOCH_DURATION(inner) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::INITIAL_MINT_SUPPLY(inner) => {
                    <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PAUSER_ROLE(inner) => {
                    <PAUSER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TOTAL_EPOCHS(inner) => {
                    <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TOTAL_SUPPLY(inner) => {
                    <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::allowance(inner) => {
                    <allowanceCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::approve(inner) => {
                    <approveCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::authorizedBridges(inner) => {
                    <authorizedBridgesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::bridgeData(inner) => {
                    <bridgeDataCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::bridgeLimits(inner) => {
                    <bridgeLimitsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bridgeProxy(inner) => {
                    <bridgeProxyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::burn(inner) => {
                    <burnCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::burningCurrentLimitOf(inner) => {
                    <burningCurrentLimitOfCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::burningMaxLimitOf(inner) => {
                    <burningMaxLimitOfCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkpoints(inner) => {
                    <checkpointsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::clock(inner) => {
                    <clockCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::currentEpoch(inner) => {
                    <currentEpochCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::decimals(inner) => {
                    <decimalsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::delegate(inner) => {
                    <delegateCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::delegateBySig(inner) => {
                    <delegateBySigCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::delegates(inner) => {
                    <delegatesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::eip712Domain(inner) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionSchedule(inner) => {
                    <emissionScheduleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionsActive(inner) => {
                    <emissionsActiveCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionsEnded(inner) => {
                    <emissionsEndedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionsStartTime(inner) => {
                    <emissionsStartTimeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionsStarted(inner) => {
                    <emissionsStartedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBridgeConfiguration(inner) => {
                    <getBridgeConfigurationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBridgeInfo(inner) => {
                    <getBridgeInfoCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBridgeUtilization(inner) => {
                    <getBridgeUtilizationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getCurrentEpochInfo(inner) => {
                    <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getCurrentTotalSupply(inner) => {
                    <getCurrentTotalSupplyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getEmissionSchedule(inner) => {
                    <getEmissionScheduleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPastTotalSupply(inner) => {
                    <getPastTotalSupplyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPastVotes(inner) => {
                    <getPastVotesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPastVotingPower(inner) => {
                    <getPastVotingPowerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRemainingEmissions(inner) => {
                    <getRemainingEmissionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getVotes(inner) => {
                    <getVotesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getVotingPower(inner) => {
                    <getVotingPowerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isBridge(inner) => {
                    <isBridgeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::mint(inner) => {
                    <mintCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::mintEmission(inner) => {
                    <mintEmissionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::mintingCurrentLimitOf(inner) => {
                    <mintingCurrentLimitOfCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::mintingMaxLimitOf(inner) => {
                    <mintingMaxLimitOfCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::name(inner) => {
                    <nameCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::nonces(inner) => {
                    <noncesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::numCheckpoints(inner) => {
                    <numCheckpointsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::pauseEmissions(inner) => {
                    <pauseEmissionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::permit(inner) => {
                    <permitCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::resumeEmissions(inner) => {
                    <resumeEmissionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setBridgeData(inner) => {
                    <setBridgeDataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setBridgeProxy(inner) => {
                    <setBridgeProxyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setLimits(inner) => {
                    <setLimitsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::startEmissions(inner) => {
                    <startEmissionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::symbol(inner) => {
                    <symbolCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::totalEmissionsMinted(inner) => {
                    <totalEmissionsMintedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::totalSupply(inner) => {
                    <totalSupplyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transfer(inner) => {
                    <transferCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::transferFrom(inner) => {
                    <transferFromCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::BRIDGE_LIMIT_DURATION(inner) => {
                    <BRIDGE_LIMIT_DURATIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BRIDGE_MANAGER_ROLE(inner) => {
                    <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CLOCK_MODE(inner) => {
                    <CLOCK_MODECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DOMAIN_SEPARATOR(inner) => {
                    <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSIONS_MANAGER_ROLE(inner) => {
                    <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSIONS_SUPPLY(inner) => {
                    <EMISSIONS_SUPPLYCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EPOCH_DURATION(inner) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::INITIAL_MINT_SUPPLY(inner) => {
                    <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PAUSER_ROLE(inner) => {
                    <PAUSER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TOTAL_EPOCHS(inner) => {
                    <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TOTAL_SUPPLY(inner) => {
                    <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::allowance(inner) => {
                    <allowanceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::approve(inner) => {
                    <approveCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::authorizedBridges(inner) => {
                    <authorizedBridgesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeData(inner) => {
                    <bridgeDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeLimits(inner) => {
                    <bridgeLimitsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeProxy(inner) => {
                    <bridgeProxyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::burn(inner) => {
                    <burnCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::burningCurrentLimitOf(inner) => {
                    <burningCurrentLimitOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::burningMaxLimitOf(inner) => {
                    <burningMaxLimitOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkpoints(inner) => {
                    <checkpointsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::clock(inner) => {
                    <clockCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::currentEpoch(inner) => {
                    <currentEpochCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::decimals(inner) => {
                    <decimalsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::delegate(inner) => {
                    <delegateCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::delegateBySig(inner) => {
                    <delegateBySigCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::delegates(inner) => {
                    <delegatesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::eip712Domain(inner) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionSchedule(inner) => {
                    <emissionScheduleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionsActive(inner) => {
                    <emissionsActiveCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionsEnded(inner) => {
                    <emissionsEndedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionsStartTime(inner) => {
                    <emissionsStartTimeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionsStarted(inner) => {
                    <emissionsStartedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBridgeConfiguration(inner) => {
                    <getBridgeConfigurationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBridgeInfo(inner) => {
                    <getBridgeInfoCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBridgeUtilization(inner) => {
                    <getBridgeUtilizationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getCurrentEpochInfo(inner) => {
                    <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getCurrentTotalSupply(inner) => {
                    <getCurrentTotalSupplyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getEmissionSchedule(inner) => {
                    <getEmissionScheduleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPastTotalSupply(inner) => {
                    <getPastTotalSupplyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPastVotes(inner) => {
                    <getPastVotesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPastVotingPower(inner) => {
                    <getPastVotingPowerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRemainingEmissions(inner) => {
                    <getRemainingEmissionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getVotes(inner) => {
                    <getVotesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getVotingPower(inner) => {
                    <getVotingPowerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::isBridge(inner) => {
                    <isBridgeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::mint(inner) => {
                    <mintCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::mintEmission(inner) => {
                    <mintEmissionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::mintingCurrentLimitOf(inner) => {
                    <mintingCurrentLimitOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::mintingMaxLimitOf(inner) => {
                    <mintingMaxLimitOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::name(inner) => {
                    <nameCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::nonces(inner) => {
                    <noncesCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::numCheckpoints(inner) => {
                    <numCheckpointsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pauseEmissions(inner) => {
                    <pauseEmissionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::permit(inner) => {
                    <permitCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::resumeEmissions(inner) => {
                    <resumeEmissionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBridgeData(inner) => {
                    <setBridgeDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBridgeProxy(inner) => {
                    <setBridgeProxyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setLimits(inner) => {
                    <setLimitsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::startEmissions(inner) => {
                    <startEmissionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::symbol(inner) => {
                    <symbolCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::totalEmissionsMinted(inner) => {
                    <totalEmissionsMintedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::totalSupply(inner) => {
                    <totalSupplyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transfer(inner) => {
                    <transferCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferFrom(inner) => {
                    <transferFromCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
            }
        }
    }
    ///Container for all the [`SyndicateToken`](self) custom errors.
    pub enum SyndicateTokenErrors {
        #[allow(missing_docs)]
        AccessControlBadConfirmation(AccessControlBadConfirmation),
        #[allow(missing_docs)]
        AccessControlUnauthorizedAccount(AccessControlUnauthorizedAccount),
        #[allow(missing_docs)]
        AllEmissionsCompleted(AllEmissionsCompleted),
        #[allow(missing_docs)]
        BridgeNotAuthorized(BridgeNotAuthorized),
        #[allow(missing_docs)]
        BridgeNotConfigured(BridgeNotConfigured),
        #[allow(missing_docs)]
        CheckpointUnorderedInsertion(CheckpointUnorderedInsertion),
        #[allow(missing_docs)]
        ECDSAInvalidSignature(ECDSAInvalidSignature),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureLength(ECDSAInvalidSignatureLength),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureS(ECDSAInvalidSignatureS),
        #[allow(missing_docs)]
        ERC20ExceededSafeSupply(ERC20ExceededSafeSupply),
        #[allow(missing_docs)]
        ERC20InsufficientAllowance(ERC20InsufficientAllowance),
        #[allow(missing_docs)]
        ERC20InsufficientBalance(ERC20InsufficientBalance),
        #[allow(missing_docs)]
        ERC20InvalidApprover(ERC20InvalidApprover),
        #[allow(missing_docs)]
        ERC20InvalidReceiver(ERC20InvalidReceiver),
        #[allow(missing_docs)]
        ERC20InvalidSender(ERC20InvalidSender),
        #[allow(missing_docs)]
        ERC20InvalidSpender(ERC20InvalidSpender),
        #[allow(missing_docs)]
        ERC2612ExpiredSignature(ERC2612ExpiredSignature),
        #[allow(missing_docs)]
        ERC2612InvalidSigner(ERC2612InvalidSigner),
        #[allow(missing_docs)]
        ERC5805FutureLookup(ERC5805FutureLookup),
        #[allow(missing_docs)]
        ERC6372InconsistentClock(ERC6372InconsistentClock),
        #[allow(missing_docs)]
        EmissionsAlreadyStarted(EmissionsAlreadyStarted),
        #[allow(missing_docs)]
        EmissionsNotActive(EmissionsNotActive),
        #[allow(missing_docs)]
        EmissionsNotStarted(EmissionsNotStarted),
        #[allow(missing_docs)]
        EnforcedPause(EnforcedPause),
        #[allow(missing_docs)]
        EpochAlreadyMinted(EpochAlreadyMinted),
        #[allow(missing_docs)]
        ExceedsEmissionsSupply(ExceedsEmissionsSupply),
        #[allow(missing_docs)]
        ExpectedPause(ExpectedPause),
        #[allow(missing_docs)]
        InsufficientLimit(InsufficientLimit),
        #[allow(missing_docs)]
        InvalidAccountNonce(InvalidAccountNonce),
        #[allow(missing_docs)]
        InvalidEpoch(InvalidEpoch),
        #[allow(missing_docs)]
        InvalidShortString(InvalidShortString),
        #[allow(missing_docs)]
        SafeCastOverflowedUintDowncast(SafeCastOverflowedUintDowncast),
        #[allow(missing_docs)]
        StringTooLong(StringTooLong),
        #[allow(missing_docs)]
        VotesExpiredSignature(VotesExpiredSignature),
        #[allow(missing_docs)]
        ZeroAddress(ZeroAddress),
        #[allow(missing_docs)]
        ZeroAmount(ZeroAmount),
        #[allow(missing_docs)]
        ZeroGasLimit(ZeroGasLimit),
    }
    #[automatically_derived]
    impl SyndicateTokenErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [28u8, 177u8, 93u8, 38u8],
            [31u8, 42u8, 32u8, 5u8],
            [35u8, 6u8, 78u8, 189u8],
            [37u8, 32u8, 96u8, 29u8],
            [48u8, 90u8, 39u8, 169u8],
            [62u8, 38u8, 127u8, 149u8],
            [69u8, 85u8, 137u8, 44u8],
            [70u8, 131u8, 175u8, 14u8],
            [75u8, 128u8, 14u8, 70u8],
            [98u8, 121u8, 19u8, 2u8],
            [102u8, 151u8, 178u8, 50u8],
            [102u8, 191u8, 38u8, 116u8],
            [109u8, 252u8, 198u8, 80u8],
            [111u8, 240u8, 113u8, 64u8],
            [113u8, 210u8, 123u8, 122u8],
            [114u8, 86u8, 123u8, 100u8],
            [117u8, 45u8, 136u8, 192u8],
            [118u8, 20u8, 145u8, 122u8],
            [136u8, 46u8, 236u8, 18u8],
            [141u8, 252u8, 32u8, 43u8],
            [143u8, 152u8, 64u8, 65u8],
            [148u8, 40u8, 13u8, 98u8],
            [150u8, 198u8, 253u8, 30u8],
            [179u8, 81u8, 43u8, 12u8],
            [213u8, 178u8, 91u8, 99u8],
            [215u8, 139u8, 206u8, 12u8],
            [217u8, 46u8, 35u8, 61u8],
            [217u8, 60u8, 6u8, 101u8],
            [224u8, 133u8, 210u8, 43u8],
            [226u8, 81u8, 125u8, 63u8],
            [228u8, 80u8, 211u8, 140u8],
            [230u8, 2u8, 223u8, 5u8],
            [236u8, 68u8, 47u8, 5u8],
            [236u8, 211u8, 248u8, 30u8],
            [246u8, 69u8, 238u8, 223u8],
            [251u8, 143u8, 65u8, 178u8],
            [252u8, 230u8, 152u8, 247u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndicateTokenErrors {
        const NAME: &'static str = "SyndicateTokenErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 37usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AccessControlBadConfirmation(_) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AccessControlUnauthorizedAccount(_) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AllEmissionsCompleted(_) => {
                    <AllEmissionsCompleted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BridgeNotAuthorized(_) => {
                    <BridgeNotAuthorized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BridgeNotConfigured(_) => {
                    <BridgeNotConfigured as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CheckpointUnorderedInsertion(_) => {
                    <CheckpointUnorderedInsertion as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignature(_) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureLength(_) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureS(_) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20ExceededSafeSupply(_) => {
                    <ERC20ExceededSafeSupply as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InsufficientAllowance(_) => {
                    <ERC20InsufficientAllowance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InsufficientBalance(_) => {
                    <ERC20InsufficientBalance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidApprover(_) => {
                    <ERC20InvalidApprover as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidReceiver(_) => {
                    <ERC20InvalidReceiver as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidSender(_) => {
                    <ERC20InvalidSender as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidSpender(_) => {
                    <ERC20InvalidSpender as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC2612ExpiredSignature(_) => {
                    <ERC2612ExpiredSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC2612InvalidSigner(_) => {
                    <ERC2612InvalidSigner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC5805FutureLookup(_) => {
                    <ERC5805FutureLookup as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC6372InconsistentClock(_) => {
                    <ERC6372InconsistentClock as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmissionsAlreadyStarted(_) => {
                    <EmissionsAlreadyStarted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmissionsNotActive(_) => {
                    <EmissionsNotActive as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmissionsNotStarted(_) => {
                    <EmissionsNotStarted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EnforcedPause(_) => {
                    <EnforcedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EpochAlreadyMinted(_) => {
                    <EpochAlreadyMinted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ExceedsEmissionsSupply(_) => {
                    <ExceedsEmissionsSupply as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ExpectedPause(_) => {
                    <ExpectedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientLimit(_) => {
                    <InsufficientLimit as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidAccountNonce(_) => {
                    <InvalidAccountNonce as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidEpoch(_) => {
                    <InvalidEpoch as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidShortString(_) => {
                    <InvalidShortString as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SafeCastOverflowedUintDowncast(_) => {
                    <SafeCastOverflowedUintDowncast as alloy_sol_types::SolError>::SELECTOR
                }
                Self::StringTooLong(_) => {
                    <StringTooLong as alloy_sol_types::SolError>::SELECTOR
                }
                Self::VotesExpiredSignature(_) => {
                    <VotesExpiredSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAddress(_) => {
                    <ZeroAddress as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAmount(_) => {
                    <ZeroAmount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroGasLimit(_) => {
                    <ZeroGasLimit as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<SyndicateTokenErrors>] = &[
                {
                    fn ERC20ExceededSafeSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20ExceededSafeSupply as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20ExceededSafeSupply)
                    }
                    ERC20ExceededSafeSupply
                },
                {
                    fn ZeroAmount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ZeroAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ZeroAmount)
                    }
                    ZeroAmount
                },
                {
                    fn ExceedsEmissionsSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ExceedsEmissionsSupply as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ExceedsEmissionsSupply)
                    }
                    ExceedsEmissionsSupply
                },
                {
                    fn CheckpointUnorderedInsertion(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <CheckpointUnorderedInsertion as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::CheckpointUnorderedInsertion)
                    }
                    CheckpointUnorderedInsertion
                },
                {
                    fn StringTooLong(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <StringTooLong as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::StringTooLong)
                    }
                    StringTooLong
                },
                {
                    fn ZeroGasLimit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ZeroGasLimit as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ZeroGasLimit)
                    }
                    ZeroGasLimit
                },
                {
                    fn AllEmissionsCompleted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <AllEmissionsCompleted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::AllEmissionsCompleted)
                    }
                    AllEmissionsCompleted
                },
                {
                    fn VotesExpiredSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <VotesExpiredSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::VotesExpiredSignature)
                    }
                    VotesExpiredSignature
                },
                {
                    fn ERC2612InvalidSigner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC2612InvalidSigner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC2612InvalidSigner)
                    }
                    ERC2612InvalidSigner
                },
                {
                    fn ERC2612ExpiredSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC2612ExpiredSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC2612ExpiredSignature)
                    }
                    ERC2612ExpiredSignature
                },
                {
                    fn AccessControlBadConfirmation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::AccessControlBadConfirmation)
                    }
                    AccessControlBadConfirmation
                },
                {
                    fn EmissionsNotActive(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <EmissionsNotActive as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::EmissionsNotActive)
                    }
                    EmissionsNotActive
                },
                {
                    fn SafeCastOverflowedUintDowncast(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <SafeCastOverflowedUintDowncast as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::SafeCastOverflowedUintDowncast)
                    }
                    SafeCastOverflowedUintDowncast
                },
                {
                    fn ERC6372InconsistentClock(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC6372InconsistentClock as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC6372InconsistentClock)
                    }
                    ERC6372InconsistentClock
                },
                {
                    fn EmissionsAlreadyStarted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <EmissionsAlreadyStarted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::EmissionsAlreadyStarted)
                    }
                    EmissionsAlreadyStarted
                },
                {
                    fn InsufficientLimit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <InsufficientLimit as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::InsufficientLimit)
                    }
                    InsufficientLimit
                },
                {
                    fn InvalidAccountNonce(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <InvalidAccountNonce as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::InvalidAccountNonce)
                    }
                    InvalidAccountNonce
                },
                {
                    fn BridgeNotConfigured(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <BridgeNotConfigured as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::BridgeNotConfigured)
                    }
                    BridgeNotConfigured
                },
                {
                    fn BridgeNotAuthorized(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <BridgeNotAuthorized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::BridgeNotAuthorized)
                    }
                    BridgeNotAuthorized
                },
                {
                    fn ExpectedPause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ExpectedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ExpectedPause)
                    }
                    ExpectedPause
                },
                {
                    fn EmissionsNotStarted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <EmissionsNotStarted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::EmissionsNotStarted)
                    }
                    EmissionsNotStarted
                },
                {
                    fn ERC20InvalidSpender(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InvalidSpender as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InvalidSpender)
                    }
                    ERC20InvalidSpender
                },
                {
                    fn ERC20InvalidSender(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InvalidSender as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InvalidSender)
                    }
                    ERC20InvalidSender
                },
                {
                    fn InvalidShortString(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <InvalidShortString as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::InvalidShortString)
                    }
                    InvalidShortString
                },
                {
                    fn InvalidEpoch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <InvalidEpoch as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::InvalidEpoch)
                    }
                    InvalidEpoch
                },
                {
                    fn ECDSAInvalidSignatureS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ECDSAInvalidSignatureS)
                    }
                    ECDSAInvalidSignatureS
                },
                {
                    fn ZeroAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ZeroAddress as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ZeroAddress)
                    }
                    ZeroAddress
                },
                {
                    fn EnforcedPause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <EnforcedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::EnforcedPause)
                    }
                    EnforcedPause
                },
                {
                    fn EpochAlreadyMinted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <EpochAlreadyMinted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::EpochAlreadyMinted)
                    }
                    EpochAlreadyMinted
                },
                {
                    fn AccessControlUnauthorizedAccount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::AccessControlUnauthorizedAccount)
                    }
                    AccessControlUnauthorizedAccount
                },
                {
                    fn ERC20InsufficientBalance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InsufficientBalance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InsufficientBalance)
                    }
                    ERC20InsufficientBalance
                },
                {
                    fn ERC20InvalidApprover(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InvalidApprover as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InvalidApprover)
                    }
                    ERC20InvalidApprover
                },
                {
                    fn ERC20InvalidReceiver(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InvalidReceiver as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InvalidReceiver)
                    }
                    ERC20InvalidReceiver
                },
                {
                    fn ERC5805FutureLookup(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC5805FutureLookup as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC5805FutureLookup)
                    }
                    ERC5805FutureLookup
                },
                {
                    fn ECDSAInvalidSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ECDSAInvalidSignature)
                    }
                    ECDSAInvalidSignature
                },
                {
                    fn ERC20InsufficientAllowance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InsufficientAllowance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InsufficientAllowance)
                    }
                    ERC20InsufficientAllowance
                },
                {
                    fn ECDSAInvalidSignatureLength(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ECDSAInvalidSignatureLength)
                    }
                    ECDSAInvalidSignatureLength
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AllEmissionsCompleted(inner) => {
                    <AllEmissionsCompleted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BridgeNotAuthorized(inner) => {
                    <BridgeNotAuthorized as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BridgeNotConfigured(inner) => {
                    <BridgeNotConfigured as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CheckpointUnorderedInsertion(inner) => {
                    <CheckpointUnorderedInsertion as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20ExceededSafeSupply(inner) => {
                    <ERC20ExceededSafeSupply as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InsufficientAllowance(inner) => {
                    <ERC20InsufficientAllowance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InsufficientBalance(inner) => {
                    <ERC20InsufficientBalance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidApprover(inner) => {
                    <ERC20InvalidApprover as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidReceiver(inner) => {
                    <ERC20InvalidReceiver as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidSender(inner) => {
                    <ERC20InvalidSender as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidSpender(inner) => {
                    <ERC20InvalidSpender as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC2612ExpiredSignature(inner) => {
                    <ERC2612ExpiredSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC2612InvalidSigner(inner) => {
                    <ERC2612InvalidSigner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC5805FutureLookup(inner) => {
                    <ERC5805FutureLookup as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC6372InconsistentClock(inner) => {
                    <ERC6372InconsistentClock as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmissionsAlreadyStarted(inner) => {
                    <EmissionsAlreadyStarted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmissionsNotActive(inner) => {
                    <EmissionsNotActive as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmissionsNotStarted(inner) => {
                    <EmissionsNotStarted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EpochAlreadyMinted(inner) => {
                    <EpochAlreadyMinted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ExceedsEmissionsSupply(inner) => {
                    <ExceedsEmissionsSupply as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InsufficientLimit(inner) => {
                    <InsufficientLimit as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidAccountNonce(inner) => {
                    <InvalidAccountNonce as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidEpoch(inner) => {
                    <InvalidEpoch as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidShortString(inner) => {
                    <InvalidShortString as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SafeCastOverflowedUintDowncast(inner) => {
                    <SafeCastOverflowedUintDowncast as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::StringTooLong(inner) => {
                    <StringTooLong as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::VotesExpiredSignature(inner) => {
                    <VotesExpiredSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ZeroAmount(inner) => {
                    <ZeroAmount as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ZeroGasLimit(inner) => {
                    <ZeroGasLimit as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AllEmissionsCompleted(inner) => {
                    <AllEmissionsCompleted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BridgeNotAuthorized(inner) => {
                    <BridgeNotAuthorized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BridgeNotConfigured(inner) => {
                    <BridgeNotConfigured as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CheckpointUnorderedInsertion(inner) => {
                    <CheckpointUnorderedInsertion as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20ExceededSafeSupply(inner) => {
                    <ERC20ExceededSafeSupply as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InsufficientAllowance(inner) => {
                    <ERC20InsufficientAllowance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InsufficientBalance(inner) => {
                    <ERC20InsufficientBalance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidApprover(inner) => {
                    <ERC20InvalidApprover as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidReceiver(inner) => {
                    <ERC20InvalidReceiver as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidSender(inner) => {
                    <ERC20InvalidSender as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidSpender(inner) => {
                    <ERC20InvalidSpender as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC2612ExpiredSignature(inner) => {
                    <ERC2612ExpiredSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC2612InvalidSigner(inner) => {
                    <ERC2612InvalidSigner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC5805FutureLookup(inner) => {
                    <ERC5805FutureLookup as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC6372InconsistentClock(inner) => {
                    <ERC6372InconsistentClock as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmissionsAlreadyStarted(inner) => {
                    <EmissionsAlreadyStarted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmissionsNotActive(inner) => {
                    <EmissionsNotActive as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmissionsNotStarted(inner) => {
                    <EmissionsNotStarted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EpochAlreadyMinted(inner) => {
                    <EpochAlreadyMinted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ExceedsEmissionsSupply(inner) => {
                    <ExceedsEmissionsSupply as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientLimit(inner) => {
                    <InsufficientLimit as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidAccountNonce(inner) => {
                    <InvalidAccountNonce as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidEpoch(inner) => {
                    <InvalidEpoch as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidShortString(inner) => {
                    <InvalidShortString as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SafeCastOverflowedUintDowncast(inner) => {
                    <SafeCastOverflowedUintDowncast as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::StringTooLong(inner) => {
                    <StringTooLong as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::VotesExpiredSignature(inner) => {
                    <VotesExpiredSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAmount(inner) => {
                    <ZeroAmount as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::ZeroGasLimit(inner) => {
                    <ZeroGasLimit as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`SyndicateToken`](self) events.
    pub enum SyndicateTokenEvents {
        #[allow(missing_docs)]
        Approval(Approval),
        #[allow(missing_docs)]
        BridgeAuthorized(BridgeAuthorized),
        #[allow(missing_docs)]
        BridgeDataUpdated(BridgeDataUpdated),
        #[allow(missing_docs)]
        BridgeDeauthorized(BridgeDeauthorized),
        #[allow(missing_docs)]
        BridgeLimitsSet(BridgeLimitsSet),
        #[allow(missing_docs)]
        BridgeProxyUpdated(BridgeProxyUpdated),
        #[allow(missing_docs)]
        DelegateChanged(DelegateChanged),
        #[allow(missing_docs)]
        DelegateVotesChanged(DelegateVotesChanged),
        #[allow(missing_docs)]
        EIP712DomainChanged(EIP712DomainChanged),
        #[allow(missing_docs)]
        EmissionMinted(EmissionMinted),
        #[allow(missing_docs)]
        EmissionsPaused(EmissionsPaused),
        #[allow(missing_docs)]
        EmissionsResumed(EmissionsResumed),
        #[allow(missing_docs)]
        EmissionsStarted(EmissionsStarted),
        #[allow(missing_docs)]
        Paused(Paused),
        #[allow(missing_docs)]
        RoleAdminChanged(RoleAdminChanged),
        #[allow(missing_docs)]
        RoleGranted(RoleGranted),
        #[allow(missing_docs)]
        RoleRevoked(RoleRevoked),
        #[allow(missing_docs)]
        Transfer(Transfer),
        #[allow(missing_docs)]
        Unpaused(Unpaused),
    }
    #[automatically_derived]
    impl SyndicateTokenEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                2u8,
                194u8,
                240u8,
                186u8,
                21u8,
                176u8,
                63u8,
                136u8,
                177u8,
                143u8,
                72u8,
                50u8,
                96u8,
                154u8,
                24u8,
                207u8,
                53u8,
                252u8,
                107u8,
                63u8,
                69u8,
                70u8,
                169u8,
                153u8,
                32u8,
                118u8,
                215u8,
                69u8,
                61u8,
                19u8,
                52u8,
                168u8,
            ],
            [
                7u8,
                1u8,
                91u8,
                106u8,
                159u8,
                5u8,
                145u8,
                49u8,
                72u8,
                253u8,
                95u8,
                173u8,
                223u8,
                42u8,
                204u8,
                151u8,
                8u8,
                243u8,
                5u8,
                147u8,
                127u8,
                48u8,
                114u8,
                202u8,
                43u8,
                75u8,
                70u8,
                250u8,
                165u8,
                208u8,
                137u8,
                139u8,
            ],
            [
                10u8,
                99u8,
                135u8,
                201u8,
                234u8,
                54u8,
                40u8,
                184u8,
                138u8,
                99u8,
                59u8,
                180u8,
                243u8,
                177u8,
                81u8,
                119u8,
                15u8,
                112u8,
                8u8,
                81u8,
                23u8,
                161u8,
                95u8,
                155u8,
                243u8,
                120u8,
                124u8,
                218u8,
                83u8,
                241u8,
                61u8,
                49u8,
            ],
            [
                17u8,
                148u8,
                176u8,
                52u8,
                207u8,
                169u8,
                171u8,
                88u8,
                7u8,
                73u8,
                74u8,
                29u8,
                92u8,
                102u8,
                125u8,
                139u8,
                14u8,
                110u8,
                151u8,
                243u8,
                136u8,
                136u8,
                116u8,
                42u8,
                163u8,
                135u8,
                26u8,
                50u8,
                32u8,
                52u8,
                17u8,
                96u8,
            ],
            [
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ],
            [
                49u8,
                52u8,
                232u8,
                162u8,
                230u8,
                217u8,
                126u8,
                146u8,
                154u8,
                126u8,
                84u8,
                1u8,
                30u8,
                165u8,
                72u8,
                93u8,
                125u8,
                25u8,
                109u8,
                213u8,
                240u8,
                186u8,
                77u8,
                78u8,
                249u8,
                88u8,
                3u8,
                232u8,
                227u8,
                252u8,
                37u8,
                127u8,
            ],
            [
                52u8,
                183u8,
                61u8,
                12u8,
                150u8,
                233u8,
                255u8,
                77u8,
                83u8,
                17u8,
                67u8,
                72u8,
                23u8,
                200u8,
                236u8,
                201u8,
                48u8,
                231u8,
                210u8,
                120u8,
                44u8,
                91u8,
                222u8,
                46u8,
                121u8,
                220u8,
                68u8,
                176u8,
                89u8,
                103u8,
                85u8,
                187u8,
            ],
            [
                74u8,
                121u8,
                42u8,
                11u8,
                228u8,
                43u8,
                86u8,
                114u8,
                250u8,
                164u8,
                1u8,
                41u8,
                252u8,
                100u8,
                105u8,
                7u8,
                36u8,
                144u8,
                119u8,
                92u8,
                168u8,
                211u8,
                195u8,
                78u8,
                133u8,
                45u8,
                77u8,
                85u8,
                211u8,
                167u8,
                53u8,
                169u8,
            ],
            [
                93u8,
                185u8,
                238u8,
                10u8,
                73u8,
                91u8,
                242u8,
                230u8,
                255u8,
                156u8,
                145u8,
                167u8,
                131u8,
                76u8,
                27u8,
                164u8,
                253u8,
                210u8,
                68u8,
                165u8,
                232u8,
                170u8,
                78u8,
                83u8,
                123u8,
                211u8,
                138u8,
                234u8,
                228u8,
                176u8,
                115u8,
                170u8,
            ],
            [
                98u8,
                231u8,
                140u8,
                234u8,
                1u8,
                190u8,
                227u8,
                32u8,
                205u8,
                78u8,
                66u8,
                2u8,
                112u8,
                181u8,
                234u8,
                116u8,
                0u8,
                13u8,
                17u8,
                176u8,
                201u8,
                247u8,
                71u8,
                84u8,
                235u8,
                219u8,
                252u8,
                84u8,
                75u8,
                5u8,
                162u8,
                88u8,
            ],
            [
                108u8,
                242u8,
                132u8,
                57u8,
                162u8,
                218u8,
                171u8,
                27u8,
                38u8,
                80u8,
                151u8,
                34u8,
                114u8,
                18u8,
                165u8,
                183u8,
                30u8,
                10u8,
                118u8,
                249u8,
                237u8,
                133u8,
                227u8,
                248u8,
                21u8,
                181u8,
                166u8,
                195u8,
                226u8,
                24u8,
                235u8,
                127u8,
            ],
            [
                115u8,
                165u8,
                252u8,
                96u8,
                170u8,
                254u8,
                236u8,
                143u8,
                19u8,
                154u8,
                242u8,
                45u8,
                152u8,
                230u8,
                33u8,
                64u8,
                226u8,
                206u8,
                145u8,
                77u8,
                31u8,
                21u8,
                92u8,
                105u8,
                43u8,
                66u8,
                119u8,
                87u8,
                195u8,
                228u8,
                1u8,
                76u8,
            ],
            [
                140u8,
                91u8,
                225u8,
                229u8,
                235u8,
                236u8,
                125u8,
                91u8,
                209u8,
                79u8,
                113u8,
                66u8,
                125u8,
                30u8,
                132u8,
                243u8,
                221u8,
                3u8,
                20u8,
                192u8,
                247u8,
                178u8,
                41u8,
                30u8,
                91u8,
                32u8,
                10u8,
                200u8,
                199u8,
                195u8,
                185u8,
                37u8,
            ],
            [
                170u8,
                128u8,
                125u8,
                10u8,
                191u8,
                48u8,
                217u8,
                25u8,
                104u8,
                199u8,
                71u8,
                140u8,
                102u8,
                182u8,
                216u8,
                37u8,
                33u8,
                161u8,
                6u8,
                175u8,
                19u8,
                237u8,
                160u8,
                54u8,
                226u8,
                3u8,
                109u8,
                169u8,
                175u8,
                22u8,
                137u8,
                88u8,
            ],
            [
                185u8,
                162u8,
                8u8,
                132u8,
                38u8,
                240u8,
                59u8,
                48u8,
                168u8,
                28u8,
                6u8,
                66u8,
                128u8,
                148u8,
                251u8,
                250u8,
                158u8,
                38u8,
                146u8,
                115u8,
                155u8,
                50u8,
                65u8,
                175u8,
                107u8,
                154u8,
                177u8,
                218u8,
                75u8,
                85u8,
                70u8,
                190u8,
            ],
            [
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ],
            [
                221u8,
                242u8,
                82u8,
                173u8,
                27u8,
                226u8,
                200u8,
                155u8,
                105u8,
                194u8,
                176u8,
                104u8,
                252u8,
                55u8,
                141u8,
                170u8,
                149u8,
                43u8,
                167u8,
                241u8,
                99u8,
                196u8,
                161u8,
                22u8,
                40u8,
                245u8,
                90u8,
                77u8,
                245u8,
                35u8,
                179u8,
                239u8,
            ],
            [
                222u8,
                194u8,
                186u8,
                205u8,
                210u8,
                240u8,
                91u8,
                89u8,
                222u8,
                52u8,
                218u8,
                155u8,
                82u8,
                61u8,
                255u8,
                139u8,
                228u8,
                46u8,
                94u8,
                56u8,
                232u8,
                24u8,
                200u8,
                47u8,
                219u8,
                11u8,
                174u8,
                119u8,
                67u8,
                135u8,
                167u8,
                36u8,
            ],
            [
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for SyndicateTokenEvents {
        const NAME: &'static str = "SyndicateTokenEvents";
        const COUNT: usize = 19usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<Approval as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Approval as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Approval)
                }
                Some(<BridgeAuthorized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <BridgeAuthorized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeAuthorized)
                }
                Some(
                    <BridgeDataUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BridgeDataUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeDataUpdated)
                }
                Some(
                    <BridgeDeauthorized as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BridgeDeauthorized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeDeauthorized)
                }
                Some(<BridgeLimitsSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <BridgeLimitsSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeLimitsSet)
                }
                Some(
                    <BridgeProxyUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BridgeProxyUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeProxyUpdated)
                }
                Some(<DelegateChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <DelegateChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::DelegateChanged)
                }
                Some(
                    <DelegateVotesChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <DelegateVotesChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::DelegateVotesChanged)
                }
                Some(
                    <EIP712DomainChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <EIP712DomainChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EIP712DomainChanged)
                }
                Some(<EmissionMinted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EmissionMinted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EmissionMinted)
                }
                Some(<EmissionsPaused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EmissionsPaused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EmissionsPaused)
                }
                Some(<EmissionsResumed as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EmissionsResumed as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EmissionsResumed)
                }
                Some(<EmissionsStarted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EmissionsStarted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EmissionsStarted)
                }
                Some(<Paused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Paused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Paused)
                }
                Some(<RoleAdminChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleAdminChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleAdminChanged)
                }
                Some(<RoleGranted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleGranted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleGranted)
                }
                Some(<RoleRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleRevoked)
                }
                Some(<Transfer as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Transfer as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Transfer)
                }
                Some(<Unpaused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Unpaused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Unpaused)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for SyndicateTokenEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Approval(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeAuthorized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeDataUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeDeauthorized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeLimitsSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeProxyUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DelegateChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DelegateVotesChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EIP712DomainChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EmissionMinted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EmissionsPaused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EmissionsResumed(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EmissionsStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Transfer(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Approval(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeAuthorized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeDataUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeDeauthorized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeLimitsSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeProxyUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DelegateChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DelegateVotesChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EIP712DomainChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EmissionMinted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EmissionsPaused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EmissionsResumed(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EmissionsStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Transfer(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`SyndicateToken`](self) contract instance.

See the [wrapper's documentation](`SyndicateTokenInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> SyndicateTokenInstance<T, P, N> {
        SyndicateTokenInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        defaultAdmin: alloy::sol_types::private::Address,
        syndFoundationAddress: alloy::sol_types::private::Address,
        emissionsManager: alloy::sol_types::private::Address,
        pauser: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<SyndicateTokenInstance<T, P, N>>,
    > {
        SyndicateTokenInstance::<
            T,
            P,
            N,
        >::deploy(
            provider,
            defaultAdmin,
            syndFoundationAddress,
            emissionsManager,
            pauser,
        )
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        defaultAdmin: alloy::sol_types::private::Address,
        syndFoundationAddress: alloy::sol_types::private::Address,
        emissionsManager: alloy::sol_types::private::Address,
        pauser: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        SyndicateTokenInstance::<
            T,
            P,
            N,
        >::deploy_builder(
            provider,
            defaultAdmin,
            syndFoundationAddress,
            emissionsManager,
            pauser,
        )
    }
    /**A [`SyndicateToken`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`SyndicateToken`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct SyndicateTokenInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for SyndicateTokenInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("SyndicateTokenInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyndicateTokenInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`SyndicateToken`](self) contract instance.

See the [wrapper's documentation](`SyndicateTokenInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            defaultAdmin: alloy::sol_types::private::Address,
            syndFoundationAddress: alloy::sol_types::private::Address,
            emissionsManager: alloy::sol_types::private::Address,
            pauser: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<SyndicateTokenInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(
                provider,
                defaultAdmin,
                syndFoundationAddress,
                emissionsManager,
                pauser,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            defaultAdmin: alloy::sol_types::private::Address,
            syndFoundationAddress: alloy::sol_types::private::Address,
            emissionsManager: alloy::sol_types::private::Address,
            pauser: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            defaultAdmin,
                            syndFoundationAddress,
                            emissionsManager,
                            pauser,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> SyndicateTokenInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> SyndicateTokenInstance<T, P, N> {
            SyndicateTokenInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyndicateTokenInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`BRIDGE_LIMIT_DURATION`] function.
        pub fn BRIDGE_LIMIT_DURATION(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, BRIDGE_LIMIT_DURATIONCall, N> {
            self.call_builder(&BRIDGE_LIMIT_DURATIONCall {})
        }
        ///Creates a new call builder for the [`BRIDGE_MANAGER_ROLE`] function.
        pub fn BRIDGE_MANAGER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, BRIDGE_MANAGER_ROLECall, N> {
            self.call_builder(&BRIDGE_MANAGER_ROLECall {})
        }
        ///Creates a new call builder for the [`CLOCK_MODE`] function.
        pub fn CLOCK_MODE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, CLOCK_MODECall, N> {
            self.call_builder(&CLOCK_MODECall {})
        }
        ///Creates a new call builder for the [`DEFAULT_ADMIN_ROLE`] function.
        pub fn DEFAULT_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, DEFAULT_ADMIN_ROLECall, N> {
            self.call_builder(&DEFAULT_ADMIN_ROLECall {})
        }
        ///Creates a new call builder for the [`DOMAIN_SEPARATOR`] function.
        pub fn DOMAIN_SEPARATOR(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, DOMAIN_SEPARATORCall, N> {
            self.call_builder(&DOMAIN_SEPARATORCall {})
        }
        ///Creates a new call builder for the [`EMISSIONS_MANAGER_ROLE`] function.
        pub fn EMISSIONS_MANAGER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSIONS_MANAGER_ROLECall, N> {
            self.call_builder(&EMISSIONS_MANAGER_ROLECall {})
        }
        ///Creates a new call builder for the [`EMISSIONS_SUPPLY`] function.
        pub fn EMISSIONS_SUPPLY(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSIONS_SUPPLYCall, N> {
            self.call_builder(&EMISSIONS_SUPPLYCall {})
        }
        ///Creates a new call builder for the [`EPOCH_DURATION`] function.
        pub fn EPOCH_DURATION(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EPOCH_DURATIONCall, N> {
            self.call_builder(&EPOCH_DURATIONCall {})
        }
        ///Creates a new call builder for the [`INITIAL_MINT_SUPPLY`] function.
        pub fn INITIAL_MINT_SUPPLY(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, INITIAL_MINT_SUPPLYCall, N> {
            self.call_builder(&INITIAL_MINT_SUPPLYCall {})
        }
        ///Creates a new call builder for the [`PAUSER_ROLE`] function.
        pub fn PAUSER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, PAUSER_ROLECall, N> {
            self.call_builder(&PAUSER_ROLECall {})
        }
        ///Creates a new call builder for the [`TOTAL_EPOCHS`] function.
        pub fn TOTAL_EPOCHS(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, TOTAL_EPOCHSCall, N> {
            self.call_builder(&TOTAL_EPOCHSCall {})
        }
        ///Creates a new call builder for the [`TOTAL_SUPPLY`] function.
        pub fn TOTAL_SUPPLY(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, TOTAL_SUPPLYCall, N> {
            self.call_builder(&TOTAL_SUPPLYCall {})
        }
        ///Creates a new call builder for the [`allowance`] function.
        pub fn allowance(
            &self,
            owner: alloy::sol_types::private::Address,
            spender: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, allowanceCall, N> {
            self.call_builder(&allowanceCall { owner, spender })
        }
        ///Creates a new call builder for the [`approve`] function.
        pub fn approve(
            &self,
            spender: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, approveCall, N> {
            self.call_builder(&approveCall { spender, value })
        }
        ///Creates a new call builder for the [`authorizedBridges`] function.
        pub fn authorizedBridges(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, authorizedBridgesCall, N> {
            self.call_builder(&authorizedBridgesCall { _0 })
        }
        ///Creates a new call builder for the [`balanceOf`] function.
        pub fn balanceOf(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, balanceOfCall, N> {
            self.call_builder(&balanceOfCall { account })
        }
        ///Creates a new call builder for the [`bridgeData`] function.
        pub fn bridgeData(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeDataCall, N> {
            self.call_builder(&bridgeDataCall {})
        }
        ///Creates a new call builder for the [`bridgeLimits`] function.
        pub fn bridgeLimits(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeLimitsCall, N> {
            self.call_builder(&bridgeLimitsCall { _0 })
        }
        ///Creates a new call builder for the [`bridgeProxy`] function.
        pub fn bridgeProxy(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeProxyCall, N> {
            self.call_builder(&bridgeProxyCall {})
        }
        ///Creates a new call builder for the [`burn`] function.
        pub fn burn(
            &self,
            _user: alloy::sol_types::private::Address,
            _amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, burnCall, N> {
            self.call_builder(&burnCall { _user, _amount })
        }
        ///Creates a new call builder for the [`burningCurrentLimitOf`] function.
        pub fn burningCurrentLimitOf(
            &self,
            _bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, burningCurrentLimitOfCall, N> {
            self.call_builder(
                &burningCurrentLimitOfCall {
                    _bridge,
                },
            )
        }
        ///Creates a new call builder for the [`burningMaxLimitOf`] function.
        pub fn burningMaxLimitOf(
            &self,
            _bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, burningMaxLimitOfCall, N> {
            self.call_builder(&burningMaxLimitOfCall { _bridge })
        }
        ///Creates a new call builder for the [`checkpoints`] function.
        pub fn checkpoints(
            &self,
            account: alloy::sol_types::private::Address,
            pos: u32,
        ) -> alloy_contract::SolCallBuilder<T, &P, checkpointsCall, N> {
            self.call_builder(&checkpointsCall { account, pos })
        }
        ///Creates a new call builder for the [`clock`] function.
        pub fn clock(&self) -> alloy_contract::SolCallBuilder<T, &P, clockCall, N> {
            self.call_builder(&clockCall {})
        }
        ///Creates a new call builder for the [`currentEpoch`] function.
        pub fn currentEpoch(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, currentEpochCall, N> {
            self.call_builder(&currentEpochCall {})
        }
        ///Creates a new call builder for the [`decimals`] function.
        pub fn decimals(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, decimalsCall, N> {
            self.call_builder(&decimalsCall {})
        }
        ///Creates a new call builder for the [`delegate`] function.
        pub fn delegate(
            &self,
            delegatee: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, delegateCall, N> {
            self.call_builder(&delegateCall { delegatee })
        }
        ///Creates a new call builder for the [`delegateBySig`] function.
        pub fn delegateBySig(
            &self,
            delegatee: alloy::sol_types::private::Address,
            nonce: alloy::sol_types::private::primitives::aliases::U256,
            expiry: alloy::sol_types::private::primitives::aliases::U256,
            v: u8,
            r: alloy::sol_types::private::FixedBytes<32>,
            s: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, delegateBySigCall, N> {
            self.call_builder(
                &delegateBySigCall {
                    delegatee,
                    nonce,
                    expiry,
                    v,
                    r,
                    s,
                },
            )
        }
        ///Creates a new call builder for the [`delegates`] function.
        pub fn delegates(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, delegatesCall, N> {
            self.call_builder(&delegatesCall { account })
        }
        ///Creates a new call builder for the [`eip712Domain`] function.
        pub fn eip712Domain(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, eip712DomainCall, N> {
            self.call_builder(&eip712DomainCall {})
        }
        ///Creates a new call builder for the [`emissionSchedule`] function.
        pub fn emissionSchedule(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionScheduleCall, N> {
            self.call_builder(&emissionScheduleCall { _0 })
        }
        ///Creates a new call builder for the [`emissionsActive`] function.
        pub fn emissionsActive(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionsActiveCall, N> {
            self.call_builder(&emissionsActiveCall {})
        }
        ///Creates a new call builder for the [`emissionsEnded`] function.
        pub fn emissionsEnded(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionsEndedCall, N> {
            self.call_builder(&emissionsEndedCall {})
        }
        ///Creates a new call builder for the [`emissionsStartTime`] function.
        pub fn emissionsStartTime(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionsStartTimeCall, N> {
            self.call_builder(&emissionsStartTimeCall {})
        }
        ///Creates a new call builder for the [`emissionsStarted`] function.
        pub fn emissionsStarted(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionsStartedCall, N> {
            self.call_builder(&emissionsStartedCall {})
        }
        ///Creates a new call builder for the [`getBridgeConfiguration`] function.
        pub fn getBridgeConfiguration(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBridgeConfigurationCall, N> {
            self.call_builder(&getBridgeConfigurationCall {})
        }
        ///Creates a new call builder for the [`getBridgeInfo`] function.
        pub fn getBridgeInfo(
            &self,
            bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBridgeInfoCall, N> {
            self.call_builder(&getBridgeInfoCall { bridge })
        }
        ///Creates a new call builder for the [`getBridgeUtilization`] function.
        pub fn getBridgeUtilization(
            &self,
            bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBridgeUtilizationCall, N> {
            self.call_builder(&getBridgeUtilizationCall { bridge })
        }
        ///Creates a new call builder for the [`getCurrentEpochInfo`] function.
        pub fn getCurrentEpochInfo(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getCurrentEpochInfoCall, N> {
            self.call_builder(&getCurrentEpochInfoCall {})
        }
        ///Creates a new call builder for the [`getCurrentTotalSupply`] function.
        pub fn getCurrentTotalSupply(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getCurrentTotalSupplyCall, N> {
            self.call_builder(&getCurrentTotalSupplyCall {})
        }
        ///Creates a new call builder for the [`getEmissionSchedule`] function.
        pub fn getEmissionSchedule(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getEmissionScheduleCall, N> {
            self.call_builder(&getEmissionScheduleCall {})
        }
        ///Creates a new call builder for the [`getPastTotalSupply`] function.
        pub fn getPastTotalSupply(
            &self,
            timepoint: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getPastTotalSupplyCall, N> {
            self.call_builder(
                &getPastTotalSupplyCall {
                    timepoint,
                },
            )
        }
        ///Creates a new call builder for the [`getPastVotes`] function.
        pub fn getPastVotes(
            &self,
            account: alloy::sol_types::private::Address,
            timepoint: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getPastVotesCall, N> {
            self.call_builder(
                &getPastVotesCall {
                    account,
                    timepoint,
                },
            )
        }
        ///Creates a new call builder for the [`getPastVotingPower`] function.
        pub fn getPastVotingPower(
            &self,
            account: alloy::sol_types::private::Address,
            blockNumber: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getPastVotingPowerCall, N> {
            self.call_builder(
                &getPastVotingPowerCall {
                    account,
                    blockNumber,
                },
            )
        }
        ///Creates a new call builder for the [`getRemainingEmissions`] function.
        pub fn getRemainingEmissions(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRemainingEmissionsCall, N> {
            self.call_builder(&getRemainingEmissionsCall {})
        }
        ///Creates a new call builder for the [`getRoleAdmin`] function.
        pub fn getRoleAdmin(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRoleAdminCall, N> {
            self.call_builder(&getRoleAdminCall { role })
        }
        ///Creates a new call builder for the [`getVotes`] function.
        pub fn getVotes(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getVotesCall, N> {
            self.call_builder(&getVotesCall { account })
        }
        ///Creates a new call builder for the [`getVotingPower`] function.
        pub fn getVotingPower(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getVotingPowerCall, N> {
            self.call_builder(&getVotingPowerCall { account })
        }
        ///Creates a new call builder for the [`grantRole`] function.
        pub fn grantRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, grantRoleCall, N> {
            self.call_builder(&grantRoleCall { role, account })
        }
        ///Creates a new call builder for the [`hasRole`] function.
        pub fn hasRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, hasRoleCall, N> {
            self.call_builder(&hasRoleCall { role, account })
        }
        ///Creates a new call builder for the [`isBridge`] function.
        pub fn isBridge(
            &self,
            bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, isBridgeCall, N> {
            self.call_builder(&isBridgeCall { bridge })
        }
        ///Creates a new call builder for the [`mint`] function.
        pub fn mint(
            &self,
            _user: alloy::sol_types::private::Address,
            _amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, mintCall, N> {
            self.call_builder(&mintCall { _user, _amount })
        }
        ///Creates a new call builder for the [`mintEmission`] function.
        pub fn mintEmission(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, mintEmissionCall, N> {
            self.call_builder(&mintEmissionCall {})
        }
        ///Creates a new call builder for the [`mintingCurrentLimitOf`] function.
        pub fn mintingCurrentLimitOf(
            &self,
            _bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, mintingCurrentLimitOfCall, N> {
            self.call_builder(
                &mintingCurrentLimitOfCall {
                    _bridge,
                },
            )
        }
        ///Creates a new call builder for the [`mintingMaxLimitOf`] function.
        pub fn mintingMaxLimitOf(
            &self,
            _bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, mintingMaxLimitOfCall, N> {
            self.call_builder(&mintingMaxLimitOfCall { _bridge })
        }
        ///Creates a new call builder for the [`name`] function.
        pub fn name(&self) -> alloy_contract::SolCallBuilder<T, &P, nameCall, N> {
            self.call_builder(&nameCall {})
        }
        ///Creates a new call builder for the [`nonces`] function.
        pub fn nonces(
            &self,
            owner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, noncesCall, N> {
            self.call_builder(&noncesCall { owner })
        }
        ///Creates a new call builder for the [`numCheckpoints`] function.
        pub fn numCheckpoints(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, numCheckpointsCall, N> {
            self.call_builder(&numCheckpointsCall { account })
        }
        ///Creates a new call builder for the [`pause`] function.
        pub fn pause(&self) -> alloy_contract::SolCallBuilder<T, &P, pauseCall, N> {
            self.call_builder(&pauseCall {})
        }
        ///Creates a new call builder for the [`pauseEmissions`] function.
        pub fn pauseEmissions(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, pauseEmissionsCall, N> {
            self.call_builder(&pauseEmissionsCall {})
        }
        ///Creates a new call builder for the [`paused`] function.
        pub fn paused(&self) -> alloy_contract::SolCallBuilder<T, &P, pausedCall, N> {
            self.call_builder(&pausedCall {})
        }
        ///Creates a new call builder for the [`permit`] function.
        pub fn permit(
            &self,
            owner: alloy::sol_types::private::Address,
            spender: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
            deadline: alloy::sol_types::private::primitives::aliases::U256,
            v: u8,
            r: alloy::sol_types::private::FixedBytes<32>,
            s: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, permitCall, N> {
            self.call_builder(
                &permitCall {
                    owner,
                    spender,
                    value,
                    deadline,
                    v,
                    r,
                    s,
                },
            )
        }
        ///Creates a new call builder for the [`renounceRole`] function.
        pub fn renounceRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            callerConfirmation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceRoleCall, N> {
            self.call_builder(
                &renounceRoleCall {
                    role,
                    callerConfirmation,
                },
            )
        }
        ///Creates a new call builder for the [`resumeEmissions`] function.
        pub fn resumeEmissions(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, resumeEmissionsCall, N> {
            self.call_builder(&resumeEmissionsCall {})
        }
        ///Creates a new call builder for the [`revokeRole`] function.
        pub fn revokeRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, revokeRoleCall, N> {
            self.call_builder(&revokeRoleCall { role, account })
        }
        ///Creates a new call builder for the [`setBridgeData`] function.
        pub fn setBridgeData(
            &self,
            _bridgeData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBridgeDataCall, N> {
            self.call_builder(&setBridgeDataCall { _bridgeData })
        }
        ///Creates a new call builder for the [`setBridgeProxy`] function.
        pub fn setBridgeProxy(
            &self,
            _bridgeProxy: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBridgeProxyCall, N> {
            self.call_builder(&setBridgeProxyCall { _bridgeProxy })
        }
        ///Creates a new call builder for the [`setLimits`] function.
        pub fn setLimits(
            &self,
            _bridge: alloy::sol_types::private::Address,
            _mintingLimit: alloy::sol_types::private::primitives::aliases::U256,
            _burningLimit: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, setLimitsCall, N> {
            self.call_builder(
                &setLimitsCall {
                    _bridge,
                    _mintingLimit,
                    _burningLimit,
                },
            )
        }
        ///Creates a new call builder for the [`startEmissions`] function.
        pub fn startEmissions(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, startEmissionsCall, N> {
            self.call_builder(&startEmissionsCall {})
        }
        ///Creates a new call builder for the [`supportsInterface`] function.
        pub fn supportsInterface(
            &self,
            interfaceId: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<T, &P, supportsInterfaceCall, N> {
            self.call_builder(
                &supportsInterfaceCall {
                    interfaceId,
                },
            )
        }
        ///Creates a new call builder for the [`symbol`] function.
        pub fn symbol(&self) -> alloy_contract::SolCallBuilder<T, &P, symbolCall, N> {
            self.call_builder(&symbolCall {})
        }
        ///Creates a new call builder for the [`totalEmissionsMinted`] function.
        pub fn totalEmissionsMinted(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, totalEmissionsMintedCall, N> {
            self.call_builder(&totalEmissionsMintedCall {})
        }
        ///Creates a new call builder for the [`totalSupply`] function.
        pub fn totalSupply(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, totalSupplyCall, N> {
            self.call_builder(&totalSupplyCall {})
        }
        ///Creates a new call builder for the [`transfer`] function.
        pub fn transfer(
            &self,
            to: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferCall, N> {
            self.call_builder(&transferCall { to, value })
        }
        ///Creates a new call builder for the [`transferFrom`] function.
        pub fn transferFrom(
            &self,
            from: alloy::sol_types::private::Address,
            to: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferFromCall, N> {
            self.call_builder(
                &transferFromCall {
                    from,
                    to,
                    value,
                },
            )
        }
        ///Creates a new call builder for the [`unpause`] function.
        pub fn unpause(&self) -> alloy_contract::SolCallBuilder<T, &P, unpauseCall, N> {
            self.call_builder(&unpauseCall {})
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyndicateTokenInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`Approval`] event.
        pub fn Approval_filter(&self) -> alloy_contract::Event<T, &P, Approval, N> {
            self.event_filter::<Approval>()
        }
        ///Creates a new event filter for the [`BridgeAuthorized`] event.
        pub fn BridgeAuthorized_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeAuthorized, N> {
            self.event_filter::<BridgeAuthorized>()
        }
        ///Creates a new event filter for the [`BridgeDataUpdated`] event.
        pub fn BridgeDataUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeDataUpdated, N> {
            self.event_filter::<BridgeDataUpdated>()
        }
        ///Creates a new event filter for the [`BridgeDeauthorized`] event.
        pub fn BridgeDeauthorized_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeDeauthorized, N> {
            self.event_filter::<BridgeDeauthorized>()
        }
        ///Creates a new event filter for the [`BridgeLimitsSet`] event.
        pub fn BridgeLimitsSet_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeLimitsSet, N> {
            self.event_filter::<BridgeLimitsSet>()
        }
        ///Creates a new event filter for the [`BridgeProxyUpdated`] event.
        pub fn BridgeProxyUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeProxyUpdated, N> {
            self.event_filter::<BridgeProxyUpdated>()
        }
        ///Creates a new event filter for the [`DelegateChanged`] event.
        pub fn DelegateChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, DelegateChanged, N> {
            self.event_filter::<DelegateChanged>()
        }
        ///Creates a new event filter for the [`DelegateVotesChanged`] event.
        pub fn DelegateVotesChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, DelegateVotesChanged, N> {
            self.event_filter::<DelegateVotesChanged>()
        }
        ///Creates a new event filter for the [`EIP712DomainChanged`] event.
        pub fn EIP712DomainChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EIP712DomainChanged, N> {
            self.event_filter::<EIP712DomainChanged>()
        }
        ///Creates a new event filter for the [`EmissionMinted`] event.
        pub fn EmissionMinted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EmissionMinted, N> {
            self.event_filter::<EmissionMinted>()
        }
        ///Creates a new event filter for the [`EmissionsPaused`] event.
        pub fn EmissionsPaused_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EmissionsPaused, N> {
            self.event_filter::<EmissionsPaused>()
        }
        ///Creates a new event filter for the [`EmissionsResumed`] event.
        pub fn EmissionsResumed_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EmissionsResumed, N> {
            self.event_filter::<EmissionsResumed>()
        }
        ///Creates a new event filter for the [`EmissionsStarted`] event.
        pub fn EmissionsStarted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EmissionsStarted, N> {
            self.event_filter::<EmissionsStarted>()
        }
        ///Creates a new event filter for the [`Paused`] event.
        pub fn Paused_filter(&self) -> alloy_contract::Event<T, &P, Paused, N> {
            self.event_filter::<Paused>()
        }
        ///Creates a new event filter for the [`RoleAdminChanged`] event.
        pub fn RoleAdminChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleAdminChanged, N> {
            self.event_filter::<RoleAdminChanged>()
        }
        ///Creates a new event filter for the [`RoleGranted`] event.
        pub fn RoleGranted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleGranted, N> {
            self.event_filter::<RoleGranted>()
        }
        ///Creates a new event filter for the [`RoleRevoked`] event.
        pub fn RoleRevoked_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleRevoked, N> {
            self.event_filter::<RoleRevoked>()
        }
        ///Creates a new event filter for the [`Transfer`] event.
        pub fn Transfer_filter(&self) -> alloy_contract::Event<T, &P, Transfer, N> {
            self.event_filter::<Transfer>()
        }
        ///Creates a new event filter for the [`Unpaused`] event.
        pub fn Unpaused_filter(&self) -> alloy_contract::Event<T, &P, Unpaused, N> {
            self.event_filter::<Unpaused>()
        }
    }
}
