///Module containing a contract's types and functions.
/**

```solidity
library Checkpoints {
    struct Checkpoint208 { uint48 _key; uint208 _value; }
}
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod Checkpoints {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /**```solidity
struct Checkpoint208 { uint48 _key; uint208 _value; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Checkpoint208 {
        #[allow(missing_docs)]
        pub _key: alloy::sol_types::private::primitives::aliases::U48,
        #[allow(missing_docs)]
        pub _value: alloy::sol_types::private::primitives::aliases::U208,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<48>,
            alloy::sol_types::sol_data::Uint<208>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U48,
            alloy::sol_types::private::primitives::aliases::U208,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Checkpoint208> for UnderlyingRustTuple<'_> {
            fn from(value: Checkpoint208) -> Self {
                (value._key, value._value)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Checkpoint208 {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    _key: tuple.0,
                    _value: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Checkpoint208 {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Checkpoint208 {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(&self._key),
                    <alloy::sol_types::sol_data::Uint<
                        208,
                    > as alloy_sol_types::SolType>::tokenize(&self._value),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Checkpoint208 {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Checkpoint208 {
            const NAME: &'static str = "Checkpoint208";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Checkpoint208(uint48 _key,uint208 _value)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self._key)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        208,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self._value)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Checkpoint208 {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust._key)
                    + <alloy::sol_types::sol_data::Uint<
                        208,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust._value,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    48,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust._key,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    208,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust._value,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`Checkpoints`](self) contract instance.

See the [wrapper's documentation](`CheckpointsInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> CheckpointsInstance<T, P, N> {
        CheckpointsInstance::<T, P, N>::new(address, provider)
    }
    /**A [`Checkpoints`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`Checkpoints`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct CheckpointsInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for CheckpointsInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("CheckpointsInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > CheckpointsInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`Checkpoints`](self) contract instance.

See the [wrapper's documentation](`CheckpointsInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> CheckpointsInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> CheckpointsInstance<T, P, N> {
            CheckpointsInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > CheckpointsInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > CheckpointsInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
/**

Generated by the following Solidity interface...
```solidity
library Checkpoints {
    struct Checkpoint208 {
        uint48 _key;
        uint208 _value;
    }
}

interface SyndicateToken {
    error AccessControlBadConfirmation();
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
    error AllEmissionsCompleted();
    error BridgeNotAuthorized();
    error BridgeNotConfigured();
    error CheckpointUnorderedInsertion();
    error ECDSAInvalidSignature();
    error ECDSAInvalidSignatureLength(uint256 length);
    error ECDSAInvalidSignatureS(bytes32 s);
    error ERC20ExceededSafeSupply(uint256 increasedSupply, uint256 cap);
    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);
    error ERC20InvalidApprover(address approver);
    error ERC20InvalidReceiver(address receiver);
    error ERC20InvalidSender(address sender);
    error ERC20InvalidSpender(address spender);
    error ERC2612ExpiredSignature(uint256 deadline);
    error ERC2612InvalidSigner(address signer, address owner);
    error ERC5805FutureLookup(uint256 timepoint, uint48 clock);
    error ERC6372InconsistentClock();
    error EmissionTooEarly();
    error EmissionsAlreadyStarted();
    error EmissionsNotActive();
    error EmissionsNotStarted();
    error EnforcedPause();
    error ExceedsEmissionsSupply();
    error ExpectedPause();
    error InsufficientLimit();
    error InvalidAccountNonce(address account, uint256 currentNonce);
    error InvalidShortString();
    error ReentrancyGuardReentrantCall();
    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);
    error StringTooLong(string str);
    error VotesExpiredSignature(uint256 expiry);
    error ZeroAddress();
    error ZeroAmount();

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event BridgeAuthorized(address indexed bridge);
    event BridgeDataUpdated(bytes oldData, bytes newData);
    event BridgeDeauthorized(address indexed bridge);
    event BridgeLimitsSet(address indexed bridge, uint256 mintingLimit, uint256 burningLimit);
    event BridgeProxyUpdated(address indexed oldProxy, address indexed newProxy);
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    event DelegateVotesChanged(address indexed delegate, uint256 previousVotes, uint256 newVotes);
    event EIP712DomainChanged();
    event EmissionMinted(uint256 epoch, uint256 amount, address indexed destination);
    event EmissionsPaused();
    event EmissionsResumed();
    event EmissionsStarted(uint256 startTime);
    event Paused(address account);
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Unpaused(address account);

    constructor(address defaultAdmin, address syndFoundationAddress, address emissionsManager, address pauser);

    function BRIDGE_LIMIT_DURATION() external view returns (uint256);
    function BRIDGE_MANAGER_ROLE() external view returns (bytes32);
    function CLOCK_MODE() external view returns (string memory);
    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function EMISSIONS_MANAGER_ROLE() external view returns (bytes32);
    function EMISSIONS_SUPPLY() external view returns (uint256);
    function EMISSION_BUFFER_TIME() external view returns (uint256);
    function EPOCH_DURATION() external view returns (uint256);
    function INITIAL_MINT_SUPPLY() external view returns (uint256);
    function PAUSER_ROLE() external view returns (bytes32);
    function PRECISION_MULTIPLIER() external view returns (uint256);
    function TOTAL_EPOCHS() external view returns (uint256);
    function TOTAL_SUPPLY() external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
    function authorizedBridges(address) external view returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function bridgeData() external view returns (bytes memory);
    function bridgeLimits(address) external view returns (uint256 mintingMaxLimit, uint256 mintingCurrentLimit, uint256 burningMaxLimit, uint256 burningCurrentLimit, uint256 lastUpdate);
    function bridgeProxy() external view returns (address);
    function burn(address _user, uint256 _amount) external;
    function burningCurrentLimitOf(address _bridge) external view returns (uint256);
    function burningMaxLimitOf(address _bridge) external view returns (uint256);
    function checkpoints(address account, uint32 pos) external view returns (Checkpoints.Checkpoint208 memory);
    function clock() external view returns (uint48);
    function currentEpoch() external view returns (uint256);
    function decimals() external view returns (uint8);
    function delegate(address delegatee) external;
    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;
    function delegates(address account) external view returns (address);
    function eip712Domain() external view returns (bytes1 fields, string memory name, string memory version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] memory extensions);
    function emissionSchedule(uint256) external view returns (uint256);
    function emissionsActive() external view returns (bool);
    function emissionsEnded() external view returns (bool);
    function emissionsStartTime() external view returns (uint256);
    function emissionsStarted() external view returns (bool);
    function getBridgeConfiguration() external view returns (address proxy, bytes memory data);
    function getBridgeInfo(address bridge) external view returns (bool authorized, uint256 mintingMax, uint256 mintingCurrent, uint256 burningMax, uint256 burningCurrent);
    function getBridgeUtilization(address bridge) external view returns (uint256 mintingUtilization, uint256 burningUtilization);
    function getCurrentEpochInfo() external view returns (uint256 epoch, uint256 nextEmissionTime, uint256 nextEmissionAmount, bool canMintEmission);
    function getCurrentTotalSupply() external view returns (uint256);
    function getEmissionSchedule() external view returns (uint256[48] memory);
    function getNextEmissionTime() external view returns (uint256);
    function getPastTotalSupply(uint256 timepoint) external view returns (uint256);
    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);
    function getPastVotingPower(address account, uint256 blockNumber) external view returns (uint256);
    function getRemainingEmissions() external view returns (uint256);
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function getVotes(address account) external view returns (uint256);
    function getVotingPower(address account) external view returns (uint256);
    function grantRole(bytes32 role, address account) external;
    function hasRole(bytes32 role, address account) external view returns (bool);
    function isBridge(address bridge) external view returns (bool);
    function mint(address _user, uint256 _amount) external;
    function mintEmission() external;
    function mintingCurrentLimitOf(address _bridge) external view returns (uint256);
    function mintingMaxLimitOf(address _bridge) external view returns (uint256);
    function name() external view returns (string memory);
    function nonces(address owner) external view returns (uint256);
    function numCheckpoints(address account) external view returns (uint32);
    function pause() external;
    function pauseEmissions() external;
    function paused() external view returns (bool);
    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
    function renounceRole(bytes32 role, address callerConfirmation) external;
    function resumeEmissions() external;
    function revokeRole(bytes32 role, address account) external;
    function setBridgeData(bytes memory _bridgeData) external;
    function setBridgeProxy(address _bridgeProxy) external;
    function setLimits(address _bridge, uint256 _mintingLimit, uint256 _burningLimit) external;
    function startEmissions() external;
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
    function symbol() external view returns (string memory);
    function totalEmissionsMinted() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
    function unpause() external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "defaultAdmin",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "syndFoundationAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "emissionsManager",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "pauser",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "BRIDGE_LIMIT_DURATION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "BRIDGE_MANAGER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "CLOCK_MODE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DEFAULT_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DOMAIN_SEPARATOR",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSIONS_MANAGER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSIONS_SUPPLY",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSION_BUFFER_TIME",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EPOCH_DURATION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "INITIAL_MINT_SUPPLY",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "PAUSER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "PRECISION_MULTIPLIER",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "TOTAL_EPOCHS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "TOTAL_SUPPLY",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "allowance",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "approve",
    "inputs": [
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "authorizedBridges",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "balanceOf",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeData",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeLimits",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "mintingMaxLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "mintingCurrentLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "burningMaxLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "burningCurrentLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "lastUpdate",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeProxy",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IBridgeProxy"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "burn",
    "inputs": [
      {
        "name": "_user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "burningCurrentLimitOf",
    "inputs": [
      {
        "name": "_bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "burningMaxLimitOf",
    "inputs": [
      {
        "name": "_bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "checkpoints",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "pos",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct Checkpoints.Checkpoint208",
        "components": [
          {
            "name": "_key",
            "type": "uint48",
            "internalType": "uint48"
          },
          {
            "name": "_value",
            "type": "uint208",
            "internalType": "uint208"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "clock",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint48",
        "internalType": "uint48"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "currentEpoch",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "decimals",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "uint8"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "delegate",
    "inputs": [
      {
        "name": "delegatee",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "delegateBySig",
    "inputs": [
      {
        "name": "delegatee",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "nonce",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "expiry",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "v",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "r",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "delegates",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "eip712Domain",
    "inputs": [],
    "outputs": [
      {
        "name": "fields",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "version",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "verifyingContract",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "salt",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "extensions",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionSchedule",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionsActive",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionsEnded",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionsStartTime",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionsStarted",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBridgeConfiguration",
    "inputs": [],
    "outputs": [
      {
        "name": "proxy",
        "type": "address",
        "internalType": "contract IBridgeProxy"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBridgeInfo",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "authorized",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "mintingMax",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "mintingCurrent",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "burningMax",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "burningCurrent",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBridgeUtilization",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "mintingUtilization",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "burningUtilization",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCurrentEpochInfo",
    "inputs": [],
    "outputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nextEmissionTime",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nextEmissionAmount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "canMintEmission",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCurrentTotalSupply",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getEmissionSchedule",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256[48]",
        "internalType": "uint256[48]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getNextEmissionTime",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPastTotalSupply",
    "inputs": [
      {
        "name": "timepoint",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPastVotes",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "timepoint",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPastVotingPower",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "blockNumber",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRemainingEmissions",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleAdmin",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getVotes",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getVotingPower",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "grantRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "hasRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isBridge",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "mint",
    "inputs": [
      {
        "name": "_user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "mintEmission",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "mintingCurrentLimitOf",
    "inputs": [
      {
        "name": "_bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "mintingMaxLimitOf",
    "inputs": [
      {
        "name": "_bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "name",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "nonces",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "numCheckpoints",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "pauseEmissions",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "paused",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "permit",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "deadline",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "v",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "r",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "callerConfirmation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "resumeEmissions",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBridgeData",
    "inputs": [
      {
        "name": "_bridgeData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBridgeProxy",
    "inputs": [
      {
        "name": "_bridgeProxy",
        "type": "address",
        "internalType": "contract IBridgeProxy"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setLimits",
    "inputs": [
      {
        "name": "_bridge",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_mintingLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "_burningLimit",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "startEmissions",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "symbol",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "totalEmissionsMinted",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "totalSupply",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "transfer",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferFrom",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "unpause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "Approval",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "spender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeAuthorized",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeDataUpdated",
    "inputs": [
      {
        "name": "oldData",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      },
      {
        "name": "newData",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeDeauthorized",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeLimitsSet",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "mintingLimit",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "burningLimit",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeProxyUpdated",
    "inputs": [
      {
        "name": "oldProxy",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newProxy",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DelegateChanged",
    "inputs": [
      {
        "name": "delegator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "fromDelegate",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "toDelegate",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DelegateVotesChanged",
    "inputs": [
      {
        "name": "delegate",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "previousVotes",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "newVotes",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EIP712DomainChanged",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EmissionMinted",
    "inputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "destination",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EmissionsPaused",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EmissionsResumed",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EmissionsStarted",
    "inputs": [
      {
        "name": "startTime",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Paused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleAdminChanged",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "previousAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleGranted",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleRevoked",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Transfer",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Unpaused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AccessControlBadConfirmation",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AccessControlUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "neededRole",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "AllEmissionsCompleted",
    "inputs": []
  },
  {
    "type": "error",
    "name": "BridgeNotAuthorized",
    "inputs": []
  },
  {
    "type": "error",
    "name": "BridgeNotConfigured",
    "inputs": []
  },
  {
    "type": "error",
    "name": "CheckpointUnorderedInsertion",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignature",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureLength",
    "inputs": [
      {
        "name": "length",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureS",
    "inputs": [
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20ExceededSafeSupply",
    "inputs": [
      {
        "name": "increasedSupply",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "cap",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InsufficientAllowance",
    "inputs": [
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "allowance",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "needed",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InsufficientBalance",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "balance",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "needed",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidApprover",
    "inputs": [
      {
        "name": "approver",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidReceiver",
    "inputs": [
      {
        "name": "receiver",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidSender",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidSpender",
    "inputs": [
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC2612ExpiredSignature",
    "inputs": [
      {
        "name": "deadline",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC2612InvalidSigner",
    "inputs": [
      {
        "name": "signer",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC5805FutureLookup",
    "inputs": [
      {
        "name": "timepoint",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "clock",
        "type": "uint48",
        "internalType": "uint48"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC6372InconsistentClock",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmissionTooEarly",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmissionsAlreadyStarted",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmissionsNotActive",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmissionsNotStarted",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EnforcedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ExceedsEmissionsSupply",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ExpectedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientLimit",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidAccountNonce",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "currentNonce",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidShortString",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ReentrancyGuardReentrantCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SafeCastOverflowedUintDowncast",
    "inputs": [
      {
        "name": "bits",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "StringTooLong",
    "inputs": [
      {
        "name": "str",
        "type": "string",
        "internalType": "string"
      }
    ]
  },
  {
    "type": "error",
    "name": "VotesExpiredSignature",
    "inputs": [
      {
        "name": "expiry",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ZeroAddress",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroAmount",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod SyndicateToken {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x610160604052346100765761001e610015610163565b9291909161035d565b61002661007b565b6176416120b9823960805181614fbc015260a05181614ff3015260c05181614f83015260e05181615bdb01526101005181615c000152610120518161578d015261014051816157cd015261764190f35b610081565b60405190565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b906100ad90610085565b810190811060018060401b038211176100c557604052565b61008f565b906100dd6100d661007b565b92836100a3565b565b5f80fd5b60018060a01b031690565b6100f7906100e3565b90565b610103816100ee565b0361010a57565b5f80fd5b9050519061011b826100fa565b565b60808183031261015e57610133825f830161010e565b9261015b610144846020850161010e565b93610152816040860161010e565b9360600161010e565b90565b6100df565b6101816196fa80380380610176816100ca565b92833981019061011d565b90919293565b60018060401b0381116101a35761019f602091610085565b0190565b61008f565b906101ba6101b583610187565b6100ca565b918252565b5f7f53796e6469636174650000000000000000000000000000000000000000000000910152565b6101f060096101a8565b906101fd602083016101bf565b565b6102076101e6565b90565b5f7f53594e4400000000000000000000000000000000000000000000000000000000910152565b61023b60046101a8565b906102486020830161020a565b565b610252610231565b90565b90565b90565b61026f61026a61027492610255565b610258565b6100e3565b90565b6102809061025b565b90565b5f0190565b90565b5f1b90565b6102a461029f6102a992610255565b61028b565b610288565b90565b6102b55f610290565b90565b7f6b9725f740f94b91b78060a1b17d1774656d381421a529ec98cdb013f4d9c25e90565b7fcce296b040332a080e6df13515a3ec2869e21cd20f7344af0987ddb938d8bd2190565b7f65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a90565b90565b90565b61033e61033961034392610324565b610258565b610327565b90565b61035a6a4a723dc6b40b8a9a00000061032a565b90565b90919261037961036b6101ff565b61037361024a565b90610516565b8161039461038e6103895f610277565b6100ee565b916100ee565b146104b057826103b46103ae6103a95f610277565b6100ee565b916100ee565b1461049457836103d46103ce6103c95f610277565b6100ee565b916100ee565b1461047857806103f46103ee6103e95f610277565b6100ee565b916100ee565b1461045c5761043561044392610427610452966104196104126102ac565b8490610a3a565b506104226102b8565b610a3a565b506104306102dc565b610a3a565b5061043e610300565b610a3a565b5061044c610346565b90610b08565b61045a610e10565b565b5f63d92e233d60e01b81528061047460048201610283565b0390fd5b5f63d92e233d60e01b81528061049060048201610283565b0390fd5b5f63d92e233d60e01b8152806104ac60048201610283565b0390fd5b5f63d92e233d60e01b8152806104c860048201610283565b0390fd5b906104d860ff9161028b565b9181191691161790565b151590565b6104f0906104e2565b90565b90565b9061050b610506610512926104e7565b6104f3565b82546104cc565b9055565b906105209161052d565b61052b5f600f6104f6565b565b610539918190916105bc565b565b90565b61055261054d6105579261053b565b610258565b610327565b90565b610564600161053e565b90565b906105735f199161028b565b9181191691161790565b61059161058c61059692610327565b610258565b610327565b90565b90565b906105b16105ac6105b89261057d565b610599565b8254610567565b9055565b906105c792916105db565b6105d96105d261055a565b600c61059c565b565b906105e692916105e8565b565b906105f392916105f5565b565b906106009291610602565b565b9061060d929161060f565b565b9061061a929161061c565b565b906106279291610674565b565b5f7f3100000000000000000000000000000000000000000000000000000000000000910152565b61065a60016101a8565b9061066760208301610629565b565b610671610650565b90565b906106889291610682610669565b9061068a565b565b906106969392916106dc565b565b90565b90565b60200190565b5190565b6106bc6106b76106c1926100e3565b610258565b6100e3565b90565b6106cd906106a8565b90565b6106d9906106c4565b90565b6106ed61073d946107229394610771565b610701816106fb6006610698565b9061103a565b61012052610719836107136007610698565b9061103a565b6101405261069b565b61073461072e826106a4565b9161069e565b2060e05261069b565b61074f610749826106a4565b9161069e565b20610100524660a05261076061113f565b60805261076c306106d0565b60c052565b9061077b9161077d565b565b9061078791610789565b565b90610793916109da565b565b634e487b7160e01b5f525f60045260245ffd5b5190565b634e487b7160e01b5f52602260045260245ffd5b90600160028304921680156107e0575b60208310146107db57565b6107ac565b91607f16916107d0565b5f5260205f2090565b601f602091010490565b1b90565b9190600861081c9102916108165f19846107fd565b926107fd565b9181191691161790565b919061083c6108376108449361057d565b610599565b908354610801565b9055565b5f90565b61085e91610858610848565b91610826565b565b5b81811061086c575050565b806108795f60019361084c565b01610861565b9190601f811161088f575b505050565b61089b6108c0936107ea565b9060206108a7846107f3565b830193106108c8575b6108b9906107f3565b0190610860565b5f808061088a565b91506108b9819290506108b0565b1c90565b906108ea905f19906008026108d6565b191690565b816108f9916108da565b906002021790565b9061090b816107a8565b9060018060401b0382116109c95761092d8261092785546107c0565b8561087f565b602090601f831160011461096157918091610950935f92610955575b50506108ef565b90555b565b90915001515f80610949565b601f19831691610970856107ea565b925f5b8181106109b157509160029391856001969410610997575b50505002019055610953565b6109a7910151601f8416906108da565b90555f808061098b565b91936020600181928787015181550195019201610973565b61008f565b906109d891610901565b565b906109e96109f09260036109ce565b60046109ce565b565b5f90565b6109ff90610288565b90565b90610a0c906109f6565b5f5260205260405f2090565b610a21906106c4565b90565b90610a2e90610a18565b5f5260205260405f2090565b610a426109f2565b50610a57610a518284906111dc565b156104e2565b5f14610ae057610a7f6001610a7a5f610a7260058690610a02565b018590610a24565b6104f6565b90610a8861120a565b90610ac5610abf610ab97f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d956109f6565b92610a18565b92610a18565b92610ace61007b565b80610ad881610283565b0390a4600190565b50505f90565b610aef906100ee565b9052565b9190610b06905f60208501940190610ae6565b565b80610b23610b1d610b185f610277565b6100ee565b916100ee565b14610b3f57610b3d91610b355f610277565b919091611217565b565b610b62610b4b5f610277565b5f91829163ec442f0560e01b835260048301610af3565b0390fd5b60018060401b038111610b795760200290565b61008f565b610b8a610b8f91610b66565b6100ca565b90565b90565b610ba9610ba4610bae92610b92565b610258565b610327565b90565b90610bbb90610327565b9052565b90565b610bd6610bd1610bdb92610bbf565b610258565b610327565b90565b90565b610bf5610bf0610bfa92610bde565b610258565b610327565b90565b90565b610c14610c0f610c1992610bfd565b610258565b610327565b90565b90565b610c33610c2e610c3892610c1c565b610258565b610327565b90565b90565b610c52610c4d610c5792610c3b565b610258565b610327565b90565b90565b610c71610c6c610c7692610c5a565b610258565b610327565b90565b90565b610c90610c8b610c9592610c79565b610258565b610327565b90565b610cac610ca7610cb192610255565b610258565b610327565b90565b6001610cc09101610327565b90565b90565b610cda610cd5610cdf92610cc3565b610258565b610327565b90565b90565b610cf9610cf4610cfe92610ce2565b610258565b610327565b90565b634e487b7160e01b5f52601160045260245ffd5b610d24610d2a91939293610327565b92610327565b91610d36838202610327565b928184041490151715610d4557565b610d01565b610d59610d5f91939293610327565b92610327565b8201809211610d6a57565b610d01565b90565b610d86610d81610d8b92610d6f565b610258565b610327565b90565b610d986030610d72565b90565b634e487b7160e01b5f52603260045260245ffd5b50600890565b90610dbf82610daf565b811015610dcd576020020190565b610d9b565b610ddc9051610327565b90565b50603090565b90565b610df181610ddf565b821015610e0b57610e03600191610de5565b910201905f90565b610d9b565b610e1a6008610b7e565b610e38610e30698f956f697aa4923c0000610b95565b5f8301610bb1565b610e57610e4e695626760c1662be240000610bc2565b60208301610bb1565b610e76610e6d6933b0b000fec593900000610be1565b60408301610bb1565b610e95610e8c691f039ccd65a9bef00000610c00565b60608301610bb1565b610eb4610eab69129bc47b3cff72900000610c1f565b60808301610bb1565b610ed3610eca690b2a483d6dadee180000610c3e565b60a08301610bb1565b610ef2610ee96906b2efd13a962a6c0000610c5d565b60c08301610bb1565b610f11610f08690404f64a565a19740000610c7c565b60e08301610bb1565b610f1a5f610c98565b915b82610f30610f2a6008610cc6565b91610327565b1015610fe657610f3f5f610c98565b5b80610f54610f4e6006610ce5565b91610327565b1015610fd557610fa290610f7c610f7586610f6f6006610ce5565b90610d15565b8290610d4a565b80610f96610f90610f8b610d8e565b610327565b91610327565b10610fa7575b50610cb4565b610f40565b610fcf90610fc9610fc1610fbc888a90610db5565b610dd2565b916010610de8565b90610826565b5f610f9c565b5091610fe090610cb4565b91610f1c565b915050565b5f90565b90565b61100661100161100b92610fef565b610258565b610327565b90565b90565b61102561102061102a9261100e565b61028b565b610288565b90565b61103760ff611011565b90565b90611043610feb565b506110556110508361069b565b6106a4565b6110686110626020610ff2565b91610327565b105f1461107c575061107990611316565b90565b5f61108a6110909392611226565b016109ce565b6110a061109b61102d565b6109f6565b90565b5f90565b7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f90565b6110d59051610288565b90565b6110e190610288565b9052565b6110ee90610327565b9052565b9095949261113d9461112c6111369261112260809661111860a088019c5f8901906110d8565b60208701906110d8565b60408501906110d8565b60608301906110e5565b0190610ae6565b565b6111476110a3565b506111506110a7565b61119a61115d60e06110cb565b9161118b61116c6101006110cb565b46611176306106d0565b9161117f61007b565b968795602087016110f2565b602082018103825203826100a3565b6111ac6111a6826106a4565b9161069e565b2090565b5f1c90565b60ff1690565b6111c76111cc916111b0565b6111b5565b90565b6111d990546111bb565b90565b611203915f6111f86111fe936111f06109f2565b506005610a02565b01610a24565b6111cf565b90565b5f90565b611212611206565b503390565b91611224929190916113c3565b565b90565b90565b61124061123b61124592611229565b610258565b610327565b90565b60209181520190565b90825f9392825e0152565b61127b61128460209361128993611272816107a8565b93848093611248565b95869101611251565b610085565b0190565b6112a29160208201915f81840391015261125c565b90565b6112bf6112ba6112b4836106a4565b9261069e565b6110cb565b90602081106112cd575b5090565b6112df905f19906020036008026107fd565b165f6112c9565b6112f26112f7916111b0565b61057d565b90565b61130e61130961131392610327565b61028b565b610288565b90565b61131e610feb565b506113288161069b565b90611332826106a4565b61134561133f601f61122c565b91610327565b1161137a57506113728161136c611366611361611377956112a5565b6112e6565b916106a4565b176112fa565b6109f6565b90565b61139c9061138661007b565b91829163305a27a960e01b83526004830161128d565b0390fd5b9160206113c19294936113ba60408201965f8301906110e5565b01906110e5565b565b92916113d1848383916114f0565b836113ec6113e66113e15f610277565b6100ee565b916100ee565b14611401575b6113ff92939190916116bd565b565b61140961165f565b9361141261169c565b948061142661142088610327565b91610327565b11611433575093506113f2565b859061144f5f928392630e58ae9360e11b8452600484016113a0565b0390fd5b9061145d90610a18565b5f5260205260405f2090565b90565b61147861147d916111b0565b611469565b90565b61148a905461146c565b90565b6040906114b66114bd94969593966114ac60608401985f850190610ae6565b60208301906110e5565b01906110e5565b565b906114ca9103610327565b90565b906114d89101610327565b90565b91906114ee905f602085019401906110e5565b565b9190918061150e6115086115035f610277565b6100ee565b916100ee565b145f146115ef5761153261152b836115266002611480565b610d4a565b600261059c565b5b8261154e6115486115435f610277565b6100ee565b916100ee565b145f146115c35761157261156b836115666002611480565b6114bf565b600261059c565b5b9190916115be6115ac6115a67fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef93610a18565b93610a18565b936115b561007b565b918291826114db565b0390a3565b6115ea826115e46115d55f8790611453565b916115df83611480565b6114cd565b9061059c565b611573565b6116026115fd5f8390611453565b611480565b8061161561160f85610327565b91610327565b1061163d576116286116389184906114bf565b6116335f8490611453565b61059c565b611533565b9061165b9091925f93849363391434e360e21b85526004850161148d565b0390fd5b611667610848565b506116726002611480565b90565b60018060d01b031690565b61169461168f61169992611675565b610258565b610327565b90565b6116a4610848565b506116b460018060d01b03611680565b90565b90565b90565b9161171561170f61171c94806116e36116dd6116d85f610277565b6100ee565b916100ee565b1461174d575b846117046116fe6116f95f610277565b6100ee565b916100ee565b1461171e575b611945565b92611945565b909161197a565b565b611746600b600261174061173a6117348961182f565b936116b7565b916116ba565b90611882565b505061170a565b611775600b600161176f6117696117638961182f565b936116b7565b916116ba565b90611882565b50506116e9565b5f90565b61178c61179291611675565b91611675565b019060018060d01b0382116117a357565b610d01565b906117bb916117b561177c565b50611780565b90565b90565b60ff1690565b6117db6117d66117e0926117be565b610258565b6117c1565b90565b6117ec906117c7565b9052565b91602061181192949361180a60408201965f8301906117e3565b01906110e5565b565b61182761182261182c92610327565b610258565b611675565b90565b61183761177c565b508061185161184b60018060d01b03611680565b91610327565b116118625761185f90611813565b90565b60d061187e5f9283926306dfcc6560e41b8452600484016117f0565b0390fd5b906118b86118be939261189361177c565b5061189c61177c565b5080936118b16118aa611b2c565b9492611bba565b9091612089565b91611c2f565b91909190565b6118d06118d691611675565b91611675565b90039060018060d01b0382116118e857565b610d01565b90611900916118fa61177c565b506118c4565b90565b9061190d90610a18565b5f5260205260405f2090565b60018060a01b031690565b611930611935916111b0565b611919565b90565b6119429054611924565b90565b61195c61196191611954611206565b506009611903565b611938565b90565b9061196e90610a18565b5f5260205260405f2090565b9190918061199061198a856100ee565b916100ee565b141580611b0e575b6119a2575b505050565b806119bd6119b76119b25f610277565b6100ee565b916100ee565b03611a7e575b50816119df6119d96119d45f610277565b6100ee565b916100ee565b036119eb575b8061199d565b611a32611a25611a2c92611a01600a8690611964565b90611a1f611a19611a1360019361182f565b936116b7565b916116ba565b90611882565b9290611680565b91611680565b919091611a5f7fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a72492610a18565b92611a74611a6b61007b565b928392836113a0565b0390a25f806119e5565b611abd611ac3611ab6611a93600a8590611964565b6002611ab0611aaa611aa48961182f565b936116b7565b916116ba565b90611882565b9290611680565b91611680565b919091611af07fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a72492610a18565b92611b05611afc61007b565b928392836113a0565b0390a25f6119c3565b5081611b22611b1c5f610c98565b91610327565b11611998565b5f90565b611b34611b28565b50611b3d611c5e565b90565b5490565b611b53611b5991939293610327565b92610327565b8203918211611b6457565b610d01565b90565b60301c90565b60018060d01b031690565b611b89611b8e91611b6c565b611b72565b90565b611b9b9054611b7d565b90565b611bb2611bad611bb792610255565b610258565b611675565b90565b611bc261177c565b50611bce5f8201611b40565b80611be1611bdb5f610c98565b91610327565b145f14611bf7575050611bf35f611b9e565b5b90565b611c245f91611c1f611c1984611c2a960192611c13600161053e565b90611b44565b91611b69565b611c73565b01611b91565b611bf4565b91611c535f611c5894611c4061177c565b50611c4961177c565b5001929192611b69565b611e64565b91909190565b611c66611b28565b50611c7043612022565b90565b5f5260205f200190565b5490565b611c8b60406100ca565b90565b65ffffffffffff1690565b90611ca390611c8e565b9052565b90611cb190611675565b9052565b5f5260205f2090565b611cc781611c7d565b821015611ce157611cd9600191611cb5565b910201905f90565b610d9b565b611cf09051611c8e565b90565b90611d0465ffffffffffff9161028b565b9181191691161790565b611d22611d1d611d2792611c8e565b610258565b611c8e565b90565b90565b90611d42611d3d611d4992611d0e565b611d2a565b8254611cf3565b9055565b611d579051611675565b90565b60301b90565b90611d7265ffffffffffff1991611d5a565b9181191691161790565b611d90611d8b611d9592611675565b610258565b611675565b90565b90565b90611db0611dab611db792611d7c565b611d98565b8254611d60565b9055565b90611de560205f611deb94611ddd828201611dd7848801611ce6565b90611d2d565b019201611d4d565b90611d9b565b565b9190611dfe57611dfc91611dbb565b565b610795565b9081549168010000000000000000831015611e335782611e2b916001611e3195018155611cbe565b90611ded565b565b61008f565b65ffffffffffff1690565b611e4f611e54916111b0565b611e38565b90565b611e619054611e43565b90565b90929192611e7061177c565b50611e7961177c565b50611e8382611c7d565b80611e96611e905f610c98565b91610327565b115f14611f6657611ebc90611eb68491611eb0600161053e565b90611b44565b90611c73565b90611ec85f8301611e57565b92611ed45f8401611b91565b9380611ee8611ee285611c8e565b91611c8e565b11611f4a57611eff611ef984611c8e565b91611c8e565b145f14611f1a575050611f15905f859101611d9b565b5b9190565b611f459250611f4086611f37611f2e611c81565b945f8601611c99565b60208401611ca7565b611e03565b611f16565b5f632520601d60e01b815280611f6260048201610283565b0390fd5b50611f9191611f8c85611f83611f7a611c81565b945f8601611c99565b60208401611ca7565b611e03565b611f9a5f611b9e565b9190565b611fb2611fad611fb792611c8e565b610258565b610327565b90565b611fce611fc9611fd392610d6f565b610258565b6117c1565b90565b611fdf90611fba565b9052565b916020612004929493611ffd60408201965f830190611fd6565b01906110e5565b565b61201a61201561201f92610327565b610258565b611c8e565b90565b61202a611b28565b508061204461203e65ffffffffffff611f9e565b91610327565b116120555761205290612006565b90565b60306120715f9283926306dfcc6560e41b845260048401611fe3565b0390fd5b634e487b7160e01b5f52605160045260245ffd5b919091806001146120a857600203612075576120a4916118ed565b905b565b506120b2916117a8565b906120a656fe60806040526004361015610013575b612542565b61001d5f3561050c565b806301ffc9a71461050757806306fdde031461050257806307a1d5fa146104fd578063095ea7b3146104f85780630c05f82c146104f357806313beaa5b146104ee57806318160ddd146104e95780631b02f845146104e457806322a97d9c146104df57806323b872dd146104da57806323e460d2146104d5578063243a30cc146104d05780632481bb5c146104cb578063248a9ca3146104c6578063284e1333146104c15780632f2ff15d146104bc578063313ce567146104b7578063334d0bbd146104b2578063359b76fe146104ad5780633644e515146104a857806336568abe146104a35780633a46b1a81461049e5780633f4ba83a1461049957806340c10f191461049457806344e181aa1461048f57806348b0daa61461048a5780634bdd36ce146104855780634bf5d7e914610480578063587cde1e1461047b5780635adf0021146104765780635c19a95c146104715780635c975abb1461046c5780635f15c3c914610467578063651fd268146104625780636c33bced1461045d5780636cf01625146104585780636fc063be146104535780636fcfff451461044e57806370a0823114610449578063726600ce14610444578063766718081461043f5780637c790cab1461043a5780637ecebe00146104355780638456cb591461043057806384b0196e1461042b5780638e539e8c14610426578063902d55a51461042157806391d148541461041c57806391ddadf41461041757806395d89b411461041257806399127d9b1461040d578063998955d3146104085780639ab24eb0146104035780639b7ef64b146103fe5780639dc29fac146103f9578063a08d5654146103f4578063a217fddf146103ef578063a3d4485b146103ea578063a4d7e31d146103e5578063a571e184146103e0578063a5b326be146103db578063a70b9f0c146103d6578063a9059cbb146103d1578063ae5ecbc6146103cc578063af2aa63b146103c7578063b0ca253e146103c2578063babc394f146103bd578063bb4d4436146103b8578063c02ae754146103b3578063c1eb7137146103ae578063c3cda520146103a9578063d505accf146103a4578063d547741f1461039f578063dd62ed3e1461039a578063e3abdfcb14610395578063e63ab1e914610390578063f1127ed81461038b578063f508e19d146103865763f75e85120361000e5761250d565b6124a9565b612464565b612381565b61231d565b6122b8565b612257565b61221d565b612173565b6120b7565b612082565b61204d565b612014565b611fa0565b611f6b565b611ec1565b611e4d565b611e18565b611daa565b611d77565b611cf5565b611cc0565b611c36565b611bc7565b611b59565b611b24565b611aae565b611a79565b611a44565b6119d6565b6119a1565b61193e565b611909565b611893565b611857565b611712565b6116dd565b6116a4565b611622565b6115de565b6115a9565b611574565b611514565b6114b0565b61143c565b611407565b6113d2565b611366565b611333565b6112fe565b6112c9565b611272565b61123d565b611208565b6111c0565b6110ab565b611078565b611042565b61100e565b610fd9565b610fa6565b610f71565b610e84565b610e28565b610dc8565b610d93565b610cf8565b610b29565b610abb565b610a62565b6109f3565b610981565b61094c565b610918565b61085d565b6107e7565b61072f565b610647565b610598565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b63ffffffff60e01b1690565b61053981610524565b0361054057565b5f80fd5b9050359061055182610530565b565b9060208282031261056c57610569915f01610544565b90565b61051c565b151590565b61057f90610571565b9052565b9190610596905f60208501940190610576565b565b346105c8576105c46105b36105ae366004610553565b6125df565b6105bb610512565b91829182610583565b0390f35b610518565b5f9103126105d757565b61051c565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b61061d61062660209361062b93610614816105dc565b938480936105e0565b958691016105e9565b6105f4565b0190565b6106449160208201915f8184039101526105fe565b90565b34610677576106573660046105cd565b6106736106626126fd565b61066a610512565b9182918261062f565b0390f35b610518565b60018060a01b031690565b90565b61069e6106996106a39261067c565b610687565b61067c565b90565b6106af9061068a565b90565b6106bb906106a6565b90565b6106c7906106b2565b9052565b5190565b60209181520190565b6106f7610700602093610705936106ee816106cb565b938480936106cf565b958691016105e9565b6105f4565b0190565b9161072c9261071f60408201935f8301906106be565b60208184039101526106d8565b90565b346107605761073f3660046105cd565b610747612749565b9061075c610753610512565b92839283610709565b0390f35b610518565b61076e9061067c565b90565b61077a81610765565b0361078157565b5f80fd5b9050359061079282610771565b565b90565b6107a081610794565b036107a757565b5f80fd5b905035906107b882610797565b565b91906040838203126107e257806107d66107df925f8601610785565b936020016107ab565b90565b61051c565b34610818576108146108036107fd3660046107ba565b90612773565b61080b610512565b91829182610583565b0390f35b610518565b9060208282031261083657610833915f01610785565b90565b61051c565b61084490610794565b9052565b919061085b905f6020850194019061083b565b565b3461088d5761088961087861087336600461081d565b612799565b610880610512565b91829182610848565b0390f35b610518565b5f80fd5b5f80fd5b5f80fd5b909182601f830112156108d85781359167ffffffffffffffff83116108d35760200192600183028401116108ce57565b61089a565b610896565b610892565b9060208282031261090e575f82013567ffffffffffffffff811161090957610905920161089e565b9091565b610520565b61051c565b5f0190565b346109475761093161092b3660046108dd565b90612a8a565b610939610512565b8061094381610913565b0390f35b610518565b3461097c5761095c3660046105cd565b610978610967612a96565b61096f610512565b91829182610848565b0390f35b610518565b346109af576109913660046105cd565b610999612c62565b6109a1610512565b806109ab81610913565b0390f35b610518565b1c90565b60ff1690565b6109ce9060086109d393026109b4565b6109b8565b90565b906109e191546109be565b90565b6109f060405f906109d6565b90565b34610a2357610a033660046105cd565b610a1f610a0e6109e4565b610a16610512565b91829182610583565b0390f35b610518565b9091606082840312610a5d57610a5a610a43845f8501610785565b93610a518160208601610785565b936040016107ab565b90565b61051c565b34610a9357610a8f610a7e610a78366004610a28565b91612c6c565b610a86610512565b91829182610583565b0390f35b610518565b916020610ab9929493610ab260408201965f83019061083b565b019061083b565b565b34610aec57610ad3610ace36600461081d565b612d9d565b90610ae8610adf610512565b92839283610a98565b0390f35b610518565b90565b610b08610b03610b0d92610af1565b610687565b610794565b90565b610b1b610e10610af4565b90565b610b26610b10565b90565b34610b5957610b393660046105cd565b610b55610b44610b1e565b610b4c610512565b91829182610848565b0390f35b610518565b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52602260045260245ffd5b9060016002830492168015610ba5575b6020831014610ba057565b610b71565b91607f1691610b95565b60209181520190565b5f5260205f2090565b905f9291805490610bdb610bd483610b85565b8094610baf565b916001811690815f14610c325750600114610bf6575b505050565b610c039192939450610bb8565b915f925b818410610c1a57505001905f8080610bf1565b60018160209295939554848601520191019290610c07565b92949550505060ff19168252151560200201905f8080610bf1565b90610c5791610bc1565b90565b634e487b7160e01b5f52604160045260245ffd5b90610c78906105f4565b810190811067ffffffffffffffff821117610c9257604052565b610c5a565b90610cb7610cb092610ca7610512565b93848092610c4d565b0383610c6e565b565b905f10610ccc57610cc990610c97565b90565b610b5e565b610cdd60455f90610cb9565b90565b610cf59160208201915f8184039101526106d8565b90565b34610d2857610d083660046105cd565b610d24610d13610cd1565b610d1b610512565b91829182610ce0565b0390f35b610518565b90565b610d3981610d2d565b03610d4057565b5f80fd5b90503590610d5182610d30565b565b90602082820312610d6c57610d69915f01610d44565b90565b61051c565b610d7a90610d2d565b9052565b9190610d91905f60208501940190610d71565b565b34610dc357610dbf610dae610da9366004610d53565b612fbe565b610db6610512565b91829182610d7e565b0390f35b610518565b34610df657610dd83660046105cd565b610de06134bc565b610de8610512565b80610df281610913565b0390f35b610518565b9190604083820312610e235780610e17610e20925f8601610d44565b93602001610785565b90565b61051c565b34610e5757610e41610e3b366004610dfb565b906134f0565b610e49610512565b80610e5381610913565b0390f35b610518565b60ff1690565b610e6b90610e5c565b9052565b9190610e82905f60208501940190610e62565b565b34610eb457610e943660046105cd565b610eb0610e9f61351f565b610ea7610512565b91829182610e6f565b0390f35b610518565b90602082820312610ed257610ecf915f016107ab565b90565b61051c565b634e487b7160e01b5f52603260045260245ffd5b50603090565b90565b610efd81610eeb565b821015610f1757610f0f600191610ef1565b910201905f90565b610ed7565b90565b610f2f906008610f3493026109b4565b610f1c565b90565b90610f429154610f1f565b90565b6010610f5081610eeb565b821015610f6d57610f6a91610f6491610ef4565b90610f37565b90565b5f80fd5b34610fa157610f9d610f8c610f87366004610eb9565b610f45565b610f94610512565b91829182610848565b0390f35b610518565b34610fd457610fb63660046105cd565b610fbe6135d0565b610fc6610512565b80610fd081610913565b0390f35b610518565b3461100957610fe93660046105cd565b611005610ff46135da565b610ffc610512565b91829182610d7e565b0390f35b610518565b3461103d57611027611021366004610dfb565b906135ee565b61102f610512565b8061103981610913565b0390f35b610518565b346110735761106f61105e6110583660046107ba565b9061366b565b611066610512565b91829182610848565b0390f35b610518565b346110a6576110883660046105cd565b6110906136c9565b611098610512565b806110a281610913565b0390f35b610518565b346110da576110c46110be3660046107ba565b90613826565b6110cc610512565b806110d681610913565b0390f35b610518565b6110e8906106a6565b90565b906110f5906110df565b5f5260205260405f2090565b5f1c90565b61111261111791611101565b610f1c565b90565b6111249054611106565b90565b61113290600d6110eb565b61113d5f820161111a565b9161114a6001830161111a565b916111576002820161111a565b9161117060046111696003850161111a565b930161111a565b90565b909594926111be946111ad6111b7926111a360809661119960a088019c5f89019061083b565b602087019061083b565b604085019061083b565b606083019061083b565b019061083b565b565b346111f4576111f06111db6111d636600461081d565b611127565b916111e7959395610512565b95869586611173565b0390f35b610518565b61120560415f90610f37565b90565b34611238576112183660046105cd565b6112346112236111f9565b61122b610512565b91829182610848565b0390f35b610518565b3461126d5761124d3660046105cd565b611269611258613832565b611260610512565b91829182610848565b0390f35b610518565b346112a2576112823660046105cd565b61129e61128d6138f3565b611295610512565b9182918261062f565b0390f35b610518565b6112b090610765565b9052565b91906112c7905f602085019401906112a7565b565b346112f9576112f56112e46112df36600461081d565b61398f565b6112ec610512565b918291826112b4565b0390f35b610518565b3461132e5761130e3660046105cd565b61132a6113196139ae565b611321610512565b91829182610583565b0390f35b610518565b346113615761134b61134636600461081d565b6139d7565b611353610512565b8061135d81610913565b0390f35b610518565b34611396576113763660046105cd565b6113926113816139ea565b611389610512565b91829182610583565b0390f35b610518565b90565b6113b26113ad6113b79261139b565b610687565b610794565b90565b6113c4603061139e565b90565b6113cf6113ba565b90565b34611402576113e23660046105cd565b6113fe6113ed6113c7565b6113f5610512565b91829182610848565b0390f35b610518565b346114375761143361142261141d36600461081d565b613a00565b61142a610512565b91829182610848565b0390f35b610518565b3461146a5761144c3660046105cd565b611454613ab7565b61145c610512565b8061146681610913565b0390f35b610518565b90565b61148661148161148b9261146f565b610687565b610794565b90565b6114a26a084595161401484a000000611472565b90565b6114ad61148e565b90565b346114e0576114c03660046105cd565b6114dc6114cb6114a5565b6114d3610512565b91829182610848565b0390f35b610518565b906114ef906110df565b5f5260205260405f2090565b6115119061150c600e915f926114e5565b6109d6565b90565b346115445761154061152f61152a36600461081d565b6114fb565b611537610512565b91829182610583565b0390f35b610518565b63ffffffff1690565b61155b90611549565b9052565b9190611572905f60208501940190611552565b565b346115a4576115a061158f61158a36600461081d565b613ac5565b611597610512565b9182918261155f565b0390f35b610518565b346115d9576115d56115c46115bf36600461081d565b613af0565b6115cc610512565b91829182610848565b0390f35b610518565b3461160e5761160a6115f96115f436600461081d565b613b0e565b611601610512565b91829182610583565b0390f35b610518565b61161f60425f90610f37565b90565b34611652576116323660046105cd565b61164e61163d611613565b611645610512565b91829182610848565b0390f35b610518565b909594926116a29461169161169b9261168760809661167d60a088019c5f890190610576565b602087019061083b565b604085019061083b565b606083019061083b565b019061083b565b565b346116d8576116d46116bf6116ba36600461081d565b613b2d565b916116cb959395610512565b95869586611657565b0390f35b610518565b3461170d576117096116f86116f336600461081d565b613c9d565b611700610512565b91829182610848565b0390f35b610518565b34611740576117223660046105cd565b61172a613cd6565b611732610512565b8061173c81610913565b0390f35b610518565b60ff60f81b1690565b61175790611745565b9052565b5190565b60209181520190565b60200190565b61177790610794565b9052565b906117888160209361176e565b0190565b60200190565b906117af6117a96117a28461175b565b809361175f565b92611768565b905f5b8181106117bf5750505090565b9091926117d86117d2600192865161177b565b9461178c565b91019190916117b2565b939591946118336118286118479561181a61183d956118549c9a61180d60e08c01925f8d019061174e565b8a820360208c01526105fe565b9088820360408a01526105fe565b97606087019061083b565b60808501906112a7565b60a0830190610d71565b60c0818403910152611792565b90565b3461188e576118673660046105cd565b61188a611872613d5d565b93611881979597939193610512565b978897886117e2565b0390f35b610518565b346118c3576118bf6118ae6118a9366004610eb9565b613de7565b6118b6610512565b91829182610848565b0390f35b610518565b90565b6118df6118da6118e4926118c8565b610687565b610794565b90565b6118fb6a52b7d2dcc80cd2e40000006118cb565b90565b6119066118e7565b90565b34611939576119193660046105cd565b6119356119246118fe565b61192c610512565b91829182610848565b0390f35b610518565b3461196f5761196b61195a611954366004610dfb565b90613e18565b611962610512565b91829182610583565b0390f35b610518565b65ffffffffffff1690565b61198890611974565b9052565b919061199f905f6020850194019061197f565b565b346119d1576119b13660046105cd565b6119cd6119bc613e46565b6119c4610512565b9182918261198c565b0390f35b610518565b34611a06576119e63660046105cd565b611a026119f1613e5a565b6119f9610512565b9182918261062f565b0390f35b610518565b90565b611a22611a1d611a2792611a0b565b610687565b610794565b90565b611a3662015180611a0e565b90565b611a41611a2a565b90565b34611a7457611a543660046105cd565b611a70611a5f611a39565b611a67610512565b91829182610848565b0390f35b610518565b34611aa957611aa5611a94611a8f36600461081d565b613e70565b611a9c610512565b91829182610848565b0390f35b610518565b34611ade57611ada611ac9611ac436600461081d565b613ecb565b611ad1610512565b91829182610848565b0390f35b610518565b90565b611afa611af5611aff92611ae3565b610687565b610794565b90565b611b166a4a723dc6b40b8a9a000000611ae6565b90565b611b21611b02565b90565b34611b5457611b343660046105cd565b611b50611b3f611b19565b611b47610512565b91829182610848565b0390f35b610518565b34611b8857611b72611b6c3660046107ba565b9061404d565b611b7a610512565b80611b8481610913565b0390f35b610518565b9091606082840312611bc257611bbf611ba8845f8501610785565b93611bb681602086016107ab565b936040016107ab565b90565b61051c565b34611bf657611be0611bda366004611b8d565b916142d3565b611be8610512565b80611bf281610913565b0390f35b610518565b90565b5f1b90565b611c17611c12611c1c92611bfb565b611bfe565b610d2d565b90565b611c285f611c03565b90565b611c33611c1f565b90565b34611c6657611c463660046105cd565b611c62611c51611c2b565b611c59610512565b91829182610d7e565b0390f35b610518565b60018060a01b031690565b611c86906008611c8b93026109b4565b611c6b565b90565b90611c999154611c76565b90565b611ca860445f90611c8e565b90565b9190611cbe905f602085019401906106be565b565b34611cf057611cd03660046105cd565b611cec611cdb611c9c565b611ce3610512565b91829182611cab565b0390f35b610518565b34611d2557611d053660046105cd565b611d21611d106142e0565b611d18610512565b91829182610583565b0390f35b610518565b611d3390610765565b90565b611d3f81611d2a565b03611d4657565b5f80fd5b90503590611d5782611d36565b565b90602082820312611d7257611d6f915f01611d4a565b90565b61051c565b34611da557611d8f611d8a366004611d59565b614437565b611d97610512565b80611da181610913565b0390f35b610518565b34611dda57611dba3660046105cd565b611dd6611dc5614461565b611dcd610512565b91829182610848565b0390f35b610518565b90565b611df6611df1611dfb92611ddf565b610687565b610794565b90565b611e0a62278d00611de2565b90565b611e15611dfe565b90565b34611e4857611e283660046105cd565b611e44611e33611e0d565b611e3b610512565b91829182610848565b0390f35b610518565b34611e7e57611e7a611e69611e633660046107ba565b906144db565b611e71610512565b91829182610583565b0390f35b610518565b90565b611e9a611e95611e9f92611e83565b610687565b610794565b90565b611eb3670de0b6b3a7640000611e86565b90565b611ebe611ea2565b90565b34611ef157611ed13660046105cd565b611eed611edc611eb6565b611ee4610512565b91829182610848565b0390f35b610518565b50603090565b905090565b90565b60200190565b611f26611f20611f1983611ef6565b8094611efc565b91611f01565b5f915b838310611f365750505050565b611f4c611f46600192845161177b565b92611f04565b92019190611f29565b9190611f69905f6106008501940190611f0a565b565b34611f9b57611f7b3660046105cd565b611f97611f86614602565b611f8e610512565b91829182611f55565b0390f35b610518565b34611fd157611fcd611fbc611fb63660046107ba565b90614618565b611fc4610512565b91829182610848565b0390f35b610518565b61200b61201294612001606094989795611ff7608086019a5f87019061083b565b602085019061083b565b604083019061083b565b0190610576565b565b34612048576120243660046105cd565b61204461202f61462e565b9061203b949294610512565b94859485611fd6565b0390f35b610518565b3461207d5761207961206861206336600461081d565b614805565b612070610512565b91829182610848565b0390f35b610518565b346120b2576120923660046105cd565b6120ae61209d61481a565b6120a5610512565b91829182610848565b0390f35b610518565b346120e7576120e36120d26120cd36600461081d565b61482e565b6120da610512565b91829182610848565b0390f35b610518565b6120f581610e5c565b036120fc57565b5f80fd5b9050359061210d826120ec565b565b909160c08284031261216e57612127835f8401610785565b9261213581602085016107ab565b9261214382604083016107ab565b9261216b6121548460608501612100565b936121628160808601610d44565b9360a001610d44565b90565b61051c565b346121a85761219261218636600461210f565b949390939291926148b8565b61219a610512565b806121a481610913565b0390f35b610518565b60e081830312612218576121c3825f8301610785565b926121d18360208401610785565b926121df81604085016107ab565b926121ed82606083016107ab565b926122156121fe8460808501612100565b9361220c8160a08601610d44565b9360c001610d44565b90565b61051c565b346122525761223c6122303660046121ad565b95949094939193614a0c565b612244610512565b8061224e81610913565b0390f35b610518565b346122865761227061226a366004610dfb565b90614b2a565b612278610512565b8061228281610913565b0390f35b610518565b91906040838203126122b357806122a76122b0925f8601610785565b93602001610785565b90565b61051c565b346122e9576122e56122d46122ce36600461228b565b90614b4c565b6122dc610512565b91829182610848565b0390f35b610518565b7f6b9725f740f94b91b78060a1b17d1774656d381421a529ec98cdb013f4d9c25e90565b61231a6122ee565b90565b3461234d5761232d3660046105cd565b612349612338612312565b612340610512565b91829182610d7e565b0390f35b610518565b7f65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a90565b61237e612352565b90565b346123b1576123913660046105cd565b6123ad61239c612376565b6123a4610512565b91829182610d7e565b0390f35b610518565b6123bf81611549565b036123c657565b5f80fd5b905035906123d7826123b6565b565b919060408382031261240157806123f56123fe925f8601610785565b936020016123ca565b90565b61051c565b61240f90611974565b9052565b60018060d01b031690565b61242790612413565b9052565b9060208061244d936124435f8201515f860190612406565b015191019061241e565b565b9190612462905f6040850194019061242b565b565b346124955761249161248061247a3660046123d9565b90614bba565b612488610512565b9182918261244f565b0390f35b610518565b6124a660435f90610f37565b90565b346124d9576124b93660046105cd565b6124d56124c461249a565b6124cc610512565b91829182610848565b0390f35b610518565b7fcce296b040332a080e6df13515a3ec2869e21cd20f7344af0987ddb938d8bd2190565b61250a6124de565b90565b3461253d5761251d3660046105cd565b612539612528612502565b612530610512565b91829182610d7e565b0390f35b610518565b5f80fd5b5f90565b634e487b7160e01b5f52601160045260245ffd5b61256a61257091612413565b91612413565b019060018060d01b03821161258157565b61254a565b9061259991612593612546565b5061255e565b90565b6125a86125ae91612413565b91612413565b90039060018060d01b0382116125c057565b61254a565b906125d8916125d2612546565b5061259c565b90565b5f90565b6125e76125db565b50806126026125fc637965db0b60e01b610524565b91610524565b1490811561260f575b5090565b6126199150614bd0565b5f61260b565b606090565b60209181520190565b5f5260205f2090565b905f929180549061265061264983610b85565b8094612624565b916001811690815f146126a7575060011461266b575b505050565b612678919293945061262d565b915f925b81841061268f57505001905f8080612666565b6001816020929593955484860152019101929061267c565b92949550505060ff19168252151560200201905f8080612666565b906126cc91612636565b90565b906126ef6126e8926126df610512565b938480926126c2565b0383610c6e565b565b6126fa906126cf565b90565b61270561261f565b5061271060036126f1565b90565b5f90565b606090565b61272861272d91611101565b611c6b565b90565b61273a905461271c565b90565b61274690610c97565b90565b612751612713565b5061275a612717565b506127656044612730565b90612770604561273d565b90565b6127909161277f6125db565b50612788614bf6565b919091614c03565b600190565b5f90565b5f6127b16127b7926127a9612795565b50600d6110eb565b0161111a565b90565b906127d4916127cf6127ca6124de565b614c13565b612a34565b565b5090565b601f602091010490565b1b90565b919060086128039102916127fd5f19846127e4565b926127e4565b9181191691161790565b61282161281c61282692610794565b610687565b610794565b90565b90565b919061284261283d61284a9361280d565b612829565b9083546127e8565b9055565b6128609161285a612795565b9161282c565b565b5b81811061286e575050565b8061287b5f60019361284e565b01612863565b9190601f8111612891575b505050565b61289d6128c293610bb8565b9060206128a9846127da565b830193106128ca575b6128bb906127da565b0190612862565b5f808061288c565b91506128bb819290506128b2565b906128e8905f19906008026109b4565b191690565b816128f7916128d8565b906002021790565b9161290a90826127d6565b9067ffffffffffffffff82116129c95761292e826129288554610b85565b85612881565b5f90601f831160011461296157918091612950935f92612955575b50506128ed565b90555b565b90915001355f80612949565b601f1983169161297085610bb8565b925f5b8181106129b157509160029391856001969410612997575b50505002019055612953565b6129a7910135601f8416906128d8565b90555f808061298b565b91936020600181928787013581550195019201612973565b610c5a565b906129d992916128ff565b565b90825f939282370152565b9190612a00816129f981612a05956106cf565b80956129db565b6105f4565b0190565b91612a23612a31949260408501908582035f8701526106d8565b9260208185039101526129e6565b90565b90612a3f604561273d565b612a4c83839060456129ce565b919091612a857fb9a2088426f03b30a81c06428094fbfa9e2692739b3241af6b9ab1da4b5546be93612a7c610512565b93849384612a09565b0390a1565b90612a94916127ba565b565b612a9e612795565b50612aa9600261111a565b90565b612abc612ab76122ee565b614c13565b612ac4612b85565b565b612ada612ad5612adf92611bfb565b610687565b610794565b90565b612af6612af1612afb92611bfb565b610687565b61067c565b90565b612b0790612ae2565b90565b90612b1660ff91611bfe565b9181191691161790565b612b2990610571565b90565b90565b90612b44612b3f612b4b92612b20565b612b2c565b8254612b0a565b9055565b90612b5b5f1991611bfe565b9181191691161790565b90612b7a612b75612b819261280d565b612829565b8254612b4f565b9055565b612b8f604161111a565b612ba1612b9b5f612ac6565b91610794565b03612c4657612bb8612bb36044612730565b6106b2565b612bd2612bcc612bc75f612afe565b610765565b91610765565b14612c2a57612be360016040612b2f565b612bee426041612b65565b42612c257f1194b034cfa9ab5807494a1d5c667d8b0e6e97f38888742aa3871a322034116091612c1c610512565b91829182610848565b0390a1565b5f633b0a48bd60e11b815280612c4260048201610913565b0390fd5b5f6338e93dbd60e11b815280612c5e60048201610913565b0390fd5b612c6a612aac565b565b91612c9692612c796125db565b50612c8e612c85614bf6565b82908491614c67565b919091614cf3565b600190565b612ca4906106a6565b90565b5f80fd5b60e01b90565b90505190612cbe82610797565b565b90602082820312612cd957612cd6915f01612cb1565b90565b61051c565b612ce6610512565b3d5f823e3d90fd5b612cfd612d0391939293610794565b92610794565b8203918211612d0e57565b61254a565b90565b612d2a612d25612d2f92612d13565b610687565b610794565b90565b612d41612d4791939293610794565b92610794565b91612d53838202610794565b928184041490151715612d6257565b61254a565b634e487b7160e01b5f52601260045260245ffd5b612d87612d8d91610794565b91610794565b908115612d98570490565b612d67565b612da5612795565b91612dae612795565b91612dc55f612dbf600d84906110eb565b0161111a565b90612ddd6002612dd7600d84906110eb565b0161111a565b91612e166020612dec30612c9b565b63651fd26890612e0b8692612dff610512565b95869485938493612cab565b8352600483016112b4565b03915afa908115612f6f57612e61916020915f91612f42575b5093612e3a30612c9b565b612e5663998955d3612e4a610512565b95869485938493612cab565b8352600483016112b4565b03915afa908115612f3d575f91612f0f575b509181612e88612e825f612ac6565b91610794565b11612ede575b505081612ea3612e9d5f612ac6565b91610794565b11612ead575b5050565b612ed6929350612ec0612ed19183612cee565b612ecb612710612d16565b90612d32565b612d7b565b905f80612ea9565b612f07929650612ef1612f029183612cee565b612efc612710612d16565b90612d32565b612d7b565b935f80612e8e565b612f30915060203d8111612f36575b612f288183610c6e565b810190612cc0565b5f612e73565b503d612f1e565b612cde565b612f629150823d8111612f68575b612f5a8183610c6e565b810190612cc0565b5f612e2f565b503d612f50565b612cde565b5f90565b612f8190610d2d565b90565b90612f8e90612f78565b5f5260205260405f2090565b90565b612fa9612fae91611101565b612f9a565b90565b612fbb9054612f9d565b90565b6001612fd7612fdd92612fcf612f74565b506005612f84565b01612fb1565b90565b612fe8614d90565b612ff0612ff2565b565b612ffa614de6565b61300261300c565b61300a614e4b565b565b61301c6130176122ee565b614c13565b613024613156565b565b61303261303791611101565b6109b8565b90565b6130449054613026565b90565b60016130539101610794565b90565b61306561306b91939293610794565b92610794565b820180921161307657565b61254a565b613084906106a6565b90565b5f91031261309157565b61051c565b905f92918054906130b06130a983610b85565b80946106cf565b916001811690815f1461310757506001146130cb575b505050565b6130d89192939450610bb8565b915f925b8184106130ef57505001905f80806130c6565b600181602092959395548486015201910192906130dc565b92949550505060ff19168252151560200201905f80806130c6565b61314661315394929361313c60608401955f8501906112a7565b602083019061083b565b6040818403910152613096565b90565b613169613163604061303a565b15610571565b6134a0576131756142e0565b6134845761319e6131904261318a604161111a565b90612cee565b613198611dfe565b90612d7b565b426131c96131c36131be6131b0614461565b6131b8610b10565b90612cee565b610794565b91610794565b10613468576131e2906131dc604261111a565b90612cee565b908161321061320a6132056131f56113ba565b6131ff604261111a565b90612cee565b610794565b91610794565b11613445575b61321f5f612ac6565b906132295f612ac6565b915b8261323e61323886610794565b91610794565b10156132855761327961327f9161327361326d6010613267613260604261111a565b8990613056565b90610ef4565b90610f37565b90613056565b92613047565b9161322b565b91509161329c613295604361111a565b8390613056565b6132b56132af6132aa61148e565b610794565b91610794565b11613429576132d06132d7916132cb604261111a565b613056565b6042612b65565b6132f46132ed826132e8604361111a565b613056565b6043612b65565b6133076133003061307b565b8290614e5f565b61332c6133133061307b565b6133256133206044612730565b6106b2565b8391614c03565b61333e6133396044612730565b6106b2565b6318b68b8c61334c3061307b565b8392604592813b15613424575f61337691613381829661336a610512565b98899788968795612cab565b855260048501613122565b03925af1801561341f576133f3575b5061339b604261111a565b906133ae6133a96044612730565b6106b2565b906133d97f34b73d0c96e9ff4d5311434817c8ecc930e7d2782c5bde2e79dc44b0596755bb926110df565b926133ee6133e5610512565b92839283610a98565b0390a2565b613412905f3d8111613418575b61340a8183610c6e565b810190613087565b5f613390565b503d613400565b612cde565b612ca7565b5f6323064ebd60e01b81528061344160048201610913565b0390fd5b90506134626134526113ba565b61345c604261111a565b90612cee565b90613216565b5f633d53c75360e01b81528061348060048201610913565b0390fd5b5f631155624b60e21b81528061349c60048201610913565b0390fd5b5f6319afc99d60e21b8152806134b860048201610913565b0390fd5b6134c4612fe0565b565b906134e1916134dc6134d782612fbe565b614c13565b6134e3565b565b906134ed91614ebd565b50565b906134fa916134c6565b565b5f90565b90565b61351761351261351c92613500565b610687565b610e5c565b90565b6135276134fc565b506135326012613503565b90565b6135456135406122ee565b614c13565b61354d61354f565b565b613559604161111a565b61356b6135655f612ac6565b91610794565b146135b45761357c60016040612b2f565b7f4a792a0be42b5672faa40129fc6469072490775ca8d3c34e852d4d55d3a735a96135a5610512565b806135af81610913565b0390a1565b5f638f98404160e01b8152806135cc60048201610913565b0390fd5b6135d8613535565b565b6135e2612f74565b506135eb614f69565b90565b90806136096136036135fe614bf6565b610765565b91610765565b0361361a5761361791615023565b50565b5f63334bd91960e11b81528061363260048201610913565b0390fd5b90613640906110df565b5f5260205260405f2090565b90565b61366361365e61366892612413565b610687565b610794565b90565b6136a29161369761369161368c61369d94613684612795565b50600a613636565b61364c565b91615104565b906151fa565b61364f565b90565b6136b56136b0611c1f565b614c13565b6136bd6136bf565b565b6136c7615381565b565b6136d16136a5565b565b906136e5916136e0614de6565b6136ef565b6136ed614e4b565b565b908161370b6137056137005f612afe565b610765565b91610765565b1461380a578061372361371d5f612ac6565b91610794565b146137ee5761374561373f61373a600e33906114e5565b61303a565b15610571565b6137d2576137523361538e565b6137696001613763600d33906110eb565b0161111a565b61377b61377583610794565b91610794565b106137b6576137b4916137af826137a96001613799600d33906110eb565b01916137a48361111a565b612cee565b90612b65565b614e5f565b565b5f631c959ed960e21b8152806137ce60048201610913565b0390fd5b5f634417760960e11b8152806137ea60048201610913565b0390fd5b5f631f2a200560e01b81528061380660048201610913565b0390fd5b5f63d92e233d60e01b81528061382260048201610913565b0390fd5b90613830916136d3565b565b61383a612795565b5061385661384661148e565b613850604361111a565b90612cee565b90565b9061386c613865610512565b9283610c6e565b565b67ffffffffffffffff811161388c576138886020916105f4565b0190565b610c5a565b906138a361389e8361386e565b613859565b918252565b5f7f6d6f64653d626c6f636b6e756d6265722666726f6d3d64656661756c74000000910152565b6138d9601d613891565b906138e6602083016138a8565b565b6138f06138cf565b90565b6138fb61261f565b50613904613e46565b61391d61391761391261555d565b611974565b91611974565b0361392d5761392a6138e8565b90565b5f6301bfc1c560e61b81528061394560048201610913565b0390fd5b5f90565b90613957906110df565b5f5260205260405f2090565b60018060a01b031690565b61397a61397f91611101565b613963565b90565b61398c905461396e565b90565b6139a66139ab9161399e613949565b50600961394d565b613982565b90565b6139b66125db565b506139c1604161111a565b6139d36139cd5f612ac6565b91610794565b1190565b6139e8906139e3614bf6565b615595565b565b6139f26125db565b506139fd600f61303a565b90565b613a5790613a0c612795565b50613a246001613a1e600d84906110eb565b0161111a565b90613a516004613a4b613a435f613a3d600d87906110eb565b0161111a565b93600d6110eb565b0161111a565b91615620565b90565b613a6a613a65612352565b614c13565b613a72613a74565b565b613a7f5f6040612b2f565b7f73a5fc60aafeec8f139af22d98e62140e2ce914d1f155c692b427757c3e4014c613aa8610512565b80613ab281610913565b0390a1565b613abf613a5a565b565b5f90565b613ad790613ad1613ac1565b506156cd565b90565b90613ae4906110df565b5f5260205260405f2090565b613b06613b0b91613aff612795565b505f613ada565b61111a565b90565b613b25613b2a91613b1d6125db565b50600e6114e5565b61303a565b90565b90613b366125db565b50613b3f612795565b50613b48612795565b50613b51612795565b50613b5a612795565b50613b6f613b6a600e84906114e5565b61303a565b91613b865f613b80600d84906110eb565b0161111a565b91613b9e6002613b98600d85906110eb565b0161111a565b90613bd76020613bad30612c9b565b63651fd26890613bcc8792613bc0610512565b95869485938493612cab565b8352600483016112b4565b03915afa908115613c9857613c22916020915f91613c6b575b5094613bfb30612c9b565b613c1763998955d3613c0b610512565b95869485938493612cab565b8352600483016112b4565b03915afa908115613c66575f91613c38575b5090565b613c59915060203d8111613c5f575b613c518183610c6e565b810190612cc0565b5f613c34565b503d613c47565b612cde565b613c8b9150823d8111613c91575b613c838183610c6e565b810190612cc0565b5f613bf0565b503d613c79565b612cde565b613caf90613ca9612795565b506156fc565b90565b613cc2613cbd612352565b614c13565b613cca613ccc565b565b613cd4615772565b565b613cde613cb2565b565b5f90565b606090565b613cf2906106a6565b90565b67ffffffffffffffff8111613d0d5760208091020190565b610c5a565b90613d24613d1f83613cf5565b613859565b918252565b369037565b90613d53613d3b83613d12565b92602080613d498693613cf5565b9201910390613d29565b565b600f60f81b90565b613d65613ce0565b50613d6e61261f565b50613d7761261f565b50613d80612795565b50613d89613949565b50613d92612f74565b50613d9b613ce4565b50613da461577f565b90613dad6157bf565b904690613db930613ce9565b90613dc35f611c03565b90613dd5613dd05f612ac6565b613d2e565b90613dde613d55565b96959493929190565b613e10613e1591613df6612795565b50613e0a613e04600b61364c565b91615104565b906151fa565b61364f565b90565b613e3f915f613e34613e3a93613e2c6125db565b506005612f84565b016114e5565b61303a565b90565b5f90565b613e4e613e42565b50613e5761555d565b90565b613e6261261f565b50613e6d60046126f1565b90565b613ec890613e7c612795565b50613e946003613e8e600d84906110eb565b0161111a565b90613ec26004613ebc613eb46002613eae600d87906110eb565b0161111a565b93600d6110eb565b0161111a565b91615620565b90565b613ef2613eed613ee8613ef793613ee0612795565b50600a613636565b61364c565b6157ff565b61364f565b90565b90613f0c91613f07614de6565b613f16565b613f14614e4b565b565b9081613f32613f2c613f275f612afe565b610765565b91610765565b146140315780613f4a613f445f612ac6565b91610794565b1461401557613f6c613f66613f61600e33906114e5565b61303a565b15610571565b613ff957613f793361538e565b613f906003613f8a600d33906110eb565b0161111a565b613fa2613f9c83610794565b91610794565b10613fdd57613fdb91613fd682613fd06003613fc0600d33906110eb565b0191613fcb8361111a565b612cee565b90612b65565b615874565b565b5f631c959ed960e21b815280613ff560048201610913565b0390fd5b5f634417760960e11b81528061401160048201610913565b0390fd5b5f631f2a200560e01b81528061402d60048201610913565b0390fd5b5f63d92e233d60e01b81528061404960048201610913565b0390fd5b9061405791613efa565b565b90614074929161406f61406a6124de565b614c13565b614076565b565b8061409161408b6140865f612afe565b610765565b91610765565b146142b7576140b36140ad6140a8600e84906114e5565b61303a565b15610571565b8061427c575b614220575b816140d16140cb5f612ac6565b91610794565b1480614206575b806141ec575b614191575b6140ec8161538e565b614103825f6140fd600d85906110eb565b01612b65565b61411b836002614115600d85906110eb565b01612b65565b61413382600161412d600d85906110eb565b01612b65565b61414b836003614145600d85906110eb565b01612b65565b90916141777faa807d0abf30d91968c7478c66b6d82521a106af13eda036e2036da9af168958926110df565b9261418c614183610512565b92839283610a98565b0390a2565b6141a65f6141a1600e84906114e5565b612b2f565b806141d17f02c2f0ba15b03f88b18f4832609a18cf35fc6b3f4546a9992076d7453d1334a8916110df565b906141da610512565b806141e481610913565b0390a26140e3565b506142016141fc600e83906114e5565b61303a565b6140de565b508261421a6142145f612ac6565b91610794565b146140d8565b6142366001614231600e84906114e5565b612b2f565b806142617f6cf28439a2daab1b265097227212a5b71e0a76f9ed85e3f815b5a6c3e218eb7f916110df565b9061426a610512565b8061427481610913565b0390a26140be565b508161429061428a5f612ac6565b91610794565b11801561429d575b6140b9565b50826142b16142ab5f612ac6565b91610794565b11614298565b5f63d92e233d60e01b8152806142cf60048201610913565b0390fd5b906142de9291614059565b565b6142e86125db565b506142f3604261111a565b61430c6143066143016113ba565b610794565b91610794565b101590565b61432a906143256143206124de565b614c13565b614382565b565b9061433d60018060a01b0391611bfe565b9181191691161790565b6143509061068a565b90565b61435c90614347565b90565b90565b9061437761437261437e92614353565b61435f565b825461432c565b9055565b61438b816106b2565b6143a561439f61439a5f612afe565b610765565b91610765565b1461441b576143d06143ca6143ba6044612730565b6143c5846044614362565b6106b2565b916106b2565b6144036143fd7f07015b6a9f05913148fd5faddf2acc9708f305937f3072ca2b4b46faa5d0898b936110df565b916110df565b9161440c610512565b8061441681610913565b0390a3565b5f63d92e233d60e01b81528061443360048201610913565b0390fd5b61444090614311565b565b90565b61445961445461445e92614442565b610687565b610794565b90565b614469612795565b50614474604161111a565b6144866144805f612ac6565b91610794565b146144cf576144cc614498604161111a565b6144c66144b86144a8604261111a565b6144b26001614445565b90613056565b6144c0611dfe565b90612d32565b90613056565b90565b6144d85f612ac6565b90565b6144f8916144e76125db565b506144f0614bf6565b919091614cf3565b600190565b67ffffffffffffffff81116145125760200290565b610c5a565b614523614528916144fd565b613859565b90565b9061454961453883614517565b9261454384916144fd565b90613d29565b565b614555603061452b565b90565b905090565b6145679054611106565b90565b60010190565b61458c61458661457f83610eeb565b8094614558565b91610ef1565b5f915b83831061459c5750505050565b6145b96145b36001926145ae8561455d565b61177b565b9261456a565b9201919061458f565b906145d08161060093614570565b0190565b906145f46145ed926145e4610512565b938480926145c2565b0383610c6e565b565b6145ff906145d4565b90565b61460a61454b565b5061461560106145f6565b90565b9061462b91614625612795565b5061366b565b90565b614636612795565b5061463f612795565b50614648612795565b506146516125db565b5061465c604161111a565b61466e6146685f612ac6565b91610794565b146147df5761469861468a42614684604161111a565b90612cee565b614692611dfe565b90612d7b565b906146da6146a6604161111a565b6146d46146c66146b6604261111a565b6146c06001614445565b90613056565b6146ce611dfe565b90612d32565b90613056565b6146e4604261111a565b6146fd6146f76146f26113ba565b610794565b91610794565b105f146147d15761472261471c6010614716604261111a565b90610ef4565b90610f37565b5b9261472e604061303a565b90816147ad575b5080614783575b80614757575b9161474d604261111a565b9193929193929190565b504261477c6147766147718461476b610b10565b90612cee565b610794565b91610794565b1015614742565b5061478e604261111a565b6147a76147a161479c6113ba565b610794565b91610794565b1061473c565b90506147ca6147c46147bf604261111a565b610794565b91610794565b115f614735565b6147da5f612ac6565b614723565b5f905f915f916148016147fb6147f55f94612ac6565b95612ac6565b93612ac6565b9190565b61481790614811612795565b50613ecb565b90565b614822612795565b5061482b612a96565b90565b600261484761484d9261483f612795565b50600d6110eb565b0161111a565b90565b7fe48329057bfd03d55e49b547132e39cffd9c1820ad7b9d4c5307691425d15adf90565b6148a96148b09461489f606094989795614895608086019a5f870190610d71565b60208501906112a7565b604083019061083b565b019061083b565b565b60200190565b93959490929195426148d26148cc89610794565b91610794565b1161494b579161493d9161494493614934614949989961491c6148f3614850565b61490d8b938b614901610512565b95869460208601614874565b60208201810382520382610c6e565b61492e614928826106cb565b916148b2565b206158d3565b929091926158f0565b918261593a565b615595565b565b614966875f918291632341d78760e11b835260048301610848565b0390fd5b7f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c990565b91946149d66149e0929897956149cc60a0966149c26149e79a6149b860c08a019e5f8b0190610d71565b60208901906112a7565b60408701906112a7565b606085019061083b565b608083019061083b565b019061083b565b565b916020614a0a929493614a0360408201965f8301906112a7565b01906112a7565b565b969591939294909442614a27614a2183610794565b91610794565b11614ae15790614a90614a99949392614a78614a4161496a565b614a698c80948c91614a538d9161597d565b9192614a5d610512565b9788966020880161498e565b60208201810382520382610c6e565b614a8a614a84826106cb565b916148b2565b206158d3565b929091926158f0565b80614aac614aa687610765565b91610765565b03614ac15750614abf9293919091614c03565b565b8490614add5f9283926325c0072360e11b8452600484016149e9565b0390fd5b614afc905f91829163313c898160e11b835260048301610848565b0390fd5b90614b1b91614b16614b1182612fbe565b614c13565b614b1d565b565b90614b2791615023565b50565b90614b3491614b00565b565b90614b40906110df565b5f5260205260405f2090565b614b7191614b67614b6c92614b5f612795565b506001614b36565b613ada565b61111a565b90565b614b7e6040613859565b90565b5f90565b5f90565b614b91614b74565b9060208083614b9e614b81565b815201614ba9614b85565b81525050565b614bb7614b89565b90565b90614bcd91614bc7614baf565b506159b0565b90565b614bd86125db565b50614bf2614bec6301ffc9a760e01b610524565b91610524565b1490565b614bfe613949565b503390565b91614c1192916001926159d8565b565b614c2590614c1f614bf6565b90615b0a565b565b604090614c50614c579496959396614c4660608401985f8501906112a7565b602083019061083b565b019061083b565b565b90614c649103610794565b90565b929192614c75818390614b4c565b9081614c8a614c845f19610794565b91610794565b10614c97575b5050509050565b81614caa614ca487610794565b91610794565b10614cd057614cc79394614cbf919392614c59565b905f926159d8565b805f8080614c90565b50614cef849291925f938493637dc7a0d960e11b855260048501614c27565b0390fd5b9182614d0f614d09614d045f612afe565b610765565b91610765565b14614d695781614d2f614d29614d245f612afe565b610765565b91610765565b14614d4257614d4092919091615b45565b565b614d65614d4e5f612afe565b5f91829163ec442f0560e01b8352600483016112b4565b0390fd5b614d8c614d755f612afe565b5f918291634b637e8f60e11b8352600483016112b4565b0390fd5b614d986139ea565b614d9e57565b5f63d93c066560e01b815280614db660048201610913565b0390fd5b90565b614dd1614dcc614dd692614dba565b610687565b610794565b90565b614de36002614dbd565b90565b614df0600c61111a565b614e09614e03614dfe614dd9565b610794565b91610794565b14614e2257614e20614e19614dd9565b600c612b65565b565b5f633ee5aeb560e01b815280614e3a60048201610913565b0390fd5b614e486001614445565b90565b614e5d614e56614e3e565b600c612b65565b565b80614e7a614e74614e6f5f612afe565b610765565b91610765565b14614e9657614e9491614e8c5f612afe565b919091615b45565b565b614eb9614ea25f612afe565b5f91829163ec442f0560e01b8352600483016112b4565b0390fd5b614ec56125db565b50614eda614ed4828490613e18565b15610571565b5f14614f6357614f026001614efd5f614ef560058690612f84565b0185906114e5565b612b2f565b90614f0b614bf6565b90614f48614f42614f3c7f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d95612f78565b926110df565b926110df565b92614f51610512565b80614f5b81610913565b0390a4600190565b50505f90565b614f71612f74565b50614f7b30613ce9565b614fad614fa77f0000000000000000000000000000000000000000000000000000000000000000610765565b91610765565b1480614fe9575b5f14614fde577f000000000000000000000000000000000000000000000000000000000000000090565b614fe6615bc5565b90565b504661501d6150177f0000000000000000000000000000000000000000000000000000000000000000610794565b91610794565b14614fb4565b61502b6125db565b50615037818390613e18565b5f146150bf5761505e5f6150595f61505160058690612f84565b0185906114e5565b612b2f565b90615067614bf6565b906150a461509e6150987ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b95612f78565b926110df565b926110df565b926150ad610512565b806150b781610913565b0390a4600190565b50505f90565b6150d96150d46150de92611974565b610687565b610794565b90565b9160206151029294936150fb60408201965f83019061083b565b019061197f565b565b61510c613e42565b50615115613e46565b81615128615122836150c5565b91610794565b101561513b575061513890615ccb565b90565b906151565f928392637669fc0f60e11b8452600484016150e1565b0390fd5b5490565b90565b61517561517061517a9261515e565b610687565b610794565b90565b90565b65ffffffffffff1690565b61519761519c91611101565b615180565b90565b6151a9905461518b565b90565b60301c90565b60018060d01b031690565b6151c96151ce916151ac565b6151b2565b90565b6151db90546151bd565b90565b6151f26151ed6151f792611bfb565b610687565b612413565b90565b9061524e90615207612546565b506152135f840161515a565b61521c5f612ac6565b90808061523261522c6005615161565b91610794565b116152af575b50906152495f86019391929361517d565b616303565b8061526161525b5f612ac6565b91610794565b145f146152775750506152735f6151de565b5b90565b6152a45f9161529f615299846152aa9601926152936001614445565b90612cee565b9161517d565b6162f9565b016151d1565b615274565b806152bd6152c39291615f8e565b90612cee565b90836152f56152ef6152ea5f6152e4818c016152df899161517d565b6162f9565b0161519f565b611974565b91611974565b105f146153065750905b905f615238565b915061531c906153166001614445565b90613056565b6152ff565b615329616392565b615331615333565b565b61533e5f600f612b2f565b615346614bf6565b61537c7f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa91615373610512565b918291826112b4565b0390a1565b615389615321565b565b90565b61539c6153a191600d6110eb565b61538b565b6153ad6004820161111a565b6153bf6153b95f612ac6565b91610794565b1461554d5761543b906153de426153d86004840161111a565b90612cee565b806153f86153f26153ed611a2a565b610794565b91610794565b10155f1461543d575061541861540f5f830161111a565b60018301612b65565b6154306154276002830161111a565b60038301612b65565b5b6004429101612b65565b565b8061545061544a5f612ac6565b91610794565b1161545c575b50615431565b61553e61552c6155479261551b6155126155016154ef6154b16154805f8b0161111a565b6154928761548c611ea2565b90612d32565b6154ab61549d611a2a565b6154a5611ea2565b90612d32565b9161641a565b946154d06154c160028c0161111a565b916154ca611ea2565b90612d32565b6154e96154db611a2a565b6154e3611ea2565b90612d32565b9161641a565b936154fc60018a0161111a565b613056565b61550c5f890161111a565b90616619565b60018701612b65565b6155276003860161111a565b613056565b6155386002850161111a565b90616619565b60038301612b65565b5f615456565b61555b906004429101612b65565b565b615565613e42565b5061556f43615ccb565b90565b90565b9061558a615585615591926110df565b615572565b825461432c565b9055565b9061561e916156186155a68261398f565b6155bb846155b66009869061394d565b615575565b828185906155fb6155f56155ef7f3134e8a2e6d97e929a7e54011ea5485d7d196dd5f0ba4d4ef95803e8e3fc257f956110df565b926110df565b926110df565b92615604610512565b8061560e81610913565b0390a49291616645565b9161665d565b565b909161562a612795565b508061563e6156385f612ac6565b91610794565b146156be5761564d9042612cee565b8061566761566161565c611a2a565b610794565b91610794565b10156156b95782916156ab6156b19261568c6156b69691615686611ea2565b90612d32565b6156a5615697611a2a565b61569f611ea2565b90612d32565b9161641a565b90613056565b616619565b90565b505090565b5050506156ca5f612ac6565b90565b6156f46156ef6156ea6156f9936156e2613ac1565b50600a613636565b61364c565b61680b565b61688a565b90565b61570e90615708612795565b506168db565b90565b615719614d90565b615721615723565b565b61572f6001600f612b2f565b615737614bf6565b61576d7f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a25891615764610512565b918291826112b4565b0390a1565b61577a615711565b565b90565b61578761261f565b506157bc7f00000000000000000000000000000000000000000000000000000000000000006157b6600661577c565b906169f6565b90565b6157c761261f565b506157fc7f00000000000000000000000000000000000000000000000000000000000000006157f6600761577c565b906169f6565b90565b615807612546565b506158135f820161515a565b806158266158205f612ac6565b91610794565b145f1461583c5750506158385f6151de565b5b90565b6158695f9161586461585e8461586f9601926158586001614445565b90612cee565b9161517d565b6162f9565b016151d1565b615839565b908161589061588a6158855f612afe565b610765565b91610765565b146158ac576158aa91906158a35f612afe565b9091615b45565b565b6158cf6158b85f612afe565b5f918291634b637e8f60e11b8352600483016112b4565b0390fd5b6158ed906158df612f74565b506158e8614f69565b616a44565b90565b9261590b9261591494615901613949565b5092909192616afa565b90929192616c25565b90565b91602061593892949361593160408201965f8301906112a7565b019061083b565b565b6159438161597d565b9161595661595084610794565b91610794565b0361595f575050565b6159795f9283926301d4b62360e61b845260048401615917565b0390fd5b61599190615989612795565b506008613ada565b6159ad61599d8261111a565b916159a783613047565b90612b65565b90565b906159d06159cb6159d5936159c3614baf565b50600a613636565b61364c565b616d87565b90565b9092816159f56159ef6159ea5f612afe565b610765565b91610765565b14615ac05783615a15615a0f615a0a5f612afe565b610765565b91610765565b14615a9957615a3983615a34615a2d60018690614b36565b8790613ada565b612b65565b615a43575b505050565b919091615a8e615a7c615a767f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925936110df565b936110df565b93615a85610512565b91829182610848565b0390a35f8080615a3e565b615abc615aa55f612afe565b5f918291634a1406b160e11b8352600483016112b4565b0390fd5b615ae3615acc5f612afe565b5f91829163e602df0560e01b8352600483016112b4565b0390fd5b916020615b08929493615b0160408201965f8301906112a7565b0190610d71565b565b90615b1f615b19838390613e18565b15610571565b615b27575050565b615b415f92839263e2517d3f60e01b845260048401615ae7565b0390fd5b91615b5292919091616da8565b565b7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f90565b90959492615bc394615bb2615bbc92615ba8608096615b9e60a088019c5f890190610d71565b6020870190610d71565b6040850190610d71565b606083019061083b565b01906112a7565b565b615bcd612f74565b50615bd6615b54565b615c4d7f000000000000000000000000000000000000000000000000000000000000000091615c3e7f000000000000000000000000000000000000000000000000000000000000000046615c2930613ce9565b91615c32610512565b96879560208701615b78565b60208201810382520382610c6e565b615c5f615c59826106cb565b916148b2565b2090565b615c77615c72615c7c9261139b565b610687565b610e5c565b90565b615c8890615c63565b9052565b916020615cad929493615ca660408201965f830190615c7f565b019061083b565b565b615cc3615cbe615cc892610794565b610687565b611974565b90565b615cd3613e42565b5080615ced615ce765ffffffffffff6150c5565b91610794565b11615cfe57615cfb90615caf565b90565b6030615d1a5f9283926306dfcc6560e41b845260048401615c8c565b0390fd5b90565b615d35615d30615d3a92615d1e565b610687565b610794565b90565b90565b615d54615d4f615d5992615d3d565b610687565b610e5c565b90565b615d7b90615d75615d6f615d8094610e5c565b91610794565b906109b4565b610794565b90565b90565b615d9a615d95615d9f92615d83565b610687565b610e5c565b90565b615dc190615dbb615db5615dc694610e5c565b91610794565b906127e4565b610794565b90565b90565b615de0615ddb615de592615dc9565b610687565b610794565b90565b90565b615dff615dfa615e0492615de8565b610687565b610e5c565b90565b90565b615e1e615e19615e2392615e07565b610687565b610794565b90565b90565b615e3d615e38615e4292615e26565b610687565b610e5c565b90565b90565b615e5c615e57615e6192615e45565b610687565b610794565b90565b90565b615e7b615e76615e8092615e64565b610687565b610e5c565b90565b90565b615e9a615e95615e9f92615e83565b610687565b610794565b90565b90565b615eb9615eb4615ebe92615ea2565b610687565b610e5c565b90565b615ed5615ed0615eda92615e26565b610687565b610794565b90565b615ef1615eec615ef692614dba565b610687565b610e5c565b90565b615f0d615f08615f1292615ea2565b610687565b610794565b90565b615f29615f24615f2e92614442565b610687565b610e5c565b90565b90565b615f48615f43615f4d92615f31565b610687565b610794565b90565b90615f5b9102610794565b90565b615f6a615f7091610794565b91610794565b908115615f7b570490565b612d67565b90615f8b9101610794565b90565b615f96612795565b5080615fab615fa56001614445565b91610794565b11156162f657806161c061619d61618d61617d61616d61615d61614d61613d61612d61611d61610d8b6161076161006161c69f6160e06160d06160f092615ff26001614445565b908061600a616004600160801b615d21565b91610794565b10156162c8575b8061602d61602768010000000000000000615dcc565b91610794565b101561629a575b8061604c616046640100000000615e0a565b91610794565b101561626c575b8061606961606362010000615e48565b91610794565b101561623e575b8061608561607f610100615e86565b91610794565b1015616210575b806160a061609a6010615ec1565b91610794565b10156161e2575b6160ba6160b46004615ef9565b91610794565b10156161c9575b6160cb6003615f34565b615f50565b6160da6001615f15565b90615d5c565b6160ea8186615f5e565b90615f80565b6160fa6001615f15565b90615d5c565b8092615f5e565b90615f80565b6161176001615f15565b90615d5c565b616127818c615f5e565b90615f80565b6161376001615f15565b90615d5c565b616147818a615f5e565b90615f80565b6161576001615f15565b90615d5c565b6161678188615f5e565b90615f80565b6161776001615f15565b90615d5c565b6161878186615f5e565b90615f80565b6161976001615f15565b90615d5c565b916161ba6161b46161af858094615f5e565b610794565b91610794565b11616e38565b90614c59565b90565b6161dd906161d76001615f15565b90615da2565b6160c1565b6161f961620a916161f36004615ea5565b90615d5c565b916162046002615edd565b90615da2565b906160a7565b616227616238916162216008615e67565b90615d5c565b916162326004615ea5565b90615da2565b9061608c565b6162556162669161624f6010615e29565b90615d5c565b916162606008615e67565b90615da2565b90616070565b6162836162949161627d6020615deb565b90615d5c565b9161628e6010615e29565b90615da2565b90616053565b6162b16162c2916162ab6040615d86565b90615d5c565b916162bc6020615deb565b90615da2565b90616034565b6162df6162f0916162d96080615d40565b90615d5c565b916162ea6040615d86565b90615da2565b90616011565b90565b5f5260205f200190565b9391909261630f612795565b505b8161632461631e83610794565b91610794565b101561638a57616335828290616e46565b9061634b5f6163458885906162f9565b0161519f565b61635d61635787611974565b91611974565b115f1461636d5750915b91616311565b9291506163849061637e6001614445565b90613056565b90616367565b925050915090565b6163a361639d6139ea565b15610571565b6163a957565b5f638dfc202b60e01b8152806163c160048201610913565b0390fd5b6163d96163d46163de92613500565b610687565b610794565b90565b6163eb60126163c5565b90565b90565b61640561640061640a926163ee565b610687565b610794565b90565b61641760116163f1565b90565b929192616425612795565b50616431818390615f50565b9161643a612795565b505f1981830983808210910303918261645b6164555f612ac6565b91610794565b14616608578561647361646d85610794565b91610794565b11156165d6576165cd92866165d39697936164c493616490612795565b50099085821190039403936001836164b15f6164ac8791612ac6565b614c59565b1680809504960493805f03040190615f50565b17916165c76165ab61658761656361653f61651b6164ec60036164e78991615f34565b615f50565b6164f66002614dbd565b18616515600261651061650a8b8590615f50565b91614dbd565b614c59565b90615f50565b616539600261653461652e8a8590615f50565b91614dbd565b614c59565b90615f50565b61655d6002616558616552898590615f50565b91614dbd565b614c59565b90615f50565b616581600261657c616576888590615f50565b91614dbd565b614c59565b90615f50565b6165a560026165a061659a878590615f50565b91614dbd565b614c59565b90615f50565b916165c26165bc6002928590615f50565b91614dbd565b614c59565b90615f50565b90615f50565b90565b616603866165ec6165e65f612ac6565b91610794565b146165f56163e1565b6165fd61640d565b91616e74565b616e98565b505050916166169192615f5e565b90565b61664291616625612795565b508161663961663383610794565b91610794565b10919091616e74565b90565b61665790616651612795565b50613af0565b90565b90565b9190918061667361666d85610765565b91610765565b1415806167f1575b616685575b505050565b806166a061669a6166955f612afe565b610765565b91610765565b03616761575b50816166c26166bc6166b75f612afe565b610765565b91610765565b036166ce575b80616680565b61671561670861670f926166e4600a8690613636565b906167026166fc6166f6600193616f13565b9361364c565b9161665a565b90616f66565b929061364f565b9161364f565b9190916167427fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a724926110df565b9261675761674e610512565b92839283610a98565b0390a25f806166c8565b6167a06167a6616799616776600a8590613636565b600261679361678d61678789616f13565b9361364c565b9161665a565b90616f66565b929061364f565b9161364f565b9190916167d37fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a724926110df565b926167e86167df610512565b92839283610a98565b0390a25f6166a6565b50816168056167ff5f612ac6565b91610794565b1161667b565b5f61681f91616818612795565b500161515a565b90565b61683661683161683b92611549565b610687565b610794565b90565b61684790615deb565b9052565b91602061686c92949361686560408201965f83019061683e565b019061083b565b565b61688261687d61688792610794565b610687565b611549565b90565b616892613ac1565b50806168aa6168a463ffffffff616822565b91610794565b116168bb576168b89061686e565b90565b60206168d75f9283926306dfcc6560e41b84526004840161684b565b0390fd5b6168f26168f7916168ea612795565b506008613ada565b61111a565b90565b90565b61691161690c616916926168fa565b611bfe565b610d2d565b90565b61692360ff6168fd565b90565b5f5260205f2090565b905f929180549061694961694283610b85565b8094612624565b916001811690815f146169a05750600114616964575b505050565b6169719192939450616926565b915f925b81841061698857505001905f808061695f565b60018160209295939554848601520191019290616975565b92949550505060ff19168252151560200201905f808061695f565b906169c59161692f565b90565b906169e86169e1926169d8610512565b938480926169bb565b0383610c6e565b565b6169f3906169c8565b90565b906169ff61261f565b50616a0982612f78565b616a22616a1c616a17616919565b610d2d565b91610d2d565b14155f14616a375750616a3490616ff0565b90565b616a4191506169ea565b90565b604291616a4f612f74565b50604051917f19010000000000000000000000000000000000000000000000000000000000008352600283015260228201522090565b5f90565b616a95616a9a91611101565b61280d565b90565b90565b616ab4616aaf616ab992616a9d565b610687565b610794565b90565b616af1616af894616ae7606094989795616add608086019a5f870190610d71565b6020850190610e62565b6040830190610d71565b0190610d71565b565b939293616b05613949565b50616b0e616a85565b50616b17612f74565b50616b2185616a89565b616b53616b4d7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0616aa0565b91610794565b11616be05790616b76602094955f94939293616b6d610512565b94859485616abc565b838052039060015afa15616bdb57616b8e5f51611bfe565b80616ba9616ba3616b9e5f612afe565b610765565b91610765565b14616bbf575f91616bb95f611c03565b91929190565b50616bc95f612afe565b600191616bd55f611c03565b91929190565b612cde565b505050616bec5f612afe565b9060039291929190565b634e487b7160e01b5f52602160045260245ffd5b60041115616c1457565b616bf6565b90616c2382616c0a565b565b80616c38616c325f616c19565b91616c19565b145f14616c43575050565b80616c57616c516001616c19565b91616c19565b145f14616c7a575f63f645eedf60e01b815280616c7660048201610913565b0390fd5b80616c8e616c886002616c19565b91616c19565b145f14616cbc57616cb8616ca183616a89565b5f91829163fce698f760e01b835260048301610848565b0390fd5b616ccf616cc96003616c19565b91616c19565b14616cd75750565b616cf2905f9182916335e2f38360e21b835260048301610d7e565b0390fd5b5f5260205f2090565b616d088161515a565b821015616d2257616d1a600191616cf6565b910201905f90565b610ed7565b90616d3190611974565b9052565b90616d3f90612413565b9052565b90616d79616d705f616d53614b74565b94616d6a616d6283830161519f565b838801616d27565b016151d1565b60208401616d35565b565b616d8490616d43565b90565b616da5915f616d9f92616d98614baf565b5001616cff565b50616d7b565b90565b9291616db684838391617020565b83616dd1616dcb616dc65f612afe565b610765565b91610765565b14616de6575b616de492939190916171aa565b565b616dee612a96565b93616df761718f565b9480616e0b616e0588610794565b91610794565b11616e1857509350616dd7565b8590616e345f928392630e58ae9360e11b845260048401610a98565b0390fd5b616e40612795565b50151590565b616e6b616e7192616e55612795565b508281169218616e656002614dbd565b90612d7b565b90613056565b90565b616e8e616e949293616e84612795565b5080941891616e38565b90615f50565b1890565b634e487b715f526020526024601cfd5b90565b616ebf616eba616ec492616ea8565b610687565b610e5c565b90565b616ed090616eab565b9052565b916020616ef5929493616eee60408201965f830190616ec7565b019061083b565b565b616f0b616f06616f1092610794565b610687565b612413565b90565b616f1b612546565b5080616f35616f2f60018060d01b0361364f565b91610794565b11616f4657616f4390616ef7565b90565b60d0616f625f9283926306dfcc6560e41b845260048401616ed4565b0390fd5b90616f9c616fa29392616f77612546565b50616f80612546565b508093616f95616f8e613e46565b94926157ff565b9091617612565b91617269565b91909190565b616fbc616fb7616fc192615de8565b610687565b610794565b90565b369037565b90616fee616fd683613891565b92602080616fe4869361386e565b9201910390616fc4565b565b616ff861261f565b50617002816172d3565b906170156170106020616fa8565b616fc9565b918252602082015290565b9190918061703e6170386170335f612afe565b610765565b91610765565b145f1461711f5761706261705b83617056600261111a565b613056565b6002612b65565b5b8261707e6170786170735f612afe565b610765565b91610765565b145f146170f3576170a261709b83617096600261111a565b614c59565b6002612b65565b5b9190916170ee6170dc6170d67fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef936110df565b936110df565b936170e5610512565b91829182610848565b0390a3565b61711a826171146171055f8790613ada565b9161710f8361111a565b615f80565b90612b65565b6170a3565b61713261712d5f8390613ada565b61111a565b8061714561713f85610794565b91610794565b1061716d57617158617168918490614c59565b6171635f8490613ada565b612b65565b617063565b9061718b9091925f93849363391434e360e21b855260048501614c27565b0390fd5b617197612795565b506171a760018060d01b0361364f565b90565b916172026171fc61720994806171d06171ca6171c55f612afe565b610765565b91610765565b1461723a575b846171f16171eb6171e65f612afe565b610765565b91610765565b1461720b575b61398f565b9261398f565b909161665d565b565b617233600b600261722d61722761722189616f13565b9361364c565b9161665a565b90616f66565b50506171f7565b617262600b600161725c61725661725089616f13565b9361364c565b9161665a565b90616f66565b50506171d6565b9161728d5f6172929461727a612546565b50617283612546565b500192919261517d565b6174c4565b91909190565b6172ac6172a76172b1926168fa565b610687565b610794565b90565b90565b6172cb6172c66172d0926172b4565b610687565b610794565b90565b6172e86172ed916172e2612795565b50612f78565b616a89565b6172f760ff617298565b168061730c617306601f6172b7565b91610794565b116173145790565b5f632cd44ac360e21b81528061732c60048201610913565b0390fd5b5490565b61733e6040613859565b90565b5f5260205f2090565b61735381617330565b82101561736d57617365600191617341565b910201905f90565b610ed7565b61737c9051611974565b90565b9061739065ffffffffffff91611bfe565b9181191691161790565b6173ae6173a96173b392611974565b610687565b611974565b90565b90565b906173ce6173c96173d59261739a565b6173b6565b825461737f565b9055565b6173e39051612413565b90565b60301b90565b906173fe65ffffffffffff19916173e6565b9181191691161790565b61741c61741761742192612413565b610687565b612413565b90565b90565b9061743c61743761744392617408565b617424565b82546173ec565b9055565b9061747160205f61747794617469828201617463848801617372565b906173b9565b0192016173d9565b90617427565b565b919061748a5761748891617447565b565b610b5e565b90815491680100000000000000008310156174bf57826174b79160016174bd9501815561734a565b90617479565b565b610c5a565b909291926174d0612546565b506174d9612546565b506174e382617330565b806174f66174f05f612ac6565b91610794565b115f146175c65761751c9061751684916175106001614445565b90612cee565b906162f9565b906175285f830161519f565b926175345f84016151d1565b938061754861754285611974565b91611974565b116175aa5761755f61755984611974565b91611974565b145f1461757a575050617575905f859101617427565b5b9190565b6175a592506175a08661759761758e617334565b945f8601616d27565b60208401616d35565b61748f565b617576565b5f632520601d60e01b8152806175c260048201610913565b0390fd5b506175f1916175ec856175e36175da617334565b945f8601616d27565b60208401616d35565b61748f565b6175fa5f6151de565b9190565b634e487b7160e01b5f52605160045260245ffd5b91909180600114617631576002036175fe5761762d916125c5565b905b565b5061763b91612586565b9061762f56
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"a\x01``@R4a\0vWa\0\x1Ea\0\x15a\x01cV[\x92\x91\x90\x91a\x03]V[a\0&a\0{V[avAa \xB9\x829`\x80Q\x81aO\xBC\x01R`\xA0Q\x81aO\xF3\x01R`\xC0Q\x81aO\x83\x01R`\xE0Q\x81a[\xDB\x01Ra\x01\0Q\x81a\\\0\x01Ra\x01 Q\x81aW\x8D\x01Ra\x01@Q\x81aW\xCD\x01RavA\x90\xF3[a\0\x81V[`@Q\x90V[_\x80\xFD[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\0\xAD\x90a\0\x85V[\x81\x01\x90\x81\x10`\x01\x80`@\x1B\x03\x82\x11\x17a\0\xC5W`@RV[a\0\x8FV[\x90a\0\xDDa\0\xD6a\0{V[\x92\x83a\0\xA3V[V[_\x80\xFD[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\0\xF7\x90a\0\xE3V[\x90V[a\x01\x03\x81a\0\xEEV[\x03a\x01\nWV[_\x80\xFD[\x90PQ\x90a\x01\x1B\x82a\0\xFAV[V[`\x80\x81\x83\x03\x12a\x01^Wa\x013\x82_\x83\x01a\x01\x0EV[\x92a\x01[a\x01D\x84` \x85\x01a\x01\x0EV[\x93a\x01R\x81`@\x86\x01a\x01\x0EV[\x93``\x01a\x01\x0EV[\x90V[a\0\xDFV[a\x01\x81a\x96\xFA\x808\x03\x80a\x01v\x81a\0\xCAV[\x92\x839\x81\x01\x90a\x01\x1DV[\x90\x91\x92\x93V[`\x01\x80`@\x1B\x03\x81\x11a\x01\xA3Wa\x01\x9F` \x91a\0\x85V[\x01\x90V[a\0\x8FV[\x90a\x01\xBAa\x01\xB5\x83a\x01\x87V[a\0\xCAV[\x91\x82RV[_\x7FSyndicate\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x01\xF0`\ta\x01\xA8V[\x90a\x01\xFD` \x83\x01a\x01\xBFV[V[a\x02\x07a\x01\xE6V[\x90V[_\x7FSYND\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x02;`\x04a\x01\xA8V[\x90a\x02H` \x83\x01a\x02\nV[V[a\x02Ra\x021V[\x90V[\x90V[\x90V[a\x02oa\x02ja\x02t\x92a\x02UV[a\x02XV[a\0\xE3V[\x90V[a\x02\x80\x90a\x02[V[\x90V[_\x01\x90V[\x90V[_\x1B\x90V[a\x02\xA4a\x02\x9Fa\x02\xA9\x92a\x02UV[a\x02\x8BV[a\x02\x88V[\x90V[a\x02\xB5_a\x02\x90V[\x90V[\x7Fk\x97%\xF7@\xF9K\x91\xB7\x80`\xA1\xB1}\x17tem8\x14!\xA5)\xEC\x98\xCD\xB0\x13\xF4\xD9\xC2^\x90V[\x7F\xCC\xE2\x96\xB0@3*\x08\x0Em\xF15\x15\xA3\xEC(i\xE2\x1C\xD2\x0FsD\xAF\t\x87\xDD\xB98\xD8\xBD!\x90V[\x7Fe\xD7\xA2\x8E2e\xB3zdt\x92\x9F3e!\xB32\xC1h\x1B\x93?l\xB9\xF37fsD\r\x86*\x90V[\x90V[\x90V[a\x03>a\x039a\x03C\x92a\x03$V[a\x02XV[a\x03'V[\x90V[a\x03ZjJr=\xC6\xB4\x0B\x8A\x9A\0\0\0a\x03*V[\x90V[\x90\x91\x92a\x03ya\x03ka\x01\xFFV[a\x03sa\x02JV[\x90a\x05\x16V[\x81a\x03\x94a\x03\x8Ea\x03\x89_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x04\xB0W\x82a\x03\xB4a\x03\xAEa\x03\xA9_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x04\x94W\x83a\x03\xD4a\x03\xCEa\x03\xC9_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x04xW\x80a\x03\xF4a\x03\xEEa\x03\xE9_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x04\\Wa\x045a\x04C\x92a\x04'a\x04R\x96a\x04\x19a\x04\x12a\x02\xACV[\x84\x90a\n:V[Pa\x04\"a\x02\xB8V[a\n:V[Pa\x040a\x02\xDCV[a\n:V[Pa\x04>a\x03\0V[a\n:V[Pa\x04La\x03FV[\x90a\x0B\x08V[a\x04Za\x0E\x10V[V[_c\xD9.#=`\xE0\x1B\x81R\x80a\x04t`\x04\x82\x01a\x02\x83V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a\x04\x90`\x04\x82\x01a\x02\x83V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a\x04\xAC`\x04\x82\x01a\x02\x83V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a\x04\xC8`\x04\x82\x01a\x02\x83V[\x03\x90\xFD[\x90a\x04\xD8`\xFF\x91a\x02\x8BV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x15\x15\x90V[a\x04\xF0\x90a\x04\xE2V[\x90V[\x90V[\x90a\x05\x0Ba\x05\x06a\x05\x12\x92a\x04\xE7V[a\x04\xF3V[\x82Ta\x04\xCCV[\x90UV[\x90a\x05 \x91a\x05-V[a\x05+_`\x0Fa\x04\xF6V[V[a\x059\x91\x81\x90\x91a\x05\xBCV[V[\x90V[a\x05Ra\x05Ma\x05W\x92a\x05;V[a\x02XV[a\x03'V[\x90V[a\x05d`\x01a\x05>V[\x90V[\x90a\x05s_\x19\x91a\x02\x8BV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x05\x91a\x05\x8Ca\x05\x96\x92a\x03'V[a\x02XV[a\x03'V[\x90V[\x90V[\x90a\x05\xB1a\x05\xACa\x05\xB8\x92a\x05}V[a\x05\x99V[\x82Ta\x05gV[\x90UV[\x90a\x05\xC7\x92\x91a\x05\xDBV[a\x05\xD9a\x05\xD2a\x05ZV[`\x0Ca\x05\x9CV[V[\x90a\x05\xE6\x92\x91a\x05\xE8V[V[\x90a\x05\xF3\x92\x91a\x05\xF5V[V[\x90a\x06\0\x92\x91a\x06\x02V[V[\x90a\x06\r\x92\x91a\x06\x0FV[V[\x90a\x06\x1A\x92\x91a\x06\x1CV[V[\x90a\x06'\x92\x91a\x06tV[V[_\x7F1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x06Z`\x01a\x01\xA8V[\x90a\x06g` \x83\x01a\x06)V[V[a\x06qa\x06PV[\x90V[\x90a\x06\x88\x92\x91a\x06\x82a\x06iV[\x90a\x06\x8AV[V[\x90a\x06\x96\x93\x92\x91a\x06\xDCV[V[\x90V[\x90V[` \x01\x90V[Q\x90V[a\x06\xBCa\x06\xB7a\x06\xC1\x92a\0\xE3V[a\x02XV[a\0\xE3V[\x90V[a\x06\xCD\x90a\x06\xA8V[\x90V[a\x06\xD9\x90a\x06\xC4V[\x90V[a\x06\xEDa\x07=\x94a\x07\"\x93\x94a\x07qV[a\x07\x01\x81a\x06\xFB`\x06a\x06\x98V[\x90a\x10:V[a\x01 Ra\x07\x19\x83a\x07\x13`\x07a\x06\x98V[\x90a\x10:V[a\x01@Ra\x06\x9BV[a\x074a\x07.\x82a\x06\xA4V[\x91a\x06\x9EV[ `\xE0Ra\x06\x9BV[a\x07Oa\x07I\x82a\x06\xA4V[\x91a\x06\x9EV[ a\x01\0RF`\xA0Ra\x07`a\x11?V[`\x80Ra\x07l0a\x06\xD0V[`\xC0RV[\x90a\x07{\x91a\x07}V[V[\x90a\x07\x87\x91a\x07\x89V[V[\x90a\x07\x93\x91a\t\xDAV[V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[Q\x90V[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x07\xE0W[` \x83\x10\x14a\x07\xDBWV[a\x07\xACV[\x91`\x7F\x16\x91a\x07\xD0V[_R` _ \x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a\x08\x1C\x91\x02\x91a\x08\x16_\x19\x84a\x07\xFDV[\x92a\x07\xFDV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x91\x90a\x08<a\x087a\x08D\x93a\x05}V[a\x05\x99V[\x90\x83Ta\x08\x01V[\x90UV[_\x90V[a\x08^\x91a\x08Xa\x08HV[\x91a\x08&V[V[[\x81\x81\x10a\x08lWPPV[\x80a\x08y_`\x01\x93a\x08LV[\x01a\x08aV[\x91\x90`\x1F\x81\x11a\x08\x8FW[PPPV[a\x08\x9Ba\x08\xC0\x93a\x07\xEAV[\x90` a\x08\xA7\x84a\x07\xF3V[\x83\x01\x93\x10a\x08\xC8W[a\x08\xB9\x90a\x07\xF3V[\x01\x90a\x08`V[_\x80\x80a\x08\x8AV[\x91Pa\x08\xB9\x81\x92\x90Pa\x08\xB0V[\x1C\x90V[\x90a\x08\xEA\x90_\x19\x90`\x08\x02a\x08\xD6V[\x19\x16\x90V[\x81a\x08\xF9\x91a\x08\xDAV[\x90`\x02\x02\x17\x90V[\x90a\t\x0B\x81a\x07\xA8V[\x90`\x01\x80`@\x1B\x03\x82\x11a\t\xC9Wa\t-\x82a\t'\x85Ta\x07\xC0V[\x85a\x08\x7FV[` \x90`\x1F\x83\x11`\x01\x14a\taW\x91\x80\x91a\tP\x93_\x92a\tUW[PPa\x08\xEFV[\x90U[V[\x90\x91P\x01Q_\x80a\tIV[`\x1F\x19\x83\x16\x91a\tp\x85a\x07\xEAV[\x92_[\x81\x81\x10a\t\xB1WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\t\x97W[PPP\x02\x01\x90Ua\tSV[a\t\xA7\x91\x01Q`\x1F\x84\x16\x90a\x08\xDAV[\x90U_\x80\x80a\t\x8BV[\x91\x93` `\x01\x81\x92\x87\x87\x01Q\x81U\x01\x95\x01\x92\x01a\tsV[a\0\x8FV[\x90a\t\xD8\x91a\t\x01V[V[\x90a\t\xE9a\t\xF0\x92`\x03a\t\xCEV[`\x04a\t\xCEV[V[_\x90V[a\t\xFF\x90a\x02\x88V[\x90V[\x90a\n\x0C\x90a\t\xF6V[_R` R`@_ \x90V[a\n!\x90a\x06\xC4V[\x90V[\x90a\n.\x90a\n\x18V[_R` R`@_ \x90V[a\nBa\t\xF2V[Pa\nWa\nQ\x82\x84\x90a\x11\xDCV[\x15a\x04\xE2V[_\x14a\n\xE0Wa\n\x7F`\x01a\nz_a\nr`\x05\x86\x90a\n\x02V[\x01\x85\x90a\n$V[a\x04\xF6V[\x90a\n\x88a\x12\nV[\x90a\n\xC5a\n\xBFa\n\xB9\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a\t\xF6V[\x92a\n\x18V[\x92a\n\x18V[\x92a\n\xCEa\0{V[\x80a\n\xD8\x81a\x02\x83V[\x03\x90\xA4`\x01\x90V[PP_\x90V[a\n\xEF\x90a\0\xEEV[\x90RV[\x91\x90a\x0B\x06\x90_` \x85\x01\x94\x01\x90a\n\xE6V[V[\x80a\x0B#a\x0B\x1Da\x0B\x18_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x0B?Wa\x0B=\x91a\x0B5_a\x02wV[\x91\x90\x91a\x12\x17V[V[a\x0Bba\x0BK_a\x02wV[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\n\xF3V[\x03\x90\xFD[`\x01\x80`@\x1B\x03\x81\x11a\x0ByW` \x02\x90V[a\0\x8FV[a\x0B\x8Aa\x0B\x8F\x91a\x0BfV[a\0\xCAV[\x90V[\x90V[a\x0B\xA9a\x0B\xA4a\x0B\xAE\x92a\x0B\x92V[a\x02XV[a\x03'V[\x90V[\x90a\x0B\xBB\x90a\x03'V[\x90RV[\x90V[a\x0B\xD6a\x0B\xD1a\x0B\xDB\x92a\x0B\xBFV[a\x02XV[a\x03'V[\x90V[\x90V[a\x0B\xF5a\x0B\xF0a\x0B\xFA\x92a\x0B\xDEV[a\x02XV[a\x03'V[\x90V[\x90V[a\x0C\x14a\x0C\x0Fa\x0C\x19\x92a\x0B\xFDV[a\x02XV[a\x03'V[\x90V[\x90V[a\x0C3a\x0C.a\x0C8\x92a\x0C\x1CV[a\x02XV[a\x03'V[\x90V[\x90V[a\x0CRa\x0CMa\x0CW\x92a\x0C;V[a\x02XV[a\x03'V[\x90V[\x90V[a\x0Cqa\x0Cla\x0Cv\x92a\x0CZV[a\x02XV[a\x03'V[\x90V[\x90V[a\x0C\x90a\x0C\x8Ba\x0C\x95\x92a\x0CyV[a\x02XV[a\x03'V[\x90V[a\x0C\xACa\x0C\xA7a\x0C\xB1\x92a\x02UV[a\x02XV[a\x03'V[\x90V[`\x01a\x0C\xC0\x91\x01a\x03'V[\x90V[\x90V[a\x0C\xDAa\x0C\xD5a\x0C\xDF\x92a\x0C\xC3V[a\x02XV[a\x03'V[\x90V[\x90V[a\x0C\xF9a\x0C\xF4a\x0C\xFE\x92a\x0C\xE2V[a\x02XV[a\x03'V[\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\r$a\r*\x91\x93\x92\x93a\x03'V[\x92a\x03'V[\x91a\r6\x83\x82\x02a\x03'V[\x92\x81\x84\x04\x14\x90\x15\x17\x15a\rEWV[a\r\x01V[a\rYa\r_\x91\x93\x92\x93a\x03'V[\x92a\x03'V[\x82\x01\x80\x92\x11a\rjWV[a\r\x01V[\x90V[a\r\x86a\r\x81a\r\x8B\x92a\roV[a\x02XV[a\x03'V[\x90V[a\r\x98`0a\rrV[\x90V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[P`\x08\x90V[\x90a\r\xBF\x82a\r\xAFV[\x81\x10\x15a\r\xCDW` \x02\x01\x90V[a\r\x9BV[a\r\xDC\x90Qa\x03'V[\x90V[P`0\x90V[\x90V[a\r\xF1\x81a\r\xDFV[\x82\x10\x15a\x0E\x0BWa\x0E\x03`\x01\x91a\r\xE5V[\x91\x02\x01\x90_\x90V[a\r\x9BV[a\x0E\x1A`\x08a\x0B~V[a\x0E8a\x0E0i\x8F\x95oiz\xA4\x92<\0\0a\x0B\x95V[_\x83\x01a\x0B\xB1V[a\x0EWa\x0ENiV&v\x0C\x16b\xBE$\0\0a\x0B\xC2V[` \x83\x01a\x0B\xB1V[a\x0Eva\x0Emi3\xB0\xB0\0\xFE\xC5\x93\x90\0\0a\x0B\xE1V[`@\x83\x01a\x0B\xB1V[a\x0E\x95a\x0E\x8Ci\x1F\x03\x9C\xCDe\xA9\xBE\xF0\0\0a\x0C\0V[``\x83\x01a\x0B\xB1V[a\x0E\xB4a\x0E\xABi\x12\x9B\xC4{<\xFFr\x90\0\0a\x0C\x1FV[`\x80\x83\x01a\x0B\xB1V[a\x0E\xD3a\x0E\xCAi\x0B*H=m\xAD\xEE\x18\0\0a\x0C>V[`\xA0\x83\x01a\x0B\xB1V[a\x0E\xF2a\x0E\xE9i\x06\xB2\xEF\xD1:\x96*l\0\0a\x0C]V[`\xC0\x83\x01a\x0B\xB1V[a\x0F\x11a\x0F\x08i\x04\x04\xF6JVZ\x19t\0\0a\x0C|V[`\xE0\x83\x01a\x0B\xB1V[a\x0F\x1A_a\x0C\x98V[\x91[\x82a\x0F0a\x0F*`\x08a\x0C\xC6V[\x91a\x03'V[\x10\x15a\x0F\xE6Wa\x0F?_a\x0C\x98V[[\x80a\x0FTa\x0FN`\x06a\x0C\xE5V[\x91a\x03'V[\x10\x15a\x0F\xD5Wa\x0F\xA2\x90a\x0F|a\x0Fu\x86a\x0Fo`\x06a\x0C\xE5V[\x90a\r\x15V[\x82\x90a\rJV[\x80a\x0F\x96a\x0F\x90a\x0F\x8Ba\r\x8EV[a\x03'V[\x91a\x03'V[\x10a\x0F\xA7W[Pa\x0C\xB4V[a\x0F@V[a\x0F\xCF\x90a\x0F\xC9a\x0F\xC1a\x0F\xBC\x88\x8A\x90a\r\xB5V[a\r\xD2V[\x91`\x10a\r\xE8V[\x90a\x08&V[_a\x0F\x9CV[P\x91a\x0F\xE0\x90a\x0C\xB4V[\x91a\x0F\x1CV[\x91PPV[_\x90V[\x90V[a\x10\x06a\x10\x01a\x10\x0B\x92a\x0F\xEFV[a\x02XV[a\x03'V[\x90V[\x90V[a\x10%a\x10 a\x10*\x92a\x10\x0EV[a\x02\x8BV[a\x02\x88V[\x90V[a\x107`\xFFa\x10\x11V[\x90V[\x90a\x10Ca\x0F\xEBV[Pa\x10Ua\x10P\x83a\x06\x9BV[a\x06\xA4V[a\x10ha\x10b` a\x0F\xF2V[\x91a\x03'V[\x10_\x14a\x10|WPa\x10y\x90a\x13\x16V[\x90V[_a\x10\x8Aa\x10\x90\x93\x92a\x12&V[\x01a\t\xCEV[a\x10\xA0a\x10\x9Ba\x10-V[a\t\xF6V[\x90V[_\x90V[\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x90V[a\x10\xD5\x90Qa\x02\x88V[\x90V[a\x10\xE1\x90a\x02\x88V[\x90RV[a\x10\xEE\x90a\x03'V[\x90RV[\x90\x95\x94\x92a\x11=\x94a\x11,a\x116\x92a\x11\"`\x80\x96a\x11\x18`\xA0\x88\x01\x9C_\x89\x01\x90a\x10\xD8V[` \x87\x01\x90a\x10\xD8V[`@\x85\x01\x90a\x10\xD8V[``\x83\x01\x90a\x10\xE5V[\x01\x90a\n\xE6V[V[a\x11Ga\x10\xA3V[Pa\x11Pa\x10\xA7V[a\x11\x9Aa\x11]`\xE0a\x10\xCBV[\x91a\x11\x8Ba\x11la\x01\0a\x10\xCBV[Fa\x11v0a\x06\xD0V[\x91a\x11\x7Fa\0{V[\x96\x87\x95` \x87\x01a\x10\xF2V[` \x82\x01\x81\x03\x82R\x03\x82a\0\xA3V[a\x11\xACa\x11\xA6\x82a\x06\xA4V[\x91a\x06\x9EV[ \x90V[_\x1C\x90V[`\xFF\x16\x90V[a\x11\xC7a\x11\xCC\x91a\x11\xB0V[a\x11\xB5V[\x90V[a\x11\xD9\x90Ta\x11\xBBV[\x90V[a\x12\x03\x91_a\x11\xF8a\x11\xFE\x93a\x11\xF0a\t\xF2V[P`\x05a\n\x02V[\x01a\n$V[a\x11\xCFV[\x90V[_\x90V[a\x12\x12a\x12\x06V[P3\x90V[\x91a\x12$\x92\x91\x90\x91a\x13\xC3V[V[\x90V[\x90V[a\x12@a\x12;a\x12E\x92a\x12)V[a\x02XV[a\x03'V[\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[a\x12{a\x12\x84` \x93a\x12\x89\x93a\x12r\x81a\x07\xA8V[\x93\x84\x80\x93a\x12HV[\x95\x86\x91\x01a\x12QV[a\0\x85V[\x01\x90V[a\x12\xA2\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x12\\V[\x90V[a\x12\xBFa\x12\xBAa\x12\xB4\x83a\x06\xA4V[\x92a\x06\x9EV[a\x10\xCBV[\x90` \x81\x10a\x12\xCDW[P\x90V[a\x12\xDF\x90_\x19\x90` \x03`\x08\x02a\x07\xFDV[\x16_a\x12\xC9V[a\x12\xF2a\x12\xF7\x91a\x11\xB0V[a\x05}V[\x90V[a\x13\x0Ea\x13\ta\x13\x13\x92a\x03'V[a\x02\x8BV[a\x02\x88V[\x90V[a\x13\x1Ea\x0F\xEBV[Pa\x13(\x81a\x06\x9BV[\x90a\x132\x82a\x06\xA4V[a\x13Ea\x13?`\x1Fa\x12,V[\x91a\x03'V[\x11a\x13zWPa\x13r\x81a\x13la\x13fa\x13aa\x13w\x95a\x12\xA5V[a\x12\xE6V[\x91a\x06\xA4V[\x17a\x12\xFAV[a\t\xF6V[\x90V[a\x13\x9C\x90a\x13\x86a\0{V[\x91\x82\x91c0Z'\xA9`\xE0\x1B\x83R`\x04\x83\x01a\x12\x8DV[\x03\x90\xFD[\x91` a\x13\xC1\x92\x94\x93a\x13\xBA`@\x82\x01\x96_\x83\x01\x90a\x10\xE5V[\x01\x90a\x10\xE5V[V[\x92\x91a\x13\xD1\x84\x83\x83\x91a\x14\xF0V[\x83a\x13\xECa\x13\xE6a\x13\xE1_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x14\x01W[a\x13\xFF\x92\x93\x91\x90\x91a\x16\xBDV[V[a\x14\ta\x16_V[\x93a\x14\x12a\x16\x9CV[\x94\x80a\x14&a\x14 \x88a\x03'V[\x91a\x03'V[\x11a\x143WP\x93Pa\x13\xF2V[\x85\x90a\x14O_\x92\x83\x92c\x0EX\xAE\x93`\xE1\x1B\x84R`\x04\x84\x01a\x13\xA0V[\x03\x90\xFD[\x90a\x14]\x90a\n\x18V[_R` R`@_ \x90V[\x90V[a\x14xa\x14}\x91a\x11\xB0V[a\x14iV[\x90V[a\x14\x8A\x90Ta\x14lV[\x90V[`@\x90a\x14\xB6a\x14\xBD\x94\x96\x95\x93\x96a\x14\xAC``\x84\x01\x98_\x85\x01\x90a\n\xE6V[` \x83\x01\x90a\x10\xE5V[\x01\x90a\x10\xE5V[V[\x90a\x14\xCA\x91\x03a\x03'V[\x90V[\x90a\x14\xD8\x91\x01a\x03'V[\x90V[\x91\x90a\x14\xEE\x90_` \x85\x01\x94\x01\x90a\x10\xE5V[V[\x91\x90\x91\x80a\x15\x0Ea\x15\x08a\x15\x03_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14_\x14a\x15\xEFWa\x152a\x15+\x83a\x15&`\x02a\x14\x80V[a\rJV[`\x02a\x05\x9CV[[\x82a\x15Na\x15Ha\x15C_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14_\x14a\x15\xC3Wa\x15ra\x15k\x83a\x15f`\x02a\x14\x80V[a\x14\xBFV[`\x02a\x05\x9CV[[\x91\x90\x91a\x15\xBEa\x15\xACa\x15\xA6\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x93a\n\x18V[\x93a\n\x18V[\x93a\x15\xB5a\0{V[\x91\x82\x91\x82a\x14\xDBV[\x03\x90\xA3V[a\x15\xEA\x82a\x15\xE4a\x15\xD5_\x87\x90a\x14SV[\x91a\x15\xDF\x83a\x14\x80V[a\x14\xCDV[\x90a\x05\x9CV[a\x15sV[a\x16\x02a\x15\xFD_\x83\x90a\x14SV[a\x14\x80V[\x80a\x16\x15a\x16\x0F\x85a\x03'V[\x91a\x03'V[\x10a\x16=Wa\x16(a\x168\x91\x84\x90a\x14\xBFV[a\x163_\x84\x90a\x14SV[a\x05\x9CV[a\x153V[\x90a\x16[\x90\x91\x92_\x93\x84\x93c9\x144\xE3`\xE2\x1B\x85R`\x04\x85\x01a\x14\x8DV[\x03\x90\xFD[a\x16ga\x08HV[Pa\x16r`\x02a\x14\x80V[\x90V[`\x01\x80`\xD0\x1B\x03\x16\x90V[a\x16\x94a\x16\x8Fa\x16\x99\x92a\x16uV[a\x02XV[a\x03'V[\x90V[a\x16\xA4a\x08HV[Pa\x16\xB4`\x01\x80`\xD0\x1B\x03a\x16\x80V[\x90V[\x90V[\x90V[\x91a\x17\x15a\x17\x0Fa\x17\x1C\x94\x80a\x16\xE3a\x16\xDDa\x16\xD8_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x17MW[\x84a\x17\x04a\x16\xFEa\x16\xF9_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x17\x1EW[a\x19EV[\x92a\x19EV[\x90\x91a\x19zV[V[a\x17F`\x0B`\x02a\x17@a\x17:a\x174\x89a\x18/V[\x93a\x16\xB7V[\x91a\x16\xBAV[\x90a\x18\x82V[PPa\x17\nV[a\x17u`\x0B`\x01a\x17oa\x17ia\x17c\x89a\x18/V[\x93a\x16\xB7V[\x91a\x16\xBAV[\x90a\x18\x82V[PPa\x16\xE9V[_\x90V[a\x17\x8Ca\x17\x92\x91a\x16uV[\x91a\x16uV[\x01\x90`\x01\x80`\xD0\x1B\x03\x82\x11a\x17\xA3WV[a\r\x01V[\x90a\x17\xBB\x91a\x17\xB5a\x17|V[Pa\x17\x80V[\x90V[\x90V[`\xFF\x16\x90V[a\x17\xDBa\x17\xD6a\x17\xE0\x92a\x17\xBEV[a\x02XV[a\x17\xC1V[\x90V[a\x17\xEC\x90a\x17\xC7V[\x90RV[\x91` a\x18\x11\x92\x94\x93a\x18\n`@\x82\x01\x96_\x83\x01\x90a\x17\xE3V[\x01\x90a\x10\xE5V[V[a\x18'a\x18\"a\x18,\x92a\x03'V[a\x02XV[a\x16uV[\x90V[a\x187a\x17|V[P\x80a\x18Qa\x18K`\x01\x80`\xD0\x1B\x03a\x16\x80V[\x91a\x03'V[\x11a\x18bWa\x18_\x90a\x18\x13V[\x90V[`\xD0a\x18~_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01a\x17\xF0V[\x03\x90\xFD[\x90a\x18\xB8a\x18\xBE\x93\x92a\x18\x93a\x17|V[Pa\x18\x9Ca\x17|V[P\x80\x93a\x18\xB1a\x18\xAAa\x1B,V[\x94\x92a\x1B\xBAV[\x90\x91a \x89V[\x91a\x1C/V[\x91\x90\x91\x90V[a\x18\xD0a\x18\xD6\x91a\x16uV[\x91a\x16uV[\x90\x03\x90`\x01\x80`\xD0\x1B\x03\x82\x11a\x18\xE8WV[a\r\x01V[\x90a\x19\0\x91a\x18\xFAa\x17|V[Pa\x18\xC4V[\x90V[\x90a\x19\r\x90a\n\x18V[_R` R`@_ \x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x190a\x195\x91a\x11\xB0V[a\x19\x19V[\x90V[a\x19B\x90Ta\x19$V[\x90V[a\x19\\a\x19a\x91a\x19Ta\x12\x06V[P`\ta\x19\x03V[a\x198V[\x90V[\x90a\x19n\x90a\n\x18V[_R` R`@_ \x90V[\x91\x90\x91\x80a\x19\x90a\x19\x8A\x85a\0\xEEV[\x91a\0\xEEV[\x14\x15\x80a\x1B\x0EW[a\x19\xA2W[PPPV[\x80a\x19\xBDa\x19\xB7a\x19\xB2_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x03a\x1A~W[P\x81a\x19\xDFa\x19\xD9a\x19\xD4_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x03a\x19\xEBW[\x80a\x19\x9DV[a\x1A2a\x1A%a\x1A,\x92a\x1A\x01`\n\x86\x90a\x19dV[\x90a\x1A\x1Fa\x1A\x19a\x1A\x13`\x01\x93a\x18/V[\x93a\x16\xB7V[\x91a\x16\xBAV[\x90a\x18\x82V[\x92\x90a\x16\x80V[\x91a\x16\x80V[\x91\x90\x91a\x1A_\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\n\x18V[\x92a\x1Ata\x1Aka\0{V[\x92\x83\x92\x83a\x13\xA0V[\x03\x90\xA2_\x80a\x19\xE5V[a\x1A\xBDa\x1A\xC3a\x1A\xB6a\x1A\x93`\n\x85\x90a\x19dV[`\x02a\x1A\xB0a\x1A\xAAa\x1A\xA4\x89a\x18/V[\x93a\x16\xB7V[\x91a\x16\xBAV[\x90a\x18\x82V[\x92\x90a\x16\x80V[\x91a\x16\x80V[\x91\x90\x91a\x1A\xF0\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\n\x18V[\x92a\x1B\x05a\x1A\xFCa\0{V[\x92\x83\x92\x83a\x13\xA0V[\x03\x90\xA2_a\x19\xC3V[P\x81a\x1B\"a\x1B\x1C_a\x0C\x98V[\x91a\x03'V[\x11a\x19\x98V[_\x90V[a\x1B4a\x1B(V[Pa\x1B=a\x1C^V[\x90V[T\x90V[a\x1BSa\x1BY\x91\x93\x92\x93a\x03'V[\x92a\x03'V[\x82\x03\x91\x82\x11a\x1BdWV[a\r\x01V[\x90V[`0\x1C\x90V[`\x01\x80`\xD0\x1B\x03\x16\x90V[a\x1B\x89a\x1B\x8E\x91a\x1BlV[a\x1BrV[\x90V[a\x1B\x9B\x90Ta\x1B}V[\x90V[a\x1B\xB2a\x1B\xADa\x1B\xB7\x92a\x02UV[a\x02XV[a\x16uV[\x90V[a\x1B\xC2a\x17|V[Pa\x1B\xCE_\x82\x01a\x1B@V[\x80a\x1B\xE1a\x1B\xDB_a\x0C\x98V[\x91a\x03'V[\x14_\x14a\x1B\xF7WPPa\x1B\xF3_a\x1B\x9EV[[\x90V[a\x1C$_\x91a\x1C\x1Fa\x1C\x19\x84a\x1C*\x96\x01\x92a\x1C\x13`\x01a\x05>V[\x90a\x1BDV[\x91a\x1BiV[a\x1CsV[\x01a\x1B\x91V[a\x1B\xF4V[\x91a\x1CS_a\x1CX\x94a\x1C@a\x17|V[Pa\x1CIa\x17|V[P\x01\x92\x91\x92a\x1BiV[a\x1EdV[\x91\x90\x91\x90V[a\x1Cfa\x1B(V[Pa\x1CpCa \"V[\x90V[_R` _ \x01\x90V[T\x90V[a\x1C\x8B`@a\0\xCAV[\x90V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[\x90a\x1C\xA3\x90a\x1C\x8EV[\x90RV[\x90a\x1C\xB1\x90a\x16uV[\x90RV[_R` _ \x90V[a\x1C\xC7\x81a\x1C}V[\x82\x10\x15a\x1C\xE1Wa\x1C\xD9`\x01\x91a\x1C\xB5V[\x91\x02\x01\x90_\x90V[a\r\x9BV[a\x1C\xF0\x90Qa\x1C\x8EV[\x90V[\x90a\x1D\x04e\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x02\x8BV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x1D\"a\x1D\x1Da\x1D'\x92a\x1C\x8EV[a\x02XV[a\x1C\x8EV[\x90V[\x90V[\x90a\x1DBa\x1D=a\x1DI\x92a\x1D\x0EV[a\x1D*V[\x82Ta\x1C\xF3V[\x90UV[a\x1DW\x90Qa\x16uV[\x90V[`0\x1B\x90V[\x90a\x1Dre\xFF\xFF\xFF\xFF\xFF\xFF\x19\x91a\x1DZV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x1D\x90a\x1D\x8Ba\x1D\x95\x92a\x16uV[a\x02XV[a\x16uV[\x90V[\x90V[\x90a\x1D\xB0a\x1D\xABa\x1D\xB7\x92a\x1D|V[a\x1D\x98V[\x82Ta\x1D`V[\x90UV[\x90a\x1D\xE5` _a\x1D\xEB\x94a\x1D\xDD\x82\x82\x01a\x1D\xD7\x84\x88\x01a\x1C\xE6V[\x90a\x1D-V[\x01\x92\x01a\x1DMV[\x90a\x1D\x9BV[V[\x91\x90a\x1D\xFEWa\x1D\xFC\x91a\x1D\xBBV[V[a\x07\x95V[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15a\x1E3W\x82a\x1E+\x91`\x01a\x1E1\x95\x01\x81Ua\x1C\xBEV[\x90a\x1D\xEDV[V[a\0\x8FV[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x1EOa\x1ET\x91a\x11\xB0V[a\x1E8V[\x90V[a\x1Ea\x90Ta\x1ECV[\x90V[\x90\x92\x91\x92a\x1Epa\x17|V[Pa\x1Eya\x17|V[Pa\x1E\x83\x82a\x1C}V[\x80a\x1E\x96a\x1E\x90_a\x0C\x98V[\x91a\x03'V[\x11_\x14a\x1FfWa\x1E\xBC\x90a\x1E\xB6\x84\x91a\x1E\xB0`\x01a\x05>V[\x90a\x1BDV[\x90a\x1CsV[\x90a\x1E\xC8_\x83\x01a\x1EWV[\x92a\x1E\xD4_\x84\x01a\x1B\x91V[\x93\x80a\x1E\xE8a\x1E\xE2\x85a\x1C\x8EV[\x91a\x1C\x8EV[\x11a\x1FJWa\x1E\xFFa\x1E\xF9\x84a\x1C\x8EV[\x91a\x1C\x8EV[\x14_\x14a\x1F\x1AWPPa\x1F\x15\x90_\x85\x91\x01a\x1D\x9BV[[\x91\x90V[a\x1FE\x92Pa\x1F@\x86a\x1F7a\x1F.a\x1C\x81V[\x94_\x86\x01a\x1C\x99V[` \x84\x01a\x1C\xA7V[a\x1E\x03V[a\x1F\x16V[_c% `\x1D`\xE0\x1B\x81R\x80a\x1Fb`\x04\x82\x01a\x02\x83V[\x03\x90\xFD[Pa\x1F\x91\x91a\x1F\x8C\x85a\x1F\x83a\x1Fza\x1C\x81V[\x94_\x86\x01a\x1C\x99V[` \x84\x01a\x1C\xA7V[a\x1E\x03V[a\x1F\x9A_a\x1B\x9EV[\x91\x90V[a\x1F\xB2a\x1F\xADa\x1F\xB7\x92a\x1C\x8EV[a\x02XV[a\x03'V[\x90V[a\x1F\xCEa\x1F\xC9a\x1F\xD3\x92a\roV[a\x02XV[a\x17\xC1V[\x90V[a\x1F\xDF\x90a\x1F\xBAV[\x90RV[\x91` a \x04\x92\x94\x93a\x1F\xFD`@\x82\x01\x96_\x83\x01\x90a\x1F\xD6V[\x01\x90a\x10\xE5V[V[a \x1Aa \x15a \x1F\x92a\x03'V[a\x02XV[a\x1C\x8EV[\x90V[a *a\x1B(V[P\x80a Da >e\xFF\xFF\xFF\xFF\xFF\xFFa\x1F\x9EV[\x91a\x03'V[\x11a UWa R\x90a \x06V[\x90V[`0a q_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01a\x1F\xE3V[\x03\x90\xFD[cNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[\x91\x90\x91\x80`\x01\x14a \xA8W`\x02\x03a uWa \xA4\x91a\x18\xEDV[\x90[V[Pa \xB2\x91a\x17\xA8V[\x90a \xA6V\xFE`\x80`@R`\x046\x10\x15a\0\x13W[a%BV[a\0\x1D_5a\x05\x0CV[\x80c\x01\xFF\xC9\xA7\x14a\x05\x07W\x80c\x06\xFD\xDE\x03\x14a\x05\x02W\x80c\x07\xA1\xD5\xFA\x14a\x04\xFDW\x80c\t^\xA7\xB3\x14a\x04\xF8W\x80c\x0C\x05\xF8,\x14a\x04\xF3W\x80c\x13\xBE\xAA[\x14a\x04\xEEW\x80c\x18\x16\r\xDD\x14a\x04\xE9W\x80c\x1B\x02\xF8E\x14a\x04\xE4W\x80c\"\xA9}\x9C\x14a\x04\xDFW\x80c#\xB8r\xDD\x14a\x04\xDAW\x80c#\xE4`\xD2\x14a\x04\xD5W\x80c$:0\xCC\x14a\x04\xD0W\x80c$\x81\xBB\\\x14a\x04\xCBW\x80c$\x8A\x9C\xA3\x14a\x04\xC6W\x80c(N\x133\x14a\x04\xC1W\x80c//\xF1]\x14a\x04\xBCW\x80c1<\xE5g\x14a\x04\xB7W\x80c3M\x0B\xBD\x14a\x04\xB2W\x80c5\x9Bv\xFE\x14a\x04\xADW\x80c6D\xE5\x15\x14a\x04\xA8W\x80c6V\x8A\xBE\x14a\x04\xA3W\x80c:F\xB1\xA8\x14a\x04\x9EW\x80c?K\xA8:\x14a\x04\x99W\x80c@\xC1\x0F\x19\x14a\x04\x94W\x80cD\xE1\x81\xAA\x14a\x04\x8FW\x80cH\xB0\xDA\xA6\x14a\x04\x8AW\x80cK\xDD6\xCE\x14a\x04\x85W\x80cK\xF5\xD7\xE9\x14a\x04\x80W\x80cX|\xDE\x1E\x14a\x04{W\x80cZ\xDF\0!\x14a\x04vW\x80c\\\x19\xA9\\\x14a\x04qW\x80c\\\x97Z\xBB\x14a\x04lW\x80c_\x15\xC3\xC9\x14a\x04gW\x80ce\x1F\xD2h\x14a\x04bW\x80cl3\xBC\xED\x14a\x04]W\x80cl\xF0\x16%\x14a\x04XW\x80co\xC0c\xBE\x14a\x04SW\x80co\xCF\xFFE\x14a\x04NW\x80cp\xA0\x821\x14a\x04IW\x80crf\0\xCE\x14a\x04DW\x80cvg\x18\x08\x14a\x04?W\x80c|y\x0C\xAB\x14a\x04:W\x80c~\xCE\xBE\0\x14a\x045W\x80c\x84V\xCBY\x14a\x040W\x80c\x84\xB0\x19n\x14a\x04+W\x80c\x8ES\x9E\x8C\x14a\x04&W\x80c\x90-U\xA5\x14a\x04!W\x80c\x91\xD1HT\x14a\x04\x1CW\x80c\x91\xDD\xAD\xF4\x14a\x04\x17W\x80c\x95\xD8\x9BA\x14a\x04\x12W\x80c\x99\x12}\x9B\x14a\x04\rW\x80c\x99\x89U\xD3\x14a\x04\x08W\x80c\x9A\xB2N\xB0\x14a\x04\x03W\x80c\x9B~\xF6K\x14a\x03\xFEW\x80c\x9D\xC2\x9F\xAC\x14a\x03\xF9W\x80c\xA0\x8DVT\x14a\x03\xF4W\x80c\xA2\x17\xFD\xDF\x14a\x03\xEFW\x80c\xA3\xD4H[\x14a\x03\xEAW\x80c\xA4\xD7\xE3\x1D\x14a\x03\xE5W\x80c\xA5q\xE1\x84\x14a\x03\xE0W\x80c\xA5\xB3&\xBE\x14a\x03\xDBW\x80c\xA7\x0B\x9F\x0C\x14a\x03\xD6W\x80c\xA9\x05\x9C\xBB\x14a\x03\xD1W\x80c\xAE^\xCB\xC6\x14a\x03\xCCW\x80c\xAF*\xA6;\x14a\x03\xC7W\x80c\xB0\xCA%>\x14a\x03\xC2W\x80c\xBA\xBC9O\x14a\x03\xBDW\x80c\xBBMD6\x14a\x03\xB8W\x80c\xC0*\xE7T\x14a\x03\xB3W\x80c\xC1\xEBq7\x14a\x03\xAEW\x80c\xC3\xCD\xA5 \x14a\x03\xA9W\x80c\xD5\x05\xAC\xCF\x14a\x03\xA4W\x80c\xD5Gt\x1F\x14a\x03\x9FW\x80c\xDDb\xED>\x14a\x03\x9AW\x80c\xE3\xAB\xDF\xCB\x14a\x03\x95W\x80c\xE6:\xB1\xE9\x14a\x03\x90W\x80c\xF1\x12~\xD8\x14a\x03\x8BW\x80c\xF5\x08\xE1\x9D\x14a\x03\x86Wc\xF7^\x85\x12\x03a\0\x0EWa%\rV[a$\xA9V[a$dV[a#\x81V[a#\x1DV[a\"\xB8V[a\"WV[a\"\x1DV[a!sV[a \xB7V[a \x82V[a MV[a \x14V[a\x1F\xA0V[a\x1FkV[a\x1E\xC1V[a\x1EMV[a\x1E\x18V[a\x1D\xAAV[a\x1DwV[a\x1C\xF5V[a\x1C\xC0V[a\x1C6V[a\x1B\xC7V[a\x1BYV[a\x1B$V[a\x1A\xAEV[a\x1AyV[a\x1ADV[a\x19\xD6V[a\x19\xA1V[a\x19>V[a\x19\tV[a\x18\x93V[a\x18WV[a\x17\x12V[a\x16\xDDV[a\x16\xA4V[a\x16\"V[a\x15\xDEV[a\x15\xA9V[a\x15tV[a\x15\x14V[a\x14\xB0V[a\x14<V[a\x14\x07V[a\x13\xD2V[a\x13fV[a\x133V[a\x12\xFEV[a\x12\xC9V[a\x12rV[a\x12=V[a\x12\x08V[a\x11\xC0V[a\x10\xABV[a\x10xV[a\x10BV[a\x10\x0EV[a\x0F\xD9V[a\x0F\xA6V[a\x0FqV[a\x0E\x84V[a\x0E(V[a\r\xC8V[a\r\x93V[a\x0C\xF8V[a\x0B)V[a\n\xBBV[a\nbV[a\t\xF3V[a\t\x81V[a\tLV[a\t\x18V[a\x08]V[a\x07\xE7V[a\x07/V[a\x06GV[a\x05\x98V[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x80\xFD[c\xFF\xFF\xFF\xFF`\xE0\x1B\x16\x90V[a\x059\x81a\x05$V[\x03a\x05@WV[_\x80\xFD[\x90P5\x90a\x05Q\x82a\x050V[V[\x90` \x82\x82\x03\x12a\x05lWa\x05i\x91_\x01a\x05DV[\x90V[a\x05\x1CV[\x15\x15\x90V[a\x05\x7F\x90a\x05qV[\x90RV[\x91\x90a\x05\x96\x90_` \x85\x01\x94\x01\x90a\x05vV[V[4a\x05\xC8Wa\x05\xC4a\x05\xB3a\x05\xAE6`\x04a\x05SV[a%\xDFV[a\x05\xBBa\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[_\x91\x03\x12a\x05\xD7WV[a\x05\x1CV[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[`\x1F\x80\x19\x91\x01\x16\x90V[a\x06\x1Da\x06&` \x93a\x06+\x93a\x06\x14\x81a\x05\xDCV[\x93\x84\x80\x93a\x05\xE0V[\x95\x86\x91\x01a\x05\xE9V[a\x05\xF4V[\x01\x90V[a\x06D\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x05\xFEV[\x90V[4a\x06wWa\x06W6`\x04a\x05\xCDV[a\x06sa\x06ba&\xFDV[a\x06ja\x05\x12V[\x91\x82\x91\x82a\x06/V[\x03\x90\xF3[a\x05\x18V[`\x01\x80`\xA0\x1B\x03\x16\x90V[\x90V[a\x06\x9Ea\x06\x99a\x06\xA3\x92a\x06|V[a\x06\x87V[a\x06|V[\x90V[a\x06\xAF\x90a\x06\x8AV[\x90V[a\x06\xBB\x90a\x06\xA6V[\x90V[a\x06\xC7\x90a\x06\xB2V[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[a\x06\xF7a\x07\0` \x93a\x07\x05\x93a\x06\xEE\x81a\x06\xCBV[\x93\x84\x80\x93a\x06\xCFV[\x95\x86\x91\x01a\x05\xE9V[a\x05\xF4V[\x01\x90V[\x91a\x07,\x92a\x07\x1F`@\x82\x01\x93_\x83\x01\x90a\x06\xBEV[` \x81\x84\x03\x91\x01Ra\x06\xD8V[\x90V[4a\x07`Wa\x07?6`\x04a\x05\xCDV[a\x07Ga'IV[\x90a\x07\\a\x07Sa\x05\x12V[\x92\x83\x92\x83a\x07\tV[\x03\x90\xF3[a\x05\x18V[a\x07n\x90a\x06|V[\x90V[a\x07z\x81a\x07eV[\x03a\x07\x81WV[_\x80\xFD[\x90P5\x90a\x07\x92\x82a\x07qV[V[\x90V[a\x07\xA0\x81a\x07\x94V[\x03a\x07\xA7WV[_\x80\xFD[\x90P5\x90a\x07\xB8\x82a\x07\x97V[V[\x91\x90`@\x83\x82\x03\x12a\x07\xE2W\x80a\x07\xD6a\x07\xDF\x92_\x86\x01a\x07\x85V[\x93` \x01a\x07\xABV[\x90V[a\x05\x1CV[4a\x08\x18Wa\x08\x14a\x08\x03a\x07\xFD6`\x04a\x07\xBAV[\x90a'sV[a\x08\x0Ba\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[\x90` \x82\x82\x03\x12a\x086Wa\x083\x91_\x01a\x07\x85V[\x90V[a\x05\x1CV[a\x08D\x90a\x07\x94V[\x90RV[\x91\x90a\x08[\x90_` \x85\x01\x94\x01\x90a\x08;V[V[4a\x08\x8DWa\x08\x89a\x08xa\x08s6`\x04a\x08\x1DV[a'\x99V[a\x08\x80a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x08\xD8W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x08\xD3W` \x01\x92`\x01\x83\x02\x84\x01\x11a\x08\xCEWV[a\x08\x9AV[a\x08\x96V[a\x08\x92V[\x90` \x82\x82\x03\x12a\t\x0EW_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\t\tWa\t\x05\x92\x01a\x08\x9EV[\x90\x91V[a\x05 V[a\x05\x1CV[_\x01\x90V[4a\tGWa\t1a\t+6`\x04a\x08\xDDV[\x90a*\x8AV[a\t9a\x05\x12V[\x80a\tC\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\t|Wa\t\\6`\x04a\x05\xCDV[a\txa\tga*\x96V[a\toa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\t\xAFWa\t\x916`\x04a\x05\xCDV[a\t\x99a,bV[a\t\xA1a\x05\x12V[\x80a\t\xAB\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[\x1C\x90V[`\xFF\x16\x90V[a\t\xCE\x90`\x08a\t\xD3\x93\x02a\t\xB4V[a\t\xB8V[\x90V[\x90a\t\xE1\x91Ta\t\xBEV[\x90V[a\t\xF0`@_\x90a\t\xD6V[\x90V[4a\n#Wa\n\x036`\x04a\x05\xCDV[a\n\x1Fa\n\x0Ea\t\xE4V[a\n\x16a\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[\x90\x91``\x82\x84\x03\x12a\n]Wa\nZa\nC\x84_\x85\x01a\x07\x85V[\x93a\nQ\x81` \x86\x01a\x07\x85V[\x93`@\x01a\x07\xABV[\x90V[a\x05\x1CV[4a\n\x93Wa\n\x8Fa\n~a\nx6`\x04a\n(V[\x91a,lV[a\n\x86a\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[\x91` a\n\xB9\x92\x94\x93a\n\xB2`@\x82\x01\x96_\x83\x01\x90a\x08;V[\x01\x90a\x08;V[V[4a\n\xECWa\n\xD3a\n\xCE6`\x04a\x08\x1DV[a-\x9DV[\x90a\n\xE8a\n\xDFa\x05\x12V[\x92\x83\x92\x83a\n\x98V[\x03\x90\xF3[a\x05\x18V[\x90V[a\x0B\x08a\x0B\x03a\x0B\r\x92a\n\xF1V[a\x06\x87V[a\x07\x94V[\x90V[a\x0B\x1Ba\x0E\x10a\n\xF4V[\x90V[a\x0B&a\x0B\x10V[\x90V[4a\x0BYWa\x0B96`\x04a\x05\xCDV[a\x0BUa\x0BDa\x0B\x1EV[a\x0BLa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x0B\xA5W[` \x83\x10\x14a\x0B\xA0WV[a\x0BqV[\x91`\x7F\x16\x91a\x0B\x95V[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x0B\xDBa\x0B\xD4\x83a\x0B\x85V[\x80\x94a\x0B\xAFV[\x91`\x01\x81\x16\x90\x81_\x14a\x0C2WP`\x01\x14a\x0B\xF6W[PPPV[a\x0C\x03\x91\x92\x93\x94Pa\x0B\xB8V[\x91_\x92[\x81\x84\x10a\x0C\x1AWPP\x01\x90_\x80\x80a\x0B\xF1V[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x0C\x07V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x0B\xF1V[\x90a\x0CW\x91a\x0B\xC1V[\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x0Cx\x90a\x05\xF4V[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x0C\x92W`@RV[a\x0CZV[\x90a\x0C\xB7a\x0C\xB0\x92a\x0C\xA7a\x05\x12V[\x93\x84\x80\x92a\x0CMV[\x03\x83a\x0CnV[V[\x90_\x10a\x0C\xCCWa\x0C\xC9\x90a\x0C\x97V[\x90V[a\x0B^V[a\x0C\xDD`E_\x90a\x0C\xB9V[\x90V[a\x0C\xF5\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x06\xD8V[\x90V[4a\r(Wa\r\x086`\x04a\x05\xCDV[a\r$a\r\x13a\x0C\xD1V[a\r\x1Ba\x05\x12V[\x91\x82\x91\x82a\x0C\xE0V[\x03\x90\xF3[a\x05\x18V[\x90V[a\r9\x81a\r-V[\x03a\r@WV[_\x80\xFD[\x90P5\x90a\rQ\x82a\r0V[V[\x90` \x82\x82\x03\x12a\rlWa\ri\x91_\x01a\rDV[\x90V[a\x05\x1CV[a\rz\x90a\r-V[\x90RV[\x91\x90a\r\x91\x90_` \x85\x01\x94\x01\x90a\rqV[V[4a\r\xC3Wa\r\xBFa\r\xAEa\r\xA96`\x04a\rSV[a/\xBEV[a\r\xB6a\x05\x12V[\x91\x82\x91\x82a\r~V[\x03\x90\xF3[a\x05\x18V[4a\r\xF6Wa\r\xD86`\x04a\x05\xCDV[a\r\xE0a4\xBCV[a\r\xE8a\x05\x12V[\x80a\r\xF2\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[\x91\x90`@\x83\x82\x03\x12a\x0E#W\x80a\x0E\x17a\x0E \x92_\x86\x01a\rDV[\x93` \x01a\x07\x85V[\x90V[a\x05\x1CV[4a\x0EWWa\x0EAa\x0E;6`\x04a\r\xFBV[\x90a4\xF0V[a\x0EIa\x05\x12V[\x80a\x0ES\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[`\xFF\x16\x90V[a\x0Ek\x90a\x0E\\V[\x90RV[\x91\x90a\x0E\x82\x90_` \x85\x01\x94\x01\x90a\x0EbV[V[4a\x0E\xB4Wa\x0E\x946`\x04a\x05\xCDV[a\x0E\xB0a\x0E\x9Fa5\x1FV[a\x0E\xA7a\x05\x12V[\x91\x82\x91\x82a\x0EoV[\x03\x90\xF3[a\x05\x18V[\x90` \x82\x82\x03\x12a\x0E\xD2Wa\x0E\xCF\x91_\x01a\x07\xABV[\x90V[a\x05\x1CV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[P`0\x90V[\x90V[a\x0E\xFD\x81a\x0E\xEBV[\x82\x10\x15a\x0F\x17Wa\x0F\x0F`\x01\x91a\x0E\xF1V[\x91\x02\x01\x90_\x90V[a\x0E\xD7V[\x90V[a\x0F/\x90`\x08a\x0F4\x93\x02a\t\xB4V[a\x0F\x1CV[\x90V[\x90a\x0FB\x91Ta\x0F\x1FV[\x90V[`\x10a\x0FP\x81a\x0E\xEBV[\x82\x10\x15a\x0FmWa\x0Fj\x91a\x0Fd\x91a\x0E\xF4V[\x90a\x0F7V[\x90V[_\x80\xFD[4a\x0F\xA1Wa\x0F\x9Da\x0F\x8Ca\x0F\x876`\x04a\x0E\xB9V[a\x0FEV[a\x0F\x94a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x0F\xD4Wa\x0F\xB66`\x04a\x05\xCDV[a\x0F\xBEa5\xD0V[a\x0F\xC6a\x05\x12V[\x80a\x0F\xD0\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\x10\tWa\x0F\xE96`\x04a\x05\xCDV[a\x10\x05a\x0F\xF4a5\xDAV[a\x0F\xFCa\x05\x12V[\x91\x82\x91\x82a\r~V[\x03\x90\xF3[a\x05\x18V[4a\x10=Wa\x10'a\x10!6`\x04a\r\xFBV[\x90a5\xEEV[a\x10/a\x05\x12V[\x80a\x109\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\x10sWa\x10oa\x10^a\x10X6`\x04a\x07\xBAV[\x90a6kV[a\x10fa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x10\xA6Wa\x10\x886`\x04a\x05\xCDV[a\x10\x90a6\xC9V[a\x10\x98a\x05\x12V[\x80a\x10\xA2\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\x10\xDAWa\x10\xC4a\x10\xBE6`\x04a\x07\xBAV[\x90a8&V[a\x10\xCCa\x05\x12V[\x80a\x10\xD6\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[a\x10\xE8\x90a\x06\xA6V[\x90V[\x90a\x10\xF5\x90a\x10\xDFV[_R` R`@_ \x90V[_\x1C\x90V[a\x11\x12a\x11\x17\x91a\x11\x01V[a\x0F\x1CV[\x90V[a\x11$\x90Ta\x11\x06V[\x90V[a\x112\x90`\ra\x10\xEBV[a\x11=_\x82\x01a\x11\x1AV[\x91a\x11J`\x01\x83\x01a\x11\x1AV[\x91a\x11W`\x02\x82\x01a\x11\x1AV[\x91a\x11p`\x04a\x11i`\x03\x85\x01a\x11\x1AV[\x93\x01a\x11\x1AV[\x90V[\x90\x95\x94\x92a\x11\xBE\x94a\x11\xADa\x11\xB7\x92a\x11\xA3`\x80\x96a\x11\x99`\xA0\x88\x01\x9C_\x89\x01\x90a\x08;V[` \x87\x01\x90a\x08;V[`@\x85\x01\x90a\x08;V[``\x83\x01\x90a\x08;V[\x01\x90a\x08;V[V[4a\x11\xF4Wa\x11\xF0a\x11\xDBa\x11\xD66`\x04a\x08\x1DV[a\x11'V[\x91a\x11\xE7\x95\x93\x95a\x05\x12V[\x95\x86\x95\x86a\x11sV[\x03\x90\xF3[a\x05\x18V[a\x12\x05`A_\x90a\x0F7V[\x90V[4a\x128Wa\x12\x186`\x04a\x05\xCDV[a\x124a\x12#a\x11\xF9V[a\x12+a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x12mWa\x12M6`\x04a\x05\xCDV[a\x12ia\x12Xa82V[a\x12`a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x12\xA2Wa\x12\x826`\x04a\x05\xCDV[a\x12\x9Ea\x12\x8Da8\xF3V[a\x12\x95a\x05\x12V[\x91\x82\x91\x82a\x06/V[\x03\x90\xF3[a\x05\x18V[a\x12\xB0\x90a\x07eV[\x90RV[\x91\x90a\x12\xC7\x90_` \x85\x01\x94\x01\x90a\x12\xA7V[V[4a\x12\xF9Wa\x12\xF5a\x12\xE4a\x12\xDF6`\x04a\x08\x1DV[a9\x8FV[a\x12\xECa\x05\x12V[\x91\x82\x91\x82a\x12\xB4V[\x03\x90\xF3[a\x05\x18V[4a\x13.Wa\x13\x0E6`\x04a\x05\xCDV[a\x13*a\x13\x19a9\xAEV[a\x13!a\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[4a\x13aWa\x13Ka\x13F6`\x04a\x08\x1DV[a9\xD7V[a\x13Sa\x05\x12V[\x80a\x13]\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\x13\x96Wa\x13v6`\x04a\x05\xCDV[a\x13\x92a\x13\x81a9\xEAV[a\x13\x89a\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[\x90V[a\x13\xB2a\x13\xADa\x13\xB7\x92a\x13\x9BV[a\x06\x87V[a\x07\x94V[\x90V[a\x13\xC4`0a\x13\x9EV[\x90V[a\x13\xCFa\x13\xBAV[\x90V[4a\x14\x02Wa\x13\xE26`\x04a\x05\xCDV[a\x13\xFEa\x13\xEDa\x13\xC7V[a\x13\xF5a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x147Wa\x143a\x14\"a\x14\x1D6`\x04a\x08\x1DV[a:\0V[a\x14*a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x14jWa\x14L6`\x04a\x05\xCDV[a\x14Ta:\xB7V[a\x14\\a\x05\x12V[\x80a\x14f\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[\x90V[a\x14\x86a\x14\x81a\x14\x8B\x92a\x14oV[a\x06\x87V[a\x07\x94V[\x90V[a\x14\xA2j\x08E\x95\x16\x14\x01HJ\0\0\0a\x14rV[\x90V[a\x14\xADa\x14\x8EV[\x90V[4a\x14\xE0Wa\x14\xC06`\x04a\x05\xCDV[a\x14\xDCa\x14\xCBa\x14\xA5V[a\x14\xD3a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x90a\x14\xEF\x90a\x10\xDFV[_R` R`@_ \x90V[a\x15\x11\x90a\x15\x0C`\x0E\x91_\x92a\x14\xE5V[a\t\xD6V[\x90V[4a\x15DWa\x15@a\x15/a\x15*6`\x04a\x08\x1DV[a\x14\xFBV[a\x157a\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[c\xFF\xFF\xFF\xFF\x16\x90V[a\x15[\x90a\x15IV[\x90RV[\x91\x90a\x15r\x90_` \x85\x01\x94\x01\x90a\x15RV[V[4a\x15\xA4Wa\x15\xA0a\x15\x8Fa\x15\x8A6`\x04a\x08\x1DV[a:\xC5V[a\x15\x97a\x05\x12V[\x91\x82\x91\x82a\x15_V[\x03\x90\xF3[a\x05\x18V[4a\x15\xD9Wa\x15\xD5a\x15\xC4a\x15\xBF6`\x04a\x08\x1DV[a:\xF0V[a\x15\xCCa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x16\x0EWa\x16\na\x15\xF9a\x15\xF46`\x04a\x08\x1DV[a;\x0EV[a\x16\x01a\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[a\x16\x1F`B_\x90a\x0F7V[\x90V[4a\x16RWa\x1626`\x04a\x05\xCDV[a\x16Na\x16=a\x16\x13V[a\x16Ea\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x90\x95\x94\x92a\x16\xA2\x94a\x16\x91a\x16\x9B\x92a\x16\x87`\x80\x96a\x16}`\xA0\x88\x01\x9C_\x89\x01\x90a\x05vV[` \x87\x01\x90a\x08;V[`@\x85\x01\x90a\x08;V[``\x83\x01\x90a\x08;V[\x01\x90a\x08;V[V[4a\x16\xD8Wa\x16\xD4a\x16\xBFa\x16\xBA6`\x04a\x08\x1DV[a;-V[\x91a\x16\xCB\x95\x93\x95a\x05\x12V[\x95\x86\x95\x86a\x16WV[\x03\x90\xF3[a\x05\x18V[4a\x17\rWa\x17\ta\x16\xF8a\x16\xF36`\x04a\x08\x1DV[a<\x9DV[a\x17\0a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x17@Wa\x17\"6`\x04a\x05\xCDV[a\x17*a<\xD6V[a\x172a\x05\x12V[\x80a\x17<\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[`\xFF`\xF8\x1B\x16\x90V[a\x17W\x90a\x17EV[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[` \x01\x90V[a\x17w\x90a\x07\x94V[\x90RV[\x90a\x17\x88\x81` \x93a\x17nV[\x01\x90V[` \x01\x90V[\x90a\x17\xAFa\x17\xA9a\x17\xA2\x84a\x17[V[\x80\x93a\x17_V[\x92a\x17hV[\x90_[\x81\x81\x10a\x17\xBFWPPP\x90V[\x90\x91\x92a\x17\xD8a\x17\xD2`\x01\x92\x86Qa\x17{V[\x94a\x17\x8CV[\x91\x01\x91\x90\x91a\x17\xB2V[\x93\x95\x91\x94a\x183a\x18(a\x18G\x95a\x18\x1Aa\x18=\x95a\x18T\x9C\x9Aa\x18\r`\xE0\x8C\x01\x92_\x8D\x01\x90a\x17NV[\x8A\x82\x03` \x8C\x01Ra\x05\xFEV[\x90\x88\x82\x03`@\x8A\x01Ra\x05\xFEV[\x97``\x87\x01\x90a\x08;V[`\x80\x85\x01\x90a\x12\xA7V[`\xA0\x83\x01\x90a\rqV[`\xC0\x81\x84\x03\x91\x01Ra\x17\x92V[\x90V[4a\x18\x8EWa\x18g6`\x04a\x05\xCDV[a\x18\x8Aa\x18ra=]V[\x93a\x18\x81\x97\x95\x97\x93\x91\x93a\x05\x12V[\x97\x88\x97\x88a\x17\xE2V[\x03\x90\xF3[a\x05\x18V[4a\x18\xC3Wa\x18\xBFa\x18\xAEa\x18\xA96`\x04a\x0E\xB9V[a=\xE7V[a\x18\xB6a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x90V[a\x18\xDFa\x18\xDAa\x18\xE4\x92a\x18\xC8V[a\x06\x87V[a\x07\x94V[\x90V[a\x18\xFBjR\xB7\xD2\xDC\xC8\x0C\xD2\xE4\0\0\0a\x18\xCBV[\x90V[a\x19\x06a\x18\xE7V[\x90V[4a\x199Wa\x19\x196`\x04a\x05\xCDV[a\x195a\x19$a\x18\xFEV[a\x19,a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x19oWa\x19ka\x19Za\x19T6`\x04a\r\xFBV[\x90a>\x18V[a\x19ba\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x19\x88\x90a\x19tV[\x90RV[\x91\x90a\x19\x9F\x90_` \x85\x01\x94\x01\x90a\x19\x7FV[V[4a\x19\xD1Wa\x19\xB16`\x04a\x05\xCDV[a\x19\xCDa\x19\xBCa>FV[a\x19\xC4a\x05\x12V[\x91\x82\x91\x82a\x19\x8CV[\x03\x90\xF3[a\x05\x18V[4a\x1A\x06Wa\x19\xE66`\x04a\x05\xCDV[a\x1A\x02a\x19\xF1a>ZV[a\x19\xF9a\x05\x12V[\x91\x82\x91\x82a\x06/V[\x03\x90\xF3[a\x05\x18V[\x90V[a\x1A\"a\x1A\x1Da\x1A'\x92a\x1A\x0BV[a\x06\x87V[a\x07\x94V[\x90V[a\x1A6b\x01Q\x80a\x1A\x0EV[\x90V[a\x1AAa\x1A*V[\x90V[4a\x1AtWa\x1AT6`\x04a\x05\xCDV[a\x1Apa\x1A_a\x1A9V[a\x1Aga\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x1A\xA9Wa\x1A\xA5a\x1A\x94a\x1A\x8F6`\x04a\x08\x1DV[a>pV[a\x1A\x9Ca\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x1A\xDEWa\x1A\xDAa\x1A\xC9a\x1A\xC46`\x04a\x08\x1DV[a>\xCBV[a\x1A\xD1a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x90V[a\x1A\xFAa\x1A\xF5a\x1A\xFF\x92a\x1A\xE3V[a\x06\x87V[a\x07\x94V[\x90V[a\x1B\x16jJr=\xC6\xB4\x0B\x8A\x9A\0\0\0a\x1A\xE6V[\x90V[a\x1B!a\x1B\x02V[\x90V[4a\x1BTWa\x1B46`\x04a\x05\xCDV[a\x1BPa\x1B?a\x1B\x19V[a\x1BGa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x1B\x88Wa\x1Bra\x1Bl6`\x04a\x07\xBAV[\x90a@MV[a\x1Bza\x05\x12V[\x80a\x1B\x84\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[\x90\x91``\x82\x84\x03\x12a\x1B\xC2Wa\x1B\xBFa\x1B\xA8\x84_\x85\x01a\x07\x85V[\x93a\x1B\xB6\x81` \x86\x01a\x07\xABV[\x93`@\x01a\x07\xABV[\x90V[a\x05\x1CV[4a\x1B\xF6Wa\x1B\xE0a\x1B\xDA6`\x04a\x1B\x8DV[\x91aB\xD3V[a\x1B\xE8a\x05\x12V[\x80a\x1B\xF2\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[\x90V[_\x1B\x90V[a\x1C\x17a\x1C\x12a\x1C\x1C\x92a\x1B\xFBV[a\x1B\xFEV[a\r-V[\x90V[a\x1C(_a\x1C\x03V[\x90V[a\x1C3a\x1C\x1FV[\x90V[4a\x1CfWa\x1CF6`\x04a\x05\xCDV[a\x1Cba\x1CQa\x1C+V[a\x1CYa\x05\x12V[\x91\x82\x91\x82a\r~V[\x03\x90\xF3[a\x05\x18V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x1C\x86\x90`\x08a\x1C\x8B\x93\x02a\t\xB4V[a\x1CkV[\x90V[\x90a\x1C\x99\x91Ta\x1CvV[\x90V[a\x1C\xA8`D_\x90a\x1C\x8EV[\x90V[\x91\x90a\x1C\xBE\x90_` \x85\x01\x94\x01\x90a\x06\xBEV[V[4a\x1C\xF0Wa\x1C\xD06`\x04a\x05\xCDV[a\x1C\xECa\x1C\xDBa\x1C\x9CV[a\x1C\xE3a\x05\x12V[\x91\x82\x91\x82a\x1C\xABV[\x03\x90\xF3[a\x05\x18V[4a\x1D%Wa\x1D\x056`\x04a\x05\xCDV[a\x1D!a\x1D\x10aB\xE0V[a\x1D\x18a\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[a\x1D3\x90a\x07eV[\x90V[a\x1D?\x81a\x1D*V[\x03a\x1DFWV[_\x80\xFD[\x90P5\x90a\x1DW\x82a\x1D6V[V[\x90` \x82\x82\x03\x12a\x1DrWa\x1Do\x91_\x01a\x1DJV[\x90V[a\x05\x1CV[4a\x1D\xA5Wa\x1D\x8Fa\x1D\x8A6`\x04a\x1DYV[aD7V[a\x1D\x97a\x05\x12V[\x80a\x1D\xA1\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\x1D\xDAWa\x1D\xBA6`\x04a\x05\xCDV[a\x1D\xD6a\x1D\xC5aDaV[a\x1D\xCDa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x90V[a\x1D\xF6a\x1D\xF1a\x1D\xFB\x92a\x1D\xDFV[a\x06\x87V[a\x07\x94V[\x90V[a\x1E\nb'\x8D\0a\x1D\xE2V[\x90V[a\x1E\x15a\x1D\xFEV[\x90V[4a\x1EHWa\x1E(6`\x04a\x05\xCDV[a\x1EDa\x1E3a\x1E\rV[a\x1E;a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x1E~Wa\x1Eza\x1Eia\x1Ec6`\x04a\x07\xBAV[\x90aD\xDBV[a\x1Eqa\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[\x90V[a\x1E\x9Aa\x1E\x95a\x1E\x9F\x92a\x1E\x83V[a\x06\x87V[a\x07\x94V[\x90V[a\x1E\xB3g\r\xE0\xB6\xB3\xA7d\0\0a\x1E\x86V[\x90V[a\x1E\xBEa\x1E\xA2V[\x90V[4a\x1E\xF1Wa\x1E\xD16`\x04a\x05\xCDV[a\x1E\xEDa\x1E\xDCa\x1E\xB6V[a\x1E\xE4a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[P`0\x90V[\x90P\x90V[\x90V[` \x01\x90V[a\x1F&a\x1F a\x1F\x19\x83a\x1E\xF6V[\x80\x94a\x1E\xFCV[\x91a\x1F\x01V[_\x91[\x83\x83\x10a\x1F6WPPPPV[a\x1FLa\x1FF`\x01\x92\x84Qa\x17{V[\x92a\x1F\x04V[\x92\x01\x91\x90a\x1F)V[\x91\x90a\x1Fi\x90_a\x06\0\x85\x01\x94\x01\x90a\x1F\nV[V[4a\x1F\x9BWa\x1F{6`\x04a\x05\xCDV[a\x1F\x97a\x1F\x86aF\x02V[a\x1F\x8Ea\x05\x12V[\x91\x82\x91\x82a\x1FUV[\x03\x90\xF3[a\x05\x18V[4a\x1F\xD1Wa\x1F\xCDa\x1F\xBCa\x1F\xB66`\x04a\x07\xBAV[\x90aF\x18V[a\x1F\xC4a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[a \x0Ba \x12\x94a \x01``\x94\x98\x97\x95a\x1F\xF7`\x80\x86\x01\x9A_\x87\x01\x90a\x08;V[` \x85\x01\x90a\x08;V[`@\x83\x01\x90a\x08;V[\x01\x90a\x05vV[V[4a HWa $6`\x04a\x05\xCDV[a Da /aF.V[\x90a ;\x94\x92\x94a\x05\x12V[\x94\x85\x94\x85a\x1F\xD6V[\x03\x90\xF3[a\x05\x18V[4a }Wa ya ha c6`\x04a\x08\x1DV[aH\x05V[a pa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a \xB2Wa \x926`\x04a\x05\xCDV[a \xAEa \x9DaH\x1AV[a \xA5a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a \xE7Wa \xE3a \xD2a \xCD6`\x04a\x08\x1DV[aH.V[a \xDAa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[a \xF5\x81a\x0E\\V[\x03a \xFCWV[_\x80\xFD[\x90P5\x90a!\r\x82a \xECV[V[\x90\x91`\xC0\x82\x84\x03\x12a!nWa!'\x83_\x84\x01a\x07\x85V[\x92a!5\x81` \x85\x01a\x07\xABV[\x92a!C\x82`@\x83\x01a\x07\xABV[\x92a!ka!T\x84``\x85\x01a!\0V[\x93a!b\x81`\x80\x86\x01a\rDV[\x93`\xA0\x01a\rDV[\x90V[a\x05\x1CV[4a!\xA8Wa!\x92a!\x866`\x04a!\x0FV[\x94\x93\x90\x93\x92\x91\x92aH\xB8V[a!\x9Aa\x05\x12V[\x80a!\xA4\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[`\xE0\x81\x83\x03\x12a\"\x18Wa!\xC3\x82_\x83\x01a\x07\x85V[\x92a!\xD1\x83` \x84\x01a\x07\x85V[\x92a!\xDF\x81`@\x85\x01a\x07\xABV[\x92a!\xED\x82``\x83\x01a\x07\xABV[\x92a\"\x15a!\xFE\x84`\x80\x85\x01a!\0V[\x93a\"\x0C\x81`\xA0\x86\x01a\rDV[\x93`\xC0\x01a\rDV[\x90V[a\x05\x1CV[4a\"RWa\"<a\"06`\x04a!\xADV[\x95\x94\x90\x94\x93\x91\x93aJ\x0CV[a\"Da\x05\x12V[\x80a\"N\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\"\x86Wa\"pa\"j6`\x04a\r\xFBV[\x90aK*V[a\"xa\x05\x12V[\x80a\"\x82\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[\x91\x90`@\x83\x82\x03\x12a\"\xB3W\x80a\"\xA7a\"\xB0\x92_\x86\x01a\x07\x85V[\x93` \x01a\x07\x85V[\x90V[a\x05\x1CV[4a\"\xE9Wa\"\xE5a\"\xD4a\"\xCE6`\x04a\"\x8BV[\x90aKLV[a\"\xDCa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x7Fk\x97%\xF7@\xF9K\x91\xB7\x80`\xA1\xB1}\x17tem8\x14!\xA5)\xEC\x98\xCD\xB0\x13\xF4\xD9\xC2^\x90V[a#\x1Aa\"\xEEV[\x90V[4a#MWa#-6`\x04a\x05\xCDV[a#Ia#8a#\x12V[a#@a\x05\x12V[\x91\x82\x91\x82a\r~V[\x03\x90\xF3[a\x05\x18V[\x7Fe\xD7\xA2\x8E2e\xB3zdt\x92\x9F3e!\xB32\xC1h\x1B\x93?l\xB9\xF37fsD\r\x86*\x90V[a#~a#RV[\x90V[4a#\xB1Wa#\x916`\x04a\x05\xCDV[a#\xADa#\x9Ca#vV[a#\xA4a\x05\x12V[\x91\x82\x91\x82a\r~V[\x03\x90\xF3[a\x05\x18V[a#\xBF\x81a\x15IV[\x03a#\xC6WV[_\x80\xFD[\x90P5\x90a#\xD7\x82a#\xB6V[V[\x91\x90`@\x83\x82\x03\x12a$\x01W\x80a#\xF5a#\xFE\x92_\x86\x01a\x07\x85V[\x93` \x01a#\xCAV[\x90V[a\x05\x1CV[a$\x0F\x90a\x19tV[\x90RV[`\x01\x80`\xD0\x1B\x03\x16\x90V[a$'\x90a$\x13V[\x90RV[\x90` \x80a$M\x93a$C_\x82\x01Q_\x86\x01\x90a$\x06V[\x01Q\x91\x01\x90a$\x1EV[V[\x91\x90a$b\x90_`@\x85\x01\x94\x01\x90a$+V[V[4a$\x95Wa$\x91a$\x80a$z6`\x04a#\xD9V[\x90aK\xBAV[a$\x88a\x05\x12V[\x91\x82\x91\x82a$OV[\x03\x90\xF3[a\x05\x18V[a$\xA6`C_\x90a\x0F7V[\x90V[4a$\xD9Wa$\xB96`\x04a\x05\xCDV[a$\xD5a$\xC4a$\x9AV[a$\xCCa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x7F\xCC\xE2\x96\xB0@3*\x08\x0Em\xF15\x15\xA3\xEC(i\xE2\x1C\xD2\x0FsD\xAF\t\x87\xDD\xB98\xD8\xBD!\x90V[a%\na$\xDEV[\x90V[4a%=Wa%\x1D6`\x04a\x05\xCDV[a%9a%(a%\x02V[a%0a\x05\x12V[\x91\x82\x91\x82a\r~V[\x03\x90\xF3[a\x05\x18V[_\x80\xFD[_\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a%ja%p\x91a$\x13V[\x91a$\x13V[\x01\x90`\x01\x80`\xD0\x1B\x03\x82\x11a%\x81WV[a%JV[\x90a%\x99\x91a%\x93a%FV[Pa%^V[\x90V[a%\xA8a%\xAE\x91a$\x13V[\x91a$\x13V[\x90\x03\x90`\x01\x80`\xD0\x1B\x03\x82\x11a%\xC0WV[a%JV[\x90a%\xD8\x91a%\xD2a%FV[Pa%\x9CV[\x90V[_\x90V[a%\xE7a%\xDBV[P\x80a&\x02a%\xFCcye\xDB\x0B`\xE0\x1Ba\x05$V[\x91a\x05$V[\x14\x90\x81\x15a&\x0FW[P\x90V[a&\x19\x91PaK\xD0V[_a&\x0BV[``\x90V[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a&Pa&I\x83a\x0B\x85V[\x80\x94a&$V[\x91`\x01\x81\x16\x90\x81_\x14a&\xA7WP`\x01\x14a&kW[PPPV[a&x\x91\x92\x93\x94Pa&-V[\x91_\x92[\x81\x84\x10a&\x8FWPP\x01\x90_\x80\x80a&fV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a&|V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a&fV[\x90a&\xCC\x91a&6V[\x90V[\x90a&\xEFa&\xE8\x92a&\xDFa\x05\x12V[\x93\x84\x80\x92a&\xC2V[\x03\x83a\x0CnV[V[a&\xFA\x90a&\xCFV[\x90V[a'\x05a&\x1FV[Pa'\x10`\x03a&\xF1V[\x90V[_\x90V[``\x90V[a'(a'-\x91a\x11\x01V[a\x1CkV[\x90V[a':\x90Ta'\x1CV[\x90V[a'F\x90a\x0C\x97V[\x90V[a'Qa'\x13V[Pa'Za'\x17V[Pa'e`Da'0V[\x90a'p`Ea'=V[\x90V[a'\x90\x91a'\x7Fa%\xDBV[Pa'\x88aK\xF6V[\x91\x90\x91aL\x03V[`\x01\x90V[_\x90V[_a'\xB1a'\xB7\x92a'\xA9a'\x95V[P`\ra\x10\xEBV[\x01a\x11\x1AV[\x90V[\x90a'\xD4\x91a'\xCFa'\xCAa$\xDEV[aL\x13V[a*4V[V[P\x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a(\x03\x91\x02\x91a'\xFD_\x19\x84a'\xE4V[\x92a'\xE4V[\x91\x81\x19\x16\x91\x16\x17\x90V[a(!a(\x1Ca(&\x92a\x07\x94V[a\x06\x87V[a\x07\x94V[\x90V[\x90V[\x91\x90a(Ba(=a(J\x93a(\rV[a()V[\x90\x83Ta'\xE8V[\x90UV[a(`\x91a(Za'\x95V[\x91a(,V[V[[\x81\x81\x10a(nWPPV[\x80a({_`\x01\x93a(NV[\x01a(cV[\x91\x90`\x1F\x81\x11a(\x91W[PPPV[a(\x9Da(\xC2\x93a\x0B\xB8V[\x90` a(\xA9\x84a'\xDAV[\x83\x01\x93\x10a(\xCAW[a(\xBB\x90a'\xDAV[\x01\x90a(bV[_\x80\x80a(\x8CV[\x91Pa(\xBB\x81\x92\x90Pa(\xB2V[\x90a(\xE8\x90_\x19\x90`\x08\x02a\t\xB4V[\x19\x16\x90V[\x81a(\xF7\x91a(\xD8V[\x90`\x02\x02\x17\x90V[\x91a)\n\x90\x82a'\xD6V[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a)\xC9Wa).\x82a)(\x85Ta\x0B\x85V[\x85a(\x81V[_\x90`\x1F\x83\x11`\x01\x14a)aW\x91\x80\x91a)P\x93_\x92a)UW[PPa(\xEDV[\x90U[V[\x90\x91P\x015_\x80a)IV[`\x1F\x19\x83\x16\x91a)p\x85a\x0B\xB8V[\x92_[\x81\x81\x10a)\xB1WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a)\x97W[PPP\x02\x01\x90Ua)SV[a)\xA7\x91\x015`\x1F\x84\x16\x90a(\xD8V[\x90U_\x80\x80a)\x8BV[\x91\x93` `\x01\x81\x92\x87\x87\x015\x81U\x01\x95\x01\x92\x01a)sV[a\x0CZV[\x90a)\xD9\x92\x91a(\xFFV[V[\x90\x82_\x93\x92\x827\x01RV[\x91\x90a*\0\x81a)\xF9\x81a*\x05\x95a\x06\xCFV[\x80\x95a)\xDBV[a\x05\xF4V[\x01\x90V[\x91a*#a*1\x94\x92`@\x85\x01\x90\x85\x82\x03_\x87\x01Ra\x06\xD8V[\x92` \x81\x85\x03\x91\x01Ra)\xE6V[\x90V[\x90a*?`Ea'=V[a*L\x83\x83\x90`Ea)\xCEV[\x91\x90\x91a*\x85\x7F\xB9\xA2\x08\x84&\xF0;0\xA8\x1C\x06B\x80\x94\xFB\xFA\x9E&\x92s\x9B2A\xAFk\x9A\xB1\xDAKUF\xBE\x93a*|a\x05\x12V[\x93\x84\x93\x84a*\tV[\x03\x90\xA1V[\x90a*\x94\x91a'\xBAV[V[a*\x9Ea'\x95V[Pa*\xA9`\x02a\x11\x1AV[\x90V[a*\xBCa*\xB7a\"\xEEV[aL\x13V[a*\xC4a+\x85V[V[a*\xDAa*\xD5a*\xDF\x92a\x1B\xFBV[a\x06\x87V[a\x07\x94V[\x90V[a*\xF6a*\xF1a*\xFB\x92a\x1B\xFBV[a\x06\x87V[a\x06|V[\x90V[a+\x07\x90a*\xE2V[\x90V[\x90a+\x16`\xFF\x91a\x1B\xFEV[\x91\x81\x19\x16\x91\x16\x17\x90V[a+)\x90a\x05qV[\x90V[\x90V[\x90a+Da+?a+K\x92a+ V[a+,V[\x82Ta+\nV[\x90UV[\x90a+[_\x19\x91a\x1B\xFEV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a+za+ua+\x81\x92a(\rV[a()V[\x82Ta+OV[\x90UV[a+\x8F`Aa\x11\x1AV[a+\xA1a+\x9B_a*\xC6V[\x91a\x07\x94V[\x03a,FWa+\xB8a+\xB3`Da'0V[a\x06\xB2V[a+\xD2a+\xCCa+\xC7_a*\xFEV[a\x07eV[\x91a\x07eV[\x14a,*Wa+\xE3`\x01`@a+/V[a+\xEEB`Aa+eV[Ba,%\x7F\x11\x94\xB04\xCF\xA9\xABX\x07IJ\x1D\\f}\x8B\x0En\x97\xF3\x88\x88t*\xA3\x87\x1A2 4\x11`\x91a,\x1Ca\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xA1V[_c;\nH\xBD`\xE1\x1B\x81R\x80a,B`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c8\xE9=\xBD`\xE1\x1B\x81R\x80a,^`\x04\x82\x01a\t\x13V[\x03\x90\xFD[a,ja*\xACV[V[\x91a,\x96\x92a,ya%\xDBV[Pa,\x8Ea,\x85aK\xF6V[\x82\x90\x84\x91aLgV[\x91\x90\x91aL\xF3V[`\x01\x90V[a,\xA4\x90a\x06\xA6V[\x90V[_\x80\xFD[`\xE0\x1B\x90V[\x90PQ\x90a,\xBE\x82a\x07\x97V[V[\x90` \x82\x82\x03\x12a,\xD9Wa,\xD6\x91_\x01a,\xB1V[\x90V[a\x05\x1CV[a,\xE6a\x05\x12V[=_\x82>=\x90\xFD[a,\xFDa-\x03\x91\x93\x92\x93a\x07\x94V[\x92a\x07\x94V[\x82\x03\x91\x82\x11a-\x0EWV[a%JV[\x90V[a-*a-%a-/\x92a-\x13V[a\x06\x87V[a\x07\x94V[\x90V[a-Aa-G\x91\x93\x92\x93a\x07\x94V[\x92a\x07\x94V[\x91a-S\x83\x82\x02a\x07\x94V[\x92\x81\x84\x04\x14\x90\x15\x17\x15a-bWV[a%JV[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[a-\x87a-\x8D\x91a\x07\x94V[\x91a\x07\x94V[\x90\x81\x15a-\x98W\x04\x90V[a-gV[a-\xA5a'\x95V[\x91a-\xAEa'\x95V[\x91a-\xC5_a-\xBF`\r\x84\x90a\x10\xEBV[\x01a\x11\x1AV[\x90a-\xDD`\x02a-\xD7`\r\x84\x90a\x10\xEBV[\x01a\x11\x1AV[\x91a.\x16` a-\xEC0a,\x9BV[ce\x1F\xD2h\x90a.\x0B\x86\x92a-\xFFa\x05\x12V[\x95\x86\x94\x85\x93\x84\x93a,\xABV[\x83R`\x04\x83\x01a\x12\xB4V[\x03\x91Z\xFA\x90\x81\x15a/oWa.a\x91` \x91_\x91a/BW[P\x93a.:0a,\x9BV[a.Vc\x99\x89U\xD3a.Ja\x05\x12V[\x95\x86\x94\x85\x93\x84\x93a,\xABV[\x83R`\x04\x83\x01a\x12\xB4V[\x03\x91Z\xFA\x90\x81\x15a/=W_\x91a/\x0FW[P\x91\x81a.\x88a.\x82_a*\xC6V[\x91a\x07\x94V[\x11a.\xDEW[PP\x81a.\xA3a.\x9D_a*\xC6V[\x91a\x07\x94V[\x11a.\xADW[PPV[a.\xD6\x92\x93Pa.\xC0a.\xD1\x91\x83a,\xEEV[a.\xCBa'\x10a-\x16V[\x90a-2V[a-{V[\x90_\x80a.\xA9V[a/\x07\x92\x96Pa.\xF1a/\x02\x91\x83a,\xEEV[a.\xFCa'\x10a-\x16V[\x90a-2V[a-{V[\x93_\x80a.\x8EV[a/0\x91P` =\x81\x11a/6W[a/(\x81\x83a\x0CnV[\x81\x01\x90a,\xC0V[_a.sV[P=a/\x1EV[a,\xDEV[a/b\x91P\x82=\x81\x11a/hW[a/Z\x81\x83a\x0CnV[\x81\x01\x90a,\xC0V[_a./V[P=a/PV[a,\xDEV[_\x90V[a/\x81\x90a\r-V[\x90V[\x90a/\x8E\x90a/xV[_R` R`@_ \x90V[\x90V[a/\xA9a/\xAE\x91a\x11\x01V[a/\x9AV[\x90V[a/\xBB\x90Ta/\x9DV[\x90V[`\x01a/\xD7a/\xDD\x92a/\xCFa/tV[P`\x05a/\x84V[\x01a/\xB1V[\x90V[a/\xE8aM\x90V[a/\xF0a/\xF2V[V[a/\xFAaM\xE6V[a0\x02a0\x0CV[a0\naNKV[V[a0\x1Ca0\x17a\"\xEEV[aL\x13V[a0$a1VV[V[a02a07\x91a\x11\x01V[a\t\xB8V[\x90V[a0D\x90Ta0&V[\x90V[`\x01a0S\x91\x01a\x07\x94V[\x90V[a0ea0k\x91\x93\x92\x93a\x07\x94V[\x92a\x07\x94V[\x82\x01\x80\x92\x11a0vWV[a%JV[a0\x84\x90a\x06\xA6V[\x90V[_\x91\x03\x12a0\x91WV[a\x05\x1CV[\x90_\x92\x91\x80T\x90a0\xB0a0\xA9\x83a\x0B\x85V[\x80\x94a\x06\xCFV[\x91`\x01\x81\x16\x90\x81_\x14a1\x07WP`\x01\x14a0\xCBW[PPPV[a0\xD8\x91\x92\x93\x94Pa\x0B\xB8V[\x91_\x92[\x81\x84\x10a0\xEFWPP\x01\x90_\x80\x80a0\xC6V[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a0\xDCV[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a0\xC6V[a1Fa1S\x94\x92\x93a1<``\x84\x01\x95_\x85\x01\x90a\x12\xA7V[` \x83\x01\x90a\x08;V[`@\x81\x84\x03\x91\x01Ra0\x96V[\x90V[a1ia1c`@a0:V[\x15a\x05qV[a4\xA0Wa1uaB\xE0V[a4\x84Wa1\x9Ea1\x90Ba1\x8A`Aa\x11\x1AV[\x90a,\xEEV[a1\x98a\x1D\xFEV[\x90a-{V[Ba1\xC9a1\xC3a1\xBEa1\xB0aDaV[a1\xB8a\x0B\x10V[\x90a,\xEEV[a\x07\x94V[\x91a\x07\x94V[\x10a4hWa1\xE2\x90a1\xDC`Ba\x11\x1AV[\x90a,\xEEV[\x90\x81a2\x10a2\na2\x05a1\xF5a\x13\xBAV[a1\xFF`Ba\x11\x1AV[\x90a,\xEEV[a\x07\x94V[\x91a\x07\x94V[\x11a4EW[a2\x1F_a*\xC6V[\x90a2)_a*\xC6V[\x91[\x82a2>a28\x86a\x07\x94V[\x91a\x07\x94V[\x10\x15a2\x85Wa2ya2\x7F\x91a2sa2m`\x10a2ga2``Ba\x11\x1AV[\x89\x90a0VV[\x90a\x0E\xF4V[\x90a\x0F7V[\x90a0VV[\x92a0GV[\x91a2+V[\x91P\x91a2\x9Ca2\x95`Ca\x11\x1AV[\x83\x90a0VV[a2\xB5a2\xAFa2\xAAa\x14\x8EV[a\x07\x94V[\x91a\x07\x94V[\x11a4)Wa2\xD0a2\xD7\x91a2\xCB`Ba\x11\x1AV[a0VV[`Ba+eV[a2\xF4a2\xED\x82a2\xE8`Ca\x11\x1AV[a0VV[`Ca+eV[a3\x07a3\x000a0{V[\x82\x90aN_V[a3,a3\x130a0{V[a3%a3 `Da'0V[a\x06\xB2V[\x83\x91aL\x03V[a3>a39`Da'0V[a\x06\xB2V[c\x18\xB6\x8B\x8Ca3L0a0{V[\x83\x92`E\x92\x81;\x15a4$W_a3v\x91a3\x81\x82\x96a3ja\x05\x12V[\x98\x89\x97\x88\x96\x87\x95a,\xABV[\x85R`\x04\x85\x01a1\"V[\x03\x92Z\xF1\x80\x15a4\x1FWa3\xF3W[Pa3\x9B`Ba\x11\x1AV[\x90a3\xAEa3\xA9`Da'0V[a\x06\xB2V[\x90a3\xD9\x7F4\xB7=\x0C\x96\xE9\xFFMS\x11CH\x17\xC8\xEC\xC90\xE7\xD2x,[\xDE.y\xDCD\xB0YgU\xBB\x92a\x10\xDFV[\x92a3\xEEa3\xE5a\x05\x12V[\x92\x83\x92\x83a\n\x98V[\x03\x90\xA2V[a4\x12\x90_=\x81\x11a4\x18W[a4\n\x81\x83a\x0CnV[\x81\x01\x90a0\x87V[_a3\x90V[P=a4\0V[a,\xDEV[a,\xA7V[_c#\x06N\xBD`\xE0\x1B\x81R\x80a4A`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x90Pa4ba4Ra\x13\xBAV[a4\\`Ba\x11\x1AV[\x90a,\xEEV[\x90a2\x16V[_c=S\xC7S`\xE0\x1B\x81R\x80a4\x80`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c\x11UbK`\xE2\x1B\x81R\x80a4\x9C`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c\x19\xAF\xC9\x9D`\xE2\x1B\x81R\x80a4\xB8`\x04\x82\x01a\t\x13V[\x03\x90\xFD[a4\xC4a/\xE0V[V[\x90a4\xE1\x91a4\xDCa4\xD7\x82a/\xBEV[aL\x13V[a4\xE3V[V[\x90a4\xED\x91aN\xBDV[PV[\x90a4\xFA\x91a4\xC6V[V[_\x90V[\x90V[a5\x17a5\x12a5\x1C\x92a5\0V[a\x06\x87V[a\x0E\\V[\x90V[a5'a4\xFCV[Pa52`\x12a5\x03V[\x90V[a5Ea5@a\"\xEEV[aL\x13V[a5Ma5OV[V[a5Y`Aa\x11\x1AV[a5ka5e_a*\xC6V[\x91a\x07\x94V[\x14a5\xB4Wa5|`\x01`@a+/V[\x7FJy*\x0B\xE4+Vr\xFA\xA4\x01)\xFCdi\x07$\x90w\\\xA8\xD3\xC3N\x85-MU\xD3\xA75\xA9a5\xA5a\x05\x12V[\x80a5\xAF\x81a\t\x13V[\x03\x90\xA1V[_c\x8F\x98@A`\xE0\x1B\x81R\x80a5\xCC`\x04\x82\x01a\t\x13V[\x03\x90\xFD[a5\xD8a55V[V[a5\xE2a/tV[Pa5\xEBaOiV[\x90V[\x90\x80a6\ta6\x03a5\xFEaK\xF6V[a\x07eV[\x91a\x07eV[\x03a6\x1AWa6\x17\x91aP#V[PV[_c3K\xD9\x19`\xE1\x1B\x81R\x80a62`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x90a6@\x90a\x10\xDFV[_R` R`@_ \x90V[\x90V[a6ca6^a6h\x92a$\x13V[a\x06\x87V[a\x07\x94V[\x90V[a6\xA2\x91a6\x97a6\x91a6\x8Ca6\x9D\x94a6\x84a'\x95V[P`\na66V[a6LV[\x91aQ\x04V[\x90aQ\xFAV[a6OV[\x90V[a6\xB5a6\xB0a\x1C\x1FV[aL\x13V[a6\xBDa6\xBFV[V[a6\xC7aS\x81V[V[a6\xD1a6\xA5V[V[\x90a6\xE5\x91a6\xE0aM\xE6V[a6\xEFV[a6\xEDaNKV[V[\x90\x81a7\x0Ba7\x05a7\0_a*\xFEV[a\x07eV[\x91a\x07eV[\x14a8\nW\x80a7#a7\x1D_a*\xC6V[\x91a\x07\x94V[\x14a7\xEEWa7Ea7?a7:`\x0E3\x90a\x14\xE5V[a0:V[\x15a\x05qV[a7\xD2Wa7R3aS\x8EV[a7i`\x01a7c`\r3\x90a\x10\xEBV[\x01a\x11\x1AV[a7{a7u\x83a\x07\x94V[\x91a\x07\x94V[\x10a7\xB6Wa7\xB4\x91a7\xAF\x82a7\xA9`\x01a7\x99`\r3\x90a\x10\xEBV[\x01\x91a7\xA4\x83a\x11\x1AV[a,\xEEV[\x90a+eV[aN_V[V[_c\x1C\x95\x9E\xD9`\xE2\x1B\x81R\x80a7\xCE`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_cD\x17v\t`\xE1\x1B\x81R\x80a7\xEA`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a8\x06`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a8\"`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x90a80\x91a6\xD3V[V[a8:a'\x95V[Pa8Va8Fa\x14\x8EV[a8P`Ca\x11\x1AV[\x90a,\xEEV[\x90V[\x90a8la8ea\x05\x12V[\x92\x83a\x0CnV[V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a8\x8CWa8\x88` \x91a\x05\xF4V[\x01\x90V[a\x0CZV[\x90a8\xA3a8\x9E\x83a8nV[a8YV[\x91\x82RV[_\x7Fmode=blocknumber&from=default\0\0\0\x91\x01RV[a8\xD9`\x1Da8\x91V[\x90a8\xE6` \x83\x01a8\xA8V[V[a8\xF0a8\xCFV[\x90V[a8\xFBa&\x1FV[Pa9\x04a>FV[a9\x1Da9\x17a9\x12aU]V[a\x19tV[\x91a\x19tV[\x03a9-Wa9*a8\xE8V[\x90V[_c\x01\xBF\xC1\xC5`\xE6\x1B\x81R\x80a9E`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_\x90V[\x90a9W\x90a\x10\xDFV[_R` R`@_ \x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a9za9\x7F\x91a\x11\x01V[a9cV[\x90V[a9\x8C\x90Ta9nV[\x90V[a9\xA6a9\xAB\x91a9\x9Ea9IV[P`\ta9MV[a9\x82V[\x90V[a9\xB6a%\xDBV[Pa9\xC1`Aa\x11\x1AV[a9\xD3a9\xCD_a*\xC6V[\x91a\x07\x94V[\x11\x90V[a9\xE8\x90a9\xE3aK\xF6V[aU\x95V[V[a9\xF2a%\xDBV[Pa9\xFD`\x0Fa0:V[\x90V[a:W\x90a:\x0Ca'\x95V[Pa:$`\x01a:\x1E`\r\x84\x90a\x10\xEBV[\x01a\x11\x1AV[\x90a:Q`\x04a:Ka:C_a:=`\r\x87\x90a\x10\xEBV[\x01a\x11\x1AV[\x93`\ra\x10\xEBV[\x01a\x11\x1AV[\x91aV V[\x90V[a:ja:ea#RV[aL\x13V[a:ra:tV[V[a:\x7F_`@a+/V[\x7Fs\xA5\xFC`\xAA\xFE\xEC\x8F\x13\x9A\xF2-\x98\xE6!@\xE2\xCE\x91M\x1F\x15\\i+BwW\xC3\xE4\x01La:\xA8a\x05\x12V[\x80a:\xB2\x81a\t\x13V[\x03\x90\xA1V[a:\xBFa:ZV[V[_\x90V[a:\xD7\x90a:\xD1a:\xC1V[PaV\xCDV[\x90V[\x90a:\xE4\x90a\x10\xDFV[_R` R`@_ \x90V[a;\x06a;\x0B\x91a:\xFFa'\x95V[P_a:\xDAV[a\x11\x1AV[\x90V[a;%a;*\x91a;\x1Da%\xDBV[P`\x0Ea\x14\xE5V[a0:V[\x90V[\x90a;6a%\xDBV[Pa;?a'\x95V[Pa;Ha'\x95V[Pa;Qa'\x95V[Pa;Za'\x95V[Pa;oa;j`\x0E\x84\x90a\x14\xE5V[a0:V[\x91a;\x86_a;\x80`\r\x84\x90a\x10\xEBV[\x01a\x11\x1AV[\x91a;\x9E`\x02a;\x98`\r\x85\x90a\x10\xEBV[\x01a\x11\x1AV[\x90a;\xD7` a;\xAD0a,\x9BV[ce\x1F\xD2h\x90a;\xCC\x87\x92a;\xC0a\x05\x12V[\x95\x86\x94\x85\x93\x84\x93a,\xABV[\x83R`\x04\x83\x01a\x12\xB4V[\x03\x91Z\xFA\x90\x81\x15a<\x98Wa<\"\x91` \x91_\x91a<kW[P\x94a;\xFB0a,\x9BV[a<\x17c\x99\x89U\xD3a<\x0Ba\x05\x12V[\x95\x86\x94\x85\x93\x84\x93a,\xABV[\x83R`\x04\x83\x01a\x12\xB4V[\x03\x91Z\xFA\x90\x81\x15a<fW_\x91a<8W[P\x90V[a<Y\x91P` =\x81\x11a<_W[a<Q\x81\x83a\x0CnV[\x81\x01\x90a,\xC0V[_a<4V[P=a<GV[a,\xDEV[a<\x8B\x91P\x82=\x81\x11a<\x91W[a<\x83\x81\x83a\x0CnV[\x81\x01\x90a,\xC0V[_a;\xF0V[P=a<yV[a,\xDEV[a<\xAF\x90a<\xA9a'\x95V[PaV\xFCV[\x90V[a<\xC2a<\xBDa#RV[aL\x13V[a<\xCAa<\xCCV[V[a<\xD4aWrV[V[a<\xDEa<\xB2V[V[_\x90V[``\x90V[a<\xF2\x90a\x06\xA6V[\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a=\rW` \x80\x91\x02\x01\x90V[a\x0CZV[\x90a=$a=\x1F\x83a<\xF5V[a8YV[\x91\x82RV[6\x907V[\x90a=Sa=;\x83a=\x12V[\x92` \x80a=I\x86\x93a<\xF5V[\x92\x01\x91\x03\x90a=)V[V[`\x0F`\xF8\x1B\x90V[a=ea<\xE0V[Pa=na&\x1FV[Pa=wa&\x1FV[Pa=\x80a'\x95V[Pa=\x89a9IV[Pa=\x92a/tV[Pa=\x9Ba<\xE4V[Pa=\xA4aW\x7FV[\x90a=\xADaW\xBFV[\x90F\x90a=\xB90a<\xE9V[\x90a=\xC3_a\x1C\x03V[\x90a=\xD5a=\xD0_a*\xC6V[a=.V[\x90a=\xDEa=UV[\x96\x95\x94\x93\x92\x91\x90V[a>\x10a>\x15\x91a=\xF6a'\x95V[Pa>\na>\x04`\x0Ba6LV[\x91aQ\x04V[\x90aQ\xFAV[a6OV[\x90V[a>?\x91_a>4a>:\x93a>,a%\xDBV[P`\x05a/\x84V[\x01a\x14\xE5V[a0:V[\x90V[_\x90V[a>Na>BV[Pa>WaU]V[\x90V[a>ba&\x1FV[Pa>m`\x04a&\xF1V[\x90V[a>\xC8\x90a>|a'\x95V[Pa>\x94`\x03a>\x8E`\r\x84\x90a\x10\xEBV[\x01a\x11\x1AV[\x90a>\xC2`\x04a>\xBCa>\xB4`\x02a>\xAE`\r\x87\x90a\x10\xEBV[\x01a\x11\x1AV[\x93`\ra\x10\xEBV[\x01a\x11\x1AV[\x91aV V[\x90V[a>\xF2a>\xEDa>\xE8a>\xF7\x93a>\xE0a'\x95V[P`\na66V[a6LV[aW\xFFV[a6OV[\x90V[\x90a?\x0C\x91a?\x07aM\xE6V[a?\x16V[a?\x14aNKV[V[\x90\x81a?2a?,a?'_a*\xFEV[a\x07eV[\x91a\x07eV[\x14a@1W\x80a?Ja?D_a*\xC6V[\x91a\x07\x94V[\x14a@\x15Wa?la?fa?a`\x0E3\x90a\x14\xE5V[a0:V[\x15a\x05qV[a?\xF9Wa?y3aS\x8EV[a?\x90`\x03a?\x8A`\r3\x90a\x10\xEBV[\x01a\x11\x1AV[a?\xA2a?\x9C\x83a\x07\x94V[\x91a\x07\x94V[\x10a?\xDDWa?\xDB\x91a?\xD6\x82a?\xD0`\x03a?\xC0`\r3\x90a\x10\xEBV[\x01\x91a?\xCB\x83a\x11\x1AV[a,\xEEV[\x90a+eV[aXtV[V[_c\x1C\x95\x9E\xD9`\xE2\x1B\x81R\x80a?\xF5`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_cD\x17v\t`\xE1\x1B\x81R\x80a@\x11`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a@-`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a@I`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x90a@W\x91a>\xFAV[V[\x90a@t\x92\x91a@oa@ja$\xDEV[aL\x13V[a@vV[V[\x80a@\x91a@\x8Ba@\x86_a*\xFEV[a\x07eV[\x91a\x07eV[\x14aB\xB7Wa@\xB3a@\xADa@\xA8`\x0E\x84\x90a\x14\xE5V[a0:V[\x15a\x05qV[\x80aB|W[aB W[\x81a@\xD1a@\xCB_a*\xC6V[\x91a\x07\x94V[\x14\x80aB\x06W[\x80aA\xECW[aA\x91W[a@\xEC\x81aS\x8EV[aA\x03\x82_a@\xFD`\r\x85\x90a\x10\xEBV[\x01a+eV[aA\x1B\x83`\x02aA\x15`\r\x85\x90a\x10\xEBV[\x01a+eV[aA3\x82`\x01aA-`\r\x85\x90a\x10\xEBV[\x01a+eV[aAK\x83`\x03aAE`\r\x85\x90a\x10\xEBV[\x01a+eV[\x90\x91aAw\x7F\xAA\x80}\n\xBF0\xD9\x19h\xC7G\x8Cf\xB6\xD8%!\xA1\x06\xAF\x13\xED\xA06\xE2\x03m\xA9\xAF\x16\x89X\x92a\x10\xDFV[\x92aA\x8CaA\x83a\x05\x12V[\x92\x83\x92\x83a\n\x98V[\x03\x90\xA2V[aA\xA6_aA\xA1`\x0E\x84\x90a\x14\xE5V[a+/V[\x80aA\xD1\x7F\x02\xC2\xF0\xBA\x15\xB0?\x88\xB1\x8FH2`\x9A\x18\xCF5\xFCk?EF\xA9\x99 v\xD7E=\x134\xA8\x91a\x10\xDFV[\x90aA\xDAa\x05\x12V[\x80aA\xE4\x81a\t\x13V[\x03\x90\xA2a@\xE3V[PaB\x01aA\xFC`\x0E\x83\x90a\x14\xE5V[a0:V[a@\xDEV[P\x82aB\x1AaB\x14_a*\xC6V[\x91a\x07\x94V[\x14a@\xD8V[aB6`\x01aB1`\x0E\x84\x90a\x14\xE5V[a+/V[\x80aBa\x7Fl\xF2\x849\xA2\xDA\xAB\x1B&P\x97\"r\x12\xA5\xB7\x1E\nv\xF9\xED\x85\xE3\xF8\x15\xB5\xA6\xC3\xE2\x18\xEB\x7F\x91a\x10\xDFV[\x90aBja\x05\x12V[\x80aBt\x81a\t\x13V[\x03\x90\xA2a@\xBEV[P\x81aB\x90aB\x8A_a*\xC6V[\x91a\x07\x94V[\x11\x80\x15aB\x9DW[a@\xB9V[P\x82aB\xB1aB\xAB_a*\xC6V[\x91a\x07\x94V[\x11aB\x98V[_c\xD9.#=`\xE0\x1B\x81R\x80aB\xCF`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x90aB\xDE\x92\x91a@YV[V[aB\xE8a%\xDBV[PaB\xF3`Ba\x11\x1AV[aC\x0CaC\x06aC\x01a\x13\xBAV[a\x07\x94V[\x91a\x07\x94V[\x10\x15\x90V[aC*\x90aC%aC a$\xDEV[aL\x13V[aC\x82V[V[\x90aC=`\x01\x80`\xA0\x1B\x03\x91a\x1B\xFEV[\x91\x81\x19\x16\x91\x16\x17\x90V[aCP\x90a\x06\x8AV[\x90V[aC\\\x90aCGV[\x90V[\x90V[\x90aCwaCraC~\x92aCSV[aC_V[\x82TaC,V[\x90UV[aC\x8B\x81a\x06\xB2V[aC\xA5aC\x9FaC\x9A_a*\xFEV[a\x07eV[\x91a\x07eV[\x14aD\x1BWaC\xD0aC\xCAaC\xBA`Da'0V[aC\xC5\x84`DaCbV[a\x06\xB2V[\x91a\x06\xB2V[aD\x03aC\xFD\x7F\x07\x01[j\x9F\x05\x911H\xFD_\xAD\xDF*\xCC\x97\x08\xF3\x05\x93\x7F0r\xCA+KF\xFA\xA5\xD0\x89\x8B\x93a\x10\xDFV[\x91a\x10\xDFV[\x91aD\x0Ca\x05\x12V[\x80aD\x16\x81a\t\x13V[\x03\x90\xA3V[_c\xD9.#=`\xE0\x1B\x81R\x80aD3`\x04\x82\x01a\t\x13V[\x03\x90\xFD[aD@\x90aC\x11V[V[\x90V[aDYaDTaD^\x92aDBV[a\x06\x87V[a\x07\x94V[\x90V[aDia'\x95V[PaDt`Aa\x11\x1AV[aD\x86aD\x80_a*\xC6V[\x91a\x07\x94V[\x14aD\xCFWaD\xCCaD\x98`Aa\x11\x1AV[aD\xC6aD\xB8aD\xA8`Ba\x11\x1AV[aD\xB2`\x01aDEV[\x90a0VV[aD\xC0a\x1D\xFEV[\x90a-2V[\x90a0VV[\x90V[aD\xD8_a*\xC6V[\x90V[aD\xF8\x91aD\xE7a%\xDBV[PaD\xF0aK\xF6V[\x91\x90\x91aL\xF3V[`\x01\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11aE\x12W` \x02\x90V[a\x0CZV[aE#aE(\x91aD\xFDV[a8YV[\x90V[\x90aEIaE8\x83aE\x17V[\x92aEC\x84\x91aD\xFDV[\x90a=)V[V[aEU`0aE+V[\x90V[\x90P\x90V[aEg\x90Ta\x11\x06V[\x90V[`\x01\x01\x90V[aE\x8CaE\x86aE\x7F\x83a\x0E\xEBV[\x80\x94aEXV[\x91a\x0E\xF1V[_\x91[\x83\x83\x10aE\x9CWPPPPV[aE\xB9aE\xB3`\x01\x92aE\xAE\x85aE]V[a\x17{V[\x92aEjV[\x92\x01\x91\x90aE\x8FV[\x90aE\xD0\x81a\x06\0\x93aEpV[\x01\x90V[\x90aE\xF4aE\xED\x92aE\xE4a\x05\x12V[\x93\x84\x80\x92aE\xC2V[\x03\x83a\x0CnV[V[aE\xFF\x90aE\xD4V[\x90V[aF\naEKV[PaF\x15`\x10aE\xF6V[\x90V[\x90aF+\x91aF%a'\x95V[Pa6kV[\x90V[aF6a'\x95V[PaF?a'\x95V[PaFHa'\x95V[PaFQa%\xDBV[PaF\\`Aa\x11\x1AV[aFnaFh_a*\xC6V[\x91a\x07\x94V[\x14aG\xDFWaF\x98aF\x8ABaF\x84`Aa\x11\x1AV[\x90a,\xEEV[aF\x92a\x1D\xFEV[\x90a-{V[\x90aF\xDAaF\xA6`Aa\x11\x1AV[aF\xD4aF\xC6aF\xB6`Ba\x11\x1AV[aF\xC0`\x01aDEV[\x90a0VV[aF\xCEa\x1D\xFEV[\x90a-2V[\x90a0VV[aF\xE4`Ba\x11\x1AV[aF\xFDaF\xF7aF\xF2a\x13\xBAV[a\x07\x94V[\x91a\x07\x94V[\x10_\x14aG\xD1WaG\"aG\x1C`\x10aG\x16`Ba\x11\x1AV[\x90a\x0E\xF4V[\x90a\x0F7V[[\x92aG.`@a0:V[\x90\x81aG\xADW[P\x80aG\x83W[\x80aGWW[\x91aGM`Ba\x11\x1AV[\x91\x93\x92\x91\x93\x92\x91\x90V[PBaG|aGvaGq\x84aGka\x0B\x10V[\x90a,\xEEV[a\x07\x94V[\x91a\x07\x94V[\x10\x15aGBV[PaG\x8E`Ba\x11\x1AV[aG\xA7aG\xA1aG\x9Ca\x13\xBAV[a\x07\x94V[\x91a\x07\x94V[\x10aG<V[\x90PaG\xCAaG\xC4aG\xBF`Ba\x11\x1AV[a\x07\x94V[\x91a\x07\x94V[\x11_aG5V[aG\xDA_a*\xC6V[aG#V[_\x90_\x91_\x91aH\x01aG\xFBaG\xF5_\x94a*\xC6V[\x95a*\xC6V[\x93a*\xC6V[\x91\x90V[aH\x17\x90aH\x11a'\x95V[Pa>\xCBV[\x90V[aH\"a'\x95V[PaH+a*\x96V[\x90V[`\x02aHGaHM\x92aH?a'\x95V[P`\ra\x10\xEBV[\x01a\x11\x1AV[\x90V[\x7F\xE4\x83)\x05{\xFD\x03\xD5^I\xB5G\x13.9\xCF\xFD\x9C\x18 \xAD{\x9DLS\x07i\x14%\xD1Z\xDF\x90V[aH\xA9aH\xB0\x94aH\x9F``\x94\x98\x97\x95aH\x95`\x80\x86\x01\x9A_\x87\x01\x90a\rqV[` \x85\x01\x90a\x12\xA7V[`@\x83\x01\x90a\x08;V[\x01\x90a\x08;V[V[` \x01\x90V[\x93\x95\x94\x90\x92\x91\x95BaH\xD2aH\xCC\x89a\x07\x94V[\x91a\x07\x94V[\x11aIKW\x91aI=\x91aID\x93aI4aII\x98\x99aI\x1CaH\xF3aHPV[aI\r\x8B\x93\x8BaI\x01a\x05\x12V[\x95\x86\x94` \x86\x01aHtV[` \x82\x01\x81\x03\x82R\x03\x82a\x0CnV[aI.aI(\x82a\x06\xCBV[\x91aH\xB2V[ aX\xD3V[\x92\x90\x91\x92aX\xF0V[\x91\x82aY:V[aU\x95V[V[aIf\x87_\x91\x82\x91c#A\xD7\x87`\xE1\x1B\x83R`\x04\x83\x01a\x08HV[\x03\x90\xFD[\x7Fnq\xED\xAE\x12\xB1\xB9\x7FM\x1F`7\x0F\xEF\x10\x10_\xA2\xFA\xAE\x01&\x11J\x16\x9Cd\x84]a&\xC9\x90V[\x91\x94aI\xD6aI\xE0\x92\x98\x97\x95aI\xCC`\xA0\x96aI\xC2aI\xE7\x9AaI\xB8`\xC0\x8A\x01\x9E_\x8B\x01\x90a\rqV[` \x89\x01\x90a\x12\xA7V[`@\x87\x01\x90a\x12\xA7V[``\x85\x01\x90a\x08;V[`\x80\x83\x01\x90a\x08;V[\x01\x90a\x08;V[V[\x91` aJ\n\x92\x94\x93aJ\x03`@\x82\x01\x96_\x83\x01\x90a\x12\xA7V[\x01\x90a\x12\xA7V[V[\x96\x95\x91\x93\x92\x94\x90\x94BaJ'aJ!\x83a\x07\x94V[\x91a\x07\x94V[\x11aJ\xE1W\x90aJ\x90aJ\x99\x94\x93\x92aJxaJAaIjV[aJi\x8C\x80\x94\x8C\x91aJS\x8D\x91aY}V[\x91\x92aJ]a\x05\x12V[\x97\x88\x96` \x88\x01aI\x8EV[` \x82\x01\x81\x03\x82R\x03\x82a\x0CnV[aJ\x8AaJ\x84\x82a\x06\xCBV[\x91aH\xB2V[ aX\xD3V[\x92\x90\x91\x92aX\xF0V[\x80aJ\xACaJ\xA6\x87a\x07eV[\x91a\x07eV[\x03aJ\xC1WPaJ\xBF\x92\x93\x91\x90\x91aL\x03V[V[\x84\x90aJ\xDD_\x92\x83\x92c%\xC0\x07#`\xE1\x1B\x84R`\x04\x84\x01aI\xE9V[\x03\x90\xFD[aJ\xFC\x90_\x91\x82\x91c1<\x89\x81`\xE1\x1B\x83R`\x04\x83\x01a\x08HV[\x03\x90\xFD[\x90aK\x1B\x91aK\x16aK\x11\x82a/\xBEV[aL\x13V[aK\x1DV[V[\x90aK'\x91aP#V[PV[\x90aK4\x91aK\0V[V[\x90aK@\x90a\x10\xDFV[_R` R`@_ \x90V[aKq\x91aKgaKl\x92aK_a'\x95V[P`\x01aK6V[a:\xDAV[a\x11\x1AV[\x90V[aK~`@a8YV[\x90V[_\x90V[_\x90V[aK\x91aKtV[\x90` \x80\x83aK\x9EaK\x81V[\x81R\x01aK\xA9aK\x85V[\x81RPPV[aK\xB7aK\x89V[\x90V[\x90aK\xCD\x91aK\xC7aK\xAFV[PaY\xB0V[\x90V[aK\xD8a%\xDBV[PaK\xF2aK\xECc\x01\xFF\xC9\xA7`\xE0\x1Ba\x05$V[\x91a\x05$V[\x14\x90V[aK\xFEa9IV[P3\x90V[\x91aL\x11\x92\x91`\x01\x92aY\xD8V[V[aL%\x90aL\x1FaK\xF6V[\x90a[\nV[V[`@\x90aLPaLW\x94\x96\x95\x93\x96aLF``\x84\x01\x98_\x85\x01\x90a\x12\xA7V[` \x83\x01\x90a\x08;V[\x01\x90a\x08;V[V[\x90aLd\x91\x03a\x07\x94V[\x90V[\x92\x91\x92aLu\x81\x83\x90aKLV[\x90\x81aL\x8AaL\x84_\x19a\x07\x94V[\x91a\x07\x94V[\x10aL\x97W[PPP\x90PV[\x81aL\xAAaL\xA4\x87a\x07\x94V[\x91a\x07\x94V[\x10aL\xD0WaL\xC7\x93\x94aL\xBF\x91\x93\x92aLYV[\x90_\x92aY\xD8V[\x80_\x80\x80aL\x90V[PaL\xEF\x84\x92\x91\x92_\x93\x84\x93c}\xC7\xA0\xD9`\xE1\x1B\x85R`\x04\x85\x01aL'V[\x03\x90\xFD[\x91\x82aM\x0FaM\taM\x04_a*\xFEV[a\x07eV[\x91a\x07eV[\x14aMiW\x81aM/aM)aM$_a*\xFEV[a\x07eV[\x91a\x07eV[\x14aMBWaM@\x92\x91\x90\x91a[EV[V[aMeaMN_a*\xFEV[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x12\xB4V[\x03\x90\xFD[aM\x8CaMu_a*\xFEV[_\x91\x82\x91cKc~\x8F`\xE1\x1B\x83R`\x04\x83\x01a\x12\xB4V[\x03\x90\xFD[aM\x98a9\xEAV[aM\x9EWV[_c\xD9<\x06e`\xE0\x1B\x81R\x80aM\xB6`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x90V[aM\xD1aM\xCCaM\xD6\x92aM\xBAV[a\x06\x87V[a\x07\x94V[\x90V[aM\xE3`\x02aM\xBDV[\x90V[aM\xF0`\x0Ca\x11\x1AV[aN\taN\x03aM\xFEaM\xD9V[a\x07\x94V[\x91a\x07\x94V[\x14aN\"WaN aN\x19aM\xD9V[`\x0Ca+eV[V[_c>\xE5\xAE\xB5`\xE0\x1B\x81R\x80aN:`\x04\x82\x01a\t\x13V[\x03\x90\xFD[aNH`\x01aDEV[\x90V[aN]aNVaN>V[`\x0Ca+eV[V[\x80aNzaNtaNo_a*\xFEV[a\x07eV[\x91a\x07eV[\x14aN\x96WaN\x94\x91aN\x8C_a*\xFEV[\x91\x90\x91a[EV[V[aN\xB9aN\xA2_a*\xFEV[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x12\xB4V[\x03\x90\xFD[aN\xC5a%\xDBV[PaN\xDAaN\xD4\x82\x84\x90a>\x18V[\x15a\x05qV[_\x14aOcWaO\x02`\x01aN\xFD_aN\xF5`\x05\x86\x90a/\x84V[\x01\x85\x90a\x14\xE5V[a+/V[\x90aO\x0BaK\xF6V[\x90aOHaOBaO<\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a/xV[\x92a\x10\xDFV[\x92a\x10\xDFV[\x92aOQa\x05\x12V[\x80aO[\x81a\t\x13V[\x03\x90\xA4`\x01\x90V[PP_\x90V[aOqa/tV[PaO{0a<\xE9V[aO\xADaO\xA7\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x07eV[\x91a\x07eV[\x14\x80aO\xE9W[_\x14aO\xDEW\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[aO\xE6a[\xC5V[\x90V[PFaP\x1DaP\x17\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x07\x94V[\x91a\x07\x94V[\x14aO\xB4V[aP+a%\xDBV[PaP7\x81\x83\x90a>\x18V[_\x14aP\xBFWaP^_aPY_aPQ`\x05\x86\x90a/\x84V[\x01\x85\x90a\x14\xE5V[a+/V[\x90aPgaK\xF6V[\x90aP\xA4aP\x9EaP\x98\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x95a/xV[\x92a\x10\xDFV[\x92a\x10\xDFV[\x92aP\xADa\x05\x12V[\x80aP\xB7\x81a\t\x13V[\x03\x90\xA4`\x01\x90V[PP_\x90V[aP\xD9aP\xD4aP\xDE\x92a\x19tV[a\x06\x87V[a\x07\x94V[\x90V[\x91` aQ\x02\x92\x94\x93aP\xFB`@\x82\x01\x96_\x83\x01\x90a\x08;V[\x01\x90a\x19\x7FV[V[aQ\x0Ca>BV[PaQ\x15a>FV[\x81aQ(aQ\"\x83aP\xC5V[\x91a\x07\x94V[\x10\x15aQ;WPaQ8\x90a\\\xCBV[\x90V[\x90aQV_\x92\x83\x92cvi\xFC\x0F`\xE1\x1B\x84R`\x04\x84\x01aP\xE1V[\x03\x90\xFD[T\x90V[\x90V[aQuaQpaQz\x92aQ^V[a\x06\x87V[a\x07\x94V[\x90V[\x90V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[aQ\x97aQ\x9C\x91a\x11\x01V[aQ\x80V[\x90V[aQ\xA9\x90TaQ\x8BV[\x90V[`0\x1C\x90V[`\x01\x80`\xD0\x1B\x03\x16\x90V[aQ\xC9aQ\xCE\x91aQ\xACV[aQ\xB2V[\x90V[aQ\xDB\x90TaQ\xBDV[\x90V[aQ\xF2aQ\xEDaQ\xF7\x92a\x1B\xFBV[a\x06\x87V[a$\x13V[\x90V[\x90aRN\x90aR\x07a%FV[PaR\x13_\x84\x01aQZV[aR\x1C_a*\xC6V[\x90\x80\x80aR2aR,`\x05aQaV[\x91a\x07\x94V[\x11aR\xAFW[P\x90aRI_\x86\x01\x93\x91\x92\x93aQ}V[ac\x03V[\x80aRaaR[_a*\xC6V[\x91a\x07\x94V[\x14_\x14aRwWPPaRs_aQ\xDEV[[\x90V[aR\xA4_\x91aR\x9FaR\x99\x84aR\xAA\x96\x01\x92aR\x93`\x01aDEV[\x90a,\xEEV[\x91aQ}V[ab\xF9V[\x01aQ\xD1V[aRtV[\x80aR\xBDaR\xC3\x92\x91a_\x8EV[\x90a,\xEEV[\x90\x83aR\xF5aR\xEFaR\xEA_aR\xE4\x81\x8C\x01aR\xDF\x89\x91aQ}V[ab\xF9V[\x01aQ\x9FV[a\x19tV[\x91a\x19tV[\x10_\x14aS\x06WP\x90[\x90_aR8V[\x91PaS\x1C\x90aS\x16`\x01aDEV[\x90a0VV[aR\xFFV[aS)ac\x92V[aS1aS3V[V[aS>_`\x0Fa+/V[aSFaK\xF6V[aS|\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA\x91aSsa\x05\x12V[\x91\x82\x91\x82a\x12\xB4V[\x03\x90\xA1V[aS\x89aS!V[V[\x90V[aS\x9CaS\xA1\x91`\ra\x10\xEBV[aS\x8BV[aS\xAD`\x04\x82\x01a\x11\x1AV[aS\xBFaS\xB9_a*\xC6V[\x91a\x07\x94V[\x14aUMWaT;\x90aS\xDEBaS\xD8`\x04\x84\x01a\x11\x1AV[\x90a,\xEEV[\x80aS\xF8aS\xF2aS\xEDa\x1A*V[a\x07\x94V[\x91a\x07\x94V[\x10\x15_\x14aT=WPaT\x18aT\x0F_\x83\x01a\x11\x1AV[`\x01\x83\x01a+eV[aT0aT'`\x02\x83\x01a\x11\x1AV[`\x03\x83\x01a+eV[[`\x04B\x91\x01a+eV[V[\x80aTPaTJ_a*\xC6V[\x91a\x07\x94V[\x11aT\\W[PaT1V[aU>aU,aUG\x92aU\x1BaU\x12aU\x01aT\xEFaT\xB1aT\x80_\x8B\x01a\x11\x1AV[aT\x92\x87aT\x8Ca\x1E\xA2V[\x90a-2V[aT\xABaT\x9Da\x1A*V[aT\xA5a\x1E\xA2V[\x90a-2V[\x91ad\x1AV[\x94aT\xD0aT\xC1`\x02\x8C\x01a\x11\x1AV[\x91aT\xCAa\x1E\xA2V[\x90a-2V[aT\xE9aT\xDBa\x1A*V[aT\xE3a\x1E\xA2V[\x90a-2V[\x91ad\x1AV[\x93aT\xFC`\x01\x8A\x01a\x11\x1AV[a0VV[aU\x0C_\x89\x01a\x11\x1AV[\x90af\x19V[`\x01\x87\x01a+eV[aU'`\x03\x86\x01a\x11\x1AV[a0VV[aU8`\x02\x85\x01a\x11\x1AV[\x90af\x19V[`\x03\x83\x01a+eV[_aTVV[aU[\x90`\x04B\x91\x01a+eV[V[aUea>BV[PaUoCa\\\xCBV[\x90V[\x90V[\x90aU\x8AaU\x85aU\x91\x92a\x10\xDFV[aUrV[\x82TaC,V[\x90UV[\x90aV\x1E\x91aV\x18aU\xA6\x82a9\x8FV[aU\xBB\x84aU\xB6`\t\x86\x90a9MV[aUuV[\x82\x81\x85\x90aU\xFBaU\xF5aU\xEF\x7F14\xE8\xA2\xE6\xD9~\x92\x9A~T\x01\x1E\xA5H]}\x19m\xD5\xF0\xBAMN\xF9X\x03\xE8\xE3\xFC%\x7F\x95a\x10\xDFV[\x92a\x10\xDFV[\x92a\x10\xDFV[\x92aV\x04a\x05\x12V[\x80aV\x0E\x81a\t\x13V[\x03\x90\xA4\x92\x91afEV[\x91af]V[V[\x90\x91aV*a'\x95V[P\x80aV>aV8_a*\xC6V[\x91a\x07\x94V[\x14aV\xBEWaVM\x90Ba,\xEEV[\x80aVgaVaaV\\a\x1A*V[a\x07\x94V[\x91a\x07\x94V[\x10\x15aV\xB9W\x82\x91aV\xABaV\xB1\x92aV\x8CaV\xB6\x96\x91aV\x86a\x1E\xA2V[\x90a-2V[aV\xA5aV\x97a\x1A*V[aV\x9Fa\x1E\xA2V[\x90a-2V[\x91ad\x1AV[\x90a0VV[af\x19V[\x90V[PP\x90V[PPPaV\xCA_a*\xC6V[\x90V[aV\xF4aV\xEFaV\xEAaV\xF9\x93aV\xE2a:\xC1V[P`\na66V[a6LV[ah\x0BV[ah\x8AV[\x90V[aW\x0E\x90aW\x08a'\x95V[Pah\xDBV[\x90V[aW\x19aM\x90V[aW!aW#V[V[aW/`\x01`\x0Fa+/V[aW7aK\xF6V[aWm\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2X\x91aWda\x05\x12V[\x91\x82\x91\x82a\x12\xB4V[\x03\x90\xA1V[aWzaW\x11V[V[\x90V[aW\x87a&\x1FV[PaW\xBC\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0aW\xB6`\x06aW|V[\x90ai\xF6V[\x90V[aW\xC7a&\x1FV[PaW\xFC\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0aW\xF6`\x07aW|V[\x90ai\xF6V[\x90V[aX\x07a%FV[PaX\x13_\x82\x01aQZV[\x80aX&aX _a*\xC6V[\x91a\x07\x94V[\x14_\x14aX<WPPaX8_aQ\xDEV[[\x90V[aXi_\x91aXdaX^\x84aXo\x96\x01\x92aXX`\x01aDEV[\x90a,\xEEV[\x91aQ}V[ab\xF9V[\x01aQ\xD1V[aX9V[\x90\x81aX\x90aX\x8AaX\x85_a*\xFEV[a\x07eV[\x91a\x07eV[\x14aX\xACWaX\xAA\x91\x90aX\xA3_a*\xFEV[\x90\x91a[EV[V[aX\xCFaX\xB8_a*\xFEV[_\x91\x82\x91cKc~\x8F`\xE1\x1B\x83R`\x04\x83\x01a\x12\xB4V[\x03\x90\xFD[aX\xED\x90aX\xDFa/tV[PaX\xE8aOiV[ajDV[\x90V[\x92aY\x0B\x92aY\x14\x94aY\x01a9IV[P\x92\x90\x91\x92aj\xFAV[\x90\x92\x91\x92al%V[\x90V[\x91` aY8\x92\x94\x93aY1`@\x82\x01\x96_\x83\x01\x90a\x12\xA7V[\x01\x90a\x08;V[V[aYC\x81aY}V[\x91aYVaYP\x84a\x07\x94V[\x91a\x07\x94V[\x03aY_WPPV[aYy_\x92\x83\x92c\x01\xD4\xB6#`\xE6\x1B\x84R`\x04\x84\x01aY\x17V[\x03\x90\xFD[aY\x91\x90aY\x89a'\x95V[P`\x08a:\xDAV[aY\xADaY\x9D\x82a\x11\x1AV[\x91aY\xA7\x83a0GV[\x90a+eV[\x90V[\x90aY\xD0aY\xCBaY\xD5\x93aY\xC3aK\xAFV[P`\na66V[a6LV[am\x87V[\x90V[\x90\x92\x81aY\xF5aY\xEFaY\xEA_a*\xFEV[a\x07eV[\x91a\x07eV[\x14aZ\xC0W\x83aZ\x15aZ\x0FaZ\n_a*\xFEV[a\x07eV[\x91a\x07eV[\x14aZ\x99WaZ9\x83aZ4aZ-`\x01\x86\x90aK6V[\x87\x90a:\xDAV[a+eV[aZCW[PPPV[\x91\x90\x91aZ\x8EaZ|aZv\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%\x93a\x10\xDFV[\x93a\x10\xDFV[\x93aZ\x85a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xA3_\x80\x80aZ>V[aZ\xBCaZ\xA5_a*\xFEV[_\x91\x82\x91cJ\x14\x06\xB1`\xE1\x1B\x83R`\x04\x83\x01a\x12\xB4V[\x03\x90\xFD[aZ\xE3aZ\xCC_a*\xFEV[_\x91\x82\x91c\xE6\x02\xDF\x05`\xE0\x1B\x83R`\x04\x83\x01a\x12\xB4V[\x03\x90\xFD[\x91` a[\x08\x92\x94\x93a[\x01`@\x82\x01\x96_\x83\x01\x90a\x12\xA7V[\x01\x90a\rqV[V[\x90a[\x1Fa[\x19\x83\x83\x90a>\x18V[\x15a\x05qV[a['WPPV[a[A_\x92\x83\x92c\xE2Q}?`\xE0\x1B\x84R`\x04\x84\x01aZ\xE7V[\x03\x90\xFD[\x91a[R\x92\x91\x90\x91am\xA8V[V[\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x90V[\x90\x95\x94\x92a[\xC3\x94a[\xB2a[\xBC\x92a[\xA8`\x80\x96a[\x9E`\xA0\x88\x01\x9C_\x89\x01\x90a\rqV[` \x87\x01\x90a\rqV[`@\x85\x01\x90a\rqV[``\x83\x01\x90a\x08;V[\x01\x90a\x12\xA7V[V[a[\xCDa/tV[Pa[\xD6a[TV[a\\M\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91a\\>\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0Fa\\)0a<\xE9V[\x91a\\2a\x05\x12V[\x96\x87\x95` \x87\x01a[xV[` \x82\x01\x81\x03\x82R\x03\x82a\x0CnV[a\\_a\\Y\x82a\x06\xCBV[\x91aH\xB2V[ \x90V[a\\wa\\ra\\|\x92a\x13\x9BV[a\x06\x87V[a\x0E\\V[\x90V[a\\\x88\x90a\\cV[\x90RV[\x91` a\\\xAD\x92\x94\x93a\\\xA6`@\x82\x01\x96_\x83\x01\x90a\\\x7FV[\x01\x90a\x08;V[V[a\\\xC3a\\\xBEa\\\xC8\x92a\x07\x94V[a\x06\x87V[a\x19tV[\x90V[a\\\xD3a>BV[P\x80a\\\xEDa\\\xE7e\xFF\xFF\xFF\xFF\xFF\xFFaP\xC5V[\x91a\x07\x94V[\x11a\\\xFEWa\\\xFB\x90a\\\xAFV[\x90V[`0a]\x1A_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01a\\\x8CV[\x03\x90\xFD[\x90V[a]5a]0a]:\x92a]\x1EV[a\x06\x87V[a\x07\x94V[\x90V[\x90V[a]Ta]Oa]Y\x92a]=V[a\x06\x87V[a\x0E\\V[\x90V[a]{\x90a]ua]oa]\x80\x94a\x0E\\V[\x91a\x07\x94V[\x90a\t\xB4V[a\x07\x94V[\x90V[\x90V[a]\x9Aa]\x95a]\x9F\x92a]\x83V[a\x06\x87V[a\x0E\\V[\x90V[a]\xC1\x90a]\xBBa]\xB5a]\xC6\x94a\x0E\\V[\x91a\x07\x94V[\x90a'\xE4V[a\x07\x94V[\x90V[\x90V[a]\xE0a]\xDBa]\xE5\x92a]\xC9V[a\x06\x87V[a\x07\x94V[\x90V[\x90V[a]\xFFa]\xFAa^\x04\x92a]\xE8V[a\x06\x87V[a\x0E\\V[\x90V[\x90V[a^\x1Ea^\x19a^#\x92a^\x07V[a\x06\x87V[a\x07\x94V[\x90V[\x90V[a^=a^8a^B\x92a^&V[a\x06\x87V[a\x0E\\V[\x90V[\x90V[a^\\a^Wa^a\x92a^EV[a\x06\x87V[a\x07\x94V[\x90V[\x90V[a^{a^va^\x80\x92a^dV[a\x06\x87V[a\x0E\\V[\x90V[\x90V[a^\x9Aa^\x95a^\x9F\x92a^\x83V[a\x06\x87V[a\x07\x94V[\x90V[\x90V[a^\xB9a^\xB4a^\xBE\x92a^\xA2V[a\x06\x87V[a\x0E\\V[\x90V[a^\xD5a^\xD0a^\xDA\x92a^&V[a\x06\x87V[a\x07\x94V[\x90V[a^\xF1a^\xECa^\xF6\x92aM\xBAV[a\x06\x87V[a\x0E\\V[\x90V[a_\ra_\x08a_\x12\x92a^\xA2V[a\x06\x87V[a\x07\x94V[\x90V[a_)a_$a_.\x92aDBV[a\x06\x87V[a\x0E\\V[\x90V[\x90V[a_Ha_Ca_M\x92a_1V[a\x06\x87V[a\x07\x94V[\x90V[\x90a_[\x91\x02a\x07\x94V[\x90V[a_ja_p\x91a\x07\x94V[\x91a\x07\x94V[\x90\x81\x15a_{W\x04\x90V[a-gV[\x90a_\x8B\x91\x01a\x07\x94V[\x90V[a_\x96a'\x95V[P\x80a_\xABa_\xA5`\x01aDEV[\x91a\x07\x94V[\x11\x15ab\xF6W\x80aa\xC0aa\x9Daa\x8Daa}aamaa]aaMaa=aa-aa\x1Daa\r\x8Baa\x07aa\0aa\xC6\x9Fa`\xE0a`\xD0a`\xF0\x92a_\xF2`\x01aDEV[\x90\x80a`\na`\x04`\x01`\x80\x1Ba]!V[\x91a\x07\x94V[\x10\x15ab\xC8W[\x80a`-a`'h\x01\0\0\0\0\0\0\0\0a]\xCCV[\x91a\x07\x94V[\x10\x15ab\x9AW[\x80a`La`Fd\x01\0\0\0\0a^\nV[\x91a\x07\x94V[\x10\x15ablW[\x80a`ia`cb\x01\0\0a^HV[\x91a\x07\x94V[\x10\x15ab>W[\x80a`\x85a`\x7Fa\x01\0a^\x86V[\x91a\x07\x94V[\x10\x15ab\x10W[\x80a`\xA0a`\x9A`\x10a^\xC1V[\x91a\x07\x94V[\x10\x15aa\xE2W[a`\xBAa`\xB4`\x04a^\xF9V[\x91a\x07\x94V[\x10\x15aa\xC9W[a`\xCB`\x03a_4V[a_PV[a`\xDA`\x01a_\x15V[\x90a]\\V[a`\xEA\x81\x86a_^V[\x90a_\x80V[a`\xFA`\x01a_\x15V[\x90a]\\V[\x80\x92a_^V[\x90a_\x80V[aa\x17`\x01a_\x15V[\x90a]\\V[aa'\x81\x8Ca_^V[\x90a_\x80V[aa7`\x01a_\x15V[\x90a]\\V[aaG\x81\x8Aa_^V[\x90a_\x80V[aaW`\x01a_\x15V[\x90a]\\V[aag\x81\x88a_^V[\x90a_\x80V[aaw`\x01a_\x15V[\x90a]\\V[aa\x87\x81\x86a_^V[\x90a_\x80V[aa\x97`\x01a_\x15V[\x90a]\\V[\x91aa\xBAaa\xB4aa\xAF\x85\x80\x94a_^V[a\x07\x94V[\x91a\x07\x94V[\x11an8V[\x90aLYV[\x90V[aa\xDD\x90aa\xD7`\x01a_\x15V[\x90a]\xA2V[a`\xC1V[aa\xF9ab\n\x91aa\xF3`\x04a^\xA5V[\x90a]\\V[\x91ab\x04`\x02a^\xDDV[\x90a]\xA2V[\x90a`\xA7V[ab'ab8\x91ab!`\x08a^gV[\x90a]\\V[\x91ab2`\x04a^\xA5V[\x90a]\xA2V[\x90a`\x8CV[abUabf\x91abO`\x10a^)V[\x90a]\\V[\x91ab``\x08a^gV[\x90a]\xA2V[\x90a`pV[ab\x83ab\x94\x91ab}` a]\xEBV[\x90a]\\V[\x91ab\x8E`\x10a^)V[\x90a]\xA2V[\x90a`SV[ab\xB1ab\xC2\x91ab\xAB`@a]\x86V[\x90a]\\V[\x91ab\xBC` a]\xEBV[\x90a]\xA2V[\x90a`4V[ab\xDFab\xF0\x91ab\xD9`\x80a]@V[\x90a]\\V[\x91ab\xEA`@a]\x86V[\x90a]\xA2V[\x90a`\x11V[\x90V[_R` _ \x01\x90V[\x93\x91\x90\x92ac\x0Fa'\x95V[P[\x81ac$ac\x1E\x83a\x07\x94V[\x91a\x07\x94V[\x10\x15ac\x8AWac5\x82\x82\x90anFV[\x90acK_acE\x88\x85\x90ab\xF9V[\x01aQ\x9FV[ac]acW\x87a\x19tV[\x91a\x19tV[\x11_\x14acmWP\x91[\x91ac\x11V[\x92\x91Pac\x84\x90ac~`\x01aDEV[\x90a0VV[\x90acgV[\x92PP\x91P\x90V[ac\xA3ac\x9Da9\xEAV[\x15a\x05qV[ac\xA9WV[_c\x8D\xFC +`\xE0\x1B\x81R\x80ac\xC1`\x04\x82\x01a\t\x13V[\x03\x90\xFD[ac\xD9ac\xD4ac\xDE\x92a5\0V[a\x06\x87V[a\x07\x94V[\x90V[ac\xEB`\x12ac\xC5V[\x90V[\x90V[ad\x05ad\0ad\n\x92ac\xEEV[a\x06\x87V[a\x07\x94V[\x90V[ad\x17`\x11ac\xF1V[\x90V[\x92\x91\x92ad%a'\x95V[Pad1\x81\x83\x90a_PV[\x91ad:a'\x95V[P_\x19\x81\x83\t\x83\x80\x82\x10\x91\x03\x03\x91\x82ad[adU_a*\xC6V[\x91a\x07\x94V[\x14af\x08W\x85adsadm\x85a\x07\x94V[\x91a\x07\x94V[\x11\x15ae\xD6Wae\xCD\x92\x86ae\xD3\x96\x97\x93ad\xC4\x93ad\x90a'\x95V[P\t\x90\x85\x82\x11\x90\x03\x94\x03\x93`\x01\x83ad\xB1_ad\xAC\x87\x91a*\xC6V[aLYV[\x16\x80\x80\x95\x04\x96\x04\x93\x80_\x03\x04\x01\x90a_PV[\x17\x91ae\xC7ae\xABae\x87aecae?ae\x1Bad\xEC`\x03ad\xE7\x89\x91a_4V[a_PV[ad\xF6`\x02aM\xBDV[\x18ae\x15`\x02ae\x10ae\n\x8B\x85\x90a_PV[\x91aM\xBDV[aLYV[\x90a_PV[ae9`\x02ae4ae.\x8A\x85\x90a_PV[\x91aM\xBDV[aLYV[\x90a_PV[ae]`\x02aeXaeR\x89\x85\x90a_PV[\x91aM\xBDV[aLYV[\x90a_PV[ae\x81`\x02ae|aev\x88\x85\x90a_PV[\x91aM\xBDV[aLYV[\x90a_PV[ae\xA5`\x02ae\xA0ae\x9A\x87\x85\x90a_PV[\x91aM\xBDV[aLYV[\x90a_PV[\x91ae\xC2ae\xBC`\x02\x92\x85\x90a_PV[\x91aM\xBDV[aLYV[\x90a_PV[\x90a_PV[\x90V[af\x03\x86ae\xECae\xE6_a*\xC6V[\x91a\x07\x94V[\x14ae\xF5ac\xE1V[ae\xFDad\rV[\x91antV[an\x98V[PPP\x91af\x16\x91\x92a_^V[\x90V[afB\x91af%a'\x95V[P\x81af9af3\x83a\x07\x94V[\x91a\x07\x94V[\x10\x91\x90\x91antV[\x90V[afW\x90afQa'\x95V[Pa:\xF0V[\x90V[\x90V[\x91\x90\x91\x80afsafm\x85a\x07eV[\x91a\x07eV[\x14\x15\x80ag\xF1W[af\x85W[PPPV[\x80af\xA0af\x9Aaf\x95_a*\xFEV[a\x07eV[\x91a\x07eV[\x03agaW[P\x81af\xC2af\xBCaf\xB7_a*\xFEV[a\x07eV[\x91a\x07eV[\x03af\xCEW[\x80af\x80V[ag\x15ag\x08ag\x0F\x92af\xE4`\n\x86\x90a66V[\x90ag\x02af\xFCaf\xF6`\x01\x93ao\x13V[\x93a6LV[\x91afZV[\x90aofV[\x92\x90a6OV[\x91a6OV[\x91\x90\x91agB\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\x10\xDFV[\x92agWagNa\x05\x12V[\x92\x83\x92\x83a\n\x98V[\x03\x90\xA2_\x80af\xC8V[ag\xA0ag\xA6ag\x99agv`\n\x85\x90a66V[`\x02ag\x93ag\x8Dag\x87\x89ao\x13V[\x93a6LV[\x91afZV[\x90aofV[\x92\x90a6OV[\x91a6OV[\x91\x90\x91ag\xD3\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\x10\xDFV[\x92ag\xE8ag\xDFa\x05\x12V[\x92\x83\x92\x83a\n\x98V[\x03\x90\xA2_af\xA6V[P\x81ah\x05ag\xFF_a*\xC6V[\x91a\x07\x94V[\x11af{V[_ah\x1F\x91ah\x18a'\x95V[P\x01aQZV[\x90V[ah6ah1ah;\x92a\x15IV[a\x06\x87V[a\x07\x94V[\x90V[ahG\x90a]\xEBV[\x90RV[\x91` ahl\x92\x94\x93ahe`@\x82\x01\x96_\x83\x01\x90ah>V[\x01\x90a\x08;V[V[ah\x82ah}ah\x87\x92a\x07\x94V[a\x06\x87V[a\x15IV[\x90V[ah\x92a:\xC1V[P\x80ah\xAAah\xA4c\xFF\xFF\xFF\xFFah\"V[\x91a\x07\x94V[\x11ah\xBBWah\xB8\x90ahnV[\x90V[` ah\xD7_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01ahKV[\x03\x90\xFD[ah\xF2ah\xF7\x91ah\xEAa'\x95V[P`\x08a:\xDAV[a\x11\x1AV[\x90V[\x90V[ai\x11ai\x0Cai\x16\x92ah\xFAV[a\x1B\xFEV[a\r-V[\x90V[ai#`\xFFah\xFDV[\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90aiIaiB\x83a\x0B\x85V[\x80\x94a&$V[\x91`\x01\x81\x16\x90\x81_\x14ai\xA0WP`\x01\x14aidW[PPPV[aiq\x91\x92\x93\x94Pai&V[\x91_\x92[\x81\x84\x10ai\x88WPP\x01\x90_\x80\x80ai_V[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90aiuV[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80ai_V[\x90ai\xC5\x91ai/V[\x90V[\x90ai\xE8ai\xE1\x92ai\xD8a\x05\x12V[\x93\x84\x80\x92ai\xBBV[\x03\x83a\x0CnV[V[ai\xF3\x90ai\xC8V[\x90V[\x90ai\xFFa&\x1FV[Paj\t\x82a/xV[aj\"aj\x1Caj\x17ai\x19V[a\r-V[\x91a\r-V[\x14\x15_\x14aj7WPaj4\x90ao\xF0V[\x90V[ajA\x91Pai\xEAV[\x90V[`B\x91ajOa/tV[P`@Q\x91\x7F\x19\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83R`\x02\x83\x01R`\"\x82\x01R \x90V[_\x90V[aj\x95aj\x9A\x91a\x11\x01V[a(\rV[\x90V[\x90V[aj\xB4aj\xAFaj\xB9\x92aj\x9DV[a\x06\x87V[a\x07\x94V[\x90V[aj\xF1aj\xF8\x94aj\xE7``\x94\x98\x97\x95aj\xDD`\x80\x86\x01\x9A_\x87\x01\x90a\rqV[` \x85\x01\x90a\x0EbV[`@\x83\x01\x90a\rqV[\x01\x90a\rqV[V[\x93\x92\x93ak\x05a9IV[Pak\x0Eaj\x85V[Pak\x17a/tV[Pak!\x85aj\x89V[akSakM\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0aj\xA0V[\x91a\x07\x94V[\x11ak\xE0W\x90akv` \x94\x95_\x94\x93\x92\x93akma\x05\x12V[\x94\x85\x94\x85aj\xBCV[\x83\x80R\x03\x90`\x01Z\xFA\x15ak\xDBWak\x8E_Qa\x1B\xFEV[\x80ak\xA9ak\xA3ak\x9E_a*\xFEV[a\x07eV[\x91a\x07eV[\x14ak\xBFW_\x91ak\xB9_a\x1C\x03V[\x91\x92\x91\x90V[Pak\xC9_a*\xFEV[`\x01\x91ak\xD5_a\x1C\x03V[\x91\x92\x91\x90V[a,\xDEV[PPPak\xEC_a*\xFEV[\x90`\x03\x92\x91\x92\x91\x90V[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x04\x11\x15al\x14WV[ak\xF6V[\x90al#\x82al\nV[V[\x80al8al2_al\x19V[\x91al\x19V[\x14_\x14alCWPPV[\x80alWalQ`\x01al\x19V[\x91al\x19V[\x14_\x14alzW_c\xF6E\xEE\xDF`\xE0\x1B\x81R\x80alv`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x80al\x8Eal\x88`\x02al\x19V[\x91al\x19V[\x14_\x14al\xBCWal\xB8al\xA1\x83aj\x89V[_\x91\x82\x91c\xFC\xE6\x98\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x08HV[\x03\x90\xFD[al\xCFal\xC9`\x03al\x19V[\x91al\x19V[\x14al\xD7WPV[al\xF2\x90_\x91\x82\x91c5\xE2\xF3\x83`\xE2\x1B\x83R`\x04\x83\x01a\r~V[\x03\x90\xFD[_R` _ \x90V[am\x08\x81aQZV[\x82\x10\x15am\"Wam\x1A`\x01\x91al\xF6V[\x91\x02\x01\x90_\x90V[a\x0E\xD7V[\x90am1\x90a\x19tV[\x90RV[\x90am?\x90a$\x13V[\x90RV[\x90amyamp_amSaKtV[\x94amjamb\x83\x83\x01aQ\x9FV[\x83\x88\x01am'V[\x01aQ\xD1V[` \x84\x01am5V[V[am\x84\x90amCV[\x90V[am\xA5\x91_am\x9F\x92am\x98aK\xAFV[P\x01al\xFFV[Pam{V[\x90V[\x92\x91am\xB6\x84\x83\x83\x91ap V[\x83am\xD1am\xCBam\xC6_a*\xFEV[a\x07eV[\x91a\x07eV[\x14am\xE6W[am\xE4\x92\x93\x91\x90\x91aq\xAAV[V[am\xEEa*\x96V[\x93am\xF7aq\x8FV[\x94\x80an\x0Ban\x05\x88a\x07\x94V[\x91a\x07\x94V[\x11an\x18WP\x93Pam\xD7V[\x85\x90an4_\x92\x83\x92c\x0EX\xAE\x93`\xE1\x1B\x84R`\x04\x84\x01a\n\x98V[\x03\x90\xFD[an@a'\x95V[P\x15\x15\x90V[ankanq\x92anUa'\x95V[P\x82\x81\x16\x92\x18ane`\x02aM\xBDV[\x90a-{V[\x90a0VV[\x90V[an\x8Ean\x94\x92\x93an\x84a'\x95V[P\x80\x94\x18\x91an8V[\x90a_PV[\x18\x90V[cNH{q_R` R`$`\x1C\xFD[\x90V[an\xBFan\xBAan\xC4\x92an\xA8V[a\x06\x87V[a\x0E\\V[\x90V[an\xD0\x90an\xABV[\x90RV[\x91` an\xF5\x92\x94\x93an\xEE`@\x82\x01\x96_\x83\x01\x90an\xC7V[\x01\x90a\x08;V[V[ao\x0Bao\x06ao\x10\x92a\x07\x94V[a\x06\x87V[a$\x13V[\x90V[ao\x1Ba%FV[P\x80ao5ao/`\x01\x80`\xD0\x1B\x03a6OV[\x91a\x07\x94V[\x11aoFWaoC\x90an\xF7V[\x90V[`\xD0aob_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01an\xD4V[\x03\x90\xFD[\x90ao\x9Cao\xA2\x93\x92aowa%FV[Pao\x80a%FV[P\x80\x93ao\x95ao\x8Ea>FV[\x94\x92aW\xFFV[\x90\x91av\x12V[\x91ariV[\x91\x90\x91\x90V[ao\xBCao\xB7ao\xC1\x92a]\xE8V[a\x06\x87V[a\x07\x94V[\x90V[6\x907V[\x90ao\xEEao\xD6\x83a8\x91V[\x92` \x80ao\xE4\x86\x93a8nV[\x92\x01\x91\x03\x90ao\xC4V[V[ao\xF8a&\x1FV[Pap\x02\x81ar\xD3V[\x90ap\x15ap\x10` ao\xA8V[ao\xC9V[\x91\x82R` \x82\x01R\x90V[\x91\x90\x91\x80ap>ap8ap3_a*\xFEV[a\x07eV[\x91a\x07eV[\x14_\x14aq\x1FWapbap[\x83apV`\x02a\x11\x1AV[a0VV[`\x02a+eV[[\x82ap~apxaps_a*\xFEV[a\x07eV[\x91a\x07eV[\x14_\x14ap\xF3Wap\xA2ap\x9B\x83ap\x96`\x02a\x11\x1AV[aLYV[`\x02a+eV[[\x91\x90\x91ap\xEEap\xDCap\xD6\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x93a\x10\xDFV[\x93a\x10\xDFV[\x93ap\xE5a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xA3V[aq\x1A\x82aq\x14aq\x05_\x87\x90a:\xDAV[\x91aq\x0F\x83a\x11\x1AV[a_\x80V[\x90a+eV[ap\xA3V[aq2aq-_\x83\x90a:\xDAV[a\x11\x1AV[\x80aqEaq?\x85a\x07\x94V[\x91a\x07\x94V[\x10aqmWaqXaqh\x91\x84\x90aLYV[aqc_\x84\x90a:\xDAV[a+eV[apcV[\x90aq\x8B\x90\x91\x92_\x93\x84\x93c9\x144\xE3`\xE2\x1B\x85R`\x04\x85\x01aL'V[\x03\x90\xFD[aq\x97a'\x95V[Paq\xA7`\x01\x80`\xD0\x1B\x03a6OV[\x90V[\x91ar\x02aq\xFCar\t\x94\x80aq\xD0aq\xCAaq\xC5_a*\xFEV[a\x07eV[\x91a\x07eV[\x14ar:W[\x84aq\xF1aq\xEBaq\xE6_a*\xFEV[a\x07eV[\x91a\x07eV[\x14ar\x0BW[a9\x8FV[\x92a9\x8FV[\x90\x91af]V[V[ar3`\x0B`\x02ar-ar'ar!\x89ao\x13V[\x93a6LV[\x91afZV[\x90aofV[PPaq\xF7V[arb`\x0B`\x01ar\\arVarP\x89ao\x13V[\x93a6LV[\x91afZV[\x90aofV[PPaq\xD6V[\x91ar\x8D_ar\x92\x94arza%FV[Par\x83a%FV[P\x01\x92\x91\x92aQ}V[at\xC4V[\x91\x90\x91\x90V[ar\xACar\xA7ar\xB1\x92ah\xFAV[a\x06\x87V[a\x07\x94V[\x90V[\x90V[ar\xCBar\xC6ar\xD0\x92ar\xB4V[a\x06\x87V[a\x07\x94V[\x90V[ar\xE8ar\xED\x91ar\xE2a'\x95V[Pa/xV[aj\x89V[ar\xF7`\xFFar\x98V[\x16\x80as\x0Cas\x06`\x1Far\xB7V[\x91a\x07\x94V[\x11as\x14W\x90V[_c,\xD4J\xC3`\xE2\x1B\x81R\x80as,`\x04\x82\x01a\t\x13V[\x03\x90\xFD[T\x90V[as>`@a8YV[\x90V[_R` _ \x90V[asS\x81as0V[\x82\x10\x15asmWase`\x01\x91asAV[\x91\x02\x01\x90_\x90V[a\x0E\xD7V[as|\x90Qa\x19tV[\x90V[\x90as\x90e\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x1B\xFEV[\x91\x81\x19\x16\x91\x16\x17\x90V[as\xAEas\xA9as\xB3\x92a\x19tV[a\x06\x87V[a\x19tV[\x90V[\x90V[\x90as\xCEas\xC9as\xD5\x92as\x9AV[as\xB6V[\x82Tas\x7FV[\x90UV[as\xE3\x90Qa$\x13V[\x90V[`0\x1B\x90V[\x90as\xFEe\xFF\xFF\xFF\xFF\xFF\xFF\x19\x91as\xE6V[\x91\x81\x19\x16\x91\x16\x17\x90V[at\x1Cat\x17at!\x92a$\x13V[a\x06\x87V[a$\x13V[\x90V[\x90V[\x90at<at7atC\x92at\x08V[at$V[\x82Tas\xECV[\x90UV[\x90atq` _atw\x94ati\x82\x82\x01atc\x84\x88\x01asrV[\x90as\xB9V[\x01\x92\x01as\xD9V[\x90at'V[V[\x91\x90at\x8AWat\x88\x91atGV[V[a\x0B^V[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15at\xBFW\x82at\xB7\x91`\x01at\xBD\x95\x01\x81UasJV[\x90atyV[V[a\x0CZV[\x90\x92\x91\x92at\xD0a%FV[Pat\xD9a%FV[Pat\xE3\x82as0V[\x80at\xF6at\xF0_a*\xC6V[\x91a\x07\x94V[\x11_\x14au\xC6Wau\x1C\x90au\x16\x84\x91au\x10`\x01aDEV[\x90a,\xEEV[\x90ab\xF9V[\x90au(_\x83\x01aQ\x9FV[\x92au4_\x84\x01aQ\xD1V[\x93\x80auHauB\x85a\x19tV[\x91a\x19tV[\x11au\xAAWau_auY\x84a\x19tV[\x91a\x19tV[\x14_\x14auzWPPauu\x90_\x85\x91\x01at'V[[\x91\x90V[au\xA5\x92Pau\xA0\x86au\x97au\x8Eas4V[\x94_\x86\x01am'V[` \x84\x01am5V[at\x8FV[auvV[_c% `\x1D`\xE0\x1B\x81R\x80au\xC2`\x04\x82\x01a\t\x13V[\x03\x90\xFD[Pau\xF1\x91au\xEC\x85au\xE3au\xDAas4V[\x94_\x86\x01am'V[` \x84\x01am5V[at\x8FV[au\xFA_aQ\xDEV[\x91\x90V[cNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[\x91\x90\x91\x80`\x01\x14av1W`\x02\x03au\xFEWav-\x91a%\xC5V[\x90[V[Pav;\x91a%\x86V[\x90av/V",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361015610013575b612542565b61001d5f3561050c565b806301ffc9a71461050757806306fdde031461050257806307a1d5fa146104fd578063095ea7b3146104f85780630c05f82c146104f357806313beaa5b146104ee57806318160ddd146104e95780631b02f845146104e457806322a97d9c146104df57806323b872dd146104da57806323e460d2146104d5578063243a30cc146104d05780632481bb5c146104cb578063248a9ca3146104c6578063284e1333146104c15780632f2ff15d146104bc578063313ce567146104b7578063334d0bbd146104b2578063359b76fe146104ad5780633644e515146104a857806336568abe146104a35780633a46b1a81461049e5780633f4ba83a1461049957806340c10f191461049457806344e181aa1461048f57806348b0daa61461048a5780634bdd36ce146104855780634bf5d7e914610480578063587cde1e1461047b5780635adf0021146104765780635c19a95c146104715780635c975abb1461046c5780635f15c3c914610467578063651fd268146104625780636c33bced1461045d5780636cf01625146104585780636fc063be146104535780636fcfff451461044e57806370a0823114610449578063726600ce14610444578063766718081461043f5780637c790cab1461043a5780637ecebe00146104355780638456cb591461043057806384b0196e1461042b5780638e539e8c14610426578063902d55a51461042157806391d148541461041c57806391ddadf41461041757806395d89b411461041257806399127d9b1461040d578063998955d3146104085780639ab24eb0146104035780639b7ef64b146103fe5780639dc29fac146103f9578063a08d5654146103f4578063a217fddf146103ef578063a3d4485b146103ea578063a4d7e31d146103e5578063a571e184146103e0578063a5b326be146103db578063a70b9f0c146103d6578063a9059cbb146103d1578063ae5ecbc6146103cc578063af2aa63b146103c7578063b0ca253e146103c2578063babc394f146103bd578063bb4d4436146103b8578063c02ae754146103b3578063c1eb7137146103ae578063c3cda520146103a9578063d505accf146103a4578063d547741f1461039f578063dd62ed3e1461039a578063e3abdfcb14610395578063e63ab1e914610390578063f1127ed81461038b578063f508e19d146103865763f75e85120361000e5761250d565b6124a9565b612464565b612381565b61231d565b6122b8565b612257565b61221d565b612173565b6120b7565b612082565b61204d565b612014565b611fa0565b611f6b565b611ec1565b611e4d565b611e18565b611daa565b611d77565b611cf5565b611cc0565b611c36565b611bc7565b611b59565b611b24565b611aae565b611a79565b611a44565b6119d6565b6119a1565b61193e565b611909565b611893565b611857565b611712565b6116dd565b6116a4565b611622565b6115de565b6115a9565b611574565b611514565b6114b0565b61143c565b611407565b6113d2565b611366565b611333565b6112fe565b6112c9565b611272565b61123d565b611208565b6111c0565b6110ab565b611078565b611042565b61100e565b610fd9565b610fa6565b610f71565b610e84565b610e28565b610dc8565b610d93565b610cf8565b610b29565b610abb565b610a62565b6109f3565b610981565b61094c565b610918565b61085d565b6107e7565b61072f565b610647565b610598565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b63ffffffff60e01b1690565b61053981610524565b0361054057565b5f80fd5b9050359061055182610530565b565b9060208282031261056c57610569915f01610544565b90565b61051c565b151590565b61057f90610571565b9052565b9190610596905f60208501940190610576565b565b346105c8576105c46105b36105ae366004610553565b6125df565b6105bb610512565b91829182610583565b0390f35b610518565b5f9103126105d757565b61051c565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b61061d61062660209361062b93610614816105dc565b938480936105e0565b958691016105e9565b6105f4565b0190565b6106449160208201915f8184039101526105fe565b90565b34610677576106573660046105cd565b6106736106626126fd565b61066a610512565b9182918261062f565b0390f35b610518565b60018060a01b031690565b90565b61069e6106996106a39261067c565b610687565b61067c565b90565b6106af9061068a565b90565b6106bb906106a6565b90565b6106c7906106b2565b9052565b5190565b60209181520190565b6106f7610700602093610705936106ee816106cb565b938480936106cf565b958691016105e9565b6105f4565b0190565b9161072c9261071f60408201935f8301906106be565b60208184039101526106d8565b90565b346107605761073f3660046105cd565b610747612749565b9061075c610753610512565b92839283610709565b0390f35b610518565b61076e9061067c565b90565b61077a81610765565b0361078157565b5f80fd5b9050359061079282610771565b565b90565b6107a081610794565b036107a757565b5f80fd5b905035906107b882610797565b565b91906040838203126107e257806107d66107df925f8601610785565b936020016107ab565b90565b61051c565b34610818576108146108036107fd3660046107ba565b90612773565b61080b610512565b91829182610583565b0390f35b610518565b9060208282031261083657610833915f01610785565b90565b61051c565b61084490610794565b9052565b919061085b905f6020850194019061083b565b565b3461088d5761088961087861087336600461081d565b612799565b610880610512565b91829182610848565b0390f35b610518565b5f80fd5b5f80fd5b5f80fd5b909182601f830112156108d85781359167ffffffffffffffff83116108d35760200192600183028401116108ce57565b61089a565b610896565b610892565b9060208282031261090e575f82013567ffffffffffffffff811161090957610905920161089e565b9091565b610520565b61051c565b5f0190565b346109475761093161092b3660046108dd565b90612a8a565b610939610512565b8061094381610913565b0390f35b610518565b3461097c5761095c3660046105cd565b610978610967612a96565b61096f610512565b91829182610848565b0390f35b610518565b346109af576109913660046105cd565b610999612c62565b6109a1610512565b806109ab81610913565b0390f35b610518565b1c90565b60ff1690565b6109ce9060086109d393026109b4565b6109b8565b90565b906109e191546109be565b90565b6109f060405f906109d6565b90565b34610a2357610a033660046105cd565b610a1f610a0e6109e4565b610a16610512565b91829182610583565b0390f35b610518565b9091606082840312610a5d57610a5a610a43845f8501610785565b93610a518160208601610785565b936040016107ab565b90565b61051c565b34610a9357610a8f610a7e610a78366004610a28565b91612c6c565b610a86610512565b91829182610583565b0390f35b610518565b916020610ab9929493610ab260408201965f83019061083b565b019061083b565b565b34610aec57610ad3610ace36600461081d565b612d9d565b90610ae8610adf610512565b92839283610a98565b0390f35b610518565b90565b610b08610b03610b0d92610af1565b610687565b610794565b90565b610b1b610e10610af4565b90565b610b26610b10565b90565b34610b5957610b393660046105cd565b610b55610b44610b1e565b610b4c610512565b91829182610848565b0390f35b610518565b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52602260045260245ffd5b9060016002830492168015610ba5575b6020831014610ba057565b610b71565b91607f1691610b95565b60209181520190565b5f5260205f2090565b905f9291805490610bdb610bd483610b85565b8094610baf565b916001811690815f14610c325750600114610bf6575b505050565b610c039192939450610bb8565b915f925b818410610c1a57505001905f8080610bf1565b60018160209295939554848601520191019290610c07565b92949550505060ff19168252151560200201905f8080610bf1565b90610c5791610bc1565b90565b634e487b7160e01b5f52604160045260245ffd5b90610c78906105f4565b810190811067ffffffffffffffff821117610c9257604052565b610c5a565b90610cb7610cb092610ca7610512565b93848092610c4d565b0383610c6e565b565b905f10610ccc57610cc990610c97565b90565b610b5e565b610cdd60455f90610cb9565b90565b610cf59160208201915f8184039101526106d8565b90565b34610d2857610d083660046105cd565b610d24610d13610cd1565b610d1b610512565b91829182610ce0565b0390f35b610518565b90565b610d3981610d2d565b03610d4057565b5f80fd5b90503590610d5182610d30565b565b90602082820312610d6c57610d69915f01610d44565b90565b61051c565b610d7a90610d2d565b9052565b9190610d91905f60208501940190610d71565b565b34610dc357610dbf610dae610da9366004610d53565b612fbe565b610db6610512565b91829182610d7e565b0390f35b610518565b34610df657610dd83660046105cd565b610de06134bc565b610de8610512565b80610df281610913565b0390f35b610518565b9190604083820312610e235780610e17610e20925f8601610d44565b93602001610785565b90565b61051c565b34610e5757610e41610e3b366004610dfb565b906134f0565b610e49610512565b80610e5381610913565b0390f35b610518565b60ff1690565b610e6b90610e5c565b9052565b9190610e82905f60208501940190610e62565b565b34610eb457610e943660046105cd565b610eb0610e9f61351f565b610ea7610512565b91829182610e6f565b0390f35b610518565b90602082820312610ed257610ecf915f016107ab565b90565b61051c565b634e487b7160e01b5f52603260045260245ffd5b50603090565b90565b610efd81610eeb565b821015610f1757610f0f600191610ef1565b910201905f90565b610ed7565b90565b610f2f906008610f3493026109b4565b610f1c565b90565b90610f429154610f1f565b90565b6010610f5081610eeb565b821015610f6d57610f6a91610f6491610ef4565b90610f37565b90565b5f80fd5b34610fa157610f9d610f8c610f87366004610eb9565b610f45565b610f94610512565b91829182610848565b0390f35b610518565b34610fd457610fb63660046105cd565b610fbe6135d0565b610fc6610512565b80610fd081610913565b0390f35b610518565b3461100957610fe93660046105cd565b611005610ff46135da565b610ffc610512565b91829182610d7e565b0390f35b610518565b3461103d57611027611021366004610dfb565b906135ee565b61102f610512565b8061103981610913565b0390f35b610518565b346110735761106f61105e6110583660046107ba565b9061366b565b611066610512565b91829182610848565b0390f35b610518565b346110a6576110883660046105cd565b6110906136c9565b611098610512565b806110a281610913565b0390f35b610518565b346110da576110c46110be3660046107ba565b90613826565b6110cc610512565b806110d681610913565b0390f35b610518565b6110e8906106a6565b90565b906110f5906110df565b5f5260205260405f2090565b5f1c90565b61111261111791611101565b610f1c565b90565b6111249054611106565b90565b61113290600d6110eb565b61113d5f820161111a565b9161114a6001830161111a565b916111576002820161111a565b9161117060046111696003850161111a565b930161111a565b90565b909594926111be946111ad6111b7926111a360809661119960a088019c5f89019061083b565b602087019061083b565b604085019061083b565b606083019061083b565b019061083b565b565b346111f4576111f06111db6111d636600461081d565b611127565b916111e7959395610512565b95869586611173565b0390f35b610518565b61120560415f90610f37565b90565b34611238576112183660046105cd565b6112346112236111f9565b61122b610512565b91829182610848565b0390f35b610518565b3461126d5761124d3660046105cd565b611269611258613832565b611260610512565b91829182610848565b0390f35b610518565b346112a2576112823660046105cd565b61129e61128d6138f3565b611295610512565b9182918261062f565b0390f35b610518565b6112b090610765565b9052565b91906112c7905f602085019401906112a7565b565b346112f9576112f56112e46112df36600461081d565b61398f565b6112ec610512565b918291826112b4565b0390f35b610518565b3461132e5761130e3660046105cd565b61132a6113196139ae565b611321610512565b91829182610583565b0390f35b610518565b346113615761134b61134636600461081d565b6139d7565b611353610512565b8061135d81610913565b0390f35b610518565b34611396576113763660046105cd565b6113926113816139ea565b611389610512565b91829182610583565b0390f35b610518565b90565b6113b26113ad6113b79261139b565b610687565b610794565b90565b6113c4603061139e565b90565b6113cf6113ba565b90565b34611402576113e23660046105cd565b6113fe6113ed6113c7565b6113f5610512565b91829182610848565b0390f35b610518565b346114375761143361142261141d36600461081d565b613a00565b61142a610512565b91829182610848565b0390f35b610518565b3461146a5761144c3660046105cd565b611454613ab7565b61145c610512565b8061146681610913565b0390f35b610518565b90565b61148661148161148b9261146f565b610687565b610794565b90565b6114a26a084595161401484a000000611472565b90565b6114ad61148e565b90565b346114e0576114c03660046105cd565b6114dc6114cb6114a5565b6114d3610512565b91829182610848565b0390f35b610518565b906114ef906110df565b5f5260205260405f2090565b6115119061150c600e915f926114e5565b6109d6565b90565b346115445761154061152f61152a36600461081d565b6114fb565b611537610512565b91829182610583565b0390f35b610518565b63ffffffff1690565b61155b90611549565b9052565b9190611572905f60208501940190611552565b565b346115a4576115a061158f61158a36600461081d565b613ac5565b611597610512565b9182918261155f565b0390f35b610518565b346115d9576115d56115c46115bf36600461081d565b613af0565b6115cc610512565b91829182610848565b0390f35b610518565b3461160e5761160a6115f96115f436600461081d565b613b0e565b611601610512565b91829182610583565b0390f35b610518565b61161f60425f90610f37565b90565b34611652576116323660046105cd565b61164e61163d611613565b611645610512565b91829182610848565b0390f35b610518565b909594926116a29461169161169b9261168760809661167d60a088019c5f890190610576565b602087019061083b565b604085019061083b565b606083019061083b565b019061083b565b565b346116d8576116d46116bf6116ba36600461081d565b613b2d565b916116cb959395610512565b95869586611657565b0390f35b610518565b3461170d576117096116f86116f336600461081d565b613c9d565b611700610512565b91829182610848565b0390f35b610518565b34611740576117223660046105cd565b61172a613cd6565b611732610512565b8061173c81610913565b0390f35b610518565b60ff60f81b1690565b61175790611745565b9052565b5190565b60209181520190565b60200190565b61177790610794565b9052565b906117888160209361176e565b0190565b60200190565b906117af6117a96117a28461175b565b809361175f565b92611768565b905f5b8181106117bf5750505090565b9091926117d86117d2600192865161177b565b9461178c565b91019190916117b2565b939591946118336118286118479561181a61183d956118549c9a61180d60e08c01925f8d019061174e565b8a820360208c01526105fe565b9088820360408a01526105fe565b97606087019061083b565b60808501906112a7565b60a0830190610d71565b60c0818403910152611792565b90565b3461188e576118673660046105cd565b61188a611872613d5d565b93611881979597939193610512565b978897886117e2565b0390f35b610518565b346118c3576118bf6118ae6118a9366004610eb9565b613de7565b6118b6610512565b91829182610848565b0390f35b610518565b90565b6118df6118da6118e4926118c8565b610687565b610794565b90565b6118fb6a52b7d2dcc80cd2e40000006118cb565b90565b6119066118e7565b90565b34611939576119193660046105cd565b6119356119246118fe565b61192c610512565b91829182610848565b0390f35b610518565b3461196f5761196b61195a611954366004610dfb565b90613e18565b611962610512565b91829182610583565b0390f35b610518565b65ffffffffffff1690565b61198890611974565b9052565b919061199f905f6020850194019061197f565b565b346119d1576119b13660046105cd565b6119cd6119bc613e46565b6119c4610512565b9182918261198c565b0390f35b610518565b34611a06576119e63660046105cd565b611a026119f1613e5a565b6119f9610512565b9182918261062f565b0390f35b610518565b90565b611a22611a1d611a2792611a0b565b610687565b610794565b90565b611a3662015180611a0e565b90565b611a41611a2a565b90565b34611a7457611a543660046105cd565b611a70611a5f611a39565b611a67610512565b91829182610848565b0390f35b610518565b34611aa957611aa5611a94611a8f36600461081d565b613e70565b611a9c610512565b91829182610848565b0390f35b610518565b34611ade57611ada611ac9611ac436600461081d565b613ecb565b611ad1610512565b91829182610848565b0390f35b610518565b90565b611afa611af5611aff92611ae3565b610687565b610794565b90565b611b166a4a723dc6b40b8a9a000000611ae6565b90565b611b21611b02565b90565b34611b5457611b343660046105cd565b611b50611b3f611b19565b611b47610512565b91829182610848565b0390f35b610518565b34611b8857611b72611b6c3660046107ba565b9061404d565b611b7a610512565b80611b8481610913565b0390f35b610518565b9091606082840312611bc257611bbf611ba8845f8501610785565b93611bb681602086016107ab565b936040016107ab565b90565b61051c565b34611bf657611be0611bda366004611b8d565b916142d3565b611be8610512565b80611bf281610913565b0390f35b610518565b90565b5f1b90565b611c17611c12611c1c92611bfb565b611bfe565b610d2d565b90565b611c285f611c03565b90565b611c33611c1f565b90565b34611c6657611c463660046105cd565b611c62611c51611c2b565b611c59610512565b91829182610d7e565b0390f35b610518565b60018060a01b031690565b611c86906008611c8b93026109b4565b611c6b565b90565b90611c999154611c76565b90565b611ca860445f90611c8e565b90565b9190611cbe905f602085019401906106be565b565b34611cf057611cd03660046105cd565b611cec611cdb611c9c565b611ce3610512565b91829182611cab565b0390f35b610518565b34611d2557611d053660046105cd565b611d21611d106142e0565b611d18610512565b91829182610583565b0390f35b610518565b611d3390610765565b90565b611d3f81611d2a565b03611d4657565b5f80fd5b90503590611d5782611d36565b565b90602082820312611d7257611d6f915f01611d4a565b90565b61051c565b34611da557611d8f611d8a366004611d59565b614437565b611d97610512565b80611da181610913565b0390f35b610518565b34611dda57611dba3660046105cd565b611dd6611dc5614461565b611dcd610512565b91829182610848565b0390f35b610518565b90565b611df6611df1611dfb92611ddf565b610687565b610794565b90565b611e0a62278d00611de2565b90565b611e15611dfe565b90565b34611e4857611e283660046105cd565b611e44611e33611e0d565b611e3b610512565b91829182610848565b0390f35b610518565b34611e7e57611e7a611e69611e633660046107ba565b906144db565b611e71610512565b91829182610583565b0390f35b610518565b90565b611e9a611e95611e9f92611e83565b610687565b610794565b90565b611eb3670de0b6b3a7640000611e86565b90565b611ebe611ea2565b90565b34611ef157611ed13660046105cd565b611eed611edc611eb6565b611ee4610512565b91829182610848565b0390f35b610518565b50603090565b905090565b90565b60200190565b611f26611f20611f1983611ef6565b8094611efc565b91611f01565b5f915b838310611f365750505050565b611f4c611f46600192845161177b565b92611f04565b92019190611f29565b9190611f69905f6106008501940190611f0a565b565b34611f9b57611f7b3660046105cd565b611f97611f86614602565b611f8e610512565b91829182611f55565b0390f35b610518565b34611fd157611fcd611fbc611fb63660046107ba565b90614618565b611fc4610512565b91829182610848565b0390f35b610518565b61200b61201294612001606094989795611ff7608086019a5f87019061083b565b602085019061083b565b604083019061083b565b0190610576565b565b34612048576120243660046105cd565b61204461202f61462e565b9061203b949294610512565b94859485611fd6565b0390f35b610518565b3461207d5761207961206861206336600461081d565b614805565b612070610512565b91829182610848565b0390f35b610518565b346120b2576120923660046105cd565b6120ae61209d61481a565b6120a5610512565b91829182610848565b0390f35b610518565b346120e7576120e36120d26120cd36600461081d565b61482e565b6120da610512565b91829182610848565b0390f35b610518565b6120f581610e5c565b036120fc57565b5f80fd5b9050359061210d826120ec565b565b909160c08284031261216e57612127835f8401610785565b9261213581602085016107ab565b9261214382604083016107ab565b9261216b6121548460608501612100565b936121628160808601610d44565b9360a001610d44565b90565b61051c565b346121a85761219261218636600461210f565b949390939291926148b8565b61219a610512565b806121a481610913565b0390f35b610518565b60e081830312612218576121c3825f8301610785565b926121d18360208401610785565b926121df81604085016107ab565b926121ed82606083016107ab565b926122156121fe8460808501612100565b9361220c8160a08601610d44565b9360c001610d44565b90565b61051c565b346122525761223c6122303660046121ad565b95949094939193614a0c565b612244610512565b8061224e81610913565b0390f35b610518565b346122865761227061226a366004610dfb565b90614b2a565b612278610512565b8061228281610913565b0390f35b610518565b91906040838203126122b357806122a76122b0925f8601610785565b93602001610785565b90565b61051c565b346122e9576122e56122d46122ce36600461228b565b90614b4c565b6122dc610512565b91829182610848565b0390f35b610518565b7f6b9725f740f94b91b78060a1b17d1774656d381421a529ec98cdb013f4d9c25e90565b61231a6122ee565b90565b3461234d5761232d3660046105cd565b612349612338612312565b612340610512565b91829182610d7e565b0390f35b610518565b7f65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a90565b61237e612352565b90565b346123b1576123913660046105cd565b6123ad61239c612376565b6123a4610512565b91829182610d7e565b0390f35b610518565b6123bf81611549565b036123c657565b5f80fd5b905035906123d7826123b6565b565b919060408382031261240157806123f56123fe925f8601610785565b936020016123ca565b90565b61051c565b61240f90611974565b9052565b60018060d01b031690565b61242790612413565b9052565b9060208061244d936124435f8201515f860190612406565b015191019061241e565b565b9190612462905f6040850194019061242b565b565b346124955761249161248061247a3660046123d9565b90614bba565b612488610512565b9182918261244f565b0390f35b610518565b6124a660435f90610f37565b90565b346124d9576124b93660046105cd565b6124d56124c461249a565b6124cc610512565b91829182610848565b0390f35b610518565b7fcce296b040332a080e6df13515a3ec2869e21cd20f7344af0987ddb938d8bd2190565b61250a6124de565b90565b3461253d5761251d3660046105cd565b612539612528612502565b612530610512565b91829182610d7e565b0390f35b610518565b5f80fd5b5f90565b634e487b7160e01b5f52601160045260245ffd5b61256a61257091612413565b91612413565b019060018060d01b03821161258157565b61254a565b9061259991612593612546565b5061255e565b90565b6125a86125ae91612413565b91612413565b90039060018060d01b0382116125c057565b61254a565b906125d8916125d2612546565b5061259c565b90565b5f90565b6125e76125db565b50806126026125fc637965db0b60e01b610524565b91610524565b1490811561260f575b5090565b6126199150614bd0565b5f61260b565b606090565b60209181520190565b5f5260205f2090565b905f929180549061265061264983610b85565b8094612624565b916001811690815f146126a7575060011461266b575b505050565b612678919293945061262d565b915f925b81841061268f57505001905f8080612666565b6001816020929593955484860152019101929061267c565b92949550505060ff19168252151560200201905f8080612666565b906126cc91612636565b90565b906126ef6126e8926126df610512565b938480926126c2565b0383610c6e565b565b6126fa906126cf565b90565b61270561261f565b5061271060036126f1565b90565b5f90565b606090565b61272861272d91611101565b611c6b565b90565b61273a905461271c565b90565b61274690610c97565b90565b612751612713565b5061275a612717565b506127656044612730565b90612770604561273d565b90565b6127909161277f6125db565b50612788614bf6565b919091614c03565b600190565b5f90565b5f6127b16127b7926127a9612795565b50600d6110eb565b0161111a565b90565b906127d4916127cf6127ca6124de565b614c13565b612a34565b565b5090565b601f602091010490565b1b90565b919060086128039102916127fd5f19846127e4565b926127e4565b9181191691161790565b61282161281c61282692610794565b610687565b610794565b90565b90565b919061284261283d61284a9361280d565b612829565b9083546127e8565b9055565b6128609161285a612795565b9161282c565b565b5b81811061286e575050565b8061287b5f60019361284e565b01612863565b9190601f8111612891575b505050565b61289d6128c293610bb8565b9060206128a9846127da565b830193106128ca575b6128bb906127da565b0190612862565b5f808061288c565b91506128bb819290506128b2565b906128e8905f19906008026109b4565b191690565b816128f7916128d8565b906002021790565b9161290a90826127d6565b9067ffffffffffffffff82116129c95761292e826129288554610b85565b85612881565b5f90601f831160011461296157918091612950935f92612955575b50506128ed565b90555b565b90915001355f80612949565b601f1983169161297085610bb8565b925f5b8181106129b157509160029391856001969410612997575b50505002019055612953565b6129a7910135601f8416906128d8565b90555f808061298b565b91936020600181928787013581550195019201612973565b610c5a565b906129d992916128ff565b565b90825f939282370152565b9190612a00816129f981612a05956106cf565b80956129db565b6105f4565b0190565b91612a23612a31949260408501908582035f8701526106d8565b9260208185039101526129e6565b90565b90612a3f604561273d565b612a4c83839060456129ce565b919091612a857fb9a2088426f03b30a81c06428094fbfa9e2692739b3241af6b9ab1da4b5546be93612a7c610512565b93849384612a09565b0390a1565b90612a94916127ba565b565b612a9e612795565b50612aa9600261111a565b90565b612abc612ab76122ee565b614c13565b612ac4612b85565b565b612ada612ad5612adf92611bfb565b610687565b610794565b90565b612af6612af1612afb92611bfb565b610687565b61067c565b90565b612b0790612ae2565b90565b90612b1660ff91611bfe565b9181191691161790565b612b2990610571565b90565b90565b90612b44612b3f612b4b92612b20565b612b2c565b8254612b0a565b9055565b90612b5b5f1991611bfe565b9181191691161790565b90612b7a612b75612b819261280d565b612829565b8254612b4f565b9055565b612b8f604161111a565b612ba1612b9b5f612ac6565b91610794565b03612c4657612bb8612bb36044612730565b6106b2565b612bd2612bcc612bc75f612afe565b610765565b91610765565b14612c2a57612be360016040612b2f565b612bee426041612b65565b42612c257f1194b034cfa9ab5807494a1d5c667d8b0e6e97f38888742aa3871a322034116091612c1c610512565b91829182610848565b0390a1565b5f633b0a48bd60e11b815280612c4260048201610913565b0390fd5b5f6338e93dbd60e11b815280612c5e60048201610913565b0390fd5b612c6a612aac565b565b91612c9692612c796125db565b50612c8e612c85614bf6565b82908491614c67565b919091614cf3565b600190565b612ca4906106a6565b90565b5f80fd5b60e01b90565b90505190612cbe82610797565b565b90602082820312612cd957612cd6915f01612cb1565b90565b61051c565b612ce6610512565b3d5f823e3d90fd5b612cfd612d0391939293610794565b92610794565b8203918211612d0e57565b61254a565b90565b612d2a612d25612d2f92612d13565b610687565b610794565b90565b612d41612d4791939293610794565b92610794565b91612d53838202610794565b928184041490151715612d6257565b61254a565b634e487b7160e01b5f52601260045260245ffd5b612d87612d8d91610794565b91610794565b908115612d98570490565b612d67565b612da5612795565b91612dae612795565b91612dc55f612dbf600d84906110eb565b0161111a565b90612ddd6002612dd7600d84906110eb565b0161111a565b91612e166020612dec30612c9b565b63651fd26890612e0b8692612dff610512565b95869485938493612cab565b8352600483016112b4565b03915afa908115612f6f57612e61916020915f91612f42575b5093612e3a30612c9b565b612e5663998955d3612e4a610512565b95869485938493612cab565b8352600483016112b4565b03915afa908115612f3d575f91612f0f575b509181612e88612e825f612ac6565b91610794565b11612ede575b505081612ea3612e9d5f612ac6565b91610794565b11612ead575b5050565b612ed6929350612ec0612ed19183612cee565b612ecb612710612d16565b90612d32565b612d7b565b905f80612ea9565b612f07929650612ef1612f029183612cee565b612efc612710612d16565b90612d32565b612d7b565b935f80612e8e565b612f30915060203d8111612f36575b612f288183610c6e565b810190612cc0565b5f612e73565b503d612f1e565b612cde565b612f629150823d8111612f68575b612f5a8183610c6e565b810190612cc0565b5f612e2f565b503d612f50565b612cde565b5f90565b612f8190610d2d565b90565b90612f8e90612f78565b5f5260205260405f2090565b90565b612fa9612fae91611101565b612f9a565b90565b612fbb9054612f9d565b90565b6001612fd7612fdd92612fcf612f74565b506005612f84565b01612fb1565b90565b612fe8614d90565b612ff0612ff2565b565b612ffa614de6565b61300261300c565b61300a614e4b565b565b61301c6130176122ee565b614c13565b613024613156565b565b61303261303791611101565b6109b8565b90565b6130449054613026565b90565b60016130539101610794565b90565b61306561306b91939293610794565b92610794565b820180921161307657565b61254a565b613084906106a6565b90565b5f91031261309157565b61051c565b905f92918054906130b06130a983610b85565b80946106cf565b916001811690815f1461310757506001146130cb575b505050565b6130d89192939450610bb8565b915f925b8184106130ef57505001905f80806130c6565b600181602092959395548486015201910192906130dc565b92949550505060ff19168252151560200201905f80806130c6565b61314661315394929361313c60608401955f8501906112a7565b602083019061083b565b6040818403910152613096565b90565b613169613163604061303a565b15610571565b6134a0576131756142e0565b6134845761319e6131904261318a604161111a565b90612cee565b613198611dfe565b90612d7b565b426131c96131c36131be6131b0614461565b6131b8610b10565b90612cee565b610794565b91610794565b10613468576131e2906131dc604261111a565b90612cee565b908161321061320a6132056131f56113ba565b6131ff604261111a565b90612cee565b610794565b91610794565b11613445575b61321f5f612ac6565b906132295f612ac6565b915b8261323e61323886610794565b91610794565b10156132855761327961327f9161327361326d6010613267613260604261111a565b8990613056565b90610ef4565b90610f37565b90613056565b92613047565b9161322b565b91509161329c613295604361111a565b8390613056565b6132b56132af6132aa61148e565b610794565b91610794565b11613429576132d06132d7916132cb604261111a565b613056565b6042612b65565b6132f46132ed826132e8604361111a565b613056565b6043612b65565b6133076133003061307b565b8290614e5f565b61332c6133133061307b565b6133256133206044612730565b6106b2565b8391614c03565b61333e6133396044612730565b6106b2565b6318b68b8c61334c3061307b565b8392604592813b15613424575f61337691613381829661336a610512565b98899788968795612cab565b855260048501613122565b03925af1801561341f576133f3575b5061339b604261111a565b906133ae6133a96044612730565b6106b2565b906133d97f34b73d0c96e9ff4d5311434817c8ecc930e7d2782c5bde2e79dc44b0596755bb926110df565b926133ee6133e5610512565b92839283610a98565b0390a2565b613412905f3d8111613418575b61340a8183610c6e565b810190613087565b5f613390565b503d613400565b612cde565b612ca7565b5f6323064ebd60e01b81528061344160048201610913565b0390fd5b90506134626134526113ba565b61345c604261111a565b90612cee565b90613216565b5f633d53c75360e01b81528061348060048201610913565b0390fd5b5f631155624b60e21b81528061349c60048201610913565b0390fd5b5f6319afc99d60e21b8152806134b860048201610913565b0390fd5b6134c4612fe0565b565b906134e1916134dc6134d782612fbe565b614c13565b6134e3565b565b906134ed91614ebd565b50565b906134fa916134c6565b565b5f90565b90565b61351761351261351c92613500565b610687565b610e5c565b90565b6135276134fc565b506135326012613503565b90565b6135456135406122ee565b614c13565b61354d61354f565b565b613559604161111a565b61356b6135655f612ac6565b91610794565b146135b45761357c60016040612b2f565b7f4a792a0be42b5672faa40129fc6469072490775ca8d3c34e852d4d55d3a735a96135a5610512565b806135af81610913565b0390a1565b5f638f98404160e01b8152806135cc60048201610913565b0390fd5b6135d8613535565b565b6135e2612f74565b506135eb614f69565b90565b90806136096136036135fe614bf6565b610765565b91610765565b0361361a5761361791615023565b50565b5f63334bd91960e11b81528061363260048201610913565b0390fd5b90613640906110df565b5f5260205260405f2090565b90565b61366361365e61366892612413565b610687565b610794565b90565b6136a29161369761369161368c61369d94613684612795565b50600a613636565b61364c565b91615104565b906151fa565b61364f565b90565b6136b56136b0611c1f565b614c13565b6136bd6136bf565b565b6136c7615381565b565b6136d16136a5565b565b906136e5916136e0614de6565b6136ef565b6136ed614e4b565b565b908161370b6137056137005f612afe565b610765565b91610765565b1461380a578061372361371d5f612ac6565b91610794565b146137ee5761374561373f61373a600e33906114e5565b61303a565b15610571565b6137d2576137523361538e565b6137696001613763600d33906110eb565b0161111a565b61377b61377583610794565b91610794565b106137b6576137b4916137af826137a96001613799600d33906110eb565b01916137a48361111a565b612cee565b90612b65565b614e5f565b565b5f631c959ed960e21b8152806137ce60048201610913565b0390fd5b5f634417760960e11b8152806137ea60048201610913565b0390fd5b5f631f2a200560e01b81528061380660048201610913565b0390fd5b5f63d92e233d60e01b81528061382260048201610913565b0390fd5b90613830916136d3565b565b61383a612795565b5061385661384661148e565b613850604361111a565b90612cee565b90565b9061386c613865610512565b9283610c6e565b565b67ffffffffffffffff811161388c576138886020916105f4565b0190565b610c5a565b906138a361389e8361386e565b613859565b918252565b5f7f6d6f64653d626c6f636b6e756d6265722666726f6d3d64656661756c74000000910152565b6138d9601d613891565b906138e6602083016138a8565b565b6138f06138cf565b90565b6138fb61261f565b50613904613e46565b61391d61391761391261555d565b611974565b91611974565b0361392d5761392a6138e8565b90565b5f6301bfc1c560e61b81528061394560048201610913565b0390fd5b5f90565b90613957906110df565b5f5260205260405f2090565b60018060a01b031690565b61397a61397f91611101565b613963565b90565b61398c905461396e565b90565b6139a66139ab9161399e613949565b50600961394d565b613982565b90565b6139b66125db565b506139c1604161111a565b6139d36139cd5f612ac6565b91610794565b1190565b6139e8906139e3614bf6565b615595565b565b6139f26125db565b506139fd600f61303a565b90565b613a5790613a0c612795565b50613a246001613a1e600d84906110eb565b0161111a565b90613a516004613a4b613a435f613a3d600d87906110eb565b0161111a565b93600d6110eb565b0161111a565b91615620565b90565b613a6a613a65612352565b614c13565b613a72613a74565b565b613a7f5f6040612b2f565b7f73a5fc60aafeec8f139af22d98e62140e2ce914d1f155c692b427757c3e4014c613aa8610512565b80613ab281610913565b0390a1565b613abf613a5a565b565b5f90565b613ad790613ad1613ac1565b506156cd565b90565b90613ae4906110df565b5f5260205260405f2090565b613b06613b0b91613aff612795565b505f613ada565b61111a565b90565b613b25613b2a91613b1d6125db565b50600e6114e5565b61303a565b90565b90613b366125db565b50613b3f612795565b50613b48612795565b50613b51612795565b50613b5a612795565b50613b6f613b6a600e84906114e5565b61303a565b91613b865f613b80600d84906110eb565b0161111a565b91613b9e6002613b98600d85906110eb565b0161111a565b90613bd76020613bad30612c9b565b63651fd26890613bcc8792613bc0610512565b95869485938493612cab565b8352600483016112b4565b03915afa908115613c9857613c22916020915f91613c6b575b5094613bfb30612c9b565b613c1763998955d3613c0b610512565b95869485938493612cab565b8352600483016112b4565b03915afa908115613c66575f91613c38575b5090565b613c59915060203d8111613c5f575b613c518183610c6e565b810190612cc0565b5f613c34565b503d613c47565b612cde565b613c8b9150823d8111613c91575b613c838183610c6e565b810190612cc0565b5f613bf0565b503d613c79565b612cde565b613caf90613ca9612795565b506156fc565b90565b613cc2613cbd612352565b614c13565b613cca613ccc565b565b613cd4615772565b565b613cde613cb2565b565b5f90565b606090565b613cf2906106a6565b90565b67ffffffffffffffff8111613d0d5760208091020190565b610c5a565b90613d24613d1f83613cf5565b613859565b918252565b369037565b90613d53613d3b83613d12565b92602080613d498693613cf5565b9201910390613d29565b565b600f60f81b90565b613d65613ce0565b50613d6e61261f565b50613d7761261f565b50613d80612795565b50613d89613949565b50613d92612f74565b50613d9b613ce4565b50613da461577f565b90613dad6157bf565b904690613db930613ce9565b90613dc35f611c03565b90613dd5613dd05f612ac6565b613d2e565b90613dde613d55565b96959493929190565b613e10613e1591613df6612795565b50613e0a613e04600b61364c565b91615104565b906151fa565b61364f565b90565b613e3f915f613e34613e3a93613e2c6125db565b506005612f84565b016114e5565b61303a565b90565b5f90565b613e4e613e42565b50613e5761555d565b90565b613e6261261f565b50613e6d60046126f1565b90565b613ec890613e7c612795565b50613e946003613e8e600d84906110eb565b0161111a565b90613ec26004613ebc613eb46002613eae600d87906110eb565b0161111a565b93600d6110eb565b0161111a565b91615620565b90565b613ef2613eed613ee8613ef793613ee0612795565b50600a613636565b61364c565b6157ff565b61364f565b90565b90613f0c91613f07614de6565b613f16565b613f14614e4b565b565b9081613f32613f2c613f275f612afe565b610765565b91610765565b146140315780613f4a613f445f612ac6565b91610794565b1461401557613f6c613f66613f61600e33906114e5565b61303a565b15610571565b613ff957613f793361538e565b613f906003613f8a600d33906110eb565b0161111a565b613fa2613f9c83610794565b91610794565b10613fdd57613fdb91613fd682613fd06003613fc0600d33906110eb565b0191613fcb8361111a565b612cee565b90612b65565b615874565b565b5f631c959ed960e21b815280613ff560048201610913565b0390fd5b5f634417760960e11b81528061401160048201610913565b0390fd5b5f631f2a200560e01b81528061402d60048201610913565b0390fd5b5f63d92e233d60e01b81528061404960048201610913565b0390fd5b9061405791613efa565b565b90614074929161406f61406a6124de565b614c13565b614076565b565b8061409161408b6140865f612afe565b610765565b91610765565b146142b7576140b36140ad6140a8600e84906114e5565b61303a565b15610571565b8061427c575b614220575b816140d16140cb5f612ac6565b91610794565b1480614206575b806141ec575b614191575b6140ec8161538e565b614103825f6140fd600d85906110eb565b01612b65565b61411b836002614115600d85906110eb565b01612b65565b61413382600161412d600d85906110eb565b01612b65565b61414b836003614145600d85906110eb565b01612b65565b90916141777faa807d0abf30d91968c7478c66b6d82521a106af13eda036e2036da9af168958926110df565b9261418c614183610512565b92839283610a98565b0390a2565b6141a65f6141a1600e84906114e5565b612b2f565b806141d17f02c2f0ba15b03f88b18f4832609a18cf35fc6b3f4546a9992076d7453d1334a8916110df565b906141da610512565b806141e481610913565b0390a26140e3565b506142016141fc600e83906114e5565b61303a565b6140de565b508261421a6142145f612ac6565b91610794565b146140d8565b6142366001614231600e84906114e5565b612b2f565b806142617f6cf28439a2daab1b265097227212a5b71e0a76f9ed85e3f815b5a6c3e218eb7f916110df565b9061426a610512565b8061427481610913565b0390a26140be565b508161429061428a5f612ac6565b91610794565b11801561429d575b6140b9565b50826142b16142ab5f612ac6565b91610794565b11614298565b5f63d92e233d60e01b8152806142cf60048201610913565b0390fd5b906142de9291614059565b565b6142e86125db565b506142f3604261111a565b61430c6143066143016113ba565b610794565b91610794565b101590565b61432a906143256143206124de565b614c13565b614382565b565b9061433d60018060a01b0391611bfe565b9181191691161790565b6143509061068a565b90565b61435c90614347565b90565b90565b9061437761437261437e92614353565b61435f565b825461432c565b9055565b61438b816106b2565b6143a561439f61439a5f612afe565b610765565b91610765565b1461441b576143d06143ca6143ba6044612730565b6143c5846044614362565b6106b2565b916106b2565b6144036143fd7f07015b6a9f05913148fd5faddf2acc9708f305937f3072ca2b4b46faa5d0898b936110df565b916110df565b9161440c610512565b8061441681610913565b0390a3565b5f63d92e233d60e01b81528061443360048201610913565b0390fd5b61444090614311565b565b90565b61445961445461445e92614442565b610687565b610794565b90565b614469612795565b50614474604161111a565b6144866144805f612ac6565b91610794565b146144cf576144cc614498604161111a565b6144c66144b86144a8604261111a565b6144b26001614445565b90613056565b6144c0611dfe565b90612d32565b90613056565b90565b6144d85f612ac6565b90565b6144f8916144e76125db565b506144f0614bf6565b919091614cf3565b600190565b67ffffffffffffffff81116145125760200290565b610c5a565b614523614528916144fd565b613859565b90565b9061454961453883614517565b9261454384916144fd565b90613d29565b565b614555603061452b565b90565b905090565b6145679054611106565b90565b60010190565b61458c61458661457f83610eeb565b8094614558565b91610ef1565b5f915b83831061459c5750505050565b6145b96145b36001926145ae8561455d565b61177b565b9261456a565b9201919061458f565b906145d08161060093614570565b0190565b906145f46145ed926145e4610512565b938480926145c2565b0383610c6e565b565b6145ff906145d4565b90565b61460a61454b565b5061461560106145f6565b90565b9061462b91614625612795565b5061366b565b90565b614636612795565b5061463f612795565b50614648612795565b506146516125db565b5061465c604161111a565b61466e6146685f612ac6565b91610794565b146147df5761469861468a42614684604161111a565b90612cee565b614692611dfe565b90612d7b565b906146da6146a6604161111a565b6146d46146c66146b6604261111a565b6146c06001614445565b90613056565b6146ce611dfe565b90612d32565b90613056565b6146e4604261111a565b6146fd6146f76146f26113ba565b610794565b91610794565b105f146147d15761472261471c6010614716604261111a565b90610ef4565b90610f37565b5b9261472e604061303a565b90816147ad575b5080614783575b80614757575b9161474d604261111a565b9193929193929190565b504261477c6147766147718461476b610b10565b90612cee565b610794565b91610794565b1015614742565b5061478e604261111a565b6147a76147a161479c6113ba565b610794565b91610794565b1061473c565b90506147ca6147c46147bf604261111a565b610794565b91610794565b115f614735565b6147da5f612ac6565b614723565b5f905f915f916148016147fb6147f55f94612ac6565b95612ac6565b93612ac6565b9190565b61481790614811612795565b50613ecb565b90565b614822612795565b5061482b612a96565b90565b600261484761484d9261483f612795565b50600d6110eb565b0161111a565b90565b7fe48329057bfd03d55e49b547132e39cffd9c1820ad7b9d4c5307691425d15adf90565b6148a96148b09461489f606094989795614895608086019a5f870190610d71565b60208501906112a7565b604083019061083b565b019061083b565b565b60200190565b93959490929195426148d26148cc89610794565b91610794565b1161494b579161493d9161494493614934614949989961491c6148f3614850565b61490d8b938b614901610512565b95869460208601614874565b60208201810382520382610c6e565b61492e614928826106cb565b916148b2565b206158d3565b929091926158f0565b918261593a565b615595565b565b614966875f918291632341d78760e11b835260048301610848565b0390fd5b7f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c990565b91946149d66149e0929897956149cc60a0966149c26149e79a6149b860c08a019e5f8b0190610d71565b60208901906112a7565b60408701906112a7565b606085019061083b565b608083019061083b565b019061083b565b565b916020614a0a929493614a0360408201965f8301906112a7565b01906112a7565b565b969591939294909442614a27614a2183610794565b91610794565b11614ae15790614a90614a99949392614a78614a4161496a565b614a698c80948c91614a538d9161597d565b9192614a5d610512565b9788966020880161498e565b60208201810382520382610c6e565b614a8a614a84826106cb565b916148b2565b206158d3565b929091926158f0565b80614aac614aa687610765565b91610765565b03614ac15750614abf9293919091614c03565b565b8490614add5f9283926325c0072360e11b8452600484016149e9565b0390fd5b614afc905f91829163313c898160e11b835260048301610848565b0390fd5b90614b1b91614b16614b1182612fbe565b614c13565b614b1d565b565b90614b2791615023565b50565b90614b3491614b00565b565b90614b40906110df565b5f5260205260405f2090565b614b7191614b67614b6c92614b5f612795565b506001614b36565b613ada565b61111a565b90565b614b7e6040613859565b90565b5f90565b5f90565b614b91614b74565b9060208083614b9e614b81565b815201614ba9614b85565b81525050565b614bb7614b89565b90565b90614bcd91614bc7614baf565b506159b0565b90565b614bd86125db565b50614bf2614bec6301ffc9a760e01b610524565b91610524565b1490565b614bfe613949565b503390565b91614c1192916001926159d8565b565b614c2590614c1f614bf6565b90615b0a565b565b604090614c50614c579496959396614c4660608401985f8501906112a7565b602083019061083b565b019061083b565b565b90614c649103610794565b90565b929192614c75818390614b4c565b9081614c8a614c845f19610794565b91610794565b10614c97575b5050509050565b81614caa614ca487610794565b91610794565b10614cd057614cc79394614cbf919392614c59565b905f926159d8565b805f8080614c90565b50614cef849291925f938493637dc7a0d960e11b855260048501614c27565b0390fd5b9182614d0f614d09614d045f612afe565b610765565b91610765565b14614d695781614d2f614d29614d245f612afe565b610765565b91610765565b14614d4257614d4092919091615b45565b565b614d65614d4e5f612afe565b5f91829163ec442f0560e01b8352600483016112b4565b0390fd5b614d8c614d755f612afe565b5f918291634b637e8f60e11b8352600483016112b4565b0390fd5b614d986139ea565b614d9e57565b5f63d93c066560e01b815280614db660048201610913565b0390fd5b90565b614dd1614dcc614dd692614dba565b610687565b610794565b90565b614de36002614dbd565b90565b614df0600c61111a565b614e09614e03614dfe614dd9565b610794565b91610794565b14614e2257614e20614e19614dd9565b600c612b65565b565b5f633ee5aeb560e01b815280614e3a60048201610913565b0390fd5b614e486001614445565b90565b614e5d614e56614e3e565b600c612b65565b565b80614e7a614e74614e6f5f612afe565b610765565b91610765565b14614e9657614e9491614e8c5f612afe565b919091615b45565b565b614eb9614ea25f612afe565b5f91829163ec442f0560e01b8352600483016112b4565b0390fd5b614ec56125db565b50614eda614ed4828490613e18565b15610571565b5f14614f6357614f026001614efd5f614ef560058690612f84565b0185906114e5565b612b2f565b90614f0b614bf6565b90614f48614f42614f3c7f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d95612f78565b926110df565b926110df565b92614f51610512565b80614f5b81610913565b0390a4600190565b50505f90565b614f71612f74565b50614f7b30613ce9565b614fad614fa77f0000000000000000000000000000000000000000000000000000000000000000610765565b91610765565b1480614fe9575b5f14614fde577f000000000000000000000000000000000000000000000000000000000000000090565b614fe6615bc5565b90565b504661501d6150177f0000000000000000000000000000000000000000000000000000000000000000610794565b91610794565b14614fb4565b61502b6125db565b50615037818390613e18565b5f146150bf5761505e5f6150595f61505160058690612f84565b0185906114e5565b612b2f565b90615067614bf6565b906150a461509e6150987ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b95612f78565b926110df565b926110df565b926150ad610512565b806150b781610913565b0390a4600190565b50505f90565b6150d96150d46150de92611974565b610687565b610794565b90565b9160206151029294936150fb60408201965f83019061083b565b019061197f565b565b61510c613e42565b50615115613e46565b81615128615122836150c5565b91610794565b101561513b575061513890615ccb565b90565b906151565f928392637669fc0f60e11b8452600484016150e1565b0390fd5b5490565b90565b61517561517061517a9261515e565b610687565b610794565b90565b90565b65ffffffffffff1690565b61519761519c91611101565b615180565b90565b6151a9905461518b565b90565b60301c90565b60018060d01b031690565b6151c96151ce916151ac565b6151b2565b90565b6151db90546151bd565b90565b6151f26151ed6151f792611bfb565b610687565b612413565b90565b9061524e90615207612546565b506152135f840161515a565b61521c5f612ac6565b90808061523261522c6005615161565b91610794565b116152af575b50906152495f86019391929361517d565b616303565b8061526161525b5f612ac6565b91610794565b145f146152775750506152735f6151de565b5b90565b6152a45f9161529f615299846152aa9601926152936001614445565b90612cee565b9161517d565b6162f9565b016151d1565b615274565b806152bd6152c39291615f8e565b90612cee565b90836152f56152ef6152ea5f6152e4818c016152df899161517d565b6162f9565b0161519f565b611974565b91611974565b105f146153065750905b905f615238565b915061531c906153166001614445565b90613056565b6152ff565b615329616392565b615331615333565b565b61533e5f600f612b2f565b615346614bf6565b61537c7f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa91615373610512565b918291826112b4565b0390a1565b615389615321565b565b90565b61539c6153a191600d6110eb565b61538b565b6153ad6004820161111a565b6153bf6153b95f612ac6565b91610794565b1461554d5761543b906153de426153d86004840161111a565b90612cee565b806153f86153f26153ed611a2a565b610794565b91610794565b10155f1461543d575061541861540f5f830161111a565b60018301612b65565b6154306154276002830161111a565b60038301612b65565b5b6004429101612b65565b565b8061545061544a5f612ac6565b91610794565b1161545c575b50615431565b61553e61552c6155479261551b6155126155016154ef6154b16154805f8b0161111a565b6154928761548c611ea2565b90612d32565b6154ab61549d611a2a565b6154a5611ea2565b90612d32565b9161641a565b946154d06154c160028c0161111a565b916154ca611ea2565b90612d32565b6154e96154db611a2a565b6154e3611ea2565b90612d32565b9161641a565b936154fc60018a0161111a565b613056565b61550c5f890161111a565b90616619565b60018701612b65565b6155276003860161111a565b613056565b6155386002850161111a565b90616619565b60038301612b65565b5f615456565b61555b906004429101612b65565b565b615565613e42565b5061556f43615ccb565b90565b90565b9061558a615585615591926110df565b615572565b825461432c565b9055565b9061561e916156186155a68261398f565b6155bb846155b66009869061394d565b615575565b828185906155fb6155f56155ef7f3134e8a2e6d97e929a7e54011ea5485d7d196dd5f0ba4d4ef95803e8e3fc257f956110df565b926110df565b926110df565b92615604610512565b8061560e81610913565b0390a49291616645565b9161665d565b565b909161562a612795565b508061563e6156385f612ac6565b91610794565b146156be5761564d9042612cee565b8061566761566161565c611a2a565b610794565b91610794565b10156156b95782916156ab6156b19261568c6156b69691615686611ea2565b90612d32565b6156a5615697611a2a565b61569f611ea2565b90612d32565b9161641a565b90613056565b616619565b90565b505090565b5050506156ca5f612ac6565b90565b6156f46156ef6156ea6156f9936156e2613ac1565b50600a613636565b61364c565b61680b565b61688a565b90565b61570e90615708612795565b506168db565b90565b615719614d90565b615721615723565b565b61572f6001600f612b2f565b615737614bf6565b61576d7f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a25891615764610512565b918291826112b4565b0390a1565b61577a615711565b565b90565b61578761261f565b506157bc7f00000000000000000000000000000000000000000000000000000000000000006157b6600661577c565b906169f6565b90565b6157c761261f565b506157fc7f00000000000000000000000000000000000000000000000000000000000000006157f6600761577c565b906169f6565b90565b615807612546565b506158135f820161515a565b806158266158205f612ac6565b91610794565b145f1461583c5750506158385f6151de565b5b90565b6158695f9161586461585e8461586f9601926158586001614445565b90612cee565b9161517d565b6162f9565b016151d1565b615839565b908161589061588a6158855f612afe565b610765565b91610765565b146158ac576158aa91906158a35f612afe565b9091615b45565b565b6158cf6158b85f612afe565b5f918291634b637e8f60e11b8352600483016112b4565b0390fd5b6158ed906158df612f74565b506158e8614f69565b616a44565b90565b9261590b9261591494615901613949565b5092909192616afa565b90929192616c25565b90565b91602061593892949361593160408201965f8301906112a7565b019061083b565b565b6159438161597d565b9161595661595084610794565b91610794565b0361595f575050565b6159795f9283926301d4b62360e61b845260048401615917565b0390fd5b61599190615989612795565b506008613ada565b6159ad61599d8261111a565b916159a783613047565b90612b65565b90565b906159d06159cb6159d5936159c3614baf565b50600a613636565b61364c565b616d87565b90565b9092816159f56159ef6159ea5f612afe565b610765565b91610765565b14615ac05783615a15615a0f615a0a5f612afe565b610765565b91610765565b14615a9957615a3983615a34615a2d60018690614b36565b8790613ada565b612b65565b615a43575b505050565b919091615a8e615a7c615a767f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925936110df565b936110df565b93615a85610512565b91829182610848565b0390a35f8080615a3e565b615abc615aa55f612afe565b5f918291634a1406b160e11b8352600483016112b4565b0390fd5b615ae3615acc5f612afe565b5f91829163e602df0560e01b8352600483016112b4565b0390fd5b916020615b08929493615b0160408201965f8301906112a7565b0190610d71565b565b90615b1f615b19838390613e18565b15610571565b615b27575050565b615b415f92839263e2517d3f60e01b845260048401615ae7565b0390fd5b91615b5292919091616da8565b565b7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f90565b90959492615bc394615bb2615bbc92615ba8608096615b9e60a088019c5f890190610d71565b6020870190610d71565b6040850190610d71565b606083019061083b565b01906112a7565b565b615bcd612f74565b50615bd6615b54565b615c4d7f000000000000000000000000000000000000000000000000000000000000000091615c3e7f000000000000000000000000000000000000000000000000000000000000000046615c2930613ce9565b91615c32610512565b96879560208701615b78565b60208201810382520382610c6e565b615c5f615c59826106cb565b916148b2565b2090565b615c77615c72615c7c9261139b565b610687565b610e5c565b90565b615c8890615c63565b9052565b916020615cad929493615ca660408201965f830190615c7f565b019061083b565b565b615cc3615cbe615cc892610794565b610687565b611974565b90565b615cd3613e42565b5080615ced615ce765ffffffffffff6150c5565b91610794565b11615cfe57615cfb90615caf565b90565b6030615d1a5f9283926306dfcc6560e41b845260048401615c8c565b0390fd5b90565b615d35615d30615d3a92615d1e565b610687565b610794565b90565b90565b615d54615d4f615d5992615d3d565b610687565b610e5c565b90565b615d7b90615d75615d6f615d8094610e5c565b91610794565b906109b4565b610794565b90565b90565b615d9a615d95615d9f92615d83565b610687565b610e5c565b90565b615dc190615dbb615db5615dc694610e5c565b91610794565b906127e4565b610794565b90565b90565b615de0615ddb615de592615dc9565b610687565b610794565b90565b90565b615dff615dfa615e0492615de8565b610687565b610e5c565b90565b90565b615e1e615e19615e2392615e07565b610687565b610794565b90565b90565b615e3d615e38615e4292615e26565b610687565b610e5c565b90565b90565b615e5c615e57615e6192615e45565b610687565b610794565b90565b90565b615e7b615e76615e8092615e64565b610687565b610e5c565b90565b90565b615e9a615e95615e9f92615e83565b610687565b610794565b90565b90565b615eb9615eb4615ebe92615ea2565b610687565b610e5c565b90565b615ed5615ed0615eda92615e26565b610687565b610794565b90565b615ef1615eec615ef692614dba565b610687565b610e5c565b90565b615f0d615f08615f1292615ea2565b610687565b610794565b90565b615f29615f24615f2e92614442565b610687565b610e5c565b90565b90565b615f48615f43615f4d92615f31565b610687565b610794565b90565b90615f5b9102610794565b90565b615f6a615f7091610794565b91610794565b908115615f7b570490565b612d67565b90615f8b9101610794565b90565b615f96612795565b5080615fab615fa56001614445565b91610794565b11156162f657806161c061619d61618d61617d61616d61615d61614d61613d61612d61611d61610d8b6161076161006161c69f6160e06160d06160f092615ff26001614445565b908061600a616004600160801b615d21565b91610794565b10156162c8575b8061602d61602768010000000000000000615dcc565b91610794565b101561629a575b8061604c616046640100000000615e0a565b91610794565b101561626c575b8061606961606362010000615e48565b91610794565b101561623e575b8061608561607f610100615e86565b91610794565b1015616210575b806160a061609a6010615ec1565b91610794565b10156161e2575b6160ba6160b46004615ef9565b91610794565b10156161c9575b6160cb6003615f34565b615f50565b6160da6001615f15565b90615d5c565b6160ea8186615f5e565b90615f80565b6160fa6001615f15565b90615d5c565b8092615f5e565b90615f80565b6161176001615f15565b90615d5c565b616127818c615f5e565b90615f80565b6161376001615f15565b90615d5c565b616147818a615f5e565b90615f80565b6161576001615f15565b90615d5c565b6161678188615f5e565b90615f80565b6161776001615f15565b90615d5c565b6161878186615f5e565b90615f80565b6161976001615f15565b90615d5c565b916161ba6161b46161af858094615f5e565b610794565b91610794565b11616e38565b90614c59565b90565b6161dd906161d76001615f15565b90615da2565b6160c1565b6161f961620a916161f36004615ea5565b90615d5c565b916162046002615edd565b90615da2565b906160a7565b616227616238916162216008615e67565b90615d5c565b916162326004615ea5565b90615da2565b9061608c565b6162556162669161624f6010615e29565b90615d5c565b916162606008615e67565b90615da2565b90616070565b6162836162949161627d6020615deb565b90615d5c565b9161628e6010615e29565b90615da2565b90616053565b6162b16162c2916162ab6040615d86565b90615d5c565b916162bc6020615deb565b90615da2565b90616034565b6162df6162f0916162d96080615d40565b90615d5c565b916162ea6040615d86565b90615da2565b90616011565b90565b5f5260205f200190565b9391909261630f612795565b505b8161632461631e83610794565b91610794565b101561638a57616335828290616e46565b9061634b5f6163458885906162f9565b0161519f565b61635d61635787611974565b91611974565b115f1461636d5750915b91616311565b9291506163849061637e6001614445565b90613056565b90616367565b925050915090565b6163a361639d6139ea565b15610571565b6163a957565b5f638dfc202b60e01b8152806163c160048201610913565b0390fd5b6163d96163d46163de92613500565b610687565b610794565b90565b6163eb60126163c5565b90565b90565b61640561640061640a926163ee565b610687565b610794565b90565b61641760116163f1565b90565b929192616425612795565b50616431818390615f50565b9161643a612795565b505f1981830983808210910303918261645b6164555f612ac6565b91610794565b14616608578561647361646d85610794565b91610794565b11156165d6576165cd92866165d39697936164c493616490612795565b50099085821190039403936001836164b15f6164ac8791612ac6565b614c59565b1680809504960493805f03040190615f50565b17916165c76165ab61658761656361653f61651b6164ec60036164e78991615f34565b615f50565b6164f66002614dbd565b18616515600261651061650a8b8590615f50565b91614dbd565b614c59565b90615f50565b616539600261653461652e8a8590615f50565b91614dbd565b614c59565b90615f50565b61655d6002616558616552898590615f50565b91614dbd565b614c59565b90615f50565b616581600261657c616576888590615f50565b91614dbd565b614c59565b90615f50565b6165a560026165a061659a878590615f50565b91614dbd565b614c59565b90615f50565b916165c26165bc6002928590615f50565b91614dbd565b614c59565b90615f50565b90615f50565b90565b616603866165ec6165e65f612ac6565b91610794565b146165f56163e1565b6165fd61640d565b91616e74565b616e98565b505050916166169192615f5e565b90565b61664291616625612795565b508161663961663383610794565b91610794565b10919091616e74565b90565b61665790616651612795565b50613af0565b90565b90565b9190918061667361666d85610765565b91610765565b1415806167f1575b616685575b505050565b806166a061669a6166955f612afe565b610765565b91610765565b03616761575b50816166c26166bc6166b75f612afe565b610765565b91610765565b036166ce575b80616680565b61671561670861670f926166e4600a8690613636565b906167026166fc6166f6600193616f13565b9361364c565b9161665a565b90616f66565b929061364f565b9161364f565b9190916167427fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a724926110df565b9261675761674e610512565b92839283610a98565b0390a25f806166c8565b6167a06167a6616799616776600a8590613636565b600261679361678d61678789616f13565b9361364c565b9161665a565b90616f66565b929061364f565b9161364f565b9190916167d37fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a724926110df565b926167e86167df610512565b92839283610a98565b0390a25f6166a6565b50816168056167ff5f612ac6565b91610794565b1161667b565b5f61681f91616818612795565b500161515a565b90565b61683661683161683b92611549565b610687565b610794565b90565b61684790615deb565b9052565b91602061686c92949361686560408201965f83019061683e565b019061083b565b565b61688261687d61688792610794565b610687565b611549565b90565b616892613ac1565b50806168aa6168a463ffffffff616822565b91610794565b116168bb576168b89061686e565b90565b60206168d75f9283926306dfcc6560e41b84526004840161684b565b0390fd5b6168f26168f7916168ea612795565b506008613ada565b61111a565b90565b90565b61691161690c616916926168fa565b611bfe565b610d2d565b90565b61692360ff6168fd565b90565b5f5260205f2090565b905f929180549061694961694283610b85565b8094612624565b916001811690815f146169a05750600114616964575b505050565b6169719192939450616926565b915f925b81841061698857505001905f808061695f565b60018160209295939554848601520191019290616975565b92949550505060ff19168252151560200201905f808061695f565b906169c59161692f565b90565b906169e86169e1926169d8610512565b938480926169bb565b0383610c6e565b565b6169f3906169c8565b90565b906169ff61261f565b50616a0982612f78565b616a22616a1c616a17616919565b610d2d565b91610d2d565b14155f14616a375750616a3490616ff0565b90565b616a4191506169ea565b90565b604291616a4f612f74565b50604051917f19010000000000000000000000000000000000000000000000000000000000008352600283015260228201522090565b5f90565b616a95616a9a91611101565b61280d565b90565b90565b616ab4616aaf616ab992616a9d565b610687565b610794565b90565b616af1616af894616ae7606094989795616add608086019a5f870190610d71565b6020850190610e62565b6040830190610d71565b0190610d71565b565b939293616b05613949565b50616b0e616a85565b50616b17612f74565b50616b2185616a89565b616b53616b4d7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0616aa0565b91610794565b11616be05790616b76602094955f94939293616b6d610512565b94859485616abc565b838052039060015afa15616bdb57616b8e5f51611bfe565b80616ba9616ba3616b9e5f612afe565b610765565b91610765565b14616bbf575f91616bb95f611c03565b91929190565b50616bc95f612afe565b600191616bd55f611c03565b91929190565b612cde565b505050616bec5f612afe565b9060039291929190565b634e487b7160e01b5f52602160045260245ffd5b60041115616c1457565b616bf6565b90616c2382616c0a565b565b80616c38616c325f616c19565b91616c19565b145f14616c43575050565b80616c57616c516001616c19565b91616c19565b145f14616c7a575f63f645eedf60e01b815280616c7660048201610913565b0390fd5b80616c8e616c886002616c19565b91616c19565b145f14616cbc57616cb8616ca183616a89565b5f91829163fce698f760e01b835260048301610848565b0390fd5b616ccf616cc96003616c19565b91616c19565b14616cd75750565b616cf2905f9182916335e2f38360e21b835260048301610d7e565b0390fd5b5f5260205f2090565b616d088161515a565b821015616d2257616d1a600191616cf6565b910201905f90565b610ed7565b90616d3190611974565b9052565b90616d3f90612413565b9052565b90616d79616d705f616d53614b74565b94616d6a616d6283830161519f565b838801616d27565b016151d1565b60208401616d35565b565b616d8490616d43565b90565b616da5915f616d9f92616d98614baf565b5001616cff565b50616d7b565b90565b9291616db684838391617020565b83616dd1616dcb616dc65f612afe565b610765565b91610765565b14616de6575b616de492939190916171aa565b565b616dee612a96565b93616df761718f565b9480616e0b616e0588610794565b91610794565b11616e1857509350616dd7565b8590616e345f928392630e58ae9360e11b845260048401610a98565b0390fd5b616e40612795565b50151590565b616e6b616e7192616e55612795565b508281169218616e656002614dbd565b90612d7b565b90613056565b90565b616e8e616e949293616e84612795565b5080941891616e38565b90615f50565b1890565b634e487b715f526020526024601cfd5b90565b616ebf616eba616ec492616ea8565b610687565b610e5c565b90565b616ed090616eab565b9052565b916020616ef5929493616eee60408201965f830190616ec7565b019061083b565b565b616f0b616f06616f1092610794565b610687565b612413565b90565b616f1b612546565b5080616f35616f2f60018060d01b0361364f565b91610794565b11616f4657616f4390616ef7565b90565b60d0616f625f9283926306dfcc6560e41b845260048401616ed4565b0390fd5b90616f9c616fa29392616f77612546565b50616f80612546565b508093616f95616f8e613e46565b94926157ff565b9091617612565b91617269565b91909190565b616fbc616fb7616fc192615de8565b610687565b610794565b90565b369037565b90616fee616fd683613891565b92602080616fe4869361386e565b9201910390616fc4565b565b616ff861261f565b50617002816172d3565b906170156170106020616fa8565b616fc9565b918252602082015290565b9190918061703e6170386170335f612afe565b610765565b91610765565b145f1461711f5761706261705b83617056600261111a565b613056565b6002612b65565b5b8261707e6170786170735f612afe565b610765565b91610765565b145f146170f3576170a261709b83617096600261111a565b614c59565b6002612b65565b5b9190916170ee6170dc6170d67fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef936110df565b936110df565b936170e5610512565b91829182610848565b0390a3565b61711a826171146171055f8790613ada565b9161710f8361111a565b615f80565b90612b65565b6170a3565b61713261712d5f8390613ada565b61111a565b8061714561713f85610794565b91610794565b1061716d57617158617168918490614c59565b6171635f8490613ada565b612b65565b617063565b9061718b9091925f93849363391434e360e21b855260048501614c27565b0390fd5b617197612795565b506171a760018060d01b0361364f565b90565b916172026171fc61720994806171d06171ca6171c55f612afe565b610765565b91610765565b1461723a575b846171f16171eb6171e65f612afe565b610765565b91610765565b1461720b575b61398f565b9261398f565b909161665d565b565b617233600b600261722d61722761722189616f13565b9361364c565b9161665a565b90616f66565b50506171f7565b617262600b600161725c61725661725089616f13565b9361364c565b9161665a565b90616f66565b50506171d6565b9161728d5f6172929461727a612546565b50617283612546565b500192919261517d565b6174c4565b91909190565b6172ac6172a76172b1926168fa565b610687565b610794565b90565b90565b6172cb6172c66172d0926172b4565b610687565b610794565b90565b6172e86172ed916172e2612795565b50612f78565b616a89565b6172f760ff617298565b168061730c617306601f6172b7565b91610794565b116173145790565b5f632cd44ac360e21b81528061732c60048201610913565b0390fd5b5490565b61733e6040613859565b90565b5f5260205f2090565b61735381617330565b82101561736d57617365600191617341565b910201905f90565b610ed7565b61737c9051611974565b90565b9061739065ffffffffffff91611bfe565b9181191691161790565b6173ae6173a96173b392611974565b610687565b611974565b90565b90565b906173ce6173c96173d59261739a565b6173b6565b825461737f565b9055565b6173e39051612413565b90565b60301b90565b906173fe65ffffffffffff19916173e6565b9181191691161790565b61741c61741761742192612413565b610687565b612413565b90565b90565b9061743c61743761744392617408565b617424565b82546173ec565b9055565b9061747160205f61747794617469828201617463848801617372565b906173b9565b0192016173d9565b90617427565b565b919061748a5761748891617447565b565b610b5e565b90815491680100000000000000008310156174bf57826174b79160016174bd9501815561734a565b90617479565b565b610c5a565b909291926174d0612546565b506174d9612546565b506174e382617330565b806174f66174f05f612ac6565b91610794565b115f146175c65761751c9061751684916175106001614445565b90612cee565b906162f9565b906175285f830161519f565b926175345f84016151d1565b938061754861754285611974565b91611974565b116175aa5761755f61755984611974565b91611974565b145f1461757a575050617575905f859101617427565b5b9190565b6175a592506175a08661759761758e617334565b945f8601616d27565b60208401616d35565b61748f565b617576565b5f632520601d60e01b8152806175c260048201610913565b0390fd5b506175f1916175ec856175e36175da617334565b945f8601616d27565b60208401616d35565b61748f565b6175fa5f6151de565b9190565b634e487b7160e01b5f52605160045260245ffd5b91909180600114617631576002036175fe5761762d916125c5565b905b565b5061763b91612586565b9061762f56
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x13W[a%BV[a\0\x1D_5a\x05\x0CV[\x80c\x01\xFF\xC9\xA7\x14a\x05\x07W\x80c\x06\xFD\xDE\x03\x14a\x05\x02W\x80c\x07\xA1\xD5\xFA\x14a\x04\xFDW\x80c\t^\xA7\xB3\x14a\x04\xF8W\x80c\x0C\x05\xF8,\x14a\x04\xF3W\x80c\x13\xBE\xAA[\x14a\x04\xEEW\x80c\x18\x16\r\xDD\x14a\x04\xE9W\x80c\x1B\x02\xF8E\x14a\x04\xE4W\x80c\"\xA9}\x9C\x14a\x04\xDFW\x80c#\xB8r\xDD\x14a\x04\xDAW\x80c#\xE4`\xD2\x14a\x04\xD5W\x80c$:0\xCC\x14a\x04\xD0W\x80c$\x81\xBB\\\x14a\x04\xCBW\x80c$\x8A\x9C\xA3\x14a\x04\xC6W\x80c(N\x133\x14a\x04\xC1W\x80c//\xF1]\x14a\x04\xBCW\x80c1<\xE5g\x14a\x04\xB7W\x80c3M\x0B\xBD\x14a\x04\xB2W\x80c5\x9Bv\xFE\x14a\x04\xADW\x80c6D\xE5\x15\x14a\x04\xA8W\x80c6V\x8A\xBE\x14a\x04\xA3W\x80c:F\xB1\xA8\x14a\x04\x9EW\x80c?K\xA8:\x14a\x04\x99W\x80c@\xC1\x0F\x19\x14a\x04\x94W\x80cD\xE1\x81\xAA\x14a\x04\x8FW\x80cH\xB0\xDA\xA6\x14a\x04\x8AW\x80cK\xDD6\xCE\x14a\x04\x85W\x80cK\xF5\xD7\xE9\x14a\x04\x80W\x80cX|\xDE\x1E\x14a\x04{W\x80cZ\xDF\0!\x14a\x04vW\x80c\\\x19\xA9\\\x14a\x04qW\x80c\\\x97Z\xBB\x14a\x04lW\x80c_\x15\xC3\xC9\x14a\x04gW\x80ce\x1F\xD2h\x14a\x04bW\x80cl3\xBC\xED\x14a\x04]W\x80cl\xF0\x16%\x14a\x04XW\x80co\xC0c\xBE\x14a\x04SW\x80co\xCF\xFFE\x14a\x04NW\x80cp\xA0\x821\x14a\x04IW\x80crf\0\xCE\x14a\x04DW\x80cvg\x18\x08\x14a\x04?W\x80c|y\x0C\xAB\x14a\x04:W\x80c~\xCE\xBE\0\x14a\x045W\x80c\x84V\xCBY\x14a\x040W\x80c\x84\xB0\x19n\x14a\x04+W\x80c\x8ES\x9E\x8C\x14a\x04&W\x80c\x90-U\xA5\x14a\x04!W\x80c\x91\xD1HT\x14a\x04\x1CW\x80c\x91\xDD\xAD\xF4\x14a\x04\x17W\x80c\x95\xD8\x9BA\x14a\x04\x12W\x80c\x99\x12}\x9B\x14a\x04\rW\x80c\x99\x89U\xD3\x14a\x04\x08W\x80c\x9A\xB2N\xB0\x14a\x04\x03W\x80c\x9B~\xF6K\x14a\x03\xFEW\x80c\x9D\xC2\x9F\xAC\x14a\x03\xF9W\x80c\xA0\x8DVT\x14a\x03\xF4W\x80c\xA2\x17\xFD\xDF\x14a\x03\xEFW\x80c\xA3\xD4H[\x14a\x03\xEAW\x80c\xA4\xD7\xE3\x1D\x14a\x03\xE5W\x80c\xA5q\xE1\x84\x14a\x03\xE0W\x80c\xA5\xB3&\xBE\x14a\x03\xDBW\x80c\xA7\x0B\x9F\x0C\x14a\x03\xD6W\x80c\xA9\x05\x9C\xBB\x14a\x03\xD1W\x80c\xAE^\xCB\xC6\x14a\x03\xCCW\x80c\xAF*\xA6;\x14a\x03\xC7W\x80c\xB0\xCA%>\x14a\x03\xC2W\x80c\xBA\xBC9O\x14a\x03\xBDW\x80c\xBBMD6\x14a\x03\xB8W\x80c\xC0*\xE7T\x14a\x03\xB3W\x80c\xC1\xEBq7\x14a\x03\xAEW\x80c\xC3\xCD\xA5 \x14a\x03\xA9W\x80c\xD5\x05\xAC\xCF\x14a\x03\xA4W\x80c\xD5Gt\x1F\x14a\x03\x9FW\x80c\xDDb\xED>\x14a\x03\x9AW\x80c\xE3\xAB\xDF\xCB\x14a\x03\x95W\x80c\xE6:\xB1\xE9\x14a\x03\x90W\x80c\xF1\x12~\xD8\x14a\x03\x8BW\x80c\xF5\x08\xE1\x9D\x14a\x03\x86Wc\xF7^\x85\x12\x03a\0\x0EWa%\rV[a$\xA9V[a$dV[a#\x81V[a#\x1DV[a\"\xB8V[a\"WV[a\"\x1DV[a!sV[a \xB7V[a \x82V[a MV[a \x14V[a\x1F\xA0V[a\x1FkV[a\x1E\xC1V[a\x1EMV[a\x1E\x18V[a\x1D\xAAV[a\x1DwV[a\x1C\xF5V[a\x1C\xC0V[a\x1C6V[a\x1B\xC7V[a\x1BYV[a\x1B$V[a\x1A\xAEV[a\x1AyV[a\x1ADV[a\x19\xD6V[a\x19\xA1V[a\x19>V[a\x19\tV[a\x18\x93V[a\x18WV[a\x17\x12V[a\x16\xDDV[a\x16\xA4V[a\x16\"V[a\x15\xDEV[a\x15\xA9V[a\x15tV[a\x15\x14V[a\x14\xB0V[a\x14<V[a\x14\x07V[a\x13\xD2V[a\x13fV[a\x133V[a\x12\xFEV[a\x12\xC9V[a\x12rV[a\x12=V[a\x12\x08V[a\x11\xC0V[a\x10\xABV[a\x10xV[a\x10BV[a\x10\x0EV[a\x0F\xD9V[a\x0F\xA6V[a\x0FqV[a\x0E\x84V[a\x0E(V[a\r\xC8V[a\r\x93V[a\x0C\xF8V[a\x0B)V[a\n\xBBV[a\nbV[a\t\xF3V[a\t\x81V[a\tLV[a\t\x18V[a\x08]V[a\x07\xE7V[a\x07/V[a\x06GV[a\x05\x98V[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x80\xFD[c\xFF\xFF\xFF\xFF`\xE0\x1B\x16\x90V[a\x059\x81a\x05$V[\x03a\x05@WV[_\x80\xFD[\x90P5\x90a\x05Q\x82a\x050V[V[\x90` \x82\x82\x03\x12a\x05lWa\x05i\x91_\x01a\x05DV[\x90V[a\x05\x1CV[\x15\x15\x90V[a\x05\x7F\x90a\x05qV[\x90RV[\x91\x90a\x05\x96\x90_` \x85\x01\x94\x01\x90a\x05vV[V[4a\x05\xC8Wa\x05\xC4a\x05\xB3a\x05\xAE6`\x04a\x05SV[a%\xDFV[a\x05\xBBa\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[_\x91\x03\x12a\x05\xD7WV[a\x05\x1CV[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[`\x1F\x80\x19\x91\x01\x16\x90V[a\x06\x1Da\x06&` \x93a\x06+\x93a\x06\x14\x81a\x05\xDCV[\x93\x84\x80\x93a\x05\xE0V[\x95\x86\x91\x01a\x05\xE9V[a\x05\xF4V[\x01\x90V[a\x06D\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x05\xFEV[\x90V[4a\x06wWa\x06W6`\x04a\x05\xCDV[a\x06sa\x06ba&\xFDV[a\x06ja\x05\x12V[\x91\x82\x91\x82a\x06/V[\x03\x90\xF3[a\x05\x18V[`\x01\x80`\xA0\x1B\x03\x16\x90V[\x90V[a\x06\x9Ea\x06\x99a\x06\xA3\x92a\x06|V[a\x06\x87V[a\x06|V[\x90V[a\x06\xAF\x90a\x06\x8AV[\x90V[a\x06\xBB\x90a\x06\xA6V[\x90V[a\x06\xC7\x90a\x06\xB2V[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[a\x06\xF7a\x07\0` \x93a\x07\x05\x93a\x06\xEE\x81a\x06\xCBV[\x93\x84\x80\x93a\x06\xCFV[\x95\x86\x91\x01a\x05\xE9V[a\x05\xF4V[\x01\x90V[\x91a\x07,\x92a\x07\x1F`@\x82\x01\x93_\x83\x01\x90a\x06\xBEV[` \x81\x84\x03\x91\x01Ra\x06\xD8V[\x90V[4a\x07`Wa\x07?6`\x04a\x05\xCDV[a\x07Ga'IV[\x90a\x07\\a\x07Sa\x05\x12V[\x92\x83\x92\x83a\x07\tV[\x03\x90\xF3[a\x05\x18V[a\x07n\x90a\x06|V[\x90V[a\x07z\x81a\x07eV[\x03a\x07\x81WV[_\x80\xFD[\x90P5\x90a\x07\x92\x82a\x07qV[V[\x90V[a\x07\xA0\x81a\x07\x94V[\x03a\x07\xA7WV[_\x80\xFD[\x90P5\x90a\x07\xB8\x82a\x07\x97V[V[\x91\x90`@\x83\x82\x03\x12a\x07\xE2W\x80a\x07\xD6a\x07\xDF\x92_\x86\x01a\x07\x85V[\x93` \x01a\x07\xABV[\x90V[a\x05\x1CV[4a\x08\x18Wa\x08\x14a\x08\x03a\x07\xFD6`\x04a\x07\xBAV[\x90a'sV[a\x08\x0Ba\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[\x90` \x82\x82\x03\x12a\x086Wa\x083\x91_\x01a\x07\x85V[\x90V[a\x05\x1CV[a\x08D\x90a\x07\x94V[\x90RV[\x91\x90a\x08[\x90_` \x85\x01\x94\x01\x90a\x08;V[V[4a\x08\x8DWa\x08\x89a\x08xa\x08s6`\x04a\x08\x1DV[a'\x99V[a\x08\x80a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x08\xD8W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x08\xD3W` \x01\x92`\x01\x83\x02\x84\x01\x11a\x08\xCEWV[a\x08\x9AV[a\x08\x96V[a\x08\x92V[\x90` \x82\x82\x03\x12a\t\x0EW_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\t\tWa\t\x05\x92\x01a\x08\x9EV[\x90\x91V[a\x05 V[a\x05\x1CV[_\x01\x90V[4a\tGWa\t1a\t+6`\x04a\x08\xDDV[\x90a*\x8AV[a\t9a\x05\x12V[\x80a\tC\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\t|Wa\t\\6`\x04a\x05\xCDV[a\txa\tga*\x96V[a\toa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\t\xAFWa\t\x916`\x04a\x05\xCDV[a\t\x99a,bV[a\t\xA1a\x05\x12V[\x80a\t\xAB\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[\x1C\x90V[`\xFF\x16\x90V[a\t\xCE\x90`\x08a\t\xD3\x93\x02a\t\xB4V[a\t\xB8V[\x90V[\x90a\t\xE1\x91Ta\t\xBEV[\x90V[a\t\xF0`@_\x90a\t\xD6V[\x90V[4a\n#Wa\n\x036`\x04a\x05\xCDV[a\n\x1Fa\n\x0Ea\t\xE4V[a\n\x16a\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[\x90\x91``\x82\x84\x03\x12a\n]Wa\nZa\nC\x84_\x85\x01a\x07\x85V[\x93a\nQ\x81` \x86\x01a\x07\x85V[\x93`@\x01a\x07\xABV[\x90V[a\x05\x1CV[4a\n\x93Wa\n\x8Fa\n~a\nx6`\x04a\n(V[\x91a,lV[a\n\x86a\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[\x91` a\n\xB9\x92\x94\x93a\n\xB2`@\x82\x01\x96_\x83\x01\x90a\x08;V[\x01\x90a\x08;V[V[4a\n\xECWa\n\xD3a\n\xCE6`\x04a\x08\x1DV[a-\x9DV[\x90a\n\xE8a\n\xDFa\x05\x12V[\x92\x83\x92\x83a\n\x98V[\x03\x90\xF3[a\x05\x18V[\x90V[a\x0B\x08a\x0B\x03a\x0B\r\x92a\n\xF1V[a\x06\x87V[a\x07\x94V[\x90V[a\x0B\x1Ba\x0E\x10a\n\xF4V[\x90V[a\x0B&a\x0B\x10V[\x90V[4a\x0BYWa\x0B96`\x04a\x05\xCDV[a\x0BUa\x0BDa\x0B\x1EV[a\x0BLa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x0B\xA5W[` \x83\x10\x14a\x0B\xA0WV[a\x0BqV[\x91`\x7F\x16\x91a\x0B\x95V[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x0B\xDBa\x0B\xD4\x83a\x0B\x85V[\x80\x94a\x0B\xAFV[\x91`\x01\x81\x16\x90\x81_\x14a\x0C2WP`\x01\x14a\x0B\xF6W[PPPV[a\x0C\x03\x91\x92\x93\x94Pa\x0B\xB8V[\x91_\x92[\x81\x84\x10a\x0C\x1AWPP\x01\x90_\x80\x80a\x0B\xF1V[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x0C\x07V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x0B\xF1V[\x90a\x0CW\x91a\x0B\xC1V[\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x0Cx\x90a\x05\xF4V[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x0C\x92W`@RV[a\x0CZV[\x90a\x0C\xB7a\x0C\xB0\x92a\x0C\xA7a\x05\x12V[\x93\x84\x80\x92a\x0CMV[\x03\x83a\x0CnV[V[\x90_\x10a\x0C\xCCWa\x0C\xC9\x90a\x0C\x97V[\x90V[a\x0B^V[a\x0C\xDD`E_\x90a\x0C\xB9V[\x90V[a\x0C\xF5\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x06\xD8V[\x90V[4a\r(Wa\r\x086`\x04a\x05\xCDV[a\r$a\r\x13a\x0C\xD1V[a\r\x1Ba\x05\x12V[\x91\x82\x91\x82a\x0C\xE0V[\x03\x90\xF3[a\x05\x18V[\x90V[a\r9\x81a\r-V[\x03a\r@WV[_\x80\xFD[\x90P5\x90a\rQ\x82a\r0V[V[\x90` \x82\x82\x03\x12a\rlWa\ri\x91_\x01a\rDV[\x90V[a\x05\x1CV[a\rz\x90a\r-V[\x90RV[\x91\x90a\r\x91\x90_` \x85\x01\x94\x01\x90a\rqV[V[4a\r\xC3Wa\r\xBFa\r\xAEa\r\xA96`\x04a\rSV[a/\xBEV[a\r\xB6a\x05\x12V[\x91\x82\x91\x82a\r~V[\x03\x90\xF3[a\x05\x18V[4a\r\xF6Wa\r\xD86`\x04a\x05\xCDV[a\r\xE0a4\xBCV[a\r\xE8a\x05\x12V[\x80a\r\xF2\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[\x91\x90`@\x83\x82\x03\x12a\x0E#W\x80a\x0E\x17a\x0E \x92_\x86\x01a\rDV[\x93` \x01a\x07\x85V[\x90V[a\x05\x1CV[4a\x0EWWa\x0EAa\x0E;6`\x04a\r\xFBV[\x90a4\xF0V[a\x0EIa\x05\x12V[\x80a\x0ES\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[`\xFF\x16\x90V[a\x0Ek\x90a\x0E\\V[\x90RV[\x91\x90a\x0E\x82\x90_` \x85\x01\x94\x01\x90a\x0EbV[V[4a\x0E\xB4Wa\x0E\x946`\x04a\x05\xCDV[a\x0E\xB0a\x0E\x9Fa5\x1FV[a\x0E\xA7a\x05\x12V[\x91\x82\x91\x82a\x0EoV[\x03\x90\xF3[a\x05\x18V[\x90` \x82\x82\x03\x12a\x0E\xD2Wa\x0E\xCF\x91_\x01a\x07\xABV[\x90V[a\x05\x1CV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[P`0\x90V[\x90V[a\x0E\xFD\x81a\x0E\xEBV[\x82\x10\x15a\x0F\x17Wa\x0F\x0F`\x01\x91a\x0E\xF1V[\x91\x02\x01\x90_\x90V[a\x0E\xD7V[\x90V[a\x0F/\x90`\x08a\x0F4\x93\x02a\t\xB4V[a\x0F\x1CV[\x90V[\x90a\x0FB\x91Ta\x0F\x1FV[\x90V[`\x10a\x0FP\x81a\x0E\xEBV[\x82\x10\x15a\x0FmWa\x0Fj\x91a\x0Fd\x91a\x0E\xF4V[\x90a\x0F7V[\x90V[_\x80\xFD[4a\x0F\xA1Wa\x0F\x9Da\x0F\x8Ca\x0F\x876`\x04a\x0E\xB9V[a\x0FEV[a\x0F\x94a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x0F\xD4Wa\x0F\xB66`\x04a\x05\xCDV[a\x0F\xBEa5\xD0V[a\x0F\xC6a\x05\x12V[\x80a\x0F\xD0\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\x10\tWa\x0F\xE96`\x04a\x05\xCDV[a\x10\x05a\x0F\xF4a5\xDAV[a\x0F\xFCa\x05\x12V[\x91\x82\x91\x82a\r~V[\x03\x90\xF3[a\x05\x18V[4a\x10=Wa\x10'a\x10!6`\x04a\r\xFBV[\x90a5\xEEV[a\x10/a\x05\x12V[\x80a\x109\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\x10sWa\x10oa\x10^a\x10X6`\x04a\x07\xBAV[\x90a6kV[a\x10fa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x10\xA6Wa\x10\x886`\x04a\x05\xCDV[a\x10\x90a6\xC9V[a\x10\x98a\x05\x12V[\x80a\x10\xA2\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\x10\xDAWa\x10\xC4a\x10\xBE6`\x04a\x07\xBAV[\x90a8&V[a\x10\xCCa\x05\x12V[\x80a\x10\xD6\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[a\x10\xE8\x90a\x06\xA6V[\x90V[\x90a\x10\xF5\x90a\x10\xDFV[_R` R`@_ \x90V[_\x1C\x90V[a\x11\x12a\x11\x17\x91a\x11\x01V[a\x0F\x1CV[\x90V[a\x11$\x90Ta\x11\x06V[\x90V[a\x112\x90`\ra\x10\xEBV[a\x11=_\x82\x01a\x11\x1AV[\x91a\x11J`\x01\x83\x01a\x11\x1AV[\x91a\x11W`\x02\x82\x01a\x11\x1AV[\x91a\x11p`\x04a\x11i`\x03\x85\x01a\x11\x1AV[\x93\x01a\x11\x1AV[\x90V[\x90\x95\x94\x92a\x11\xBE\x94a\x11\xADa\x11\xB7\x92a\x11\xA3`\x80\x96a\x11\x99`\xA0\x88\x01\x9C_\x89\x01\x90a\x08;V[` \x87\x01\x90a\x08;V[`@\x85\x01\x90a\x08;V[``\x83\x01\x90a\x08;V[\x01\x90a\x08;V[V[4a\x11\xF4Wa\x11\xF0a\x11\xDBa\x11\xD66`\x04a\x08\x1DV[a\x11'V[\x91a\x11\xE7\x95\x93\x95a\x05\x12V[\x95\x86\x95\x86a\x11sV[\x03\x90\xF3[a\x05\x18V[a\x12\x05`A_\x90a\x0F7V[\x90V[4a\x128Wa\x12\x186`\x04a\x05\xCDV[a\x124a\x12#a\x11\xF9V[a\x12+a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x12mWa\x12M6`\x04a\x05\xCDV[a\x12ia\x12Xa82V[a\x12`a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x12\xA2Wa\x12\x826`\x04a\x05\xCDV[a\x12\x9Ea\x12\x8Da8\xF3V[a\x12\x95a\x05\x12V[\x91\x82\x91\x82a\x06/V[\x03\x90\xF3[a\x05\x18V[a\x12\xB0\x90a\x07eV[\x90RV[\x91\x90a\x12\xC7\x90_` \x85\x01\x94\x01\x90a\x12\xA7V[V[4a\x12\xF9Wa\x12\xF5a\x12\xE4a\x12\xDF6`\x04a\x08\x1DV[a9\x8FV[a\x12\xECa\x05\x12V[\x91\x82\x91\x82a\x12\xB4V[\x03\x90\xF3[a\x05\x18V[4a\x13.Wa\x13\x0E6`\x04a\x05\xCDV[a\x13*a\x13\x19a9\xAEV[a\x13!a\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[4a\x13aWa\x13Ka\x13F6`\x04a\x08\x1DV[a9\xD7V[a\x13Sa\x05\x12V[\x80a\x13]\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\x13\x96Wa\x13v6`\x04a\x05\xCDV[a\x13\x92a\x13\x81a9\xEAV[a\x13\x89a\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[\x90V[a\x13\xB2a\x13\xADa\x13\xB7\x92a\x13\x9BV[a\x06\x87V[a\x07\x94V[\x90V[a\x13\xC4`0a\x13\x9EV[\x90V[a\x13\xCFa\x13\xBAV[\x90V[4a\x14\x02Wa\x13\xE26`\x04a\x05\xCDV[a\x13\xFEa\x13\xEDa\x13\xC7V[a\x13\xF5a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x147Wa\x143a\x14\"a\x14\x1D6`\x04a\x08\x1DV[a:\0V[a\x14*a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x14jWa\x14L6`\x04a\x05\xCDV[a\x14Ta:\xB7V[a\x14\\a\x05\x12V[\x80a\x14f\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[\x90V[a\x14\x86a\x14\x81a\x14\x8B\x92a\x14oV[a\x06\x87V[a\x07\x94V[\x90V[a\x14\xA2j\x08E\x95\x16\x14\x01HJ\0\0\0a\x14rV[\x90V[a\x14\xADa\x14\x8EV[\x90V[4a\x14\xE0Wa\x14\xC06`\x04a\x05\xCDV[a\x14\xDCa\x14\xCBa\x14\xA5V[a\x14\xD3a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x90a\x14\xEF\x90a\x10\xDFV[_R` R`@_ \x90V[a\x15\x11\x90a\x15\x0C`\x0E\x91_\x92a\x14\xE5V[a\t\xD6V[\x90V[4a\x15DWa\x15@a\x15/a\x15*6`\x04a\x08\x1DV[a\x14\xFBV[a\x157a\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[c\xFF\xFF\xFF\xFF\x16\x90V[a\x15[\x90a\x15IV[\x90RV[\x91\x90a\x15r\x90_` \x85\x01\x94\x01\x90a\x15RV[V[4a\x15\xA4Wa\x15\xA0a\x15\x8Fa\x15\x8A6`\x04a\x08\x1DV[a:\xC5V[a\x15\x97a\x05\x12V[\x91\x82\x91\x82a\x15_V[\x03\x90\xF3[a\x05\x18V[4a\x15\xD9Wa\x15\xD5a\x15\xC4a\x15\xBF6`\x04a\x08\x1DV[a:\xF0V[a\x15\xCCa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x16\x0EWa\x16\na\x15\xF9a\x15\xF46`\x04a\x08\x1DV[a;\x0EV[a\x16\x01a\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[a\x16\x1F`B_\x90a\x0F7V[\x90V[4a\x16RWa\x1626`\x04a\x05\xCDV[a\x16Na\x16=a\x16\x13V[a\x16Ea\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x90\x95\x94\x92a\x16\xA2\x94a\x16\x91a\x16\x9B\x92a\x16\x87`\x80\x96a\x16}`\xA0\x88\x01\x9C_\x89\x01\x90a\x05vV[` \x87\x01\x90a\x08;V[`@\x85\x01\x90a\x08;V[``\x83\x01\x90a\x08;V[\x01\x90a\x08;V[V[4a\x16\xD8Wa\x16\xD4a\x16\xBFa\x16\xBA6`\x04a\x08\x1DV[a;-V[\x91a\x16\xCB\x95\x93\x95a\x05\x12V[\x95\x86\x95\x86a\x16WV[\x03\x90\xF3[a\x05\x18V[4a\x17\rWa\x17\ta\x16\xF8a\x16\xF36`\x04a\x08\x1DV[a<\x9DV[a\x17\0a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x17@Wa\x17\"6`\x04a\x05\xCDV[a\x17*a<\xD6V[a\x172a\x05\x12V[\x80a\x17<\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[`\xFF`\xF8\x1B\x16\x90V[a\x17W\x90a\x17EV[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[` \x01\x90V[a\x17w\x90a\x07\x94V[\x90RV[\x90a\x17\x88\x81` \x93a\x17nV[\x01\x90V[` \x01\x90V[\x90a\x17\xAFa\x17\xA9a\x17\xA2\x84a\x17[V[\x80\x93a\x17_V[\x92a\x17hV[\x90_[\x81\x81\x10a\x17\xBFWPPP\x90V[\x90\x91\x92a\x17\xD8a\x17\xD2`\x01\x92\x86Qa\x17{V[\x94a\x17\x8CV[\x91\x01\x91\x90\x91a\x17\xB2V[\x93\x95\x91\x94a\x183a\x18(a\x18G\x95a\x18\x1Aa\x18=\x95a\x18T\x9C\x9Aa\x18\r`\xE0\x8C\x01\x92_\x8D\x01\x90a\x17NV[\x8A\x82\x03` \x8C\x01Ra\x05\xFEV[\x90\x88\x82\x03`@\x8A\x01Ra\x05\xFEV[\x97``\x87\x01\x90a\x08;V[`\x80\x85\x01\x90a\x12\xA7V[`\xA0\x83\x01\x90a\rqV[`\xC0\x81\x84\x03\x91\x01Ra\x17\x92V[\x90V[4a\x18\x8EWa\x18g6`\x04a\x05\xCDV[a\x18\x8Aa\x18ra=]V[\x93a\x18\x81\x97\x95\x97\x93\x91\x93a\x05\x12V[\x97\x88\x97\x88a\x17\xE2V[\x03\x90\xF3[a\x05\x18V[4a\x18\xC3Wa\x18\xBFa\x18\xAEa\x18\xA96`\x04a\x0E\xB9V[a=\xE7V[a\x18\xB6a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x90V[a\x18\xDFa\x18\xDAa\x18\xE4\x92a\x18\xC8V[a\x06\x87V[a\x07\x94V[\x90V[a\x18\xFBjR\xB7\xD2\xDC\xC8\x0C\xD2\xE4\0\0\0a\x18\xCBV[\x90V[a\x19\x06a\x18\xE7V[\x90V[4a\x199Wa\x19\x196`\x04a\x05\xCDV[a\x195a\x19$a\x18\xFEV[a\x19,a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x19oWa\x19ka\x19Za\x19T6`\x04a\r\xFBV[\x90a>\x18V[a\x19ba\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x19\x88\x90a\x19tV[\x90RV[\x91\x90a\x19\x9F\x90_` \x85\x01\x94\x01\x90a\x19\x7FV[V[4a\x19\xD1Wa\x19\xB16`\x04a\x05\xCDV[a\x19\xCDa\x19\xBCa>FV[a\x19\xC4a\x05\x12V[\x91\x82\x91\x82a\x19\x8CV[\x03\x90\xF3[a\x05\x18V[4a\x1A\x06Wa\x19\xE66`\x04a\x05\xCDV[a\x1A\x02a\x19\xF1a>ZV[a\x19\xF9a\x05\x12V[\x91\x82\x91\x82a\x06/V[\x03\x90\xF3[a\x05\x18V[\x90V[a\x1A\"a\x1A\x1Da\x1A'\x92a\x1A\x0BV[a\x06\x87V[a\x07\x94V[\x90V[a\x1A6b\x01Q\x80a\x1A\x0EV[\x90V[a\x1AAa\x1A*V[\x90V[4a\x1AtWa\x1AT6`\x04a\x05\xCDV[a\x1Apa\x1A_a\x1A9V[a\x1Aga\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x1A\xA9Wa\x1A\xA5a\x1A\x94a\x1A\x8F6`\x04a\x08\x1DV[a>pV[a\x1A\x9Ca\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x1A\xDEWa\x1A\xDAa\x1A\xC9a\x1A\xC46`\x04a\x08\x1DV[a>\xCBV[a\x1A\xD1a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x90V[a\x1A\xFAa\x1A\xF5a\x1A\xFF\x92a\x1A\xE3V[a\x06\x87V[a\x07\x94V[\x90V[a\x1B\x16jJr=\xC6\xB4\x0B\x8A\x9A\0\0\0a\x1A\xE6V[\x90V[a\x1B!a\x1B\x02V[\x90V[4a\x1BTWa\x1B46`\x04a\x05\xCDV[a\x1BPa\x1B?a\x1B\x19V[a\x1BGa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x1B\x88Wa\x1Bra\x1Bl6`\x04a\x07\xBAV[\x90a@MV[a\x1Bza\x05\x12V[\x80a\x1B\x84\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[\x90\x91``\x82\x84\x03\x12a\x1B\xC2Wa\x1B\xBFa\x1B\xA8\x84_\x85\x01a\x07\x85V[\x93a\x1B\xB6\x81` \x86\x01a\x07\xABV[\x93`@\x01a\x07\xABV[\x90V[a\x05\x1CV[4a\x1B\xF6Wa\x1B\xE0a\x1B\xDA6`\x04a\x1B\x8DV[\x91aB\xD3V[a\x1B\xE8a\x05\x12V[\x80a\x1B\xF2\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[\x90V[_\x1B\x90V[a\x1C\x17a\x1C\x12a\x1C\x1C\x92a\x1B\xFBV[a\x1B\xFEV[a\r-V[\x90V[a\x1C(_a\x1C\x03V[\x90V[a\x1C3a\x1C\x1FV[\x90V[4a\x1CfWa\x1CF6`\x04a\x05\xCDV[a\x1Cba\x1CQa\x1C+V[a\x1CYa\x05\x12V[\x91\x82\x91\x82a\r~V[\x03\x90\xF3[a\x05\x18V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x1C\x86\x90`\x08a\x1C\x8B\x93\x02a\t\xB4V[a\x1CkV[\x90V[\x90a\x1C\x99\x91Ta\x1CvV[\x90V[a\x1C\xA8`D_\x90a\x1C\x8EV[\x90V[\x91\x90a\x1C\xBE\x90_` \x85\x01\x94\x01\x90a\x06\xBEV[V[4a\x1C\xF0Wa\x1C\xD06`\x04a\x05\xCDV[a\x1C\xECa\x1C\xDBa\x1C\x9CV[a\x1C\xE3a\x05\x12V[\x91\x82\x91\x82a\x1C\xABV[\x03\x90\xF3[a\x05\x18V[4a\x1D%Wa\x1D\x056`\x04a\x05\xCDV[a\x1D!a\x1D\x10aB\xE0V[a\x1D\x18a\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[a\x1D3\x90a\x07eV[\x90V[a\x1D?\x81a\x1D*V[\x03a\x1DFWV[_\x80\xFD[\x90P5\x90a\x1DW\x82a\x1D6V[V[\x90` \x82\x82\x03\x12a\x1DrWa\x1Do\x91_\x01a\x1DJV[\x90V[a\x05\x1CV[4a\x1D\xA5Wa\x1D\x8Fa\x1D\x8A6`\x04a\x1DYV[aD7V[a\x1D\x97a\x05\x12V[\x80a\x1D\xA1\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\x1D\xDAWa\x1D\xBA6`\x04a\x05\xCDV[a\x1D\xD6a\x1D\xC5aDaV[a\x1D\xCDa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x90V[a\x1D\xF6a\x1D\xF1a\x1D\xFB\x92a\x1D\xDFV[a\x06\x87V[a\x07\x94V[\x90V[a\x1E\nb'\x8D\0a\x1D\xE2V[\x90V[a\x1E\x15a\x1D\xFEV[\x90V[4a\x1EHWa\x1E(6`\x04a\x05\xCDV[a\x1EDa\x1E3a\x1E\rV[a\x1E;a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x1E~Wa\x1Eza\x1Eia\x1Ec6`\x04a\x07\xBAV[\x90aD\xDBV[a\x1Eqa\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[\x90V[a\x1E\x9Aa\x1E\x95a\x1E\x9F\x92a\x1E\x83V[a\x06\x87V[a\x07\x94V[\x90V[a\x1E\xB3g\r\xE0\xB6\xB3\xA7d\0\0a\x1E\x86V[\x90V[a\x1E\xBEa\x1E\xA2V[\x90V[4a\x1E\xF1Wa\x1E\xD16`\x04a\x05\xCDV[a\x1E\xEDa\x1E\xDCa\x1E\xB6V[a\x1E\xE4a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[P`0\x90V[\x90P\x90V[\x90V[` \x01\x90V[a\x1F&a\x1F a\x1F\x19\x83a\x1E\xF6V[\x80\x94a\x1E\xFCV[\x91a\x1F\x01V[_\x91[\x83\x83\x10a\x1F6WPPPPV[a\x1FLa\x1FF`\x01\x92\x84Qa\x17{V[\x92a\x1F\x04V[\x92\x01\x91\x90a\x1F)V[\x91\x90a\x1Fi\x90_a\x06\0\x85\x01\x94\x01\x90a\x1F\nV[V[4a\x1F\x9BWa\x1F{6`\x04a\x05\xCDV[a\x1F\x97a\x1F\x86aF\x02V[a\x1F\x8Ea\x05\x12V[\x91\x82\x91\x82a\x1FUV[\x03\x90\xF3[a\x05\x18V[4a\x1F\xD1Wa\x1F\xCDa\x1F\xBCa\x1F\xB66`\x04a\x07\xBAV[\x90aF\x18V[a\x1F\xC4a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[a \x0Ba \x12\x94a \x01``\x94\x98\x97\x95a\x1F\xF7`\x80\x86\x01\x9A_\x87\x01\x90a\x08;V[` \x85\x01\x90a\x08;V[`@\x83\x01\x90a\x08;V[\x01\x90a\x05vV[V[4a HWa $6`\x04a\x05\xCDV[a Da /aF.V[\x90a ;\x94\x92\x94a\x05\x12V[\x94\x85\x94\x85a\x1F\xD6V[\x03\x90\xF3[a\x05\x18V[4a }Wa ya ha c6`\x04a\x08\x1DV[aH\x05V[a pa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a \xB2Wa \x926`\x04a\x05\xCDV[a \xAEa \x9DaH\x1AV[a \xA5a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a \xE7Wa \xE3a \xD2a \xCD6`\x04a\x08\x1DV[aH.V[a \xDAa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[a \xF5\x81a\x0E\\V[\x03a \xFCWV[_\x80\xFD[\x90P5\x90a!\r\x82a \xECV[V[\x90\x91`\xC0\x82\x84\x03\x12a!nWa!'\x83_\x84\x01a\x07\x85V[\x92a!5\x81` \x85\x01a\x07\xABV[\x92a!C\x82`@\x83\x01a\x07\xABV[\x92a!ka!T\x84``\x85\x01a!\0V[\x93a!b\x81`\x80\x86\x01a\rDV[\x93`\xA0\x01a\rDV[\x90V[a\x05\x1CV[4a!\xA8Wa!\x92a!\x866`\x04a!\x0FV[\x94\x93\x90\x93\x92\x91\x92aH\xB8V[a!\x9Aa\x05\x12V[\x80a!\xA4\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[`\xE0\x81\x83\x03\x12a\"\x18Wa!\xC3\x82_\x83\x01a\x07\x85V[\x92a!\xD1\x83` \x84\x01a\x07\x85V[\x92a!\xDF\x81`@\x85\x01a\x07\xABV[\x92a!\xED\x82``\x83\x01a\x07\xABV[\x92a\"\x15a!\xFE\x84`\x80\x85\x01a!\0V[\x93a\"\x0C\x81`\xA0\x86\x01a\rDV[\x93`\xC0\x01a\rDV[\x90V[a\x05\x1CV[4a\"RWa\"<a\"06`\x04a!\xADV[\x95\x94\x90\x94\x93\x91\x93aJ\x0CV[a\"Da\x05\x12V[\x80a\"N\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\"\x86Wa\"pa\"j6`\x04a\r\xFBV[\x90aK*V[a\"xa\x05\x12V[\x80a\"\x82\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[\x91\x90`@\x83\x82\x03\x12a\"\xB3W\x80a\"\xA7a\"\xB0\x92_\x86\x01a\x07\x85V[\x93` \x01a\x07\x85V[\x90V[a\x05\x1CV[4a\"\xE9Wa\"\xE5a\"\xD4a\"\xCE6`\x04a\"\x8BV[\x90aKLV[a\"\xDCa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x7Fk\x97%\xF7@\xF9K\x91\xB7\x80`\xA1\xB1}\x17tem8\x14!\xA5)\xEC\x98\xCD\xB0\x13\xF4\xD9\xC2^\x90V[a#\x1Aa\"\xEEV[\x90V[4a#MWa#-6`\x04a\x05\xCDV[a#Ia#8a#\x12V[a#@a\x05\x12V[\x91\x82\x91\x82a\r~V[\x03\x90\xF3[a\x05\x18V[\x7Fe\xD7\xA2\x8E2e\xB3zdt\x92\x9F3e!\xB32\xC1h\x1B\x93?l\xB9\xF37fsD\r\x86*\x90V[a#~a#RV[\x90V[4a#\xB1Wa#\x916`\x04a\x05\xCDV[a#\xADa#\x9Ca#vV[a#\xA4a\x05\x12V[\x91\x82\x91\x82a\r~V[\x03\x90\xF3[a\x05\x18V[a#\xBF\x81a\x15IV[\x03a#\xC6WV[_\x80\xFD[\x90P5\x90a#\xD7\x82a#\xB6V[V[\x91\x90`@\x83\x82\x03\x12a$\x01W\x80a#\xF5a#\xFE\x92_\x86\x01a\x07\x85V[\x93` \x01a#\xCAV[\x90V[a\x05\x1CV[a$\x0F\x90a\x19tV[\x90RV[`\x01\x80`\xD0\x1B\x03\x16\x90V[a$'\x90a$\x13V[\x90RV[\x90` \x80a$M\x93a$C_\x82\x01Q_\x86\x01\x90a$\x06V[\x01Q\x91\x01\x90a$\x1EV[V[\x91\x90a$b\x90_`@\x85\x01\x94\x01\x90a$+V[V[4a$\x95Wa$\x91a$\x80a$z6`\x04a#\xD9V[\x90aK\xBAV[a$\x88a\x05\x12V[\x91\x82\x91\x82a$OV[\x03\x90\xF3[a\x05\x18V[a$\xA6`C_\x90a\x0F7V[\x90V[4a$\xD9Wa$\xB96`\x04a\x05\xCDV[a$\xD5a$\xC4a$\x9AV[a$\xCCa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x7F\xCC\xE2\x96\xB0@3*\x08\x0Em\xF15\x15\xA3\xEC(i\xE2\x1C\xD2\x0FsD\xAF\t\x87\xDD\xB98\xD8\xBD!\x90V[a%\na$\xDEV[\x90V[4a%=Wa%\x1D6`\x04a\x05\xCDV[a%9a%(a%\x02V[a%0a\x05\x12V[\x91\x82\x91\x82a\r~V[\x03\x90\xF3[a\x05\x18V[_\x80\xFD[_\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a%ja%p\x91a$\x13V[\x91a$\x13V[\x01\x90`\x01\x80`\xD0\x1B\x03\x82\x11a%\x81WV[a%JV[\x90a%\x99\x91a%\x93a%FV[Pa%^V[\x90V[a%\xA8a%\xAE\x91a$\x13V[\x91a$\x13V[\x90\x03\x90`\x01\x80`\xD0\x1B\x03\x82\x11a%\xC0WV[a%JV[\x90a%\xD8\x91a%\xD2a%FV[Pa%\x9CV[\x90V[_\x90V[a%\xE7a%\xDBV[P\x80a&\x02a%\xFCcye\xDB\x0B`\xE0\x1Ba\x05$V[\x91a\x05$V[\x14\x90\x81\x15a&\x0FW[P\x90V[a&\x19\x91PaK\xD0V[_a&\x0BV[``\x90V[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a&Pa&I\x83a\x0B\x85V[\x80\x94a&$V[\x91`\x01\x81\x16\x90\x81_\x14a&\xA7WP`\x01\x14a&kW[PPPV[a&x\x91\x92\x93\x94Pa&-V[\x91_\x92[\x81\x84\x10a&\x8FWPP\x01\x90_\x80\x80a&fV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a&|V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a&fV[\x90a&\xCC\x91a&6V[\x90V[\x90a&\xEFa&\xE8\x92a&\xDFa\x05\x12V[\x93\x84\x80\x92a&\xC2V[\x03\x83a\x0CnV[V[a&\xFA\x90a&\xCFV[\x90V[a'\x05a&\x1FV[Pa'\x10`\x03a&\xF1V[\x90V[_\x90V[``\x90V[a'(a'-\x91a\x11\x01V[a\x1CkV[\x90V[a':\x90Ta'\x1CV[\x90V[a'F\x90a\x0C\x97V[\x90V[a'Qa'\x13V[Pa'Za'\x17V[Pa'e`Da'0V[\x90a'p`Ea'=V[\x90V[a'\x90\x91a'\x7Fa%\xDBV[Pa'\x88aK\xF6V[\x91\x90\x91aL\x03V[`\x01\x90V[_\x90V[_a'\xB1a'\xB7\x92a'\xA9a'\x95V[P`\ra\x10\xEBV[\x01a\x11\x1AV[\x90V[\x90a'\xD4\x91a'\xCFa'\xCAa$\xDEV[aL\x13V[a*4V[V[P\x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a(\x03\x91\x02\x91a'\xFD_\x19\x84a'\xE4V[\x92a'\xE4V[\x91\x81\x19\x16\x91\x16\x17\x90V[a(!a(\x1Ca(&\x92a\x07\x94V[a\x06\x87V[a\x07\x94V[\x90V[\x90V[\x91\x90a(Ba(=a(J\x93a(\rV[a()V[\x90\x83Ta'\xE8V[\x90UV[a(`\x91a(Za'\x95V[\x91a(,V[V[[\x81\x81\x10a(nWPPV[\x80a({_`\x01\x93a(NV[\x01a(cV[\x91\x90`\x1F\x81\x11a(\x91W[PPPV[a(\x9Da(\xC2\x93a\x0B\xB8V[\x90` a(\xA9\x84a'\xDAV[\x83\x01\x93\x10a(\xCAW[a(\xBB\x90a'\xDAV[\x01\x90a(bV[_\x80\x80a(\x8CV[\x91Pa(\xBB\x81\x92\x90Pa(\xB2V[\x90a(\xE8\x90_\x19\x90`\x08\x02a\t\xB4V[\x19\x16\x90V[\x81a(\xF7\x91a(\xD8V[\x90`\x02\x02\x17\x90V[\x91a)\n\x90\x82a'\xD6V[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a)\xC9Wa).\x82a)(\x85Ta\x0B\x85V[\x85a(\x81V[_\x90`\x1F\x83\x11`\x01\x14a)aW\x91\x80\x91a)P\x93_\x92a)UW[PPa(\xEDV[\x90U[V[\x90\x91P\x015_\x80a)IV[`\x1F\x19\x83\x16\x91a)p\x85a\x0B\xB8V[\x92_[\x81\x81\x10a)\xB1WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a)\x97W[PPP\x02\x01\x90Ua)SV[a)\xA7\x91\x015`\x1F\x84\x16\x90a(\xD8V[\x90U_\x80\x80a)\x8BV[\x91\x93` `\x01\x81\x92\x87\x87\x015\x81U\x01\x95\x01\x92\x01a)sV[a\x0CZV[\x90a)\xD9\x92\x91a(\xFFV[V[\x90\x82_\x93\x92\x827\x01RV[\x91\x90a*\0\x81a)\xF9\x81a*\x05\x95a\x06\xCFV[\x80\x95a)\xDBV[a\x05\xF4V[\x01\x90V[\x91a*#a*1\x94\x92`@\x85\x01\x90\x85\x82\x03_\x87\x01Ra\x06\xD8V[\x92` \x81\x85\x03\x91\x01Ra)\xE6V[\x90V[\x90a*?`Ea'=V[a*L\x83\x83\x90`Ea)\xCEV[\x91\x90\x91a*\x85\x7F\xB9\xA2\x08\x84&\xF0;0\xA8\x1C\x06B\x80\x94\xFB\xFA\x9E&\x92s\x9B2A\xAFk\x9A\xB1\xDAKUF\xBE\x93a*|a\x05\x12V[\x93\x84\x93\x84a*\tV[\x03\x90\xA1V[\x90a*\x94\x91a'\xBAV[V[a*\x9Ea'\x95V[Pa*\xA9`\x02a\x11\x1AV[\x90V[a*\xBCa*\xB7a\"\xEEV[aL\x13V[a*\xC4a+\x85V[V[a*\xDAa*\xD5a*\xDF\x92a\x1B\xFBV[a\x06\x87V[a\x07\x94V[\x90V[a*\xF6a*\xF1a*\xFB\x92a\x1B\xFBV[a\x06\x87V[a\x06|V[\x90V[a+\x07\x90a*\xE2V[\x90V[\x90a+\x16`\xFF\x91a\x1B\xFEV[\x91\x81\x19\x16\x91\x16\x17\x90V[a+)\x90a\x05qV[\x90V[\x90V[\x90a+Da+?a+K\x92a+ V[a+,V[\x82Ta+\nV[\x90UV[\x90a+[_\x19\x91a\x1B\xFEV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a+za+ua+\x81\x92a(\rV[a()V[\x82Ta+OV[\x90UV[a+\x8F`Aa\x11\x1AV[a+\xA1a+\x9B_a*\xC6V[\x91a\x07\x94V[\x03a,FWa+\xB8a+\xB3`Da'0V[a\x06\xB2V[a+\xD2a+\xCCa+\xC7_a*\xFEV[a\x07eV[\x91a\x07eV[\x14a,*Wa+\xE3`\x01`@a+/V[a+\xEEB`Aa+eV[Ba,%\x7F\x11\x94\xB04\xCF\xA9\xABX\x07IJ\x1D\\f}\x8B\x0En\x97\xF3\x88\x88t*\xA3\x87\x1A2 4\x11`\x91a,\x1Ca\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xA1V[_c;\nH\xBD`\xE1\x1B\x81R\x80a,B`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c8\xE9=\xBD`\xE1\x1B\x81R\x80a,^`\x04\x82\x01a\t\x13V[\x03\x90\xFD[a,ja*\xACV[V[\x91a,\x96\x92a,ya%\xDBV[Pa,\x8Ea,\x85aK\xF6V[\x82\x90\x84\x91aLgV[\x91\x90\x91aL\xF3V[`\x01\x90V[a,\xA4\x90a\x06\xA6V[\x90V[_\x80\xFD[`\xE0\x1B\x90V[\x90PQ\x90a,\xBE\x82a\x07\x97V[V[\x90` \x82\x82\x03\x12a,\xD9Wa,\xD6\x91_\x01a,\xB1V[\x90V[a\x05\x1CV[a,\xE6a\x05\x12V[=_\x82>=\x90\xFD[a,\xFDa-\x03\x91\x93\x92\x93a\x07\x94V[\x92a\x07\x94V[\x82\x03\x91\x82\x11a-\x0EWV[a%JV[\x90V[a-*a-%a-/\x92a-\x13V[a\x06\x87V[a\x07\x94V[\x90V[a-Aa-G\x91\x93\x92\x93a\x07\x94V[\x92a\x07\x94V[\x91a-S\x83\x82\x02a\x07\x94V[\x92\x81\x84\x04\x14\x90\x15\x17\x15a-bWV[a%JV[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[a-\x87a-\x8D\x91a\x07\x94V[\x91a\x07\x94V[\x90\x81\x15a-\x98W\x04\x90V[a-gV[a-\xA5a'\x95V[\x91a-\xAEa'\x95V[\x91a-\xC5_a-\xBF`\r\x84\x90a\x10\xEBV[\x01a\x11\x1AV[\x90a-\xDD`\x02a-\xD7`\r\x84\x90a\x10\xEBV[\x01a\x11\x1AV[\x91a.\x16` a-\xEC0a,\x9BV[ce\x1F\xD2h\x90a.\x0B\x86\x92a-\xFFa\x05\x12V[\x95\x86\x94\x85\x93\x84\x93a,\xABV[\x83R`\x04\x83\x01a\x12\xB4V[\x03\x91Z\xFA\x90\x81\x15a/oWa.a\x91` \x91_\x91a/BW[P\x93a.:0a,\x9BV[a.Vc\x99\x89U\xD3a.Ja\x05\x12V[\x95\x86\x94\x85\x93\x84\x93a,\xABV[\x83R`\x04\x83\x01a\x12\xB4V[\x03\x91Z\xFA\x90\x81\x15a/=W_\x91a/\x0FW[P\x91\x81a.\x88a.\x82_a*\xC6V[\x91a\x07\x94V[\x11a.\xDEW[PP\x81a.\xA3a.\x9D_a*\xC6V[\x91a\x07\x94V[\x11a.\xADW[PPV[a.\xD6\x92\x93Pa.\xC0a.\xD1\x91\x83a,\xEEV[a.\xCBa'\x10a-\x16V[\x90a-2V[a-{V[\x90_\x80a.\xA9V[a/\x07\x92\x96Pa.\xF1a/\x02\x91\x83a,\xEEV[a.\xFCa'\x10a-\x16V[\x90a-2V[a-{V[\x93_\x80a.\x8EV[a/0\x91P` =\x81\x11a/6W[a/(\x81\x83a\x0CnV[\x81\x01\x90a,\xC0V[_a.sV[P=a/\x1EV[a,\xDEV[a/b\x91P\x82=\x81\x11a/hW[a/Z\x81\x83a\x0CnV[\x81\x01\x90a,\xC0V[_a./V[P=a/PV[a,\xDEV[_\x90V[a/\x81\x90a\r-V[\x90V[\x90a/\x8E\x90a/xV[_R` R`@_ \x90V[\x90V[a/\xA9a/\xAE\x91a\x11\x01V[a/\x9AV[\x90V[a/\xBB\x90Ta/\x9DV[\x90V[`\x01a/\xD7a/\xDD\x92a/\xCFa/tV[P`\x05a/\x84V[\x01a/\xB1V[\x90V[a/\xE8aM\x90V[a/\xF0a/\xF2V[V[a/\xFAaM\xE6V[a0\x02a0\x0CV[a0\naNKV[V[a0\x1Ca0\x17a\"\xEEV[aL\x13V[a0$a1VV[V[a02a07\x91a\x11\x01V[a\t\xB8V[\x90V[a0D\x90Ta0&V[\x90V[`\x01a0S\x91\x01a\x07\x94V[\x90V[a0ea0k\x91\x93\x92\x93a\x07\x94V[\x92a\x07\x94V[\x82\x01\x80\x92\x11a0vWV[a%JV[a0\x84\x90a\x06\xA6V[\x90V[_\x91\x03\x12a0\x91WV[a\x05\x1CV[\x90_\x92\x91\x80T\x90a0\xB0a0\xA9\x83a\x0B\x85V[\x80\x94a\x06\xCFV[\x91`\x01\x81\x16\x90\x81_\x14a1\x07WP`\x01\x14a0\xCBW[PPPV[a0\xD8\x91\x92\x93\x94Pa\x0B\xB8V[\x91_\x92[\x81\x84\x10a0\xEFWPP\x01\x90_\x80\x80a0\xC6V[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a0\xDCV[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a0\xC6V[a1Fa1S\x94\x92\x93a1<``\x84\x01\x95_\x85\x01\x90a\x12\xA7V[` \x83\x01\x90a\x08;V[`@\x81\x84\x03\x91\x01Ra0\x96V[\x90V[a1ia1c`@a0:V[\x15a\x05qV[a4\xA0Wa1uaB\xE0V[a4\x84Wa1\x9Ea1\x90Ba1\x8A`Aa\x11\x1AV[\x90a,\xEEV[a1\x98a\x1D\xFEV[\x90a-{V[Ba1\xC9a1\xC3a1\xBEa1\xB0aDaV[a1\xB8a\x0B\x10V[\x90a,\xEEV[a\x07\x94V[\x91a\x07\x94V[\x10a4hWa1\xE2\x90a1\xDC`Ba\x11\x1AV[\x90a,\xEEV[\x90\x81a2\x10a2\na2\x05a1\xF5a\x13\xBAV[a1\xFF`Ba\x11\x1AV[\x90a,\xEEV[a\x07\x94V[\x91a\x07\x94V[\x11a4EW[a2\x1F_a*\xC6V[\x90a2)_a*\xC6V[\x91[\x82a2>a28\x86a\x07\x94V[\x91a\x07\x94V[\x10\x15a2\x85Wa2ya2\x7F\x91a2sa2m`\x10a2ga2``Ba\x11\x1AV[\x89\x90a0VV[\x90a\x0E\xF4V[\x90a\x0F7V[\x90a0VV[\x92a0GV[\x91a2+V[\x91P\x91a2\x9Ca2\x95`Ca\x11\x1AV[\x83\x90a0VV[a2\xB5a2\xAFa2\xAAa\x14\x8EV[a\x07\x94V[\x91a\x07\x94V[\x11a4)Wa2\xD0a2\xD7\x91a2\xCB`Ba\x11\x1AV[a0VV[`Ba+eV[a2\xF4a2\xED\x82a2\xE8`Ca\x11\x1AV[a0VV[`Ca+eV[a3\x07a3\x000a0{V[\x82\x90aN_V[a3,a3\x130a0{V[a3%a3 `Da'0V[a\x06\xB2V[\x83\x91aL\x03V[a3>a39`Da'0V[a\x06\xB2V[c\x18\xB6\x8B\x8Ca3L0a0{V[\x83\x92`E\x92\x81;\x15a4$W_a3v\x91a3\x81\x82\x96a3ja\x05\x12V[\x98\x89\x97\x88\x96\x87\x95a,\xABV[\x85R`\x04\x85\x01a1\"V[\x03\x92Z\xF1\x80\x15a4\x1FWa3\xF3W[Pa3\x9B`Ba\x11\x1AV[\x90a3\xAEa3\xA9`Da'0V[a\x06\xB2V[\x90a3\xD9\x7F4\xB7=\x0C\x96\xE9\xFFMS\x11CH\x17\xC8\xEC\xC90\xE7\xD2x,[\xDE.y\xDCD\xB0YgU\xBB\x92a\x10\xDFV[\x92a3\xEEa3\xE5a\x05\x12V[\x92\x83\x92\x83a\n\x98V[\x03\x90\xA2V[a4\x12\x90_=\x81\x11a4\x18W[a4\n\x81\x83a\x0CnV[\x81\x01\x90a0\x87V[_a3\x90V[P=a4\0V[a,\xDEV[a,\xA7V[_c#\x06N\xBD`\xE0\x1B\x81R\x80a4A`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x90Pa4ba4Ra\x13\xBAV[a4\\`Ba\x11\x1AV[\x90a,\xEEV[\x90a2\x16V[_c=S\xC7S`\xE0\x1B\x81R\x80a4\x80`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c\x11UbK`\xE2\x1B\x81R\x80a4\x9C`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c\x19\xAF\xC9\x9D`\xE2\x1B\x81R\x80a4\xB8`\x04\x82\x01a\t\x13V[\x03\x90\xFD[a4\xC4a/\xE0V[V[\x90a4\xE1\x91a4\xDCa4\xD7\x82a/\xBEV[aL\x13V[a4\xE3V[V[\x90a4\xED\x91aN\xBDV[PV[\x90a4\xFA\x91a4\xC6V[V[_\x90V[\x90V[a5\x17a5\x12a5\x1C\x92a5\0V[a\x06\x87V[a\x0E\\V[\x90V[a5'a4\xFCV[Pa52`\x12a5\x03V[\x90V[a5Ea5@a\"\xEEV[aL\x13V[a5Ma5OV[V[a5Y`Aa\x11\x1AV[a5ka5e_a*\xC6V[\x91a\x07\x94V[\x14a5\xB4Wa5|`\x01`@a+/V[\x7FJy*\x0B\xE4+Vr\xFA\xA4\x01)\xFCdi\x07$\x90w\\\xA8\xD3\xC3N\x85-MU\xD3\xA75\xA9a5\xA5a\x05\x12V[\x80a5\xAF\x81a\t\x13V[\x03\x90\xA1V[_c\x8F\x98@A`\xE0\x1B\x81R\x80a5\xCC`\x04\x82\x01a\t\x13V[\x03\x90\xFD[a5\xD8a55V[V[a5\xE2a/tV[Pa5\xEBaOiV[\x90V[\x90\x80a6\ta6\x03a5\xFEaK\xF6V[a\x07eV[\x91a\x07eV[\x03a6\x1AWa6\x17\x91aP#V[PV[_c3K\xD9\x19`\xE1\x1B\x81R\x80a62`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x90a6@\x90a\x10\xDFV[_R` R`@_ \x90V[\x90V[a6ca6^a6h\x92a$\x13V[a\x06\x87V[a\x07\x94V[\x90V[a6\xA2\x91a6\x97a6\x91a6\x8Ca6\x9D\x94a6\x84a'\x95V[P`\na66V[a6LV[\x91aQ\x04V[\x90aQ\xFAV[a6OV[\x90V[a6\xB5a6\xB0a\x1C\x1FV[aL\x13V[a6\xBDa6\xBFV[V[a6\xC7aS\x81V[V[a6\xD1a6\xA5V[V[\x90a6\xE5\x91a6\xE0aM\xE6V[a6\xEFV[a6\xEDaNKV[V[\x90\x81a7\x0Ba7\x05a7\0_a*\xFEV[a\x07eV[\x91a\x07eV[\x14a8\nW\x80a7#a7\x1D_a*\xC6V[\x91a\x07\x94V[\x14a7\xEEWa7Ea7?a7:`\x0E3\x90a\x14\xE5V[a0:V[\x15a\x05qV[a7\xD2Wa7R3aS\x8EV[a7i`\x01a7c`\r3\x90a\x10\xEBV[\x01a\x11\x1AV[a7{a7u\x83a\x07\x94V[\x91a\x07\x94V[\x10a7\xB6Wa7\xB4\x91a7\xAF\x82a7\xA9`\x01a7\x99`\r3\x90a\x10\xEBV[\x01\x91a7\xA4\x83a\x11\x1AV[a,\xEEV[\x90a+eV[aN_V[V[_c\x1C\x95\x9E\xD9`\xE2\x1B\x81R\x80a7\xCE`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_cD\x17v\t`\xE1\x1B\x81R\x80a7\xEA`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a8\x06`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a8\"`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x90a80\x91a6\xD3V[V[a8:a'\x95V[Pa8Va8Fa\x14\x8EV[a8P`Ca\x11\x1AV[\x90a,\xEEV[\x90V[\x90a8la8ea\x05\x12V[\x92\x83a\x0CnV[V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a8\x8CWa8\x88` \x91a\x05\xF4V[\x01\x90V[a\x0CZV[\x90a8\xA3a8\x9E\x83a8nV[a8YV[\x91\x82RV[_\x7Fmode=blocknumber&from=default\0\0\0\x91\x01RV[a8\xD9`\x1Da8\x91V[\x90a8\xE6` \x83\x01a8\xA8V[V[a8\xF0a8\xCFV[\x90V[a8\xFBa&\x1FV[Pa9\x04a>FV[a9\x1Da9\x17a9\x12aU]V[a\x19tV[\x91a\x19tV[\x03a9-Wa9*a8\xE8V[\x90V[_c\x01\xBF\xC1\xC5`\xE6\x1B\x81R\x80a9E`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_\x90V[\x90a9W\x90a\x10\xDFV[_R` R`@_ \x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a9za9\x7F\x91a\x11\x01V[a9cV[\x90V[a9\x8C\x90Ta9nV[\x90V[a9\xA6a9\xAB\x91a9\x9Ea9IV[P`\ta9MV[a9\x82V[\x90V[a9\xB6a%\xDBV[Pa9\xC1`Aa\x11\x1AV[a9\xD3a9\xCD_a*\xC6V[\x91a\x07\x94V[\x11\x90V[a9\xE8\x90a9\xE3aK\xF6V[aU\x95V[V[a9\xF2a%\xDBV[Pa9\xFD`\x0Fa0:V[\x90V[a:W\x90a:\x0Ca'\x95V[Pa:$`\x01a:\x1E`\r\x84\x90a\x10\xEBV[\x01a\x11\x1AV[\x90a:Q`\x04a:Ka:C_a:=`\r\x87\x90a\x10\xEBV[\x01a\x11\x1AV[\x93`\ra\x10\xEBV[\x01a\x11\x1AV[\x91aV V[\x90V[a:ja:ea#RV[aL\x13V[a:ra:tV[V[a:\x7F_`@a+/V[\x7Fs\xA5\xFC`\xAA\xFE\xEC\x8F\x13\x9A\xF2-\x98\xE6!@\xE2\xCE\x91M\x1F\x15\\i+BwW\xC3\xE4\x01La:\xA8a\x05\x12V[\x80a:\xB2\x81a\t\x13V[\x03\x90\xA1V[a:\xBFa:ZV[V[_\x90V[a:\xD7\x90a:\xD1a:\xC1V[PaV\xCDV[\x90V[\x90a:\xE4\x90a\x10\xDFV[_R` R`@_ \x90V[a;\x06a;\x0B\x91a:\xFFa'\x95V[P_a:\xDAV[a\x11\x1AV[\x90V[a;%a;*\x91a;\x1Da%\xDBV[P`\x0Ea\x14\xE5V[a0:V[\x90V[\x90a;6a%\xDBV[Pa;?a'\x95V[Pa;Ha'\x95V[Pa;Qa'\x95V[Pa;Za'\x95V[Pa;oa;j`\x0E\x84\x90a\x14\xE5V[a0:V[\x91a;\x86_a;\x80`\r\x84\x90a\x10\xEBV[\x01a\x11\x1AV[\x91a;\x9E`\x02a;\x98`\r\x85\x90a\x10\xEBV[\x01a\x11\x1AV[\x90a;\xD7` a;\xAD0a,\x9BV[ce\x1F\xD2h\x90a;\xCC\x87\x92a;\xC0a\x05\x12V[\x95\x86\x94\x85\x93\x84\x93a,\xABV[\x83R`\x04\x83\x01a\x12\xB4V[\x03\x91Z\xFA\x90\x81\x15a<\x98Wa<\"\x91` \x91_\x91a<kW[P\x94a;\xFB0a,\x9BV[a<\x17c\x99\x89U\xD3a<\x0Ba\x05\x12V[\x95\x86\x94\x85\x93\x84\x93a,\xABV[\x83R`\x04\x83\x01a\x12\xB4V[\x03\x91Z\xFA\x90\x81\x15a<fW_\x91a<8W[P\x90V[a<Y\x91P` =\x81\x11a<_W[a<Q\x81\x83a\x0CnV[\x81\x01\x90a,\xC0V[_a<4V[P=a<GV[a,\xDEV[a<\x8B\x91P\x82=\x81\x11a<\x91W[a<\x83\x81\x83a\x0CnV[\x81\x01\x90a,\xC0V[_a;\xF0V[P=a<yV[a,\xDEV[a<\xAF\x90a<\xA9a'\x95V[PaV\xFCV[\x90V[a<\xC2a<\xBDa#RV[aL\x13V[a<\xCAa<\xCCV[V[a<\xD4aWrV[V[a<\xDEa<\xB2V[V[_\x90V[``\x90V[a<\xF2\x90a\x06\xA6V[\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a=\rW` \x80\x91\x02\x01\x90V[a\x0CZV[\x90a=$a=\x1F\x83a<\xF5V[a8YV[\x91\x82RV[6\x907V[\x90a=Sa=;\x83a=\x12V[\x92` \x80a=I\x86\x93a<\xF5V[\x92\x01\x91\x03\x90a=)V[V[`\x0F`\xF8\x1B\x90V[a=ea<\xE0V[Pa=na&\x1FV[Pa=wa&\x1FV[Pa=\x80a'\x95V[Pa=\x89a9IV[Pa=\x92a/tV[Pa=\x9Ba<\xE4V[Pa=\xA4aW\x7FV[\x90a=\xADaW\xBFV[\x90F\x90a=\xB90a<\xE9V[\x90a=\xC3_a\x1C\x03V[\x90a=\xD5a=\xD0_a*\xC6V[a=.V[\x90a=\xDEa=UV[\x96\x95\x94\x93\x92\x91\x90V[a>\x10a>\x15\x91a=\xF6a'\x95V[Pa>\na>\x04`\x0Ba6LV[\x91aQ\x04V[\x90aQ\xFAV[a6OV[\x90V[a>?\x91_a>4a>:\x93a>,a%\xDBV[P`\x05a/\x84V[\x01a\x14\xE5V[a0:V[\x90V[_\x90V[a>Na>BV[Pa>WaU]V[\x90V[a>ba&\x1FV[Pa>m`\x04a&\xF1V[\x90V[a>\xC8\x90a>|a'\x95V[Pa>\x94`\x03a>\x8E`\r\x84\x90a\x10\xEBV[\x01a\x11\x1AV[\x90a>\xC2`\x04a>\xBCa>\xB4`\x02a>\xAE`\r\x87\x90a\x10\xEBV[\x01a\x11\x1AV[\x93`\ra\x10\xEBV[\x01a\x11\x1AV[\x91aV V[\x90V[a>\xF2a>\xEDa>\xE8a>\xF7\x93a>\xE0a'\x95V[P`\na66V[a6LV[aW\xFFV[a6OV[\x90V[\x90a?\x0C\x91a?\x07aM\xE6V[a?\x16V[a?\x14aNKV[V[\x90\x81a?2a?,a?'_a*\xFEV[a\x07eV[\x91a\x07eV[\x14a@1W\x80a?Ja?D_a*\xC6V[\x91a\x07\x94V[\x14a@\x15Wa?la?fa?a`\x0E3\x90a\x14\xE5V[a0:V[\x15a\x05qV[a?\xF9Wa?y3aS\x8EV[a?\x90`\x03a?\x8A`\r3\x90a\x10\xEBV[\x01a\x11\x1AV[a?\xA2a?\x9C\x83a\x07\x94V[\x91a\x07\x94V[\x10a?\xDDWa?\xDB\x91a?\xD6\x82a?\xD0`\x03a?\xC0`\r3\x90a\x10\xEBV[\x01\x91a?\xCB\x83a\x11\x1AV[a,\xEEV[\x90a+eV[aXtV[V[_c\x1C\x95\x9E\xD9`\xE2\x1B\x81R\x80a?\xF5`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_cD\x17v\t`\xE1\x1B\x81R\x80a@\x11`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a@-`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a@I`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x90a@W\x91a>\xFAV[V[\x90a@t\x92\x91a@oa@ja$\xDEV[aL\x13V[a@vV[V[\x80a@\x91a@\x8Ba@\x86_a*\xFEV[a\x07eV[\x91a\x07eV[\x14aB\xB7Wa@\xB3a@\xADa@\xA8`\x0E\x84\x90a\x14\xE5V[a0:V[\x15a\x05qV[\x80aB|W[aB W[\x81a@\xD1a@\xCB_a*\xC6V[\x91a\x07\x94V[\x14\x80aB\x06W[\x80aA\xECW[aA\x91W[a@\xEC\x81aS\x8EV[aA\x03\x82_a@\xFD`\r\x85\x90a\x10\xEBV[\x01a+eV[aA\x1B\x83`\x02aA\x15`\r\x85\x90a\x10\xEBV[\x01a+eV[aA3\x82`\x01aA-`\r\x85\x90a\x10\xEBV[\x01a+eV[aAK\x83`\x03aAE`\r\x85\x90a\x10\xEBV[\x01a+eV[\x90\x91aAw\x7F\xAA\x80}\n\xBF0\xD9\x19h\xC7G\x8Cf\xB6\xD8%!\xA1\x06\xAF\x13\xED\xA06\xE2\x03m\xA9\xAF\x16\x89X\x92a\x10\xDFV[\x92aA\x8CaA\x83a\x05\x12V[\x92\x83\x92\x83a\n\x98V[\x03\x90\xA2V[aA\xA6_aA\xA1`\x0E\x84\x90a\x14\xE5V[a+/V[\x80aA\xD1\x7F\x02\xC2\xF0\xBA\x15\xB0?\x88\xB1\x8FH2`\x9A\x18\xCF5\xFCk?EF\xA9\x99 v\xD7E=\x134\xA8\x91a\x10\xDFV[\x90aA\xDAa\x05\x12V[\x80aA\xE4\x81a\t\x13V[\x03\x90\xA2a@\xE3V[PaB\x01aA\xFC`\x0E\x83\x90a\x14\xE5V[a0:V[a@\xDEV[P\x82aB\x1AaB\x14_a*\xC6V[\x91a\x07\x94V[\x14a@\xD8V[aB6`\x01aB1`\x0E\x84\x90a\x14\xE5V[a+/V[\x80aBa\x7Fl\xF2\x849\xA2\xDA\xAB\x1B&P\x97\"r\x12\xA5\xB7\x1E\nv\xF9\xED\x85\xE3\xF8\x15\xB5\xA6\xC3\xE2\x18\xEB\x7F\x91a\x10\xDFV[\x90aBja\x05\x12V[\x80aBt\x81a\t\x13V[\x03\x90\xA2a@\xBEV[P\x81aB\x90aB\x8A_a*\xC6V[\x91a\x07\x94V[\x11\x80\x15aB\x9DW[a@\xB9V[P\x82aB\xB1aB\xAB_a*\xC6V[\x91a\x07\x94V[\x11aB\x98V[_c\xD9.#=`\xE0\x1B\x81R\x80aB\xCF`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x90aB\xDE\x92\x91a@YV[V[aB\xE8a%\xDBV[PaB\xF3`Ba\x11\x1AV[aC\x0CaC\x06aC\x01a\x13\xBAV[a\x07\x94V[\x91a\x07\x94V[\x10\x15\x90V[aC*\x90aC%aC a$\xDEV[aL\x13V[aC\x82V[V[\x90aC=`\x01\x80`\xA0\x1B\x03\x91a\x1B\xFEV[\x91\x81\x19\x16\x91\x16\x17\x90V[aCP\x90a\x06\x8AV[\x90V[aC\\\x90aCGV[\x90V[\x90V[\x90aCwaCraC~\x92aCSV[aC_V[\x82TaC,V[\x90UV[aC\x8B\x81a\x06\xB2V[aC\xA5aC\x9FaC\x9A_a*\xFEV[a\x07eV[\x91a\x07eV[\x14aD\x1BWaC\xD0aC\xCAaC\xBA`Da'0V[aC\xC5\x84`DaCbV[a\x06\xB2V[\x91a\x06\xB2V[aD\x03aC\xFD\x7F\x07\x01[j\x9F\x05\x911H\xFD_\xAD\xDF*\xCC\x97\x08\xF3\x05\x93\x7F0r\xCA+KF\xFA\xA5\xD0\x89\x8B\x93a\x10\xDFV[\x91a\x10\xDFV[\x91aD\x0Ca\x05\x12V[\x80aD\x16\x81a\t\x13V[\x03\x90\xA3V[_c\xD9.#=`\xE0\x1B\x81R\x80aD3`\x04\x82\x01a\t\x13V[\x03\x90\xFD[aD@\x90aC\x11V[V[\x90V[aDYaDTaD^\x92aDBV[a\x06\x87V[a\x07\x94V[\x90V[aDia'\x95V[PaDt`Aa\x11\x1AV[aD\x86aD\x80_a*\xC6V[\x91a\x07\x94V[\x14aD\xCFWaD\xCCaD\x98`Aa\x11\x1AV[aD\xC6aD\xB8aD\xA8`Ba\x11\x1AV[aD\xB2`\x01aDEV[\x90a0VV[aD\xC0a\x1D\xFEV[\x90a-2V[\x90a0VV[\x90V[aD\xD8_a*\xC6V[\x90V[aD\xF8\x91aD\xE7a%\xDBV[PaD\xF0aK\xF6V[\x91\x90\x91aL\xF3V[`\x01\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11aE\x12W` \x02\x90V[a\x0CZV[aE#aE(\x91aD\xFDV[a8YV[\x90V[\x90aEIaE8\x83aE\x17V[\x92aEC\x84\x91aD\xFDV[\x90a=)V[V[aEU`0aE+V[\x90V[\x90P\x90V[aEg\x90Ta\x11\x06V[\x90V[`\x01\x01\x90V[aE\x8CaE\x86aE\x7F\x83a\x0E\xEBV[\x80\x94aEXV[\x91a\x0E\xF1V[_\x91[\x83\x83\x10aE\x9CWPPPPV[aE\xB9aE\xB3`\x01\x92aE\xAE\x85aE]V[a\x17{V[\x92aEjV[\x92\x01\x91\x90aE\x8FV[\x90aE\xD0\x81a\x06\0\x93aEpV[\x01\x90V[\x90aE\xF4aE\xED\x92aE\xE4a\x05\x12V[\x93\x84\x80\x92aE\xC2V[\x03\x83a\x0CnV[V[aE\xFF\x90aE\xD4V[\x90V[aF\naEKV[PaF\x15`\x10aE\xF6V[\x90V[\x90aF+\x91aF%a'\x95V[Pa6kV[\x90V[aF6a'\x95V[PaF?a'\x95V[PaFHa'\x95V[PaFQa%\xDBV[PaF\\`Aa\x11\x1AV[aFnaFh_a*\xC6V[\x91a\x07\x94V[\x14aG\xDFWaF\x98aF\x8ABaF\x84`Aa\x11\x1AV[\x90a,\xEEV[aF\x92a\x1D\xFEV[\x90a-{V[\x90aF\xDAaF\xA6`Aa\x11\x1AV[aF\xD4aF\xC6aF\xB6`Ba\x11\x1AV[aF\xC0`\x01aDEV[\x90a0VV[aF\xCEa\x1D\xFEV[\x90a-2V[\x90a0VV[aF\xE4`Ba\x11\x1AV[aF\xFDaF\xF7aF\xF2a\x13\xBAV[a\x07\x94V[\x91a\x07\x94V[\x10_\x14aG\xD1WaG\"aG\x1C`\x10aG\x16`Ba\x11\x1AV[\x90a\x0E\xF4V[\x90a\x0F7V[[\x92aG.`@a0:V[\x90\x81aG\xADW[P\x80aG\x83W[\x80aGWW[\x91aGM`Ba\x11\x1AV[\x91\x93\x92\x91\x93\x92\x91\x90V[PBaG|aGvaGq\x84aGka\x0B\x10V[\x90a,\xEEV[a\x07\x94V[\x91a\x07\x94V[\x10\x15aGBV[PaG\x8E`Ba\x11\x1AV[aG\xA7aG\xA1aG\x9Ca\x13\xBAV[a\x07\x94V[\x91a\x07\x94V[\x10aG<V[\x90PaG\xCAaG\xC4aG\xBF`Ba\x11\x1AV[a\x07\x94V[\x91a\x07\x94V[\x11_aG5V[aG\xDA_a*\xC6V[aG#V[_\x90_\x91_\x91aH\x01aG\xFBaG\xF5_\x94a*\xC6V[\x95a*\xC6V[\x93a*\xC6V[\x91\x90V[aH\x17\x90aH\x11a'\x95V[Pa>\xCBV[\x90V[aH\"a'\x95V[PaH+a*\x96V[\x90V[`\x02aHGaHM\x92aH?a'\x95V[P`\ra\x10\xEBV[\x01a\x11\x1AV[\x90V[\x7F\xE4\x83)\x05{\xFD\x03\xD5^I\xB5G\x13.9\xCF\xFD\x9C\x18 \xAD{\x9DLS\x07i\x14%\xD1Z\xDF\x90V[aH\xA9aH\xB0\x94aH\x9F``\x94\x98\x97\x95aH\x95`\x80\x86\x01\x9A_\x87\x01\x90a\rqV[` \x85\x01\x90a\x12\xA7V[`@\x83\x01\x90a\x08;V[\x01\x90a\x08;V[V[` \x01\x90V[\x93\x95\x94\x90\x92\x91\x95BaH\xD2aH\xCC\x89a\x07\x94V[\x91a\x07\x94V[\x11aIKW\x91aI=\x91aID\x93aI4aII\x98\x99aI\x1CaH\xF3aHPV[aI\r\x8B\x93\x8BaI\x01a\x05\x12V[\x95\x86\x94` \x86\x01aHtV[` \x82\x01\x81\x03\x82R\x03\x82a\x0CnV[aI.aI(\x82a\x06\xCBV[\x91aH\xB2V[ aX\xD3V[\x92\x90\x91\x92aX\xF0V[\x91\x82aY:V[aU\x95V[V[aIf\x87_\x91\x82\x91c#A\xD7\x87`\xE1\x1B\x83R`\x04\x83\x01a\x08HV[\x03\x90\xFD[\x7Fnq\xED\xAE\x12\xB1\xB9\x7FM\x1F`7\x0F\xEF\x10\x10_\xA2\xFA\xAE\x01&\x11J\x16\x9Cd\x84]a&\xC9\x90V[\x91\x94aI\xD6aI\xE0\x92\x98\x97\x95aI\xCC`\xA0\x96aI\xC2aI\xE7\x9AaI\xB8`\xC0\x8A\x01\x9E_\x8B\x01\x90a\rqV[` \x89\x01\x90a\x12\xA7V[`@\x87\x01\x90a\x12\xA7V[``\x85\x01\x90a\x08;V[`\x80\x83\x01\x90a\x08;V[\x01\x90a\x08;V[V[\x91` aJ\n\x92\x94\x93aJ\x03`@\x82\x01\x96_\x83\x01\x90a\x12\xA7V[\x01\x90a\x12\xA7V[V[\x96\x95\x91\x93\x92\x94\x90\x94BaJ'aJ!\x83a\x07\x94V[\x91a\x07\x94V[\x11aJ\xE1W\x90aJ\x90aJ\x99\x94\x93\x92aJxaJAaIjV[aJi\x8C\x80\x94\x8C\x91aJS\x8D\x91aY}V[\x91\x92aJ]a\x05\x12V[\x97\x88\x96` \x88\x01aI\x8EV[` \x82\x01\x81\x03\x82R\x03\x82a\x0CnV[aJ\x8AaJ\x84\x82a\x06\xCBV[\x91aH\xB2V[ aX\xD3V[\x92\x90\x91\x92aX\xF0V[\x80aJ\xACaJ\xA6\x87a\x07eV[\x91a\x07eV[\x03aJ\xC1WPaJ\xBF\x92\x93\x91\x90\x91aL\x03V[V[\x84\x90aJ\xDD_\x92\x83\x92c%\xC0\x07#`\xE1\x1B\x84R`\x04\x84\x01aI\xE9V[\x03\x90\xFD[aJ\xFC\x90_\x91\x82\x91c1<\x89\x81`\xE1\x1B\x83R`\x04\x83\x01a\x08HV[\x03\x90\xFD[\x90aK\x1B\x91aK\x16aK\x11\x82a/\xBEV[aL\x13V[aK\x1DV[V[\x90aK'\x91aP#V[PV[\x90aK4\x91aK\0V[V[\x90aK@\x90a\x10\xDFV[_R` R`@_ \x90V[aKq\x91aKgaKl\x92aK_a'\x95V[P`\x01aK6V[a:\xDAV[a\x11\x1AV[\x90V[aK~`@a8YV[\x90V[_\x90V[_\x90V[aK\x91aKtV[\x90` \x80\x83aK\x9EaK\x81V[\x81R\x01aK\xA9aK\x85V[\x81RPPV[aK\xB7aK\x89V[\x90V[\x90aK\xCD\x91aK\xC7aK\xAFV[PaY\xB0V[\x90V[aK\xD8a%\xDBV[PaK\xF2aK\xECc\x01\xFF\xC9\xA7`\xE0\x1Ba\x05$V[\x91a\x05$V[\x14\x90V[aK\xFEa9IV[P3\x90V[\x91aL\x11\x92\x91`\x01\x92aY\xD8V[V[aL%\x90aL\x1FaK\xF6V[\x90a[\nV[V[`@\x90aLPaLW\x94\x96\x95\x93\x96aLF``\x84\x01\x98_\x85\x01\x90a\x12\xA7V[` \x83\x01\x90a\x08;V[\x01\x90a\x08;V[V[\x90aLd\x91\x03a\x07\x94V[\x90V[\x92\x91\x92aLu\x81\x83\x90aKLV[\x90\x81aL\x8AaL\x84_\x19a\x07\x94V[\x91a\x07\x94V[\x10aL\x97W[PPP\x90PV[\x81aL\xAAaL\xA4\x87a\x07\x94V[\x91a\x07\x94V[\x10aL\xD0WaL\xC7\x93\x94aL\xBF\x91\x93\x92aLYV[\x90_\x92aY\xD8V[\x80_\x80\x80aL\x90V[PaL\xEF\x84\x92\x91\x92_\x93\x84\x93c}\xC7\xA0\xD9`\xE1\x1B\x85R`\x04\x85\x01aL'V[\x03\x90\xFD[\x91\x82aM\x0FaM\taM\x04_a*\xFEV[a\x07eV[\x91a\x07eV[\x14aMiW\x81aM/aM)aM$_a*\xFEV[a\x07eV[\x91a\x07eV[\x14aMBWaM@\x92\x91\x90\x91a[EV[V[aMeaMN_a*\xFEV[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x12\xB4V[\x03\x90\xFD[aM\x8CaMu_a*\xFEV[_\x91\x82\x91cKc~\x8F`\xE1\x1B\x83R`\x04\x83\x01a\x12\xB4V[\x03\x90\xFD[aM\x98a9\xEAV[aM\x9EWV[_c\xD9<\x06e`\xE0\x1B\x81R\x80aM\xB6`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x90V[aM\xD1aM\xCCaM\xD6\x92aM\xBAV[a\x06\x87V[a\x07\x94V[\x90V[aM\xE3`\x02aM\xBDV[\x90V[aM\xF0`\x0Ca\x11\x1AV[aN\taN\x03aM\xFEaM\xD9V[a\x07\x94V[\x91a\x07\x94V[\x14aN\"WaN aN\x19aM\xD9V[`\x0Ca+eV[V[_c>\xE5\xAE\xB5`\xE0\x1B\x81R\x80aN:`\x04\x82\x01a\t\x13V[\x03\x90\xFD[aNH`\x01aDEV[\x90V[aN]aNVaN>V[`\x0Ca+eV[V[\x80aNzaNtaNo_a*\xFEV[a\x07eV[\x91a\x07eV[\x14aN\x96WaN\x94\x91aN\x8C_a*\xFEV[\x91\x90\x91a[EV[V[aN\xB9aN\xA2_a*\xFEV[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x12\xB4V[\x03\x90\xFD[aN\xC5a%\xDBV[PaN\xDAaN\xD4\x82\x84\x90a>\x18V[\x15a\x05qV[_\x14aOcWaO\x02`\x01aN\xFD_aN\xF5`\x05\x86\x90a/\x84V[\x01\x85\x90a\x14\xE5V[a+/V[\x90aO\x0BaK\xF6V[\x90aOHaOBaO<\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a/xV[\x92a\x10\xDFV[\x92a\x10\xDFV[\x92aOQa\x05\x12V[\x80aO[\x81a\t\x13V[\x03\x90\xA4`\x01\x90V[PP_\x90V[aOqa/tV[PaO{0a<\xE9V[aO\xADaO\xA7\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x07eV[\x91a\x07eV[\x14\x80aO\xE9W[_\x14aO\xDEW\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[aO\xE6a[\xC5V[\x90V[PFaP\x1DaP\x17\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x07\x94V[\x91a\x07\x94V[\x14aO\xB4V[aP+a%\xDBV[PaP7\x81\x83\x90a>\x18V[_\x14aP\xBFWaP^_aPY_aPQ`\x05\x86\x90a/\x84V[\x01\x85\x90a\x14\xE5V[a+/V[\x90aPgaK\xF6V[\x90aP\xA4aP\x9EaP\x98\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x95a/xV[\x92a\x10\xDFV[\x92a\x10\xDFV[\x92aP\xADa\x05\x12V[\x80aP\xB7\x81a\t\x13V[\x03\x90\xA4`\x01\x90V[PP_\x90V[aP\xD9aP\xD4aP\xDE\x92a\x19tV[a\x06\x87V[a\x07\x94V[\x90V[\x91` aQ\x02\x92\x94\x93aP\xFB`@\x82\x01\x96_\x83\x01\x90a\x08;V[\x01\x90a\x19\x7FV[V[aQ\x0Ca>BV[PaQ\x15a>FV[\x81aQ(aQ\"\x83aP\xC5V[\x91a\x07\x94V[\x10\x15aQ;WPaQ8\x90a\\\xCBV[\x90V[\x90aQV_\x92\x83\x92cvi\xFC\x0F`\xE1\x1B\x84R`\x04\x84\x01aP\xE1V[\x03\x90\xFD[T\x90V[\x90V[aQuaQpaQz\x92aQ^V[a\x06\x87V[a\x07\x94V[\x90V[\x90V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[aQ\x97aQ\x9C\x91a\x11\x01V[aQ\x80V[\x90V[aQ\xA9\x90TaQ\x8BV[\x90V[`0\x1C\x90V[`\x01\x80`\xD0\x1B\x03\x16\x90V[aQ\xC9aQ\xCE\x91aQ\xACV[aQ\xB2V[\x90V[aQ\xDB\x90TaQ\xBDV[\x90V[aQ\xF2aQ\xEDaQ\xF7\x92a\x1B\xFBV[a\x06\x87V[a$\x13V[\x90V[\x90aRN\x90aR\x07a%FV[PaR\x13_\x84\x01aQZV[aR\x1C_a*\xC6V[\x90\x80\x80aR2aR,`\x05aQaV[\x91a\x07\x94V[\x11aR\xAFW[P\x90aRI_\x86\x01\x93\x91\x92\x93aQ}V[ac\x03V[\x80aRaaR[_a*\xC6V[\x91a\x07\x94V[\x14_\x14aRwWPPaRs_aQ\xDEV[[\x90V[aR\xA4_\x91aR\x9FaR\x99\x84aR\xAA\x96\x01\x92aR\x93`\x01aDEV[\x90a,\xEEV[\x91aQ}V[ab\xF9V[\x01aQ\xD1V[aRtV[\x80aR\xBDaR\xC3\x92\x91a_\x8EV[\x90a,\xEEV[\x90\x83aR\xF5aR\xEFaR\xEA_aR\xE4\x81\x8C\x01aR\xDF\x89\x91aQ}V[ab\xF9V[\x01aQ\x9FV[a\x19tV[\x91a\x19tV[\x10_\x14aS\x06WP\x90[\x90_aR8V[\x91PaS\x1C\x90aS\x16`\x01aDEV[\x90a0VV[aR\xFFV[aS)ac\x92V[aS1aS3V[V[aS>_`\x0Fa+/V[aSFaK\xF6V[aS|\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA\x91aSsa\x05\x12V[\x91\x82\x91\x82a\x12\xB4V[\x03\x90\xA1V[aS\x89aS!V[V[\x90V[aS\x9CaS\xA1\x91`\ra\x10\xEBV[aS\x8BV[aS\xAD`\x04\x82\x01a\x11\x1AV[aS\xBFaS\xB9_a*\xC6V[\x91a\x07\x94V[\x14aUMWaT;\x90aS\xDEBaS\xD8`\x04\x84\x01a\x11\x1AV[\x90a,\xEEV[\x80aS\xF8aS\xF2aS\xEDa\x1A*V[a\x07\x94V[\x91a\x07\x94V[\x10\x15_\x14aT=WPaT\x18aT\x0F_\x83\x01a\x11\x1AV[`\x01\x83\x01a+eV[aT0aT'`\x02\x83\x01a\x11\x1AV[`\x03\x83\x01a+eV[[`\x04B\x91\x01a+eV[V[\x80aTPaTJ_a*\xC6V[\x91a\x07\x94V[\x11aT\\W[PaT1V[aU>aU,aUG\x92aU\x1BaU\x12aU\x01aT\xEFaT\xB1aT\x80_\x8B\x01a\x11\x1AV[aT\x92\x87aT\x8Ca\x1E\xA2V[\x90a-2V[aT\xABaT\x9Da\x1A*V[aT\xA5a\x1E\xA2V[\x90a-2V[\x91ad\x1AV[\x94aT\xD0aT\xC1`\x02\x8C\x01a\x11\x1AV[\x91aT\xCAa\x1E\xA2V[\x90a-2V[aT\xE9aT\xDBa\x1A*V[aT\xE3a\x1E\xA2V[\x90a-2V[\x91ad\x1AV[\x93aT\xFC`\x01\x8A\x01a\x11\x1AV[a0VV[aU\x0C_\x89\x01a\x11\x1AV[\x90af\x19V[`\x01\x87\x01a+eV[aU'`\x03\x86\x01a\x11\x1AV[a0VV[aU8`\x02\x85\x01a\x11\x1AV[\x90af\x19V[`\x03\x83\x01a+eV[_aTVV[aU[\x90`\x04B\x91\x01a+eV[V[aUea>BV[PaUoCa\\\xCBV[\x90V[\x90V[\x90aU\x8AaU\x85aU\x91\x92a\x10\xDFV[aUrV[\x82TaC,V[\x90UV[\x90aV\x1E\x91aV\x18aU\xA6\x82a9\x8FV[aU\xBB\x84aU\xB6`\t\x86\x90a9MV[aUuV[\x82\x81\x85\x90aU\xFBaU\xF5aU\xEF\x7F14\xE8\xA2\xE6\xD9~\x92\x9A~T\x01\x1E\xA5H]}\x19m\xD5\xF0\xBAMN\xF9X\x03\xE8\xE3\xFC%\x7F\x95a\x10\xDFV[\x92a\x10\xDFV[\x92a\x10\xDFV[\x92aV\x04a\x05\x12V[\x80aV\x0E\x81a\t\x13V[\x03\x90\xA4\x92\x91afEV[\x91af]V[V[\x90\x91aV*a'\x95V[P\x80aV>aV8_a*\xC6V[\x91a\x07\x94V[\x14aV\xBEWaVM\x90Ba,\xEEV[\x80aVgaVaaV\\a\x1A*V[a\x07\x94V[\x91a\x07\x94V[\x10\x15aV\xB9W\x82\x91aV\xABaV\xB1\x92aV\x8CaV\xB6\x96\x91aV\x86a\x1E\xA2V[\x90a-2V[aV\xA5aV\x97a\x1A*V[aV\x9Fa\x1E\xA2V[\x90a-2V[\x91ad\x1AV[\x90a0VV[af\x19V[\x90V[PP\x90V[PPPaV\xCA_a*\xC6V[\x90V[aV\xF4aV\xEFaV\xEAaV\xF9\x93aV\xE2a:\xC1V[P`\na66V[a6LV[ah\x0BV[ah\x8AV[\x90V[aW\x0E\x90aW\x08a'\x95V[Pah\xDBV[\x90V[aW\x19aM\x90V[aW!aW#V[V[aW/`\x01`\x0Fa+/V[aW7aK\xF6V[aWm\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2X\x91aWda\x05\x12V[\x91\x82\x91\x82a\x12\xB4V[\x03\x90\xA1V[aWzaW\x11V[V[\x90V[aW\x87a&\x1FV[PaW\xBC\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0aW\xB6`\x06aW|V[\x90ai\xF6V[\x90V[aW\xC7a&\x1FV[PaW\xFC\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0aW\xF6`\x07aW|V[\x90ai\xF6V[\x90V[aX\x07a%FV[PaX\x13_\x82\x01aQZV[\x80aX&aX _a*\xC6V[\x91a\x07\x94V[\x14_\x14aX<WPPaX8_aQ\xDEV[[\x90V[aXi_\x91aXdaX^\x84aXo\x96\x01\x92aXX`\x01aDEV[\x90a,\xEEV[\x91aQ}V[ab\xF9V[\x01aQ\xD1V[aX9V[\x90\x81aX\x90aX\x8AaX\x85_a*\xFEV[a\x07eV[\x91a\x07eV[\x14aX\xACWaX\xAA\x91\x90aX\xA3_a*\xFEV[\x90\x91a[EV[V[aX\xCFaX\xB8_a*\xFEV[_\x91\x82\x91cKc~\x8F`\xE1\x1B\x83R`\x04\x83\x01a\x12\xB4V[\x03\x90\xFD[aX\xED\x90aX\xDFa/tV[PaX\xE8aOiV[ajDV[\x90V[\x92aY\x0B\x92aY\x14\x94aY\x01a9IV[P\x92\x90\x91\x92aj\xFAV[\x90\x92\x91\x92al%V[\x90V[\x91` aY8\x92\x94\x93aY1`@\x82\x01\x96_\x83\x01\x90a\x12\xA7V[\x01\x90a\x08;V[V[aYC\x81aY}V[\x91aYVaYP\x84a\x07\x94V[\x91a\x07\x94V[\x03aY_WPPV[aYy_\x92\x83\x92c\x01\xD4\xB6#`\xE6\x1B\x84R`\x04\x84\x01aY\x17V[\x03\x90\xFD[aY\x91\x90aY\x89a'\x95V[P`\x08a:\xDAV[aY\xADaY\x9D\x82a\x11\x1AV[\x91aY\xA7\x83a0GV[\x90a+eV[\x90V[\x90aY\xD0aY\xCBaY\xD5\x93aY\xC3aK\xAFV[P`\na66V[a6LV[am\x87V[\x90V[\x90\x92\x81aY\xF5aY\xEFaY\xEA_a*\xFEV[a\x07eV[\x91a\x07eV[\x14aZ\xC0W\x83aZ\x15aZ\x0FaZ\n_a*\xFEV[a\x07eV[\x91a\x07eV[\x14aZ\x99WaZ9\x83aZ4aZ-`\x01\x86\x90aK6V[\x87\x90a:\xDAV[a+eV[aZCW[PPPV[\x91\x90\x91aZ\x8EaZ|aZv\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%\x93a\x10\xDFV[\x93a\x10\xDFV[\x93aZ\x85a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xA3_\x80\x80aZ>V[aZ\xBCaZ\xA5_a*\xFEV[_\x91\x82\x91cJ\x14\x06\xB1`\xE1\x1B\x83R`\x04\x83\x01a\x12\xB4V[\x03\x90\xFD[aZ\xE3aZ\xCC_a*\xFEV[_\x91\x82\x91c\xE6\x02\xDF\x05`\xE0\x1B\x83R`\x04\x83\x01a\x12\xB4V[\x03\x90\xFD[\x91` a[\x08\x92\x94\x93a[\x01`@\x82\x01\x96_\x83\x01\x90a\x12\xA7V[\x01\x90a\rqV[V[\x90a[\x1Fa[\x19\x83\x83\x90a>\x18V[\x15a\x05qV[a['WPPV[a[A_\x92\x83\x92c\xE2Q}?`\xE0\x1B\x84R`\x04\x84\x01aZ\xE7V[\x03\x90\xFD[\x91a[R\x92\x91\x90\x91am\xA8V[V[\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x90V[\x90\x95\x94\x92a[\xC3\x94a[\xB2a[\xBC\x92a[\xA8`\x80\x96a[\x9E`\xA0\x88\x01\x9C_\x89\x01\x90a\rqV[` \x87\x01\x90a\rqV[`@\x85\x01\x90a\rqV[``\x83\x01\x90a\x08;V[\x01\x90a\x12\xA7V[V[a[\xCDa/tV[Pa[\xD6a[TV[a\\M\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91a\\>\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0Fa\\)0a<\xE9V[\x91a\\2a\x05\x12V[\x96\x87\x95` \x87\x01a[xV[` \x82\x01\x81\x03\x82R\x03\x82a\x0CnV[a\\_a\\Y\x82a\x06\xCBV[\x91aH\xB2V[ \x90V[a\\wa\\ra\\|\x92a\x13\x9BV[a\x06\x87V[a\x0E\\V[\x90V[a\\\x88\x90a\\cV[\x90RV[\x91` a\\\xAD\x92\x94\x93a\\\xA6`@\x82\x01\x96_\x83\x01\x90a\\\x7FV[\x01\x90a\x08;V[V[a\\\xC3a\\\xBEa\\\xC8\x92a\x07\x94V[a\x06\x87V[a\x19tV[\x90V[a\\\xD3a>BV[P\x80a\\\xEDa\\\xE7e\xFF\xFF\xFF\xFF\xFF\xFFaP\xC5V[\x91a\x07\x94V[\x11a\\\xFEWa\\\xFB\x90a\\\xAFV[\x90V[`0a]\x1A_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01a\\\x8CV[\x03\x90\xFD[\x90V[a]5a]0a]:\x92a]\x1EV[a\x06\x87V[a\x07\x94V[\x90V[\x90V[a]Ta]Oa]Y\x92a]=V[a\x06\x87V[a\x0E\\V[\x90V[a]{\x90a]ua]oa]\x80\x94a\x0E\\V[\x91a\x07\x94V[\x90a\t\xB4V[a\x07\x94V[\x90V[\x90V[a]\x9Aa]\x95a]\x9F\x92a]\x83V[a\x06\x87V[a\x0E\\V[\x90V[a]\xC1\x90a]\xBBa]\xB5a]\xC6\x94a\x0E\\V[\x91a\x07\x94V[\x90a'\xE4V[a\x07\x94V[\x90V[\x90V[a]\xE0a]\xDBa]\xE5\x92a]\xC9V[a\x06\x87V[a\x07\x94V[\x90V[\x90V[a]\xFFa]\xFAa^\x04\x92a]\xE8V[a\x06\x87V[a\x0E\\V[\x90V[\x90V[a^\x1Ea^\x19a^#\x92a^\x07V[a\x06\x87V[a\x07\x94V[\x90V[\x90V[a^=a^8a^B\x92a^&V[a\x06\x87V[a\x0E\\V[\x90V[\x90V[a^\\a^Wa^a\x92a^EV[a\x06\x87V[a\x07\x94V[\x90V[\x90V[a^{a^va^\x80\x92a^dV[a\x06\x87V[a\x0E\\V[\x90V[\x90V[a^\x9Aa^\x95a^\x9F\x92a^\x83V[a\x06\x87V[a\x07\x94V[\x90V[\x90V[a^\xB9a^\xB4a^\xBE\x92a^\xA2V[a\x06\x87V[a\x0E\\V[\x90V[a^\xD5a^\xD0a^\xDA\x92a^&V[a\x06\x87V[a\x07\x94V[\x90V[a^\xF1a^\xECa^\xF6\x92aM\xBAV[a\x06\x87V[a\x0E\\V[\x90V[a_\ra_\x08a_\x12\x92a^\xA2V[a\x06\x87V[a\x07\x94V[\x90V[a_)a_$a_.\x92aDBV[a\x06\x87V[a\x0E\\V[\x90V[\x90V[a_Ha_Ca_M\x92a_1V[a\x06\x87V[a\x07\x94V[\x90V[\x90a_[\x91\x02a\x07\x94V[\x90V[a_ja_p\x91a\x07\x94V[\x91a\x07\x94V[\x90\x81\x15a_{W\x04\x90V[a-gV[\x90a_\x8B\x91\x01a\x07\x94V[\x90V[a_\x96a'\x95V[P\x80a_\xABa_\xA5`\x01aDEV[\x91a\x07\x94V[\x11\x15ab\xF6W\x80aa\xC0aa\x9Daa\x8Daa}aamaa]aaMaa=aa-aa\x1Daa\r\x8Baa\x07aa\0aa\xC6\x9Fa`\xE0a`\xD0a`\xF0\x92a_\xF2`\x01aDEV[\x90\x80a`\na`\x04`\x01`\x80\x1Ba]!V[\x91a\x07\x94V[\x10\x15ab\xC8W[\x80a`-a`'h\x01\0\0\0\0\0\0\0\0a]\xCCV[\x91a\x07\x94V[\x10\x15ab\x9AW[\x80a`La`Fd\x01\0\0\0\0a^\nV[\x91a\x07\x94V[\x10\x15ablW[\x80a`ia`cb\x01\0\0a^HV[\x91a\x07\x94V[\x10\x15ab>W[\x80a`\x85a`\x7Fa\x01\0a^\x86V[\x91a\x07\x94V[\x10\x15ab\x10W[\x80a`\xA0a`\x9A`\x10a^\xC1V[\x91a\x07\x94V[\x10\x15aa\xE2W[a`\xBAa`\xB4`\x04a^\xF9V[\x91a\x07\x94V[\x10\x15aa\xC9W[a`\xCB`\x03a_4V[a_PV[a`\xDA`\x01a_\x15V[\x90a]\\V[a`\xEA\x81\x86a_^V[\x90a_\x80V[a`\xFA`\x01a_\x15V[\x90a]\\V[\x80\x92a_^V[\x90a_\x80V[aa\x17`\x01a_\x15V[\x90a]\\V[aa'\x81\x8Ca_^V[\x90a_\x80V[aa7`\x01a_\x15V[\x90a]\\V[aaG\x81\x8Aa_^V[\x90a_\x80V[aaW`\x01a_\x15V[\x90a]\\V[aag\x81\x88a_^V[\x90a_\x80V[aaw`\x01a_\x15V[\x90a]\\V[aa\x87\x81\x86a_^V[\x90a_\x80V[aa\x97`\x01a_\x15V[\x90a]\\V[\x91aa\xBAaa\xB4aa\xAF\x85\x80\x94a_^V[a\x07\x94V[\x91a\x07\x94V[\x11an8V[\x90aLYV[\x90V[aa\xDD\x90aa\xD7`\x01a_\x15V[\x90a]\xA2V[a`\xC1V[aa\xF9ab\n\x91aa\xF3`\x04a^\xA5V[\x90a]\\V[\x91ab\x04`\x02a^\xDDV[\x90a]\xA2V[\x90a`\xA7V[ab'ab8\x91ab!`\x08a^gV[\x90a]\\V[\x91ab2`\x04a^\xA5V[\x90a]\xA2V[\x90a`\x8CV[abUabf\x91abO`\x10a^)V[\x90a]\\V[\x91ab``\x08a^gV[\x90a]\xA2V[\x90a`pV[ab\x83ab\x94\x91ab}` a]\xEBV[\x90a]\\V[\x91ab\x8E`\x10a^)V[\x90a]\xA2V[\x90a`SV[ab\xB1ab\xC2\x91ab\xAB`@a]\x86V[\x90a]\\V[\x91ab\xBC` a]\xEBV[\x90a]\xA2V[\x90a`4V[ab\xDFab\xF0\x91ab\xD9`\x80a]@V[\x90a]\\V[\x91ab\xEA`@a]\x86V[\x90a]\xA2V[\x90a`\x11V[\x90V[_R` _ \x01\x90V[\x93\x91\x90\x92ac\x0Fa'\x95V[P[\x81ac$ac\x1E\x83a\x07\x94V[\x91a\x07\x94V[\x10\x15ac\x8AWac5\x82\x82\x90anFV[\x90acK_acE\x88\x85\x90ab\xF9V[\x01aQ\x9FV[ac]acW\x87a\x19tV[\x91a\x19tV[\x11_\x14acmWP\x91[\x91ac\x11V[\x92\x91Pac\x84\x90ac~`\x01aDEV[\x90a0VV[\x90acgV[\x92PP\x91P\x90V[ac\xA3ac\x9Da9\xEAV[\x15a\x05qV[ac\xA9WV[_c\x8D\xFC +`\xE0\x1B\x81R\x80ac\xC1`\x04\x82\x01a\t\x13V[\x03\x90\xFD[ac\xD9ac\xD4ac\xDE\x92a5\0V[a\x06\x87V[a\x07\x94V[\x90V[ac\xEB`\x12ac\xC5V[\x90V[\x90V[ad\x05ad\0ad\n\x92ac\xEEV[a\x06\x87V[a\x07\x94V[\x90V[ad\x17`\x11ac\xF1V[\x90V[\x92\x91\x92ad%a'\x95V[Pad1\x81\x83\x90a_PV[\x91ad:a'\x95V[P_\x19\x81\x83\t\x83\x80\x82\x10\x91\x03\x03\x91\x82ad[adU_a*\xC6V[\x91a\x07\x94V[\x14af\x08W\x85adsadm\x85a\x07\x94V[\x91a\x07\x94V[\x11\x15ae\xD6Wae\xCD\x92\x86ae\xD3\x96\x97\x93ad\xC4\x93ad\x90a'\x95V[P\t\x90\x85\x82\x11\x90\x03\x94\x03\x93`\x01\x83ad\xB1_ad\xAC\x87\x91a*\xC6V[aLYV[\x16\x80\x80\x95\x04\x96\x04\x93\x80_\x03\x04\x01\x90a_PV[\x17\x91ae\xC7ae\xABae\x87aecae?ae\x1Bad\xEC`\x03ad\xE7\x89\x91a_4V[a_PV[ad\xF6`\x02aM\xBDV[\x18ae\x15`\x02ae\x10ae\n\x8B\x85\x90a_PV[\x91aM\xBDV[aLYV[\x90a_PV[ae9`\x02ae4ae.\x8A\x85\x90a_PV[\x91aM\xBDV[aLYV[\x90a_PV[ae]`\x02aeXaeR\x89\x85\x90a_PV[\x91aM\xBDV[aLYV[\x90a_PV[ae\x81`\x02ae|aev\x88\x85\x90a_PV[\x91aM\xBDV[aLYV[\x90a_PV[ae\xA5`\x02ae\xA0ae\x9A\x87\x85\x90a_PV[\x91aM\xBDV[aLYV[\x90a_PV[\x91ae\xC2ae\xBC`\x02\x92\x85\x90a_PV[\x91aM\xBDV[aLYV[\x90a_PV[\x90a_PV[\x90V[af\x03\x86ae\xECae\xE6_a*\xC6V[\x91a\x07\x94V[\x14ae\xF5ac\xE1V[ae\xFDad\rV[\x91antV[an\x98V[PPP\x91af\x16\x91\x92a_^V[\x90V[afB\x91af%a'\x95V[P\x81af9af3\x83a\x07\x94V[\x91a\x07\x94V[\x10\x91\x90\x91antV[\x90V[afW\x90afQa'\x95V[Pa:\xF0V[\x90V[\x90V[\x91\x90\x91\x80afsafm\x85a\x07eV[\x91a\x07eV[\x14\x15\x80ag\xF1W[af\x85W[PPPV[\x80af\xA0af\x9Aaf\x95_a*\xFEV[a\x07eV[\x91a\x07eV[\x03agaW[P\x81af\xC2af\xBCaf\xB7_a*\xFEV[a\x07eV[\x91a\x07eV[\x03af\xCEW[\x80af\x80V[ag\x15ag\x08ag\x0F\x92af\xE4`\n\x86\x90a66V[\x90ag\x02af\xFCaf\xF6`\x01\x93ao\x13V[\x93a6LV[\x91afZV[\x90aofV[\x92\x90a6OV[\x91a6OV[\x91\x90\x91agB\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\x10\xDFV[\x92agWagNa\x05\x12V[\x92\x83\x92\x83a\n\x98V[\x03\x90\xA2_\x80af\xC8V[ag\xA0ag\xA6ag\x99agv`\n\x85\x90a66V[`\x02ag\x93ag\x8Dag\x87\x89ao\x13V[\x93a6LV[\x91afZV[\x90aofV[\x92\x90a6OV[\x91a6OV[\x91\x90\x91ag\xD3\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\x10\xDFV[\x92ag\xE8ag\xDFa\x05\x12V[\x92\x83\x92\x83a\n\x98V[\x03\x90\xA2_af\xA6V[P\x81ah\x05ag\xFF_a*\xC6V[\x91a\x07\x94V[\x11af{V[_ah\x1F\x91ah\x18a'\x95V[P\x01aQZV[\x90V[ah6ah1ah;\x92a\x15IV[a\x06\x87V[a\x07\x94V[\x90V[ahG\x90a]\xEBV[\x90RV[\x91` ahl\x92\x94\x93ahe`@\x82\x01\x96_\x83\x01\x90ah>V[\x01\x90a\x08;V[V[ah\x82ah}ah\x87\x92a\x07\x94V[a\x06\x87V[a\x15IV[\x90V[ah\x92a:\xC1V[P\x80ah\xAAah\xA4c\xFF\xFF\xFF\xFFah\"V[\x91a\x07\x94V[\x11ah\xBBWah\xB8\x90ahnV[\x90V[` ah\xD7_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01ahKV[\x03\x90\xFD[ah\xF2ah\xF7\x91ah\xEAa'\x95V[P`\x08a:\xDAV[a\x11\x1AV[\x90V[\x90V[ai\x11ai\x0Cai\x16\x92ah\xFAV[a\x1B\xFEV[a\r-V[\x90V[ai#`\xFFah\xFDV[\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90aiIaiB\x83a\x0B\x85V[\x80\x94a&$V[\x91`\x01\x81\x16\x90\x81_\x14ai\xA0WP`\x01\x14aidW[PPPV[aiq\x91\x92\x93\x94Pai&V[\x91_\x92[\x81\x84\x10ai\x88WPP\x01\x90_\x80\x80ai_V[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90aiuV[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80ai_V[\x90ai\xC5\x91ai/V[\x90V[\x90ai\xE8ai\xE1\x92ai\xD8a\x05\x12V[\x93\x84\x80\x92ai\xBBV[\x03\x83a\x0CnV[V[ai\xF3\x90ai\xC8V[\x90V[\x90ai\xFFa&\x1FV[Paj\t\x82a/xV[aj\"aj\x1Caj\x17ai\x19V[a\r-V[\x91a\r-V[\x14\x15_\x14aj7WPaj4\x90ao\xF0V[\x90V[ajA\x91Pai\xEAV[\x90V[`B\x91ajOa/tV[P`@Q\x91\x7F\x19\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83R`\x02\x83\x01R`\"\x82\x01R \x90V[_\x90V[aj\x95aj\x9A\x91a\x11\x01V[a(\rV[\x90V[\x90V[aj\xB4aj\xAFaj\xB9\x92aj\x9DV[a\x06\x87V[a\x07\x94V[\x90V[aj\xF1aj\xF8\x94aj\xE7``\x94\x98\x97\x95aj\xDD`\x80\x86\x01\x9A_\x87\x01\x90a\rqV[` \x85\x01\x90a\x0EbV[`@\x83\x01\x90a\rqV[\x01\x90a\rqV[V[\x93\x92\x93ak\x05a9IV[Pak\x0Eaj\x85V[Pak\x17a/tV[Pak!\x85aj\x89V[akSakM\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0aj\xA0V[\x91a\x07\x94V[\x11ak\xE0W\x90akv` \x94\x95_\x94\x93\x92\x93akma\x05\x12V[\x94\x85\x94\x85aj\xBCV[\x83\x80R\x03\x90`\x01Z\xFA\x15ak\xDBWak\x8E_Qa\x1B\xFEV[\x80ak\xA9ak\xA3ak\x9E_a*\xFEV[a\x07eV[\x91a\x07eV[\x14ak\xBFW_\x91ak\xB9_a\x1C\x03V[\x91\x92\x91\x90V[Pak\xC9_a*\xFEV[`\x01\x91ak\xD5_a\x1C\x03V[\x91\x92\x91\x90V[a,\xDEV[PPPak\xEC_a*\xFEV[\x90`\x03\x92\x91\x92\x91\x90V[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x04\x11\x15al\x14WV[ak\xF6V[\x90al#\x82al\nV[V[\x80al8al2_al\x19V[\x91al\x19V[\x14_\x14alCWPPV[\x80alWalQ`\x01al\x19V[\x91al\x19V[\x14_\x14alzW_c\xF6E\xEE\xDF`\xE0\x1B\x81R\x80alv`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x80al\x8Eal\x88`\x02al\x19V[\x91al\x19V[\x14_\x14al\xBCWal\xB8al\xA1\x83aj\x89V[_\x91\x82\x91c\xFC\xE6\x98\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x08HV[\x03\x90\xFD[al\xCFal\xC9`\x03al\x19V[\x91al\x19V[\x14al\xD7WPV[al\xF2\x90_\x91\x82\x91c5\xE2\xF3\x83`\xE2\x1B\x83R`\x04\x83\x01a\r~V[\x03\x90\xFD[_R` _ \x90V[am\x08\x81aQZV[\x82\x10\x15am\"Wam\x1A`\x01\x91al\xF6V[\x91\x02\x01\x90_\x90V[a\x0E\xD7V[\x90am1\x90a\x19tV[\x90RV[\x90am?\x90a$\x13V[\x90RV[\x90amyamp_amSaKtV[\x94amjamb\x83\x83\x01aQ\x9FV[\x83\x88\x01am'V[\x01aQ\xD1V[` \x84\x01am5V[V[am\x84\x90amCV[\x90V[am\xA5\x91_am\x9F\x92am\x98aK\xAFV[P\x01al\xFFV[Pam{V[\x90V[\x92\x91am\xB6\x84\x83\x83\x91ap V[\x83am\xD1am\xCBam\xC6_a*\xFEV[a\x07eV[\x91a\x07eV[\x14am\xE6W[am\xE4\x92\x93\x91\x90\x91aq\xAAV[V[am\xEEa*\x96V[\x93am\xF7aq\x8FV[\x94\x80an\x0Ban\x05\x88a\x07\x94V[\x91a\x07\x94V[\x11an\x18WP\x93Pam\xD7V[\x85\x90an4_\x92\x83\x92c\x0EX\xAE\x93`\xE1\x1B\x84R`\x04\x84\x01a\n\x98V[\x03\x90\xFD[an@a'\x95V[P\x15\x15\x90V[ankanq\x92anUa'\x95V[P\x82\x81\x16\x92\x18ane`\x02aM\xBDV[\x90a-{V[\x90a0VV[\x90V[an\x8Ean\x94\x92\x93an\x84a'\x95V[P\x80\x94\x18\x91an8V[\x90a_PV[\x18\x90V[cNH{q_R` R`$`\x1C\xFD[\x90V[an\xBFan\xBAan\xC4\x92an\xA8V[a\x06\x87V[a\x0E\\V[\x90V[an\xD0\x90an\xABV[\x90RV[\x91` an\xF5\x92\x94\x93an\xEE`@\x82\x01\x96_\x83\x01\x90an\xC7V[\x01\x90a\x08;V[V[ao\x0Bao\x06ao\x10\x92a\x07\x94V[a\x06\x87V[a$\x13V[\x90V[ao\x1Ba%FV[P\x80ao5ao/`\x01\x80`\xD0\x1B\x03a6OV[\x91a\x07\x94V[\x11aoFWaoC\x90an\xF7V[\x90V[`\xD0aob_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01an\xD4V[\x03\x90\xFD[\x90ao\x9Cao\xA2\x93\x92aowa%FV[Pao\x80a%FV[P\x80\x93ao\x95ao\x8Ea>FV[\x94\x92aW\xFFV[\x90\x91av\x12V[\x91ariV[\x91\x90\x91\x90V[ao\xBCao\xB7ao\xC1\x92a]\xE8V[a\x06\x87V[a\x07\x94V[\x90V[6\x907V[\x90ao\xEEao\xD6\x83a8\x91V[\x92` \x80ao\xE4\x86\x93a8nV[\x92\x01\x91\x03\x90ao\xC4V[V[ao\xF8a&\x1FV[Pap\x02\x81ar\xD3V[\x90ap\x15ap\x10` ao\xA8V[ao\xC9V[\x91\x82R` \x82\x01R\x90V[\x91\x90\x91\x80ap>ap8ap3_a*\xFEV[a\x07eV[\x91a\x07eV[\x14_\x14aq\x1FWapbap[\x83apV`\x02a\x11\x1AV[a0VV[`\x02a+eV[[\x82ap~apxaps_a*\xFEV[a\x07eV[\x91a\x07eV[\x14_\x14ap\xF3Wap\xA2ap\x9B\x83ap\x96`\x02a\x11\x1AV[aLYV[`\x02a+eV[[\x91\x90\x91ap\xEEap\xDCap\xD6\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x93a\x10\xDFV[\x93a\x10\xDFV[\x93ap\xE5a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xA3V[aq\x1A\x82aq\x14aq\x05_\x87\x90a:\xDAV[\x91aq\x0F\x83a\x11\x1AV[a_\x80V[\x90a+eV[ap\xA3V[aq2aq-_\x83\x90a:\xDAV[a\x11\x1AV[\x80aqEaq?\x85a\x07\x94V[\x91a\x07\x94V[\x10aqmWaqXaqh\x91\x84\x90aLYV[aqc_\x84\x90a:\xDAV[a+eV[apcV[\x90aq\x8B\x90\x91\x92_\x93\x84\x93c9\x144\xE3`\xE2\x1B\x85R`\x04\x85\x01aL'V[\x03\x90\xFD[aq\x97a'\x95V[Paq\xA7`\x01\x80`\xD0\x1B\x03a6OV[\x90V[\x91ar\x02aq\xFCar\t\x94\x80aq\xD0aq\xCAaq\xC5_a*\xFEV[a\x07eV[\x91a\x07eV[\x14ar:W[\x84aq\xF1aq\xEBaq\xE6_a*\xFEV[a\x07eV[\x91a\x07eV[\x14ar\x0BW[a9\x8FV[\x92a9\x8FV[\x90\x91af]V[V[ar3`\x0B`\x02ar-ar'ar!\x89ao\x13V[\x93a6LV[\x91afZV[\x90aofV[PPaq\xF7V[arb`\x0B`\x01ar\\arVarP\x89ao\x13V[\x93a6LV[\x91afZV[\x90aofV[PPaq\xD6V[\x91ar\x8D_ar\x92\x94arza%FV[Par\x83a%FV[P\x01\x92\x91\x92aQ}V[at\xC4V[\x91\x90\x91\x90V[ar\xACar\xA7ar\xB1\x92ah\xFAV[a\x06\x87V[a\x07\x94V[\x90V[\x90V[ar\xCBar\xC6ar\xD0\x92ar\xB4V[a\x06\x87V[a\x07\x94V[\x90V[ar\xE8ar\xED\x91ar\xE2a'\x95V[Pa/xV[aj\x89V[ar\xF7`\xFFar\x98V[\x16\x80as\x0Cas\x06`\x1Far\xB7V[\x91a\x07\x94V[\x11as\x14W\x90V[_c,\xD4J\xC3`\xE2\x1B\x81R\x80as,`\x04\x82\x01a\t\x13V[\x03\x90\xFD[T\x90V[as>`@a8YV[\x90V[_R` _ \x90V[asS\x81as0V[\x82\x10\x15asmWase`\x01\x91asAV[\x91\x02\x01\x90_\x90V[a\x0E\xD7V[as|\x90Qa\x19tV[\x90V[\x90as\x90e\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x1B\xFEV[\x91\x81\x19\x16\x91\x16\x17\x90V[as\xAEas\xA9as\xB3\x92a\x19tV[a\x06\x87V[a\x19tV[\x90V[\x90V[\x90as\xCEas\xC9as\xD5\x92as\x9AV[as\xB6V[\x82Tas\x7FV[\x90UV[as\xE3\x90Qa$\x13V[\x90V[`0\x1B\x90V[\x90as\xFEe\xFF\xFF\xFF\xFF\xFF\xFF\x19\x91as\xE6V[\x91\x81\x19\x16\x91\x16\x17\x90V[at\x1Cat\x17at!\x92a$\x13V[a\x06\x87V[a$\x13V[\x90V[\x90V[\x90at<at7atC\x92at\x08V[at$V[\x82Tas\xECV[\x90UV[\x90atq` _atw\x94ati\x82\x82\x01atc\x84\x88\x01asrV[\x90as\xB9V[\x01\x92\x01as\xD9V[\x90at'V[V[\x91\x90at\x8AWat\x88\x91atGV[V[a\x0B^V[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15at\xBFW\x82at\xB7\x91`\x01at\xBD\x95\x01\x81UasJV[\x90atyV[V[a\x0CZV[\x90\x92\x91\x92at\xD0a%FV[Pat\xD9a%FV[Pat\xE3\x82as0V[\x80at\xF6at\xF0_a*\xC6V[\x91a\x07\x94V[\x11_\x14au\xC6Wau\x1C\x90au\x16\x84\x91au\x10`\x01aDEV[\x90a,\xEEV[\x90ab\xF9V[\x90au(_\x83\x01aQ\x9FV[\x92au4_\x84\x01aQ\xD1V[\x93\x80auHauB\x85a\x19tV[\x91a\x19tV[\x11au\xAAWau_auY\x84a\x19tV[\x91a\x19tV[\x14_\x14auzWPPauu\x90_\x85\x91\x01at'V[[\x91\x90V[au\xA5\x92Pau\xA0\x86au\x97au\x8Eas4V[\x94_\x86\x01am'V[` \x84\x01am5V[at\x8FV[auvV[_c% `\x1D`\xE0\x1B\x81R\x80au\xC2`\x04\x82\x01a\t\x13V[\x03\x90\xFD[Pau\xF1\x91au\xEC\x85au\xE3au\xDAas4V[\x94_\x86\x01am'V[` \x84\x01am5V[at\x8FV[au\xFA_aQ\xDEV[\x91\x90V[cNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[\x91\x90\x91\x80`\x01\x14av1W`\x02\x03au\xFEWav-\x91a%\xC5V[\x90[V[Pav;\x91a%\x86V[\x90av/V",
    );
    /**Custom error with signature `AccessControlBadConfirmation()` and selector `0x6697b232`.
```solidity
error AccessControlBadConfirmation();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlBadConfirmation {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlBadConfirmation>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlBadConfirmation) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlBadConfirmation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlBadConfirmation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlBadConfirmation()";
            const SELECTOR: [u8; 4] = [102u8, 151u8, 178u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `AccessControlUnauthorizedAccount(address,bytes32)` and selector `0xe2517d3f`.
```solidity
error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub neededRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlUnauthorizedAccount) -> Self {
                (value.account, value.neededRole)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    neededRole: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlUnauthorizedAccount(address,bytes32)";
            const SELECTOR: [u8; 4] = [226u8, 81u8, 125u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.neededRole),
                )
            }
        }
    };
    /**Custom error with signature `AllEmissionsCompleted()` and selector `0x4555892c`.
```solidity
error AllEmissionsCompleted();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AllEmissionsCompleted {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AllEmissionsCompleted> for UnderlyingRustTuple<'_> {
            fn from(value: AllEmissionsCompleted) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AllEmissionsCompleted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AllEmissionsCompleted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AllEmissionsCompleted()";
            const SELECTOR: [u8; 4] = [69u8, 85u8, 137u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `BridgeNotAuthorized()` and selector `0x882eec12`.
```solidity
error BridgeNotAuthorized();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BridgeNotAuthorized {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BridgeNotAuthorized> for UnderlyingRustTuple<'_> {
            fn from(value: BridgeNotAuthorized) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BridgeNotAuthorized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BridgeNotAuthorized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BridgeNotAuthorized()";
            const SELECTOR: [u8; 4] = [136u8, 46u8, 236u8, 18u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `BridgeNotConfigured()` and selector `0x7614917a`.
```solidity
error BridgeNotConfigured();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BridgeNotConfigured {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BridgeNotConfigured> for UnderlyingRustTuple<'_> {
            fn from(value: BridgeNotConfigured) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BridgeNotConfigured {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BridgeNotConfigured {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BridgeNotConfigured()";
            const SELECTOR: [u8; 4] = [118u8, 20u8, 145u8, 122u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `CheckpointUnorderedInsertion()` and selector `0x2520601d`.
```solidity
error CheckpointUnorderedInsertion();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CheckpointUnorderedInsertion {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CheckpointUnorderedInsertion>
        for UnderlyingRustTuple<'_> {
            fn from(value: CheckpointUnorderedInsertion) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for CheckpointUnorderedInsertion {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CheckpointUnorderedInsertion {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CheckpointUnorderedInsertion()";
            const SELECTOR: [u8; 4] = [37u8, 32u8, 96u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignature()` and selector `0xf645eedf`.
```solidity
error ECDSAInvalidSignature();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignature {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignature> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignature) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignature()";
            const SELECTOR: [u8; 4] = [246u8, 69u8, 238u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureLength(uint256)` and selector `0xfce698f7`.
```solidity
error ECDSAInvalidSignatureLength(uint256 length);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureLength {
        #[allow(missing_docs)]
        pub length: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureLength>
        for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureLength) -> Self {
                (value.length,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ECDSAInvalidSignatureLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { length: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureLength(uint256)";
            const SELECTOR: [u8; 4] = [252u8, 230u8, 152u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.length),
                )
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureS(bytes32)` and selector `0xd78bce0c`.
```solidity
error ECDSAInvalidSignatureS(bytes32 s);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureS {
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureS> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureS) -> Self {
                (value.s,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignatureS {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { s: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureS {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureS(bytes32)";
            const SELECTOR: [u8; 4] = [215u8, 139u8, 206u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
        }
    };
    /**Custom error with signature `ERC20ExceededSafeSupply(uint256,uint256)` and selector `0x1cb15d26`.
```solidity
error ERC20ExceededSafeSupply(uint256 increasedSupply, uint256 cap);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20ExceededSafeSupply {
        #[allow(missing_docs)]
        pub increasedSupply: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub cap: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20ExceededSafeSupply> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20ExceededSafeSupply) -> Self {
                (value.increasedSupply, value.cap)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20ExceededSafeSupply {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    increasedSupply: tuple.0,
                    cap: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20ExceededSafeSupply {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20ExceededSafeSupply(uint256,uint256)";
            const SELECTOR: [u8; 4] = [28u8, 177u8, 93u8, 38u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.increasedSupply),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.cap),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InsufficientAllowance(address,uint256,uint256)` and selector `0xfb8f41b2`.
```solidity
error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InsufficientAllowance {
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub allowance: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub needed: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InsufficientAllowance>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InsufficientAllowance) -> Self {
                (value.spender, value.allowance, value.needed)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC20InsufficientAllowance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    spender: tuple.0,
                    allowance: tuple.1,
                    needed: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InsufficientAllowance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InsufficientAllowance(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [251u8, 143u8, 65u8, 178u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allowance),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.needed),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InsufficientBalance(address,uint256,uint256)` and selector `0xe450d38c`.
```solidity
error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InsufficientBalance {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub balance: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub needed: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InsufficientBalance>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InsufficientBalance) -> Self {
                (value.sender, value.balance, value.needed)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC20InsufficientBalance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    sender: tuple.0,
                    balance: tuple.1,
                    needed: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InsufficientBalance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InsufficientBalance(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [228u8, 80u8, 211u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.balance),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.needed),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidApprover(address)` and selector `0xe602df05`.
```solidity
error ERC20InvalidApprover(address approver);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidApprover {
        #[allow(missing_docs)]
        pub approver: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidApprover> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidApprover) -> Self {
                (value.approver,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidApprover {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { approver: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidApprover {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidApprover(address)";
            const SELECTOR: [u8; 4] = [230u8, 2u8, 223u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.approver,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidReceiver(address)` and selector `0xec442f05`.
```solidity
error ERC20InvalidReceiver(address receiver);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidReceiver {
        #[allow(missing_docs)]
        pub receiver: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidReceiver> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidReceiver) -> Self {
                (value.receiver,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidReceiver {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { receiver: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidReceiver {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidReceiver(address)";
            const SELECTOR: [u8; 4] = [236u8, 68u8, 47u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.receiver,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidSender(address)` and selector `0x96c6fd1e`.
```solidity
error ERC20InvalidSender(address sender);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidSender {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidSender> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidSender) -> Self {
                (value.sender,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidSender {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { sender: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidSender {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidSender(address)";
            const SELECTOR: [u8; 4] = [150u8, 198u8, 253u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidSpender(address)` and selector `0x94280d62`.
```solidity
error ERC20InvalidSpender(address spender);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidSpender {
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidSpender> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidSpender) -> Self {
                (value.spender,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidSpender {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { spender: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidSpender {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidSpender(address)";
            const SELECTOR: [u8; 4] = [148u8, 40u8, 13u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC2612ExpiredSignature(uint256)` and selector `0x62791302`.
```solidity
error ERC2612ExpiredSignature(uint256 deadline);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC2612ExpiredSignature {
        #[allow(missing_docs)]
        pub deadline: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC2612ExpiredSignature> for UnderlyingRustTuple<'_> {
            fn from(value: ERC2612ExpiredSignature) -> Self {
                (value.deadline,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC2612ExpiredSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { deadline: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC2612ExpiredSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC2612ExpiredSignature(uint256)";
            const SELECTOR: [u8; 4] = [98u8, 121u8, 19u8, 2u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.deadline),
                )
            }
        }
    };
    /**Custom error with signature `ERC2612InvalidSigner(address,address)` and selector `0x4b800e46`.
```solidity
error ERC2612InvalidSigner(address signer, address owner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC2612InvalidSigner {
        #[allow(missing_docs)]
        pub signer: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC2612InvalidSigner> for UnderlyingRustTuple<'_> {
            fn from(value: ERC2612InvalidSigner) -> Self {
                (value.signer, value.owner)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC2612InvalidSigner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    signer: tuple.0,
                    owner: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC2612InvalidSigner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC2612InvalidSigner(address,address)";
            const SELECTOR: [u8; 4] = [75u8, 128u8, 14u8, 70u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signer,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC5805FutureLookup(uint256,uint48)` and selector `0xecd3f81e`.
```solidity
error ERC5805FutureLookup(uint256 timepoint, uint48 clock);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC5805FutureLookup {
        #[allow(missing_docs)]
        pub timepoint: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub clock: alloy::sol_types::private::primitives::aliases::U48,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<48>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U48,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC5805FutureLookup> for UnderlyingRustTuple<'_> {
            fn from(value: ERC5805FutureLookup) -> Self {
                (value.timepoint, value.clock)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC5805FutureLookup {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    timepoint: tuple.0,
                    clock: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC5805FutureLookup {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC5805FutureLookup(uint256,uint48)";
            const SELECTOR: [u8; 4] = [236u8, 211u8, 248u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.timepoint),
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(&self.clock),
                )
            }
        }
    };
    /**Custom error with signature `ERC6372InconsistentClock()` and selector `0x6ff07140`.
```solidity
error ERC6372InconsistentClock();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC6372InconsistentClock {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC6372InconsistentClock>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC6372InconsistentClock) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC6372InconsistentClock {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC6372InconsistentClock {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC6372InconsistentClock()";
            const SELECTOR: [u8; 4] = [111u8, 240u8, 113u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmissionTooEarly()` and selector `0x3d53c753`.
```solidity
error EmissionTooEarly();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmissionTooEarly {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmissionTooEarly> for UnderlyingRustTuple<'_> {
            fn from(value: EmissionTooEarly) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmissionTooEarly {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmissionTooEarly {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmissionTooEarly()";
            const SELECTOR: [u8; 4] = [61u8, 83u8, 199u8, 83u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmissionsAlreadyStarted()` and selector `0x71d27b7a`.
```solidity
error EmissionsAlreadyStarted();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmissionsAlreadyStarted {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmissionsAlreadyStarted> for UnderlyingRustTuple<'_> {
            fn from(value: EmissionsAlreadyStarted) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmissionsAlreadyStarted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmissionsAlreadyStarted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmissionsAlreadyStarted()";
            const SELECTOR: [u8; 4] = [113u8, 210u8, 123u8, 122u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmissionsNotActive()` and selector `0x66bf2674`.
```solidity
error EmissionsNotActive();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmissionsNotActive {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmissionsNotActive> for UnderlyingRustTuple<'_> {
            fn from(value: EmissionsNotActive) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmissionsNotActive {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmissionsNotActive {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmissionsNotActive()";
            const SELECTOR: [u8; 4] = [102u8, 191u8, 38u8, 116u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmissionsNotStarted()` and selector `0x8f984041`.
```solidity
error EmissionsNotStarted();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmissionsNotStarted {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmissionsNotStarted> for UnderlyingRustTuple<'_> {
            fn from(value: EmissionsNotStarted) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmissionsNotStarted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmissionsNotStarted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmissionsNotStarted()";
            const SELECTOR: [u8; 4] = [143u8, 152u8, 64u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EnforcedPause()` and selector `0xd93c0665`.
```solidity
error EnforcedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EnforcedPause {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EnforcedPause> for UnderlyingRustTuple<'_> {
            fn from(value: EnforcedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EnforcedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EnforcedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EnforcedPause()";
            const SELECTOR: [u8; 4] = [217u8, 60u8, 6u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ExceedsEmissionsSupply()` and selector `0x23064ebd`.
```solidity
error ExceedsEmissionsSupply();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExceedsEmissionsSupply {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExceedsEmissionsSupply> for UnderlyingRustTuple<'_> {
            fn from(value: ExceedsEmissionsSupply) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ExceedsEmissionsSupply {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ExceedsEmissionsSupply {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ExceedsEmissionsSupply()";
            const SELECTOR: [u8; 4] = [35u8, 6u8, 78u8, 189u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ExpectedPause()` and selector `0x8dfc202b`.
```solidity
error ExpectedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExpectedPause {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExpectedPause> for UnderlyingRustTuple<'_> {
            fn from(value: ExpectedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ExpectedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ExpectedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ExpectedPause()";
            const SELECTOR: [u8; 4] = [141u8, 252u8, 32u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InsufficientLimit()` and selector `0x72567b64`.
```solidity
error InsufficientLimit();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientLimit {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientLimit> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientLimit) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientLimit {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientLimit {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientLimit()";
            const SELECTOR: [u8; 4] = [114u8, 86u8, 123u8, 100u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidAccountNonce(address,uint256)` and selector `0x752d88c0`.
```solidity
error InvalidAccountNonce(address account, uint256 currentNonce);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidAccountNonce {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub currentNonce: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidAccountNonce> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidAccountNonce) -> Self {
                (value.account, value.currentNonce)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidAccountNonce {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    currentNonce: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidAccountNonce {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidAccountNonce(address,uint256)";
            const SELECTOR: [u8; 4] = [117u8, 45u8, 136u8, 192u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.currentNonce),
                )
            }
        }
    };
    /**Custom error with signature `InvalidShortString()` and selector `0xb3512b0c`.
```solidity
error InvalidShortString();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidShortString {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidShortString> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidShortString) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidShortString {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidShortString {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidShortString()";
            const SELECTOR: [u8; 4] = [179u8, 81u8, 43u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ReentrancyGuardReentrantCall()` and selector `0x3ee5aeb5`.
```solidity
error ReentrancyGuardReentrantCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ReentrancyGuardReentrantCall {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ReentrancyGuardReentrantCall>
        for UnderlyingRustTuple<'_> {
            fn from(value: ReentrancyGuardReentrantCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ReentrancyGuardReentrantCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ReentrancyGuardReentrantCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ReentrancyGuardReentrantCall()";
            const SELECTOR: [u8; 4] = [62u8, 229u8, 174u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `SafeCastOverflowedUintDowncast(uint8,uint256)` and selector `0x6dfcc650`.
```solidity
error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SafeCastOverflowedUintDowncast {
        #[allow(missing_docs)]
        pub bits: u8,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            u8,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SafeCastOverflowedUintDowncast>
        for UnderlyingRustTuple<'_> {
            fn from(value: SafeCastOverflowedUintDowncast) -> Self {
                (value.bits, value.value)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SafeCastOverflowedUintDowncast {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    bits: tuple.0,
                    value: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SafeCastOverflowedUintDowncast {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SafeCastOverflowedUintDowncast(uint8,uint256)";
            const SELECTOR: [u8; 4] = [109u8, 252u8, 198u8, 80u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.bits),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
        }
    };
    /**Custom error with signature `StringTooLong(string)` and selector `0x305a27a9`.
```solidity
error StringTooLong(string str);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct StringTooLong {
        #[allow(missing_docs)]
        pub str: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<StringTooLong> for UnderlyingRustTuple<'_> {
            fn from(value: StringTooLong) -> Self {
                (value.str,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for StringTooLong {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { str: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for StringTooLong {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "StringTooLong(string)";
            const SELECTOR: [u8; 4] = [48u8, 90u8, 39u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.str,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `VotesExpiredSignature(uint256)` and selector `0x4683af0e`.
```solidity
error VotesExpiredSignature(uint256 expiry);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct VotesExpiredSignature {
        #[allow(missing_docs)]
        pub expiry: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<VotesExpiredSignature> for UnderlyingRustTuple<'_> {
            fn from(value: VotesExpiredSignature) -> Self {
                (value.expiry,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for VotesExpiredSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { expiry: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for VotesExpiredSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "VotesExpiredSignature(uint256)";
            const SELECTOR: [u8; 4] = [70u8, 131u8, 175u8, 14u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expiry),
                )
            }
        }
    };
    /**Custom error with signature `ZeroAddress()` and selector `0xd92e233d`.
```solidity
error ZeroAddress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAddress {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAddress> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAddress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAddress()";
            const SELECTOR: [u8; 4] = [217u8, 46u8, 35u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ZeroAmount()` and selector `0x1f2a2005`.
```solidity
error ZeroAmount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAmount {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAmount> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAmount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAmount()";
            const SELECTOR: [u8; 4] = [31u8, 42u8, 32u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Event with signature `Approval(address,address,uint256)` and selector `0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925`.
```solidity
event Approval(address indexed owner, address indexed spender, uint256 value);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Approval {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Approval {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Approval(address,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                140u8,
                91u8,
                225u8,
                229u8,
                235u8,
                236u8,
                125u8,
                91u8,
                209u8,
                79u8,
                113u8,
                66u8,
                125u8,
                30u8,
                132u8,
                243u8,
                221u8,
                3u8,
                20u8,
                192u8,
                247u8,
                178u8,
                41u8,
                30u8,
                91u8,
                32u8,
                10u8,
                200u8,
                199u8,
                195u8,
                185u8,
                37u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    owner: topics.1,
                    spender: topics.2,
                    value: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.owner.clone(), self.spender.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.owner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.spender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Approval {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Approval> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Approval) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeAuthorized(address)` and selector `0x6cf28439a2daab1b265097227212a5b71e0a76f9ed85e3f815b5a6c3e218eb7f`.
```solidity
event BridgeAuthorized(address indexed bridge);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeAuthorized {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeAuthorized {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeAuthorized(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                108u8,
                242u8,
                132u8,
                57u8,
                162u8,
                218u8,
                171u8,
                27u8,
                38u8,
                80u8,
                151u8,
                34u8,
                114u8,
                18u8,
                165u8,
                183u8,
                30u8,
                10u8,
                118u8,
                249u8,
                237u8,
                133u8,
                227u8,
                248u8,
                21u8,
                181u8,
                166u8,
                195u8,
                226u8,
                24u8,
                235u8,
                127u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { bridge: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.bridge.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridge,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeAuthorized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeAuthorized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeAuthorized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeDataUpdated(bytes,bytes)` and selector `0xb9a2088426f03b30a81c06428094fbfa9e2692739b3241af6b9ab1da4b5546be`.
```solidity
event BridgeDataUpdated(bytes oldData, bytes newData);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeDataUpdated {
        #[allow(missing_docs)]
        pub oldData: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub newData: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeDataUpdated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Bytes,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "BridgeDataUpdated(bytes,bytes)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                185u8,
                162u8,
                8u8,
                132u8,
                38u8,
                240u8,
                59u8,
                48u8,
                168u8,
                28u8,
                6u8,
                66u8,
                128u8,
                148u8,
                251u8,
                250u8,
                158u8,
                38u8,
                146u8,
                115u8,
                155u8,
                50u8,
                65u8,
                175u8,
                107u8,
                154u8,
                177u8,
                218u8,
                75u8,
                85u8,
                70u8,
                190u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldData: data.0,
                    newData: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.oldData,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.newData,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeDataUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeDataUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeDataUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeDeauthorized(address)` and selector `0x02c2f0ba15b03f88b18f4832609a18cf35fc6b3f4546a9992076d7453d1334a8`.
```solidity
event BridgeDeauthorized(address indexed bridge);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeDeauthorized {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeDeauthorized {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeDeauthorized(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                2u8,
                194u8,
                240u8,
                186u8,
                21u8,
                176u8,
                63u8,
                136u8,
                177u8,
                143u8,
                72u8,
                50u8,
                96u8,
                154u8,
                24u8,
                207u8,
                53u8,
                252u8,
                107u8,
                63u8,
                69u8,
                70u8,
                169u8,
                153u8,
                32u8,
                118u8,
                215u8,
                69u8,
                61u8,
                19u8,
                52u8,
                168u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { bridge: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.bridge.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridge,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeDeauthorized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeDeauthorized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeDeauthorized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeLimitsSet(address,uint256,uint256)` and selector `0xaa807d0abf30d91968c7478c66b6d82521a106af13eda036e2036da9af168958`.
```solidity
event BridgeLimitsSet(address indexed bridge, uint256 mintingLimit, uint256 burningLimit);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeLimitsSet {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub mintingLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub burningLimit: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeLimitsSet {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeLimitsSet(address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                170u8,
                128u8,
                125u8,
                10u8,
                191u8,
                48u8,
                217u8,
                25u8,
                104u8,
                199u8,
                71u8,
                140u8,
                102u8,
                182u8,
                216u8,
                37u8,
                33u8,
                161u8,
                6u8,
                175u8,
                19u8,
                237u8,
                160u8,
                54u8,
                226u8,
                3u8,
                109u8,
                169u8,
                175u8,
                22u8,
                137u8,
                88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    bridge: topics.1,
                    mintingLimit: data.0,
                    burningLimit: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.mintingLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.burningLimit),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.bridge.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridge,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeLimitsSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeLimitsSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeLimitsSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeProxyUpdated(address,address)` and selector `0x07015b6a9f05913148fd5faddf2acc9708f305937f3072ca2b4b46faa5d0898b`.
```solidity
event BridgeProxyUpdated(address indexed oldProxy, address indexed newProxy);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeProxyUpdated {
        #[allow(missing_docs)]
        pub oldProxy: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newProxy: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeProxyUpdated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeProxyUpdated(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                7u8,
                1u8,
                91u8,
                106u8,
                159u8,
                5u8,
                145u8,
                49u8,
                72u8,
                253u8,
                95u8,
                173u8,
                223u8,
                42u8,
                204u8,
                151u8,
                8u8,
                243u8,
                5u8,
                147u8,
                127u8,
                48u8,
                114u8,
                202u8,
                43u8,
                75u8,
                70u8,
                250u8,
                165u8,
                208u8,
                137u8,
                139u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldProxy: topics.1,
                    newProxy: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.oldProxy.clone(),
                    self.newProxy.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.oldProxy,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newProxy,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeProxyUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeProxyUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeProxyUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `DelegateChanged(address,address,address)` and selector `0x3134e8a2e6d97e929a7e54011ea5485d7d196dd5f0ba4d4ef95803e8e3fc257f`.
```solidity
event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DelegateChanged {
        #[allow(missing_docs)]
        pub delegator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub fromDelegate: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub toDelegate: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DelegateChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "DelegateChanged(address,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                49u8,
                52u8,
                232u8,
                162u8,
                230u8,
                217u8,
                126u8,
                146u8,
                154u8,
                126u8,
                84u8,
                1u8,
                30u8,
                165u8,
                72u8,
                93u8,
                125u8,
                25u8,
                109u8,
                213u8,
                240u8,
                186u8,
                77u8,
                78u8,
                249u8,
                88u8,
                3u8,
                232u8,
                227u8,
                252u8,
                37u8,
                127u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    delegator: topics.1,
                    fromDelegate: topics.2,
                    toDelegate: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.delegator.clone(),
                    self.fromDelegate.clone(),
                    self.toDelegate.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.delegator,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.fromDelegate,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.toDelegate,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DelegateChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DelegateChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &DelegateChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `DelegateVotesChanged(address,uint256,uint256)` and selector `0xdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a724`.
```solidity
event DelegateVotesChanged(address indexed delegate, uint256 previousVotes, uint256 newVotes);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DelegateVotesChanged {
        #[allow(missing_docs)]
        pub delegate: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub previousVotes: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub newVotes: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DelegateVotesChanged {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "DelegateVotesChanged(address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                222u8,
                194u8,
                186u8,
                205u8,
                210u8,
                240u8,
                91u8,
                89u8,
                222u8,
                52u8,
                218u8,
                155u8,
                82u8,
                61u8,
                255u8,
                139u8,
                228u8,
                46u8,
                94u8,
                56u8,
                232u8,
                24u8,
                200u8,
                47u8,
                219u8,
                11u8,
                174u8,
                119u8,
                67u8,
                135u8,
                167u8,
                36u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    delegate: topics.1,
                    previousVotes: data.0,
                    newVotes: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.previousVotes),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newVotes),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.delegate.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.delegate,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DelegateVotesChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DelegateVotesChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &DelegateVotesChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EIP712DomainChanged()` and selector `0x0a6387c9ea3628b88a633bb4f3b151770f70085117a15f9bf3787cda53f13d31`.
```solidity
event EIP712DomainChanged();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EIP712DomainChanged {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EIP712DomainChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "EIP712DomainChanged()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                10u8,
                99u8,
                135u8,
                201u8,
                234u8,
                54u8,
                40u8,
                184u8,
                138u8,
                99u8,
                59u8,
                180u8,
                243u8,
                177u8,
                81u8,
                119u8,
                15u8,
                112u8,
                8u8,
                81u8,
                23u8,
                161u8,
                95u8,
                155u8,
                243u8,
                120u8,
                124u8,
                218u8,
                83u8,
                241u8,
                61u8,
                49u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EIP712DomainChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EIP712DomainChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EIP712DomainChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EmissionMinted(uint256,uint256,address)` and selector `0x34b73d0c96e9ff4d5311434817c8ecc930e7d2782c5bde2e79dc44b0596755bb`.
```solidity
event EmissionMinted(uint256 epoch, uint256 amount, address indexed destination);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EmissionMinted {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub destination: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EmissionMinted {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "EmissionMinted(uint256,uint256,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                52u8,
                183u8,
                61u8,
                12u8,
                150u8,
                233u8,
                255u8,
                77u8,
                83u8,
                17u8,
                67u8,
                72u8,
                23u8,
                200u8,
                236u8,
                201u8,
                48u8,
                231u8,
                210u8,
                120u8,
                44u8,
                91u8,
                222u8,
                46u8,
                121u8,
                220u8,
                68u8,
                176u8,
                89u8,
                103u8,
                85u8,
                187u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    epoch: data.0,
                    amount: data.1,
                    destination: topics.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epoch),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.destination.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.destination,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EmissionMinted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EmissionMinted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EmissionMinted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EmissionsPaused()` and selector `0x73a5fc60aafeec8f139af22d98e62140e2ce914d1f155c692b427757c3e4014c`.
```solidity
event EmissionsPaused();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EmissionsPaused {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EmissionsPaused {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "EmissionsPaused()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                115u8,
                165u8,
                252u8,
                96u8,
                170u8,
                254u8,
                236u8,
                143u8,
                19u8,
                154u8,
                242u8,
                45u8,
                152u8,
                230u8,
                33u8,
                64u8,
                226u8,
                206u8,
                145u8,
                77u8,
                31u8,
                21u8,
                92u8,
                105u8,
                43u8,
                66u8,
                119u8,
                87u8,
                195u8,
                228u8,
                1u8,
                76u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EmissionsPaused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EmissionsPaused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EmissionsPaused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EmissionsResumed()` and selector `0x4a792a0be42b5672faa40129fc6469072490775ca8d3c34e852d4d55d3a735a9`.
```solidity
event EmissionsResumed();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EmissionsResumed {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EmissionsResumed {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "EmissionsResumed()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                74u8,
                121u8,
                42u8,
                11u8,
                228u8,
                43u8,
                86u8,
                114u8,
                250u8,
                164u8,
                1u8,
                41u8,
                252u8,
                100u8,
                105u8,
                7u8,
                36u8,
                144u8,
                119u8,
                92u8,
                168u8,
                211u8,
                195u8,
                78u8,
                133u8,
                45u8,
                77u8,
                85u8,
                211u8,
                167u8,
                53u8,
                169u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EmissionsResumed {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EmissionsResumed> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EmissionsResumed) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EmissionsStarted(uint256)` and selector `0x1194b034cfa9ab5807494a1d5c667d8b0e6e97f38888742aa3871a3220341160`.
```solidity
event EmissionsStarted(uint256 startTime);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EmissionsStarted {
        #[allow(missing_docs)]
        pub startTime: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EmissionsStarted {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "EmissionsStarted(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                17u8,
                148u8,
                176u8,
                52u8,
                207u8,
                169u8,
                171u8,
                88u8,
                7u8,
                73u8,
                74u8,
                29u8,
                92u8,
                102u8,
                125u8,
                139u8,
                14u8,
                110u8,
                151u8,
                243u8,
                136u8,
                136u8,
                116u8,
                42u8,
                163u8,
                135u8,
                26u8,
                50u8,
                32u8,
                52u8,
                17u8,
                96u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { startTime: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.startTime),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EmissionsStarted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EmissionsStarted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EmissionsStarted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Paused(address)` and selector `0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258`.
```solidity
event Paused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Paused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Paused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Paused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                98u8,
                231u8,
                140u8,
                234u8,
                1u8,
                190u8,
                227u8,
                32u8,
                205u8,
                78u8,
                66u8,
                2u8,
                112u8,
                181u8,
                234u8,
                116u8,
                0u8,
                13u8,
                17u8,
                176u8,
                201u8,
                247u8,
                71u8,
                84u8,
                235u8,
                219u8,
                252u8,
                84u8,
                75u8,
                5u8,
                162u8,
                88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Paused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Paused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Paused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleAdminChanged(bytes32,bytes32,bytes32)` and selector `0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff`.
```solidity
event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleAdminChanged {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub previousAdminRole: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newAdminRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleAdminChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "RoleAdminChanged(bytes32,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    previousAdminRole: topics.2,
                    newAdminRole: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.previousAdminRole.clone(),
                    self.newAdminRole.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.previousAdminRole);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newAdminRole);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleAdminChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleAdminChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleAdminChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleGranted(bytes32,address,address)` and selector `0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d`.
```solidity
event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleGranted {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleGranted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleGranted(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleGranted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleGranted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleGranted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleRevoked(bytes32,address,address)` and selector `0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b`.
```solidity
event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleRevoked {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleRevoked(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Transfer(address,address,uint256)` and selector `0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef`.
```solidity
event Transfer(address indexed from, address indexed to, uint256 value);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Transfer {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Transfer {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Transfer(address,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                221u8,
                242u8,
                82u8,
                173u8,
                27u8,
                226u8,
                200u8,
                155u8,
                105u8,
                194u8,
                176u8,
                104u8,
                252u8,
                55u8,
                141u8,
                170u8,
                149u8,
                43u8,
                167u8,
                241u8,
                99u8,
                196u8,
                161u8,
                22u8,
                40u8,
                245u8,
                90u8,
                77u8,
                245u8,
                35u8,
                179u8,
                239u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    from: topics.1,
                    to: topics.2,
                    value: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.from.clone(), self.to.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.from,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.to,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Transfer {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Transfer> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Transfer) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Unpaused(address)` and selector `0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa`.
```solidity
event Unpaused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Unpaused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Unpaused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Unpaused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                93u8,
                185u8,
                238u8,
                10u8,
                73u8,
                91u8,
                242u8,
                230u8,
                255u8,
                156u8,
                145u8,
                167u8,
                131u8,
                76u8,
                27u8,
                164u8,
                253u8,
                210u8,
                68u8,
                165u8,
                232u8,
                170u8,
                78u8,
                83u8,
                123u8,
                211u8,
                138u8,
                234u8,
                228u8,
                176u8,
                115u8,
                170u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Unpaused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Unpaused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Unpaused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address defaultAdmin, address syndFoundationAddress, address emissionsManager, address pauser);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub defaultAdmin: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub syndFoundationAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub emissionsManager: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub pauser: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (
                        value.defaultAdmin,
                        value.syndFoundationAddress,
                        value.emissionsManager,
                        value.pauser,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        defaultAdmin: tuple.0,
                        syndFoundationAddress: tuple.1,
                        emissionsManager: tuple.2,
                        pauser: tuple.3,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.defaultAdmin,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.syndFoundationAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.emissionsManager,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.pauser,
                    ),
                )
            }
        }
    };
    /**Function with signature `BRIDGE_LIMIT_DURATION()` and selector `0x99127d9b`.
```solidity
function BRIDGE_LIMIT_DURATION() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_LIMIT_DURATIONCall {}
    ///Container type for the return parameters of the [`BRIDGE_LIMIT_DURATION()`](BRIDGE_LIMIT_DURATIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_LIMIT_DURATIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_LIMIT_DURATIONCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_LIMIT_DURATIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_LIMIT_DURATIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_LIMIT_DURATIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_LIMIT_DURATIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_LIMIT_DURATIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for BRIDGE_LIMIT_DURATIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = BRIDGE_LIMIT_DURATIONReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BRIDGE_LIMIT_DURATION()";
            const SELECTOR: [u8; 4] = [153u8, 18u8, 125u8, 155u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `BRIDGE_MANAGER_ROLE()` and selector `0xf75e8512`.
```solidity
function BRIDGE_MANAGER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_MANAGER_ROLECall {}
    ///Container type for the return parameters of the [`BRIDGE_MANAGER_ROLE()`](BRIDGE_MANAGER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_MANAGER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_MANAGER_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_MANAGER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_MANAGER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_MANAGER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_MANAGER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_MANAGER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for BRIDGE_MANAGER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = BRIDGE_MANAGER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BRIDGE_MANAGER_ROLE()";
            const SELECTOR: [u8; 4] = [247u8, 94u8, 133u8, 18u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `CLOCK_MODE()` and selector `0x4bf5d7e9`.
```solidity
function CLOCK_MODE() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CLOCK_MODECall {}
    ///Container type for the return parameters of the [`CLOCK_MODE()`](CLOCK_MODECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CLOCK_MODEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CLOCK_MODECall> for UnderlyingRustTuple<'_> {
                fn from(value: CLOCK_MODECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for CLOCK_MODECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CLOCK_MODEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: CLOCK_MODEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for CLOCK_MODEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for CLOCK_MODECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = CLOCK_MODEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CLOCK_MODE()";
            const SELECTOR: [u8; 4] = [75u8, 245u8, 215u8, 233u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `DEFAULT_ADMIN_ROLE()` and selector `0xa217fddf`.
```solidity
function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLECall {}
    ///Container type for the return parameters of the [`DEFAULT_ADMIN_ROLE()`](DEFAULT_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEFAULT_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DEFAULT_ADMIN_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEFAULT_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [162u8, 23u8, 253u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `DOMAIN_SEPARATOR()` and selector `0x3644e515`.
```solidity
function DOMAIN_SEPARATOR() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DOMAIN_SEPARATORCall {}
    ///Container type for the return parameters of the [`DOMAIN_SEPARATOR()`](DOMAIN_SEPARATORCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DOMAIN_SEPARATORReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DOMAIN_SEPARATORCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DOMAIN_SEPARATORCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DOMAIN_SEPARATORCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DOMAIN_SEPARATORReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DOMAIN_SEPARATORReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DOMAIN_SEPARATORReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DOMAIN_SEPARATORCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DOMAIN_SEPARATORReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DOMAIN_SEPARATOR()";
            const SELECTOR: [u8; 4] = [54u8, 68u8, 229u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSIONS_MANAGER_ROLE()` and selector `0xe3abdfcb`.
```solidity
function EMISSIONS_MANAGER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_MANAGER_ROLECall {}
    ///Container type for the return parameters of the [`EMISSIONS_MANAGER_ROLE()`](EMISSIONS_MANAGER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_MANAGER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_MANAGER_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_MANAGER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSIONS_MANAGER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_MANAGER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_MANAGER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSIONS_MANAGER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSIONS_MANAGER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSIONS_MANAGER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSIONS_MANAGER_ROLE()";
            const SELECTOR: [u8; 4] = [227u8, 171u8, 223u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSIONS_SUPPLY()` and selector `0x6cf01625`.
```solidity
function EMISSIONS_SUPPLY() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_SUPPLYCall {}
    ///Container type for the return parameters of the [`EMISSIONS_SUPPLY()`](EMISSIONS_SUPPLYCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_SUPPLYReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_SUPPLYCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_SUPPLYCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSIONS_SUPPLYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_SUPPLYReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_SUPPLYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSIONS_SUPPLYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSIONS_SUPPLYCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSIONS_SUPPLYReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSIONS_SUPPLY()";
            const SELECTOR: [u8; 4] = [108u8, 240u8, 22u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSION_BUFFER_TIME()` and selector `0x243a30cc`.
```solidity
function EMISSION_BUFFER_TIME() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_BUFFER_TIMECall {}
    ///Container type for the return parameters of the [`EMISSION_BUFFER_TIME()`](EMISSION_BUFFER_TIMECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_BUFFER_TIMEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_BUFFER_TIMECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_BUFFER_TIMECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_BUFFER_TIMECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_BUFFER_TIMEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_BUFFER_TIMEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_BUFFER_TIMEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSION_BUFFER_TIMECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSION_BUFFER_TIMEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSION_BUFFER_TIME()";
            const SELECTOR: [u8; 4] = [36u8, 58u8, 48u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EPOCH_DURATION()` and selector `0xa70b9f0c`.
```solidity
function EPOCH_DURATION() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EPOCH_DURATIONCall {}
    ///Container type for the return parameters of the [`EPOCH_DURATION()`](EPOCH_DURATIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EPOCH_DURATIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EPOCH_DURATIONCall> for UnderlyingRustTuple<'_> {
                fn from(value: EPOCH_DURATIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for EPOCH_DURATIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EPOCH_DURATIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EPOCH_DURATIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EPOCH_DURATIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EPOCH_DURATIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EPOCH_DURATIONReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EPOCH_DURATION()";
            const SELECTOR: [u8; 4] = [167u8, 11u8, 159u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `INITIAL_MINT_SUPPLY()` and selector `0x9b7ef64b`.
```solidity
function INITIAL_MINT_SUPPLY() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct INITIAL_MINT_SUPPLYCall {}
    ///Container type for the return parameters of the [`INITIAL_MINT_SUPPLY()`](INITIAL_MINT_SUPPLYCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct INITIAL_MINT_SUPPLYReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<INITIAL_MINT_SUPPLYCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: INITIAL_MINT_SUPPLYCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for INITIAL_MINT_SUPPLYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<INITIAL_MINT_SUPPLYReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: INITIAL_MINT_SUPPLYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for INITIAL_MINT_SUPPLYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for INITIAL_MINT_SUPPLYCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = INITIAL_MINT_SUPPLYReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "INITIAL_MINT_SUPPLY()";
            const SELECTOR: [u8; 4] = [155u8, 126u8, 246u8, 75u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `PAUSER_ROLE()` and selector `0xe63ab1e9`.
```solidity
function PAUSER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PAUSER_ROLECall {}
    ///Container type for the return parameters of the [`PAUSER_ROLE()`](PAUSER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PAUSER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PAUSER_ROLECall> for UnderlyingRustTuple<'_> {
                fn from(value: PAUSER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for PAUSER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PAUSER_ROLEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: PAUSER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for PAUSER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for PAUSER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = PAUSER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PAUSER_ROLE()";
            const SELECTOR: [u8; 4] = [230u8, 58u8, 177u8, 233u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `PRECISION_MULTIPLIER()` and selector `0xae5ecbc6`.
```solidity
function PRECISION_MULTIPLIER() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PRECISION_MULTIPLIERCall {}
    ///Container type for the return parameters of the [`PRECISION_MULTIPLIER()`](PRECISION_MULTIPLIERCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PRECISION_MULTIPLIERReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PRECISION_MULTIPLIERCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: PRECISION_MULTIPLIERCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for PRECISION_MULTIPLIERCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PRECISION_MULTIPLIERReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: PRECISION_MULTIPLIERReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for PRECISION_MULTIPLIERReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for PRECISION_MULTIPLIERCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = PRECISION_MULTIPLIERReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PRECISION_MULTIPLIER()";
            const SELECTOR: [u8; 4] = [174u8, 94u8, 203u8, 198u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `TOTAL_EPOCHS()` and selector `0x5f15c3c9`.
```solidity
function TOTAL_EPOCHS() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_EPOCHSCall {}
    ///Container type for the return parameters of the [`TOTAL_EPOCHS()`](TOTAL_EPOCHSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_EPOCHSReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_EPOCHSCall> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_EPOCHSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_EPOCHSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_EPOCHSReturn> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_EPOCHSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_EPOCHSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for TOTAL_EPOCHSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = TOTAL_EPOCHSReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TOTAL_EPOCHS()";
            const SELECTOR: [u8; 4] = [95u8, 21u8, 195u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `TOTAL_SUPPLY()` and selector `0x902d55a5`.
```solidity
function TOTAL_SUPPLY() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_SUPPLYCall {}
    ///Container type for the return parameters of the [`TOTAL_SUPPLY()`](TOTAL_SUPPLYCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_SUPPLYReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_SUPPLYCall> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_SUPPLYCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_SUPPLYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_SUPPLYReturn> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_SUPPLYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_SUPPLYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for TOTAL_SUPPLYCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = TOTAL_SUPPLYReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TOTAL_SUPPLY()";
            const SELECTOR: [u8; 4] = [144u8, 45u8, 85u8, 165u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `allowance(address,address)` and selector `0xdd62ed3e`.
```solidity
function allowance(address owner, address spender) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allowanceCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`allowance(address,address)`](allowanceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allowanceReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowanceCall> for UnderlyingRustTuple<'_> {
                fn from(value: allowanceCall) -> Self {
                    (value.owner, value.spender)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for allowanceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        spender: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowanceReturn> for UnderlyingRustTuple<'_> {
                fn from(value: allowanceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for allowanceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for allowanceCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = allowanceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "allowance(address,address)";
            const SELECTOR: [u8; 4] = [221u8, 98u8, 237u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `approve(address,uint256)` and selector `0x095ea7b3`.
```solidity
function approve(address spender, uint256 value) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveCall {
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`approve(address,uint256)`](approveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveCall> for UnderlyingRustTuple<'_> {
                fn from(value: approveCall) -> Self {
                    (value.spender, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        spender: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveReturn> for UnderlyingRustTuple<'_> {
                fn from(value: approveReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for approveCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = approveReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "approve(address,uint256)";
            const SELECTOR: [u8; 4] = [9u8, 94u8, 167u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `authorizedBridges(address)` and selector `0x6fc063be`.
```solidity
function authorizedBridges(address) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct authorizedBridgesCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`authorizedBridges(address)`](authorizedBridgesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct authorizedBridgesReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<authorizedBridgesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: authorizedBridgesCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for authorizedBridgesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<authorizedBridgesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: authorizedBridgesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for authorizedBridgesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for authorizedBridgesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = authorizedBridgesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "authorizedBridges(address)";
            const SELECTOR: [u8; 4] = [111u8, 192u8, 99u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `balanceOf(address)` and selector `0x70a08231`.
```solidity
function balanceOf(address account) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`balanceOf(address)`](balanceOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfCall> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfReturn> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for balanceOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = balanceOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "balanceOf(address)";
            const SELECTOR: [u8; 4] = [112u8, 160u8, 130u8, 49u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeData()` and selector `0x2481bb5c`.
```solidity
function bridgeData() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeDataCall {}
    ///Container type for the return parameters of the [`bridgeData()`](bridgeDataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeDataReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeDataCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeDataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeDataReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeDataReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeDataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeDataReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeData()";
            const SELECTOR: [u8; 4] = [36u8, 129u8, 187u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeLimits(address)` and selector `0x44e181aa`.
```solidity
function bridgeLimits(address) external view returns (uint256 mintingMaxLimit, uint256 mintingCurrentLimit, uint256 burningMaxLimit, uint256 burningCurrentLimit, uint256 lastUpdate);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeLimitsCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`bridgeLimits(address)`](bridgeLimitsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeLimitsReturn {
        #[allow(missing_docs)]
        pub mintingMaxLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub mintingCurrentLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub burningMaxLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub burningCurrentLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub lastUpdate: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeLimitsCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeLimitsCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeLimitsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeLimitsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeLimitsReturn) -> Self {
                    (
                        value.mintingMaxLimit,
                        value.mintingCurrentLimit,
                        value.burningMaxLimit,
                        value.burningCurrentLimit,
                        value.lastUpdate,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeLimitsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        mintingMaxLimit: tuple.0,
                        mintingCurrentLimit: tuple.1,
                        burningMaxLimit: tuple.2,
                        burningCurrentLimit: tuple.3,
                        lastUpdate: tuple.4,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeLimitsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeLimitsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeLimits(address)";
            const SELECTOR: [u8; 4] = [68u8, 225u8, 129u8, 170u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeProxy()` and selector `0xa3d4485b`.
```solidity
function bridgeProxy() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeProxyCall {}
    ///Container type for the return parameters of the [`bridgeProxy()`](bridgeProxyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeProxyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeProxyCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeProxyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeProxyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeProxyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeProxyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeProxyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeProxyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeProxyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeProxy()";
            const SELECTOR: [u8; 4] = [163u8, 212u8, 72u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `burn(address,uint256)` and selector `0x9dc29fac`.
```solidity
function burn(address _user, uint256 _amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burnCall {
        #[allow(missing_docs)]
        pub _user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`burn(address,uint256)`](burnCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burnReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burnCall> for UnderlyingRustTuple<'_> {
                fn from(value: burnCall) -> Self {
                    (value._user, value._amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for burnCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _user: tuple.0,
                        _amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burnReturn> for UnderlyingRustTuple<'_> {
                fn from(value: burnReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for burnReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for burnCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = burnReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "burn(address,uint256)";
            const SELECTOR: [u8; 4] = [157u8, 194u8, 159u8, 172u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `burningCurrentLimitOf(address)` and selector `0x998955d3`.
```solidity
function burningCurrentLimitOf(address _bridge) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burningCurrentLimitOfCall {
        #[allow(missing_docs)]
        pub _bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`burningCurrentLimitOf(address)`](burningCurrentLimitOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burningCurrentLimitOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burningCurrentLimitOfCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: burningCurrentLimitOfCall) -> Self {
                    (value._bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for burningCurrentLimitOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burningCurrentLimitOfReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: burningCurrentLimitOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for burningCurrentLimitOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for burningCurrentLimitOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = burningCurrentLimitOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "burningCurrentLimitOf(address)";
            const SELECTOR: [u8; 4] = [153u8, 137u8, 85u8, 211u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `burningMaxLimitOf(address)` and selector `0xc1eb7137`.
```solidity
function burningMaxLimitOf(address _bridge) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burningMaxLimitOfCall {
        #[allow(missing_docs)]
        pub _bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`burningMaxLimitOf(address)`](burningMaxLimitOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burningMaxLimitOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burningMaxLimitOfCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: burningMaxLimitOfCall) -> Self {
                    (value._bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for burningMaxLimitOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burningMaxLimitOfReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: burningMaxLimitOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for burningMaxLimitOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for burningMaxLimitOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = burningMaxLimitOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "burningMaxLimitOf(address)";
            const SELECTOR: [u8; 4] = [193u8, 235u8, 113u8, 55u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `checkpoints(address,uint32)` and selector `0xf1127ed8`.
```solidity
function checkpoints(address account, uint32 pos) external view returns (Checkpoints.Checkpoint208 memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkpointsCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub pos: u32,
    }
    ///Container type for the return parameters of the [`checkpoints(address,uint32)`](checkpointsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkpointsReturn {
        #[allow(missing_docs)]
        pub _0: <Checkpoints::Checkpoint208 as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, u32);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkpointsCall> for UnderlyingRustTuple<'_> {
                fn from(value: checkpointsCall) -> Self {
                    (value.account, value.pos)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for checkpointsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        account: tuple.0,
                        pos: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Checkpoints::Checkpoint208,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Checkpoints::Checkpoint208 as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkpointsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: checkpointsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for checkpointsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkpointsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkpointsReturn;
            type ReturnTuple<'a> = (Checkpoints::Checkpoint208,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkpoints(address,uint32)";
            const SELECTOR: [u8; 4] = [241u8, 18u8, 126u8, 216u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.pos),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `clock()` and selector `0x91ddadf4`.
```solidity
function clock() external view returns (uint48);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct clockCall {}
    ///Container type for the return parameters of the [`clock()`](clockCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct clockReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U48,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<clockCall> for UnderlyingRustTuple<'_> {
                fn from(value: clockCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for clockCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U48,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<clockReturn> for UnderlyingRustTuple<'_> {
                fn from(value: clockReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for clockReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for clockCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = clockReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "clock()";
            const SELECTOR: [u8; 4] = [145u8, 221u8, 173u8, 244u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `currentEpoch()` and selector `0x76671808`.
```solidity
function currentEpoch() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct currentEpochCall {}
    ///Container type for the return parameters of the [`currentEpoch()`](currentEpochCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct currentEpochReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<currentEpochCall> for UnderlyingRustTuple<'_> {
                fn from(value: currentEpochCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for currentEpochCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<currentEpochReturn> for UnderlyingRustTuple<'_> {
                fn from(value: currentEpochReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for currentEpochReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for currentEpochCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = currentEpochReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "currentEpoch()";
            const SELECTOR: [u8; 4] = [118u8, 103u8, 24u8, 8u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `decimals()` and selector `0x313ce567`.
```solidity
function decimals() external view returns (uint8);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decimalsCall {}
    ///Container type for the return parameters of the [`decimals()`](decimalsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decimalsReturn {
        #[allow(missing_docs)]
        pub _0: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decimalsCall> for UnderlyingRustTuple<'_> {
                fn from(value: decimalsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for decimalsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decimalsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: decimalsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for decimalsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for decimalsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = decimalsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "decimals()";
            const SELECTOR: [u8; 4] = [49u8, 60u8, 229u8, 103u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `delegate(address)` and selector `0x5c19a95c`.
```solidity
function delegate(address delegatee) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateCall {
        #[allow(missing_docs)]
        pub delegatee: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`delegate(address)`](delegateCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateCall> for UnderlyingRustTuple<'_> {
                fn from(value: delegateCall) -> Self {
                    (value.delegatee,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegateCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { delegatee: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateReturn> for UnderlyingRustTuple<'_> {
                fn from(value: delegateReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegateReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for delegateCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = delegateReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "delegate(address)";
            const SELECTOR: [u8; 4] = [92u8, 25u8, 169u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.delegatee,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)` and selector `0xc3cda520`.
```solidity
function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateBySigCall {
        #[allow(missing_docs)]
        pub delegatee: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub expiry: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub v: u8,
        #[allow(missing_docs)]
        pub r: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)`](delegateBySigCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateBySigReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                u8,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateBySigCall> for UnderlyingRustTuple<'_> {
                fn from(value: delegateBySigCall) -> Self {
                    (
                        value.delegatee,
                        value.nonce,
                        value.expiry,
                        value.v,
                        value.r,
                        value.s,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegateBySigCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        delegatee: tuple.0,
                        nonce: tuple.1,
                        expiry: tuple.2,
                        v: tuple.3,
                        r: tuple.4,
                        s: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateBySigReturn> for UnderlyingRustTuple<'_> {
                fn from(value: delegateBySigReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegateBySigReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for delegateBySigCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = delegateBySigReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [195u8, 205u8, 165u8, 32u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.delegatee,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expiry),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.v),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.r),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `delegates(address)` and selector `0x587cde1e`.
```solidity
function delegates(address account) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegatesCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`delegates(address)`](delegatesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegatesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegatesCall> for UnderlyingRustTuple<'_> {
                fn from(value: delegatesCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegatesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegatesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: delegatesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegatesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for delegatesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = delegatesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "delegates(address)";
            const SELECTOR: [u8; 4] = [88u8, 124u8, 222u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `eip712Domain()` and selector `0x84b0196e`.
```solidity
function eip712Domain() external view returns (bytes1 fields, string memory name, string memory version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] memory extensions);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eip712DomainCall {}
    ///Container type for the return parameters of the [`eip712Domain()`](eip712DomainCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eip712DomainReturn {
        #[allow(missing_docs)]
        pub fields: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub name: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub version: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub verifyingContract: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub salt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub extensions: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eip712DomainCall> for UnderlyingRustTuple<'_> {
                fn from(value: eip712DomainCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eip712DomainCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eip712DomainReturn> for UnderlyingRustTuple<'_> {
                fn from(value: eip712DomainReturn) -> Self {
                    (
                        value.fields,
                        value.name,
                        value.version,
                        value.chainId,
                        value.verifyingContract,
                        value.salt,
                        value.extensions,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eip712DomainReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        fields: tuple.0,
                        name: tuple.1,
                        version: tuple.2,
                        chainId: tuple.3,
                        verifyingContract: tuple.4,
                        salt: tuple.5,
                        extensions: tuple.6,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for eip712DomainCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = eip712DomainReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "eip712Domain()";
            const SELECTOR: [u8; 4] = [132u8, 176u8, 25u8, 110u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionSchedule(uint256)` and selector `0x334d0bbd`.
```solidity
function emissionSchedule(uint256) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionScheduleCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`emissionSchedule(uint256)`](emissionScheduleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionScheduleReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionScheduleCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionScheduleCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionScheduleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionScheduleReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionScheduleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionScheduleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionScheduleCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionScheduleReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionSchedule(uint256)";
            const SELECTOR: [u8; 4] = [51u8, 77u8, 11u8, 189u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionsActive()` and selector `0x22a97d9c`.
```solidity
function emissionsActive() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsActiveCall {}
    ///Container type for the return parameters of the [`emissionsActive()`](emissionsActiveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsActiveReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsActiveCall> for UnderlyingRustTuple<'_> {
                fn from(value: emissionsActiveCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for emissionsActiveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsActiveReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsActiveReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsActiveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionsActiveCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionsActiveReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionsActive()";
            const SELECTOR: [u8; 4] = [34u8, 169u8, 125u8, 156u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionsEnded()` and selector `0xa4d7e31d`.
```solidity
function emissionsEnded() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsEndedCall {}
    ///Container type for the return parameters of the [`emissionsEnded()`](emissionsEndedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsEndedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsEndedCall> for UnderlyingRustTuple<'_> {
                fn from(value: emissionsEndedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for emissionsEndedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsEndedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsEndedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsEndedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionsEndedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionsEndedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionsEnded()";
            const SELECTOR: [u8; 4] = [164u8, 215u8, 227u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionsStartTime()` and selector `0x48b0daa6`.
```solidity
function emissionsStartTime() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartTimeCall {}
    ///Container type for the return parameters of the [`emissionsStartTime()`](emissionsStartTimeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartTimeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartTimeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartTimeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartTimeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartTimeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartTimeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartTimeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionsStartTimeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionsStartTimeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionsStartTime()";
            const SELECTOR: [u8; 4] = [72u8, 176u8, 218u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionsStarted()` and selector `0x5adf0021`.
```solidity
function emissionsStarted() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartedCall {}
    ///Container type for the return parameters of the [`emissionsStarted()`](emissionsStartedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionsStartedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionsStartedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionsStarted()";
            const SELECTOR: [u8; 4] = [90u8, 223u8, 0u8, 33u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBridgeConfiguration()` and selector `0x07a1d5fa`.
```solidity
function getBridgeConfiguration() external view returns (address proxy, bytes memory data);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeConfigurationCall {}
    ///Container type for the return parameters of the [`getBridgeConfiguration()`](getBridgeConfigurationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeConfigurationReturn {
        #[allow(missing_docs)]
        pub proxy: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeConfigurationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeConfigurationCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeConfigurationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeConfigurationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeConfigurationReturn) -> Self {
                    (value.proxy, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeConfigurationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        proxy: tuple.0,
                        data: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBridgeConfigurationCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBridgeConfigurationReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBridgeConfiguration()";
            const SELECTOR: [u8; 4] = [7u8, 161u8, 213u8, 250u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBridgeInfo(address)` and selector `0x7c790cab`.
```solidity
function getBridgeInfo(address bridge) external view returns (bool authorized, uint256 mintingMax, uint256 mintingCurrent, uint256 burningMax, uint256 burningCurrent);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeInfoCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getBridgeInfo(address)`](getBridgeInfoCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeInfoReturn {
        #[allow(missing_docs)]
        pub authorized: bool,
        #[allow(missing_docs)]
        pub mintingMax: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub mintingCurrent: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub burningMax: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub burningCurrent: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeInfoCall> for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeInfoCall) -> Self {
                    (value.bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBridgeInfoCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                bool,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeInfoReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeInfoReturn) -> Self {
                    (
                        value.authorized,
                        value.mintingMax,
                        value.mintingCurrent,
                        value.burningMax,
                        value.burningCurrent,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBridgeInfoReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        authorized: tuple.0,
                        mintingMax: tuple.1,
                        mintingCurrent: tuple.2,
                        burningMax: tuple.3,
                        burningCurrent: tuple.4,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBridgeInfoCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBridgeInfoReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBridgeInfo(address)";
            const SELECTOR: [u8; 4] = [124u8, 121u8, 12u8, 171u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBridgeUtilization(address)` and selector `0x23e460d2`.
```solidity
function getBridgeUtilization(address bridge) external view returns (uint256 mintingUtilization, uint256 burningUtilization);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeUtilizationCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getBridgeUtilization(address)`](getBridgeUtilizationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeUtilizationReturn {
        #[allow(missing_docs)]
        pub mintingUtilization: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub burningUtilization: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeUtilizationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeUtilizationCall) -> Self {
                    (value.bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeUtilizationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeUtilizationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeUtilizationReturn) -> Self {
                    (value.mintingUtilization, value.burningUtilization)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeUtilizationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        mintingUtilization: tuple.0,
                        burningUtilization: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBridgeUtilizationCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBridgeUtilizationReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBridgeUtilization(address)";
            const SELECTOR: [u8; 4] = [35u8, 228u8, 96u8, 210u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getCurrentEpochInfo()` and selector `0xbabc394f`.
```solidity
function getCurrentEpochInfo() external view returns (uint256 epoch, uint256 nextEmissionTime, uint256 nextEmissionAmount, bool canMintEmission);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentEpochInfoCall {}
    ///Container type for the return parameters of the [`getCurrentEpochInfo()`](getCurrentEpochInfoCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentEpochInfoReturn {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nextEmissionTime: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nextEmissionAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub canMintEmission: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentEpochInfoCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentEpochInfoCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentEpochInfoCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                bool,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentEpochInfoReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentEpochInfoReturn) -> Self {
                    (
                        value.epoch,
                        value.nextEmissionTime,
                        value.nextEmissionAmount,
                        value.canMintEmission,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentEpochInfoReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epoch: tuple.0,
                        nextEmissionTime: tuple.1,
                        nextEmissionAmount: tuple.2,
                        canMintEmission: tuple.3,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCurrentEpochInfoCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getCurrentEpochInfoReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bool,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCurrentEpochInfo()";
            const SELECTOR: [u8; 4] = [186u8, 188u8, 57u8, 79u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getCurrentTotalSupply()` and selector `0xc02ae754`.
```solidity
function getCurrentTotalSupply() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentTotalSupplyCall {}
    ///Container type for the return parameters of the [`getCurrentTotalSupply()`](getCurrentTotalSupplyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentTotalSupplyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentTotalSupplyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentTotalSupplyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentTotalSupplyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentTotalSupplyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentTotalSupplyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentTotalSupplyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCurrentTotalSupplyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getCurrentTotalSupplyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCurrentTotalSupply()";
            const SELECTOR: [u8; 4] = [192u8, 42u8, 231u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getEmissionSchedule()` and selector `0xaf2aa63b`.
```solidity
function getEmissionSchedule() external view returns (uint256[48] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEmissionScheduleCall {}
    ///Container type for the return parameters of the [`getEmissionSchedule()`](getEmissionScheduleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEmissionScheduleReturn {
        #[allow(missing_docs)]
        pub _0: [alloy::sol_types::private::primitives::aliases::U256; 48usize],
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEmissionScheduleCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getEmissionScheduleCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getEmissionScheduleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    48usize,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                [alloy::sol_types::private::primitives::aliases::U256; 48usize],
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEmissionScheduleReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getEmissionScheduleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getEmissionScheduleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getEmissionScheduleCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getEmissionScheduleReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    48usize,
                >,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getEmissionSchedule()";
            const SELECTOR: [u8; 4] = [175u8, 42u8, 166u8, 59u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getNextEmissionTime()` and selector `0xa5b326be`.
```solidity
function getNextEmissionTime() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getNextEmissionTimeCall {}
    ///Container type for the return parameters of the [`getNextEmissionTime()`](getNextEmissionTimeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getNextEmissionTimeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getNextEmissionTimeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getNextEmissionTimeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getNextEmissionTimeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getNextEmissionTimeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getNextEmissionTimeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getNextEmissionTimeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getNextEmissionTimeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getNextEmissionTimeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getNextEmissionTime()";
            const SELECTOR: [u8; 4] = [165u8, 179u8, 38u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getPastTotalSupply(uint256)` and selector `0x8e539e8c`.
```solidity
function getPastTotalSupply(uint256 timepoint) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastTotalSupplyCall {
        #[allow(missing_docs)]
        pub timepoint: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getPastTotalSupply(uint256)`](getPastTotalSupplyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastTotalSupplyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastTotalSupplyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPastTotalSupplyCall) -> Self {
                    (value.timepoint,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPastTotalSupplyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { timepoint: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastTotalSupplyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPastTotalSupplyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPastTotalSupplyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPastTotalSupplyCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPastTotalSupplyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPastTotalSupply(uint256)";
            const SELECTOR: [u8; 4] = [142u8, 83u8, 158u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.timepoint),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getPastVotes(address,uint256)` and selector `0x3a46b1a8`.
```solidity
function getPastVotes(address account, uint256 timepoint) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastVotesCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub timepoint: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getPastVotes(address,uint256)`](getPastVotesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastVotesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastVotesCall> for UnderlyingRustTuple<'_> {
                fn from(value: getPastVotesCall) -> Self {
                    (value.account, value.timepoint)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getPastVotesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        account: tuple.0,
                        timepoint: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastVotesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getPastVotesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getPastVotesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPastVotesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPastVotesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPastVotes(address,uint256)";
            const SELECTOR: [u8; 4] = [58u8, 70u8, 177u8, 168u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.timepoint),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getPastVotingPower(address,uint256)` and selector `0xb0ca253e`.
```solidity
function getPastVotingPower(address account, uint256 blockNumber) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastVotingPowerCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub blockNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getPastVotingPower(address,uint256)`](getPastVotingPowerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastVotingPowerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastVotingPowerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPastVotingPowerCall) -> Self {
                    (value.account, value.blockNumber)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPastVotingPowerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        account: tuple.0,
                        blockNumber: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastVotingPowerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPastVotingPowerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPastVotingPowerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPastVotingPowerCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPastVotingPowerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPastVotingPower(address,uint256)";
            const SELECTOR: [u8; 4] = [176u8, 202u8, 37u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNumber),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRemainingEmissions()` and selector `0x4bdd36ce`.
```solidity
function getRemainingEmissions() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRemainingEmissionsCall {}
    ///Container type for the return parameters of the [`getRemainingEmissions()`](getRemainingEmissionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRemainingEmissionsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRemainingEmissionsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRemainingEmissionsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRemainingEmissionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRemainingEmissionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRemainingEmissionsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRemainingEmissionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRemainingEmissionsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRemainingEmissionsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRemainingEmissions()";
            const SELECTOR: [u8; 4] = [75u8, 221u8, 54u8, 206u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRoleAdmin(bytes32)` and selector `0x248a9ca3`.
```solidity
function getRoleAdmin(bytes32 role) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getRoleAdmin(bytes32)`](getRoleAdminCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleAdminCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRoleAdminReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleAdmin(bytes32)";
            const SELECTOR: [u8; 4] = [36u8, 138u8, 156u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getVotes(address)` and selector `0x9ab24eb0`.
```solidity
function getVotes(address account) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVotesCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getVotes(address)`](getVotesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVotesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVotesCall> for UnderlyingRustTuple<'_> {
                fn from(value: getVotesCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVotesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVotesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getVotesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVotesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getVotesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getVotesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getVotes(address)";
            const SELECTOR: [u8; 4] = [154u8, 178u8, 78u8, 176u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getVotingPower(address)` and selector `0xbb4d4436`.
```solidity
function getVotingPower(address account) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVotingPowerCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getVotingPower(address)`](getVotingPowerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVotingPowerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVotingPowerCall> for UnderlyingRustTuple<'_> {
                fn from(value: getVotingPowerCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVotingPowerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVotingPowerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getVotingPowerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getVotingPowerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getVotingPowerCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getVotingPowerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getVotingPower(address)";
            const SELECTOR: [u8; 4] = [187u8, 77u8, 68u8, 54u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `grantRole(bytes32,address)` and selector `0x2f2ff15d`.
```solidity
function grantRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`grantRole(bytes32,address)`](grantRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for grantRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = grantRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "grantRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [47u8, 47u8, 241u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `hasRole(bytes32,address)` and selector `0x91d14854`.
```solidity
function hasRole(bytes32 role, address account) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`hasRole(bytes32,address)`](hasRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = hasRoleReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [145u8, 209u8, 72u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isBridge(address)` and selector `0x726600ce`.
```solidity
function isBridge(address bridge) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isBridgeCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`isBridge(address)`](isBridgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isBridgeReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isBridgeCall> for UnderlyingRustTuple<'_> {
                fn from(value: isBridgeCall) -> Self {
                    (value.bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isBridgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isBridgeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isBridgeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isBridgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isBridgeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isBridgeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isBridge(address)";
            const SELECTOR: [u8; 4] = [114u8, 102u8, 0u8, 206u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `mint(address,uint256)` and selector `0x40c10f19`.
```solidity
function mint(address _user, uint256 _amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintCall {
        #[allow(missing_docs)]
        pub _user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`mint(address,uint256)`](mintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintCall> for UnderlyingRustTuple<'_> {
                fn from(value: mintCall) -> Self {
                    (value._user, value._amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _user: tuple.0,
                        _amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintReturn> for UnderlyingRustTuple<'_> {
                fn from(value: mintReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mintCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mintReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mint(address,uint256)";
            const SELECTOR: [u8; 4] = [64u8, 193u8, 15u8, 25u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `mintEmission()` and selector `0x284e1333`.
```solidity
function mintEmission() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintEmissionCall {}
    ///Container type for the return parameters of the [`mintEmission()`](mintEmissionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintEmissionReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintEmissionCall> for UnderlyingRustTuple<'_> {
                fn from(value: mintEmissionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintEmissionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintEmissionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: mintEmissionReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintEmissionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mintEmissionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mintEmissionReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mintEmission()";
            const SELECTOR: [u8; 4] = [40u8, 78u8, 19u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `mintingCurrentLimitOf(address)` and selector `0x651fd268`.
```solidity
function mintingCurrentLimitOf(address _bridge) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintingCurrentLimitOfCall {
        #[allow(missing_docs)]
        pub _bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`mintingCurrentLimitOf(address)`](mintingCurrentLimitOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintingCurrentLimitOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintingCurrentLimitOfCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: mintingCurrentLimitOfCall) -> Self {
                    (value._bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for mintingCurrentLimitOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintingCurrentLimitOfReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: mintingCurrentLimitOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for mintingCurrentLimitOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mintingCurrentLimitOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mintingCurrentLimitOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mintingCurrentLimitOf(address)";
            const SELECTOR: [u8; 4] = [101u8, 31u8, 210u8, 104u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `mintingMaxLimitOf(address)` and selector `0x0c05f82c`.
```solidity
function mintingMaxLimitOf(address _bridge) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintingMaxLimitOfCall {
        #[allow(missing_docs)]
        pub _bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`mintingMaxLimitOf(address)`](mintingMaxLimitOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintingMaxLimitOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintingMaxLimitOfCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: mintingMaxLimitOfCall) -> Self {
                    (value._bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for mintingMaxLimitOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintingMaxLimitOfReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: mintingMaxLimitOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for mintingMaxLimitOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mintingMaxLimitOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mintingMaxLimitOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mintingMaxLimitOf(address)";
            const SELECTOR: [u8; 4] = [12u8, 5u8, 248u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `name()` and selector `0x06fdde03`.
```solidity
function name() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nameCall {}
    ///Container type for the return parameters of the [`name()`](nameCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nameReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nameCall> for UnderlyingRustTuple<'_> {
                fn from(value: nameCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nameCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nameReturn> for UnderlyingRustTuple<'_> {
                fn from(value: nameReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nameReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for nameCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = nameReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "name()";
            const SELECTOR: [u8; 4] = [6u8, 253u8, 222u8, 3u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `nonces(address)` and selector `0x7ecebe00`.
```solidity
function nonces(address owner) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct noncesCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`nonces(address)`](noncesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct noncesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<noncesCall> for UnderlyingRustTuple<'_> {
                fn from(value: noncesCall) -> Self {
                    (value.owner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for noncesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { owner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<noncesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: noncesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for noncesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for noncesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = noncesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "nonces(address)";
            const SELECTOR: [u8; 4] = [126u8, 206u8, 190u8, 0u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `numCheckpoints(address)` and selector `0x6fcfff45`.
```solidity
function numCheckpoints(address account) external view returns (uint32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct numCheckpointsCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`numCheckpoints(address)`](numCheckpointsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct numCheckpointsReturn {
        #[allow(missing_docs)]
        pub _0: u32,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<numCheckpointsCall> for UnderlyingRustTuple<'_> {
                fn from(value: numCheckpointsCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for numCheckpointsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<numCheckpointsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: numCheckpointsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for numCheckpointsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for numCheckpointsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = numCheckpointsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "numCheckpoints(address)";
            const SELECTOR: [u8; 4] = [111u8, 207u8, 255u8, 69u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `pause()` and selector `0x8456cb59`.
```solidity
function pause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseCall {}
    ///Container type for the return parameters of the [`pause()`](pauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pause()";
            const SELECTOR: [u8; 4] = [132u8, 86u8, 203u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `pauseEmissions()` and selector `0x6c33bced`.
```solidity
function pauseEmissions() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseEmissionsCall {}
    ///Container type for the return parameters of the [`pauseEmissions()`](pauseEmissionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseEmissionsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseEmissionsCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseEmissionsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseEmissionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseEmissionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: pauseEmissionsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for pauseEmissionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseEmissionsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseEmissionsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pauseEmissions()";
            const SELECTOR: [u8; 4] = [108u8, 51u8, 188u8, 237u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `paused()` and selector `0x5c975abb`.
```solidity
function paused() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedCall {}
    ///Container type for the return parameters of the [`paused()`](pausedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedCall> for UnderlyingRustTuple<'_> {
                fn from(value: pausedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pausedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pausedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pausedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "paused()";
            const SELECTOR: [u8; 4] = [92u8, 151u8, 90u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `permit(address,address,uint256,uint256,uint8,bytes32,bytes32)` and selector `0xd505accf`.
```solidity
function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct permitCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub deadline: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub v: u8,
        #[allow(missing_docs)]
        pub r: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`permit(address,address,uint256,uint256,uint8,bytes32,bytes32)`](permitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct permitReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                u8,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<permitCall> for UnderlyingRustTuple<'_> {
                fn from(value: permitCall) -> Self {
                    (
                        value.owner,
                        value.spender,
                        value.value,
                        value.deadline,
                        value.v,
                        value.r,
                        value.s,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for permitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        spender: tuple.1,
                        value: tuple.2,
                        deadline: tuple.3,
                        v: tuple.4,
                        r: tuple.5,
                        s: tuple.6,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<permitReturn> for UnderlyingRustTuple<'_> {
                fn from(value: permitReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for permitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for permitCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = permitReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [213u8, 5u8, 172u8, 207u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.deadline),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.v),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.r),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `renounceRole(bytes32,address)` and selector `0x36568abe`.
```solidity
function renounceRole(bytes32 role, address callerConfirmation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub callerConfirmation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`renounceRole(bytes32,address)`](renounceRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleCall) -> Self {
                    (value.role, value.callerConfirmation)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        callerConfirmation: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [54u8, 86u8, 138u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callerConfirmation,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `resumeEmissions()` and selector `0x359b76fe`.
```solidity
function resumeEmissions() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resumeEmissionsCall {}
    ///Container type for the return parameters of the [`resumeEmissions()`](resumeEmissionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resumeEmissionsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resumeEmissionsCall> for UnderlyingRustTuple<'_> {
                fn from(value: resumeEmissionsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for resumeEmissionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resumeEmissionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: resumeEmissionsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for resumeEmissionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for resumeEmissionsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = resumeEmissionsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "resumeEmissions()";
            const SELECTOR: [u8; 4] = [53u8, 155u8, 118u8, 254u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `revokeRole(bytes32,address)` and selector `0xd547741f`.
```solidity
function revokeRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeRole(bytes32,address)`](revokeRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [213u8, 71u8, 116u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBridgeData(bytes)` and selector `0x13beaa5b`.
```solidity
function setBridgeData(bytes memory _bridgeData) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeDataCall {
        #[allow(missing_docs)]
        pub _bridgeData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`setBridgeData(bytes)`](setBridgeDataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeDataReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeDataCall> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeDataCall) -> Self {
                    (value._bridgeData,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgeDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridgeData: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeDataReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeDataReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgeDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBridgeDataCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBridgeDataReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBridgeData(bytes)";
            const SELECTOR: [u8; 4] = [19u8, 190u8, 170u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self._bridgeData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBridgeProxy(address)` and selector `0xa571e184`.
```solidity
function setBridgeProxy(address _bridgeProxy) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeProxyCall {
        #[allow(missing_docs)]
        pub _bridgeProxy: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setBridgeProxy(address)`](setBridgeProxyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeProxyReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeProxyCall> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeProxyCall) -> Self {
                    (value._bridgeProxy,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgeProxyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridgeProxy: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeProxyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeProxyReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setBridgeProxyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBridgeProxyCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBridgeProxyReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBridgeProxy(address)";
            const SELECTOR: [u8; 4] = [165u8, 113u8, 225u8, 132u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridgeProxy,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setLimits(address,uint256,uint256)` and selector `0xa08d5654`.
```solidity
function setLimits(address _bridge, uint256 _mintingLimit, uint256 _burningLimit) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setLimitsCall {
        #[allow(missing_docs)]
        pub _bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _mintingLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _burningLimit: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setLimits(address,uint256,uint256)`](setLimitsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setLimitsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setLimitsCall> for UnderlyingRustTuple<'_> {
                fn from(value: setLimitsCall) -> Self {
                    (value._bridge, value._mintingLimit, value._burningLimit)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setLimitsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _bridge: tuple.0,
                        _mintingLimit: tuple.1,
                        _burningLimit: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setLimitsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setLimitsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setLimitsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setLimitsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setLimitsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setLimits(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [160u8, 141u8, 86u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridge,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._mintingLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._burningLimit),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `startEmissions()` and selector `0x1b02f845`.
```solidity
function startEmissions() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startEmissionsCall {}
    ///Container type for the return parameters of the [`startEmissions()`](startEmissionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startEmissionsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startEmissionsCall> for UnderlyingRustTuple<'_> {
                fn from(value: startEmissionsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for startEmissionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startEmissionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: startEmissionsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for startEmissionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for startEmissionsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = startEmissionsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "startEmissions()";
            const SELECTOR: [u8; 4] = [27u8, 2u8, 248u8, 69u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
```solidity
function supportsInterface(bytes4 interfaceId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceCall {
        #[allow(missing_docs)]
        pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
    }
    ///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceCall) -> Self {
                    (value.interfaceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { interfaceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportsInterfaceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = supportsInterfaceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportsInterface(bytes4)";
            const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.interfaceId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `symbol()` and selector `0x95d89b41`.
```solidity
function symbol() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct symbolCall {}
    ///Container type for the return parameters of the [`symbol()`](symbolCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct symbolReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<symbolCall> for UnderlyingRustTuple<'_> {
                fn from(value: symbolCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for symbolCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<symbolReturn> for UnderlyingRustTuple<'_> {
                fn from(value: symbolReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for symbolReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for symbolCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = symbolReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "symbol()";
            const SELECTOR: [u8; 4] = [149u8, 216u8, 155u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `totalEmissionsMinted()` and selector `0xf508e19d`.
```solidity
function totalEmissionsMinted() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalEmissionsMintedCall {}
    ///Container type for the return parameters of the [`totalEmissionsMinted()`](totalEmissionsMintedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalEmissionsMintedReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalEmissionsMintedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: totalEmissionsMintedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for totalEmissionsMintedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalEmissionsMintedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: totalEmissionsMintedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for totalEmissionsMintedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for totalEmissionsMintedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = totalEmissionsMintedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "totalEmissionsMinted()";
            const SELECTOR: [u8; 4] = [245u8, 8u8, 225u8, 157u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `totalSupply()` and selector `0x18160ddd`.
```solidity
function totalSupply() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalSupplyCall {}
    ///Container type for the return parameters of the [`totalSupply()`](totalSupplyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalSupplyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalSupplyCall> for UnderlyingRustTuple<'_> {
                fn from(value: totalSupplyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalSupplyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalSupplyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: totalSupplyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalSupplyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for totalSupplyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = totalSupplyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "totalSupply()";
            const SELECTOR: [u8; 4] = [24u8, 22u8, 13u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transfer(address,uint256)` and selector `0xa9059cbb`.
```solidity
function transfer(address to, uint256 value) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferCall {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`transfer(address,uint256)`](transferCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferCall> for UnderlyingRustTuple<'_> {
                fn from(value: transferCall) -> Self {
                    (value.to, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferReturn> for UnderlyingRustTuple<'_> {
                fn from(value: transferReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transfer(address,uint256)";
            const SELECTOR: [u8; 4] = [169u8, 5u8, 156u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transferFrom(address,address,uint256)` and selector `0x23b872dd`.
```solidity
function transferFrom(address from, address to, uint256 value) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferFromCall {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`transferFrom(address,address,uint256)`](transferFromCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferFromReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferFromCall> for UnderlyingRustTuple<'_> {
                fn from(value: transferFromCall) -> Self {
                    (value.from, value.to, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        from: tuple.0,
                        to: tuple.1,
                        value: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferFromReturn> for UnderlyingRustTuple<'_> {
                fn from(value: transferFromReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferFromCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferFromReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferFrom(address,address,uint256)";
            const SELECTOR: [u8; 4] = [35u8, 184u8, 114u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `unpause()` and selector `0x3f4ba83a`.
```solidity
function unpause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseCall {}
    ///Container type for the return parameters of the [`unpause()`](unpauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unpauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = unpauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unpause()";
            const SELECTOR: [u8; 4] = [63u8, 75u8, 168u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`SyndicateToken`](self) function calls.
    pub enum SyndicateTokenCalls {
        #[allow(missing_docs)]
        BRIDGE_LIMIT_DURATION(BRIDGE_LIMIT_DURATIONCall),
        #[allow(missing_docs)]
        BRIDGE_MANAGER_ROLE(BRIDGE_MANAGER_ROLECall),
        #[allow(missing_docs)]
        CLOCK_MODE(CLOCK_MODECall),
        #[allow(missing_docs)]
        DEFAULT_ADMIN_ROLE(DEFAULT_ADMIN_ROLECall),
        #[allow(missing_docs)]
        DOMAIN_SEPARATOR(DOMAIN_SEPARATORCall),
        #[allow(missing_docs)]
        EMISSIONS_MANAGER_ROLE(EMISSIONS_MANAGER_ROLECall),
        #[allow(missing_docs)]
        EMISSIONS_SUPPLY(EMISSIONS_SUPPLYCall),
        #[allow(missing_docs)]
        EMISSION_BUFFER_TIME(EMISSION_BUFFER_TIMECall),
        #[allow(missing_docs)]
        EPOCH_DURATION(EPOCH_DURATIONCall),
        #[allow(missing_docs)]
        INITIAL_MINT_SUPPLY(INITIAL_MINT_SUPPLYCall),
        #[allow(missing_docs)]
        PAUSER_ROLE(PAUSER_ROLECall),
        #[allow(missing_docs)]
        PRECISION_MULTIPLIER(PRECISION_MULTIPLIERCall),
        #[allow(missing_docs)]
        TOTAL_EPOCHS(TOTAL_EPOCHSCall),
        #[allow(missing_docs)]
        TOTAL_SUPPLY(TOTAL_SUPPLYCall),
        #[allow(missing_docs)]
        allowance(allowanceCall),
        #[allow(missing_docs)]
        approve(approveCall),
        #[allow(missing_docs)]
        authorizedBridges(authorizedBridgesCall),
        #[allow(missing_docs)]
        balanceOf(balanceOfCall),
        #[allow(missing_docs)]
        bridgeData(bridgeDataCall),
        #[allow(missing_docs)]
        bridgeLimits(bridgeLimitsCall),
        #[allow(missing_docs)]
        bridgeProxy(bridgeProxyCall),
        #[allow(missing_docs)]
        burn(burnCall),
        #[allow(missing_docs)]
        burningCurrentLimitOf(burningCurrentLimitOfCall),
        #[allow(missing_docs)]
        burningMaxLimitOf(burningMaxLimitOfCall),
        #[allow(missing_docs)]
        checkpoints(checkpointsCall),
        #[allow(missing_docs)]
        clock(clockCall),
        #[allow(missing_docs)]
        currentEpoch(currentEpochCall),
        #[allow(missing_docs)]
        decimals(decimalsCall),
        #[allow(missing_docs)]
        delegate(delegateCall),
        #[allow(missing_docs)]
        delegateBySig(delegateBySigCall),
        #[allow(missing_docs)]
        delegates(delegatesCall),
        #[allow(missing_docs)]
        eip712Domain(eip712DomainCall),
        #[allow(missing_docs)]
        emissionSchedule(emissionScheduleCall),
        #[allow(missing_docs)]
        emissionsActive(emissionsActiveCall),
        #[allow(missing_docs)]
        emissionsEnded(emissionsEndedCall),
        #[allow(missing_docs)]
        emissionsStartTime(emissionsStartTimeCall),
        #[allow(missing_docs)]
        emissionsStarted(emissionsStartedCall),
        #[allow(missing_docs)]
        getBridgeConfiguration(getBridgeConfigurationCall),
        #[allow(missing_docs)]
        getBridgeInfo(getBridgeInfoCall),
        #[allow(missing_docs)]
        getBridgeUtilization(getBridgeUtilizationCall),
        #[allow(missing_docs)]
        getCurrentEpochInfo(getCurrentEpochInfoCall),
        #[allow(missing_docs)]
        getCurrentTotalSupply(getCurrentTotalSupplyCall),
        #[allow(missing_docs)]
        getEmissionSchedule(getEmissionScheduleCall),
        #[allow(missing_docs)]
        getNextEmissionTime(getNextEmissionTimeCall),
        #[allow(missing_docs)]
        getPastTotalSupply(getPastTotalSupplyCall),
        #[allow(missing_docs)]
        getPastVotes(getPastVotesCall),
        #[allow(missing_docs)]
        getPastVotingPower(getPastVotingPowerCall),
        #[allow(missing_docs)]
        getRemainingEmissions(getRemainingEmissionsCall),
        #[allow(missing_docs)]
        getRoleAdmin(getRoleAdminCall),
        #[allow(missing_docs)]
        getVotes(getVotesCall),
        #[allow(missing_docs)]
        getVotingPower(getVotingPowerCall),
        #[allow(missing_docs)]
        grantRole(grantRoleCall),
        #[allow(missing_docs)]
        hasRole(hasRoleCall),
        #[allow(missing_docs)]
        isBridge(isBridgeCall),
        #[allow(missing_docs)]
        mint(mintCall),
        #[allow(missing_docs)]
        mintEmission(mintEmissionCall),
        #[allow(missing_docs)]
        mintingCurrentLimitOf(mintingCurrentLimitOfCall),
        #[allow(missing_docs)]
        mintingMaxLimitOf(mintingMaxLimitOfCall),
        #[allow(missing_docs)]
        name(nameCall),
        #[allow(missing_docs)]
        nonces(noncesCall),
        #[allow(missing_docs)]
        numCheckpoints(numCheckpointsCall),
        #[allow(missing_docs)]
        pause(pauseCall),
        #[allow(missing_docs)]
        pauseEmissions(pauseEmissionsCall),
        #[allow(missing_docs)]
        paused(pausedCall),
        #[allow(missing_docs)]
        permit(permitCall),
        #[allow(missing_docs)]
        renounceRole(renounceRoleCall),
        #[allow(missing_docs)]
        resumeEmissions(resumeEmissionsCall),
        #[allow(missing_docs)]
        revokeRole(revokeRoleCall),
        #[allow(missing_docs)]
        setBridgeData(setBridgeDataCall),
        #[allow(missing_docs)]
        setBridgeProxy(setBridgeProxyCall),
        #[allow(missing_docs)]
        setLimits(setLimitsCall),
        #[allow(missing_docs)]
        startEmissions(startEmissionsCall),
        #[allow(missing_docs)]
        supportsInterface(supportsInterfaceCall),
        #[allow(missing_docs)]
        symbol(symbolCall),
        #[allow(missing_docs)]
        totalEmissionsMinted(totalEmissionsMintedCall),
        #[allow(missing_docs)]
        totalSupply(totalSupplyCall),
        #[allow(missing_docs)]
        transfer(transferCall),
        #[allow(missing_docs)]
        transferFrom(transferFromCall),
        #[allow(missing_docs)]
        unpause(unpauseCall),
    }
    #[automatically_derived]
    impl SyndicateTokenCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 255u8, 201u8, 167u8],
            [6u8, 253u8, 222u8, 3u8],
            [7u8, 161u8, 213u8, 250u8],
            [9u8, 94u8, 167u8, 179u8],
            [12u8, 5u8, 248u8, 44u8],
            [19u8, 190u8, 170u8, 91u8],
            [24u8, 22u8, 13u8, 221u8],
            [27u8, 2u8, 248u8, 69u8],
            [34u8, 169u8, 125u8, 156u8],
            [35u8, 184u8, 114u8, 221u8],
            [35u8, 228u8, 96u8, 210u8],
            [36u8, 58u8, 48u8, 204u8],
            [36u8, 129u8, 187u8, 92u8],
            [36u8, 138u8, 156u8, 163u8],
            [40u8, 78u8, 19u8, 51u8],
            [47u8, 47u8, 241u8, 93u8],
            [49u8, 60u8, 229u8, 103u8],
            [51u8, 77u8, 11u8, 189u8],
            [53u8, 155u8, 118u8, 254u8],
            [54u8, 68u8, 229u8, 21u8],
            [54u8, 86u8, 138u8, 190u8],
            [58u8, 70u8, 177u8, 168u8],
            [63u8, 75u8, 168u8, 58u8],
            [64u8, 193u8, 15u8, 25u8],
            [68u8, 225u8, 129u8, 170u8],
            [72u8, 176u8, 218u8, 166u8],
            [75u8, 221u8, 54u8, 206u8],
            [75u8, 245u8, 215u8, 233u8],
            [88u8, 124u8, 222u8, 30u8],
            [90u8, 223u8, 0u8, 33u8],
            [92u8, 25u8, 169u8, 92u8],
            [92u8, 151u8, 90u8, 187u8],
            [95u8, 21u8, 195u8, 201u8],
            [101u8, 31u8, 210u8, 104u8],
            [108u8, 51u8, 188u8, 237u8],
            [108u8, 240u8, 22u8, 37u8],
            [111u8, 192u8, 99u8, 190u8],
            [111u8, 207u8, 255u8, 69u8],
            [112u8, 160u8, 130u8, 49u8],
            [114u8, 102u8, 0u8, 206u8],
            [118u8, 103u8, 24u8, 8u8],
            [124u8, 121u8, 12u8, 171u8],
            [126u8, 206u8, 190u8, 0u8],
            [132u8, 86u8, 203u8, 89u8],
            [132u8, 176u8, 25u8, 110u8],
            [142u8, 83u8, 158u8, 140u8],
            [144u8, 45u8, 85u8, 165u8],
            [145u8, 209u8, 72u8, 84u8],
            [145u8, 221u8, 173u8, 244u8],
            [149u8, 216u8, 155u8, 65u8],
            [153u8, 18u8, 125u8, 155u8],
            [153u8, 137u8, 85u8, 211u8],
            [154u8, 178u8, 78u8, 176u8],
            [155u8, 126u8, 246u8, 75u8],
            [157u8, 194u8, 159u8, 172u8],
            [160u8, 141u8, 86u8, 84u8],
            [162u8, 23u8, 253u8, 223u8],
            [163u8, 212u8, 72u8, 91u8],
            [164u8, 215u8, 227u8, 29u8],
            [165u8, 113u8, 225u8, 132u8],
            [165u8, 179u8, 38u8, 190u8],
            [167u8, 11u8, 159u8, 12u8],
            [169u8, 5u8, 156u8, 187u8],
            [174u8, 94u8, 203u8, 198u8],
            [175u8, 42u8, 166u8, 59u8],
            [176u8, 202u8, 37u8, 62u8],
            [186u8, 188u8, 57u8, 79u8],
            [187u8, 77u8, 68u8, 54u8],
            [192u8, 42u8, 231u8, 84u8],
            [193u8, 235u8, 113u8, 55u8],
            [195u8, 205u8, 165u8, 32u8],
            [213u8, 5u8, 172u8, 207u8],
            [213u8, 71u8, 116u8, 31u8],
            [221u8, 98u8, 237u8, 62u8],
            [227u8, 171u8, 223u8, 203u8],
            [230u8, 58u8, 177u8, 233u8],
            [241u8, 18u8, 126u8, 216u8],
            [245u8, 8u8, 225u8, 157u8],
            [247u8, 94u8, 133u8, 18u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndicateTokenCalls {
        const NAME: &'static str = "SyndicateTokenCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 79usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::BRIDGE_LIMIT_DURATION(_) => {
                    <BRIDGE_LIMIT_DURATIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::BRIDGE_MANAGER_ROLE(_) => {
                    <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::CLOCK_MODE(_) => {
                    <CLOCK_MODECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DEFAULT_ADMIN_ROLE(_) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DOMAIN_SEPARATOR(_) => {
                    <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSIONS_MANAGER_ROLE(_) => {
                    <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSIONS_SUPPLY(_) => {
                    <EMISSIONS_SUPPLYCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSION_BUFFER_TIME(_) => {
                    <EMISSION_BUFFER_TIMECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EPOCH_DURATION(_) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::INITIAL_MINT_SUPPLY(_) => {
                    <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::PAUSER_ROLE(_) => {
                    <PAUSER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::PRECISION_MULTIPLIER(_) => {
                    <PRECISION_MULTIPLIERCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::TOTAL_EPOCHS(_) => {
                    <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::TOTAL_SUPPLY(_) => {
                    <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::allowance(_) => {
                    <allowanceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::approve(_) => <approveCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::authorizedBridges(_) => {
                    <authorizedBridgesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::balanceOf(_) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeData(_) => {
                    <bridgeDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeLimits(_) => {
                    <bridgeLimitsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeProxy(_) => {
                    <bridgeProxyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::burn(_) => <burnCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::burningCurrentLimitOf(_) => {
                    <burningCurrentLimitOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::burningMaxLimitOf(_) => {
                    <burningMaxLimitOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkpoints(_) => {
                    <checkpointsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::clock(_) => <clockCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::currentEpoch(_) => {
                    <currentEpochCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::decimals(_) => <decimalsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::delegate(_) => <delegateCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::delegateBySig(_) => {
                    <delegateBySigCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::delegates(_) => {
                    <delegatesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::eip712Domain(_) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionSchedule(_) => {
                    <emissionScheduleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionsActive(_) => {
                    <emissionsActiveCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionsEnded(_) => {
                    <emissionsEndedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionsStartTime(_) => {
                    <emissionsStartTimeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionsStarted(_) => {
                    <emissionsStartedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBridgeConfiguration(_) => {
                    <getBridgeConfigurationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBridgeInfo(_) => {
                    <getBridgeInfoCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBridgeUtilization(_) => {
                    <getBridgeUtilizationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCurrentEpochInfo(_) => {
                    <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCurrentTotalSupply(_) => {
                    <getCurrentTotalSupplyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getEmissionSchedule(_) => {
                    <getEmissionScheduleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getNextEmissionTime(_) => {
                    <getNextEmissionTimeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPastTotalSupply(_) => {
                    <getPastTotalSupplyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPastVotes(_) => {
                    <getPastVotesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPastVotingPower(_) => {
                    <getPastVotingPowerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRemainingEmissions(_) => {
                    <getRemainingEmissionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleAdmin(_) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getVotes(_) => <getVotesCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getVotingPower(_) => {
                    <getVotingPowerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::grantRole(_) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasRole(_) => <hasRoleCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::isBridge(_) => <isBridgeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::mint(_) => <mintCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::mintEmission(_) => {
                    <mintEmissionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::mintingCurrentLimitOf(_) => {
                    <mintingCurrentLimitOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::mintingMaxLimitOf(_) => {
                    <mintingMaxLimitOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::name(_) => <nameCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::nonces(_) => <noncesCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::numCheckpoints(_) => {
                    <numCheckpointsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::pause(_) => <pauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pauseEmissions(_) => {
                    <pauseEmissionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::paused(_) => <pausedCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::permit(_) => <permitCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::renounceRole(_) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::resumeEmissions(_) => {
                    <resumeEmissionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeRole(_) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBridgeData(_) => {
                    <setBridgeDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBridgeProxy(_) => {
                    <setBridgeProxyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setLimits(_) => {
                    <setLimitsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::startEmissions(_) => {
                    <startEmissionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::supportsInterface(_) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::symbol(_) => <symbolCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::totalEmissionsMinted(_) => {
                    <totalEmissionsMintedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::totalSupply(_) => {
                    <totalSupplyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transfer(_) => <transferCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::transferFrom(_) => {
                    <transferFromCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::unpause(_) => <unpauseCall as alloy_sol_types::SolCall>::SELECTOR,
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<SyndicateTokenCalls>] = &[
                {
                    fn supportsInterface(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn name(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <nameCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::name)
                    }
                    name
                },
                {
                    fn getBridgeConfiguration(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getBridgeConfigurationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getBridgeConfiguration)
                    }
                    getBridgeConfiguration
                },
                {
                    fn approve(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <approveCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::approve)
                    }
                    approve
                },
                {
                    fn mintingMaxLimitOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <mintingMaxLimitOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::mintingMaxLimitOf)
                    }
                    mintingMaxLimitOf
                },
                {
                    fn setBridgeData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <setBridgeDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::setBridgeData)
                    }
                    setBridgeData
                },
                {
                    fn totalSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <totalSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::totalSupply)
                    }
                    totalSupply
                },
                {
                    fn startEmissions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <startEmissionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::startEmissions)
                    }
                    startEmissions
                },
                {
                    fn emissionsActive(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <emissionsActiveCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::emissionsActive)
                    }
                    emissionsActive
                },
                {
                    fn transferFrom(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <transferFromCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::transferFrom)
                    }
                    transferFrom
                },
                {
                    fn getBridgeUtilization(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getBridgeUtilizationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getBridgeUtilization)
                    }
                    getBridgeUtilization
                },
                {
                    fn EMISSION_BUFFER_TIME(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <EMISSION_BUFFER_TIMECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::EMISSION_BUFFER_TIME)
                    }
                    EMISSION_BUFFER_TIME
                },
                {
                    fn bridgeData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <bridgeDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::bridgeData)
                    }
                    bridgeData
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn mintEmission(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <mintEmissionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::mintEmission)
                    }
                    mintEmission
                },
                {
                    fn grantRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn decimals(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <decimalsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::decimals)
                    }
                    decimals
                },
                {
                    fn emissionSchedule(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <emissionScheduleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::emissionSchedule)
                    }
                    emissionSchedule
                },
                {
                    fn resumeEmissions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <resumeEmissionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::resumeEmissions)
                    }
                    resumeEmissions
                },
                {
                    fn DOMAIN_SEPARATOR(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::DOMAIN_SEPARATOR)
                    }
                    DOMAIN_SEPARATOR
                },
                {
                    fn renounceRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn getPastVotes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getPastVotesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getPastVotes)
                    }
                    getPastVotes
                },
                {
                    fn unpause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <unpauseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::unpause)
                    }
                    unpause
                },
                {
                    fn mint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <mintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::mint)
                    }
                    mint
                },
                {
                    fn bridgeLimits(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <bridgeLimitsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::bridgeLimits)
                    }
                    bridgeLimits
                },
                {
                    fn emissionsStartTime(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <emissionsStartTimeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::emissionsStartTime)
                    }
                    emissionsStartTime
                },
                {
                    fn getRemainingEmissions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getRemainingEmissionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getRemainingEmissions)
                    }
                    getRemainingEmissions
                },
                {
                    fn CLOCK_MODE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <CLOCK_MODECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::CLOCK_MODE)
                    }
                    CLOCK_MODE
                },
                {
                    fn delegates(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <delegatesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::delegates)
                    }
                    delegates
                },
                {
                    fn emissionsStarted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <emissionsStartedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::emissionsStarted)
                    }
                    emissionsStarted
                },
                {
                    fn delegate(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <delegateCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::delegate)
                    }
                    delegate
                },
                {
                    fn paused(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <pausedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::paused)
                    }
                    paused
                },
                {
                    fn TOTAL_EPOCHS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::TOTAL_EPOCHS)
                    }
                    TOTAL_EPOCHS
                },
                {
                    fn mintingCurrentLimitOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <mintingCurrentLimitOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::mintingCurrentLimitOf)
                    }
                    mintingCurrentLimitOf
                },
                {
                    fn pauseEmissions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <pauseEmissionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::pauseEmissions)
                    }
                    pauseEmissions
                },
                {
                    fn EMISSIONS_SUPPLY(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <EMISSIONS_SUPPLYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::EMISSIONS_SUPPLY)
                    }
                    EMISSIONS_SUPPLY
                },
                {
                    fn authorizedBridges(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <authorizedBridgesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::authorizedBridges)
                    }
                    authorizedBridges
                },
                {
                    fn numCheckpoints(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <numCheckpointsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::numCheckpoints)
                    }
                    numCheckpoints
                },
                {
                    fn balanceOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <balanceOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::balanceOf)
                    }
                    balanceOf
                },
                {
                    fn isBridge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <isBridgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::isBridge)
                    }
                    isBridge
                },
                {
                    fn currentEpoch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <currentEpochCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::currentEpoch)
                    }
                    currentEpoch
                },
                {
                    fn getBridgeInfo(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getBridgeInfoCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getBridgeInfo)
                    }
                    getBridgeInfo
                },
                {
                    fn nonces(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <noncesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::nonces)
                    }
                    nonces
                },
                {
                    fn pause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <pauseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::pause)
                    }
                    pause
                },
                {
                    fn eip712Domain(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <eip712DomainCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::eip712Domain)
                    }
                    eip712Domain
                },
                {
                    fn getPastTotalSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getPastTotalSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getPastTotalSupply)
                    }
                    getPastTotalSupply
                },
                {
                    fn TOTAL_SUPPLY(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::TOTAL_SUPPLY)
                    }
                    TOTAL_SUPPLY
                },
                {
                    fn hasRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn clock(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <clockCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::clock)
                    }
                    clock
                },
                {
                    fn symbol(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <symbolCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::symbol)
                    }
                    symbol
                },
                {
                    fn BRIDGE_LIMIT_DURATION(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <BRIDGE_LIMIT_DURATIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::BRIDGE_LIMIT_DURATION)
                    }
                    BRIDGE_LIMIT_DURATION
                },
                {
                    fn burningCurrentLimitOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <burningCurrentLimitOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::burningCurrentLimitOf)
                    }
                    burningCurrentLimitOf
                },
                {
                    fn getVotes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getVotesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getVotes)
                    }
                    getVotes
                },
                {
                    fn INITIAL_MINT_SUPPLY(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::INITIAL_MINT_SUPPLY)
                    }
                    INITIAL_MINT_SUPPLY
                },
                {
                    fn burn(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <burnCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::burn)
                    }
                    burn
                },
                {
                    fn setLimits(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <setLimitsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::setLimits)
                    }
                    setLimits
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn bridgeProxy(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <bridgeProxyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::bridgeProxy)
                    }
                    bridgeProxy
                },
                {
                    fn emissionsEnded(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <emissionsEndedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::emissionsEnded)
                    }
                    emissionsEnded
                },
                {
                    fn setBridgeProxy(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <setBridgeProxyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::setBridgeProxy)
                    }
                    setBridgeProxy
                },
                {
                    fn getNextEmissionTime(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getNextEmissionTimeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getNextEmissionTime)
                    }
                    getNextEmissionTime
                },
                {
                    fn EPOCH_DURATION(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::EPOCH_DURATION)
                    }
                    EPOCH_DURATION
                },
                {
                    fn transfer(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <transferCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::transfer)
                    }
                    transfer
                },
                {
                    fn PRECISION_MULTIPLIER(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <PRECISION_MULTIPLIERCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::PRECISION_MULTIPLIER)
                    }
                    PRECISION_MULTIPLIER
                },
                {
                    fn getEmissionSchedule(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getEmissionScheduleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getEmissionSchedule)
                    }
                    getEmissionSchedule
                },
                {
                    fn getPastVotingPower(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getPastVotingPowerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getPastVotingPower)
                    }
                    getPastVotingPower
                },
                {
                    fn getCurrentEpochInfo(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getCurrentEpochInfo)
                    }
                    getCurrentEpochInfo
                },
                {
                    fn getVotingPower(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getVotingPowerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getVotingPower)
                    }
                    getVotingPower
                },
                {
                    fn getCurrentTotalSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getCurrentTotalSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getCurrentTotalSupply)
                    }
                    getCurrentTotalSupply
                },
                {
                    fn burningMaxLimitOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <burningMaxLimitOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::burningMaxLimitOf)
                    }
                    burningMaxLimitOf
                },
                {
                    fn delegateBySig(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <delegateBySigCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::delegateBySig)
                    }
                    delegateBySig
                },
                {
                    fn permit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <permitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::permit)
                    }
                    permit
                },
                {
                    fn revokeRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn allowance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <allowanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::allowance)
                    }
                    allowance
                },
                {
                    fn EMISSIONS_MANAGER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::EMISSIONS_MANAGER_ROLE)
                    }
                    EMISSIONS_MANAGER_ROLE
                },
                {
                    fn PAUSER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <PAUSER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::PAUSER_ROLE)
                    }
                    PAUSER_ROLE
                },
                {
                    fn checkpoints(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <checkpointsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::checkpoints)
                    }
                    checkpoints
                },
                {
                    fn totalEmissionsMinted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <totalEmissionsMintedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::totalEmissionsMinted)
                    }
                    totalEmissionsMinted
                },
                {
                    fn BRIDGE_MANAGER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::BRIDGE_MANAGER_ROLE)
                    }
                    BRIDGE_MANAGER_ROLE
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::BRIDGE_LIMIT_DURATION(inner) => {
                    <BRIDGE_LIMIT_DURATIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BRIDGE_MANAGER_ROLE(inner) => {
                    <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CLOCK_MODE(inner) => {
                    <CLOCK_MODECall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DOMAIN_SEPARATOR(inner) => {
                    <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSIONS_MANAGER_ROLE(inner) => {
                    <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSIONS_SUPPLY(inner) => {
                    <EMISSIONS_SUPPLYCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSION_BUFFER_TIME(inner) => {
                    <EMISSION_BUFFER_TIMECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EPOCH_DURATION(inner) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::INITIAL_MINT_SUPPLY(inner) => {
                    <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PAUSER_ROLE(inner) => {
                    <PAUSER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PRECISION_MULTIPLIER(inner) => {
                    <PRECISION_MULTIPLIERCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TOTAL_EPOCHS(inner) => {
                    <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TOTAL_SUPPLY(inner) => {
                    <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::allowance(inner) => {
                    <allowanceCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::approve(inner) => {
                    <approveCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::authorizedBridges(inner) => {
                    <authorizedBridgesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::bridgeData(inner) => {
                    <bridgeDataCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::bridgeLimits(inner) => {
                    <bridgeLimitsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bridgeProxy(inner) => {
                    <bridgeProxyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::burn(inner) => {
                    <burnCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::burningCurrentLimitOf(inner) => {
                    <burningCurrentLimitOfCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::burningMaxLimitOf(inner) => {
                    <burningMaxLimitOfCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkpoints(inner) => {
                    <checkpointsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::clock(inner) => {
                    <clockCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::currentEpoch(inner) => {
                    <currentEpochCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::decimals(inner) => {
                    <decimalsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::delegate(inner) => {
                    <delegateCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::delegateBySig(inner) => {
                    <delegateBySigCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::delegates(inner) => {
                    <delegatesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::eip712Domain(inner) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionSchedule(inner) => {
                    <emissionScheduleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionsActive(inner) => {
                    <emissionsActiveCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionsEnded(inner) => {
                    <emissionsEndedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionsStartTime(inner) => {
                    <emissionsStartTimeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionsStarted(inner) => {
                    <emissionsStartedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBridgeConfiguration(inner) => {
                    <getBridgeConfigurationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBridgeInfo(inner) => {
                    <getBridgeInfoCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBridgeUtilization(inner) => {
                    <getBridgeUtilizationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getCurrentEpochInfo(inner) => {
                    <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getCurrentTotalSupply(inner) => {
                    <getCurrentTotalSupplyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getEmissionSchedule(inner) => {
                    <getEmissionScheduleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getNextEmissionTime(inner) => {
                    <getNextEmissionTimeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPastTotalSupply(inner) => {
                    <getPastTotalSupplyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPastVotes(inner) => {
                    <getPastVotesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPastVotingPower(inner) => {
                    <getPastVotingPowerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRemainingEmissions(inner) => {
                    <getRemainingEmissionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getVotes(inner) => {
                    <getVotesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getVotingPower(inner) => {
                    <getVotingPowerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isBridge(inner) => {
                    <isBridgeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::mint(inner) => {
                    <mintCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::mintEmission(inner) => {
                    <mintEmissionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::mintingCurrentLimitOf(inner) => {
                    <mintingCurrentLimitOfCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::mintingMaxLimitOf(inner) => {
                    <mintingMaxLimitOfCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::name(inner) => {
                    <nameCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::nonces(inner) => {
                    <noncesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::numCheckpoints(inner) => {
                    <numCheckpointsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::pauseEmissions(inner) => {
                    <pauseEmissionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::permit(inner) => {
                    <permitCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::resumeEmissions(inner) => {
                    <resumeEmissionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setBridgeData(inner) => {
                    <setBridgeDataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setBridgeProxy(inner) => {
                    <setBridgeProxyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setLimits(inner) => {
                    <setLimitsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::startEmissions(inner) => {
                    <startEmissionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::symbol(inner) => {
                    <symbolCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::totalEmissionsMinted(inner) => {
                    <totalEmissionsMintedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::totalSupply(inner) => {
                    <totalSupplyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transfer(inner) => {
                    <transferCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::transferFrom(inner) => {
                    <transferFromCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::BRIDGE_LIMIT_DURATION(inner) => {
                    <BRIDGE_LIMIT_DURATIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BRIDGE_MANAGER_ROLE(inner) => {
                    <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CLOCK_MODE(inner) => {
                    <CLOCK_MODECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DOMAIN_SEPARATOR(inner) => {
                    <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSIONS_MANAGER_ROLE(inner) => {
                    <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSIONS_SUPPLY(inner) => {
                    <EMISSIONS_SUPPLYCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSION_BUFFER_TIME(inner) => {
                    <EMISSION_BUFFER_TIMECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EPOCH_DURATION(inner) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::INITIAL_MINT_SUPPLY(inner) => {
                    <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PAUSER_ROLE(inner) => {
                    <PAUSER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PRECISION_MULTIPLIER(inner) => {
                    <PRECISION_MULTIPLIERCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TOTAL_EPOCHS(inner) => {
                    <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TOTAL_SUPPLY(inner) => {
                    <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::allowance(inner) => {
                    <allowanceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::approve(inner) => {
                    <approveCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::authorizedBridges(inner) => {
                    <authorizedBridgesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeData(inner) => {
                    <bridgeDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeLimits(inner) => {
                    <bridgeLimitsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeProxy(inner) => {
                    <bridgeProxyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::burn(inner) => {
                    <burnCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::burningCurrentLimitOf(inner) => {
                    <burningCurrentLimitOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::burningMaxLimitOf(inner) => {
                    <burningMaxLimitOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkpoints(inner) => {
                    <checkpointsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::clock(inner) => {
                    <clockCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::currentEpoch(inner) => {
                    <currentEpochCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::decimals(inner) => {
                    <decimalsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::delegate(inner) => {
                    <delegateCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::delegateBySig(inner) => {
                    <delegateBySigCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::delegates(inner) => {
                    <delegatesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::eip712Domain(inner) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionSchedule(inner) => {
                    <emissionScheduleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionsActive(inner) => {
                    <emissionsActiveCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionsEnded(inner) => {
                    <emissionsEndedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionsStartTime(inner) => {
                    <emissionsStartTimeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionsStarted(inner) => {
                    <emissionsStartedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBridgeConfiguration(inner) => {
                    <getBridgeConfigurationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBridgeInfo(inner) => {
                    <getBridgeInfoCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBridgeUtilization(inner) => {
                    <getBridgeUtilizationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getCurrentEpochInfo(inner) => {
                    <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getCurrentTotalSupply(inner) => {
                    <getCurrentTotalSupplyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getEmissionSchedule(inner) => {
                    <getEmissionScheduleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getNextEmissionTime(inner) => {
                    <getNextEmissionTimeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPastTotalSupply(inner) => {
                    <getPastTotalSupplyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPastVotes(inner) => {
                    <getPastVotesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPastVotingPower(inner) => {
                    <getPastVotingPowerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRemainingEmissions(inner) => {
                    <getRemainingEmissionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getVotes(inner) => {
                    <getVotesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getVotingPower(inner) => {
                    <getVotingPowerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::isBridge(inner) => {
                    <isBridgeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::mint(inner) => {
                    <mintCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::mintEmission(inner) => {
                    <mintEmissionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::mintingCurrentLimitOf(inner) => {
                    <mintingCurrentLimitOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::mintingMaxLimitOf(inner) => {
                    <mintingMaxLimitOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::name(inner) => {
                    <nameCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::nonces(inner) => {
                    <noncesCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::numCheckpoints(inner) => {
                    <numCheckpointsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pauseEmissions(inner) => {
                    <pauseEmissionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::permit(inner) => {
                    <permitCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::resumeEmissions(inner) => {
                    <resumeEmissionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBridgeData(inner) => {
                    <setBridgeDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBridgeProxy(inner) => {
                    <setBridgeProxyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setLimits(inner) => {
                    <setLimitsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::startEmissions(inner) => {
                    <startEmissionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::symbol(inner) => {
                    <symbolCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::totalEmissionsMinted(inner) => {
                    <totalEmissionsMintedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::totalSupply(inner) => {
                    <totalSupplyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transfer(inner) => {
                    <transferCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferFrom(inner) => {
                    <transferFromCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
            }
        }
    }
    ///Container for all the [`SyndicateToken`](self) custom errors.
    pub enum SyndicateTokenErrors {
        #[allow(missing_docs)]
        AccessControlBadConfirmation(AccessControlBadConfirmation),
        #[allow(missing_docs)]
        AccessControlUnauthorizedAccount(AccessControlUnauthorizedAccount),
        #[allow(missing_docs)]
        AllEmissionsCompleted(AllEmissionsCompleted),
        #[allow(missing_docs)]
        BridgeNotAuthorized(BridgeNotAuthorized),
        #[allow(missing_docs)]
        BridgeNotConfigured(BridgeNotConfigured),
        #[allow(missing_docs)]
        CheckpointUnorderedInsertion(CheckpointUnorderedInsertion),
        #[allow(missing_docs)]
        ECDSAInvalidSignature(ECDSAInvalidSignature),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureLength(ECDSAInvalidSignatureLength),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureS(ECDSAInvalidSignatureS),
        #[allow(missing_docs)]
        ERC20ExceededSafeSupply(ERC20ExceededSafeSupply),
        #[allow(missing_docs)]
        ERC20InsufficientAllowance(ERC20InsufficientAllowance),
        #[allow(missing_docs)]
        ERC20InsufficientBalance(ERC20InsufficientBalance),
        #[allow(missing_docs)]
        ERC20InvalidApprover(ERC20InvalidApprover),
        #[allow(missing_docs)]
        ERC20InvalidReceiver(ERC20InvalidReceiver),
        #[allow(missing_docs)]
        ERC20InvalidSender(ERC20InvalidSender),
        #[allow(missing_docs)]
        ERC20InvalidSpender(ERC20InvalidSpender),
        #[allow(missing_docs)]
        ERC2612ExpiredSignature(ERC2612ExpiredSignature),
        #[allow(missing_docs)]
        ERC2612InvalidSigner(ERC2612InvalidSigner),
        #[allow(missing_docs)]
        ERC5805FutureLookup(ERC5805FutureLookup),
        #[allow(missing_docs)]
        ERC6372InconsistentClock(ERC6372InconsistentClock),
        #[allow(missing_docs)]
        EmissionTooEarly(EmissionTooEarly),
        #[allow(missing_docs)]
        EmissionsAlreadyStarted(EmissionsAlreadyStarted),
        #[allow(missing_docs)]
        EmissionsNotActive(EmissionsNotActive),
        #[allow(missing_docs)]
        EmissionsNotStarted(EmissionsNotStarted),
        #[allow(missing_docs)]
        EnforcedPause(EnforcedPause),
        #[allow(missing_docs)]
        ExceedsEmissionsSupply(ExceedsEmissionsSupply),
        #[allow(missing_docs)]
        ExpectedPause(ExpectedPause),
        #[allow(missing_docs)]
        InsufficientLimit(InsufficientLimit),
        #[allow(missing_docs)]
        InvalidAccountNonce(InvalidAccountNonce),
        #[allow(missing_docs)]
        InvalidShortString(InvalidShortString),
        #[allow(missing_docs)]
        ReentrancyGuardReentrantCall(ReentrancyGuardReentrantCall),
        #[allow(missing_docs)]
        SafeCastOverflowedUintDowncast(SafeCastOverflowedUintDowncast),
        #[allow(missing_docs)]
        StringTooLong(StringTooLong),
        #[allow(missing_docs)]
        VotesExpiredSignature(VotesExpiredSignature),
        #[allow(missing_docs)]
        ZeroAddress(ZeroAddress),
        #[allow(missing_docs)]
        ZeroAmount(ZeroAmount),
    }
    #[automatically_derived]
    impl SyndicateTokenErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [28u8, 177u8, 93u8, 38u8],
            [31u8, 42u8, 32u8, 5u8],
            [35u8, 6u8, 78u8, 189u8],
            [37u8, 32u8, 96u8, 29u8],
            [48u8, 90u8, 39u8, 169u8],
            [61u8, 83u8, 199u8, 83u8],
            [62u8, 229u8, 174u8, 181u8],
            [69u8, 85u8, 137u8, 44u8],
            [70u8, 131u8, 175u8, 14u8],
            [75u8, 128u8, 14u8, 70u8],
            [98u8, 121u8, 19u8, 2u8],
            [102u8, 151u8, 178u8, 50u8],
            [102u8, 191u8, 38u8, 116u8],
            [109u8, 252u8, 198u8, 80u8],
            [111u8, 240u8, 113u8, 64u8],
            [113u8, 210u8, 123u8, 122u8],
            [114u8, 86u8, 123u8, 100u8],
            [117u8, 45u8, 136u8, 192u8],
            [118u8, 20u8, 145u8, 122u8],
            [136u8, 46u8, 236u8, 18u8],
            [141u8, 252u8, 32u8, 43u8],
            [143u8, 152u8, 64u8, 65u8],
            [148u8, 40u8, 13u8, 98u8],
            [150u8, 198u8, 253u8, 30u8],
            [179u8, 81u8, 43u8, 12u8],
            [215u8, 139u8, 206u8, 12u8],
            [217u8, 46u8, 35u8, 61u8],
            [217u8, 60u8, 6u8, 101u8],
            [226u8, 81u8, 125u8, 63u8],
            [228u8, 80u8, 211u8, 140u8],
            [230u8, 2u8, 223u8, 5u8],
            [236u8, 68u8, 47u8, 5u8],
            [236u8, 211u8, 248u8, 30u8],
            [246u8, 69u8, 238u8, 223u8],
            [251u8, 143u8, 65u8, 178u8],
            [252u8, 230u8, 152u8, 247u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndicateTokenErrors {
        const NAME: &'static str = "SyndicateTokenErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 36usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AccessControlBadConfirmation(_) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AccessControlUnauthorizedAccount(_) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AllEmissionsCompleted(_) => {
                    <AllEmissionsCompleted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BridgeNotAuthorized(_) => {
                    <BridgeNotAuthorized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BridgeNotConfigured(_) => {
                    <BridgeNotConfigured as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CheckpointUnorderedInsertion(_) => {
                    <CheckpointUnorderedInsertion as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignature(_) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureLength(_) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureS(_) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20ExceededSafeSupply(_) => {
                    <ERC20ExceededSafeSupply as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InsufficientAllowance(_) => {
                    <ERC20InsufficientAllowance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InsufficientBalance(_) => {
                    <ERC20InsufficientBalance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidApprover(_) => {
                    <ERC20InvalidApprover as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidReceiver(_) => {
                    <ERC20InvalidReceiver as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidSender(_) => {
                    <ERC20InvalidSender as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidSpender(_) => {
                    <ERC20InvalidSpender as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC2612ExpiredSignature(_) => {
                    <ERC2612ExpiredSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC2612InvalidSigner(_) => {
                    <ERC2612InvalidSigner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC5805FutureLookup(_) => {
                    <ERC5805FutureLookup as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC6372InconsistentClock(_) => {
                    <ERC6372InconsistentClock as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmissionTooEarly(_) => {
                    <EmissionTooEarly as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmissionsAlreadyStarted(_) => {
                    <EmissionsAlreadyStarted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmissionsNotActive(_) => {
                    <EmissionsNotActive as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmissionsNotStarted(_) => {
                    <EmissionsNotStarted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EnforcedPause(_) => {
                    <EnforcedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ExceedsEmissionsSupply(_) => {
                    <ExceedsEmissionsSupply as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ExpectedPause(_) => {
                    <ExpectedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientLimit(_) => {
                    <InsufficientLimit as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidAccountNonce(_) => {
                    <InvalidAccountNonce as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidShortString(_) => {
                    <InvalidShortString as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ReentrancyGuardReentrantCall(_) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SafeCastOverflowedUintDowncast(_) => {
                    <SafeCastOverflowedUintDowncast as alloy_sol_types::SolError>::SELECTOR
                }
                Self::StringTooLong(_) => {
                    <StringTooLong as alloy_sol_types::SolError>::SELECTOR
                }
                Self::VotesExpiredSignature(_) => {
                    <VotesExpiredSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAddress(_) => {
                    <ZeroAddress as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAmount(_) => {
                    <ZeroAmount as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<SyndicateTokenErrors>] = &[
                {
                    fn ERC20ExceededSafeSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20ExceededSafeSupply as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20ExceededSafeSupply)
                    }
                    ERC20ExceededSafeSupply
                },
                {
                    fn ZeroAmount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ZeroAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ZeroAmount)
                    }
                    ZeroAmount
                },
                {
                    fn ExceedsEmissionsSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ExceedsEmissionsSupply as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ExceedsEmissionsSupply)
                    }
                    ExceedsEmissionsSupply
                },
                {
                    fn CheckpointUnorderedInsertion(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <CheckpointUnorderedInsertion as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::CheckpointUnorderedInsertion)
                    }
                    CheckpointUnorderedInsertion
                },
                {
                    fn StringTooLong(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <StringTooLong as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::StringTooLong)
                    }
                    StringTooLong
                },
                {
                    fn EmissionTooEarly(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <EmissionTooEarly as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::EmissionTooEarly)
                    }
                    EmissionTooEarly
                },
                {
                    fn ReentrancyGuardReentrantCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ReentrancyGuardReentrantCall)
                    }
                    ReentrancyGuardReentrantCall
                },
                {
                    fn AllEmissionsCompleted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <AllEmissionsCompleted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::AllEmissionsCompleted)
                    }
                    AllEmissionsCompleted
                },
                {
                    fn VotesExpiredSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <VotesExpiredSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::VotesExpiredSignature)
                    }
                    VotesExpiredSignature
                },
                {
                    fn ERC2612InvalidSigner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC2612InvalidSigner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC2612InvalidSigner)
                    }
                    ERC2612InvalidSigner
                },
                {
                    fn ERC2612ExpiredSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC2612ExpiredSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC2612ExpiredSignature)
                    }
                    ERC2612ExpiredSignature
                },
                {
                    fn AccessControlBadConfirmation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::AccessControlBadConfirmation)
                    }
                    AccessControlBadConfirmation
                },
                {
                    fn EmissionsNotActive(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <EmissionsNotActive as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::EmissionsNotActive)
                    }
                    EmissionsNotActive
                },
                {
                    fn SafeCastOverflowedUintDowncast(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <SafeCastOverflowedUintDowncast as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::SafeCastOverflowedUintDowncast)
                    }
                    SafeCastOverflowedUintDowncast
                },
                {
                    fn ERC6372InconsistentClock(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC6372InconsistentClock as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC6372InconsistentClock)
                    }
                    ERC6372InconsistentClock
                },
                {
                    fn EmissionsAlreadyStarted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <EmissionsAlreadyStarted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::EmissionsAlreadyStarted)
                    }
                    EmissionsAlreadyStarted
                },
                {
                    fn InsufficientLimit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <InsufficientLimit as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::InsufficientLimit)
                    }
                    InsufficientLimit
                },
                {
                    fn InvalidAccountNonce(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <InvalidAccountNonce as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::InvalidAccountNonce)
                    }
                    InvalidAccountNonce
                },
                {
                    fn BridgeNotConfigured(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <BridgeNotConfigured as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::BridgeNotConfigured)
                    }
                    BridgeNotConfigured
                },
                {
                    fn BridgeNotAuthorized(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <BridgeNotAuthorized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::BridgeNotAuthorized)
                    }
                    BridgeNotAuthorized
                },
                {
                    fn ExpectedPause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ExpectedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ExpectedPause)
                    }
                    ExpectedPause
                },
                {
                    fn EmissionsNotStarted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <EmissionsNotStarted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::EmissionsNotStarted)
                    }
                    EmissionsNotStarted
                },
                {
                    fn ERC20InvalidSpender(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InvalidSpender as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InvalidSpender)
                    }
                    ERC20InvalidSpender
                },
                {
                    fn ERC20InvalidSender(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InvalidSender as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InvalidSender)
                    }
                    ERC20InvalidSender
                },
                {
                    fn InvalidShortString(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <InvalidShortString as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::InvalidShortString)
                    }
                    InvalidShortString
                },
                {
                    fn ECDSAInvalidSignatureS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ECDSAInvalidSignatureS)
                    }
                    ECDSAInvalidSignatureS
                },
                {
                    fn ZeroAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ZeroAddress as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ZeroAddress)
                    }
                    ZeroAddress
                },
                {
                    fn EnforcedPause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <EnforcedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::EnforcedPause)
                    }
                    EnforcedPause
                },
                {
                    fn AccessControlUnauthorizedAccount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::AccessControlUnauthorizedAccount)
                    }
                    AccessControlUnauthorizedAccount
                },
                {
                    fn ERC20InsufficientBalance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InsufficientBalance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InsufficientBalance)
                    }
                    ERC20InsufficientBalance
                },
                {
                    fn ERC20InvalidApprover(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InvalidApprover as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InvalidApprover)
                    }
                    ERC20InvalidApprover
                },
                {
                    fn ERC20InvalidReceiver(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InvalidReceiver as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InvalidReceiver)
                    }
                    ERC20InvalidReceiver
                },
                {
                    fn ERC5805FutureLookup(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC5805FutureLookup as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC5805FutureLookup)
                    }
                    ERC5805FutureLookup
                },
                {
                    fn ECDSAInvalidSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ECDSAInvalidSignature)
                    }
                    ECDSAInvalidSignature
                },
                {
                    fn ERC20InsufficientAllowance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InsufficientAllowance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InsufficientAllowance)
                    }
                    ERC20InsufficientAllowance
                },
                {
                    fn ECDSAInvalidSignatureLength(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ECDSAInvalidSignatureLength)
                    }
                    ECDSAInvalidSignatureLength
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AllEmissionsCompleted(inner) => {
                    <AllEmissionsCompleted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BridgeNotAuthorized(inner) => {
                    <BridgeNotAuthorized as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BridgeNotConfigured(inner) => {
                    <BridgeNotConfigured as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CheckpointUnorderedInsertion(inner) => {
                    <CheckpointUnorderedInsertion as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20ExceededSafeSupply(inner) => {
                    <ERC20ExceededSafeSupply as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InsufficientAllowance(inner) => {
                    <ERC20InsufficientAllowance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InsufficientBalance(inner) => {
                    <ERC20InsufficientBalance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidApprover(inner) => {
                    <ERC20InvalidApprover as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidReceiver(inner) => {
                    <ERC20InvalidReceiver as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidSender(inner) => {
                    <ERC20InvalidSender as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidSpender(inner) => {
                    <ERC20InvalidSpender as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC2612ExpiredSignature(inner) => {
                    <ERC2612ExpiredSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC2612InvalidSigner(inner) => {
                    <ERC2612InvalidSigner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC5805FutureLookup(inner) => {
                    <ERC5805FutureLookup as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC6372InconsistentClock(inner) => {
                    <ERC6372InconsistentClock as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmissionTooEarly(inner) => {
                    <EmissionTooEarly as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmissionsAlreadyStarted(inner) => {
                    <EmissionsAlreadyStarted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmissionsNotActive(inner) => {
                    <EmissionsNotActive as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmissionsNotStarted(inner) => {
                    <EmissionsNotStarted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ExceedsEmissionsSupply(inner) => {
                    <ExceedsEmissionsSupply as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InsufficientLimit(inner) => {
                    <InsufficientLimit as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidAccountNonce(inner) => {
                    <InvalidAccountNonce as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidShortString(inner) => {
                    <InvalidShortString as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ReentrancyGuardReentrantCall(inner) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SafeCastOverflowedUintDowncast(inner) => {
                    <SafeCastOverflowedUintDowncast as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::StringTooLong(inner) => {
                    <StringTooLong as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::VotesExpiredSignature(inner) => {
                    <VotesExpiredSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ZeroAmount(inner) => {
                    <ZeroAmount as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AllEmissionsCompleted(inner) => {
                    <AllEmissionsCompleted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BridgeNotAuthorized(inner) => {
                    <BridgeNotAuthorized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BridgeNotConfigured(inner) => {
                    <BridgeNotConfigured as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CheckpointUnorderedInsertion(inner) => {
                    <CheckpointUnorderedInsertion as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20ExceededSafeSupply(inner) => {
                    <ERC20ExceededSafeSupply as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InsufficientAllowance(inner) => {
                    <ERC20InsufficientAllowance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InsufficientBalance(inner) => {
                    <ERC20InsufficientBalance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidApprover(inner) => {
                    <ERC20InvalidApprover as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidReceiver(inner) => {
                    <ERC20InvalidReceiver as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidSender(inner) => {
                    <ERC20InvalidSender as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidSpender(inner) => {
                    <ERC20InvalidSpender as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC2612ExpiredSignature(inner) => {
                    <ERC2612ExpiredSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC2612InvalidSigner(inner) => {
                    <ERC2612InvalidSigner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC5805FutureLookup(inner) => {
                    <ERC5805FutureLookup as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC6372InconsistentClock(inner) => {
                    <ERC6372InconsistentClock as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmissionTooEarly(inner) => {
                    <EmissionTooEarly as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmissionsAlreadyStarted(inner) => {
                    <EmissionsAlreadyStarted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmissionsNotActive(inner) => {
                    <EmissionsNotActive as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmissionsNotStarted(inner) => {
                    <EmissionsNotStarted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ExceedsEmissionsSupply(inner) => {
                    <ExceedsEmissionsSupply as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientLimit(inner) => {
                    <InsufficientLimit as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidAccountNonce(inner) => {
                    <InvalidAccountNonce as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidShortString(inner) => {
                    <InvalidShortString as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ReentrancyGuardReentrantCall(inner) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SafeCastOverflowedUintDowncast(inner) => {
                    <SafeCastOverflowedUintDowncast as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::StringTooLong(inner) => {
                    <StringTooLong as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::VotesExpiredSignature(inner) => {
                    <VotesExpiredSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAmount(inner) => {
                    <ZeroAmount as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
            }
        }
    }
    ///Container for all the [`SyndicateToken`](self) events.
    pub enum SyndicateTokenEvents {
        #[allow(missing_docs)]
        Approval(Approval),
        #[allow(missing_docs)]
        BridgeAuthorized(BridgeAuthorized),
        #[allow(missing_docs)]
        BridgeDataUpdated(BridgeDataUpdated),
        #[allow(missing_docs)]
        BridgeDeauthorized(BridgeDeauthorized),
        #[allow(missing_docs)]
        BridgeLimitsSet(BridgeLimitsSet),
        #[allow(missing_docs)]
        BridgeProxyUpdated(BridgeProxyUpdated),
        #[allow(missing_docs)]
        DelegateChanged(DelegateChanged),
        #[allow(missing_docs)]
        DelegateVotesChanged(DelegateVotesChanged),
        #[allow(missing_docs)]
        EIP712DomainChanged(EIP712DomainChanged),
        #[allow(missing_docs)]
        EmissionMinted(EmissionMinted),
        #[allow(missing_docs)]
        EmissionsPaused(EmissionsPaused),
        #[allow(missing_docs)]
        EmissionsResumed(EmissionsResumed),
        #[allow(missing_docs)]
        EmissionsStarted(EmissionsStarted),
        #[allow(missing_docs)]
        Paused(Paused),
        #[allow(missing_docs)]
        RoleAdminChanged(RoleAdminChanged),
        #[allow(missing_docs)]
        RoleGranted(RoleGranted),
        #[allow(missing_docs)]
        RoleRevoked(RoleRevoked),
        #[allow(missing_docs)]
        Transfer(Transfer),
        #[allow(missing_docs)]
        Unpaused(Unpaused),
    }
    #[automatically_derived]
    impl SyndicateTokenEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                2u8,
                194u8,
                240u8,
                186u8,
                21u8,
                176u8,
                63u8,
                136u8,
                177u8,
                143u8,
                72u8,
                50u8,
                96u8,
                154u8,
                24u8,
                207u8,
                53u8,
                252u8,
                107u8,
                63u8,
                69u8,
                70u8,
                169u8,
                153u8,
                32u8,
                118u8,
                215u8,
                69u8,
                61u8,
                19u8,
                52u8,
                168u8,
            ],
            [
                7u8,
                1u8,
                91u8,
                106u8,
                159u8,
                5u8,
                145u8,
                49u8,
                72u8,
                253u8,
                95u8,
                173u8,
                223u8,
                42u8,
                204u8,
                151u8,
                8u8,
                243u8,
                5u8,
                147u8,
                127u8,
                48u8,
                114u8,
                202u8,
                43u8,
                75u8,
                70u8,
                250u8,
                165u8,
                208u8,
                137u8,
                139u8,
            ],
            [
                10u8,
                99u8,
                135u8,
                201u8,
                234u8,
                54u8,
                40u8,
                184u8,
                138u8,
                99u8,
                59u8,
                180u8,
                243u8,
                177u8,
                81u8,
                119u8,
                15u8,
                112u8,
                8u8,
                81u8,
                23u8,
                161u8,
                95u8,
                155u8,
                243u8,
                120u8,
                124u8,
                218u8,
                83u8,
                241u8,
                61u8,
                49u8,
            ],
            [
                17u8,
                148u8,
                176u8,
                52u8,
                207u8,
                169u8,
                171u8,
                88u8,
                7u8,
                73u8,
                74u8,
                29u8,
                92u8,
                102u8,
                125u8,
                139u8,
                14u8,
                110u8,
                151u8,
                243u8,
                136u8,
                136u8,
                116u8,
                42u8,
                163u8,
                135u8,
                26u8,
                50u8,
                32u8,
                52u8,
                17u8,
                96u8,
            ],
            [
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ],
            [
                49u8,
                52u8,
                232u8,
                162u8,
                230u8,
                217u8,
                126u8,
                146u8,
                154u8,
                126u8,
                84u8,
                1u8,
                30u8,
                165u8,
                72u8,
                93u8,
                125u8,
                25u8,
                109u8,
                213u8,
                240u8,
                186u8,
                77u8,
                78u8,
                249u8,
                88u8,
                3u8,
                232u8,
                227u8,
                252u8,
                37u8,
                127u8,
            ],
            [
                52u8,
                183u8,
                61u8,
                12u8,
                150u8,
                233u8,
                255u8,
                77u8,
                83u8,
                17u8,
                67u8,
                72u8,
                23u8,
                200u8,
                236u8,
                201u8,
                48u8,
                231u8,
                210u8,
                120u8,
                44u8,
                91u8,
                222u8,
                46u8,
                121u8,
                220u8,
                68u8,
                176u8,
                89u8,
                103u8,
                85u8,
                187u8,
            ],
            [
                74u8,
                121u8,
                42u8,
                11u8,
                228u8,
                43u8,
                86u8,
                114u8,
                250u8,
                164u8,
                1u8,
                41u8,
                252u8,
                100u8,
                105u8,
                7u8,
                36u8,
                144u8,
                119u8,
                92u8,
                168u8,
                211u8,
                195u8,
                78u8,
                133u8,
                45u8,
                77u8,
                85u8,
                211u8,
                167u8,
                53u8,
                169u8,
            ],
            [
                93u8,
                185u8,
                238u8,
                10u8,
                73u8,
                91u8,
                242u8,
                230u8,
                255u8,
                156u8,
                145u8,
                167u8,
                131u8,
                76u8,
                27u8,
                164u8,
                253u8,
                210u8,
                68u8,
                165u8,
                232u8,
                170u8,
                78u8,
                83u8,
                123u8,
                211u8,
                138u8,
                234u8,
                228u8,
                176u8,
                115u8,
                170u8,
            ],
            [
                98u8,
                231u8,
                140u8,
                234u8,
                1u8,
                190u8,
                227u8,
                32u8,
                205u8,
                78u8,
                66u8,
                2u8,
                112u8,
                181u8,
                234u8,
                116u8,
                0u8,
                13u8,
                17u8,
                176u8,
                201u8,
                247u8,
                71u8,
                84u8,
                235u8,
                219u8,
                252u8,
                84u8,
                75u8,
                5u8,
                162u8,
                88u8,
            ],
            [
                108u8,
                242u8,
                132u8,
                57u8,
                162u8,
                218u8,
                171u8,
                27u8,
                38u8,
                80u8,
                151u8,
                34u8,
                114u8,
                18u8,
                165u8,
                183u8,
                30u8,
                10u8,
                118u8,
                249u8,
                237u8,
                133u8,
                227u8,
                248u8,
                21u8,
                181u8,
                166u8,
                195u8,
                226u8,
                24u8,
                235u8,
                127u8,
            ],
            [
                115u8,
                165u8,
                252u8,
                96u8,
                170u8,
                254u8,
                236u8,
                143u8,
                19u8,
                154u8,
                242u8,
                45u8,
                152u8,
                230u8,
                33u8,
                64u8,
                226u8,
                206u8,
                145u8,
                77u8,
                31u8,
                21u8,
                92u8,
                105u8,
                43u8,
                66u8,
                119u8,
                87u8,
                195u8,
                228u8,
                1u8,
                76u8,
            ],
            [
                140u8,
                91u8,
                225u8,
                229u8,
                235u8,
                236u8,
                125u8,
                91u8,
                209u8,
                79u8,
                113u8,
                66u8,
                125u8,
                30u8,
                132u8,
                243u8,
                221u8,
                3u8,
                20u8,
                192u8,
                247u8,
                178u8,
                41u8,
                30u8,
                91u8,
                32u8,
                10u8,
                200u8,
                199u8,
                195u8,
                185u8,
                37u8,
            ],
            [
                170u8,
                128u8,
                125u8,
                10u8,
                191u8,
                48u8,
                217u8,
                25u8,
                104u8,
                199u8,
                71u8,
                140u8,
                102u8,
                182u8,
                216u8,
                37u8,
                33u8,
                161u8,
                6u8,
                175u8,
                19u8,
                237u8,
                160u8,
                54u8,
                226u8,
                3u8,
                109u8,
                169u8,
                175u8,
                22u8,
                137u8,
                88u8,
            ],
            [
                185u8,
                162u8,
                8u8,
                132u8,
                38u8,
                240u8,
                59u8,
                48u8,
                168u8,
                28u8,
                6u8,
                66u8,
                128u8,
                148u8,
                251u8,
                250u8,
                158u8,
                38u8,
                146u8,
                115u8,
                155u8,
                50u8,
                65u8,
                175u8,
                107u8,
                154u8,
                177u8,
                218u8,
                75u8,
                85u8,
                70u8,
                190u8,
            ],
            [
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ],
            [
                221u8,
                242u8,
                82u8,
                173u8,
                27u8,
                226u8,
                200u8,
                155u8,
                105u8,
                194u8,
                176u8,
                104u8,
                252u8,
                55u8,
                141u8,
                170u8,
                149u8,
                43u8,
                167u8,
                241u8,
                99u8,
                196u8,
                161u8,
                22u8,
                40u8,
                245u8,
                90u8,
                77u8,
                245u8,
                35u8,
                179u8,
                239u8,
            ],
            [
                222u8,
                194u8,
                186u8,
                205u8,
                210u8,
                240u8,
                91u8,
                89u8,
                222u8,
                52u8,
                218u8,
                155u8,
                82u8,
                61u8,
                255u8,
                139u8,
                228u8,
                46u8,
                94u8,
                56u8,
                232u8,
                24u8,
                200u8,
                47u8,
                219u8,
                11u8,
                174u8,
                119u8,
                67u8,
                135u8,
                167u8,
                36u8,
            ],
            [
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for SyndicateTokenEvents {
        const NAME: &'static str = "SyndicateTokenEvents";
        const COUNT: usize = 19usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<Approval as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Approval as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Approval)
                }
                Some(<BridgeAuthorized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <BridgeAuthorized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeAuthorized)
                }
                Some(
                    <BridgeDataUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BridgeDataUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeDataUpdated)
                }
                Some(
                    <BridgeDeauthorized as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BridgeDeauthorized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeDeauthorized)
                }
                Some(<BridgeLimitsSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <BridgeLimitsSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeLimitsSet)
                }
                Some(
                    <BridgeProxyUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BridgeProxyUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeProxyUpdated)
                }
                Some(<DelegateChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <DelegateChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::DelegateChanged)
                }
                Some(
                    <DelegateVotesChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <DelegateVotesChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::DelegateVotesChanged)
                }
                Some(
                    <EIP712DomainChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <EIP712DomainChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EIP712DomainChanged)
                }
                Some(<EmissionMinted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EmissionMinted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EmissionMinted)
                }
                Some(<EmissionsPaused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EmissionsPaused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EmissionsPaused)
                }
                Some(<EmissionsResumed as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EmissionsResumed as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EmissionsResumed)
                }
                Some(<EmissionsStarted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EmissionsStarted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EmissionsStarted)
                }
                Some(<Paused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Paused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Paused)
                }
                Some(<RoleAdminChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleAdminChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleAdminChanged)
                }
                Some(<RoleGranted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleGranted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleGranted)
                }
                Some(<RoleRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleRevoked)
                }
                Some(<Transfer as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Transfer as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Transfer)
                }
                Some(<Unpaused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Unpaused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Unpaused)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for SyndicateTokenEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Approval(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeAuthorized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeDataUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeDeauthorized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeLimitsSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeProxyUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DelegateChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DelegateVotesChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EIP712DomainChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EmissionMinted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EmissionsPaused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EmissionsResumed(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EmissionsStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Transfer(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Approval(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeAuthorized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeDataUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeDeauthorized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeLimitsSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeProxyUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DelegateChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DelegateVotesChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EIP712DomainChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EmissionMinted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EmissionsPaused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EmissionsResumed(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EmissionsStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Transfer(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`SyndicateToken`](self) contract instance.

See the [wrapper's documentation](`SyndicateTokenInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> SyndicateTokenInstance<T, P, N> {
        SyndicateTokenInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        defaultAdmin: alloy::sol_types::private::Address,
        syndFoundationAddress: alloy::sol_types::private::Address,
        emissionsManager: alloy::sol_types::private::Address,
        pauser: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<SyndicateTokenInstance<T, P, N>>,
    > {
        SyndicateTokenInstance::<
            T,
            P,
            N,
        >::deploy(
            provider,
            defaultAdmin,
            syndFoundationAddress,
            emissionsManager,
            pauser,
        )
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        defaultAdmin: alloy::sol_types::private::Address,
        syndFoundationAddress: alloy::sol_types::private::Address,
        emissionsManager: alloy::sol_types::private::Address,
        pauser: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        SyndicateTokenInstance::<
            T,
            P,
            N,
        >::deploy_builder(
            provider,
            defaultAdmin,
            syndFoundationAddress,
            emissionsManager,
            pauser,
        )
    }
    /**A [`SyndicateToken`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`SyndicateToken`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct SyndicateTokenInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for SyndicateTokenInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("SyndicateTokenInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyndicateTokenInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`SyndicateToken`](self) contract instance.

See the [wrapper's documentation](`SyndicateTokenInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            defaultAdmin: alloy::sol_types::private::Address,
            syndFoundationAddress: alloy::sol_types::private::Address,
            emissionsManager: alloy::sol_types::private::Address,
            pauser: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<SyndicateTokenInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(
                provider,
                defaultAdmin,
                syndFoundationAddress,
                emissionsManager,
                pauser,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            defaultAdmin: alloy::sol_types::private::Address,
            syndFoundationAddress: alloy::sol_types::private::Address,
            emissionsManager: alloy::sol_types::private::Address,
            pauser: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            defaultAdmin,
                            syndFoundationAddress,
                            emissionsManager,
                            pauser,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> SyndicateTokenInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> SyndicateTokenInstance<T, P, N> {
            SyndicateTokenInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyndicateTokenInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`BRIDGE_LIMIT_DURATION`] function.
        pub fn BRIDGE_LIMIT_DURATION(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, BRIDGE_LIMIT_DURATIONCall, N> {
            self.call_builder(&BRIDGE_LIMIT_DURATIONCall {})
        }
        ///Creates a new call builder for the [`BRIDGE_MANAGER_ROLE`] function.
        pub fn BRIDGE_MANAGER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, BRIDGE_MANAGER_ROLECall, N> {
            self.call_builder(&BRIDGE_MANAGER_ROLECall {})
        }
        ///Creates a new call builder for the [`CLOCK_MODE`] function.
        pub fn CLOCK_MODE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, CLOCK_MODECall, N> {
            self.call_builder(&CLOCK_MODECall {})
        }
        ///Creates a new call builder for the [`DEFAULT_ADMIN_ROLE`] function.
        pub fn DEFAULT_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, DEFAULT_ADMIN_ROLECall, N> {
            self.call_builder(&DEFAULT_ADMIN_ROLECall {})
        }
        ///Creates a new call builder for the [`DOMAIN_SEPARATOR`] function.
        pub fn DOMAIN_SEPARATOR(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, DOMAIN_SEPARATORCall, N> {
            self.call_builder(&DOMAIN_SEPARATORCall {})
        }
        ///Creates a new call builder for the [`EMISSIONS_MANAGER_ROLE`] function.
        pub fn EMISSIONS_MANAGER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSIONS_MANAGER_ROLECall, N> {
            self.call_builder(&EMISSIONS_MANAGER_ROLECall {})
        }
        ///Creates a new call builder for the [`EMISSIONS_SUPPLY`] function.
        pub fn EMISSIONS_SUPPLY(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSIONS_SUPPLYCall, N> {
            self.call_builder(&EMISSIONS_SUPPLYCall {})
        }
        ///Creates a new call builder for the [`EMISSION_BUFFER_TIME`] function.
        pub fn EMISSION_BUFFER_TIME(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSION_BUFFER_TIMECall, N> {
            self.call_builder(&EMISSION_BUFFER_TIMECall {})
        }
        ///Creates a new call builder for the [`EPOCH_DURATION`] function.
        pub fn EPOCH_DURATION(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EPOCH_DURATIONCall, N> {
            self.call_builder(&EPOCH_DURATIONCall {})
        }
        ///Creates a new call builder for the [`INITIAL_MINT_SUPPLY`] function.
        pub fn INITIAL_MINT_SUPPLY(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, INITIAL_MINT_SUPPLYCall, N> {
            self.call_builder(&INITIAL_MINT_SUPPLYCall {})
        }
        ///Creates a new call builder for the [`PAUSER_ROLE`] function.
        pub fn PAUSER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, PAUSER_ROLECall, N> {
            self.call_builder(&PAUSER_ROLECall {})
        }
        ///Creates a new call builder for the [`PRECISION_MULTIPLIER`] function.
        pub fn PRECISION_MULTIPLIER(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, PRECISION_MULTIPLIERCall, N> {
            self.call_builder(&PRECISION_MULTIPLIERCall {})
        }
        ///Creates a new call builder for the [`TOTAL_EPOCHS`] function.
        pub fn TOTAL_EPOCHS(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, TOTAL_EPOCHSCall, N> {
            self.call_builder(&TOTAL_EPOCHSCall {})
        }
        ///Creates a new call builder for the [`TOTAL_SUPPLY`] function.
        pub fn TOTAL_SUPPLY(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, TOTAL_SUPPLYCall, N> {
            self.call_builder(&TOTAL_SUPPLYCall {})
        }
        ///Creates a new call builder for the [`allowance`] function.
        pub fn allowance(
            &self,
            owner: alloy::sol_types::private::Address,
            spender: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, allowanceCall, N> {
            self.call_builder(&allowanceCall { owner, spender })
        }
        ///Creates a new call builder for the [`approve`] function.
        pub fn approve(
            &self,
            spender: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, approveCall, N> {
            self.call_builder(&approveCall { spender, value })
        }
        ///Creates a new call builder for the [`authorizedBridges`] function.
        pub fn authorizedBridges(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, authorizedBridgesCall, N> {
            self.call_builder(&authorizedBridgesCall { _0 })
        }
        ///Creates a new call builder for the [`balanceOf`] function.
        pub fn balanceOf(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, balanceOfCall, N> {
            self.call_builder(&balanceOfCall { account })
        }
        ///Creates a new call builder for the [`bridgeData`] function.
        pub fn bridgeData(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeDataCall, N> {
            self.call_builder(&bridgeDataCall {})
        }
        ///Creates a new call builder for the [`bridgeLimits`] function.
        pub fn bridgeLimits(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeLimitsCall, N> {
            self.call_builder(&bridgeLimitsCall { _0 })
        }
        ///Creates a new call builder for the [`bridgeProxy`] function.
        pub fn bridgeProxy(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeProxyCall, N> {
            self.call_builder(&bridgeProxyCall {})
        }
        ///Creates a new call builder for the [`burn`] function.
        pub fn burn(
            &self,
            _user: alloy::sol_types::private::Address,
            _amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, burnCall, N> {
            self.call_builder(&burnCall { _user, _amount })
        }
        ///Creates a new call builder for the [`burningCurrentLimitOf`] function.
        pub fn burningCurrentLimitOf(
            &self,
            _bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, burningCurrentLimitOfCall, N> {
            self.call_builder(
                &burningCurrentLimitOfCall {
                    _bridge,
                },
            )
        }
        ///Creates a new call builder for the [`burningMaxLimitOf`] function.
        pub fn burningMaxLimitOf(
            &self,
            _bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, burningMaxLimitOfCall, N> {
            self.call_builder(&burningMaxLimitOfCall { _bridge })
        }
        ///Creates a new call builder for the [`checkpoints`] function.
        pub fn checkpoints(
            &self,
            account: alloy::sol_types::private::Address,
            pos: u32,
        ) -> alloy_contract::SolCallBuilder<T, &P, checkpointsCall, N> {
            self.call_builder(&checkpointsCall { account, pos })
        }
        ///Creates a new call builder for the [`clock`] function.
        pub fn clock(&self) -> alloy_contract::SolCallBuilder<T, &P, clockCall, N> {
            self.call_builder(&clockCall {})
        }
        ///Creates a new call builder for the [`currentEpoch`] function.
        pub fn currentEpoch(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, currentEpochCall, N> {
            self.call_builder(&currentEpochCall {})
        }
        ///Creates a new call builder for the [`decimals`] function.
        pub fn decimals(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, decimalsCall, N> {
            self.call_builder(&decimalsCall {})
        }
        ///Creates a new call builder for the [`delegate`] function.
        pub fn delegate(
            &self,
            delegatee: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, delegateCall, N> {
            self.call_builder(&delegateCall { delegatee })
        }
        ///Creates a new call builder for the [`delegateBySig`] function.
        pub fn delegateBySig(
            &self,
            delegatee: alloy::sol_types::private::Address,
            nonce: alloy::sol_types::private::primitives::aliases::U256,
            expiry: alloy::sol_types::private::primitives::aliases::U256,
            v: u8,
            r: alloy::sol_types::private::FixedBytes<32>,
            s: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, delegateBySigCall, N> {
            self.call_builder(
                &delegateBySigCall {
                    delegatee,
                    nonce,
                    expiry,
                    v,
                    r,
                    s,
                },
            )
        }
        ///Creates a new call builder for the [`delegates`] function.
        pub fn delegates(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, delegatesCall, N> {
            self.call_builder(&delegatesCall { account })
        }
        ///Creates a new call builder for the [`eip712Domain`] function.
        pub fn eip712Domain(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, eip712DomainCall, N> {
            self.call_builder(&eip712DomainCall {})
        }
        ///Creates a new call builder for the [`emissionSchedule`] function.
        pub fn emissionSchedule(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionScheduleCall, N> {
            self.call_builder(&emissionScheduleCall { _0 })
        }
        ///Creates a new call builder for the [`emissionsActive`] function.
        pub fn emissionsActive(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionsActiveCall, N> {
            self.call_builder(&emissionsActiveCall {})
        }
        ///Creates a new call builder for the [`emissionsEnded`] function.
        pub fn emissionsEnded(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionsEndedCall, N> {
            self.call_builder(&emissionsEndedCall {})
        }
        ///Creates a new call builder for the [`emissionsStartTime`] function.
        pub fn emissionsStartTime(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionsStartTimeCall, N> {
            self.call_builder(&emissionsStartTimeCall {})
        }
        ///Creates a new call builder for the [`emissionsStarted`] function.
        pub fn emissionsStarted(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionsStartedCall, N> {
            self.call_builder(&emissionsStartedCall {})
        }
        ///Creates a new call builder for the [`getBridgeConfiguration`] function.
        pub fn getBridgeConfiguration(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBridgeConfigurationCall, N> {
            self.call_builder(&getBridgeConfigurationCall {})
        }
        ///Creates a new call builder for the [`getBridgeInfo`] function.
        pub fn getBridgeInfo(
            &self,
            bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBridgeInfoCall, N> {
            self.call_builder(&getBridgeInfoCall { bridge })
        }
        ///Creates a new call builder for the [`getBridgeUtilization`] function.
        pub fn getBridgeUtilization(
            &self,
            bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBridgeUtilizationCall, N> {
            self.call_builder(&getBridgeUtilizationCall { bridge })
        }
        ///Creates a new call builder for the [`getCurrentEpochInfo`] function.
        pub fn getCurrentEpochInfo(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getCurrentEpochInfoCall, N> {
            self.call_builder(&getCurrentEpochInfoCall {})
        }
        ///Creates a new call builder for the [`getCurrentTotalSupply`] function.
        pub fn getCurrentTotalSupply(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getCurrentTotalSupplyCall, N> {
            self.call_builder(&getCurrentTotalSupplyCall {})
        }
        ///Creates a new call builder for the [`getEmissionSchedule`] function.
        pub fn getEmissionSchedule(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getEmissionScheduleCall, N> {
            self.call_builder(&getEmissionScheduleCall {})
        }
        ///Creates a new call builder for the [`getNextEmissionTime`] function.
        pub fn getNextEmissionTime(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getNextEmissionTimeCall, N> {
            self.call_builder(&getNextEmissionTimeCall {})
        }
        ///Creates a new call builder for the [`getPastTotalSupply`] function.
        pub fn getPastTotalSupply(
            &self,
            timepoint: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getPastTotalSupplyCall, N> {
            self.call_builder(
                &getPastTotalSupplyCall {
                    timepoint,
                },
            )
        }
        ///Creates a new call builder for the [`getPastVotes`] function.
        pub fn getPastVotes(
            &self,
            account: alloy::sol_types::private::Address,
            timepoint: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getPastVotesCall, N> {
            self.call_builder(
                &getPastVotesCall {
                    account,
                    timepoint,
                },
            )
        }
        ///Creates a new call builder for the [`getPastVotingPower`] function.
        pub fn getPastVotingPower(
            &self,
            account: alloy::sol_types::private::Address,
            blockNumber: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getPastVotingPowerCall, N> {
            self.call_builder(
                &getPastVotingPowerCall {
                    account,
                    blockNumber,
                },
            )
        }
        ///Creates a new call builder for the [`getRemainingEmissions`] function.
        pub fn getRemainingEmissions(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRemainingEmissionsCall, N> {
            self.call_builder(&getRemainingEmissionsCall {})
        }
        ///Creates a new call builder for the [`getRoleAdmin`] function.
        pub fn getRoleAdmin(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRoleAdminCall, N> {
            self.call_builder(&getRoleAdminCall { role })
        }
        ///Creates a new call builder for the [`getVotes`] function.
        pub fn getVotes(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getVotesCall, N> {
            self.call_builder(&getVotesCall { account })
        }
        ///Creates a new call builder for the [`getVotingPower`] function.
        pub fn getVotingPower(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getVotingPowerCall, N> {
            self.call_builder(&getVotingPowerCall { account })
        }
        ///Creates a new call builder for the [`grantRole`] function.
        pub fn grantRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, grantRoleCall, N> {
            self.call_builder(&grantRoleCall { role, account })
        }
        ///Creates a new call builder for the [`hasRole`] function.
        pub fn hasRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, hasRoleCall, N> {
            self.call_builder(&hasRoleCall { role, account })
        }
        ///Creates a new call builder for the [`isBridge`] function.
        pub fn isBridge(
            &self,
            bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, isBridgeCall, N> {
            self.call_builder(&isBridgeCall { bridge })
        }
        ///Creates a new call builder for the [`mint`] function.
        pub fn mint(
            &self,
            _user: alloy::sol_types::private::Address,
            _amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, mintCall, N> {
            self.call_builder(&mintCall { _user, _amount })
        }
        ///Creates a new call builder for the [`mintEmission`] function.
        pub fn mintEmission(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, mintEmissionCall, N> {
            self.call_builder(&mintEmissionCall {})
        }
        ///Creates a new call builder for the [`mintingCurrentLimitOf`] function.
        pub fn mintingCurrentLimitOf(
            &self,
            _bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, mintingCurrentLimitOfCall, N> {
            self.call_builder(
                &mintingCurrentLimitOfCall {
                    _bridge,
                },
            )
        }
        ///Creates a new call builder for the [`mintingMaxLimitOf`] function.
        pub fn mintingMaxLimitOf(
            &self,
            _bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, mintingMaxLimitOfCall, N> {
            self.call_builder(&mintingMaxLimitOfCall { _bridge })
        }
        ///Creates a new call builder for the [`name`] function.
        pub fn name(&self) -> alloy_contract::SolCallBuilder<T, &P, nameCall, N> {
            self.call_builder(&nameCall {})
        }
        ///Creates a new call builder for the [`nonces`] function.
        pub fn nonces(
            &self,
            owner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, noncesCall, N> {
            self.call_builder(&noncesCall { owner })
        }
        ///Creates a new call builder for the [`numCheckpoints`] function.
        pub fn numCheckpoints(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, numCheckpointsCall, N> {
            self.call_builder(&numCheckpointsCall { account })
        }
        ///Creates a new call builder for the [`pause`] function.
        pub fn pause(&self) -> alloy_contract::SolCallBuilder<T, &P, pauseCall, N> {
            self.call_builder(&pauseCall {})
        }
        ///Creates a new call builder for the [`pauseEmissions`] function.
        pub fn pauseEmissions(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, pauseEmissionsCall, N> {
            self.call_builder(&pauseEmissionsCall {})
        }
        ///Creates a new call builder for the [`paused`] function.
        pub fn paused(&self) -> alloy_contract::SolCallBuilder<T, &P, pausedCall, N> {
            self.call_builder(&pausedCall {})
        }
        ///Creates a new call builder for the [`permit`] function.
        pub fn permit(
            &self,
            owner: alloy::sol_types::private::Address,
            spender: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
            deadline: alloy::sol_types::private::primitives::aliases::U256,
            v: u8,
            r: alloy::sol_types::private::FixedBytes<32>,
            s: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, permitCall, N> {
            self.call_builder(
                &permitCall {
                    owner,
                    spender,
                    value,
                    deadline,
                    v,
                    r,
                    s,
                },
            )
        }
        ///Creates a new call builder for the [`renounceRole`] function.
        pub fn renounceRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            callerConfirmation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceRoleCall, N> {
            self.call_builder(
                &renounceRoleCall {
                    role,
                    callerConfirmation,
                },
            )
        }
        ///Creates a new call builder for the [`resumeEmissions`] function.
        pub fn resumeEmissions(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, resumeEmissionsCall, N> {
            self.call_builder(&resumeEmissionsCall {})
        }
        ///Creates a new call builder for the [`revokeRole`] function.
        pub fn revokeRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, revokeRoleCall, N> {
            self.call_builder(&revokeRoleCall { role, account })
        }
        ///Creates a new call builder for the [`setBridgeData`] function.
        pub fn setBridgeData(
            &self,
            _bridgeData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBridgeDataCall, N> {
            self.call_builder(&setBridgeDataCall { _bridgeData })
        }
        ///Creates a new call builder for the [`setBridgeProxy`] function.
        pub fn setBridgeProxy(
            &self,
            _bridgeProxy: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBridgeProxyCall, N> {
            self.call_builder(&setBridgeProxyCall { _bridgeProxy })
        }
        ///Creates a new call builder for the [`setLimits`] function.
        pub fn setLimits(
            &self,
            _bridge: alloy::sol_types::private::Address,
            _mintingLimit: alloy::sol_types::private::primitives::aliases::U256,
            _burningLimit: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, setLimitsCall, N> {
            self.call_builder(
                &setLimitsCall {
                    _bridge,
                    _mintingLimit,
                    _burningLimit,
                },
            )
        }
        ///Creates a new call builder for the [`startEmissions`] function.
        pub fn startEmissions(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, startEmissionsCall, N> {
            self.call_builder(&startEmissionsCall {})
        }
        ///Creates a new call builder for the [`supportsInterface`] function.
        pub fn supportsInterface(
            &self,
            interfaceId: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<T, &P, supportsInterfaceCall, N> {
            self.call_builder(
                &supportsInterfaceCall {
                    interfaceId,
                },
            )
        }
        ///Creates a new call builder for the [`symbol`] function.
        pub fn symbol(&self) -> alloy_contract::SolCallBuilder<T, &P, symbolCall, N> {
            self.call_builder(&symbolCall {})
        }
        ///Creates a new call builder for the [`totalEmissionsMinted`] function.
        pub fn totalEmissionsMinted(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, totalEmissionsMintedCall, N> {
            self.call_builder(&totalEmissionsMintedCall {})
        }
        ///Creates a new call builder for the [`totalSupply`] function.
        pub fn totalSupply(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, totalSupplyCall, N> {
            self.call_builder(&totalSupplyCall {})
        }
        ///Creates a new call builder for the [`transfer`] function.
        pub fn transfer(
            &self,
            to: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferCall, N> {
            self.call_builder(&transferCall { to, value })
        }
        ///Creates a new call builder for the [`transferFrom`] function.
        pub fn transferFrom(
            &self,
            from: alloy::sol_types::private::Address,
            to: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferFromCall, N> {
            self.call_builder(
                &transferFromCall {
                    from,
                    to,
                    value,
                },
            )
        }
        ///Creates a new call builder for the [`unpause`] function.
        pub fn unpause(&self) -> alloy_contract::SolCallBuilder<T, &P, unpauseCall, N> {
            self.call_builder(&unpauseCall {})
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyndicateTokenInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`Approval`] event.
        pub fn Approval_filter(&self) -> alloy_contract::Event<T, &P, Approval, N> {
            self.event_filter::<Approval>()
        }
        ///Creates a new event filter for the [`BridgeAuthorized`] event.
        pub fn BridgeAuthorized_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeAuthorized, N> {
            self.event_filter::<BridgeAuthorized>()
        }
        ///Creates a new event filter for the [`BridgeDataUpdated`] event.
        pub fn BridgeDataUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeDataUpdated, N> {
            self.event_filter::<BridgeDataUpdated>()
        }
        ///Creates a new event filter for the [`BridgeDeauthorized`] event.
        pub fn BridgeDeauthorized_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeDeauthorized, N> {
            self.event_filter::<BridgeDeauthorized>()
        }
        ///Creates a new event filter for the [`BridgeLimitsSet`] event.
        pub fn BridgeLimitsSet_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeLimitsSet, N> {
            self.event_filter::<BridgeLimitsSet>()
        }
        ///Creates a new event filter for the [`BridgeProxyUpdated`] event.
        pub fn BridgeProxyUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeProxyUpdated, N> {
            self.event_filter::<BridgeProxyUpdated>()
        }
        ///Creates a new event filter for the [`DelegateChanged`] event.
        pub fn DelegateChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, DelegateChanged, N> {
            self.event_filter::<DelegateChanged>()
        }
        ///Creates a new event filter for the [`DelegateVotesChanged`] event.
        pub fn DelegateVotesChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, DelegateVotesChanged, N> {
            self.event_filter::<DelegateVotesChanged>()
        }
        ///Creates a new event filter for the [`EIP712DomainChanged`] event.
        pub fn EIP712DomainChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EIP712DomainChanged, N> {
            self.event_filter::<EIP712DomainChanged>()
        }
        ///Creates a new event filter for the [`EmissionMinted`] event.
        pub fn EmissionMinted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EmissionMinted, N> {
            self.event_filter::<EmissionMinted>()
        }
        ///Creates a new event filter for the [`EmissionsPaused`] event.
        pub fn EmissionsPaused_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EmissionsPaused, N> {
            self.event_filter::<EmissionsPaused>()
        }
        ///Creates a new event filter for the [`EmissionsResumed`] event.
        pub fn EmissionsResumed_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EmissionsResumed, N> {
            self.event_filter::<EmissionsResumed>()
        }
        ///Creates a new event filter for the [`EmissionsStarted`] event.
        pub fn EmissionsStarted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EmissionsStarted, N> {
            self.event_filter::<EmissionsStarted>()
        }
        ///Creates a new event filter for the [`Paused`] event.
        pub fn Paused_filter(&self) -> alloy_contract::Event<T, &P, Paused, N> {
            self.event_filter::<Paused>()
        }
        ///Creates a new event filter for the [`RoleAdminChanged`] event.
        pub fn RoleAdminChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleAdminChanged, N> {
            self.event_filter::<RoleAdminChanged>()
        }
        ///Creates a new event filter for the [`RoleGranted`] event.
        pub fn RoleGranted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleGranted, N> {
            self.event_filter::<RoleGranted>()
        }
        ///Creates a new event filter for the [`RoleRevoked`] event.
        pub fn RoleRevoked_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleRevoked, N> {
            self.event_filter::<RoleRevoked>()
        }
        ///Creates a new event filter for the [`Transfer`] event.
        pub fn Transfer_filter(&self) -> alloy_contract::Event<T, &P, Transfer, N> {
            self.event_filter::<Transfer>()
        }
        ///Creates a new event filter for the [`Unpaused`] event.
        pub fn Unpaused_filter(&self) -> alloy_contract::Event<T, &P, Unpaused, N> {
            self.event_filter::<Unpaused>()
        }
    }
}
