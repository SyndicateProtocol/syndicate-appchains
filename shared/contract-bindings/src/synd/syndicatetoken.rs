///Module containing a contract's types and functions.
/**

```solidity
library Checkpoints {
    struct Checkpoint208 { uint48 _key; uint208 _value; }
}
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod Checkpoints {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /**```solidity
struct Checkpoint208 { uint48 _key; uint208 _value; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Checkpoint208 {
        #[allow(missing_docs)]
        pub _key: alloy::sol_types::private::primitives::aliases::U48,
        #[allow(missing_docs)]
        pub _value: alloy::sol_types::private::primitives::aliases::U208,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<48>,
            alloy::sol_types::sol_data::Uint<208>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U48,
            alloy::sol_types::private::primitives::aliases::U208,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Checkpoint208> for UnderlyingRustTuple<'_> {
            fn from(value: Checkpoint208) -> Self {
                (value._key, value._value)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Checkpoint208 {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    _key: tuple.0,
                    _value: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Checkpoint208 {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Checkpoint208 {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(&self._key),
                    <alloy::sol_types::sol_data::Uint<
                        208,
                    > as alloy_sol_types::SolType>::tokenize(&self._value),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Checkpoint208 {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Checkpoint208 {
            const NAME: &'static str = "Checkpoint208";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Checkpoint208(uint48 _key,uint208 _value)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self._key)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        208,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self._value)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Checkpoint208 {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust._key)
                    + <alloy::sol_types::sol_data::Uint<
                        208,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust._value,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    48,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust._key,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    208,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust._value,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`Checkpoints`](self) contract instance.

See the [wrapper's documentation](`CheckpointsInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> CheckpointsInstance<T, P, N> {
        CheckpointsInstance::<T, P, N>::new(address, provider)
    }
    /**A [`Checkpoints`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`Checkpoints`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct CheckpointsInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for CheckpointsInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("CheckpointsInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > CheckpointsInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`Checkpoints`](self) contract instance.

See the [wrapper's documentation](`CheckpointsInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> CheckpointsInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> CheckpointsInstance<T, P, N> {
            CheckpointsInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > CheckpointsInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > CheckpointsInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
/**

Generated by the following Solidity interface...
```solidity
library Checkpoints {
    struct Checkpoint208 {
        uint48 _key;
        uint208 _value;
    }
}

interface SyndicateToken {
    error AccessControlBadConfirmation();
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
    error AllEmissionsCompleted();
    error BridgeNotAuthorized();
    error BridgeNotConfigured();
    error CheckpointUnorderedInsertion();
    error ECDSAInvalidSignature();
    error ECDSAInvalidSignatureLength(uint256 length);
    error ECDSAInvalidSignatureS(bytes32 s);
    error ERC20ExceededSafeSupply(uint256 increasedSupply, uint256 cap);
    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);
    error ERC20InvalidApprover(address approver);
    error ERC20InvalidReceiver(address receiver);
    error ERC20InvalidSender(address sender);
    error ERC20InvalidSpender(address spender);
    error ERC2612ExpiredSignature(uint256 deadline);
    error ERC2612InvalidSigner(address signer, address owner);
    error ERC5805FutureLookup(uint256 timepoint, uint48 clock);
    error ERC6372InconsistentClock();
    error EmissionTooEarly();
    error EmissionsAlreadyStarted();
    error EmissionsNotActive();
    error EmissionsNotStarted();
    error EnforcedPause();
    error ExceedsEmissionsSupply();
    error ExpectedPause();
    error InsufficientLimit();
    error InvalidAccountNonce(address account, uint256 currentNonce);
    error InvalidShortString();
    error ReentrancyGuardReentrantCall();
    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);
    error StringTooLong(string str);
    error VotesExpiredSignature(uint256 expiry);
    error ZeroAddress();
    error ZeroAmount();

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event BridgeAuthorized(address indexed bridge);
    event BridgeDataUpdated(bytes oldData, bytes newData);
    event BridgeDeauthorized(address indexed bridge);
    event BridgeLimitsSet(address indexed bridge, uint256 mintingLimit, uint256 burningLimit);
    event BridgeProxyUpdated(address indexed oldProxy, address indexed newProxy);
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    event DelegateVotesChanged(address indexed delegate, uint256 previousVotes, uint256 newVotes);
    event EIP712DomainChanged();
    event EmissionMinted(uint256 epoch, uint256 amount, address indexed destination);
    event EmissionsPaused();
    event EmissionsResumed();
    event EmissionsStarted(uint256 startTime);
    event Paused(address account);
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Unpaused(address account);

    constructor(address defaultAdmin, address syndFoundationAddress, address emissionsManager, address pauser);

    function BRIDGE_LIMIT_DURATION() external view returns (uint256);
    function BRIDGE_MANAGER_ROLE() external view returns (bytes32);
    function CLOCK_MODE() external view returns (string memory);
    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function EMISSIONS_MANAGER_ROLE() external view returns (bytes32);
    function EMISSIONS_SUPPLY() external view returns (uint256);
    function EMISSION_BUFFER_TIME() external view returns (uint256);
    function EPOCH_DURATION() external view returns (uint256);
    function INITIAL_MINT_SUPPLY() external view returns (uint256);
    function PAUSER_ROLE() external view returns (bytes32);
    function PRECISION_MULTIPLIER() external view returns (uint256);
    function TOTAL_EPOCHS() external view returns (uint256);
    function TOTAL_SUPPLY() external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
    function authorizedBridges(address) external view returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function bridgeData() external view returns (bytes memory);
    function bridgeLimits(address) external view returns (uint256 mintingMaxLimit, uint256 mintingCurrentLimit, uint256 burningMaxLimit, uint256 burningCurrentLimit, uint256 lastUpdate);
    function bridgeProxy() external view returns (address);
    function burn(address _user, uint256 _amount) external;
    function burningCurrentLimitOf(address _bridge) external view returns (uint256);
    function burningMaxLimitOf(address _bridge) external view returns (uint256);
    function checkpoints(address account, uint32 pos) external view returns (Checkpoints.Checkpoint208 memory);
    function clock() external view returns (uint48);
    function currentEpoch() external view returns (uint256);
    function decimals() external view returns (uint8);
    function delegate(address delegatee) external;
    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;
    function delegates(address account) external view returns (address);
    function eip712Domain() external view returns (bytes1 fields, string memory name, string memory version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] memory extensions);
    function emissionSchedule(uint256) external view returns (uint256);
    function emissionsActive() external view returns (bool);
    function emissionsEnded() external view returns (bool);
    function emissionsStartTime() external view returns (uint256);
    function emissionsStarted() external view returns (bool);
    function getBridgeConfiguration() external view returns (address proxy, bytes memory data);
    function getBridgeInfo(address bridge) external view returns (bool authorized, uint256 mintingMax, uint256 mintingCurrent, uint256 burningMax, uint256 burningCurrent);
    function getBridgeUtilization(address bridge) external view returns (uint256 mintingUtilization, uint256 burningUtilization);
    function getCurrentEpochInfo() external view returns (uint256 epoch, uint256 nextEmissionTime, uint256 nextEmissionAmount, bool canMintEmission);
    function getCurrentTotalSupply() external view returns (uint256);
    function getEmissionSchedule() external view returns (uint256[48] memory);
    function getNextEmissionTime() external view returns (uint256);
    function getPastTotalSupply(uint256 timepoint) external view returns (uint256);
    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);
    function getPastVotingPower(address account, uint256 blockNumber) external view returns (uint256);
    function getRemainingEmissions() external view returns (uint256);
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function getVotes(address account) external view returns (uint256);
    function getVotingPower(address account) external view returns (uint256);
    function grantRole(bytes32 role, address account) external;
    function hasRole(bytes32 role, address account) external view returns (bool);
    function isBridge(address bridge) external view returns (bool);
    function mint(address _user, uint256 _amount) external;
    function mintEmission() external;
    function mintingCurrentLimitOf(address _bridge) external view returns (uint256);
    function mintingMaxLimitOf(address _bridge) external view returns (uint256);
    function name() external view returns (string memory);
    function nonces(address owner) external view returns (uint256);
    function numCheckpoints(address account) external view returns (uint32);
    function pause() external;
    function pauseEmissions() external;
    function paused() external view returns (bool);
    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
    function renounceRole(bytes32 role, address callerConfirmation) external;
    function resumeEmissions() external;
    function revokeRole(bytes32 role, address account) external;
    function setBridgeData(bytes memory _bridgeData) external;
    function setBridgeProxy(address _bridgeProxy) external;
    function setLimits(address _bridge, uint256 _mintingLimit, uint256 _burningLimit) external;
    function startEmissions() external;
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
    function symbol() external view returns (string memory);
    function totalEmissionsMinted() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
    function unpause() external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "defaultAdmin",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "syndFoundationAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "emissionsManager",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "pauser",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "BRIDGE_LIMIT_DURATION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "BRIDGE_MANAGER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "CLOCK_MODE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DEFAULT_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DOMAIN_SEPARATOR",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSIONS_MANAGER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSIONS_SUPPLY",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSION_BUFFER_TIME",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EPOCH_DURATION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "INITIAL_MINT_SUPPLY",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "PAUSER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "PRECISION_MULTIPLIER",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "TOTAL_EPOCHS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "TOTAL_SUPPLY",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "allowance",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "approve",
    "inputs": [
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "authorizedBridges",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "balanceOf",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeData",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeLimits",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "mintingMaxLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "mintingCurrentLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "burningMaxLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "burningCurrentLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "lastUpdate",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeProxy",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IBridgeProxy"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "burn",
    "inputs": [
      {
        "name": "_user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "burningCurrentLimitOf",
    "inputs": [
      {
        "name": "_bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "burningMaxLimitOf",
    "inputs": [
      {
        "name": "_bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "checkpoints",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "pos",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct Checkpoints.Checkpoint208",
        "components": [
          {
            "name": "_key",
            "type": "uint48",
            "internalType": "uint48"
          },
          {
            "name": "_value",
            "type": "uint208",
            "internalType": "uint208"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "clock",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint48",
        "internalType": "uint48"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "currentEpoch",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "decimals",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "uint8"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "delegate",
    "inputs": [
      {
        "name": "delegatee",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "delegateBySig",
    "inputs": [
      {
        "name": "delegatee",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "nonce",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "expiry",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "v",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "r",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "delegates",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "eip712Domain",
    "inputs": [],
    "outputs": [
      {
        "name": "fields",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "version",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "verifyingContract",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "salt",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "extensions",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionSchedule",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionsActive",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionsEnded",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionsStartTime",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionsStarted",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBridgeConfiguration",
    "inputs": [],
    "outputs": [
      {
        "name": "proxy",
        "type": "address",
        "internalType": "contract IBridgeProxy"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBridgeInfo",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "authorized",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "mintingMax",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "mintingCurrent",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "burningMax",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "burningCurrent",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBridgeUtilization",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "mintingUtilization",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "burningUtilization",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCurrentEpochInfo",
    "inputs": [],
    "outputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nextEmissionTime",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nextEmissionAmount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "canMintEmission",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCurrentTotalSupply",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getEmissionSchedule",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256[48]",
        "internalType": "uint256[48]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getNextEmissionTime",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPastTotalSupply",
    "inputs": [
      {
        "name": "timepoint",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPastVotes",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "timepoint",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPastVotingPower",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "blockNumber",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRemainingEmissions",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleAdmin",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getVotes",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getVotingPower",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "grantRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "hasRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isBridge",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "mint",
    "inputs": [
      {
        "name": "_user",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "mintEmission",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "mintingCurrentLimitOf",
    "inputs": [
      {
        "name": "_bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "mintingMaxLimitOf",
    "inputs": [
      {
        "name": "_bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "name",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "nonces",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "numCheckpoints",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "pauseEmissions",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "paused",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "permit",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "deadline",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "v",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "r",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "callerConfirmation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "resumeEmissions",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBridgeData",
    "inputs": [
      {
        "name": "_bridgeData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBridgeProxy",
    "inputs": [
      {
        "name": "_bridgeProxy",
        "type": "address",
        "internalType": "contract IBridgeProxy"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setLimits",
    "inputs": [
      {
        "name": "_bridge",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_mintingLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "_burningLimit",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "startEmissions",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "symbol",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "totalEmissionsMinted",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "totalSupply",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "transfer",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferFrom",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "unpause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "Approval",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "spender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeAuthorized",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeDataUpdated",
    "inputs": [
      {
        "name": "oldData",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      },
      {
        "name": "newData",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeDeauthorized",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeLimitsSet",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "mintingLimit",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "burningLimit",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeProxyUpdated",
    "inputs": [
      {
        "name": "oldProxy",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newProxy",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DelegateChanged",
    "inputs": [
      {
        "name": "delegator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "fromDelegate",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "toDelegate",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DelegateVotesChanged",
    "inputs": [
      {
        "name": "delegate",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "previousVotes",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "newVotes",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EIP712DomainChanged",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EmissionMinted",
    "inputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "destination",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EmissionsPaused",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EmissionsResumed",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EmissionsStarted",
    "inputs": [
      {
        "name": "startTime",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Paused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleAdminChanged",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "previousAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleGranted",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleRevoked",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Transfer",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Unpaused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AccessControlBadConfirmation",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AccessControlUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "neededRole",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "AllEmissionsCompleted",
    "inputs": []
  },
  {
    "type": "error",
    "name": "BridgeNotAuthorized",
    "inputs": []
  },
  {
    "type": "error",
    "name": "BridgeNotConfigured",
    "inputs": []
  },
  {
    "type": "error",
    "name": "CheckpointUnorderedInsertion",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignature",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureLength",
    "inputs": [
      {
        "name": "length",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureS",
    "inputs": [
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20ExceededSafeSupply",
    "inputs": [
      {
        "name": "increasedSupply",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "cap",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InsufficientAllowance",
    "inputs": [
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "allowance",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "needed",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InsufficientBalance",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "balance",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "needed",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidApprover",
    "inputs": [
      {
        "name": "approver",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidReceiver",
    "inputs": [
      {
        "name": "receiver",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidSender",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidSpender",
    "inputs": [
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC2612ExpiredSignature",
    "inputs": [
      {
        "name": "deadline",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC2612InvalidSigner",
    "inputs": [
      {
        "name": "signer",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC5805FutureLookup",
    "inputs": [
      {
        "name": "timepoint",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "clock",
        "type": "uint48",
        "internalType": "uint48"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC6372InconsistentClock",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmissionTooEarly",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmissionsAlreadyStarted",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmissionsNotActive",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmissionsNotStarted",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EnforcedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ExceedsEmissionsSupply",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ExpectedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientLimit",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidAccountNonce",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "currentNonce",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidShortString",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ReentrancyGuardReentrantCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SafeCastOverflowedUintDowncast",
    "inputs": [
      {
        "name": "bits",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "StringTooLong",
    "inputs": [
      {
        "name": "str",
        "type": "string",
        "internalType": "string"
      }
    ]
  },
  {
    "type": "error",
    "name": "VotesExpiredSignature",
    "inputs": [
      {
        "name": "expiry",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ZeroAddress",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroAmount",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod SyndicateToken {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x610160604052346100765761001e610015610163565b9291909161035e565b61002661007b565b6176436120be823960805181614fbe015260a05181614ff5015260c05181614f85015260e05181615bdd01526101005181615c020152610120518161578f015261014051816157cf015261764390f35b610081565b60405190565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b906100ad90610085565b810190811060018060401b038211176100c557604052565b61008f565b906100dd6100d661007b565b92836100a3565b565b5f80fd5b60018060a01b031690565b6100f7906100e3565b90565b610103816100ee565b0361010a57565b5f80fd5b9050519061011b826100fa565b565b60808183031261015e57610133825f830161010e565b9261015b610144846020850161010e565b93610152816040860161010e565b9360600161010e565b90565b6100df565b61018161970180380380610176816100ca565b92833981019061011d565b90919293565b60018060401b0381116101a35761019f602091610085565b0190565b61008f565b906101ba6101b583610187565b6100ca565b918252565b5f7f53796e6469636174650000000000000000000000000000000000000000000000910152565b6101f060096101a8565b906101fd602083016101bf565b565b6102076101e6565b90565b5f7f53594e4400000000000000000000000000000000000000000000000000000000910152565b61023b60046101a8565b906102486020830161020a565b565b610252610231565b90565b90565b90565b61026f61026a61027492610255565b610258565b6100e3565b90565b6102809061025b565b90565b5f0190565b90565b5f1b90565b6102a461029f6102a992610255565b61028b565b610288565b90565b6102b55f610290565b90565b7f6b9725f740f94b91b78060a1b17d1774656d381421a529ec98cdb013f4d9c25e90565b7fcce296b040332a080e6df13515a3ec2869e21cd20f7344af0987ddb938d8bd2190565b7f65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a90565b90565b90565b61033e61033961034392610324565b610258565b610327565b90565b61035b6b02e87669c308736a0400000061032a565b90565b90919261037a61036c6101ff565b61037461024a565b90610517565b8161039561038f61038a5f610277565b6100ee565b916100ee565b146104b157826103b56103af6103aa5f610277565b6100ee565b916100ee565b1461049557836103d56103cf6103ca5f610277565b6100ee565b916100ee565b1461047957806103f56103ef6103ea5f610277565b6100ee565b916100ee565b1461045d57610436610444926104286104539661041a6104136102ac565b8490610a3b565b506104236102b8565b610a3b565b506104316102dc565b610a3b565b5061043f610300565b610a3b565b5061044d610346565b90610b09565b61045b610e11565b565b5f63d92e233d60e01b81528061047560048201610283565b0390fd5b5f63d92e233d60e01b81528061049160048201610283565b0390fd5b5f63d92e233d60e01b8152806104ad60048201610283565b0390fd5b5f63d92e233d60e01b8152806104c960048201610283565b0390fd5b906104d960ff9161028b565b9181191691161790565b151590565b6104f1906104e3565b90565b90565b9061050c610507610513926104e8565b6104f4565b82546104cd565b9055565b906105219161052e565b61052c5f600f6104f7565b565b61053a918190916105bd565b565b90565b61055361054e6105589261053c565b610258565b610327565b90565b610565600161053f565b90565b906105745f199161028b565b9181191691161790565b61059261058d61059792610327565b610258565b610327565b90565b90565b906105b26105ad6105b99261057e565b61059a565b8254610568565b9055565b906105c892916105dc565b6105da6105d361055b565b600c61059d565b565b906105e792916105e9565b565b906105f492916105f6565b565b906106019291610603565b565b9061060e9291610610565b565b9061061b929161061d565b565b906106289291610675565b565b5f7f3100000000000000000000000000000000000000000000000000000000000000910152565b61065b60016101a8565b906106686020830161062a565b565b610672610651565b90565b90610689929161068361066a565b9061068b565b565b906106979392916106dd565b565b90565b90565b60200190565b5190565b6106bd6106b86106c2926100e3565b610258565b6100e3565b90565b6106ce906106a9565b90565b6106da906106c5565b90565b6106ee61073e946107239394610772565b610702816106fc6006610699565b9061103f565b6101205261071a836107146007610699565b9061103f565b6101405261069c565b61073561072f826106a5565b9161069f565b2060e05261069c565b61075061074a826106a5565b9161069f565b20610100524660a052610761611144565b60805261076d306106d1565b60c052565b9061077c9161077e565b565b906107889161078a565b565b90610794916109db565b565b634e487b7160e01b5f525f60045260245ffd5b5190565b634e487b7160e01b5f52602260045260245ffd5b90600160028304921680156107e1575b60208310146107dc57565b6107ad565b91607f16916107d1565b5f5260205f2090565b601f602091010490565b1b90565b9190600861081d9102916108175f19846107fe565b926107fe565b9181191691161790565b919061083d6108386108459361057e565b61059a565b908354610802565b9055565b5f90565b61085f91610859610849565b91610827565b565b5b81811061086d575050565b8061087a5f60019361084d565b01610862565b9190601f8111610890575b505050565b61089c6108c1936107eb565b9060206108a8846107f4565b830193106108c9575b6108ba906107f4565b0190610861565b5f808061088b565b91506108ba819290506108b1565b1c90565b906108eb905f19906008026108d7565b191690565b816108fa916108db565b906002021790565b9061090c816107a9565b9060018060401b0382116109ca5761092e8261092885546107c1565b85610880565b602090601f831160011461096257918091610951935f92610956575b50506108f0565b90555b565b90915001515f8061094a565b601f19831691610971856107eb565b925f5b8181106109b257509160029391856001969410610998575b50505002019055610954565b6109a8910151601f8416906108db565b90555f808061098c565b91936020600181928787015181550195019201610974565b61008f565b906109d991610902565b565b906109ea6109f19260036109cf565b60046109cf565b565b5f90565b610a0090610288565b90565b90610a0d906109f7565b5f5260205260405f2090565b610a22906106c5565b90565b90610a2f90610a19565b5f5260205260405f2090565b610a436109f3565b50610a58610a528284906111e1565b156104e3565b5f14610ae157610a806001610a7b5f610a7360058690610a03565b018590610a25565b6104f7565b90610a8961120f565b90610ac6610ac0610aba7f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d956109f7565b92610a19565b92610a19565b92610acf61007b565b80610ad981610283565b0390a4600190565b50505f90565b610af0906100ee565b9052565b9190610b07905f60208501940190610ae7565b565b80610b24610b1e610b195f610277565b6100ee565b916100ee565b14610b4057610b3e91610b365f610277565b91909161121c565b565b610b63610b4c5f610277565b5f91829163ec442f0560e01b835260048301610af4565b0390fd5b60018060401b038111610b7a5760200290565b61008f565b610b8b610b9091610b67565b6100ca565b90565b90565b610baa610ba5610baf92610b93565b610258565b610327565b90565b90610bbc90610327565b9052565b90565b610bd7610bd2610bdc92610bc0565b610258565b610327565b90565b90565b610bf6610bf1610bfb92610bdf565b610258565b610327565b90565b90565b610c15610c10610c1a92610bfe565b610258565b610327565b90565b90565b610c34610c2f610c3992610c1d565b610258565b610327565b90565b90565b610c53610c4e610c5892610c3c565b610258565b610327565b90565b90565b610c72610c6d610c7792610c5b565b610258565b610327565b90565b90565b610c91610c8c610c9692610c7a565b610258565b610327565b90565b610cad610ca8610cb292610255565b610258565b610327565b90565b6001610cc19101610327565b90565b90565b610cdb610cd6610ce092610cc4565b610258565b610327565b90565b90565b610cfa610cf5610cff92610ce3565b610258565b610327565b90565b634e487b7160e01b5f52601160045260245ffd5b610d25610d2b91939293610327565b92610327565b91610d37838202610327565b928184041490151715610d4657565b610d02565b610d5a610d6091939293610327565b92610327565b8201809211610d6b57565b610d02565b90565b610d87610d82610d8c92610d70565b610258565b610327565b90565b610d996030610d73565b90565b634e487b7160e01b5f52603260045260245ffd5b50600890565b90610dc082610db0565b811015610dce576020020190565b610d9c565b610ddd9051610327565b90565b50603090565b90565b610df281610de0565b821015610e0c57610e04600191610de6565b910201905f90565b610d9c565b610e1b6008610b7f565b610e3a610e326a059bd65a1eca6db6580000610b96565b5f8301610bb2565b610e5a610e516a035d809c78dfdb6d680000610bc3565b60208301610bb2565b610e7a610e716a0204e6e009f3b7c3a00000610be2565b60408301610bb2565b610e9a610e916a0136242005f8a175600000610c01565b60608301610bb2565b610eb9610eb069ba15acd061fa79a00000610c20565b60808301610bb2565b610ed8610ecf696fa6d26648cb4cf00000610c3f565b60a08301610bb2565b610ef7610eee6942fd5e2c49dda8380000610c5e565b60c08301610bb2565b610f16610f0d6928319ee75f84fe880000610c7d565b60e08301610bb2565b610f1f5f610c99565b915b82610f35610f2f6008610cc7565b91610327565b1015610feb57610f445f610c99565b5b80610f59610f536006610ce6565b91610327565b1015610fda57610fa790610f81610f7a86610f746006610ce6565b90610d16565b8290610d4b565b80610f9b610f95610f90610d8f565b610327565b91610327565b10610fac575b50610cb5565b610f45565b610fd490610fce610fc6610fc1888a90610db6565b610dd3565b916010610de9565b90610827565b5f610fa1565b5091610fe590610cb5565b91610f21565b915050565b5f90565b90565b61100b61100661101092610ff4565b610258565b610327565b90565b90565b61102a61102561102f92611013565b61028b565b610288565b90565b61103c60ff611016565b90565b90611048610ff0565b5061105a6110558361069c565b6106a5565b61106d6110676020610ff7565b91610327565b105f14611081575061107e9061131b565b90565b5f61108f611095939261122b565b016109cf565b6110a56110a0611032565b6109f7565b90565b5f90565b7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f90565b6110da9051610288565b90565b6110e690610288565b9052565b6110f390610327565b9052565b909594926111429461113161113b9261112760809661111d60a088019c5f8901906110dd565b60208701906110dd565b60408501906110dd565b60608301906110ea565b0190610ae7565b565b61114c6110a8565b506111556110ac565b61119f61116260e06110d0565b916111906111716101006110d0565b4661117b306106d1565b9161118461007b565b968795602087016110f7565b602082018103825203826100a3565b6111b16111ab826106a5565b9161069f565b2090565b5f1c90565b60ff1690565b6111cc6111d1916111b5565b6111ba565b90565b6111de90546111c0565b90565b611208915f6111fd611203936111f56109f3565b506005610a03565b01610a25565b6111d4565b90565b5f90565b61121761120b565b503390565b91611229929190916113c8565b565b90565b90565b61124561124061124a9261122e565b610258565b610327565b90565b60209181520190565b90825f9392825e0152565b61128061128960209361128e93611277816107a9565b9384809361124d565b95869101611256565b610085565b0190565b6112a79160208201915f818403910152611261565b90565b6112c46112bf6112b9836106a5565b9261069f565b6110d0565b90602081106112d2575b5090565b6112e4905f19906020036008026107fe565b165f6112ce565b6112f76112fc916111b5565b61057e565b90565b61131361130e61131892610327565b61028b565b610288565b90565b611323610ff0565b5061132d8161069c565b90611337826106a5565b61134a611344601f611231565b91610327565b1161137f57506113778161137161136b61136661137c956112aa565b6112eb565b916106a5565b176112ff565b6109f7565b90565b6113a19061138b61007b565b91829163305a27a960e01b835260048301611292565b0390fd5b9160206113c69294936113bf60408201965f8301906110ea565b01906110ea565b565b92916113d6848383916114f5565b836113f16113eb6113e65f610277565b6100ee565b916100ee565b14611406575b61140492939190916116c2565b565b61140e611664565b936114176116a1565b948061142b61142588610327565b91610327565b11611438575093506113f7565b85906114545f928392630e58ae9360e11b8452600484016113a5565b0390fd5b9061146290610a19565b5f5260205260405f2090565b90565b61147d611482916111b5565b61146e565b90565b61148f9054611471565b90565b6040906114bb6114c294969593966114b160608401985f850190610ae7565b60208301906110ea565b01906110ea565b565b906114cf9103610327565b90565b906114dd9101610327565b90565b91906114f3905f602085019401906110ea565b565b9190918061151361150d6115085f610277565b6100ee565b916100ee565b145f146115f4576115376115308361152b6002611485565b610d4b565b600261059d565b5b8261155361154d6115485f610277565b6100ee565b916100ee565b145f146115c8576115776115708361156b6002611485565b6114c4565b600261059d565b5b9190916115c36115b16115ab7fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef93610a19565b93610a19565b936115ba61007b565b918291826114e0565b0390a3565b6115ef826115e96115da5f8790611458565b916115e483611485565b6114d2565b9061059d565b611578565b6116076116025f8390611458565b611485565b8061161a61161485610327565b91610327565b106116425761162d61163d9184906114c4565b6116385f8490611458565b61059d565b611538565b906116609091925f93849363391434e360e21b855260048501611492565b0390fd5b61166c610849565b506116776002611485565b90565b60018060d01b031690565b61169961169461169e9261167a565b610258565b610327565b90565b6116a9610849565b506116b960018060d01b03611685565b90565b90565b90565b9161171a61171461172194806116e86116e26116dd5f610277565b6100ee565b916100ee565b14611752575b846117096117036116fe5f610277565b6100ee565b916100ee565b14611723575b61194a565b9261194a565b909161197f565b565b61174b600b600261174561173f61173989611834565b936116bc565b916116bf565b90611887565b505061170f565b61177a600b600161177461176e61176889611834565b936116bc565b916116bf565b90611887565b50506116ee565b5f90565b6117916117979161167a565b9161167a565b019060018060d01b0382116117a857565b610d02565b906117c0916117ba611781565b50611785565b90565b90565b60ff1690565b6117e06117db6117e5926117c3565b610258565b6117c6565b90565b6117f1906117cc565b9052565b91602061181692949361180f60408201965f8301906117e8565b01906110ea565b565b61182c61182761183192610327565b610258565b61167a565b90565b61183c611781565b508061185661185060018060d01b03611685565b91610327565b116118675761186490611818565b90565b60d06118835f9283926306dfcc6560e41b8452600484016117f5565b0390fd5b906118bd6118c39392611898611781565b506118a1611781565b5080936118b66118af611b31565b9492611bbf565b909161208e565b91611c34565b91909190565b6118d56118db9161167a565b9161167a565b90039060018060d01b0382116118ed57565b610d02565b90611905916118ff611781565b506118c9565b90565b9061191290610a19565b5f5260205260405f2090565b60018060a01b031690565b61193561193a916111b5565b61191e565b90565b6119479054611929565b90565b6119616119669161195961120b565b506009611908565b61193d565b90565b9061197390610a19565b5f5260205260405f2090565b9190918061199561198f856100ee565b916100ee565b141580611b13575b6119a7575b505050565b806119c26119bc6119b75f610277565b6100ee565b916100ee565b03611a83575b50816119e46119de6119d95f610277565b6100ee565b916100ee565b036119f0575b806119a2565b611a37611a2a611a3192611a06600a8690611969565b90611a24611a1e611a18600193611834565b936116bc565b916116bf565b90611887565b9290611685565b91611685565b919091611a647fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a72492610a19565b92611a79611a7061007b565b928392836113a5565b0390a25f806119ea565b611ac2611ac8611abb611a98600a8590611969565b6002611ab5611aaf611aa989611834565b936116bc565b916116bf565b90611887565b9290611685565b91611685565b919091611af57fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a72492610a19565b92611b0a611b0161007b565b928392836113a5565b0390a25f6119c8565b5081611b27611b215f610c99565b91610327565b1161199d565b5f90565b611b39611b2d565b50611b42611c63565b90565b5490565b611b58611b5e91939293610327565b92610327565b8203918211611b6957565b610d02565b90565b60301c90565b60018060d01b031690565b611b8e611b9391611b71565b611b77565b90565b611ba09054611b82565b90565b611bb7611bb2611bbc92610255565b610258565b61167a565b90565b611bc7611781565b50611bd35f8201611b45565b80611be6611be05f610c99565b91610327565b145f14611bfc575050611bf85f611ba3565b5b90565b611c295f91611c24611c1e84611c2f960192611c18600161053f565b90611b49565b91611b6e565b611c78565b01611b96565b611bf9565b91611c585f611c5d94611c45611781565b50611c4e611781565b5001929192611b6e565b611e69565b91909190565b611c6b611b2d565b50611c7543612027565b90565b5f5260205f200190565b5490565b611c9060406100ca565b90565b65ffffffffffff1690565b90611ca890611c93565b9052565b90611cb69061167a565b9052565b5f5260205f2090565b611ccc81611c82565b821015611ce657611cde600191611cba565b910201905f90565b610d9c565b611cf59051611c93565b90565b90611d0965ffffffffffff9161028b565b9181191691161790565b611d27611d22611d2c92611c93565b610258565b611c93565b90565b90565b90611d47611d42611d4e92611d13565b611d2f565b8254611cf8565b9055565b611d5c905161167a565b90565b60301b90565b90611d7765ffffffffffff1991611d5f565b9181191691161790565b611d95611d90611d9a9261167a565b610258565b61167a565b90565b90565b90611db5611db0611dbc92611d81565b611d9d565b8254611d65565b9055565b90611dea60205f611df094611de2828201611ddc848801611ceb565b90611d32565b019201611d52565b90611da0565b565b9190611e0357611e0191611dc0565b565b610796565b9081549168010000000000000000831015611e385782611e30916001611e3695018155611cc3565b90611df2565b565b61008f565b65ffffffffffff1690565b611e54611e59916111b5565b611e3d565b90565b611e669054611e48565b90565b90929192611e75611781565b50611e7e611781565b50611e8882611c82565b80611e9b611e955f610c99565b91610327565b115f14611f6b57611ec190611ebb8491611eb5600161053f565b90611b49565b90611c78565b90611ecd5f8301611e5c565b92611ed95f8401611b96565b9380611eed611ee785611c93565b91611c93565b11611f4f57611f04611efe84611c93565b91611c93565b145f14611f1f575050611f1a905f859101611da0565b5b9190565b611f4a9250611f4586611f3c611f33611c86565b945f8601611c9e565b60208401611cac565b611e08565b611f1b565b5f632520601d60e01b815280611f6760048201610283565b0390fd5b50611f9691611f9185611f88611f7f611c86565b945f8601611c9e565b60208401611cac565b611e08565b611f9f5f611ba3565b9190565b611fb7611fb2611fbc92611c93565b610258565b610327565b90565b611fd3611fce611fd892610d70565b610258565b6117c6565b90565b611fe490611fbf565b9052565b91602061200992949361200260408201965f830190611fdb565b01906110ea565b565b61201f61201a61202492610327565b610258565b611c93565b90565b61202f611b2d565b508061204961204365ffffffffffff611fa3565b91610327565b1161205a576120579061200b565b90565b60306120765f9283926306dfcc6560e41b845260048401611fe8565b0390fd5b634e487b7160e01b5f52605160045260245ffd5b919091806001146120ad5760020361207a576120a9916118f2565b905b565b506120b7916117ad565b906120ab56fe60806040526004361015610013575b612544565b61001d5f3561050c565b806301ffc9a71461050757806306fdde031461050257806307a1d5fa146104fd578063095ea7b3146104f85780630c05f82c146104f357806313beaa5b146104ee57806318160ddd146104e95780631b02f845146104e457806322a97d9c146104df57806323b872dd146104da57806323e460d2146104d5578063243a30cc146104d05780632481bb5c146104cb578063248a9ca3146104c6578063284e1333146104c15780632f2ff15d146104bc578063313ce567146104b7578063334d0bbd146104b2578063359b76fe146104ad5780633644e515146104a857806336568abe146104a35780633a46b1a81461049e5780633f4ba83a1461049957806340c10f191461049457806344e181aa1461048f57806348b0daa61461048a5780634bdd36ce146104855780634bf5d7e914610480578063587cde1e1461047b5780635adf0021146104765780635c19a95c146104715780635c975abb1461046c5780635f15c3c914610467578063651fd268146104625780636c33bced1461045d5780636cf01625146104585780636fc063be146104535780636fcfff451461044e57806370a0823114610449578063726600ce14610444578063766718081461043f5780637c790cab1461043a5780637ecebe00146104355780638456cb591461043057806384b0196e1461042b5780638e539e8c14610426578063902d55a51461042157806391d148541461041c57806391ddadf41461041757806395d89b411461041257806399127d9b1461040d578063998955d3146104085780639ab24eb0146104035780639b7ef64b146103fe5780639dc29fac146103f9578063a08d5654146103f4578063a217fddf146103ef578063a3d4485b146103ea578063a4d7e31d146103e5578063a571e184146103e0578063a5b326be146103db578063a70b9f0c146103d6578063a9059cbb146103d1578063ae5ecbc6146103cc578063af2aa63b146103c7578063b0ca253e146103c2578063babc394f146103bd578063bb4d4436146103b8578063c02ae754146103b3578063c1eb7137146103ae578063c3cda520146103a9578063d505accf146103a4578063d547741f1461039f578063dd62ed3e1461039a578063e3abdfcb14610395578063e63ab1e914610390578063f1127ed81461038b578063f508e19d146103865763f75e85120361000e5761250f565b6124ab565b612466565b612383565b61231f565b6122ba565b612259565b61221f565b612175565b6120b9565b612084565b61204f565b612016565b611fa2565b611f6d565b611ec3565b611e4f565b611e1a565b611dac565b611d79565b611cf7565b611cc2565b611c38565b611bc9565b611b5b565b611b26565b611aaf565b611a7a565b611a45565b6119d7565b6119a2565b61193f565b61190a565b611893565b611857565b611712565b6116dd565b6116a4565b611622565b6115de565b6115a9565b611574565b611514565b6114b0565b61143c565b611407565b6113d2565b611366565b611333565b6112fe565b6112c9565b611272565b61123d565b611208565b6111c0565b6110ab565b611078565b611042565b61100e565b610fd9565b610fa6565b610f71565b610e84565b610e28565b610dc8565b610d93565b610cf8565b610b29565b610abb565b610a62565b6109f3565b610981565b61094c565b610918565b61085d565b6107e7565b61072f565b610647565b610598565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b63ffffffff60e01b1690565b61053981610524565b0361054057565b5f80fd5b9050359061055182610530565b565b9060208282031261056c57610569915f01610544565b90565b61051c565b151590565b61057f90610571565b9052565b9190610596905f60208501940190610576565b565b346105c8576105c46105b36105ae366004610553565b6125e1565b6105bb610512565b91829182610583565b0390f35b610518565b5f9103126105d757565b61051c565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b61061d61062660209361062b93610614816105dc565b938480936105e0565b958691016105e9565b6105f4565b0190565b6106449160208201915f8184039101526105fe565b90565b34610677576106573660046105cd565b6106736106626126ff565b61066a610512565b9182918261062f565b0390f35b610518565b60018060a01b031690565b90565b61069e6106996106a39261067c565b610687565b61067c565b90565b6106af9061068a565b90565b6106bb906106a6565b90565b6106c7906106b2565b9052565b5190565b60209181520190565b6106f7610700602093610705936106ee816106cb565b938480936106cf565b958691016105e9565b6105f4565b0190565b9161072c9261071f60408201935f8301906106be565b60208184039101526106d8565b90565b346107605761073f3660046105cd565b61074761274b565b9061075c610753610512565b92839283610709565b0390f35b610518565b61076e9061067c565b90565b61077a81610765565b0361078157565b5f80fd5b9050359061079282610771565b565b90565b6107a081610794565b036107a757565b5f80fd5b905035906107b882610797565b565b91906040838203126107e257806107d66107df925f8601610785565b936020016107ab565b90565b61051c565b34610818576108146108036107fd3660046107ba565b90612775565b61080b610512565b91829182610583565b0390f35b610518565b9060208282031261083657610833915f01610785565b90565b61051c565b61084490610794565b9052565b919061085b905f6020850194019061083b565b565b3461088d5761088961087861087336600461081d565b61279b565b610880610512565b91829182610848565b0390f35b610518565b5f80fd5b5f80fd5b5f80fd5b909182601f830112156108d85781359167ffffffffffffffff83116108d35760200192600183028401116108ce57565b61089a565b610896565b610892565b9060208282031261090e575f82013567ffffffffffffffff811161090957610905920161089e565b9091565b610520565b61051c565b5f0190565b346109475761093161092b3660046108dd565b90612a8c565b610939610512565b8061094381610913565b0390f35b610518565b3461097c5761095c3660046105cd565b610978610967612a98565b61096f610512565b91829182610848565b0390f35b610518565b346109af576109913660046105cd565b610999612c64565b6109a1610512565b806109ab81610913565b0390f35b610518565b1c90565b60ff1690565b6109ce9060086109d393026109b4565b6109b8565b90565b906109e191546109be565b90565b6109f060405f906109d6565b90565b34610a2357610a033660046105cd565b610a1f610a0e6109e4565b610a16610512565b91829182610583565b0390f35b610518565b9091606082840312610a5d57610a5a610a43845f8501610785565b93610a518160208601610785565b936040016107ab565b90565b61051c565b34610a9357610a8f610a7e610a78366004610a28565b91612c6e565b610a86610512565b91829182610583565b0390f35b610518565b916020610ab9929493610ab260408201965f83019061083b565b019061083b565b565b34610aec57610ad3610ace36600461081d565b612d9f565b90610ae8610adf610512565b92839283610a98565b0390f35b610518565b90565b610b08610b03610b0d92610af1565b610687565b610794565b90565b610b1b610e10610af4565b90565b610b26610b10565b90565b34610b5957610b393660046105cd565b610b55610b44610b1e565b610b4c610512565b91829182610848565b0390f35b610518565b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52602260045260245ffd5b9060016002830492168015610ba5575b6020831014610ba057565b610b71565b91607f1691610b95565b60209181520190565b5f5260205f2090565b905f9291805490610bdb610bd483610b85565b8094610baf565b916001811690815f14610c325750600114610bf6575b505050565b610c039192939450610bb8565b915f925b818410610c1a57505001905f8080610bf1565b60018160209295939554848601520191019290610c07565b92949550505060ff19168252151560200201905f8080610bf1565b90610c5791610bc1565b90565b634e487b7160e01b5f52604160045260245ffd5b90610c78906105f4565b810190811067ffffffffffffffff821117610c9257604052565b610c5a565b90610cb7610cb092610ca7610512565b93848092610c4d565b0383610c6e565b565b905f10610ccc57610cc990610c97565b90565b610b5e565b610cdd60455f90610cb9565b90565b610cf59160208201915f8184039101526106d8565b90565b34610d2857610d083660046105cd565b610d24610d13610cd1565b610d1b610512565b91829182610ce0565b0390f35b610518565b90565b610d3981610d2d565b03610d4057565b5f80fd5b90503590610d5182610d30565b565b90602082820312610d6c57610d69915f01610d44565b90565b61051c565b610d7a90610d2d565b9052565b9190610d91905f60208501940190610d71565b565b34610dc357610dbf610dae610da9366004610d53565b612fc0565b610db6610512565b91829182610d7e565b0390f35b610518565b34610df657610dd83660046105cd565b610de06134be565b610de8610512565b80610df281610913565b0390f35b610518565b9190604083820312610e235780610e17610e20925f8601610d44565b93602001610785565b90565b61051c565b34610e5757610e41610e3b366004610dfb565b906134f2565b610e49610512565b80610e5381610913565b0390f35b610518565b60ff1690565b610e6b90610e5c565b9052565b9190610e82905f60208501940190610e62565b565b34610eb457610e943660046105cd565b610eb0610e9f613521565b610ea7610512565b91829182610e6f565b0390f35b610518565b90602082820312610ed257610ecf915f016107ab565b90565b61051c565b634e487b7160e01b5f52603260045260245ffd5b50603090565b90565b610efd81610eeb565b821015610f1757610f0f600191610ef1565b910201905f90565b610ed7565b90565b610f2f906008610f3493026109b4565b610f1c565b90565b90610f429154610f1f565b90565b6010610f5081610eeb565b821015610f6d57610f6a91610f6491610ef4565b90610f37565b90565b5f80fd5b34610fa157610f9d610f8c610f87366004610eb9565b610f45565b610f94610512565b91829182610848565b0390f35b610518565b34610fd457610fb63660046105cd565b610fbe6135d2565b610fc6610512565b80610fd081610913565b0390f35b610518565b3461100957610fe93660046105cd565b611005610ff46135dc565b610ffc610512565b91829182610d7e565b0390f35b610518565b3461103d57611027611021366004610dfb565b906135f0565b61102f610512565b8061103981610913565b0390f35b610518565b346110735761106f61105e6110583660046107ba565b9061366d565b611066610512565b91829182610848565b0390f35b610518565b346110a6576110883660046105cd565b6110906136cb565b611098610512565b806110a281610913565b0390f35b610518565b346110da576110c46110be3660046107ba565b90613828565b6110cc610512565b806110d681610913565b0390f35b610518565b6110e8906106a6565b90565b906110f5906110df565b5f5260205260405f2090565b5f1c90565b61111261111791611101565b610f1c565b90565b6111249054611106565b90565b61113290600d6110eb565b61113d5f820161111a565b9161114a6001830161111a565b916111576002820161111a565b9161117060046111696003850161111a565b930161111a565b90565b909594926111be946111ad6111b7926111a360809661119960a088019c5f89019061083b565b602087019061083b565b604085019061083b565b606083019061083b565b019061083b565b565b346111f4576111f06111db6111d636600461081d565b611127565b916111e7959395610512565b95869586611173565b0390f35b610518565b61120560415f90610f37565b90565b34611238576112183660046105cd565b6112346112236111f9565b61122b610512565b91829182610848565b0390f35b610518565b3461126d5761124d3660046105cd565b611269611258613834565b611260610512565b91829182610848565b0390f35b610518565b346112a2576112823660046105cd565b61129e61128d6138f5565b611295610512565b9182918261062f565b0390f35b610518565b6112b090610765565b9052565b91906112c7905f602085019401906112a7565b565b346112f9576112f56112e46112df36600461081d565b613991565b6112ec610512565b918291826112b4565b0390f35b610518565b3461132e5761130e3660046105cd565b61132a6113196139b0565b611321610512565b91829182610583565b0390f35b610518565b346113615761134b61134636600461081d565b6139d9565b611353610512565b8061135d81610913565b0390f35b610518565b34611396576113763660046105cd565b6113926113816139ec565b611389610512565b91829182610583565b0390f35b610518565b90565b6113b26113ad6113b79261139b565b610687565b610794565b90565b6113c4603061139e565b90565b6113cf6113ba565b90565b34611402576113e23660046105cd565b6113fe6113ed6113c7565b6113f5610512565b91829182610848565b0390f35b610518565b346114375761143361142261141d36600461081d565b613a02565b61142a610512565b91829182610848565b0390f35b610518565b3461146a5761144c3660046105cd565b611454613ab9565b61145c610512565b8061146681610913565b0390f35b610518565b90565b61148661148161148b9261146f565b610687565b610794565b90565b6114a26a52b7d2dcc80cd2e4000000611472565b90565b6114ad61148e565b90565b346114e0576114c03660046105cd565b6114dc6114cb6114a5565b6114d3610512565b91829182610848565b0390f35b610518565b906114ef906110df565b5f5260205260405f2090565b6115119061150c600e915f926114e5565b6109d6565b90565b346115445761154061152f61152a36600461081d565b6114fb565b611537610512565b91829182610583565b0390f35b610518565b63ffffffff1690565b61155b90611549565b9052565b9190611572905f60208501940190611552565b565b346115a4576115a061158f61158a36600461081d565b613ac7565b611597610512565b9182918261155f565b0390f35b610518565b346115d9576115d56115c46115bf36600461081d565b613af2565b6115cc610512565b91829182610848565b0390f35b610518565b3461160e5761160a6115f96115f436600461081d565b613b10565b611601610512565b91829182610583565b0390f35b610518565b61161f60425f90610f37565b90565b34611652576116323660046105cd565b61164e61163d611613565b611645610512565b91829182610848565b0390f35b610518565b909594926116a29461169161169b9261168760809661167d60a088019c5f890190610576565b602087019061083b565b604085019061083b565b606083019061083b565b019061083b565b565b346116d8576116d46116bf6116ba36600461081d565b613b2f565b916116cb959395610512565b95869586611657565b0390f35b610518565b3461170d576117096116f86116f336600461081d565b613c9f565b611700610512565b91829182610848565b0390f35b610518565b34611740576117223660046105cd565b61172a613cd8565b611732610512565b8061173c81610913565b0390f35b610518565b60ff60f81b1690565b61175790611745565b9052565b5190565b60209181520190565b60200190565b61177790610794565b9052565b906117888160209361176e565b0190565b60200190565b906117af6117a96117a28461175b565b809361175f565b92611768565b905f5b8181106117bf5750505090565b9091926117d86117d2600192865161177b565b9461178c565b91019190916117b2565b939591946118336118286118479561181a61183d956118549c9a61180d60e08c01925f8d019061174e565b8a820360208c01526105fe565b9088820360408a01526105fe565b97606087019061083b565b60808501906112a7565b60a0830190610d71565b60c0818403910152611792565b90565b3461188e576118673660046105cd565b61188a611872613d5f565b93611881979597939193610512565b978897886117e2565b0390f35b610518565b346118c3576118bf6118ae6118a9366004610eb9565b613de9565b6118b6610512565b91829182610848565b0390f35b610518565b90565b6118df6118da6118e4926118c8565b610687565b610794565b90565b6118fc6b033b2e3c9fd0803ce80000006118cb565b90565b6119076118e7565b90565b3461193a5761191a3660046105cd565b6119366119256118ff565b61192d610512565b91829182610848565b0390f35b610518565b346119705761196c61195b611955366004610dfb565b90613e1a565b611963610512565b91829182610583565b0390f35b610518565b65ffffffffffff1690565b61198990611975565b9052565b91906119a0905f60208501940190611980565b565b346119d2576119b23660046105cd565b6119ce6119bd613e48565b6119c5610512565b9182918261198d565b0390f35b610518565b34611a07576119e73660046105cd565b611a036119f2613e5c565b6119fa610512565b9182918261062f565b0390f35b610518565b90565b611a23611a1e611a2892611a0c565b610687565b610794565b90565b611a3762015180611a0f565b90565b611a42611a2b565b90565b34611a7557611a553660046105cd565b611a71611a60611a3a565b611a68610512565b91829182610848565b0390f35b610518565b34611aaa57611aa6611a95611a9036600461081d565b613e72565b611a9d610512565b91829182610848565b0390f35b610518565b34611adf57611adb611aca611ac536600461081d565b613ecd565b611ad2610512565b91829182610848565b0390f35b610518565b90565b611afb611af6611b0092611ae4565b610687565b610794565b90565b611b186b02e87669c308736a04000000611ae7565b90565b611b23611b03565b90565b34611b5657611b363660046105cd565b611b52611b41611b1b565b611b49610512565b91829182610848565b0390f35b610518565b34611b8a57611b74611b6e3660046107ba565b9061404f565b611b7c610512565b80611b8681610913565b0390f35b610518565b9091606082840312611bc457611bc1611baa845f8501610785565b93611bb881602086016107ab565b936040016107ab565b90565b61051c565b34611bf857611be2611bdc366004611b8f565b916142d5565b611bea610512565b80611bf481610913565b0390f35b610518565b90565b5f1b90565b611c19611c14611c1e92611bfd565b611c00565b610d2d565b90565b611c2a5f611c05565b90565b611c35611c21565b90565b34611c6857611c483660046105cd565b611c64611c53611c2d565b611c5b610512565b91829182610d7e565b0390f35b610518565b60018060a01b031690565b611c88906008611c8d93026109b4565b611c6d565b90565b90611c9b9154611c78565b90565b611caa60445f90611c90565b90565b9190611cc0905f602085019401906106be565b565b34611cf257611cd23660046105cd565b611cee611cdd611c9e565b611ce5610512565b91829182611cad565b0390f35b610518565b34611d2757611d073660046105cd565b611d23611d126142e2565b611d1a610512565b91829182610583565b0390f35b610518565b611d3590610765565b90565b611d4181611d2c565b03611d4857565b5f80fd5b90503590611d5982611d38565b565b90602082820312611d7457611d71915f01611d4c565b90565b61051c565b34611da757611d91611d8c366004611d5b565b614439565b611d99610512565b80611da381610913565b0390f35b610518565b34611ddc57611dbc3660046105cd565b611dd8611dc7614463565b611dcf610512565b91829182610848565b0390f35b610518565b90565b611df8611df3611dfd92611de1565b610687565b610794565b90565b611e0c62278d00611de4565b90565b611e17611e00565b90565b34611e4a57611e2a3660046105cd565b611e46611e35611e0f565b611e3d610512565b91829182610848565b0390f35b610518565b34611e8057611e7c611e6b611e653660046107ba565b906144dd565b611e73610512565b91829182610583565b0390f35b610518565b90565b611e9c611e97611ea192611e85565b610687565b610794565b90565b611eb5670de0b6b3a7640000611e88565b90565b611ec0611ea4565b90565b34611ef357611ed33660046105cd565b611eef611ede611eb8565b611ee6610512565b91829182610848565b0390f35b610518565b50603090565b905090565b90565b60200190565b611f28611f22611f1b83611ef8565b8094611efe565b91611f03565b5f915b838310611f385750505050565b611f4e611f48600192845161177b565b92611f06565b92019190611f2b565b9190611f6b905f6106008501940190611f0c565b565b34611f9d57611f7d3660046105cd565b611f99611f88614604565b611f90610512565b91829182611f57565b0390f35b610518565b34611fd357611fcf611fbe611fb83660046107ba565b9061461a565b611fc6610512565b91829182610848565b0390f35b610518565b61200d61201494612003606094989795611ff9608086019a5f87019061083b565b602085019061083b565b604083019061083b565b0190610576565b565b3461204a576120263660046105cd565b612046612031614630565b9061203d949294610512565b94859485611fd8565b0390f35b610518565b3461207f5761207b61206a61206536600461081d565b614807565b612072610512565b91829182610848565b0390f35b610518565b346120b4576120943660046105cd565b6120b061209f61481c565b6120a7610512565b91829182610848565b0390f35b610518565b346120e9576120e56120d46120cf36600461081d565b614830565b6120dc610512565b91829182610848565b0390f35b610518565b6120f781610e5c565b036120fe57565b5f80fd5b9050359061210f826120ee565b565b909160c08284031261217057612129835f8401610785565b9261213781602085016107ab565b9261214582604083016107ab565b9261216d6121568460608501612102565b936121648160808601610d44565b9360a001610d44565b90565b61051c565b346121aa57612194612188366004612111565b949390939291926148ba565b61219c610512565b806121a681610913565b0390f35b610518565b60e08183031261221a576121c5825f8301610785565b926121d38360208401610785565b926121e181604085016107ab565b926121ef82606083016107ab565b926122176122008460808501612102565b9361220e8160a08601610d44565b9360c001610d44565b90565b61051c565b346122545761223e6122323660046121af565b95949094939193614a0e565b612246610512565b8061225081610913565b0390f35b610518565b346122885761227261226c366004610dfb565b90614b2c565b61227a610512565b8061228481610913565b0390f35b610518565b91906040838203126122b557806122a96122b2925f8601610785565b93602001610785565b90565b61051c565b346122eb576122e76122d66122d036600461228d565b90614b4e565b6122de610512565b91829182610848565b0390f35b610518565b7f6b9725f740f94b91b78060a1b17d1774656d381421a529ec98cdb013f4d9c25e90565b61231c6122f0565b90565b3461234f5761232f3660046105cd565b61234b61233a612314565b612342610512565b91829182610d7e565b0390f35b610518565b7f65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a90565b612380612354565b90565b346123b3576123933660046105cd565b6123af61239e612378565b6123a6610512565b91829182610d7e565b0390f35b610518565b6123c181611549565b036123c857565b5f80fd5b905035906123d9826123b8565b565b919060408382031261240357806123f7612400925f8601610785565b936020016123cc565b90565b61051c565b61241190611975565b9052565b60018060d01b031690565b61242990612415565b9052565b9060208061244f936124455f8201515f860190612408565b0151910190612420565b565b9190612464905f6040850194019061242d565b565b346124975761249361248261247c3660046123db565b90614bbc565b61248a610512565b91829182612451565b0390f35b610518565b6124a860435f90610f37565b90565b346124db576124bb3660046105cd565b6124d76124c661249c565b6124ce610512565b91829182610848565b0390f35b610518565b7fcce296b040332a080e6df13515a3ec2869e21cd20f7344af0987ddb938d8bd2190565b61250c6124e0565b90565b3461253f5761251f3660046105cd565b61253b61252a612504565b612532610512565b91829182610d7e565b0390f35b610518565b5f80fd5b5f90565b634e487b7160e01b5f52601160045260245ffd5b61256c61257291612415565b91612415565b019060018060d01b03821161258357565b61254c565b9061259b91612595612548565b50612560565b90565b6125aa6125b091612415565b91612415565b90039060018060d01b0382116125c257565b61254c565b906125da916125d4612548565b5061259e565b90565b5f90565b6125e96125dd565b50806126046125fe637965db0b60e01b610524565b91610524565b14908115612611575b5090565b61261b9150614bd2565b5f61260d565b606090565b60209181520190565b5f5260205f2090565b905f929180549061265261264b83610b85565b8094612626565b916001811690815f146126a9575060011461266d575b505050565b61267a919293945061262f565b915f925b81841061269157505001905f8080612668565b6001816020929593955484860152019101929061267e565b92949550505060ff19168252151560200201905f8080612668565b906126ce91612638565b90565b906126f16126ea926126e1610512565b938480926126c4565b0383610c6e565b565b6126fc906126d1565b90565b612707612621565b5061271260036126f3565b90565b5f90565b606090565b61272a61272f91611101565b611c6d565b90565b61273c905461271e565b90565b61274890610c97565b90565b612753612715565b5061275c612719565b506127676044612732565b90612772604561273f565b90565b612792916127816125dd565b5061278a614bf8565b919091614c05565b600190565b5f90565b5f6127b36127b9926127ab612797565b50600d6110eb565b0161111a565b90565b906127d6916127d16127cc6124e0565b614c15565b612a36565b565b5090565b601f602091010490565b1b90565b919060086128059102916127ff5f19846127e6565b926127e6565b9181191691161790565b61282361281e61282892610794565b610687565b610794565b90565b90565b919061284461283f61284c9361280f565b61282b565b9083546127ea565b9055565b6128629161285c612797565b9161282e565b565b5b818110612870575050565b8061287d5f600193612850565b01612865565b9190601f8111612893575b505050565b61289f6128c493610bb8565b9060206128ab846127dc565b830193106128cc575b6128bd906127dc565b0190612864565b5f808061288e565b91506128bd819290506128b4565b906128ea905f19906008026109b4565b191690565b816128f9916128da565b906002021790565b9161290c90826127d8565b9067ffffffffffffffff82116129cb576129308261292a8554610b85565b85612883565b5f90601f831160011461296357918091612952935f92612957575b50506128ef565b90555b565b90915001355f8061294b565b601f1983169161297285610bb8565b925f5b8181106129b357509160029391856001969410612999575b50505002019055612955565b6129a9910135601f8416906128da565b90555f808061298d565b91936020600181928787013581550195019201612975565b610c5a565b906129db9291612901565b565b90825f939282370152565b9190612a02816129fb81612a07956106cf565b80956129dd565b6105f4565b0190565b91612a25612a33949260408501908582035f8701526106d8565b9260208185039101526129e8565b90565b90612a41604561273f565b612a4e83839060456129d0565b919091612a877fb9a2088426f03b30a81c06428094fbfa9e2692739b3241af6b9ab1da4b5546be93612a7e610512565b93849384612a0b565b0390a1565b90612a96916127bc565b565b612aa0612797565b50612aab600261111a565b90565b612abe612ab96122f0565b614c15565b612ac6612b87565b565b612adc612ad7612ae192611bfd565b610687565b610794565b90565b612af8612af3612afd92611bfd565b610687565b61067c565b90565b612b0990612ae4565b90565b90612b1860ff91611c00565b9181191691161790565b612b2b90610571565b90565b90565b90612b46612b41612b4d92612b22565b612b2e565b8254612b0c565b9055565b90612b5d5f1991611c00565b9181191691161790565b90612b7c612b77612b839261280f565b61282b565b8254612b51565b9055565b612b91604161111a565b612ba3612b9d5f612ac8565b91610794565b03612c4857612bba612bb56044612732565b6106b2565b612bd4612bce612bc95f612b00565b610765565b91610765565b14612c2c57612be560016040612b31565b612bf0426041612b67565b42612c277f1194b034cfa9ab5807494a1d5c667d8b0e6e97f38888742aa3871a322034116091612c1e610512565b91829182610848565b0390a1565b5f633b0a48bd60e11b815280612c4460048201610913565b0390fd5b5f6338e93dbd60e11b815280612c6060048201610913565b0390fd5b612c6c612aae565b565b91612c9892612c7b6125dd565b50612c90612c87614bf8565b82908491614c69565b919091614cf5565b600190565b612ca6906106a6565b90565b5f80fd5b60e01b90565b90505190612cc082610797565b565b90602082820312612cdb57612cd8915f01612cb3565b90565b61051c565b612ce8610512565b3d5f823e3d90fd5b612cff612d0591939293610794565b92610794565b8203918211612d1057565b61254c565b90565b612d2c612d27612d3192612d15565b610687565b610794565b90565b612d43612d4991939293610794565b92610794565b91612d55838202610794565b928184041490151715612d6457565b61254c565b634e487b7160e01b5f52601260045260245ffd5b612d89612d8f91610794565b91610794565b908115612d9a570490565b612d69565b612da7612797565b91612db0612797565b91612dc75f612dc1600d84906110eb565b0161111a565b90612ddf6002612dd9600d84906110eb565b0161111a565b91612e186020612dee30612c9d565b63651fd26890612e0d8692612e01610512565b95869485938493612cad565b8352600483016112b4565b03915afa908115612f7157612e63916020915f91612f44575b5093612e3c30612c9d565b612e5863998955d3612e4c610512565b95869485938493612cad565b8352600483016112b4565b03915afa908115612f3f575f91612f11575b509181612e8a612e845f612ac8565b91610794565b11612ee0575b505081612ea5612e9f5f612ac8565b91610794565b11612eaf575b5050565b612ed8929350612ec2612ed39183612cf0565b612ecd612710612d18565b90612d34565b612d7d565b905f80612eab565b612f09929650612ef3612f049183612cf0565b612efe612710612d18565b90612d34565b612d7d565b935f80612e90565b612f32915060203d8111612f38575b612f2a8183610c6e565b810190612cc2565b5f612e75565b503d612f20565b612ce0565b612f649150823d8111612f6a575b612f5c8183610c6e565b810190612cc2565b5f612e31565b503d612f52565b612ce0565b5f90565b612f8390610d2d565b90565b90612f9090612f7a565b5f5260205260405f2090565b90565b612fab612fb091611101565b612f9c565b90565b612fbd9054612f9f565b90565b6001612fd9612fdf92612fd1612f76565b506005612f86565b01612fb3565b90565b612fea614d92565b612ff2612ff4565b565b612ffc614de8565b61300461300e565b61300c614e4d565b565b61301e6130196122f0565b614c15565b613026613158565b565b61303461303991611101565b6109b8565b90565b6130469054613028565b90565b60016130559101610794565b90565b61306761306d91939293610794565b92610794565b820180921161307857565b61254c565b613086906106a6565b90565b5f91031261309357565b61051c565b905f92918054906130b26130ab83610b85565b80946106cf565b916001811690815f1461310957506001146130cd575b505050565b6130da9192939450610bb8565b915f925b8184106130f157505001905f80806130c8565b600181602092959395548486015201910192906130de565b92949550505060ff19168252151560200201905f80806130c8565b61314861315594929361313e60608401955f8501906112a7565b602083019061083b565b6040818403910152613098565b90565b61316b613165604061303c565b15610571565b6134a2576131776142e2565b613486576131a06131924261318c604161111a565b90612cf0565b61319a611e00565b90612d7d565b426131cb6131c56131c06131b2614463565b6131ba610b10565b90612cf0565b610794565b91610794565b1061346a576131e4906131de604261111a565b90612cf0565b908161321261320c6132076131f76113ba565b613201604261111a565b90612cf0565b610794565b91610794565b11613447575b6132215f612ac8565b9061322b5f612ac8565b915b8261324061323a86610794565b91610794565b10156132875761327b6132819161327561326f6010613269613262604261111a565b8990613058565b90610ef4565b90610f37565b90613058565b92613049565b9161322d565b91509161329e613297604361111a565b8390613058565b6132b76132b16132ac61148e565b610794565b91610794565b1161342b576132d26132d9916132cd604261111a565b613058565b6042612b67565b6132f66132ef826132ea604361111a565b613058565b6043612b67565b6133096133023061307d565b8290614e61565b61332e6133153061307d565b6133276133226044612732565b6106b2565b8391614c05565b61334061333b6044612732565b6106b2565b6318b68b8c61334e3061307d565b8392604592813b15613426575f61337891613383829661336c610512565b98899788968795612cad565b855260048501613124565b03925af18015613421576133f5575b5061339d604261111a565b906133b06133ab6044612732565b6106b2565b906133db7f34b73d0c96e9ff4d5311434817c8ecc930e7d2782c5bde2e79dc44b0596755bb926110df565b926133f06133e7610512565b92839283610a98565b0390a2565b613414905f3d811161341a575b61340c8183610c6e565b810190613089565b5f613392565b503d613402565b612ce0565b612ca9565b5f6323064ebd60e01b81528061344360048201610913565b0390fd5b90506134646134546113ba565b61345e604261111a565b90612cf0565b90613218565b5f633d53c75360e01b81528061348260048201610913565b0390fd5b5f631155624b60e21b81528061349e60048201610913565b0390fd5b5f6319afc99d60e21b8152806134ba60048201610913565b0390fd5b6134c6612fe2565b565b906134e3916134de6134d982612fc0565b614c15565b6134e5565b565b906134ef91614ebf565b50565b906134fc916134c8565b565b5f90565b90565b61351961351461351e92613502565b610687565b610e5c565b90565b6135296134fe565b506135346012613505565b90565b6135476135426122f0565b614c15565b61354f613551565b565b61355b604161111a565b61356d6135675f612ac8565b91610794565b146135b65761357e60016040612b31565b7f4a792a0be42b5672faa40129fc6469072490775ca8d3c34e852d4d55d3a735a96135a7610512565b806135b181610913565b0390a1565b5f638f98404160e01b8152806135ce60048201610913565b0390fd5b6135da613537565b565b6135e4612f76565b506135ed614f6b565b90565b908061360b613605613600614bf8565b610765565b91610765565b0361361c5761361991615025565b50565b5f63334bd91960e11b81528061363460048201610913565b0390fd5b90613642906110df565b5f5260205260405f2090565b90565b61366561366061366a92612415565b610687565b610794565b90565b6136a49161369961369361368e61369f94613686612797565b50600a613638565b61364e565b91615106565b906151fc565b613651565b90565b6136b76136b2611c21565b614c15565b6136bf6136c1565b565b6136c9615383565b565b6136d36136a7565b565b906136e7916136e2614de8565b6136f1565b6136ef614e4d565b565b908161370d6137076137025f612b00565b610765565b91610765565b1461380c578061372561371f5f612ac8565b91610794565b146137f05761374761374161373c600e33906114e5565b61303c565b15610571565b6137d45761375433615390565b61376b6001613765600d33906110eb565b0161111a565b61377d61377783610794565b91610794565b106137b8576137b6916137b1826137ab600161379b600d33906110eb565b01916137a68361111a565b612cf0565b90612b67565b614e61565b565b5f631c959ed960e21b8152806137d060048201610913565b0390fd5b5f634417760960e11b8152806137ec60048201610913565b0390fd5b5f631f2a200560e01b81528061380860048201610913565b0390fd5b5f63d92e233d60e01b81528061382460048201610913565b0390fd5b90613832916136d5565b565b61383c612797565b5061385861384861148e565b613852604361111a565b90612cf0565b90565b9061386e613867610512565b9283610c6e565b565b67ffffffffffffffff811161388e5761388a6020916105f4565b0190565b610c5a565b906138a56138a083613870565b61385b565b918252565b5f7f6d6f64653d626c6f636b6e756d6265722666726f6d3d64656661756c74000000910152565b6138db601d613893565b906138e8602083016138aa565b565b6138f26138d1565b90565b6138fd612621565b50613906613e48565b61391f61391961391461555f565b611975565b91611975565b0361392f5761392c6138ea565b90565b5f6301bfc1c560e61b81528061394760048201610913565b0390fd5b5f90565b90613959906110df565b5f5260205260405f2090565b60018060a01b031690565b61397c61398191611101565b613965565b90565b61398e9054613970565b90565b6139a86139ad916139a061394b565b50600961394f565b613984565b90565b6139b86125dd565b506139c3604161111a565b6139d56139cf5f612ac8565b91610794565b1190565b6139ea906139e5614bf8565b615597565b565b6139f46125dd565b506139ff600f61303c565b90565b613a5990613a0e612797565b50613a266001613a20600d84906110eb565b0161111a565b90613a536004613a4d613a455f613a3f600d87906110eb565b0161111a565b93600d6110eb565b0161111a565b91615622565b90565b613a6c613a67612354565b614c15565b613a74613a76565b565b613a815f6040612b31565b7f73a5fc60aafeec8f139af22d98e62140e2ce914d1f155c692b427757c3e4014c613aaa610512565b80613ab481610913565b0390a1565b613ac1613a5c565b565b5f90565b613ad990613ad3613ac3565b506156cf565b90565b90613ae6906110df565b5f5260205260405f2090565b613b08613b0d91613b01612797565b505f613adc565b61111a565b90565b613b27613b2c91613b1f6125dd565b50600e6114e5565b61303c565b90565b90613b386125dd565b50613b41612797565b50613b4a612797565b50613b53612797565b50613b5c612797565b50613b71613b6c600e84906114e5565b61303c565b91613b885f613b82600d84906110eb565b0161111a565b91613ba06002613b9a600d85906110eb565b0161111a565b90613bd96020613baf30612c9d565b63651fd26890613bce8792613bc2610512565b95869485938493612cad565b8352600483016112b4565b03915afa908115613c9a57613c24916020915f91613c6d575b5094613bfd30612c9d565b613c1963998955d3613c0d610512565b95869485938493612cad565b8352600483016112b4565b03915afa908115613c68575f91613c3a575b5090565b613c5b915060203d8111613c61575b613c538183610c6e565b810190612cc2565b5f613c36565b503d613c49565b612ce0565b613c8d9150823d8111613c93575b613c858183610c6e565b810190612cc2565b5f613bf2565b503d613c7b565b612ce0565b613cb190613cab612797565b506156fe565b90565b613cc4613cbf612354565b614c15565b613ccc613cce565b565b613cd6615774565b565b613ce0613cb4565b565b5f90565b606090565b613cf4906106a6565b90565b67ffffffffffffffff8111613d0f5760208091020190565b610c5a565b90613d26613d2183613cf7565b61385b565b918252565b369037565b90613d55613d3d83613d14565b92602080613d4b8693613cf7565b9201910390613d2b565b565b600f60f81b90565b613d67613ce2565b50613d70612621565b50613d79612621565b50613d82612797565b50613d8b61394b565b50613d94612f76565b50613d9d613ce6565b50613da6615781565b90613daf6157c1565b904690613dbb30613ceb565b90613dc55f611c05565b90613dd7613dd25f612ac8565b613d30565b90613de0613d57565b96959493929190565b613e12613e1791613df8612797565b50613e0c613e06600b61364e565b91615106565b906151fc565b613651565b90565b613e41915f613e36613e3c93613e2e6125dd565b506005612f86565b016114e5565b61303c565b90565b5f90565b613e50613e44565b50613e5961555f565b90565b613e64612621565b50613e6f60046126f3565b90565b613eca90613e7e612797565b50613e966003613e90600d84906110eb565b0161111a565b90613ec46004613ebe613eb66002613eb0600d87906110eb565b0161111a565b93600d6110eb565b0161111a565b91615622565b90565b613ef4613eef613eea613ef993613ee2612797565b50600a613638565b61364e565b615801565b613651565b90565b90613f0e91613f09614de8565b613f18565b613f16614e4d565b565b9081613f34613f2e613f295f612b00565b610765565b91610765565b146140335780613f4c613f465f612ac8565b91610794565b1461401757613f6e613f68613f63600e33906114e5565b61303c565b15610571565b613ffb57613f7b33615390565b613f926003613f8c600d33906110eb565b0161111a565b613fa4613f9e83610794565b91610794565b10613fdf57613fdd91613fd882613fd26003613fc2600d33906110eb565b0191613fcd8361111a565b612cf0565b90612b67565b615876565b565b5f631c959ed960e21b815280613ff760048201610913565b0390fd5b5f634417760960e11b81528061401360048201610913565b0390fd5b5f631f2a200560e01b81528061402f60048201610913565b0390fd5b5f63d92e233d60e01b81528061404b60048201610913565b0390fd5b9061405991613efc565b565b90614076929161407161406c6124e0565b614c15565b614078565b565b8061409361408d6140885f612b00565b610765565b91610765565b146142b9576140b56140af6140aa600e84906114e5565b61303c565b15610571565b8061427e575b614222575b816140d36140cd5f612ac8565b91610794565b1480614208575b806141ee575b614193575b6140ee81615390565b614105825f6140ff600d85906110eb565b01612b67565b61411d836002614117600d85906110eb565b01612b67565b61413582600161412f600d85906110eb565b01612b67565b61414d836003614147600d85906110eb565b01612b67565b90916141797faa807d0abf30d91968c7478c66b6d82521a106af13eda036e2036da9af168958926110df565b9261418e614185610512565b92839283610a98565b0390a2565b6141a85f6141a3600e84906114e5565b612b31565b806141d37f02c2f0ba15b03f88b18f4832609a18cf35fc6b3f4546a9992076d7453d1334a8916110df565b906141dc610512565b806141e681610913565b0390a26140e5565b506142036141fe600e83906114e5565b61303c565b6140e0565b508261421c6142165f612ac8565b91610794565b146140da565b6142386001614233600e84906114e5565b612b31565b806142637f6cf28439a2daab1b265097227212a5b71e0a76f9ed85e3f815b5a6c3e218eb7f916110df565b9061426c610512565b8061427681610913565b0390a26140c0565b508161429261428c5f612ac8565b91610794565b11801561429f575b6140bb565b50826142b36142ad5f612ac8565b91610794565b1161429a565b5f63d92e233d60e01b8152806142d160048201610913565b0390fd5b906142e0929161405b565b565b6142ea6125dd565b506142f5604261111a565b61430e6143086143036113ba565b610794565b91610794565b101590565b61432c906143276143226124e0565b614c15565b614384565b565b9061433f60018060a01b0391611c00565b9181191691161790565b6143529061068a565b90565b61435e90614349565b90565b90565b9061437961437461438092614355565b614361565b825461432e565b9055565b61438d816106b2565b6143a76143a161439c5f612b00565b610765565b91610765565b1461441d576143d26143cc6143bc6044612732565b6143c7846044614364565b6106b2565b916106b2565b6144056143ff7f07015b6a9f05913148fd5faddf2acc9708f305937f3072ca2b4b46faa5d0898b936110df565b916110df565b9161440e610512565b8061441881610913565b0390a3565b5f63d92e233d60e01b81528061443560048201610913565b0390fd5b61444290614313565b565b90565b61445b61445661446092614444565b610687565b610794565b90565b61446b612797565b50614476604161111a565b6144886144825f612ac8565b91610794565b146144d1576144ce61449a604161111a565b6144c86144ba6144aa604261111a565b6144b46001614447565b90613058565b6144c2611e00565b90612d34565b90613058565b90565b6144da5f612ac8565b90565b6144fa916144e96125dd565b506144f2614bf8565b919091614cf5565b600190565b67ffffffffffffffff81116145145760200290565b610c5a565b61452561452a916144ff565b61385b565b90565b9061454b61453a83614519565b9261454584916144ff565b90613d2b565b565b614557603061452d565b90565b905090565b6145699054611106565b90565b60010190565b61458e61458861458183610eeb565b809461455a565b91610ef1565b5f915b83831061459e5750505050565b6145bb6145b56001926145b08561455f565b61177b565b9261456c565b92019190614591565b906145d28161060093614572565b0190565b906145f66145ef926145e6610512565b938480926145c4565b0383610c6e565b565b614601906145d6565b90565b61460c61454d565b5061461760106145f8565b90565b9061462d91614627612797565b5061366d565b90565b614638612797565b50614641612797565b5061464a612797565b506146536125dd565b5061465e604161111a565b61467061466a5f612ac8565b91610794565b146147e15761469a61468c42614686604161111a565b90612cf0565b614694611e00565b90612d7d565b906146dc6146a8604161111a565b6146d66146c86146b8604261111a565b6146c26001614447565b90613058565b6146d0611e00565b90612d34565b90613058565b6146e6604261111a565b6146ff6146f96146f46113ba565b610794565b91610794565b105f146147d35761472461471e6010614718604261111a565b90610ef4565b90610f37565b5b92614730604061303c565b90816147af575b5080614785575b80614759575b9161474f604261111a565b9193929193929190565b504261477e6147786147738461476d610b10565b90612cf0565b610794565b91610794565b1015614744565b50614790604261111a565b6147a96147a361479e6113ba565b610794565b91610794565b1061473e565b90506147cc6147c66147c1604261111a565b610794565b91610794565b115f614737565b6147dc5f612ac8565b614725565b5f905f915f916148036147fd6147f75f94612ac8565b95612ac8565b93612ac8565b9190565b61481990614813612797565b50613ecd565b90565b614824612797565b5061482d612a98565b90565b600261484961484f92614841612797565b50600d6110eb565b0161111a565b90565b7fe48329057bfd03d55e49b547132e39cffd9c1820ad7b9d4c5307691425d15adf90565b6148ab6148b2946148a1606094989795614897608086019a5f870190610d71565b60208501906112a7565b604083019061083b565b019061083b565b565b60200190565b93959490929195426148d46148ce89610794565b91610794565b1161494d579161493f916149469361493661494b989961491e6148f5614852565b61490f8b938b614903610512565b95869460208601614876565b60208201810382520382610c6e565b61493061492a826106cb565b916148b4565b206158d5565b929091926158f2565b918261593c565b615597565b565b614968875f918291632341d78760e11b835260048301610848565b0390fd5b7f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c990565b91946149d86149e2929897956149ce60a0966149c46149e99a6149ba60c08a019e5f8b0190610d71565b60208901906112a7565b60408701906112a7565b606085019061083b565b608083019061083b565b019061083b565b565b916020614a0c929493614a0560408201965f8301906112a7565b01906112a7565b565b969591939294909442614a29614a2383610794565b91610794565b11614ae35790614a92614a9b949392614a7a614a4361496c565b614a6b8c80948c91614a558d9161597f565b9192614a5f610512565b97889660208801614990565b60208201810382520382610c6e565b614a8c614a86826106cb565b916148b4565b206158d5565b929091926158f2565b80614aae614aa887610765565b91610765565b03614ac35750614ac19293919091614c05565b565b8490614adf5f9283926325c0072360e11b8452600484016149eb565b0390fd5b614afe905f91829163313c898160e11b835260048301610848565b0390fd5b90614b1d91614b18614b1382612fc0565b614c15565b614b1f565b565b90614b2991615025565b50565b90614b3691614b02565b565b90614b42906110df565b5f5260205260405f2090565b614b7391614b69614b6e92614b61612797565b506001614b38565b613adc565b61111a565b90565b614b80604061385b565b90565b5f90565b5f90565b614b93614b76565b9060208083614ba0614b83565b815201614bab614b87565b81525050565b614bb9614b8b565b90565b90614bcf91614bc9614bb1565b506159b2565b90565b614bda6125dd565b50614bf4614bee6301ffc9a760e01b610524565b91610524565b1490565b614c0061394b565b503390565b91614c1392916001926159da565b565b614c2790614c21614bf8565b90615b0c565b565b604090614c52614c599496959396614c4860608401985f8501906112a7565b602083019061083b565b019061083b565b565b90614c669103610794565b90565b929192614c77818390614b4e565b9081614c8c614c865f19610794565b91610794565b10614c99575b5050509050565b81614cac614ca687610794565b91610794565b10614cd257614cc99394614cc1919392614c5b565b905f926159da565b805f8080614c92565b50614cf1849291925f938493637dc7a0d960e11b855260048501614c29565b0390fd5b9182614d11614d0b614d065f612b00565b610765565b91610765565b14614d6b5781614d31614d2b614d265f612b00565b610765565b91610765565b14614d4457614d4292919091615b47565b565b614d67614d505f612b00565b5f91829163ec442f0560e01b8352600483016112b4565b0390fd5b614d8e614d775f612b00565b5f918291634b637e8f60e11b8352600483016112b4565b0390fd5b614d9a6139ec565b614da057565b5f63d93c066560e01b815280614db860048201610913565b0390fd5b90565b614dd3614dce614dd892614dbc565b610687565b610794565b90565b614de56002614dbf565b90565b614df2600c61111a565b614e0b614e05614e00614ddb565b610794565b91610794565b14614e2457614e22614e1b614ddb565b600c612b67565b565b5f633ee5aeb560e01b815280614e3c60048201610913565b0390fd5b614e4a6001614447565b90565b614e5f614e58614e40565b600c612b67565b565b80614e7c614e76614e715f612b00565b610765565b91610765565b14614e9857614e9691614e8e5f612b00565b919091615b47565b565b614ebb614ea45f612b00565b5f91829163ec442f0560e01b8352600483016112b4565b0390fd5b614ec76125dd565b50614edc614ed6828490613e1a565b15610571565b5f14614f6557614f046001614eff5f614ef760058690612f86565b0185906114e5565b612b31565b90614f0d614bf8565b90614f4a614f44614f3e7f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d95612f7a565b926110df565b926110df565b92614f53610512565b80614f5d81610913565b0390a4600190565b50505f90565b614f73612f76565b50614f7d30613ceb565b614faf614fa97f0000000000000000000000000000000000000000000000000000000000000000610765565b91610765565b1480614feb575b5f14614fe0577f000000000000000000000000000000000000000000000000000000000000000090565b614fe8615bc7565b90565b504661501f6150197f0000000000000000000000000000000000000000000000000000000000000000610794565b91610794565b14614fb6565b61502d6125dd565b50615039818390613e1a565b5f146150c1576150605f61505b5f61505360058690612f86565b0185906114e5565b612b31565b90615069614bf8565b906150a66150a061509a7ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b95612f7a565b926110df565b926110df565b926150af610512565b806150b981610913565b0390a4600190565b50505f90565b6150db6150d66150e092611975565b610687565b610794565b90565b9160206151049294936150fd60408201965f83019061083b565b0190611980565b565b61510e613e44565b50615117613e48565b8161512a615124836150c7565b91610794565b101561513d575061513a90615ccd565b90565b906151585f928392637669fc0f60e11b8452600484016150e3565b0390fd5b5490565b90565b61517761517261517c92615160565b610687565b610794565b90565b90565b65ffffffffffff1690565b61519961519e91611101565b615182565b90565b6151ab905461518d565b90565b60301c90565b60018060d01b031690565b6151cb6151d0916151ae565b6151b4565b90565b6151dd90546151bf565b90565b6151f46151ef6151f992611bfd565b610687565b612415565b90565b9061525090615209612548565b506152155f840161515c565b61521e5f612ac8565b90808061523461522e6005615163565b91610794565b116152b1575b509061524b5f86019391929361517f565b616305565b8061526361525d5f612ac8565b91610794565b145f146152795750506152755f6151e0565b5b90565b6152a65f916152a161529b846152ac9601926152956001614447565b90612cf0565b9161517f565b6162fb565b016151d3565b615276565b806152bf6152c59291615f90565b90612cf0565b90836152f76152f16152ec5f6152e6818c016152e1899161517f565b6162fb565b016151a1565b611975565b91611975565b105f146153085750905b905f61523a565b915061531e906153186001614447565b90613058565b615301565b61532b616394565b615333615335565b565b6153405f600f612b31565b615348614bf8565b61537e7f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa91615375610512565b918291826112b4565b0390a1565b61538b615323565b565b90565b61539e6153a391600d6110eb565b61538d565b6153af6004820161111a565b6153c16153bb5f612ac8565b91610794565b1461554f5761543d906153e0426153da6004840161111a565b90612cf0565b806153fa6153f46153ef611a2b565b610794565b91610794565b10155f1461543f575061541a6154115f830161111a565b60018301612b67565b6154326154296002830161111a565b60038301612b67565b5b6004429101612b67565b565b8061545261544c5f612ac8565b91610794565b1161545e575b50615433565b61554061552e6155499261551d6155146155036154f16154b36154825f8b0161111a565b6154948761548e611ea4565b90612d34565b6154ad61549f611a2b565b6154a7611ea4565b90612d34565b9161641c565b946154d26154c360028c0161111a565b916154cc611ea4565b90612d34565b6154eb6154dd611a2b565b6154e5611ea4565b90612d34565b9161641c565b936154fe60018a0161111a565b613058565b61550e5f890161111a565b9061661b565b60018701612b67565b6155296003860161111a565b613058565b61553a6002850161111a565b9061661b565b60038301612b67565b5f615458565b61555d906004429101612b67565b565b615567613e44565b5061557143615ccd565b90565b90565b9061558c615587615593926110df565b615574565b825461432e565b9055565b906156209161561a6155a882613991565b6155bd846155b86009869061394f565b615577565b828185906155fd6155f76155f17f3134e8a2e6d97e929a7e54011ea5485d7d196dd5f0ba4d4ef95803e8e3fc257f956110df565b926110df565b926110df565b92615606610512565b8061561081610913565b0390a49291616647565b9161665f565b565b909161562c612797565b508061564061563a5f612ac8565b91610794565b146156c05761564f9042612cf0565b8061566961566361565e611a2b565b610794565b91610794565b10156156bb5782916156ad6156b39261568e6156b89691615688611ea4565b90612d34565b6156a7615699611a2b565b6156a1611ea4565b90612d34565b9161641c565b90613058565b61661b565b90565b505090565b5050506156cc5f612ac8565b90565b6156f66156f16156ec6156fb936156e4613ac3565b50600a613638565b61364e565b61680d565b61688c565b90565b6157109061570a612797565b506168dd565b90565b61571b614d92565b615723615725565b565b6157316001600f612b31565b615739614bf8565b61576f7f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a25891615766610512565b918291826112b4565b0390a1565b61577c615713565b565b90565b615789612621565b506157be7f00000000000000000000000000000000000000000000000000000000000000006157b8600661577e565b906169f8565b90565b6157c9612621565b506157fe7f00000000000000000000000000000000000000000000000000000000000000006157f8600761577e565b906169f8565b90565b615809612548565b506158155f820161515c565b806158286158225f612ac8565b91610794565b145f1461583e57505061583a5f6151e0565b5b90565b61586b5f916158666158608461587196019261585a6001614447565b90612cf0565b9161517f565b6162fb565b016151d3565b61583b565b908161589261588c6158875f612b00565b610765565b91610765565b146158ae576158ac91906158a55f612b00565b9091615b47565b565b6158d16158ba5f612b00565b5f918291634b637e8f60e11b8352600483016112b4565b0390fd5b6158ef906158e1612f76565b506158ea614f6b565b616a46565b90565b9261590d926159169461590361394b565b5092909192616afc565b90929192616c27565b90565b91602061593a92949361593360408201965f8301906112a7565b019061083b565b565b6159458161597f565b9161595861595284610794565b91610794565b03615961575050565b61597b5f9283926301d4b62360e61b845260048401615919565b0390fd5b6159939061598b612797565b506008613adc565b6159af61599f8261111a565b916159a983613049565b90612b67565b90565b906159d26159cd6159d7936159c5614bb1565b50600a613638565b61364e565b616d89565b90565b9092816159f76159f16159ec5f612b00565b610765565b91610765565b14615ac25783615a17615a11615a0c5f612b00565b610765565b91610765565b14615a9b57615a3b83615a36615a2f60018690614b38565b8790613adc565b612b67565b615a45575b505050565b919091615a90615a7e615a787f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925936110df565b936110df565b93615a87610512565b91829182610848565b0390a35f8080615a40565b615abe615aa75f612b00565b5f918291634a1406b160e11b8352600483016112b4565b0390fd5b615ae5615ace5f612b00565b5f91829163e602df0560e01b8352600483016112b4565b0390fd5b916020615b0a929493615b0360408201965f8301906112a7565b0190610d71565b565b90615b21615b1b838390613e1a565b15610571565b615b29575050565b615b435f92839263e2517d3f60e01b845260048401615ae9565b0390fd5b91615b5492919091616daa565b565b7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f90565b90959492615bc594615bb4615bbe92615baa608096615ba060a088019c5f890190610d71565b6020870190610d71565b6040850190610d71565b606083019061083b565b01906112a7565b565b615bcf612f76565b50615bd8615b56565b615c4f7f000000000000000000000000000000000000000000000000000000000000000091615c407f000000000000000000000000000000000000000000000000000000000000000046615c2b30613ceb565b91615c34610512565b96879560208701615b7a565b60208201810382520382610c6e565b615c61615c5b826106cb565b916148b4565b2090565b615c79615c74615c7e9261139b565b610687565b610e5c565b90565b615c8a90615c65565b9052565b916020615caf929493615ca860408201965f830190615c81565b019061083b565b565b615cc5615cc0615cca92610794565b610687565b611975565b90565b615cd5613e44565b5080615cef615ce965ffffffffffff6150c7565b91610794565b11615d0057615cfd90615cb1565b90565b6030615d1c5f9283926306dfcc6560e41b845260048401615c8e565b0390fd5b90565b615d37615d32615d3c92615d20565b610687565b610794565b90565b90565b615d56615d51615d5b92615d3f565b610687565b610e5c565b90565b615d7d90615d77615d71615d8294610e5c565b91610794565b906109b4565b610794565b90565b90565b615d9c615d97615da192615d85565b610687565b610e5c565b90565b615dc390615dbd615db7615dc894610e5c565b91610794565b906127e6565b610794565b90565b90565b615de2615ddd615de792615dcb565b610687565b610794565b90565b90565b615e01615dfc615e0692615dea565b610687565b610e5c565b90565b90565b615e20615e1b615e2592615e09565b610687565b610794565b90565b90565b615e3f615e3a615e4492615e28565b610687565b610e5c565b90565b90565b615e5e615e59615e6392615e47565b610687565b610794565b90565b90565b615e7d615e78615e8292615e66565b610687565b610e5c565b90565b90565b615e9c615e97615ea192615e85565b610687565b610794565b90565b90565b615ebb615eb6615ec092615ea4565b610687565b610e5c565b90565b615ed7615ed2615edc92615e28565b610687565b610794565b90565b615ef3615eee615ef892614dbc565b610687565b610e5c565b90565b615f0f615f0a615f1492615ea4565b610687565b610794565b90565b615f2b615f26615f3092614444565b610687565b610e5c565b90565b90565b615f4a615f45615f4f92615f33565b610687565b610794565b90565b90615f5d9102610794565b90565b615f6c615f7291610794565b91610794565b908115615f7d570490565b612d69565b90615f8d9101610794565b90565b615f98612797565b5080615fad615fa76001614447565b91610794565b11156162f857806161c261619f61618f61617f61616f61615f61614f61613f61612f61611f61610f8b6161096161026161c89f6160e26160d26160f292615ff46001614447565b908061600c616006600160801b615d23565b91610794565b10156162ca575b8061602f61602968010000000000000000615dce565b91610794565b101561629c575b8061604e616048640100000000615e0c565b91610794565b101561626e575b8061606b61606562010000615e4a565b91610794565b1015616240575b80616087616081610100615e88565b91610794565b1015616212575b806160a261609c6010615ec3565b91610794565b10156161e4575b6160bc6160b66004615efb565b91610794565b10156161cb575b6160cd6003615f36565b615f52565b6160dc6001615f17565b90615d5e565b6160ec8186615f60565b90615f82565b6160fc6001615f17565b90615d5e565b8092615f60565b90615f82565b6161196001615f17565b90615d5e565b616129818c615f60565b90615f82565b6161396001615f17565b90615d5e565b616149818a615f60565b90615f82565b6161596001615f17565b90615d5e565b6161698188615f60565b90615f82565b6161796001615f17565b90615d5e565b6161898186615f60565b90615f82565b6161996001615f17565b90615d5e565b916161bc6161b66161b1858094615f60565b610794565b91610794565b11616e3a565b90614c5b565b90565b6161df906161d96001615f17565b90615da4565b6160c3565b6161fb61620c916161f56004615ea7565b90615d5e565b916162066002615edf565b90615da4565b906160a9565b61622961623a916162236008615e69565b90615d5e565b916162346004615ea7565b90615da4565b9061608e565b616257616268916162516010615e2b565b90615d5e565b916162626008615e69565b90615da4565b90616072565b6162856162969161627f6020615ded565b90615d5e565b916162906010615e2b565b90615da4565b90616055565b6162b36162c4916162ad6040615d88565b90615d5e565b916162be6020615ded565b90615da4565b90616036565b6162e16162f2916162db6080615d42565b90615d5e565b916162ec6040615d88565b90615da4565b90616013565b90565b5f5260205f200190565b93919092616311612797565b505b8161632661632083610794565b91610794565b101561638c57616337828290616e48565b9061634d5f6163478885906162fb565b016151a1565b61635f61635987611975565b91611975565b115f1461636f5750915b91616313565b929150616386906163806001614447565b90613058565b90616369565b925050915090565b6163a561639f6139ec565b15610571565b6163ab57565b5f638dfc202b60e01b8152806163c360048201610913565b0390fd5b6163db6163d66163e092613502565b610687565b610794565b90565b6163ed60126163c7565b90565b90565b61640761640261640c926163f0565b610687565b610794565b90565b61641960116163f3565b90565b929192616427612797565b50616433818390615f52565b9161643c612797565b505f1981830983808210910303918261645d6164575f612ac8565b91610794565b1461660a578561647561646f85610794565b91610794565b11156165d8576165cf92866165d59697936164c693616492612797565b50099085821190039403936001836164b35f6164ae8791612ac8565b614c5b565b1680809504960493805f03040190615f52565b17916165c96165ad61658961656561654161651d6164ee60036164e98991615f36565b615f52565b6164f86002614dbf565b18616517600261651261650c8b8590615f52565b91614dbf565b614c5b565b90615f52565b61653b60026165366165308a8590615f52565b91614dbf565b614c5b565b90615f52565b61655f600261655a616554898590615f52565b91614dbf565b614c5b565b90615f52565b616583600261657e616578888590615f52565b91614dbf565b614c5b565b90615f52565b6165a760026165a261659c878590615f52565b91614dbf565b614c5b565b90615f52565b916165c46165be6002928590615f52565b91614dbf565b614c5b565b90615f52565b90615f52565b90565b616605866165ee6165e85f612ac8565b91610794565b146165f76163e3565b6165ff61640f565b91616e76565b616e9a565b505050916166189192615f60565b90565b61664491616627612797565b508161663b61663583610794565b91610794565b10919091616e76565b90565b61665990616653612797565b50613af2565b90565b90565b9190918061667561666f85610765565b91610765565b1415806167f3575b616687575b505050565b806166a261669c6166975f612b00565b610765565b91610765565b03616763575b50816166c46166be6166b95f612b00565b610765565b91610765565b036166d0575b80616682565b61671761670a616711926166e6600a8690613638565b906167046166fe6166f8600193616f15565b9361364e565b9161665c565b90616f68565b9290613651565b91613651565b9190916167447fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a724926110df565b92616759616750610512565b92839283610a98565b0390a25f806166ca565b6167a26167a861679b616778600a8590613638565b600261679561678f61678989616f15565b9361364e565b9161665c565b90616f68565b9290613651565b91613651565b9190916167d57fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a724926110df565b926167ea6167e1610512565b92839283610a98565b0390a25f6166a8565b50816168076168015f612ac8565b91610794565b1161667d565b5f6168219161681a612797565b500161515c565b90565b61683861683361683d92611549565b610687565b610794565b90565b61684990615ded565b9052565b91602061686e92949361686760408201965f830190616840565b019061083b565b565b61688461687f61688992610794565b610687565b611549565b90565b616894613ac3565b50806168ac6168a663ffffffff616824565b91610794565b116168bd576168ba90616870565b90565b60206168d95f9283926306dfcc6560e41b84526004840161684d565b0390fd5b6168f46168f9916168ec612797565b506008613adc565b61111a565b90565b90565b61691361690e616918926168fc565b611c00565b610d2d565b90565b61692560ff6168ff565b90565b5f5260205f2090565b905f929180549061694b61694483610b85565b8094612626565b916001811690815f146169a25750600114616966575b505050565b6169739192939450616928565b915f925b81841061698a57505001905f8080616961565b60018160209295939554848601520191019290616977565b92949550505060ff19168252151560200201905f8080616961565b906169c791616931565b90565b906169ea6169e3926169da610512565b938480926169bd565b0383610c6e565b565b6169f5906169ca565b90565b90616a01612621565b50616a0b82612f7a565b616a24616a1e616a1961691b565b610d2d565b91610d2d565b14155f14616a395750616a3690616ff2565b90565b616a4391506169ec565b90565b604291616a51612f76565b50604051917f19010000000000000000000000000000000000000000000000000000000000008352600283015260228201522090565b5f90565b616a97616a9c91611101565b61280f565b90565b90565b616ab6616ab1616abb92616a9f565b610687565b610794565b90565b616af3616afa94616ae9606094989795616adf608086019a5f870190610d71565b6020850190610e62565b6040830190610d71565b0190610d71565b565b939293616b0761394b565b50616b10616a87565b50616b19612f76565b50616b2385616a8b565b616b55616b4f7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0616aa2565b91610794565b11616be25790616b78602094955f94939293616b6f610512565b94859485616abe565b838052039060015afa15616bdd57616b905f51611c00565b80616bab616ba5616ba05f612b00565b610765565b91610765565b14616bc1575f91616bbb5f611c05565b91929190565b50616bcb5f612b00565b600191616bd75f611c05565b91929190565b612ce0565b505050616bee5f612b00565b9060039291929190565b634e487b7160e01b5f52602160045260245ffd5b60041115616c1657565b616bf8565b90616c2582616c0c565b565b80616c3a616c345f616c1b565b91616c1b565b145f14616c45575050565b80616c59616c536001616c1b565b91616c1b565b145f14616c7c575f63f645eedf60e01b815280616c7860048201610913565b0390fd5b80616c90616c8a6002616c1b565b91616c1b565b145f14616cbe57616cba616ca383616a8b565b5f91829163fce698f760e01b835260048301610848565b0390fd5b616cd1616ccb6003616c1b565b91616c1b565b14616cd95750565b616cf4905f9182916335e2f38360e21b835260048301610d7e565b0390fd5b5f5260205f2090565b616d0a8161515c565b821015616d2457616d1c600191616cf8565b910201905f90565b610ed7565b90616d3390611975565b9052565b90616d4190612415565b9052565b90616d7b616d725f616d55614b76565b94616d6c616d648383016151a1565b838801616d29565b016151d3565b60208401616d37565b565b616d8690616d45565b90565b616da7915f616da192616d9a614bb1565b5001616d01565b50616d7d565b90565b9291616db884838391617022565b83616dd3616dcd616dc85f612b00565b610765565b91610765565b14616de8575b616de692939190916171ac565b565b616df0612a98565b93616df9617191565b9480616e0d616e0788610794565b91610794565b11616e1a57509350616dd9565b8590616e365f928392630e58ae9360e11b845260048401610a98565b0390fd5b616e42612797565b50151590565b616e6d616e7392616e57612797565b508281169218616e676002614dbf565b90612d7d565b90613058565b90565b616e90616e969293616e86612797565b5080941891616e3a565b90615f52565b1890565b634e487b715f526020526024601cfd5b90565b616ec1616ebc616ec692616eaa565b610687565b610e5c565b90565b616ed290616ead565b9052565b916020616ef7929493616ef060408201965f830190616ec9565b019061083b565b565b616f0d616f08616f1292610794565b610687565b612415565b90565b616f1d612548565b5080616f37616f3160018060d01b03613651565b91610794565b11616f4857616f4590616ef9565b90565b60d0616f645f9283926306dfcc6560e41b845260048401616ed6565b0390fd5b90616f9e616fa49392616f79612548565b50616f82612548565b508093616f97616f90613e48565b9492615801565b9091617614565b9161726b565b91909190565b616fbe616fb9616fc392615dea565b610687565b610794565b90565b369037565b90616ff0616fd883613893565b92602080616fe68693613870565b9201910390616fc6565b565b616ffa612621565b50617004816172d5565b906170176170126020616faa565b616fcb565b918252602082015290565b9190918061704061703a6170355f612b00565b610765565b91610765565b145f146171215761706461705d83617058600261111a565b613058565b6002612b67565b5b8261708061707a6170755f612b00565b610765565b91610765565b145f146170f5576170a461709d83617098600261111a565b614c5b565b6002612b67565b5b9190916170f06170de6170d87fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef936110df565b936110df565b936170e7610512565b91829182610848565b0390a3565b61711c826171166171075f8790613adc565b916171118361111a565b615f82565b90612b67565b6170a5565b61713461712f5f8390613adc565b61111a565b8061714761714185610794565b91610794565b1061716f5761715a61716a918490614c5b565b6171655f8490613adc565b612b67565b617065565b9061718d9091925f93849363391434e360e21b855260048501614c29565b0390fd5b617199612797565b506171a960018060d01b03613651565b90565b916172046171fe61720b94806171d26171cc6171c75f612b00565b610765565b91610765565b1461723c575b846171f36171ed6171e85f612b00565b610765565b91610765565b1461720d575b613991565b92613991565b909161665f565b565b617235600b600261722f61722961722389616f15565b9361364e565b9161665c565b90616f68565b50506171f9565b617264600b600161725e61725861725289616f15565b9361364e565b9161665c565b90616f68565b50506171d8565b9161728f5f6172949461727c612548565b50617285612548565b500192919261517f565b6174c6565b91909190565b6172ae6172a96172b3926168fc565b610687565b610794565b90565b90565b6172cd6172c86172d2926172b6565b610687565b610794565b90565b6172ea6172ef916172e4612797565b50612f7a565b616a8b565b6172f960ff61729a565b168061730e617308601f6172b9565b91610794565b116173165790565b5f632cd44ac360e21b81528061732e60048201610913565b0390fd5b5490565b617340604061385b565b90565b5f5260205f2090565b61735581617332565b82101561736f57617367600191617343565b910201905f90565b610ed7565b61737e9051611975565b90565b9061739265ffffffffffff91611c00565b9181191691161790565b6173b06173ab6173b592611975565b610687565b611975565b90565b90565b906173d06173cb6173d79261739c565b6173b8565b8254617381565b9055565b6173e59051612415565b90565b60301b90565b9061740065ffffffffffff19916173e8565b9181191691161790565b61741e61741961742392612415565b610687565b612415565b90565b90565b9061743e6174396174459261740a565b617426565b82546173ee565b9055565b9061747360205f6174799461746b828201617465848801617374565b906173bb565b0192016173db565b90617429565b565b919061748c5761748a91617449565b565b610b5e565b90815491680100000000000000008310156174c157826174b99160016174bf9501815561734c565b9061747b565b565b610c5a565b909291926174d2612548565b506174db612548565b506174e582617332565b806174f86174f25f612ac8565b91610794565b115f146175c85761751e9061751884916175126001614447565b90612cf0565b906162fb565b9061752a5f83016151a1565b926175365f84016151d3565b938061754a61754485611975565b91611975565b116175ac5761756161755b84611975565b91611975565b145f1461757c575050617577905f859101617429565b5b9190565b6175a792506175a286617599617590617336565b945f8601616d29565b60208401616d37565b617491565b617578565b5f632520601d60e01b8152806175c460048201610913565b0390fd5b506175f3916175ee856175e56175dc617336565b945f8601616d29565b60208401616d37565b617491565b6175fc5f6151e0565b9190565b634e487b7160e01b5f52605160045260245ffd5b91909180600114617633576002036176005761762f916125c7565b905b565b5061763d91612588565b9061763156
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"a\x01``@R4a\0vWa\0\x1Ea\0\x15a\x01cV[\x92\x91\x90\x91a\x03^V[a\0&a\0{V[avCa \xBE\x829`\x80Q\x81aO\xBE\x01R`\xA0Q\x81aO\xF5\x01R`\xC0Q\x81aO\x85\x01R`\xE0Q\x81a[\xDD\x01Ra\x01\0Q\x81a\\\x02\x01Ra\x01 Q\x81aW\x8F\x01Ra\x01@Q\x81aW\xCF\x01RavC\x90\xF3[a\0\x81V[`@Q\x90V[_\x80\xFD[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\0\xAD\x90a\0\x85V[\x81\x01\x90\x81\x10`\x01\x80`@\x1B\x03\x82\x11\x17a\0\xC5W`@RV[a\0\x8FV[\x90a\0\xDDa\0\xD6a\0{V[\x92\x83a\0\xA3V[V[_\x80\xFD[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\0\xF7\x90a\0\xE3V[\x90V[a\x01\x03\x81a\0\xEEV[\x03a\x01\nWV[_\x80\xFD[\x90PQ\x90a\x01\x1B\x82a\0\xFAV[V[`\x80\x81\x83\x03\x12a\x01^Wa\x013\x82_\x83\x01a\x01\x0EV[\x92a\x01[a\x01D\x84` \x85\x01a\x01\x0EV[\x93a\x01R\x81`@\x86\x01a\x01\x0EV[\x93``\x01a\x01\x0EV[\x90V[a\0\xDFV[a\x01\x81a\x97\x01\x808\x03\x80a\x01v\x81a\0\xCAV[\x92\x839\x81\x01\x90a\x01\x1DV[\x90\x91\x92\x93V[`\x01\x80`@\x1B\x03\x81\x11a\x01\xA3Wa\x01\x9F` \x91a\0\x85V[\x01\x90V[a\0\x8FV[\x90a\x01\xBAa\x01\xB5\x83a\x01\x87V[a\0\xCAV[\x91\x82RV[_\x7FSyndicate\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x01\xF0`\ta\x01\xA8V[\x90a\x01\xFD` \x83\x01a\x01\xBFV[V[a\x02\x07a\x01\xE6V[\x90V[_\x7FSYND\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x02;`\x04a\x01\xA8V[\x90a\x02H` \x83\x01a\x02\nV[V[a\x02Ra\x021V[\x90V[\x90V[\x90V[a\x02oa\x02ja\x02t\x92a\x02UV[a\x02XV[a\0\xE3V[\x90V[a\x02\x80\x90a\x02[V[\x90V[_\x01\x90V[\x90V[_\x1B\x90V[a\x02\xA4a\x02\x9Fa\x02\xA9\x92a\x02UV[a\x02\x8BV[a\x02\x88V[\x90V[a\x02\xB5_a\x02\x90V[\x90V[\x7Fk\x97%\xF7@\xF9K\x91\xB7\x80`\xA1\xB1}\x17tem8\x14!\xA5)\xEC\x98\xCD\xB0\x13\xF4\xD9\xC2^\x90V[\x7F\xCC\xE2\x96\xB0@3*\x08\x0Em\xF15\x15\xA3\xEC(i\xE2\x1C\xD2\x0FsD\xAF\t\x87\xDD\xB98\xD8\xBD!\x90V[\x7Fe\xD7\xA2\x8E2e\xB3zdt\x92\x9F3e!\xB32\xC1h\x1B\x93?l\xB9\xF37fsD\r\x86*\x90V[\x90V[\x90V[a\x03>a\x039a\x03C\x92a\x03$V[a\x02XV[a\x03'V[\x90V[a\x03[k\x02\xE8vi\xC3\x08sj\x04\0\0\0a\x03*V[\x90V[\x90\x91\x92a\x03za\x03la\x01\xFFV[a\x03ta\x02JV[\x90a\x05\x17V[\x81a\x03\x95a\x03\x8Fa\x03\x8A_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x04\xB1W\x82a\x03\xB5a\x03\xAFa\x03\xAA_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x04\x95W\x83a\x03\xD5a\x03\xCFa\x03\xCA_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x04yW\x80a\x03\xF5a\x03\xEFa\x03\xEA_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x04]Wa\x046a\x04D\x92a\x04(a\x04S\x96a\x04\x1Aa\x04\x13a\x02\xACV[\x84\x90a\n;V[Pa\x04#a\x02\xB8V[a\n;V[Pa\x041a\x02\xDCV[a\n;V[Pa\x04?a\x03\0V[a\n;V[Pa\x04Ma\x03FV[\x90a\x0B\tV[a\x04[a\x0E\x11V[V[_c\xD9.#=`\xE0\x1B\x81R\x80a\x04u`\x04\x82\x01a\x02\x83V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a\x04\x91`\x04\x82\x01a\x02\x83V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a\x04\xAD`\x04\x82\x01a\x02\x83V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a\x04\xC9`\x04\x82\x01a\x02\x83V[\x03\x90\xFD[\x90a\x04\xD9`\xFF\x91a\x02\x8BV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x15\x15\x90V[a\x04\xF1\x90a\x04\xE3V[\x90V[\x90V[\x90a\x05\x0Ca\x05\x07a\x05\x13\x92a\x04\xE8V[a\x04\xF4V[\x82Ta\x04\xCDV[\x90UV[\x90a\x05!\x91a\x05.V[a\x05,_`\x0Fa\x04\xF7V[V[a\x05:\x91\x81\x90\x91a\x05\xBDV[V[\x90V[a\x05Sa\x05Na\x05X\x92a\x05<V[a\x02XV[a\x03'V[\x90V[a\x05e`\x01a\x05?V[\x90V[\x90a\x05t_\x19\x91a\x02\x8BV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x05\x92a\x05\x8Da\x05\x97\x92a\x03'V[a\x02XV[a\x03'V[\x90V[\x90V[\x90a\x05\xB2a\x05\xADa\x05\xB9\x92a\x05~V[a\x05\x9AV[\x82Ta\x05hV[\x90UV[\x90a\x05\xC8\x92\x91a\x05\xDCV[a\x05\xDAa\x05\xD3a\x05[V[`\x0Ca\x05\x9DV[V[\x90a\x05\xE7\x92\x91a\x05\xE9V[V[\x90a\x05\xF4\x92\x91a\x05\xF6V[V[\x90a\x06\x01\x92\x91a\x06\x03V[V[\x90a\x06\x0E\x92\x91a\x06\x10V[V[\x90a\x06\x1B\x92\x91a\x06\x1DV[V[\x90a\x06(\x92\x91a\x06uV[V[_\x7F1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x06[`\x01a\x01\xA8V[\x90a\x06h` \x83\x01a\x06*V[V[a\x06ra\x06QV[\x90V[\x90a\x06\x89\x92\x91a\x06\x83a\x06jV[\x90a\x06\x8BV[V[\x90a\x06\x97\x93\x92\x91a\x06\xDDV[V[\x90V[\x90V[` \x01\x90V[Q\x90V[a\x06\xBDa\x06\xB8a\x06\xC2\x92a\0\xE3V[a\x02XV[a\0\xE3V[\x90V[a\x06\xCE\x90a\x06\xA9V[\x90V[a\x06\xDA\x90a\x06\xC5V[\x90V[a\x06\xEEa\x07>\x94a\x07#\x93\x94a\x07rV[a\x07\x02\x81a\x06\xFC`\x06a\x06\x99V[\x90a\x10?V[a\x01 Ra\x07\x1A\x83a\x07\x14`\x07a\x06\x99V[\x90a\x10?V[a\x01@Ra\x06\x9CV[a\x075a\x07/\x82a\x06\xA5V[\x91a\x06\x9FV[ `\xE0Ra\x06\x9CV[a\x07Pa\x07J\x82a\x06\xA5V[\x91a\x06\x9FV[ a\x01\0RF`\xA0Ra\x07aa\x11DV[`\x80Ra\x07m0a\x06\xD1V[`\xC0RV[\x90a\x07|\x91a\x07~V[V[\x90a\x07\x88\x91a\x07\x8AV[V[\x90a\x07\x94\x91a\t\xDBV[V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[Q\x90V[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x07\xE1W[` \x83\x10\x14a\x07\xDCWV[a\x07\xADV[\x91`\x7F\x16\x91a\x07\xD1V[_R` _ \x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a\x08\x1D\x91\x02\x91a\x08\x17_\x19\x84a\x07\xFEV[\x92a\x07\xFEV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x91\x90a\x08=a\x088a\x08E\x93a\x05~V[a\x05\x9AV[\x90\x83Ta\x08\x02V[\x90UV[_\x90V[a\x08_\x91a\x08Ya\x08IV[\x91a\x08'V[V[[\x81\x81\x10a\x08mWPPV[\x80a\x08z_`\x01\x93a\x08MV[\x01a\x08bV[\x91\x90`\x1F\x81\x11a\x08\x90W[PPPV[a\x08\x9Ca\x08\xC1\x93a\x07\xEBV[\x90` a\x08\xA8\x84a\x07\xF4V[\x83\x01\x93\x10a\x08\xC9W[a\x08\xBA\x90a\x07\xF4V[\x01\x90a\x08aV[_\x80\x80a\x08\x8BV[\x91Pa\x08\xBA\x81\x92\x90Pa\x08\xB1V[\x1C\x90V[\x90a\x08\xEB\x90_\x19\x90`\x08\x02a\x08\xD7V[\x19\x16\x90V[\x81a\x08\xFA\x91a\x08\xDBV[\x90`\x02\x02\x17\x90V[\x90a\t\x0C\x81a\x07\xA9V[\x90`\x01\x80`@\x1B\x03\x82\x11a\t\xCAWa\t.\x82a\t(\x85Ta\x07\xC1V[\x85a\x08\x80V[` \x90`\x1F\x83\x11`\x01\x14a\tbW\x91\x80\x91a\tQ\x93_\x92a\tVW[PPa\x08\xF0V[\x90U[V[\x90\x91P\x01Q_\x80a\tJV[`\x1F\x19\x83\x16\x91a\tq\x85a\x07\xEBV[\x92_[\x81\x81\x10a\t\xB2WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\t\x98W[PPP\x02\x01\x90Ua\tTV[a\t\xA8\x91\x01Q`\x1F\x84\x16\x90a\x08\xDBV[\x90U_\x80\x80a\t\x8CV[\x91\x93` `\x01\x81\x92\x87\x87\x01Q\x81U\x01\x95\x01\x92\x01a\ttV[a\0\x8FV[\x90a\t\xD9\x91a\t\x02V[V[\x90a\t\xEAa\t\xF1\x92`\x03a\t\xCFV[`\x04a\t\xCFV[V[_\x90V[a\n\0\x90a\x02\x88V[\x90V[\x90a\n\r\x90a\t\xF7V[_R` R`@_ \x90V[a\n\"\x90a\x06\xC5V[\x90V[\x90a\n/\x90a\n\x19V[_R` R`@_ \x90V[a\nCa\t\xF3V[Pa\nXa\nR\x82\x84\x90a\x11\xE1V[\x15a\x04\xE3V[_\x14a\n\xE1Wa\n\x80`\x01a\n{_a\ns`\x05\x86\x90a\n\x03V[\x01\x85\x90a\n%V[a\x04\xF7V[\x90a\n\x89a\x12\x0FV[\x90a\n\xC6a\n\xC0a\n\xBA\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a\t\xF7V[\x92a\n\x19V[\x92a\n\x19V[\x92a\n\xCFa\0{V[\x80a\n\xD9\x81a\x02\x83V[\x03\x90\xA4`\x01\x90V[PP_\x90V[a\n\xF0\x90a\0\xEEV[\x90RV[\x91\x90a\x0B\x07\x90_` \x85\x01\x94\x01\x90a\n\xE7V[V[\x80a\x0B$a\x0B\x1Ea\x0B\x19_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x0B@Wa\x0B>\x91a\x0B6_a\x02wV[\x91\x90\x91a\x12\x1CV[V[a\x0Bca\x0BL_a\x02wV[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\n\xF4V[\x03\x90\xFD[`\x01\x80`@\x1B\x03\x81\x11a\x0BzW` \x02\x90V[a\0\x8FV[a\x0B\x8Ba\x0B\x90\x91a\x0BgV[a\0\xCAV[\x90V[\x90V[a\x0B\xAAa\x0B\xA5a\x0B\xAF\x92a\x0B\x93V[a\x02XV[a\x03'V[\x90V[\x90a\x0B\xBC\x90a\x03'V[\x90RV[\x90V[a\x0B\xD7a\x0B\xD2a\x0B\xDC\x92a\x0B\xC0V[a\x02XV[a\x03'V[\x90V[\x90V[a\x0B\xF6a\x0B\xF1a\x0B\xFB\x92a\x0B\xDFV[a\x02XV[a\x03'V[\x90V[\x90V[a\x0C\x15a\x0C\x10a\x0C\x1A\x92a\x0B\xFEV[a\x02XV[a\x03'V[\x90V[\x90V[a\x0C4a\x0C/a\x0C9\x92a\x0C\x1DV[a\x02XV[a\x03'V[\x90V[\x90V[a\x0CSa\x0CNa\x0CX\x92a\x0C<V[a\x02XV[a\x03'V[\x90V[\x90V[a\x0Cra\x0Cma\x0Cw\x92a\x0C[V[a\x02XV[a\x03'V[\x90V[\x90V[a\x0C\x91a\x0C\x8Ca\x0C\x96\x92a\x0CzV[a\x02XV[a\x03'V[\x90V[a\x0C\xADa\x0C\xA8a\x0C\xB2\x92a\x02UV[a\x02XV[a\x03'V[\x90V[`\x01a\x0C\xC1\x91\x01a\x03'V[\x90V[\x90V[a\x0C\xDBa\x0C\xD6a\x0C\xE0\x92a\x0C\xC4V[a\x02XV[a\x03'V[\x90V[\x90V[a\x0C\xFAa\x0C\xF5a\x0C\xFF\x92a\x0C\xE3V[a\x02XV[a\x03'V[\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\r%a\r+\x91\x93\x92\x93a\x03'V[\x92a\x03'V[\x91a\r7\x83\x82\x02a\x03'V[\x92\x81\x84\x04\x14\x90\x15\x17\x15a\rFWV[a\r\x02V[a\rZa\r`\x91\x93\x92\x93a\x03'V[\x92a\x03'V[\x82\x01\x80\x92\x11a\rkWV[a\r\x02V[\x90V[a\r\x87a\r\x82a\r\x8C\x92a\rpV[a\x02XV[a\x03'V[\x90V[a\r\x99`0a\rsV[\x90V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[P`\x08\x90V[\x90a\r\xC0\x82a\r\xB0V[\x81\x10\x15a\r\xCEW` \x02\x01\x90V[a\r\x9CV[a\r\xDD\x90Qa\x03'V[\x90V[P`0\x90V[\x90V[a\r\xF2\x81a\r\xE0V[\x82\x10\x15a\x0E\x0CWa\x0E\x04`\x01\x91a\r\xE6V[\x91\x02\x01\x90_\x90V[a\r\x9CV[a\x0E\x1B`\x08a\x0B\x7FV[a\x0E:a\x0E2j\x05\x9B\xD6Z\x1E\xCAm\xB6X\0\0a\x0B\x96V[_\x83\x01a\x0B\xB2V[a\x0EZa\x0EQj\x03]\x80\x9Cx\xDF\xDBmh\0\0a\x0B\xC3V[` \x83\x01a\x0B\xB2V[a\x0Eza\x0Eqj\x02\x04\xE6\xE0\t\xF3\xB7\xC3\xA0\0\0a\x0B\xE2V[`@\x83\x01a\x0B\xB2V[a\x0E\x9Aa\x0E\x91j\x016$ \x05\xF8\xA1u`\0\0a\x0C\x01V[``\x83\x01a\x0B\xB2V[a\x0E\xB9a\x0E\xB0i\xBA\x15\xAC\xD0a\xFAy\xA0\0\0a\x0C V[`\x80\x83\x01a\x0B\xB2V[a\x0E\xD8a\x0E\xCFio\xA6\xD2fH\xCBL\xF0\0\0a\x0C?V[`\xA0\x83\x01a\x0B\xB2V[a\x0E\xF7a\x0E\xEEiB\xFD^,I\xDD\xA88\0\0a\x0C^V[`\xC0\x83\x01a\x0B\xB2V[a\x0F\x16a\x0F\ri(1\x9E\xE7_\x84\xFE\x88\0\0a\x0C}V[`\xE0\x83\x01a\x0B\xB2V[a\x0F\x1F_a\x0C\x99V[\x91[\x82a\x0F5a\x0F/`\x08a\x0C\xC7V[\x91a\x03'V[\x10\x15a\x0F\xEBWa\x0FD_a\x0C\x99V[[\x80a\x0FYa\x0FS`\x06a\x0C\xE6V[\x91a\x03'V[\x10\x15a\x0F\xDAWa\x0F\xA7\x90a\x0F\x81a\x0Fz\x86a\x0Ft`\x06a\x0C\xE6V[\x90a\r\x16V[\x82\x90a\rKV[\x80a\x0F\x9Ba\x0F\x95a\x0F\x90a\r\x8FV[a\x03'V[\x91a\x03'V[\x10a\x0F\xACW[Pa\x0C\xB5V[a\x0FEV[a\x0F\xD4\x90a\x0F\xCEa\x0F\xC6a\x0F\xC1\x88\x8A\x90a\r\xB6V[a\r\xD3V[\x91`\x10a\r\xE9V[\x90a\x08'V[_a\x0F\xA1V[P\x91a\x0F\xE5\x90a\x0C\xB5V[\x91a\x0F!V[\x91PPV[_\x90V[\x90V[a\x10\x0Ba\x10\x06a\x10\x10\x92a\x0F\xF4V[a\x02XV[a\x03'V[\x90V[\x90V[a\x10*a\x10%a\x10/\x92a\x10\x13V[a\x02\x8BV[a\x02\x88V[\x90V[a\x10<`\xFFa\x10\x16V[\x90V[\x90a\x10Ha\x0F\xF0V[Pa\x10Za\x10U\x83a\x06\x9CV[a\x06\xA5V[a\x10ma\x10g` a\x0F\xF7V[\x91a\x03'V[\x10_\x14a\x10\x81WPa\x10~\x90a\x13\x1BV[\x90V[_a\x10\x8Fa\x10\x95\x93\x92a\x12+V[\x01a\t\xCFV[a\x10\xA5a\x10\xA0a\x102V[a\t\xF7V[\x90V[_\x90V[\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x90V[a\x10\xDA\x90Qa\x02\x88V[\x90V[a\x10\xE6\x90a\x02\x88V[\x90RV[a\x10\xF3\x90a\x03'V[\x90RV[\x90\x95\x94\x92a\x11B\x94a\x111a\x11;\x92a\x11'`\x80\x96a\x11\x1D`\xA0\x88\x01\x9C_\x89\x01\x90a\x10\xDDV[` \x87\x01\x90a\x10\xDDV[`@\x85\x01\x90a\x10\xDDV[``\x83\x01\x90a\x10\xEAV[\x01\x90a\n\xE7V[V[a\x11La\x10\xA8V[Pa\x11Ua\x10\xACV[a\x11\x9Fa\x11b`\xE0a\x10\xD0V[\x91a\x11\x90a\x11qa\x01\0a\x10\xD0V[Fa\x11{0a\x06\xD1V[\x91a\x11\x84a\0{V[\x96\x87\x95` \x87\x01a\x10\xF7V[` \x82\x01\x81\x03\x82R\x03\x82a\0\xA3V[a\x11\xB1a\x11\xAB\x82a\x06\xA5V[\x91a\x06\x9FV[ \x90V[_\x1C\x90V[`\xFF\x16\x90V[a\x11\xCCa\x11\xD1\x91a\x11\xB5V[a\x11\xBAV[\x90V[a\x11\xDE\x90Ta\x11\xC0V[\x90V[a\x12\x08\x91_a\x11\xFDa\x12\x03\x93a\x11\xF5a\t\xF3V[P`\x05a\n\x03V[\x01a\n%V[a\x11\xD4V[\x90V[_\x90V[a\x12\x17a\x12\x0BV[P3\x90V[\x91a\x12)\x92\x91\x90\x91a\x13\xC8V[V[\x90V[\x90V[a\x12Ea\x12@a\x12J\x92a\x12.V[a\x02XV[a\x03'V[\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[a\x12\x80a\x12\x89` \x93a\x12\x8E\x93a\x12w\x81a\x07\xA9V[\x93\x84\x80\x93a\x12MV[\x95\x86\x91\x01a\x12VV[a\0\x85V[\x01\x90V[a\x12\xA7\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x12aV[\x90V[a\x12\xC4a\x12\xBFa\x12\xB9\x83a\x06\xA5V[\x92a\x06\x9FV[a\x10\xD0V[\x90` \x81\x10a\x12\xD2W[P\x90V[a\x12\xE4\x90_\x19\x90` \x03`\x08\x02a\x07\xFEV[\x16_a\x12\xCEV[a\x12\xF7a\x12\xFC\x91a\x11\xB5V[a\x05~V[\x90V[a\x13\x13a\x13\x0Ea\x13\x18\x92a\x03'V[a\x02\x8BV[a\x02\x88V[\x90V[a\x13#a\x0F\xF0V[Pa\x13-\x81a\x06\x9CV[\x90a\x137\x82a\x06\xA5V[a\x13Ja\x13D`\x1Fa\x121V[\x91a\x03'V[\x11a\x13\x7FWPa\x13w\x81a\x13qa\x13ka\x13fa\x13|\x95a\x12\xAAV[a\x12\xEBV[\x91a\x06\xA5V[\x17a\x12\xFFV[a\t\xF7V[\x90V[a\x13\xA1\x90a\x13\x8Ba\0{V[\x91\x82\x91c0Z'\xA9`\xE0\x1B\x83R`\x04\x83\x01a\x12\x92V[\x03\x90\xFD[\x91` a\x13\xC6\x92\x94\x93a\x13\xBF`@\x82\x01\x96_\x83\x01\x90a\x10\xEAV[\x01\x90a\x10\xEAV[V[\x92\x91a\x13\xD6\x84\x83\x83\x91a\x14\xF5V[\x83a\x13\xF1a\x13\xEBa\x13\xE6_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x14\x06W[a\x14\x04\x92\x93\x91\x90\x91a\x16\xC2V[V[a\x14\x0Ea\x16dV[\x93a\x14\x17a\x16\xA1V[\x94\x80a\x14+a\x14%\x88a\x03'V[\x91a\x03'V[\x11a\x148WP\x93Pa\x13\xF7V[\x85\x90a\x14T_\x92\x83\x92c\x0EX\xAE\x93`\xE1\x1B\x84R`\x04\x84\x01a\x13\xA5V[\x03\x90\xFD[\x90a\x14b\x90a\n\x19V[_R` R`@_ \x90V[\x90V[a\x14}a\x14\x82\x91a\x11\xB5V[a\x14nV[\x90V[a\x14\x8F\x90Ta\x14qV[\x90V[`@\x90a\x14\xBBa\x14\xC2\x94\x96\x95\x93\x96a\x14\xB1``\x84\x01\x98_\x85\x01\x90a\n\xE7V[` \x83\x01\x90a\x10\xEAV[\x01\x90a\x10\xEAV[V[\x90a\x14\xCF\x91\x03a\x03'V[\x90V[\x90a\x14\xDD\x91\x01a\x03'V[\x90V[\x91\x90a\x14\xF3\x90_` \x85\x01\x94\x01\x90a\x10\xEAV[V[\x91\x90\x91\x80a\x15\x13a\x15\ra\x15\x08_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14_\x14a\x15\xF4Wa\x157a\x150\x83a\x15+`\x02a\x14\x85V[a\rKV[`\x02a\x05\x9DV[[\x82a\x15Sa\x15Ma\x15H_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14_\x14a\x15\xC8Wa\x15wa\x15p\x83a\x15k`\x02a\x14\x85V[a\x14\xC4V[`\x02a\x05\x9DV[[\x91\x90\x91a\x15\xC3a\x15\xB1a\x15\xAB\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x93a\n\x19V[\x93a\n\x19V[\x93a\x15\xBAa\0{V[\x91\x82\x91\x82a\x14\xE0V[\x03\x90\xA3V[a\x15\xEF\x82a\x15\xE9a\x15\xDA_\x87\x90a\x14XV[\x91a\x15\xE4\x83a\x14\x85V[a\x14\xD2V[\x90a\x05\x9DV[a\x15xV[a\x16\x07a\x16\x02_\x83\x90a\x14XV[a\x14\x85V[\x80a\x16\x1Aa\x16\x14\x85a\x03'V[\x91a\x03'V[\x10a\x16BWa\x16-a\x16=\x91\x84\x90a\x14\xC4V[a\x168_\x84\x90a\x14XV[a\x05\x9DV[a\x158V[\x90a\x16`\x90\x91\x92_\x93\x84\x93c9\x144\xE3`\xE2\x1B\x85R`\x04\x85\x01a\x14\x92V[\x03\x90\xFD[a\x16la\x08IV[Pa\x16w`\x02a\x14\x85V[\x90V[`\x01\x80`\xD0\x1B\x03\x16\x90V[a\x16\x99a\x16\x94a\x16\x9E\x92a\x16zV[a\x02XV[a\x03'V[\x90V[a\x16\xA9a\x08IV[Pa\x16\xB9`\x01\x80`\xD0\x1B\x03a\x16\x85V[\x90V[\x90V[\x90V[\x91a\x17\x1Aa\x17\x14a\x17!\x94\x80a\x16\xE8a\x16\xE2a\x16\xDD_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x17RW[\x84a\x17\ta\x17\x03a\x16\xFE_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x14a\x17#W[a\x19JV[\x92a\x19JV[\x90\x91a\x19\x7FV[V[a\x17K`\x0B`\x02a\x17Ea\x17?a\x179\x89a\x184V[\x93a\x16\xBCV[\x91a\x16\xBFV[\x90a\x18\x87V[PPa\x17\x0FV[a\x17z`\x0B`\x01a\x17ta\x17na\x17h\x89a\x184V[\x93a\x16\xBCV[\x91a\x16\xBFV[\x90a\x18\x87V[PPa\x16\xEEV[_\x90V[a\x17\x91a\x17\x97\x91a\x16zV[\x91a\x16zV[\x01\x90`\x01\x80`\xD0\x1B\x03\x82\x11a\x17\xA8WV[a\r\x02V[\x90a\x17\xC0\x91a\x17\xBAa\x17\x81V[Pa\x17\x85V[\x90V[\x90V[`\xFF\x16\x90V[a\x17\xE0a\x17\xDBa\x17\xE5\x92a\x17\xC3V[a\x02XV[a\x17\xC6V[\x90V[a\x17\xF1\x90a\x17\xCCV[\x90RV[\x91` a\x18\x16\x92\x94\x93a\x18\x0F`@\x82\x01\x96_\x83\x01\x90a\x17\xE8V[\x01\x90a\x10\xEAV[V[a\x18,a\x18'a\x181\x92a\x03'V[a\x02XV[a\x16zV[\x90V[a\x18<a\x17\x81V[P\x80a\x18Va\x18P`\x01\x80`\xD0\x1B\x03a\x16\x85V[\x91a\x03'V[\x11a\x18gWa\x18d\x90a\x18\x18V[\x90V[`\xD0a\x18\x83_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01a\x17\xF5V[\x03\x90\xFD[\x90a\x18\xBDa\x18\xC3\x93\x92a\x18\x98a\x17\x81V[Pa\x18\xA1a\x17\x81V[P\x80\x93a\x18\xB6a\x18\xAFa\x1B1V[\x94\x92a\x1B\xBFV[\x90\x91a \x8EV[\x91a\x1C4V[\x91\x90\x91\x90V[a\x18\xD5a\x18\xDB\x91a\x16zV[\x91a\x16zV[\x90\x03\x90`\x01\x80`\xD0\x1B\x03\x82\x11a\x18\xEDWV[a\r\x02V[\x90a\x19\x05\x91a\x18\xFFa\x17\x81V[Pa\x18\xC9V[\x90V[\x90a\x19\x12\x90a\n\x19V[_R` R`@_ \x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x195a\x19:\x91a\x11\xB5V[a\x19\x1EV[\x90V[a\x19G\x90Ta\x19)V[\x90V[a\x19aa\x19f\x91a\x19Ya\x12\x0BV[P`\ta\x19\x08V[a\x19=V[\x90V[\x90a\x19s\x90a\n\x19V[_R` R`@_ \x90V[\x91\x90\x91\x80a\x19\x95a\x19\x8F\x85a\0\xEEV[\x91a\0\xEEV[\x14\x15\x80a\x1B\x13W[a\x19\xA7W[PPPV[\x80a\x19\xC2a\x19\xBCa\x19\xB7_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x03a\x1A\x83W[P\x81a\x19\xE4a\x19\xDEa\x19\xD9_a\x02wV[a\0\xEEV[\x91a\0\xEEV[\x03a\x19\xF0W[\x80a\x19\xA2V[a\x1A7a\x1A*a\x1A1\x92a\x1A\x06`\n\x86\x90a\x19iV[\x90a\x1A$a\x1A\x1Ea\x1A\x18`\x01\x93a\x184V[\x93a\x16\xBCV[\x91a\x16\xBFV[\x90a\x18\x87V[\x92\x90a\x16\x85V[\x91a\x16\x85V[\x91\x90\x91a\x1Ad\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\n\x19V[\x92a\x1Aya\x1Apa\0{V[\x92\x83\x92\x83a\x13\xA5V[\x03\x90\xA2_\x80a\x19\xEAV[a\x1A\xC2a\x1A\xC8a\x1A\xBBa\x1A\x98`\n\x85\x90a\x19iV[`\x02a\x1A\xB5a\x1A\xAFa\x1A\xA9\x89a\x184V[\x93a\x16\xBCV[\x91a\x16\xBFV[\x90a\x18\x87V[\x92\x90a\x16\x85V[\x91a\x16\x85V[\x91\x90\x91a\x1A\xF5\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\n\x19V[\x92a\x1B\na\x1B\x01a\0{V[\x92\x83\x92\x83a\x13\xA5V[\x03\x90\xA2_a\x19\xC8V[P\x81a\x1B'a\x1B!_a\x0C\x99V[\x91a\x03'V[\x11a\x19\x9DV[_\x90V[a\x1B9a\x1B-V[Pa\x1BBa\x1CcV[\x90V[T\x90V[a\x1BXa\x1B^\x91\x93\x92\x93a\x03'V[\x92a\x03'V[\x82\x03\x91\x82\x11a\x1BiWV[a\r\x02V[\x90V[`0\x1C\x90V[`\x01\x80`\xD0\x1B\x03\x16\x90V[a\x1B\x8Ea\x1B\x93\x91a\x1BqV[a\x1BwV[\x90V[a\x1B\xA0\x90Ta\x1B\x82V[\x90V[a\x1B\xB7a\x1B\xB2a\x1B\xBC\x92a\x02UV[a\x02XV[a\x16zV[\x90V[a\x1B\xC7a\x17\x81V[Pa\x1B\xD3_\x82\x01a\x1BEV[\x80a\x1B\xE6a\x1B\xE0_a\x0C\x99V[\x91a\x03'V[\x14_\x14a\x1B\xFCWPPa\x1B\xF8_a\x1B\xA3V[[\x90V[a\x1C)_\x91a\x1C$a\x1C\x1E\x84a\x1C/\x96\x01\x92a\x1C\x18`\x01a\x05?V[\x90a\x1BIV[\x91a\x1BnV[a\x1CxV[\x01a\x1B\x96V[a\x1B\xF9V[\x91a\x1CX_a\x1C]\x94a\x1CEa\x17\x81V[Pa\x1CNa\x17\x81V[P\x01\x92\x91\x92a\x1BnV[a\x1EiV[\x91\x90\x91\x90V[a\x1Cka\x1B-V[Pa\x1CuCa 'V[\x90V[_R` _ \x01\x90V[T\x90V[a\x1C\x90`@a\0\xCAV[\x90V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[\x90a\x1C\xA8\x90a\x1C\x93V[\x90RV[\x90a\x1C\xB6\x90a\x16zV[\x90RV[_R` _ \x90V[a\x1C\xCC\x81a\x1C\x82V[\x82\x10\x15a\x1C\xE6Wa\x1C\xDE`\x01\x91a\x1C\xBAV[\x91\x02\x01\x90_\x90V[a\r\x9CV[a\x1C\xF5\x90Qa\x1C\x93V[\x90V[\x90a\x1D\te\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x02\x8BV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x1D'a\x1D\"a\x1D,\x92a\x1C\x93V[a\x02XV[a\x1C\x93V[\x90V[\x90V[\x90a\x1DGa\x1DBa\x1DN\x92a\x1D\x13V[a\x1D/V[\x82Ta\x1C\xF8V[\x90UV[a\x1D\\\x90Qa\x16zV[\x90V[`0\x1B\x90V[\x90a\x1Dwe\xFF\xFF\xFF\xFF\xFF\xFF\x19\x91a\x1D_V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x1D\x95a\x1D\x90a\x1D\x9A\x92a\x16zV[a\x02XV[a\x16zV[\x90V[\x90V[\x90a\x1D\xB5a\x1D\xB0a\x1D\xBC\x92a\x1D\x81V[a\x1D\x9DV[\x82Ta\x1DeV[\x90UV[\x90a\x1D\xEA` _a\x1D\xF0\x94a\x1D\xE2\x82\x82\x01a\x1D\xDC\x84\x88\x01a\x1C\xEBV[\x90a\x1D2V[\x01\x92\x01a\x1DRV[\x90a\x1D\xA0V[V[\x91\x90a\x1E\x03Wa\x1E\x01\x91a\x1D\xC0V[V[a\x07\x96V[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15a\x1E8W\x82a\x1E0\x91`\x01a\x1E6\x95\x01\x81Ua\x1C\xC3V[\x90a\x1D\xF2V[V[a\0\x8FV[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x1ETa\x1EY\x91a\x11\xB5V[a\x1E=V[\x90V[a\x1Ef\x90Ta\x1EHV[\x90V[\x90\x92\x91\x92a\x1Eua\x17\x81V[Pa\x1E~a\x17\x81V[Pa\x1E\x88\x82a\x1C\x82V[\x80a\x1E\x9Ba\x1E\x95_a\x0C\x99V[\x91a\x03'V[\x11_\x14a\x1FkWa\x1E\xC1\x90a\x1E\xBB\x84\x91a\x1E\xB5`\x01a\x05?V[\x90a\x1BIV[\x90a\x1CxV[\x90a\x1E\xCD_\x83\x01a\x1E\\V[\x92a\x1E\xD9_\x84\x01a\x1B\x96V[\x93\x80a\x1E\xEDa\x1E\xE7\x85a\x1C\x93V[\x91a\x1C\x93V[\x11a\x1FOWa\x1F\x04a\x1E\xFE\x84a\x1C\x93V[\x91a\x1C\x93V[\x14_\x14a\x1F\x1FWPPa\x1F\x1A\x90_\x85\x91\x01a\x1D\xA0V[[\x91\x90V[a\x1FJ\x92Pa\x1FE\x86a\x1F<a\x1F3a\x1C\x86V[\x94_\x86\x01a\x1C\x9EV[` \x84\x01a\x1C\xACV[a\x1E\x08V[a\x1F\x1BV[_c% `\x1D`\xE0\x1B\x81R\x80a\x1Fg`\x04\x82\x01a\x02\x83V[\x03\x90\xFD[Pa\x1F\x96\x91a\x1F\x91\x85a\x1F\x88a\x1F\x7Fa\x1C\x86V[\x94_\x86\x01a\x1C\x9EV[` \x84\x01a\x1C\xACV[a\x1E\x08V[a\x1F\x9F_a\x1B\xA3V[\x91\x90V[a\x1F\xB7a\x1F\xB2a\x1F\xBC\x92a\x1C\x93V[a\x02XV[a\x03'V[\x90V[a\x1F\xD3a\x1F\xCEa\x1F\xD8\x92a\rpV[a\x02XV[a\x17\xC6V[\x90V[a\x1F\xE4\x90a\x1F\xBFV[\x90RV[\x91` a \t\x92\x94\x93a \x02`@\x82\x01\x96_\x83\x01\x90a\x1F\xDBV[\x01\x90a\x10\xEAV[V[a \x1Fa \x1Aa $\x92a\x03'V[a\x02XV[a\x1C\x93V[\x90V[a /a\x1B-V[P\x80a Ia Ce\xFF\xFF\xFF\xFF\xFF\xFFa\x1F\xA3V[\x91a\x03'V[\x11a ZWa W\x90a \x0BV[\x90V[`0a v_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01a\x1F\xE8V[\x03\x90\xFD[cNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[\x91\x90\x91\x80`\x01\x14a \xADW`\x02\x03a zWa \xA9\x91a\x18\xF2V[\x90[V[Pa \xB7\x91a\x17\xADV[\x90a \xABV\xFE`\x80`@R`\x046\x10\x15a\0\x13W[a%DV[a\0\x1D_5a\x05\x0CV[\x80c\x01\xFF\xC9\xA7\x14a\x05\x07W\x80c\x06\xFD\xDE\x03\x14a\x05\x02W\x80c\x07\xA1\xD5\xFA\x14a\x04\xFDW\x80c\t^\xA7\xB3\x14a\x04\xF8W\x80c\x0C\x05\xF8,\x14a\x04\xF3W\x80c\x13\xBE\xAA[\x14a\x04\xEEW\x80c\x18\x16\r\xDD\x14a\x04\xE9W\x80c\x1B\x02\xF8E\x14a\x04\xE4W\x80c\"\xA9}\x9C\x14a\x04\xDFW\x80c#\xB8r\xDD\x14a\x04\xDAW\x80c#\xE4`\xD2\x14a\x04\xD5W\x80c$:0\xCC\x14a\x04\xD0W\x80c$\x81\xBB\\\x14a\x04\xCBW\x80c$\x8A\x9C\xA3\x14a\x04\xC6W\x80c(N\x133\x14a\x04\xC1W\x80c//\xF1]\x14a\x04\xBCW\x80c1<\xE5g\x14a\x04\xB7W\x80c3M\x0B\xBD\x14a\x04\xB2W\x80c5\x9Bv\xFE\x14a\x04\xADW\x80c6D\xE5\x15\x14a\x04\xA8W\x80c6V\x8A\xBE\x14a\x04\xA3W\x80c:F\xB1\xA8\x14a\x04\x9EW\x80c?K\xA8:\x14a\x04\x99W\x80c@\xC1\x0F\x19\x14a\x04\x94W\x80cD\xE1\x81\xAA\x14a\x04\x8FW\x80cH\xB0\xDA\xA6\x14a\x04\x8AW\x80cK\xDD6\xCE\x14a\x04\x85W\x80cK\xF5\xD7\xE9\x14a\x04\x80W\x80cX|\xDE\x1E\x14a\x04{W\x80cZ\xDF\0!\x14a\x04vW\x80c\\\x19\xA9\\\x14a\x04qW\x80c\\\x97Z\xBB\x14a\x04lW\x80c_\x15\xC3\xC9\x14a\x04gW\x80ce\x1F\xD2h\x14a\x04bW\x80cl3\xBC\xED\x14a\x04]W\x80cl\xF0\x16%\x14a\x04XW\x80co\xC0c\xBE\x14a\x04SW\x80co\xCF\xFFE\x14a\x04NW\x80cp\xA0\x821\x14a\x04IW\x80crf\0\xCE\x14a\x04DW\x80cvg\x18\x08\x14a\x04?W\x80c|y\x0C\xAB\x14a\x04:W\x80c~\xCE\xBE\0\x14a\x045W\x80c\x84V\xCBY\x14a\x040W\x80c\x84\xB0\x19n\x14a\x04+W\x80c\x8ES\x9E\x8C\x14a\x04&W\x80c\x90-U\xA5\x14a\x04!W\x80c\x91\xD1HT\x14a\x04\x1CW\x80c\x91\xDD\xAD\xF4\x14a\x04\x17W\x80c\x95\xD8\x9BA\x14a\x04\x12W\x80c\x99\x12}\x9B\x14a\x04\rW\x80c\x99\x89U\xD3\x14a\x04\x08W\x80c\x9A\xB2N\xB0\x14a\x04\x03W\x80c\x9B~\xF6K\x14a\x03\xFEW\x80c\x9D\xC2\x9F\xAC\x14a\x03\xF9W\x80c\xA0\x8DVT\x14a\x03\xF4W\x80c\xA2\x17\xFD\xDF\x14a\x03\xEFW\x80c\xA3\xD4H[\x14a\x03\xEAW\x80c\xA4\xD7\xE3\x1D\x14a\x03\xE5W\x80c\xA5q\xE1\x84\x14a\x03\xE0W\x80c\xA5\xB3&\xBE\x14a\x03\xDBW\x80c\xA7\x0B\x9F\x0C\x14a\x03\xD6W\x80c\xA9\x05\x9C\xBB\x14a\x03\xD1W\x80c\xAE^\xCB\xC6\x14a\x03\xCCW\x80c\xAF*\xA6;\x14a\x03\xC7W\x80c\xB0\xCA%>\x14a\x03\xC2W\x80c\xBA\xBC9O\x14a\x03\xBDW\x80c\xBBMD6\x14a\x03\xB8W\x80c\xC0*\xE7T\x14a\x03\xB3W\x80c\xC1\xEBq7\x14a\x03\xAEW\x80c\xC3\xCD\xA5 \x14a\x03\xA9W\x80c\xD5\x05\xAC\xCF\x14a\x03\xA4W\x80c\xD5Gt\x1F\x14a\x03\x9FW\x80c\xDDb\xED>\x14a\x03\x9AW\x80c\xE3\xAB\xDF\xCB\x14a\x03\x95W\x80c\xE6:\xB1\xE9\x14a\x03\x90W\x80c\xF1\x12~\xD8\x14a\x03\x8BW\x80c\xF5\x08\xE1\x9D\x14a\x03\x86Wc\xF7^\x85\x12\x03a\0\x0EWa%\x0FV[a$\xABV[a$fV[a#\x83V[a#\x1FV[a\"\xBAV[a\"YV[a\"\x1FV[a!uV[a \xB9V[a \x84V[a OV[a \x16V[a\x1F\xA2V[a\x1FmV[a\x1E\xC3V[a\x1EOV[a\x1E\x1AV[a\x1D\xACV[a\x1DyV[a\x1C\xF7V[a\x1C\xC2V[a\x1C8V[a\x1B\xC9V[a\x1B[V[a\x1B&V[a\x1A\xAFV[a\x1AzV[a\x1AEV[a\x19\xD7V[a\x19\xA2V[a\x19?V[a\x19\nV[a\x18\x93V[a\x18WV[a\x17\x12V[a\x16\xDDV[a\x16\xA4V[a\x16\"V[a\x15\xDEV[a\x15\xA9V[a\x15tV[a\x15\x14V[a\x14\xB0V[a\x14<V[a\x14\x07V[a\x13\xD2V[a\x13fV[a\x133V[a\x12\xFEV[a\x12\xC9V[a\x12rV[a\x12=V[a\x12\x08V[a\x11\xC0V[a\x10\xABV[a\x10xV[a\x10BV[a\x10\x0EV[a\x0F\xD9V[a\x0F\xA6V[a\x0FqV[a\x0E\x84V[a\x0E(V[a\r\xC8V[a\r\x93V[a\x0C\xF8V[a\x0B)V[a\n\xBBV[a\nbV[a\t\xF3V[a\t\x81V[a\tLV[a\t\x18V[a\x08]V[a\x07\xE7V[a\x07/V[a\x06GV[a\x05\x98V[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x80\xFD[c\xFF\xFF\xFF\xFF`\xE0\x1B\x16\x90V[a\x059\x81a\x05$V[\x03a\x05@WV[_\x80\xFD[\x90P5\x90a\x05Q\x82a\x050V[V[\x90` \x82\x82\x03\x12a\x05lWa\x05i\x91_\x01a\x05DV[\x90V[a\x05\x1CV[\x15\x15\x90V[a\x05\x7F\x90a\x05qV[\x90RV[\x91\x90a\x05\x96\x90_` \x85\x01\x94\x01\x90a\x05vV[V[4a\x05\xC8Wa\x05\xC4a\x05\xB3a\x05\xAE6`\x04a\x05SV[a%\xE1V[a\x05\xBBa\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[_\x91\x03\x12a\x05\xD7WV[a\x05\x1CV[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[`\x1F\x80\x19\x91\x01\x16\x90V[a\x06\x1Da\x06&` \x93a\x06+\x93a\x06\x14\x81a\x05\xDCV[\x93\x84\x80\x93a\x05\xE0V[\x95\x86\x91\x01a\x05\xE9V[a\x05\xF4V[\x01\x90V[a\x06D\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x05\xFEV[\x90V[4a\x06wWa\x06W6`\x04a\x05\xCDV[a\x06sa\x06ba&\xFFV[a\x06ja\x05\x12V[\x91\x82\x91\x82a\x06/V[\x03\x90\xF3[a\x05\x18V[`\x01\x80`\xA0\x1B\x03\x16\x90V[\x90V[a\x06\x9Ea\x06\x99a\x06\xA3\x92a\x06|V[a\x06\x87V[a\x06|V[\x90V[a\x06\xAF\x90a\x06\x8AV[\x90V[a\x06\xBB\x90a\x06\xA6V[\x90V[a\x06\xC7\x90a\x06\xB2V[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[a\x06\xF7a\x07\0` \x93a\x07\x05\x93a\x06\xEE\x81a\x06\xCBV[\x93\x84\x80\x93a\x06\xCFV[\x95\x86\x91\x01a\x05\xE9V[a\x05\xF4V[\x01\x90V[\x91a\x07,\x92a\x07\x1F`@\x82\x01\x93_\x83\x01\x90a\x06\xBEV[` \x81\x84\x03\x91\x01Ra\x06\xD8V[\x90V[4a\x07`Wa\x07?6`\x04a\x05\xCDV[a\x07Ga'KV[\x90a\x07\\a\x07Sa\x05\x12V[\x92\x83\x92\x83a\x07\tV[\x03\x90\xF3[a\x05\x18V[a\x07n\x90a\x06|V[\x90V[a\x07z\x81a\x07eV[\x03a\x07\x81WV[_\x80\xFD[\x90P5\x90a\x07\x92\x82a\x07qV[V[\x90V[a\x07\xA0\x81a\x07\x94V[\x03a\x07\xA7WV[_\x80\xFD[\x90P5\x90a\x07\xB8\x82a\x07\x97V[V[\x91\x90`@\x83\x82\x03\x12a\x07\xE2W\x80a\x07\xD6a\x07\xDF\x92_\x86\x01a\x07\x85V[\x93` \x01a\x07\xABV[\x90V[a\x05\x1CV[4a\x08\x18Wa\x08\x14a\x08\x03a\x07\xFD6`\x04a\x07\xBAV[\x90a'uV[a\x08\x0Ba\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[\x90` \x82\x82\x03\x12a\x086Wa\x083\x91_\x01a\x07\x85V[\x90V[a\x05\x1CV[a\x08D\x90a\x07\x94V[\x90RV[\x91\x90a\x08[\x90_` \x85\x01\x94\x01\x90a\x08;V[V[4a\x08\x8DWa\x08\x89a\x08xa\x08s6`\x04a\x08\x1DV[a'\x9BV[a\x08\x80a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x08\xD8W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x08\xD3W` \x01\x92`\x01\x83\x02\x84\x01\x11a\x08\xCEWV[a\x08\x9AV[a\x08\x96V[a\x08\x92V[\x90` \x82\x82\x03\x12a\t\x0EW_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\t\tWa\t\x05\x92\x01a\x08\x9EV[\x90\x91V[a\x05 V[a\x05\x1CV[_\x01\x90V[4a\tGWa\t1a\t+6`\x04a\x08\xDDV[\x90a*\x8CV[a\t9a\x05\x12V[\x80a\tC\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\t|Wa\t\\6`\x04a\x05\xCDV[a\txa\tga*\x98V[a\toa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\t\xAFWa\t\x916`\x04a\x05\xCDV[a\t\x99a,dV[a\t\xA1a\x05\x12V[\x80a\t\xAB\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[\x1C\x90V[`\xFF\x16\x90V[a\t\xCE\x90`\x08a\t\xD3\x93\x02a\t\xB4V[a\t\xB8V[\x90V[\x90a\t\xE1\x91Ta\t\xBEV[\x90V[a\t\xF0`@_\x90a\t\xD6V[\x90V[4a\n#Wa\n\x036`\x04a\x05\xCDV[a\n\x1Fa\n\x0Ea\t\xE4V[a\n\x16a\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[\x90\x91``\x82\x84\x03\x12a\n]Wa\nZa\nC\x84_\x85\x01a\x07\x85V[\x93a\nQ\x81` \x86\x01a\x07\x85V[\x93`@\x01a\x07\xABV[\x90V[a\x05\x1CV[4a\n\x93Wa\n\x8Fa\n~a\nx6`\x04a\n(V[\x91a,nV[a\n\x86a\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[\x91` a\n\xB9\x92\x94\x93a\n\xB2`@\x82\x01\x96_\x83\x01\x90a\x08;V[\x01\x90a\x08;V[V[4a\n\xECWa\n\xD3a\n\xCE6`\x04a\x08\x1DV[a-\x9FV[\x90a\n\xE8a\n\xDFa\x05\x12V[\x92\x83\x92\x83a\n\x98V[\x03\x90\xF3[a\x05\x18V[\x90V[a\x0B\x08a\x0B\x03a\x0B\r\x92a\n\xF1V[a\x06\x87V[a\x07\x94V[\x90V[a\x0B\x1Ba\x0E\x10a\n\xF4V[\x90V[a\x0B&a\x0B\x10V[\x90V[4a\x0BYWa\x0B96`\x04a\x05\xCDV[a\x0BUa\x0BDa\x0B\x1EV[a\x0BLa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x0B\xA5W[` \x83\x10\x14a\x0B\xA0WV[a\x0BqV[\x91`\x7F\x16\x91a\x0B\x95V[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x0B\xDBa\x0B\xD4\x83a\x0B\x85V[\x80\x94a\x0B\xAFV[\x91`\x01\x81\x16\x90\x81_\x14a\x0C2WP`\x01\x14a\x0B\xF6W[PPPV[a\x0C\x03\x91\x92\x93\x94Pa\x0B\xB8V[\x91_\x92[\x81\x84\x10a\x0C\x1AWPP\x01\x90_\x80\x80a\x0B\xF1V[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x0C\x07V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x0B\xF1V[\x90a\x0CW\x91a\x0B\xC1V[\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x0Cx\x90a\x05\xF4V[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x0C\x92W`@RV[a\x0CZV[\x90a\x0C\xB7a\x0C\xB0\x92a\x0C\xA7a\x05\x12V[\x93\x84\x80\x92a\x0CMV[\x03\x83a\x0CnV[V[\x90_\x10a\x0C\xCCWa\x0C\xC9\x90a\x0C\x97V[\x90V[a\x0B^V[a\x0C\xDD`E_\x90a\x0C\xB9V[\x90V[a\x0C\xF5\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x06\xD8V[\x90V[4a\r(Wa\r\x086`\x04a\x05\xCDV[a\r$a\r\x13a\x0C\xD1V[a\r\x1Ba\x05\x12V[\x91\x82\x91\x82a\x0C\xE0V[\x03\x90\xF3[a\x05\x18V[\x90V[a\r9\x81a\r-V[\x03a\r@WV[_\x80\xFD[\x90P5\x90a\rQ\x82a\r0V[V[\x90` \x82\x82\x03\x12a\rlWa\ri\x91_\x01a\rDV[\x90V[a\x05\x1CV[a\rz\x90a\r-V[\x90RV[\x91\x90a\r\x91\x90_` \x85\x01\x94\x01\x90a\rqV[V[4a\r\xC3Wa\r\xBFa\r\xAEa\r\xA96`\x04a\rSV[a/\xC0V[a\r\xB6a\x05\x12V[\x91\x82\x91\x82a\r~V[\x03\x90\xF3[a\x05\x18V[4a\r\xF6Wa\r\xD86`\x04a\x05\xCDV[a\r\xE0a4\xBEV[a\r\xE8a\x05\x12V[\x80a\r\xF2\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[\x91\x90`@\x83\x82\x03\x12a\x0E#W\x80a\x0E\x17a\x0E \x92_\x86\x01a\rDV[\x93` \x01a\x07\x85V[\x90V[a\x05\x1CV[4a\x0EWWa\x0EAa\x0E;6`\x04a\r\xFBV[\x90a4\xF2V[a\x0EIa\x05\x12V[\x80a\x0ES\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[`\xFF\x16\x90V[a\x0Ek\x90a\x0E\\V[\x90RV[\x91\x90a\x0E\x82\x90_` \x85\x01\x94\x01\x90a\x0EbV[V[4a\x0E\xB4Wa\x0E\x946`\x04a\x05\xCDV[a\x0E\xB0a\x0E\x9Fa5!V[a\x0E\xA7a\x05\x12V[\x91\x82\x91\x82a\x0EoV[\x03\x90\xF3[a\x05\x18V[\x90` \x82\x82\x03\x12a\x0E\xD2Wa\x0E\xCF\x91_\x01a\x07\xABV[\x90V[a\x05\x1CV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[P`0\x90V[\x90V[a\x0E\xFD\x81a\x0E\xEBV[\x82\x10\x15a\x0F\x17Wa\x0F\x0F`\x01\x91a\x0E\xF1V[\x91\x02\x01\x90_\x90V[a\x0E\xD7V[\x90V[a\x0F/\x90`\x08a\x0F4\x93\x02a\t\xB4V[a\x0F\x1CV[\x90V[\x90a\x0FB\x91Ta\x0F\x1FV[\x90V[`\x10a\x0FP\x81a\x0E\xEBV[\x82\x10\x15a\x0FmWa\x0Fj\x91a\x0Fd\x91a\x0E\xF4V[\x90a\x0F7V[\x90V[_\x80\xFD[4a\x0F\xA1Wa\x0F\x9Da\x0F\x8Ca\x0F\x876`\x04a\x0E\xB9V[a\x0FEV[a\x0F\x94a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x0F\xD4Wa\x0F\xB66`\x04a\x05\xCDV[a\x0F\xBEa5\xD2V[a\x0F\xC6a\x05\x12V[\x80a\x0F\xD0\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\x10\tWa\x0F\xE96`\x04a\x05\xCDV[a\x10\x05a\x0F\xF4a5\xDCV[a\x0F\xFCa\x05\x12V[\x91\x82\x91\x82a\r~V[\x03\x90\xF3[a\x05\x18V[4a\x10=Wa\x10'a\x10!6`\x04a\r\xFBV[\x90a5\xF0V[a\x10/a\x05\x12V[\x80a\x109\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\x10sWa\x10oa\x10^a\x10X6`\x04a\x07\xBAV[\x90a6mV[a\x10fa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x10\xA6Wa\x10\x886`\x04a\x05\xCDV[a\x10\x90a6\xCBV[a\x10\x98a\x05\x12V[\x80a\x10\xA2\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\x10\xDAWa\x10\xC4a\x10\xBE6`\x04a\x07\xBAV[\x90a8(V[a\x10\xCCa\x05\x12V[\x80a\x10\xD6\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[a\x10\xE8\x90a\x06\xA6V[\x90V[\x90a\x10\xF5\x90a\x10\xDFV[_R` R`@_ \x90V[_\x1C\x90V[a\x11\x12a\x11\x17\x91a\x11\x01V[a\x0F\x1CV[\x90V[a\x11$\x90Ta\x11\x06V[\x90V[a\x112\x90`\ra\x10\xEBV[a\x11=_\x82\x01a\x11\x1AV[\x91a\x11J`\x01\x83\x01a\x11\x1AV[\x91a\x11W`\x02\x82\x01a\x11\x1AV[\x91a\x11p`\x04a\x11i`\x03\x85\x01a\x11\x1AV[\x93\x01a\x11\x1AV[\x90V[\x90\x95\x94\x92a\x11\xBE\x94a\x11\xADa\x11\xB7\x92a\x11\xA3`\x80\x96a\x11\x99`\xA0\x88\x01\x9C_\x89\x01\x90a\x08;V[` \x87\x01\x90a\x08;V[`@\x85\x01\x90a\x08;V[``\x83\x01\x90a\x08;V[\x01\x90a\x08;V[V[4a\x11\xF4Wa\x11\xF0a\x11\xDBa\x11\xD66`\x04a\x08\x1DV[a\x11'V[\x91a\x11\xE7\x95\x93\x95a\x05\x12V[\x95\x86\x95\x86a\x11sV[\x03\x90\xF3[a\x05\x18V[a\x12\x05`A_\x90a\x0F7V[\x90V[4a\x128Wa\x12\x186`\x04a\x05\xCDV[a\x124a\x12#a\x11\xF9V[a\x12+a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x12mWa\x12M6`\x04a\x05\xCDV[a\x12ia\x12Xa84V[a\x12`a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x12\xA2Wa\x12\x826`\x04a\x05\xCDV[a\x12\x9Ea\x12\x8Da8\xF5V[a\x12\x95a\x05\x12V[\x91\x82\x91\x82a\x06/V[\x03\x90\xF3[a\x05\x18V[a\x12\xB0\x90a\x07eV[\x90RV[\x91\x90a\x12\xC7\x90_` \x85\x01\x94\x01\x90a\x12\xA7V[V[4a\x12\xF9Wa\x12\xF5a\x12\xE4a\x12\xDF6`\x04a\x08\x1DV[a9\x91V[a\x12\xECa\x05\x12V[\x91\x82\x91\x82a\x12\xB4V[\x03\x90\xF3[a\x05\x18V[4a\x13.Wa\x13\x0E6`\x04a\x05\xCDV[a\x13*a\x13\x19a9\xB0V[a\x13!a\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[4a\x13aWa\x13Ka\x13F6`\x04a\x08\x1DV[a9\xD9V[a\x13Sa\x05\x12V[\x80a\x13]\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\x13\x96Wa\x13v6`\x04a\x05\xCDV[a\x13\x92a\x13\x81a9\xECV[a\x13\x89a\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[\x90V[a\x13\xB2a\x13\xADa\x13\xB7\x92a\x13\x9BV[a\x06\x87V[a\x07\x94V[\x90V[a\x13\xC4`0a\x13\x9EV[\x90V[a\x13\xCFa\x13\xBAV[\x90V[4a\x14\x02Wa\x13\xE26`\x04a\x05\xCDV[a\x13\xFEa\x13\xEDa\x13\xC7V[a\x13\xF5a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x147Wa\x143a\x14\"a\x14\x1D6`\x04a\x08\x1DV[a:\x02V[a\x14*a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x14jWa\x14L6`\x04a\x05\xCDV[a\x14Ta:\xB9V[a\x14\\a\x05\x12V[\x80a\x14f\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[\x90V[a\x14\x86a\x14\x81a\x14\x8B\x92a\x14oV[a\x06\x87V[a\x07\x94V[\x90V[a\x14\xA2jR\xB7\xD2\xDC\xC8\x0C\xD2\xE4\0\0\0a\x14rV[\x90V[a\x14\xADa\x14\x8EV[\x90V[4a\x14\xE0Wa\x14\xC06`\x04a\x05\xCDV[a\x14\xDCa\x14\xCBa\x14\xA5V[a\x14\xD3a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x90a\x14\xEF\x90a\x10\xDFV[_R` R`@_ \x90V[a\x15\x11\x90a\x15\x0C`\x0E\x91_\x92a\x14\xE5V[a\t\xD6V[\x90V[4a\x15DWa\x15@a\x15/a\x15*6`\x04a\x08\x1DV[a\x14\xFBV[a\x157a\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[c\xFF\xFF\xFF\xFF\x16\x90V[a\x15[\x90a\x15IV[\x90RV[\x91\x90a\x15r\x90_` \x85\x01\x94\x01\x90a\x15RV[V[4a\x15\xA4Wa\x15\xA0a\x15\x8Fa\x15\x8A6`\x04a\x08\x1DV[a:\xC7V[a\x15\x97a\x05\x12V[\x91\x82\x91\x82a\x15_V[\x03\x90\xF3[a\x05\x18V[4a\x15\xD9Wa\x15\xD5a\x15\xC4a\x15\xBF6`\x04a\x08\x1DV[a:\xF2V[a\x15\xCCa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x16\x0EWa\x16\na\x15\xF9a\x15\xF46`\x04a\x08\x1DV[a;\x10V[a\x16\x01a\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[a\x16\x1F`B_\x90a\x0F7V[\x90V[4a\x16RWa\x1626`\x04a\x05\xCDV[a\x16Na\x16=a\x16\x13V[a\x16Ea\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x90\x95\x94\x92a\x16\xA2\x94a\x16\x91a\x16\x9B\x92a\x16\x87`\x80\x96a\x16}`\xA0\x88\x01\x9C_\x89\x01\x90a\x05vV[` \x87\x01\x90a\x08;V[`@\x85\x01\x90a\x08;V[``\x83\x01\x90a\x08;V[\x01\x90a\x08;V[V[4a\x16\xD8Wa\x16\xD4a\x16\xBFa\x16\xBA6`\x04a\x08\x1DV[a;/V[\x91a\x16\xCB\x95\x93\x95a\x05\x12V[\x95\x86\x95\x86a\x16WV[\x03\x90\xF3[a\x05\x18V[4a\x17\rWa\x17\ta\x16\xF8a\x16\xF36`\x04a\x08\x1DV[a<\x9FV[a\x17\0a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x17@Wa\x17\"6`\x04a\x05\xCDV[a\x17*a<\xD8V[a\x172a\x05\x12V[\x80a\x17<\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[`\xFF`\xF8\x1B\x16\x90V[a\x17W\x90a\x17EV[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[` \x01\x90V[a\x17w\x90a\x07\x94V[\x90RV[\x90a\x17\x88\x81` \x93a\x17nV[\x01\x90V[` \x01\x90V[\x90a\x17\xAFa\x17\xA9a\x17\xA2\x84a\x17[V[\x80\x93a\x17_V[\x92a\x17hV[\x90_[\x81\x81\x10a\x17\xBFWPPP\x90V[\x90\x91\x92a\x17\xD8a\x17\xD2`\x01\x92\x86Qa\x17{V[\x94a\x17\x8CV[\x91\x01\x91\x90\x91a\x17\xB2V[\x93\x95\x91\x94a\x183a\x18(a\x18G\x95a\x18\x1Aa\x18=\x95a\x18T\x9C\x9Aa\x18\r`\xE0\x8C\x01\x92_\x8D\x01\x90a\x17NV[\x8A\x82\x03` \x8C\x01Ra\x05\xFEV[\x90\x88\x82\x03`@\x8A\x01Ra\x05\xFEV[\x97``\x87\x01\x90a\x08;V[`\x80\x85\x01\x90a\x12\xA7V[`\xA0\x83\x01\x90a\rqV[`\xC0\x81\x84\x03\x91\x01Ra\x17\x92V[\x90V[4a\x18\x8EWa\x18g6`\x04a\x05\xCDV[a\x18\x8Aa\x18ra=_V[\x93a\x18\x81\x97\x95\x97\x93\x91\x93a\x05\x12V[\x97\x88\x97\x88a\x17\xE2V[\x03\x90\xF3[a\x05\x18V[4a\x18\xC3Wa\x18\xBFa\x18\xAEa\x18\xA96`\x04a\x0E\xB9V[a=\xE9V[a\x18\xB6a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x90V[a\x18\xDFa\x18\xDAa\x18\xE4\x92a\x18\xC8V[a\x06\x87V[a\x07\x94V[\x90V[a\x18\xFCk\x03;.<\x9F\xD0\x80<\xE8\0\0\0a\x18\xCBV[\x90V[a\x19\x07a\x18\xE7V[\x90V[4a\x19:Wa\x19\x1A6`\x04a\x05\xCDV[a\x196a\x19%a\x18\xFFV[a\x19-a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x19pWa\x19la\x19[a\x19U6`\x04a\r\xFBV[\x90a>\x1AV[a\x19ca\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x19\x89\x90a\x19uV[\x90RV[\x91\x90a\x19\xA0\x90_` \x85\x01\x94\x01\x90a\x19\x80V[V[4a\x19\xD2Wa\x19\xB26`\x04a\x05\xCDV[a\x19\xCEa\x19\xBDa>HV[a\x19\xC5a\x05\x12V[\x91\x82\x91\x82a\x19\x8DV[\x03\x90\xF3[a\x05\x18V[4a\x1A\x07Wa\x19\xE76`\x04a\x05\xCDV[a\x1A\x03a\x19\xF2a>\\V[a\x19\xFAa\x05\x12V[\x91\x82\x91\x82a\x06/V[\x03\x90\xF3[a\x05\x18V[\x90V[a\x1A#a\x1A\x1Ea\x1A(\x92a\x1A\x0CV[a\x06\x87V[a\x07\x94V[\x90V[a\x1A7b\x01Q\x80a\x1A\x0FV[\x90V[a\x1ABa\x1A+V[\x90V[4a\x1AuWa\x1AU6`\x04a\x05\xCDV[a\x1Aqa\x1A`a\x1A:V[a\x1Aha\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x1A\xAAWa\x1A\xA6a\x1A\x95a\x1A\x906`\x04a\x08\x1DV[a>rV[a\x1A\x9Da\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x1A\xDFWa\x1A\xDBa\x1A\xCAa\x1A\xC56`\x04a\x08\x1DV[a>\xCDV[a\x1A\xD2a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x90V[a\x1A\xFBa\x1A\xF6a\x1B\0\x92a\x1A\xE4V[a\x06\x87V[a\x07\x94V[\x90V[a\x1B\x18k\x02\xE8vi\xC3\x08sj\x04\0\0\0a\x1A\xE7V[\x90V[a\x1B#a\x1B\x03V[\x90V[4a\x1BVWa\x1B66`\x04a\x05\xCDV[a\x1BRa\x1BAa\x1B\x1BV[a\x1BIa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x1B\x8AWa\x1Bta\x1Bn6`\x04a\x07\xBAV[\x90a@OV[a\x1B|a\x05\x12V[\x80a\x1B\x86\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[\x90\x91``\x82\x84\x03\x12a\x1B\xC4Wa\x1B\xC1a\x1B\xAA\x84_\x85\x01a\x07\x85V[\x93a\x1B\xB8\x81` \x86\x01a\x07\xABV[\x93`@\x01a\x07\xABV[\x90V[a\x05\x1CV[4a\x1B\xF8Wa\x1B\xE2a\x1B\xDC6`\x04a\x1B\x8FV[\x91aB\xD5V[a\x1B\xEAa\x05\x12V[\x80a\x1B\xF4\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[\x90V[_\x1B\x90V[a\x1C\x19a\x1C\x14a\x1C\x1E\x92a\x1B\xFDV[a\x1C\0V[a\r-V[\x90V[a\x1C*_a\x1C\x05V[\x90V[a\x1C5a\x1C!V[\x90V[4a\x1ChWa\x1CH6`\x04a\x05\xCDV[a\x1Cda\x1CSa\x1C-V[a\x1C[a\x05\x12V[\x91\x82\x91\x82a\r~V[\x03\x90\xF3[a\x05\x18V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x1C\x88\x90`\x08a\x1C\x8D\x93\x02a\t\xB4V[a\x1CmV[\x90V[\x90a\x1C\x9B\x91Ta\x1CxV[\x90V[a\x1C\xAA`D_\x90a\x1C\x90V[\x90V[\x91\x90a\x1C\xC0\x90_` \x85\x01\x94\x01\x90a\x06\xBEV[V[4a\x1C\xF2Wa\x1C\xD26`\x04a\x05\xCDV[a\x1C\xEEa\x1C\xDDa\x1C\x9EV[a\x1C\xE5a\x05\x12V[\x91\x82\x91\x82a\x1C\xADV[\x03\x90\xF3[a\x05\x18V[4a\x1D'Wa\x1D\x076`\x04a\x05\xCDV[a\x1D#a\x1D\x12aB\xE2V[a\x1D\x1Aa\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[a\x1D5\x90a\x07eV[\x90V[a\x1DA\x81a\x1D,V[\x03a\x1DHWV[_\x80\xFD[\x90P5\x90a\x1DY\x82a\x1D8V[V[\x90` \x82\x82\x03\x12a\x1DtWa\x1Dq\x91_\x01a\x1DLV[\x90V[a\x05\x1CV[4a\x1D\xA7Wa\x1D\x91a\x1D\x8C6`\x04a\x1D[V[aD9V[a\x1D\x99a\x05\x12V[\x80a\x1D\xA3\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\x1D\xDCWa\x1D\xBC6`\x04a\x05\xCDV[a\x1D\xD8a\x1D\xC7aDcV[a\x1D\xCFa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x90V[a\x1D\xF8a\x1D\xF3a\x1D\xFD\x92a\x1D\xE1V[a\x06\x87V[a\x07\x94V[\x90V[a\x1E\x0Cb'\x8D\0a\x1D\xE4V[\x90V[a\x1E\x17a\x1E\0V[\x90V[4a\x1EJWa\x1E*6`\x04a\x05\xCDV[a\x1EFa\x1E5a\x1E\x0FV[a\x1E=a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x1E\x80Wa\x1E|a\x1Eka\x1Ee6`\x04a\x07\xBAV[\x90aD\xDDV[a\x1Esa\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[\x90V[a\x1E\x9Ca\x1E\x97a\x1E\xA1\x92a\x1E\x85V[a\x06\x87V[a\x07\x94V[\x90V[a\x1E\xB5g\r\xE0\xB6\xB3\xA7d\0\0a\x1E\x88V[\x90V[a\x1E\xC0a\x1E\xA4V[\x90V[4a\x1E\xF3Wa\x1E\xD36`\x04a\x05\xCDV[a\x1E\xEFa\x1E\xDEa\x1E\xB8V[a\x1E\xE6a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[P`0\x90V[\x90P\x90V[\x90V[` \x01\x90V[a\x1F(a\x1F\"a\x1F\x1B\x83a\x1E\xF8V[\x80\x94a\x1E\xFEV[\x91a\x1F\x03V[_\x91[\x83\x83\x10a\x1F8WPPPPV[a\x1FNa\x1FH`\x01\x92\x84Qa\x17{V[\x92a\x1F\x06V[\x92\x01\x91\x90a\x1F+V[\x91\x90a\x1Fk\x90_a\x06\0\x85\x01\x94\x01\x90a\x1F\x0CV[V[4a\x1F\x9DWa\x1F}6`\x04a\x05\xCDV[a\x1F\x99a\x1F\x88aF\x04V[a\x1F\x90a\x05\x12V[\x91\x82\x91\x82a\x1FWV[\x03\x90\xF3[a\x05\x18V[4a\x1F\xD3Wa\x1F\xCFa\x1F\xBEa\x1F\xB86`\x04a\x07\xBAV[\x90aF\x1AV[a\x1F\xC6a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[a \ra \x14\x94a \x03``\x94\x98\x97\x95a\x1F\xF9`\x80\x86\x01\x9A_\x87\x01\x90a\x08;V[` \x85\x01\x90a\x08;V[`@\x83\x01\x90a\x08;V[\x01\x90a\x05vV[V[4a JWa &6`\x04a\x05\xCDV[a Fa 1aF0V[\x90a =\x94\x92\x94a\x05\x12V[\x94\x85\x94\x85a\x1F\xD8V[\x03\x90\xF3[a\x05\x18V[4a \x7FWa {a ja e6`\x04a\x08\x1DV[aH\x07V[a ra\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a \xB4Wa \x946`\x04a\x05\xCDV[a \xB0a \x9FaH\x1CV[a \xA7a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a \xE9Wa \xE5a \xD4a \xCF6`\x04a\x08\x1DV[aH0V[a \xDCa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[a \xF7\x81a\x0E\\V[\x03a \xFEWV[_\x80\xFD[\x90P5\x90a!\x0F\x82a \xEEV[V[\x90\x91`\xC0\x82\x84\x03\x12a!pWa!)\x83_\x84\x01a\x07\x85V[\x92a!7\x81` \x85\x01a\x07\xABV[\x92a!E\x82`@\x83\x01a\x07\xABV[\x92a!ma!V\x84``\x85\x01a!\x02V[\x93a!d\x81`\x80\x86\x01a\rDV[\x93`\xA0\x01a\rDV[\x90V[a\x05\x1CV[4a!\xAAWa!\x94a!\x886`\x04a!\x11V[\x94\x93\x90\x93\x92\x91\x92aH\xBAV[a!\x9Ca\x05\x12V[\x80a!\xA6\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[`\xE0\x81\x83\x03\x12a\"\x1AWa!\xC5\x82_\x83\x01a\x07\x85V[\x92a!\xD3\x83` \x84\x01a\x07\x85V[\x92a!\xE1\x81`@\x85\x01a\x07\xABV[\x92a!\xEF\x82``\x83\x01a\x07\xABV[\x92a\"\x17a\"\0\x84`\x80\x85\x01a!\x02V[\x93a\"\x0E\x81`\xA0\x86\x01a\rDV[\x93`\xC0\x01a\rDV[\x90V[a\x05\x1CV[4a\"TWa\">a\"26`\x04a!\xAFV[\x95\x94\x90\x94\x93\x91\x93aJ\x0EV[a\"Fa\x05\x12V[\x80a\"P\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\"\x88Wa\"ra\"l6`\x04a\r\xFBV[\x90aK,V[a\"za\x05\x12V[\x80a\"\x84\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[\x91\x90`@\x83\x82\x03\x12a\"\xB5W\x80a\"\xA9a\"\xB2\x92_\x86\x01a\x07\x85V[\x93` \x01a\x07\x85V[\x90V[a\x05\x1CV[4a\"\xEBWa\"\xE7a\"\xD6a\"\xD06`\x04a\"\x8DV[\x90aKNV[a\"\xDEa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x7Fk\x97%\xF7@\xF9K\x91\xB7\x80`\xA1\xB1}\x17tem8\x14!\xA5)\xEC\x98\xCD\xB0\x13\xF4\xD9\xC2^\x90V[a#\x1Ca\"\xF0V[\x90V[4a#OWa#/6`\x04a\x05\xCDV[a#Ka#:a#\x14V[a#Ba\x05\x12V[\x91\x82\x91\x82a\r~V[\x03\x90\xF3[a\x05\x18V[\x7Fe\xD7\xA2\x8E2e\xB3zdt\x92\x9F3e!\xB32\xC1h\x1B\x93?l\xB9\xF37fsD\r\x86*\x90V[a#\x80a#TV[\x90V[4a#\xB3Wa#\x936`\x04a\x05\xCDV[a#\xAFa#\x9Ea#xV[a#\xA6a\x05\x12V[\x91\x82\x91\x82a\r~V[\x03\x90\xF3[a\x05\x18V[a#\xC1\x81a\x15IV[\x03a#\xC8WV[_\x80\xFD[\x90P5\x90a#\xD9\x82a#\xB8V[V[\x91\x90`@\x83\x82\x03\x12a$\x03W\x80a#\xF7a$\0\x92_\x86\x01a\x07\x85V[\x93` \x01a#\xCCV[\x90V[a\x05\x1CV[a$\x11\x90a\x19uV[\x90RV[`\x01\x80`\xD0\x1B\x03\x16\x90V[a$)\x90a$\x15V[\x90RV[\x90` \x80a$O\x93a$E_\x82\x01Q_\x86\x01\x90a$\x08V[\x01Q\x91\x01\x90a$ V[V[\x91\x90a$d\x90_`@\x85\x01\x94\x01\x90a$-V[V[4a$\x97Wa$\x93a$\x82a$|6`\x04a#\xDBV[\x90aK\xBCV[a$\x8Aa\x05\x12V[\x91\x82\x91\x82a$QV[\x03\x90\xF3[a\x05\x18V[a$\xA8`C_\x90a\x0F7V[\x90V[4a$\xDBWa$\xBB6`\x04a\x05\xCDV[a$\xD7a$\xC6a$\x9CV[a$\xCEa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x7F\xCC\xE2\x96\xB0@3*\x08\x0Em\xF15\x15\xA3\xEC(i\xE2\x1C\xD2\x0FsD\xAF\t\x87\xDD\xB98\xD8\xBD!\x90V[a%\x0Ca$\xE0V[\x90V[4a%?Wa%\x1F6`\x04a\x05\xCDV[a%;a%*a%\x04V[a%2a\x05\x12V[\x91\x82\x91\x82a\r~V[\x03\x90\xF3[a\x05\x18V[_\x80\xFD[_\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a%la%r\x91a$\x15V[\x91a$\x15V[\x01\x90`\x01\x80`\xD0\x1B\x03\x82\x11a%\x83WV[a%LV[\x90a%\x9B\x91a%\x95a%HV[Pa%`V[\x90V[a%\xAAa%\xB0\x91a$\x15V[\x91a$\x15V[\x90\x03\x90`\x01\x80`\xD0\x1B\x03\x82\x11a%\xC2WV[a%LV[\x90a%\xDA\x91a%\xD4a%HV[Pa%\x9EV[\x90V[_\x90V[a%\xE9a%\xDDV[P\x80a&\x04a%\xFEcye\xDB\x0B`\xE0\x1Ba\x05$V[\x91a\x05$V[\x14\x90\x81\x15a&\x11W[P\x90V[a&\x1B\x91PaK\xD2V[_a&\rV[``\x90V[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a&Ra&K\x83a\x0B\x85V[\x80\x94a&&V[\x91`\x01\x81\x16\x90\x81_\x14a&\xA9WP`\x01\x14a&mW[PPPV[a&z\x91\x92\x93\x94Pa&/V[\x91_\x92[\x81\x84\x10a&\x91WPP\x01\x90_\x80\x80a&hV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a&~V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a&hV[\x90a&\xCE\x91a&8V[\x90V[\x90a&\xF1a&\xEA\x92a&\xE1a\x05\x12V[\x93\x84\x80\x92a&\xC4V[\x03\x83a\x0CnV[V[a&\xFC\x90a&\xD1V[\x90V[a'\x07a&!V[Pa'\x12`\x03a&\xF3V[\x90V[_\x90V[``\x90V[a'*a'/\x91a\x11\x01V[a\x1CmV[\x90V[a'<\x90Ta'\x1EV[\x90V[a'H\x90a\x0C\x97V[\x90V[a'Sa'\x15V[Pa'\\a'\x19V[Pa'g`Da'2V[\x90a'r`Ea'?V[\x90V[a'\x92\x91a'\x81a%\xDDV[Pa'\x8AaK\xF8V[\x91\x90\x91aL\x05V[`\x01\x90V[_\x90V[_a'\xB3a'\xB9\x92a'\xABa'\x97V[P`\ra\x10\xEBV[\x01a\x11\x1AV[\x90V[\x90a'\xD6\x91a'\xD1a'\xCCa$\xE0V[aL\x15V[a*6V[V[P\x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a(\x05\x91\x02\x91a'\xFF_\x19\x84a'\xE6V[\x92a'\xE6V[\x91\x81\x19\x16\x91\x16\x17\x90V[a(#a(\x1Ea((\x92a\x07\x94V[a\x06\x87V[a\x07\x94V[\x90V[\x90V[\x91\x90a(Da(?a(L\x93a(\x0FV[a(+V[\x90\x83Ta'\xEAV[\x90UV[a(b\x91a(\\a'\x97V[\x91a(.V[V[[\x81\x81\x10a(pWPPV[\x80a(}_`\x01\x93a(PV[\x01a(eV[\x91\x90`\x1F\x81\x11a(\x93W[PPPV[a(\x9Fa(\xC4\x93a\x0B\xB8V[\x90` a(\xAB\x84a'\xDCV[\x83\x01\x93\x10a(\xCCW[a(\xBD\x90a'\xDCV[\x01\x90a(dV[_\x80\x80a(\x8EV[\x91Pa(\xBD\x81\x92\x90Pa(\xB4V[\x90a(\xEA\x90_\x19\x90`\x08\x02a\t\xB4V[\x19\x16\x90V[\x81a(\xF9\x91a(\xDAV[\x90`\x02\x02\x17\x90V[\x91a)\x0C\x90\x82a'\xD8V[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a)\xCBWa)0\x82a)*\x85Ta\x0B\x85V[\x85a(\x83V[_\x90`\x1F\x83\x11`\x01\x14a)cW\x91\x80\x91a)R\x93_\x92a)WW[PPa(\xEFV[\x90U[V[\x90\x91P\x015_\x80a)KV[`\x1F\x19\x83\x16\x91a)r\x85a\x0B\xB8V[\x92_[\x81\x81\x10a)\xB3WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a)\x99W[PPP\x02\x01\x90Ua)UV[a)\xA9\x91\x015`\x1F\x84\x16\x90a(\xDAV[\x90U_\x80\x80a)\x8DV[\x91\x93` `\x01\x81\x92\x87\x87\x015\x81U\x01\x95\x01\x92\x01a)uV[a\x0CZV[\x90a)\xDB\x92\x91a)\x01V[V[\x90\x82_\x93\x92\x827\x01RV[\x91\x90a*\x02\x81a)\xFB\x81a*\x07\x95a\x06\xCFV[\x80\x95a)\xDDV[a\x05\xF4V[\x01\x90V[\x91a*%a*3\x94\x92`@\x85\x01\x90\x85\x82\x03_\x87\x01Ra\x06\xD8V[\x92` \x81\x85\x03\x91\x01Ra)\xE8V[\x90V[\x90a*A`Ea'?V[a*N\x83\x83\x90`Ea)\xD0V[\x91\x90\x91a*\x87\x7F\xB9\xA2\x08\x84&\xF0;0\xA8\x1C\x06B\x80\x94\xFB\xFA\x9E&\x92s\x9B2A\xAFk\x9A\xB1\xDAKUF\xBE\x93a*~a\x05\x12V[\x93\x84\x93\x84a*\x0BV[\x03\x90\xA1V[\x90a*\x96\x91a'\xBCV[V[a*\xA0a'\x97V[Pa*\xAB`\x02a\x11\x1AV[\x90V[a*\xBEa*\xB9a\"\xF0V[aL\x15V[a*\xC6a+\x87V[V[a*\xDCa*\xD7a*\xE1\x92a\x1B\xFDV[a\x06\x87V[a\x07\x94V[\x90V[a*\xF8a*\xF3a*\xFD\x92a\x1B\xFDV[a\x06\x87V[a\x06|V[\x90V[a+\t\x90a*\xE4V[\x90V[\x90a+\x18`\xFF\x91a\x1C\0V[\x91\x81\x19\x16\x91\x16\x17\x90V[a++\x90a\x05qV[\x90V[\x90V[\x90a+Fa+Aa+M\x92a+\"V[a+.V[\x82Ta+\x0CV[\x90UV[\x90a+]_\x19\x91a\x1C\0V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a+|a+wa+\x83\x92a(\x0FV[a(+V[\x82Ta+QV[\x90UV[a+\x91`Aa\x11\x1AV[a+\xA3a+\x9D_a*\xC8V[\x91a\x07\x94V[\x03a,HWa+\xBAa+\xB5`Da'2V[a\x06\xB2V[a+\xD4a+\xCEa+\xC9_a+\0V[a\x07eV[\x91a\x07eV[\x14a,,Wa+\xE5`\x01`@a+1V[a+\xF0B`Aa+gV[Ba,'\x7F\x11\x94\xB04\xCF\xA9\xABX\x07IJ\x1D\\f}\x8B\x0En\x97\xF3\x88\x88t*\xA3\x87\x1A2 4\x11`\x91a,\x1Ea\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xA1V[_c;\nH\xBD`\xE1\x1B\x81R\x80a,D`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c8\xE9=\xBD`\xE1\x1B\x81R\x80a,``\x04\x82\x01a\t\x13V[\x03\x90\xFD[a,la*\xAEV[V[\x91a,\x98\x92a,{a%\xDDV[Pa,\x90a,\x87aK\xF8V[\x82\x90\x84\x91aLiV[\x91\x90\x91aL\xF5V[`\x01\x90V[a,\xA6\x90a\x06\xA6V[\x90V[_\x80\xFD[`\xE0\x1B\x90V[\x90PQ\x90a,\xC0\x82a\x07\x97V[V[\x90` \x82\x82\x03\x12a,\xDBWa,\xD8\x91_\x01a,\xB3V[\x90V[a\x05\x1CV[a,\xE8a\x05\x12V[=_\x82>=\x90\xFD[a,\xFFa-\x05\x91\x93\x92\x93a\x07\x94V[\x92a\x07\x94V[\x82\x03\x91\x82\x11a-\x10WV[a%LV[\x90V[a-,a-'a-1\x92a-\x15V[a\x06\x87V[a\x07\x94V[\x90V[a-Ca-I\x91\x93\x92\x93a\x07\x94V[\x92a\x07\x94V[\x91a-U\x83\x82\x02a\x07\x94V[\x92\x81\x84\x04\x14\x90\x15\x17\x15a-dWV[a%LV[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[a-\x89a-\x8F\x91a\x07\x94V[\x91a\x07\x94V[\x90\x81\x15a-\x9AW\x04\x90V[a-iV[a-\xA7a'\x97V[\x91a-\xB0a'\x97V[\x91a-\xC7_a-\xC1`\r\x84\x90a\x10\xEBV[\x01a\x11\x1AV[\x90a-\xDF`\x02a-\xD9`\r\x84\x90a\x10\xEBV[\x01a\x11\x1AV[\x91a.\x18` a-\xEE0a,\x9DV[ce\x1F\xD2h\x90a.\r\x86\x92a.\x01a\x05\x12V[\x95\x86\x94\x85\x93\x84\x93a,\xADV[\x83R`\x04\x83\x01a\x12\xB4V[\x03\x91Z\xFA\x90\x81\x15a/qWa.c\x91` \x91_\x91a/DW[P\x93a.<0a,\x9DV[a.Xc\x99\x89U\xD3a.La\x05\x12V[\x95\x86\x94\x85\x93\x84\x93a,\xADV[\x83R`\x04\x83\x01a\x12\xB4V[\x03\x91Z\xFA\x90\x81\x15a/?W_\x91a/\x11W[P\x91\x81a.\x8Aa.\x84_a*\xC8V[\x91a\x07\x94V[\x11a.\xE0W[PP\x81a.\xA5a.\x9F_a*\xC8V[\x91a\x07\x94V[\x11a.\xAFW[PPV[a.\xD8\x92\x93Pa.\xC2a.\xD3\x91\x83a,\xF0V[a.\xCDa'\x10a-\x18V[\x90a-4V[a-}V[\x90_\x80a.\xABV[a/\t\x92\x96Pa.\xF3a/\x04\x91\x83a,\xF0V[a.\xFEa'\x10a-\x18V[\x90a-4V[a-}V[\x93_\x80a.\x90V[a/2\x91P` =\x81\x11a/8W[a/*\x81\x83a\x0CnV[\x81\x01\x90a,\xC2V[_a.uV[P=a/ V[a,\xE0V[a/d\x91P\x82=\x81\x11a/jW[a/\\\x81\x83a\x0CnV[\x81\x01\x90a,\xC2V[_a.1V[P=a/RV[a,\xE0V[_\x90V[a/\x83\x90a\r-V[\x90V[\x90a/\x90\x90a/zV[_R` R`@_ \x90V[\x90V[a/\xABa/\xB0\x91a\x11\x01V[a/\x9CV[\x90V[a/\xBD\x90Ta/\x9FV[\x90V[`\x01a/\xD9a/\xDF\x92a/\xD1a/vV[P`\x05a/\x86V[\x01a/\xB3V[\x90V[a/\xEAaM\x92V[a/\xF2a/\xF4V[V[a/\xFCaM\xE8V[a0\x04a0\x0EV[a0\x0CaNMV[V[a0\x1Ea0\x19a\"\xF0V[aL\x15V[a0&a1XV[V[a04a09\x91a\x11\x01V[a\t\xB8V[\x90V[a0F\x90Ta0(V[\x90V[`\x01a0U\x91\x01a\x07\x94V[\x90V[a0ga0m\x91\x93\x92\x93a\x07\x94V[\x92a\x07\x94V[\x82\x01\x80\x92\x11a0xWV[a%LV[a0\x86\x90a\x06\xA6V[\x90V[_\x91\x03\x12a0\x93WV[a\x05\x1CV[\x90_\x92\x91\x80T\x90a0\xB2a0\xAB\x83a\x0B\x85V[\x80\x94a\x06\xCFV[\x91`\x01\x81\x16\x90\x81_\x14a1\tWP`\x01\x14a0\xCDW[PPPV[a0\xDA\x91\x92\x93\x94Pa\x0B\xB8V[\x91_\x92[\x81\x84\x10a0\xF1WPP\x01\x90_\x80\x80a0\xC8V[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a0\xDEV[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a0\xC8V[a1Ha1U\x94\x92\x93a1>``\x84\x01\x95_\x85\x01\x90a\x12\xA7V[` \x83\x01\x90a\x08;V[`@\x81\x84\x03\x91\x01Ra0\x98V[\x90V[a1ka1e`@a0<V[\x15a\x05qV[a4\xA2Wa1waB\xE2V[a4\x86Wa1\xA0a1\x92Ba1\x8C`Aa\x11\x1AV[\x90a,\xF0V[a1\x9Aa\x1E\0V[\x90a-}V[Ba1\xCBa1\xC5a1\xC0a1\xB2aDcV[a1\xBAa\x0B\x10V[\x90a,\xF0V[a\x07\x94V[\x91a\x07\x94V[\x10a4jWa1\xE4\x90a1\xDE`Ba\x11\x1AV[\x90a,\xF0V[\x90\x81a2\x12a2\x0Ca2\x07a1\xF7a\x13\xBAV[a2\x01`Ba\x11\x1AV[\x90a,\xF0V[a\x07\x94V[\x91a\x07\x94V[\x11a4GW[a2!_a*\xC8V[\x90a2+_a*\xC8V[\x91[\x82a2@a2:\x86a\x07\x94V[\x91a\x07\x94V[\x10\x15a2\x87Wa2{a2\x81\x91a2ua2o`\x10a2ia2b`Ba\x11\x1AV[\x89\x90a0XV[\x90a\x0E\xF4V[\x90a\x0F7V[\x90a0XV[\x92a0IV[\x91a2-V[\x91P\x91a2\x9Ea2\x97`Ca\x11\x1AV[\x83\x90a0XV[a2\xB7a2\xB1a2\xACa\x14\x8EV[a\x07\x94V[\x91a\x07\x94V[\x11a4+Wa2\xD2a2\xD9\x91a2\xCD`Ba\x11\x1AV[a0XV[`Ba+gV[a2\xF6a2\xEF\x82a2\xEA`Ca\x11\x1AV[a0XV[`Ca+gV[a3\ta3\x020a0}V[\x82\x90aNaV[a3.a3\x150a0}V[a3'a3\"`Da'2V[a\x06\xB2V[\x83\x91aL\x05V[a3@a3;`Da'2V[a\x06\xB2V[c\x18\xB6\x8B\x8Ca3N0a0}V[\x83\x92`E\x92\x81;\x15a4&W_a3x\x91a3\x83\x82\x96a3la\x05\x12V[\x98\x89\x97\x88\x96\x87\x95a,\xADV[\x85R`\x04\x85\x01a1$V[\x03\x92Z\xF1\x80\x15a4!Wa3\xF5W[Pa3\x9D`Ba\x11\x1AV[\x90a3\xB0a3\xAB`Da'2V[a\x06\xB2V[\x90a3\xDB\x7F4\xB7=\x0C\x96\xE9\xFFMS\x11CH\x17\xC8\xEC\xC90\xE7\xD2x,[\xDE.y\xDCD\xB0YgU\xBB\x92a\x10\xDFV[\x92a3\xF0a3\xE7a\x05\x12V[\x92\x83\x92\x83a\n\x98V[\x03\x90\xA2V[a4\x14\x90_=\x81\x11a4\x1AW[a4\x0C\x81\x83a\x0CnV[\x81\x01\x90a0\x89V[_a3\x92V[P=a4\x02V[a,\xE0V[a,\xA9V[_c#\x06N\xBD`\xE0\x1B\x81R\x80a4C`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x90Pa4da4Ta\x13\xBAV[a4^`Ba\x11\x1AV[\x90a,\xF0V[\x90a2\x18V[_c=S\xC7S`\xE0\x1B\x81R\x80a4\x82`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c\x11UbK`\xE2\x1B\x81R\x80a4\x9E`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c\x19\xAF\xC9\x9D`\xE2\x1B\x81R\x80a4\xBA`\x04\x82\x01a\t\x13V[\x03\x90\xFD[a4\xC6a/\xE2V[V[\x90a4\xE3\x91a4\xDEa4\xD9\x82a/\xC0V[aL\x15V[a4\xE5V[V[\x90a4\xEF\x91aN\xBFV[PV[\x90a4\xFC\x91a4\xC8V[V[_\x90V[\x90V[a5\x19a5\x14a5\x1E\x92a5\x02V[a\x06\x87V[a\x0E\\V[\x90V[a5)a4\xFEV[Pa54`\x12a5\x05V[\x90V[a5Ga5Ba\"\xF0V[aL\x15V[a5Oa5QV[V[a5[`Aa\x11\x1AV[a5ma5g_a*\xC8V[\x91a\x07\x94V[\x14a5\xB6Wa5~`\x01`@a+1V[\x7FJy*\x0B\xE4+Vr\xFA\xA4\x01)\xFCdi\x07$\x90w\\\xA8\xD3\xC3N\x85-MU\xD3\xA75\xA9a5\xA7a\x05\x12V[\x80a5\xB1\x81a\t\x13V[\x03\x90\xA1V[_c\x8F\x98@A`\xE0\x1B\x81R\x80a5\xCE`\x04\x82\x01a\t\x13V[\x03\x90\xFD[a5\xDAa57V[V[a5\xE4a/vV[Pa5\xEDaOkV[\x90V[\x90\x80a6\x0Ba6\x05a6\0aK\xF8V[a\x07eV[\x91a\x07eV[\x03a6\x1CWa6\x19\x91aP%V[PV[_c3K\xD9\x19`\xE1\x1B\x81R\x80a64`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x90a6B\x90a\x10\xDFV[_R` R`@_ \x90V[\x90V[a6ea6`a6j\x92a$\x15V[a\x06\x87V[a\x07\x94V[\x90V[a6\xA4\x91a6\x99a6\x93a6\x8Ea6\x9F\x94a6\x86a'\x97V[P`\na68V[a6NV[\x91aQ\x06V[\x90aQ\xFCV[a6QV[\x90V[a6\xB7a6\xB2a\x1C!V[aL\x15V[a6\xBFa6\xC1V[V[a6\xC9aS\x83V[V[a6\xD3a6\xA7V[V[\x90a6\xE7\x91a6\xE2aM\xE8V[a6\xF1V[a6\xEFaNMV[V[\x90\x81a7\ra7\x07a7\x02_a+\0V[a\x07eV[\x91a\x07eV[\x14a8\x0CW\x80a7%a7\x1F_a*\xC8V[\x91a\x07\x94V[\x14a7\xF0Wa7Ga7Aa7<`\x0E3\x90a\x14\xE5V[a0<V[\x15a\x05qV[a7\xD4Wa7T3aS\x90V[a7k`\x01a7e`\r3\x90a\x10\xEBV[\x01a\x11\x1AV[a7}a7w\x83a\x07\x94V[\x91a\x07\x94V[\x10a7\xB8Wa7\xB6\x91a7\xB1\x82a7\xAB`\x01a7\x9B`\r3\x90a\x10\xEBV[\x01\x91a7\xA6\x83a\x11\x1AV[a,\xF0V[\x90a+gV[aNaV[V[_c\x1C\x95\x9E\xD9`\xE2\x1B\x81R\x80a7\xD0`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_cD\x17v\t`\xE1\x1B\x81R\x80a7\xEC`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a8\x08`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a8$`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x90a82\x91a6\xD5V[V[a8<a'\x97V[Pa8Xa8Ha\x14\x8EV[a8R`Ca\x11\x1AV[\x90a,\xF0V[\x90V[\x90a8na8ga\x05\x12V[\x92\x83a\x0CnV[V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a8\x8EWa8\x8A` \x91a\x05\xF4V[\x01\x90V[a\x0CZV[\x90a8\xA5a8\xA0\x83a8pV[a8[V[\x91\x82RV[_\x7Fmode=blocknumber&from=default\0\0\0\x91\x01RV[a8\xDB`\x1Da8\x93V[\x90a8\xE8` \x83\x01a8\xAAV[V[a8\xF2a8\xD1V[\x90V[a8\xFDa&!V[Pa9\x06a>HV[a9\x1Fa9\x19a9\x14aU_V[a\x19uV[\x91a\x19uV[\x03a9/Wa9,a8\xEAV[\x90V[_c\x01\xBF\xC1\xC5`\xE6\x1B\x81R\x80a9G`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_\x90V[\x90a9Y\x90a\x10\xDFV[_R` R`@_ \x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a9|a9\x81\x91a\x11\x01V[a9eV[\x90V[a9\x8E\x90Ta9pV[\x90V[a9\xA8a9\xAD\x91a9\xA0a9KV[P`\ta9OV[a9\x84V[\x90V[a9\xB8a%\xDDV[Pa9\xC3`Aa\x11\x1AV[a9\xD5a9\xCF_a*\xC8V[\x91a\x07\x94V[\x11\x90V[a9\xEA\x90a9\xE5aK\xF8V[aU\x97V[V[a9\xF4a%\xDDV[Pa9\xFF`\x0Fa0<V[\x90V[a:Y\x90a:\x0Ea'\x97V[Pa:&`\x01a: `\r\x84\x90a\x10\xEBV[\x01a\x11\x1AV[\x90a:S`\x04a:Ma:E_a:?`\r\x87\x90a\x10\xEBV[\x01a\x11\x1AV[\x93`\ra\x10\xEBV[\x01a\x11\x1AV[\x91aV\"V[\x90V[a:la:ga#TV[aL\x15V[a:ta:vV[V[a:\x81_`@a+1V[\x7Fs\xA5\xFC`\xAA\xFE\xEC\x8F\x13\x9A\xF2-\x98\xE6!@\xE2\xCE\x91M\x1F\x15\\i+BwW\xC3\xE4\x01La:\xAAa\x05\x12V[\x80a:\xB4\x81a\t\x13V[\x03\x90\xA1V[a:\xC1a:\\V[V[_\x90V[a:\xD9\x90a:\xD3a:\xC3V[PaV\xCFV[\x90V[\x90a:\xE6\x90a\x10\xDFV[_R` R`@_ \x90V[a;\x08a;\r\x91a;\x01a'\x97V[P_a:\xDCV[a\x11\x1AV[\x90V[a;'a;,\x91a;\x1Fa%\xDDV[P`\x0Ea\x14\xE5V[a0<V[\x90V[\x90a;8a%\xDDV[Pa;Aa'\x97V[Pa;Ja'\x97V[Pa;Sa'\x97V[Pa;\\a'\x97V[Pa;qa;l`\x0E\x84\x90a\x14\xE5V[a0<V[\x91a;\x88_a;\x82`\r\x84\x90a\x10\xEBV[\x01a\x11\x1AV[\x91a;\xA0`\x02a;\x9A`\r\x85\x90a\x10\xEBV[\x01a\x11\x1AV[\x90a;\xD9` a;\xAF0a,\x9DV[ce\x1F\xD2h\x90a;\xCE\x87\x92a;\xC2a\x05\x12V[\x95\x86\x94\x85\x93\x84\x93a,\xADV[\x83R`\x04\x83\x01a\x12\xB4V[\x03\x91Z\xFA\x90\x81\x15a<\x9AWa<$\x91` \x91_\x91a<mW[P\x94a;\xFD0a,\x9DV[a<\x19c\x99\x89U\xD3a<\ra\x05\x12V[\x95\x86\x94\x85\x93\x84\x93a,\xADV[\x83R`\x04\x83\x01a\x12\xB4V[\x03\x91Z\xFA\x90\x81\x15a<hW_\x91a<:W[P\x90V[a<[\x91P` =\x81\x11a<aW[a<S\x81\x83a\x0CnV[\x81\x01\x90a,\xC2V[_a<6V[P=a<IV[a,\xE0V[a<\x8D\x91P\x82=\x81\x11a<\x93W[a<\x85\x81\x83a\x0CnV[\x81\x01\x90a,\xC2V[_a;\xF2V[P=a<{V[a,\xE0V[a<\xB1\x90a<\xABa'\x97V[PaV\xFEV[\x90V[a<\xC4a<\xBFa#TV[aL\x15V[a<\xCCa<\xCEV[V[a<\xD6aWtV[V[a<\xE0a<\xB4V[V[_\x90V[``\x90V[a<\xF4\x90a\x06\xA6V[\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a=\x0FW` \x80\x91\x02\x01\x90V[a\x0CZV[\x90a=&a=!\x83a<\xF7V[a8[V[\x91\x82RV[6\x907V[\x90a=Ua==\x83a=\x14V[\x92` \x80a=K\x86\x93a<\xF7V[\x92\x01\x91\x03\x90a=+V[V[`\x0F`\xF8\x1B\x90V[a=ga<\xE2V[Pa=pa&!V[Pa=ya&!V[Pa=\x82a'\x97V[Pa=\x8Ba9KV[Pa=\x94a/vV[Pa=\x9Da<\xE6V[Pa=\xA6aW\x81V[\x90a=\xAFaW\xC1V[\x90F\x90a=\xBB0a<\xEBV[\x90a=\xC5_a\x1C\x05V[\x90a=\xD7a=\xD2_a*\xC8V[a=0V[\x90a=\xE0a=WV[\x96\x95\x94\x93\x92\x91\x90V[a>\x12a>\x17\x91a=\xF8a'\x97V[Pa>\x0Ca>\x06`\x0Ba6NV[\x91aQ\x06V[\x90aQ\xFCV[a6QV[\x90V[a>A\x91_a>6a><\x93a>.a%\xDDV[P`\x05a/\x86V[\x01a\x14\xE5V[a0<V[\x90V[_\x90V[a>Pa>DV[Pa>YaU_V[\x90V[a>da&!V[Pa>o`\x04a&\xF3V[\x90V[a>\xCA\x90a>~a'\x97V[Pa>\x96`\x03a>\x90`\r\x84\x90a\x10\xEBV[\x01a\x11\x1AV[\x90a>\xC4`\x04a>\xBEa>\xB6`\x02a>\xB0`\r\x87\x90a\x10\xEBV[\x01a\x11\x1AV[\x93`\ra\x10\xEBV[\x01a\x11\x1AV[\x91aV\"V[\x90V[a>\xF4a>\xEFa>\xEAa>\xF9\x93a>\xE2a'\x97V[P`\na68V[a6NV[aX\x01V[a6QV[\x90V[\x90a?\x0E\x91a?\taM\xE8V[a?\x18V[a?\x16aNMV[V[\x90\x81a?4a?.a?)_a+\0V[a\x07eV[\x91a\x07eV[\x14a@3W\x80a?La?F_a*\xC8V[\x91a\x07\x94V[\x14a@\x17Wa?na?ha?c`\x0E3\x90a\x14\xE5V[a0<V[\x15a\x05qV[a?\xFBWa?{3aS\x90V[a?\x92`\x03a?\x8C`\r3\x90a\x10\xEBV[\x01a\x11\x1AV[a?\xA4a?\x9E\x83a\x07\x94V[\x91a\x07\x94V[\x10a?\xDFWa?\xDD\x91a?\xD8\x82a?\xD2`\x03a?\xC2`\r3\x90a\x10\xEBV[\x01\x91a?\xCD\x83a\x11\x1AV[a,\xF0V[\x90a+gV[aXvV[V[_c\x1C\x95\x9E\xD9`\xE2\x1B\x81R\x80a?\xF7`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_cD\x17v\t`\xE1\x1B\x81R\x80a@\x13`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a@/`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a@K`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x90a@Y\x91a>\xFCV[V[\x90a@v\x92\x91a@qa@la$\xE0V[aL\x15V[a@xV[V[\x80a@\x93a@\x8Da@\x88_a+\0V[a\x07eV[\x91a\x07eV[\x14aB\xB9Wa@\xB5a@\xAFa@\xAA`\x0E\x84\x90a\x14\xE5V[a0<V[\x15a\x05qV[\x80aB~W[aB\"W[\x81a@\xD3a@\xCD_a*\xC8V[\x91a\x07\x94V[\x14\x80aB\x08W[\x80aA\xEEW[aA\x93W[a@\xEE\x81aS\x90V[aA\x05\x82_a@\xFF`\r\x85\x90a\x10\xEBV[\x01a+gV[aA\x1D\x83`\x02aA\x17`\r\x85\x90a\x10\xEBV[\x01a+gV[aA5\x82`\x01aA/`\r\x85\x90a\x10\xEBV[\x01a+gV[aAM\x83`\x03aAG`\r\x85\x90a\x10\xEBV[\x01a+gV[\x90\x91aAy\x7F\xAA\x80}\n\xBF0\xD9\x19h\xC7G\x8Cf\xB6\xD8%!\xA1\x06\xAF\x13\xED\xA06\xE2\x03m\xA9\xAF\x16\x89X\x92a\x10\xDFV[\x92aA\x8EaA\x85a\x05\x12V[\x92\x83\x92\x83a\n\x98V[\x03\x90\xA2V[aA\xA8_aA\xA3`\x0E\x84\x90a\x14\xE5V[a+1V[\x80aA\xD3\x7F\x02\xC2\xF0\xBA\x15\xB0?\x88\xB1\x8FH2`\x9A\x18\xCF5\xFCk?EF\xA9\x99 v\xD7E=\x134\xA8\x91a\x10\xDFV[\x90aA\xDCa\x05\x12V[\x80aA\xE6\x81a\t\x13V[\x03\x90\xA2a@\xE5V[PaB\x03aA\xFE`\x0E\x83\x90a\x14\xE5V[a0<V[a@\xE0V[P\x82aB\x1CaB\x16_a*\xC8V[\x91a\x07\x94V[\x14a@\xDAV[aB8`\x01aB3`\x0E\x84\x90a\x14\xE5V[a+1V[\x80aBc\x7Fl\xF2\x849\xA2\xDA\xAB\x1B&P\x97\"r\x12\xA5\xB7\x1E\nv\xF9\xED\x85\xE3\xF8\x15\xB5\xA6\xC3\xE2\x18\xEB\x7F\x91a\x10\xDFV[\x90aBla\x05\x12V[\x80aBv\x81a\t\x13V[\x03\x90\xA2a@\xC0V[P\x81aB\x92aB\x8C_a*\xC8V[\x91a\x07\x94V[\x11\x80\x15aB\x9FW[a@\xBBV[P\x82aB\xB3aB\xAD_a*\xC8V[\x91a\x07\x94V[\x11aB\x9AV[_c\xD9.#=`\xE0\x1B\x81R\x80aB\xD1`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x90aB\xE0\x92\x91a@[V[V[aB\xEAa%\xDDV[PaB\xF5`Ba\x11\x1AV[aC\x0EaC\x08aC\x03a\x13\xBAV[a\x07\x94V[\x91a\x07\x94V[\x10\x15\x90V[aC,\x90aC'aC\"a$\xE0V[aL\x15V[aC\x84V[V[\x90aC?`\x01\x80`\xA0\x1B\x03\x91a\x1C\0V[\x91\x81\x19\x16\x91\x16\x17\x90V[aCR\x90a\x06\x8AV[\x90V[aC^\x90aCIV[\x90V[\x90V[\x90aCyaCtaC\x80\x92aCUV[aCaV[\x82TaC.V[\x90UV[aC\x8D\x81a\x06\xB2V[aC\xA7aC\xA1aC\x9C_a+\0V[a\x07eV[\x91a\x07eV[\x14aD\x1DWaC\xD2aC\xCCaC\xBC`Da'2V[aC\xC7\x84`DaCdV[a\x06\xB2V[\x91a\x06\xB2V[aD\x05aC\xFF\x7F\x07\x01[j\x9F\x05\x911H\xFD_\xAD\xDF*\xCC\x97\x08\xF3\x05\x93\x7F0r\xCA+KF\xFA\xA5\xD0\x89\x8B\x93a\x10\xDFV[\x91a\x10\xDFV[\x91aD\x0Ea\x05\x12V[\x80aD\x18\x81a\t\x13V[\x03\x90\xA3V[_c\xD9.#=`\xE0\x1B\x81R\x80aD5`\x04\x82\x01a\t\x13V[\x03\x90\xFD[aDB\x90aC\x13V[V[\x90V[aD[aDVaD`\x92aDDV[a\x06\x87V[a\x07\x94V[\x90V[aDka'\x97V[PaDv`Aa\x11\x1AV[aD\x88aD\x82_a*\xC8V[\x91a\x07\x94V[\x14aD\xD1WaD\xCEaD\x9A`Aa\x11\x1AV[aD\xC8aD\xBAaD\xAA`Ba\x11\x1AV[aD\xB4`\x01aDGV[\x90a0XV[aD\xC2a\x1E\0V[\x90a-4V[\x90a0XV[\x90V[aD\xDA_a*\xC8V[\x90V[aD\xFA\x91aD\xE9a%\xDDV[PaD\xF2aK\xF8V[\x91\x90\x91aL\xF5V[`\x01\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11aE\x14W` \x02\x90V[a\x0CZV[aE%aE*\x91aD\xFFV[a8[V[\x90V[\x90aEKaE:\x83aE\x19V[\x92aEE\x84\x91aD\xFFV[\x90a=+V[V[aEW`0aE-V[\x90V[\x90P\x90V[aEi\x90Ta\x11\x06V[\x90V[`\x01\x01\x90V[aE\x8EaE\x88aE\x81\x83a\x0E\xEBV[\x80\x94aEZV[\x91a\x0E\xF1V[_\x91[\x83\x83\x10aE\x9EWPPPPV[aE\xBBaE\xB5`\x01\x92aE\xB0\x85aE_V[a\x17{V[\x92aElV[\x92\x01\x91\x90aE\x91V[\x90aE\xD2\x81a\x06\0\x93aErV[\x01\x90V[\x90aE\xF6aE\xEF\x92aE\xE6a\x05\x12V[\x93\x84\x80\x92aE\xC4V[\x03\x83a\x0CnV[V[aF\x01\x90aE\xD6V[\x90V[aF\x0CaEMV[PaF\x17`\x10aE\xF8V[\x90V[\x90aF-\x91aF'a'\x97V[Pa6mV[\x90V[aF8a'\x97V[PaFAa'\x97V[PaFJa'\x97V[PaFSa%\xDDV[PaF^`Aa\x11\x1AV[aFpaFj_a*\xC8V[\x91a\x07\x94V[\x14aG\xE1WaF\x9AaF\x8CBaF\x86`Aa\x11\x1AV[\x90a,\xF0V[aF\x94a\x1E\0V[\x90a-}V[\x90aF\xDCaF\xA8`Aa\x11\x1AV[aF\xD6aF\xC8aF\xB8`Ba\x11\x1AV[aF\xC2`\x01aDGV[\x90a0XV[aF\xD0a\x1E\0V[\x90a-4V[\x90a0XV[aF\xE6`Ba\x11\x1AV[aF\xFFaF\xF9aF\xF4a\x13\xBAV[a\x07\x94V[\x91a\x07\x94V[\x10_\x14aG\xD3WaG$aG\x1E`\x10aG\x18`Ba\x11\x1AV[\x90a\x0E\xF4V[\x90a\x0F7V[[\x92aG0`@a0<V[\x90\x81aG\xAFW[P\x80aG\x85W[\x80aGYW[\x91aGO`Ba\x11\x1AV[\x91\x93\x92\x91\x93\x92\x91\x90V[PBaG~aGxaGs\x84aGma\x0B\x10V[\x90a,\xF0V[a\x07\x94V[\x91a\x07\x94V[\x10\x15aGDV[PaG\x90`Ba\x11\x1AV[aG\xA9aG\xA3aG\x9Ea\x13\xBAV[a\x07\x94V[\x91a\x07\x94V[\x10aG>V[\x90PaG\xCCaG\xC6aG\xC1`Ba\x11\x1AV[a\x07\x94V[\x91a\x07\x94V[\x11_aG7V[aG\xDC_a*\xC8V[aG%V[_\x90_\x91_\x91aH\x03aG\xFDaG\xF7_\x94a*\xC8V[\x95a*\xC8V[\x93a*\xC8V[\x91\x90V[aH\x19\x90aH\x13a'\x97V[Pa>\xCDV[\x90V[aH$a'\x97V[PaH-a*\x98V[\x90V[`\x02aHIaHO\x92aHAa'\x97V[P`\ra\x10\xEBV[\x01a\x11\x1AV[\x90V[\x7F\xE4\x83)\x05{\xFD\x03\xD5^I\xB5G\x13.9\xCF\xFD\x9C\x18 \xAD{\x9DLS\x07i\x14%\xD1Z\xDF\x90V[aH\xABaH\xB2\x94aH\xA1``\x94\x98\x97\x95aH\x97`\x80\x86\x01\x9A_\x87\x01\x90a\rqV[` \x85\x01\x90a\x12\xA7V[`@\x83\x01\x90a\x08;V[\x01\x90a\x08;V[V[` \x01\x90V[\x93\x95\x94\x90\x92\x91\x95BaH\xD4aH\xCE\x89a\x07\x94V[\x91a\x07\x94V[\x11aIMW\x91aI?\x91aIF\x93aI6aIK\x98\x99aI\x1EaH\xF5aHRV[aI\x0F\x8B\x93\x8BaI\x03a\x05\x12V[\x95\x86\x94` \x86\x01aHvV[` \x82\x01\x81\x03\x82R\x03\x82a\x0CnV[aI0aI*\x82a\x06\xCBV[\x91aH\xB4V[ aX\xD5V[\x92\x90\x91\x92aX\xF2V[\x91\x82aY<V[aU\x97V[V[aIh\x87_\x91\x82\x91c#A\xD7\x87`\xE1\x1B\x83R`\x04\x83\x01a\x08HV[\x03\x90\xFD[\x7Fnq\xED\xAE\x12\xB1\xB9\x7FM\x1F`7\x0F\xEF\x10\x10_\xA2\xFA\xAE\x01&\x11J\x16\x9Cd\x84]a&\xC9\x90V[\x91\x94aI\xD8aI\xE2\x92\x98\x97\x95aI\xCE`\xA0\x96aI\xC4aI\xE9\x9AaI\xBA`\xC0\x8A\x01\x9E_\x8B\x01\x90a\rqV[` \x89\x01\x90a\x12\xA7V[`@\x87\x01\x90a\x12\xA7V[``\x85\x01\x90a\x08;V[`\x80\x83\x01\x90a\x08;V[\x01\x90a\x08;V[V[\x91` aJ\x0C\x92\x94\x93aJ\x05`@\x82\x01\x96_\x83\x01\x90a\x12\xA7V[\x01\x90a\x12\xA7V[V[\x96\x95\x91\x93\x92\x94\x90\x94BaJ)aJ#\x83a\x07\x94V[\x91a\x07\x94V[\x11aJ\xE3W\x90aJ\x92aJ\x9B\x94\x93\x92aJzaJCaIlV[aJk\x8C\x80\x94\x8C\x91aJU\x8D\x91aY\x7FV[\x91\x92aJ_a\x05\x12V[\x97\x88\x96` \x88\x01aI\x90V[` \x82\x01\x81\x03\x82R\x03\x82a\x0CnV[aJ\x8CaJ\x86\x82a\x06\xCBV[\x91aH\xB4V[ aX\xD5V[\x92\x90\x91\x92aX\xF2V[\x80aJ\xAEaJ\xA8\x87a\x07eV[\x91a\x07eV[\x03aJ\xC3WPaJ\xC1\x92\x93\x91\x90\x91aL\x05V[V[\x84\x90aJ\xDF_\x92\x83\x92c%\xC0\x07#`\xE1\x1B\x84R`\x04\x84\x01aI\xEBV[\x03\x90\xFD[aJ\xFE\x90_\x91\x82\x91c1<\x89\x81`\xE1\x1B\x83R`\x04\x83\x01a\x08HV[\x03\x90\xFD[\x90aK\x1D\x91aK\x18aK\x13\x82a/\xC0V[aL\x15V[aK\x1FV[V[\x90aK)\x91aP%V[PV[\x90aK6\x91aK\x02V[V[\x90aKB\x90a\x10\xDFV[_R` R`@_ \x90V[aKs\x91aKiaKn\x92aKaa'\x97V[P`\x01aK8V[a:\xDCV[a\x11\x1AV[\x90V[aK\x80`@a8[V[\x90V[_\x90V[_\x90V[aK\x93aKvV[\x90` \x80\x83aK\xA0aK\x83V[\x81R\x01aK\xABaK\x87V[\x81RPPV[aK\xB9aK\x8BV[\x90V[\x90aK\xCF\x91aK\xC9aK\xB1V[PaY\xB2V[\x90V[aK\xDAa%\xDDV[PaK\xF4aK\xEEc\x01\xFF\xC9\xA7`\xE0\x1Ba\x05$V[\x91a\x05$V[\x14\x90V[aL\0a9KV[P3\x90V[\x91aL\x13\x92\x91`\x01\x92aY\xDAV[V[aL'\x90aL!aK\xF8V[\x90a[\x0CV[V[`@\x90aLRaLY\x94\x96\x95\x93\x96aLH``\x84\x01\x98_\x85\x01\x90a\x12\xA7V[` \x83\x01\x90a\x08;V[\x01\x90a\x08;V[V[\x90aLf\x91\x03a\x07\x94V[\x90V[\x92\x91\x92aLw\x81\x83\x90aKNV[\x90\x81aL\x8CaL\x86_\x19a\x07\x94V[\x91a\x07\x94V[\x10aL\x99W[PPP\x90PV[\x81aL\xACaL\xA6\x87a\x07\x94V[\x91a\x07\x94V[\x10aL\xD2WaL\xC9\x93\x94aL\xC1\x91\x93\x92aL[V[\x90_\x92aY\xDAV[\x80_\x80\x80aL\x92V[PaL\xF1\x84\x92\x91\x92_\x93\x84\x93c}\xC7\xA0\xD9`\xE1\x1B\x85R`\x04\x85\x01aL)V[\x03\x90\xFD[\x91\x82aM\x11aM\x0BaM\x06_a+\0V[a\x07eV[\x91a\x07eV[\x14aMkW\x81aM1aM+aM&_a+\0V[a\x07eV[\x91a\x07eV[\x14aMDWaMB\x92\x91\x90\x91a[GV[V[aMgaMP_a+\0V[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x12\xB4V[\x03\x90\xFD[aM\x8EaMw_a+\0V[_\x91\x82\x91cKc~\x8F`\xE1\x1B\x83R`\x04\x83\x01a\x12\xB4V[\x03\x90\xFD[aM\x9Aa9\xECV[aM\xA0WV[_c\xD9<\x06e`\xE0\x1B\x81R\x80aM\xB8`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x90V[aM\xD3aM\xCEaM\xD8\x92aM\xBCV[a\x06\x87V[a\x07\x94V[\x90V[aM\xE5`\x02aM\xBFV[\x90V[aM\xF2`\x0Ca\x11\x1AV[aN\x0BaN\x05aN\0aM\xDBV[a\x07\x94V[\x91a\x07\x94V[\x14aN$WaN\"aN\x1BaM\xDBV[`\x0Ca+gV[V[_c>\xE5\xAE\xB5`\xE0\x1B\x81R\x80aN<`\x04\x82\x01a\t\x13V[\x03\x90\xFD[aNJ`\x01aDGV[\x90V[aN_aNXaN@V[`\x0Ca+gV[V[\x80aN|aNvaNq_a+\0V[a\x07eV[\x91a\x07eV[\x14aN\x98WaN\x96\x91aN\x8E_a+\0V[\x91\x90\x91a[GV[V[aN\xBBaN\xA4_a+\0V[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x12\xB4V[\x03\x90\xFD[aN\xC7a%\xDDV[PaN\xDCaN\xD6\x82\x84\x90a>\x1AV[\x15a\x05qV[_\x14aOeWaO\x04`\x01aN\xFF_aN\xF7`\x05\x86\x90a/\x86V[\x01\x85\x90a\x14\xE5V[a+1V[\x90aO\raK\xF8V[\x90aOJaODaO>\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a/zV[\x92a\x10\xDFV[\x92a\x10\xDFV[\x92aOSa\x05\x12V[\x80aO]\x81a\t\x13V[\x03\x90\xA4`\x01\x90V[PP_\x90V[aOsa/vV[PaO}0a<\xEBV[aO\xAFaO\xA9\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x07eV[\x91a\x07eV[\x14\x80aO\xEBW[_\x14aO\xE0W\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[aO\xE8a[\xC7V[\x90V[PFaP\x1FaP\x19\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x07\x94V[\x91a\x07\x94V[\x14aO\xB6V[aP-a%\xDDV[PaP9\x81\x83\x90a>\x1AV[_\x14aP\xC1WaP`_aP[_aPS`\x05\x86\x90a/\x86V[\x01\x85\x90a\x14\xE5V[a+1V[\x90aPiaK\xF8V[\x90aP\xA6aP\xA0aP\x9A\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x95a/zV[\x92a\x10\xDFV[\x92a\x10\xDFV[\x92aP\xAFa\x05\x12V[\x80aP\xB9\x81a\t\x13V[\x03\x90\xA4`\x01\x90V[PP_\x90V[aP\xDBaP\xD6aP\xE0\x92a\x19uV[a\x06\x87V[a\x07\x94V[\x90V[\x91` aQ\x04\x92\x94\x93aP\xFD`@\x82\x01\x96_\x83\x01\x90a\x08;V[\x01\x90a\x19\x80V[V[aQ\x0Ea>DV[PaQ\x17a>HV[\x81aQ*aQ$\x83aP\xC7V[\x91a\x07\x94V[\x10\x15aQ=WPaQ:\x90a\\\xCDV[\x90V[\x90aQX_\x92\x83\x92cvi\xFC\x0F`\xE1\x1B\x84R`\x04\x84\x01aP\xE3V[\x03\x90\xFD[T\x90V[\x90V[aQwaQraQ|\x92aQ`V[a\x06\x87V[a\x07\x94V[\x90V[\x90V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[aQ\x99aQ\x9E\x91a\x11\x01V[aQ\x82V[\x90V[aQ\xAB\x90TaQ\x8DV[\x90V[`0\x1C\x90V[`\x01\x80`\xD0\x1B\x03\x16\x90V[aQ\xCBaQ\xD0\x91aQ\xAEV[aQ\xB4V[\x90V[aQ\xDD\x90TaQ\xBFV[\x90V[aQ\xF4aQ\xEFaQ\xF9\x92a\x1B\xFDV[a\x06\x87V[a$\x15V[\x90V[\x90aRP\x90aR\ta%HV[PaR\x15_\x84\x01aQ\\V[aR\x1E_a*\xC8V[\x90\x80\x80aR4aR.`\x05aQcV[\x91a\x07\x94V[\x11aR\xB1W[P\x90aRK_\x86\x01\x93\x91\x92\x93aQ\x7FV[ac\x05V[\x80aRcaR]_a*\xC8V[\x91a\x07\x94V[\x14_\x14aRyWPPaRu_aQ\xE0V[[\x90V[aR\xA6_\x91aR\xA1aR\x9B\x84aR\xAC\x96\x01\x92aR\x95`\x01aDGV[\x90a,\xF0V[\x91aQ\x7FV[ab\xFBV[\x01aQ\xD3V[aRvV[\x80aR\xBFaR\xC5\x92\x91a_\x90V[\x90a,\xF0V[\x90\x83aR\xF7aR\xF1aR\xEC_aR\xE6\x81\x8C\x01aR\xE1\x89\x91aQ\x7FV[ab\xFBV[\x01aQ\xA1V[a\x19uV[\x91a\x19uV[\x10_\x14aS\x08WP\x90[\x90_aR:V[\x91PaS\x1E\x90aS\x18`\x01aDGV[\x90a0XV[aS\x01V[aS+ac\x94V[aS3aS5V[V[aS@_`\x0Fa+1V[aSHaK\xF8V[aS~\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA\x91aSua\x05\x12V[\x91\x82\x91\x82a\x12\xB4V[\x03\x90\xA1V[aS\x8BaS#V[V[\x90V[aS\x9EaS\xA3\x91`\ra\x10\xEBV[aS\x8DV[aS\xAF`\x04\x82\x01a\x11\x1AV[aS\xC1aS\xBB_a*\xC8V[\x91a\x07\x94V[\x14aUOWaT=\x90aS\xE0BaS\xDA`\x04\x84\x01a\x11\x1AV[\x90a,\xF0V[\x80aS\xFAaS\xF4aS\xEFa\x1A+V[a\x07\x94V[\x91a\x07\x94V[\x10\x15_\x14aT?WPaT\x1AaT\x11_\x83\x01a\x11\x1AV[`\x01\x83\x01a+gV[aT2aT)`\x02\x83\x01a\x11\x1AV[`\x03\x83\x01a+gV[[`\x04B\x91\x01a+gV[V[\x80aTRaTL_a*\xC8V[\x91a\x07\x94V[\x11aT^W[PaT3V[aU@aU.aUI\x92aU\x1DaU\x14aU\x03aT\xF1aT\xB3aT\x82_\x8B\x01a\x11\x1AV[aT\x94\x87aT\x8Ea\x1E\xA4V[\x90a-4V[aT\xADaT\x9Fa\x1A+V[aT\xA7a\x1E\xA4V[\x90a-4V[\x91ad\x1CV[\x94aT\xD2aT\xC3`\x02\x8C\x01a\x11\x1AV[\x91aT\xCCa\x1E\xA4V[\x90a-4V[aT\xEBaT\xDDa\x1A+V[aT\xE5a\x1E\xA4V[\x90a-4V[\x91ad\x1CV[\x93aT\xFE`\x01\x8A\x01a\x11\x1AV[a0XV[aU\x0E_\x89\x01a\x11\x1AV[\x90af\x1BV[`\x01\x87\x01a+gV[aU)`\x03\x86\x01a\x11\x1AV[a0XV[aU:`\x02\x85\x01a\x11\x1AV[\x90af\x1BV[`\x03\x83\x01a+gV[_aTXV[aU]\x90`\x04B\x91\x01a+gV[V[aUga>DV[PaUqCa\\\xCDV[\x90V[\x90V[\x90aU\x8CaU\x87aU\x93\x92a\x10\xDFV[aUtV[\x82TaC.V[\x90UV[\x90aV \x91aV\x1AaU\xA8\x82a9\x91V[aU\xBD\x84aU\xB8`\t\x86\x90a9OV[aUwV[\x82\x81\x85\x90aU\xFDaU\xF7aU\xF1\x7F14\xE8\xA2\xE6\xD9~\x92\x9A~T\x01\x1E\xA5H]}\x19m\xD5\xF0\xBAMN\xF9X\x03\xE8\xE3\xFC%\x7F\x95a\x10\xDFV[\x92a\x10\xDFV[\x92a\x10\xDFV[\x92aV\x06a\x05\x12V[\x80aV\x10\x81a\t\x13V[\x03\x90\xA4\x92\x91afGV[\x91af_V[V[\x90\x91aV,a'\x97V[P\x80aV@aV:_a*\xC8V[\x91a\x07\x94V[\x14aV\xC0WaVO\x90Ba,\xF0V[\x80aViaVcaV^a\x1A+V[a\x07\x94V[\x91a\x07\x94V[\x10\x15aV\xBBW\x82\x91aV\xADaV\xB3\x92aV\x8EaV\xB8\x96\x91aV\x88a\x1E\xA4V[\x90a-4V[aV\xA7aV\x99a\x1A+V[aV\xA1a\x1E\xA4V[\x90a-4V[\x91ad\x1CV[\x90a0XV[af\x1BV[\x90V[PP\x90V[PPPaV\xCC_a*\xC8V[\x90V[aV\xF6aV\xF1aV\xECaV\xFB\x93aV\xE4a:\xC3V[P`\na68V[a6NV[ah\rV[ah\x8CV[\x90V[aW\x10\x90aW\na'\x97V[Pah\xDDV[\x90V[aW\x1BaM\x92V[aW#aW%V[V[aW1`\x01`\x0Fa+1V[aW9aK\xF8V[aWo\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2X\x91aWfa\x05\x12V[\x91\x82\x91\x82a\x12\xB4V[\x03\x90\xA1V[aW|aW\x13V[V[\x90V[aW\x89a&!V[PaW\xBE\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0aW\xB8`\x06aW~V[\x90ai\xF8V[\x90V[aW\xC9a&!V[PaW\xFE\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0aW\xF8`\x07aW~V[\x90ai\xF8V[\x90V[aX\ta%HV[PaX\x15_\x82\x01aQ\\V[\x80aX(aX\"_a*\xC8V[\x91a\x07\x94V[\x14_\x14aX>WPPaX:_aQ\xE0V[[\x90V[aXk_\x91aXfaX`\x84aXq\x96\x01\x92aXZ`\x01aDGV[\x90a,\xF0V[\x91aQ\x7FV[ab\xFBV[\x01aQ\xD3V[aX;V[\x90\x81aX\x92aX\x8CaX\x87_a+\0V[a\x07eV[\x91a\x07eV[\x14aX\xAEWaX\xAC\x91\x90aX\xA5_a+\0V[\x90\x91a[GV[V[aX\xD1aX\xBA_a+\0V[_\x91\x82\x91cKc~\x8F`\xE1\x1B\x83R`\x04\x83\x01a\x12\xB4V[\x03\x90\xFD[aX\xEF\x90aX\xE1a/vV[PaX\xEAaOkV[ajFV[\x90V[\x92aY\r\x92aY\x16\x94aY\x03a9KV[P\x92\x90\x91\x92aj\xFCV[\x90\x92\x91\x92al'V[\x90V[\x91` aY:\x92\x94\x93aY3`@\x82\x01\x96_\x83\x01\x90a\x12\xA7V[\x01\x90a\x08;V[V[aYE\x81aY\x7FV[\x91aYXaYR\x84a\x07\x94V[\x91a\x07\x94V[\x03aYaWPPV[aY{_\x92\x83\x92c\x01\xD4\xB6#`\xE6\x1B\x84R`\x04\x84\x01aY\x19V[\x03\x90\xFD[aY\x93\x90aY\x8Ba'\x97V[P`\x08a:\xDCV[aY\xAFaY\x9F\x82a\x11\x1AV[\x91aY\xA9\x83a0IV[\x90a+gV[\x90V[\x90aY\xD2aY\xCDaY\xD7\x93aY\xC5aK\xB1V[P`\na68V[a6NV[am\x89V[\x90V[\x90\x92\x81aY\xF7aY\xF1aY\xEC_a+\0V[a\x07eV[\x91a\x07eV[\x14aZ\xC2W\x83aZ\x17aZ\x11aZ\x0C_a+\0V[a\x07eV[\x91a\x07eV[\x14aZ\x9BWaZ;\x83aZ6aZ/`\x01\x86\x90aK8V[\x87\x90a:\xDCV[a+gV[aZEW[PPPV[\x91\x90\x91aZ\x90aZ~aZx\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%\x93a\x10\xDFV[\x93a\x10\xDFV[\x93aZ\x87a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xA3_\x80\x80aZ@V[aZ\xBEaZ\xA7_a+\0V[_\x91\x82\x91cJ\x14\x06\xB1`\xE1\x1B\x83R`\x04\x83\x01a\x12\xB4V[\x03\x90\xFD[aZ\xE5aZ\xCE_a+\0V[_\x91\x82\x91c\xE6\x02\xDF\x05`\xE0\x1B\x83R`\x04\x83\x01a\x12\xB4V[\x03\x90\xFD[\x91` a[\n\x92\x94\x93a[\x03`@\x82\x01\x96_\x83\x01\x90a\x12\xA7V[\x01\x90a\rqV[V[\x90a[!a[\x1B\x83\x83\x90a>\x1AV[\x15a\x05qV[a[)WPPV[a[C_\x92\x83\x92c\xE2Q}?`\xE0\x1B\x84R`\x04\x84\x01aZ\xE9V[\x03\x90\xFD[\x91a[T\x92\x91\x90\x91am\xAAV[V[\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x90V[\x90\x95\x94\x92a[\xC5\x94a[\xB4a[\xBE\x92a[\xAA`\x80\x96a[\xA0`\xA0\x88\x01\x9C_\x89\x01\x90a\rqV[` \x87\x01\x90a\rqV[`@\x85\x01\x90a\rqV[``\x83\x01\x90a\x08;V[\x01\x90a\x12\xA7V[V[a[\xCFa/vV[Pa[\xD8a[VV[a\\O\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91a\\@\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0Fa\\+0a<\xEBV[\x91a\\4a\x05\x12V[\x96\x87\x95` \x87\x01a[zV[` \x82\x01\x81\x03\x82R\x03\x82a\x0CnV[a\\aa\\[\x82a\x06\xCBV[\x91aH\xB4V[ \x90V[a\\ya\\ta\\~\x92a\x13\x9BV[a\x06\x87V[a\x0E\\V[\x90V[a\\\x8A\x90a\\eV[\x90RV[\x91` a\\\xAF\x92\x94\x93a\\\xA8`@\x82\x01\x96_\x83\x01\x90a\\\x81V[\x01\x90a\x08;V[V[a\\\xC5a\\\xC0a\\\xCA\x92a\x07\x94V[a\x06\x87V[a\x19uV[\x90V[a\\\xD5a>DV[P\x80a\\\xEFa\\\xE9e\xFF\xFF\xFF\xFF\xFF\xFFaP\xC7V[\x91a\x07\x94V[\x11a]\0Wa\\\xFD\x90a\\\xB1V[\x90V[`0a]\x1C_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01a\\\x8EV[\x03\x90\xFD[\x90V[a]7a]2a]<\x92a] V[a\x06\x87V[a\x07\x94V[\x90V[\x90V[a]Va]Qa][\x92a]?V[a\x06\x87V[a\x0E\\V[\x90V[a]}\x90a]wa]qa]\x82\x94a\x0E\\V[\x91a\x07\x94V[\x90a\t\xB4V[a\x07\x94V[\x90V[\x90V[a]\x9Ca]\x97a]\xA1\x92a]\x85V[a\x06\x87V[a\x0E\\V[\x90V[a]\xC3\x90a]\xBDa]\xB7a]\xC8\x94a\x0E\\V[\x91a\x07\x94V[\x90a'\xE6V[a\x07\x94V[\x90V[\x90V[a]\xE2a]\xDDa]\xE7\x92a]\xCBV[a\x06\x87V[a\x07\x94V[\x90V[\x90V[a^\x01a]\xFCa^\x06\x92a]\xEAV[a\x06\x87V[a\x0E\\V[\x90V[\x90V[a^ a^\x1Ba^%\x92a^\tV[a\x06\x87V[a\x07\x94V[\x90V[\x90V[a^?a^:a^D\x92a^(V[a\x06\x87V[a\x0E\\V[\x90V[\x90V[a^^a^Ya^c\x92a^GV[a\x06\x87V[a\x07\x94V[\x90V[\x90V[a^}a^xa^\x82\x92a^fV[a\x06\x87V[a\x0E\\V[\x90V[\x90V[a^\x9Ca^\x97a^\xA1\x92a^\x85V[a\x06\x87V[a\x07\x94V[\x90V[\x90V[a^\xBBa^\xB6a^\xC0\x92a^\xA4V[a\x06\x87V[a\x0E\\V[\x90V[a^\xD7a^\xD2a^\xDC\x92a^(V[a\x06\x87V[a\x07\x94V[\x90V[a^\xF3a^\xEEa^\xF8\x92aM\xBCV[a\x06\x87V[a\x0E\\V[\x90V[a_\x0Fa_\na_\x14\x92a^\xA4V[a\x06\x87V[a\x07\x94V[\x90V[a_+a_&a_0\x92aDDV[a\x06\x87V[a\x0E\\V[\x90V[\x90V[a_Ja_Ea_O\x92a_3V[a\x06\x87V[a\x07\x94V[\x90V[\x90a_]\x91\x02a\x07\x94V[\x90V[a_la_r\x91a\x07\x94V[\x91a\x07\x94V[\x90\x81\x15a_}W\x04\x90V[a-iV[\x90a_\x8D\x91\x01a\x07\x94V[\x90V[a_\x98a'\x97V[P\x80a_\xADa_\xA7`\x01aDGV[\x91a\x07\x94V[\x11\x15ab\xF8W\x80aa\xC2aa\x9Faa\x8Faa\x7Faaoaa_aaOaa?aa/aa\x1Faa\x0F\x8Baa\taa\x02aa\xC8\x9Fa`\xE2a`\xD2a`\xF2\x92a_\xF4`\x01aDGV[\x90\x80a`\x0Ca`\x06`\x01`\x80\x1Ba]#V[\x91a\x07\x94V[\x10\x15ab\xCAW[\x80a`/a`)h\x01\0\0\0\0\0\0\0\0a]\xCEV[\x91a\x07\x94V[\x10\x15ab\x9CW[\x80a`Na`Hd\x01\0\0\0\0a^\x0CV[\x91a\x07\x94V[\x10\x15abnW[\x80a`ka`eb\x01\0\0a^JV[\x91a\x07\x94V[\x10\x15ab@W[\x80a`\x87a`\x81a\x01\0a^\x88V[\x91a\x07\x94V[\x10\x15ab\x12W[\x80a`\xA2a`\x9C`\x10a^\xC3V[\x91a\x07\x94V[\x10\x15aa\xE4W[a`\xBCa`\xB6`\x04a^\xFBV[\x91a\x07\x94V[\x10\x15aa\xCBW[a`\xCD`\x03a_6V[a_RV[a`\xDC`\x01a_\x17V[\x90a]^V[a`\xEC\x81\x86a_`V[\x90a_\x82V[a`\xFC`\x01a_\x17V[\x90a]^V[\x80\x92a_`V[\x90a_\x82V[aa\x19`\x01a_\x17V[\x90a]^V[aa)\x81\x8Ca_`V[\x90a_\x82V[aa9`\x01a_\x17V[\x90a]^V[aaI\x81\x8Aa_`V[\x90a_\x82V[aaY`\x01a_\x17V[\x90a]^V[aai\x81\x88a_`V[\x90a_\x82V[aay`\x01a_\x17V[\x90a]^V[aa\x89\x81\x86a_`V[\x90a_\x82V[aa\x99`\x01a_\x17V[\x90a]^V[\x91aa\xBCaa\xB6aa\xB1\x85\x80\x94a_`V[a\x07\x94V[\x91a\x07\x94V[\x11an:V[\x90aL[V[\x90V[aa\xDF\x90aa\xD9`\x01a_\x17V[\x90a]\xA4V[a`\xC3V[aa\xFBab\x0C\x91aa\xF5`\x04a^\xA7V[\x90a]^V[\x91ab\x06`\x02a^\xDFV[\x90a]\xA4V[\x90a`\xA9V[ab)ab:\x91ab#`\x08a^iV[\x90a]^V[\x91ab4`\x04a^\xA7V[\x90a]\xA4V[\x90a`\x8EV[abWabh\x91abQ`\x10a^+V[\x90a]^V[\x91abb`\x08a^iV[\x90a]\xA4V[\x90a`rV[ab\x85ab\x96\x91ab\x7F` a]\xEDV[\x90a]^V[\x91ab\x90`\x10a^+V[\x90a]\xA4V[\x90a`UV[ab\xB3ab\xC4\x91ab\xAD`@a]\x88V[\x90a]^V[\x91ab\xBE` a]\xEDV[\x90a]\xA4V[\x90a`6V[ab\xE1ab\xF2\x91ab\xDB`\x80a]BV[\x90a]^V[\x91ab\xEC`@a]\x88V[\x90a]\xA4V[\x90a`\x13V[\x90V[_R` _ \x01\x90V[\x93\x91\x90\x92ac\x11a'\x97V[P[\x81ac&ac \x83a\x07\x94V[\x91a\x07\x94V[\x10\x15ac\x8CWac7\x82\x82\x90anHV[\x90acM_acG\x88\x85\x90ab\xFBV[\x01aQ\xA1V[ac_acY\x87a\x19uV[\x91a\x19uV[\x11_\x14acoWP\x91[\x91ac\x13V[\x92\x91Pac\x86\x90ac\x80`\x01aDGV[\x90a0XV[\x90aciV[\x92PP\x91P\x90V[ac\xA5ac\x9Fa9\xECV[\x15a\x05qV[ac\xABWV[_c\x8D\xFC +`\xE0\x1B\x81R\x80ac\xC3`\x04\x82\x01a\t\x13V[\x03\x90\xFD[ac\xDBac\xD6ac\xE0\x92a5\x02V[a\x06\x87V[a\x07\x94V[\x90V[ac\xED`\x12ac\xC7V[\x90V[\x90V[ad\x07ad\x02ad\x0C\x92ac\xF0V[a\x06\x87V[a\x07\x94V[\x90V[ad\x19`\x11ac\xF3V[\x90V[\x92\x91\x92ad'a'\x97V[Pad3\x81\x83\x90a_RV[\x91ad<a'\x97V[P_\x19\x81\x83\t\x83\x80\x82\x10\x91\x03\x03\x91\x82ad]adW_a*\xC8V[\x91a\x07\x94V[\x14af\nW\x85aduado\x85a\x07\x94V[\x91a\x07\x94V[\x11\x15ae\xD8Wae\xCF\x92\x86ae\xD5\x96\x97\x93ad\xC6\x93ad\x92a'\x97V[P\t\x90\x85\x82\x11\x90\x03\x94\x03\x93`\x01\x83ad\xB3_ad\xAE\x87\x91a*\xC8V[aL[V[\x16\x80\x80\x95\x04\x96\x04\x93\x80_\x03\x04\x01\x90a_RV[\x17\x91ae\xC9ae\xADae\x89aeeaeAae\x1Dad\xEE`\x03ad\xE9\x89\x91a_6V[a_RV[ad\xF8`\x02aM\xBFV[\x18ae\x17`\x02ae\x12ae\x0C\x8B\x85\x90a_RV[\x91aM\xBFV[aL[V[\x90a_RV[ae;`\x02ae6ae0\x8A\x85\x90a_RV[\x91aM\xBFV[aL[V[\x90a_RV[ae_`\x02aeZaeT\x89\x85\x90a_RV[\x91aM\xBFV[aL[V[\x90a_RV[ae\x83`\x02ae~aex\x88\x85\x90a_RV[\x91aM\xBFV[aL[V[\x90a_RV[ae\xA7`\x02ae\xA2ae\x9C\x87\x85\x90a_RV[\x91aM\xBFV[aL[V[\x90a_RV[\x91ae\xC4ae\xBE`\x02\x92\x85\x90a_RV[\x91aM\xBFV[aL[V[\x90a_RV[\x90a_RV[\x90V[af\x05\x86ae\xEEae\xE8_a*\xC8V[\x91a\x07\x94V[\x14ae\xF7ac\xE3V[ae\xFFad\x0FV[\x91anvV[an\x9AV[PPP\x91af\x18\x91\x92a_`V[\x90V[afD\x91af'a'\x97V[P\x81af;af5\x83a\x07\x94V[\x91a\x07\x94V[\x10\x91\x90\x91anvV[\x90V[afY\x90afSa'\x97V[Pa:\xF2V[\x90V[\x90V[\x91\x90\x91\x80afuafo\x85a\x07eV[\x91a\x07eV[\x14\x15\x80ag\xF3W[af\x87W[PPPV[\x80af\xA2af\x9Caf\x97_a+\0V[a\x07eV[\x91a\x07eV[\x03agcW[P\x81af\xC4af\xBEaf\xB9_a+\0V[a\x07eV[\x91a\x07eV[\x03af\xD0W[\x80af\x82V[ag\x17ag\nag\x11\x92af\xE6`\n\x86\x90a68V[\x90ag\x04af\xFEaf\xF8`\x01\x93ao\x15V[\x93a6NV[\x91af\\V[\x90aohV[\x92\x90a6QV[\x91a6QV[\x91\x90\x91agD\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\x10\xDFV[\x92agYagPa\x05\x12V[\x92\x83\x92\x83a\n\x98V[\x03\x90\xA2_\x80af\xCAV[ag\xA2ag\xA8ag\x9Bagx`\n\x85\x90a68V[`\x02ag\x95ag\x8Fag\x89\x89ao\x15V[\x93a6NV[\x91af\\V[\x90aohV[\x92\x90a6QV[\x91a6QV[\x91\x90\x91ag\xD5\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\x10\xDFV[\x92ag\xEAag\xE1a\x05\x12V[\x92\x83\x92\x83a\n\x98V[\x03\x90\xA2_af\xA8V[P\x81ah\x07ah\x01_a*\xC8V[\x91a\x07\x94V[\x11af}V[_ah!\x91ah\x1Aa'\x97V[P\x01aQ\\V[\x90V[ah8ah3ah=\x92a\x15IV[a\x06\x87V[a\x07\x94V[\x90V[ahI\x90a]\xEDV[\x90RV[\x91` ahn\x92\x94\x93ahg`@\x82\x01\x96_\x83\x01\x90ah@V[\x01\x90a\x08;V[V[ah\x84ah\x7Fah\x89\x92a\x07\x94V[a\x06\x87V[a\x15IV[\x90V[ah\x94a:\xC3V[P\x80ah\xACah\xA6c\xFF\xFF\xFF\xFFah$V[\x91a\x07\x94V[\x11ah\xBDWah\xBA\x90ahpV[\x90V[` ah\xD9_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01ahMV[\x03\x90\xFD[ah\xF4ah\xF9\x91ah\xECa'\x97V[P`\x08a:\xDCV[a\x11\x1AV[\x90V[\x90V[ai\x13ai\x0Eai\x18\x92ah\xFCV[a\x1C\0V[a\r-V[\x90V[ai%`\xFFah\xFFV[\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90aiKaiD\x83a\x0B\x85V[\x80\x94a&&V[\x91`\x01\x81\x16\x90\x81_\x14ai\xA2WP`\x01\x14aifW[PPPV[ais\x91\x92\x93\x94Pai(V[\x91_\x92[\x81\x84\x10ai\x8AWPP\x01\x90_\x80\x80aiaV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90aiwV[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80aiaV[\x90ai\xC7\x91ai1V[\x90V[\x90ai\xEAai\xE3\x92ai\xDAa\x05\x12V[\x93\x84\x80\x92ai\xBDV[\x03\x83a\x0CnV[V[ai\xF5\x90ai\xCAV[\x90V[\x90aj\x01a&!V[Paj\x0B\x82a/zV[aj$aj\x1Eaj\x19ai\x1BV[a\r-V[\x91a\r-V[\x14\x15_\x14aj9WPaj6\x90ao\xF2V[\x90V[ajC\x91Pai\xECV[\x90V[`B\x91ajQa/vV[P`@Q\x91\x7F\x19\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83R`\x02\x83\x01R`\"\x82\x01R \x90V[_\x90V[aj\x97aj\x9C\x91a\x11\x01V[a(\x0FV[\x90V[\x90V[aj\xB6aj\xB1aj\xBB\x92aj\x9FV[a\x06\x87V[a\x07\x94V[\x90V[aj\xF3aj\xFA\x94aj\xE9``\x94\x98\x97\x95aj\xDF`\x80\x86\x01\x9A_\x87\x01\x90a\rqV[` \x85\x01\x90a\x0EbV[`@\x83\x01\x90a\rqV[\x01\x90a\rqV[V[\x93\x92\x93ak\x07a9KV[Pak\x10aj\x87V[Pak\x19a/vV[Pak#\x85aj\x8BV[akUakO\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0aj\xA2V[\x91a\x07\x94V[\x11ak\xE2W\x90akx` \x94\x95_\x94\x93\x92\x93akoa\x05\x12V[\x94\x85\x94\x85aj\xBEV[\x83\x80R\x03\x90`\x01Z\xFA\x15ak\xDDWak\x90_Qa\x1C\0V[\x80ak\xABak\xA5ak\xA0_a+\0V[a\x07eV[\x91a\x07eV[\x14ak\xC1W_\x91ak\xBB_a\x1C\x05V[\x91\x92\x91\x90V[Pak\xCB_a+\0V[`\x01\x91ak\xD7_a\x1C\x05V[\x91\x92\x91\x90V[a,\xE0V[PPPak\xEE_a+\0V[\x90`\x03\x92\x91\x92\x91\x90V[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x04\x11\x15al\x16WV[ak\xF8V[\x90al%\x82al\x0CV[V[\x80al:al4_al\x1BV[\x91al\x1BV[\x14_\x14alEWPPV[\x80alYalS`\x01al\x1BV[\x91al\x1BV[\x14_\x14al|W_c\xF6E\xEE\xDF`\xE0\x1B\x81R\x80alx`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x80al\x90al\x8A`\x02al\x1BV[\x91al\x1BV[\x14_\x14al\xBEWal\xBAal\xA3\x83aj\x8BV[_\x91\x82\x91c\xFC\xE6\x98\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x08HV[\x03\x90\xFD[al\xD1al\xCB`\x03al\x1BV[\x91al\x1BV[\x14al\xD9WPV[al\xF4\x90_\x91\x82\x91c5\xE2\xF3\x83`\xE2\x1B\x83R`\x04\x83\x01a\r~V[\x03\x90\xFD[_R` _ \x90V[am\n\x81aQ\\V[\x82\x10\x15am$Wam\x1C`\x01\x91al\xF8V[\x91\x02\x01\x90_\x90V[a\x0E\xD7V[\x90am3\x90a\x19uV[\x90RV[\x90amA\x90a$\x15V[\x90RV[\x90am{amr_amUaKvV[\x94amlamd\x83\x83\x01aQ\xA1V[\x83\x88\x01am)V[\x01aQ\xD3V[` \x84\x01am7V[V[am\x86\x90amEV[\x90V[am\xA7\x91_am\xA1\x92am\x9AaK\xB1V[P\x01am\x01V[Pam}V[\x90V[\x92\x91am\xB8\x84\x83\x83\x91ap\"V[\x83am\xD3am\xCDam\xC8_a+\0V[a\x07eV[\x91a\x07eV[\x14am\xE8W[am\xE6\x92\x93\x91\x90\x91aq\xACV[V[am\xF0a*\x98V[\x93am\xF9aq\x91V[\x94\x80an\ran\x07\x88a\x07\x94V[\x91a\x07\x94V[\x11an\x1AWP\x93Pam\xD9V[\x85\x90an6_\x92\x83\x92c\x0EX\xAE\x93`\xE1\x1B\x84R`\x04\x84\x01a\n\x98V[\x03\x90\xFD[anBa'\x97V[P\x15\x15\x90V[anmans\x92anWa'\x97V[P\x82\x81\x16\x92\x18ang`\x02aM\xBFV[\x90a-}V[\x90a0XV[\x90V[an\x90an\x96\x92\x93an\x86a'\x97V[P\x80\x94\x18\x91an:V[\x90a_RV[\x18\x90V[cNH{q_R` R`$`\x1C\xFD[\x90V[an\xC1an\xBCan\xC6\x92an\xAAV[a\x06\x87V[a\x0E\\V[\x90V[an\xD2\x90an\xADV[\x90RV[\x91` an\xF7\x92\x94\x93an\xF0`@\x82\x01\x96_\x83\x01\x90an\xC9V[\x01\x90a\x08;V[V[ao\rao\x08ao\x12\x92a\x07\x94V[a\x06\x87V[a$\x15V[\x90V[ao\x1Da%HV[P\x80ao7ao1`\x01\x80`\xD0\x1B\x03a6QV[\x91a\x07\x94V[\x11aoHWaoE\x90an\xF9V[\x90V[`\xD0aod_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01an\xD6V[\x03\x90\xFD[\x90ao\x9Eao\xA4\x93\x92aoya%HV[Pao\x82a%HV[P\x80\x93ao\x97ao\x90a>HV[\x94\x92aX\x01V[\x90\x91av\x14V[\x91arkV[\x91\x90\x91\x90V[ao\xBEao\xB9ao\xC3\x92a]\xEAV[a\x06\x87V[a\x07\x94V[\x90V[6\x907V[\x90ao\xF0ao\xD8\x83a8\x93V[\x92` \x80ao\xE6\x86\x93a8pV[\x92\x01\x91\x03\x90ao\xC6V[V[ao\xFAa&!V[Pap\x04\x81ar\xD5V[\x90ap\x17ap\x12` ao\xAAV[ao\xCBV[\x91\x82R` \x82\x01R\x90V[\x91\x90\x91\x80ap@ap:ap5_a+\0V[a\x07eV[\x91a\x07eV[\x14_\x14aq!Wapdap]\x83apX`\x02a\x11\x1AV[a0XV[`\x02a+gV[[\x82ap\x80apzapu_a+\0V[a\x07eV[\x91a\x07eV[\x14_\x14ap\xF5Wap\xA4ap\x9D\x83ap\x98`\x02a\x11\x1AV[aL[V[`\x02a+gV[[\x91\x90\x91ap\xF0ap\xDEap\xD8\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x93a\x10\xDFV[\x93a\x10\xDFV[\x93ap\xE7a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xA3V[aq\x1C\x82aq\x16aq\x07_\x87\x90a:\xDCV[\x91aq\x11\x83a\x11\x1AV[a_\x82V[\x90a+gV[ap\xA5V[aq4aq/_\x83\x90a:\xDCV[a\x11\x1AV[\x80aqGaqA\x85a\x07\x94V[\x91a\x07\x94V[\x10aqoWaqZaqj\x91\x84\x90aL[V[aqe_\x84\x90a:\xDCV[a+gV[apeV[\x90aq\x8D\x90\x91\x92_\x93\x84\x93c9\x144\xE3`\xE2\x1B\x85R`\x04\x85\x01aL)V[\x03\x90\xFD[aq\x99a'\x97V[Paq\xA9`\x01\x80`\xD0\x1B\x03a6QV[\x90V[\x91ar\x04aq\xFEar\x0B\x94\x80aq\xD2aq\xCCaq\xC7_a+\0V[a\x07eV[\x91a\x07eV[\x14ar<W[\x84aq\xF3aq\xEDaq\xE8_a+\0V[a\x07eV[\x91a\x07eV[\x14ar\rW[a9\x91V[\x92a9\x91V[\x90\x91af_V[V[ar5`\x0B`\x02ar/ar)ar#\x89ao\x15V[\x93a6NV[\x91af\\V[\x90aohV[PPaq\xF9V[ard`\x0B`\x01ar^arXarR\x89ao\x15V[\x93a6NV[\x91af\\V[\x90aohV[PPaq\xD8V[\x91ar\x8F_ar\x94\x94ar|a%HV[Par\x85a%HV[P\x01\x92\x91\x92aQ\x7FV[at\xC6V[\x91\x90\x91\x90V[ar\xAEar\xA9ar\xB3\x92ah\xFCV[a\x06\x87V[a\x07\x94V[\x90V[\x90V[ar\xCDar\xC8ar\xD2\x92ar\xB6V[a\x06\x87V[a\x07\x94V[\x90V[ar\xEAar\xEF\x91ar\xE4a'\x97V[Pa/zV[aj\x8BV[ar\xF9`\xFFar\x9AV[\x16\x80as\x0Eas\x08`\x1Far\xB9V[\x91a\x07\x94V[\x11as\x16W\x90V[_c,\xD4J\xC3`\xE2\x1B\x81R\x80as.`\x04\x82\x01a\t\x13V[\x03\x90\xFD[T\x90V[as@`@a8[V[\x90V[_R` _ \x90V[asU\x81as2V[\x82\x10\x15asoWasg`\x01\x91asCV[\x91\x02\x01\x90_\x90V[a\x0E\xD7V[as~\x90Qa\x19uV[\x90V[\x90as\x92e\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x1C\0V[\x91\x81\x19\x16\x91\x16\x17\x90V[as\xB0as\xABas\xB5\x92a\x19uV[a\x06\x87V[a\x19uV[\x90V[\x90V[\x90as\xD0as\xCBas\xD7\x92as\x9CV[as\xB8V[\x82Tas\x81V[\x90UV[as\xE5\x90Qa$\x15V[\x90V[`0\x1B\x90V[\x90at\0e\xFF\xFF\xFF\xFF\xFF\xFF\x19\x91as\xE8V[\x91\x81\x19\x16\x91\x16\x17\x90V[at\x1Eat\x19at#\x92a$\x15V[a\x06\x87V[a$\x15V[\x90V[\x90V[\x90at>at9atE\x92at\nV[at&V[\x82Tas\xEEV[\x90UV[\x90ats` _aty\x94atk\x82\x82\x01ate\x84\x88\x01astV[\x90as\xBBV[\x01\x92\x01as\xDBV[\x90at)V[V[\x91\x90at\x8CWat\x8A\x91atIV[V[a\x0B^V[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15at\xC1W\x82at\xB9\x91`\x01at\xBF\x95\x01\x81UasLV[\x90at{V[V[a\x0CZV[\x90\x92\x91\x92at\xD2a%HV[Pat\xDBa%HV[Pat\xE5\x82as2V[\x80at\xF8at\xF2_a*\xC8V[\x91a\x07\x94V[\x11_\x14au\xC8Wau\x1E\x90au\x18\x84\x91au\x12`\x01aDGV[\x90a,\xF0V[\x90ab\xFBV[\x90au*_\x83\x01aQ\xA1V[\x92au6_\x84\x01aQ\xD3V[\x93\x80auJauD\x85a\x19uV[\x91a\x19uV[\x11au\xACWauaau[\x84a\x19uV[\x91a\x19uV[\x14_\x14au|WPPauw\x90_\x85\x91\x01at)V[[\x91\x90V[au\xA7\x92Pau\xA2\x86au\x99au\x90as6V[\x94_\x86\x01am)V[` \x84\x01am7V[at\x91V[auxV[_c% `\x1D`\xE0\x1B\x81R\x80au\xC4`\x04\x82\x01a\t\x13V[\x03\x90\xFD[Pau\xF3\x91au\xEE\x85au\xE5au\xDCas6V[\x94_\x86\x01am)V[` \x84\x01am7V[at\x91V[au\xFC_aQ\xE0V[\x91\x90V[cNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[\x91\x90\x91\x80`\x01\x14av3W`\x02\x03av\0Wav/\x91a%\xC7V[\x90[V[Pav=\x91a%\x88V[\x90av1V",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361015610013575b612544565b61001d5f3561050c565b806301ffc9a71461050757806306fdde031461050257806307a1d5fa146104fd578063095ea7b3146104f85780630c05f82c146104f357806313beaa5b146104ee57806318160ddd146104e95780631b02f845146104e457806322a97d9c146104df57806323b872dd146104da57806323e460d2146104d5578063243a30cc146104d05780632481bb5c146104cb578063248a9ca3146104c6578063284e1333146104c15780632f2ff15d146104bc578063313ce567146104b7578063334d0bbd146104b2578063359b76fe146104ad5780633644e515146104a857806336568abe146104a35780633a46b1a81461049e5780633f4ba83a1461049957806340c10f191461049457806344e181aa1461048f57806348b0daa61461048a5780634bdd36ce146104855780634bf5d7e914610480578063587cde1e1461047b5780635adf0021146104765780635c19a95c146104715780635c975abb1461046c5780635f15c3c914610467578063651fd268146104625780636c33bced1461045d5780636cf01625146104585780636fc063be146104535780636fcfff451461044e57806370a0823114610449578063726600ce14610444578063766718081461043f5780637c790cab1461043a5780637ecebe00146104355780638456cb591461043057806384b0196e1461042b5780638e539e8c14610426578063902d55a51461042157806391d148541461041c57806391ddadf41461041757806395d89b411461041257806399127d9b1461040d578063998955d3146104085780639ab24eb0146104035780639b7ef64b146103fe5780639dc29fac146103f9578063a08d5654146103f4578063a217fddf146103ef578063a3d4485b146103ea578063a4d7e31d146103e5578063a571e184146103e0578063a5b326be146103db578063a70b9f0c146103d6578063a9059cbb146103d1578063ae5ecbc6146103cc578063af2aa63b146103c7578063b0ca253e146103c2578063babc394f146103bd578063bb4d4436146103b8578063c02ae754146103b3578063c1eb7137146103ae578063c3cda520146103a9578063d505accf146103a4578063d547741f1461039f578063dd62ed3e1461039a578063e3abdfcb14610395578063e63ab1e914610390578063f1127ed81461038b578063f508e19d146103865763f75e85120361000e5761250f565b6124ab565b612466565b612383565b61231f565b6122ba565b612259565b61221f565b612175565b6120b9565b612084565b61204f565b612016565b611fa2565b611f6d565b611ec3565b611e4f565b611e1a565b611dac565b611d79565b611cf7565b611cc2565b611c38565b611bc9565b611b5b565b611b26565b611aaf565b611a7a565b611a45565b6119d7565b6119a2565b61193f565b61190a565b611893565b611857565b611712565b6116dd565b6116a4565b611622565b6115de565b6115a9565b611574565b611514565b6114b0565b61143c565b611407565b6113d2565b611366565b611333565b6112fe565b6112c9565b611272565b61123d565b611208565b6111c0565b6110ab565b611078565b611042565b61100e565b610fd9565b610fa6565b610f71565b610e84565b610e28565b610dc8565b610d93565b610cf8565b610b29565b610abb565b610a62565b6109f3565b610981565b61094c565b610918565b61085d565b6107e7565b61072f565b610647565b610598565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b63ffffffff60e01b1690565b61053981610524565b0361054057565b5f80fd5b9050359061055182610530565b565b9060208282031261056c57610569915f01610544565b90565b61051c565b151590565b61057f90610571565b9052565b9190610596905f60208501940190610576565b565b346105c8576105c46105b36105ae366004610553565b6125e1565b6105bb610512565b91829182610583565b0390f35b610518565b5f9103126105d757565b61051c565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b61061d61062660209361062b93610614816105dc565b938480936105e0565b958691016105e9565b6105f4565b0190565b6106449160208201915f8184039101526105fe565b90565b34610677576106573660046105cd565b6106736106626126ff565b61066a610512565b9182918261062f565b0390f35b610518565b60018060a01b031690565b90565b61069e6106996106a39261067c565b610687565b61067c565b90565b6106af9061068a565b90565b6106bb906106a6565b90565b6106c7906106b2565b9052565b5190565b60209181520190565b6106f7610700602093610705936106ee816106cb565b938480936106cf565b958691016105e9565b6105f4565b0190565b9161072c9261071f60408201935f8301906106be565b60208184039101526106d8565b90565b346107605761073f3660046105cd565b61074761274b565b9061075c610753610512565b92839283610709565b0390f35b610518565b61076e9061067c565b90565b61077a81610765565b0361078157565b5f80fd5b9050359061079282610771565b565b90565b6107a081610794565b036107a757565b5f80fd5b905035906107b882610797565b565b91906040838203126107e257806107d66107df925f8601610785565b936020016107ab565b90565b61051c565b34610818576108146108036107fd3660046107ba565b90612775565b61080b610512565b91829182610583565b0390f35b610518565b9060208282031261083657610833915f01610785565b90565b61051c565b61084490610794565b9052565b919061085b905f6020850194019061083b565b565b3461088d5761088961087861087336600461081d565b61279b565b610880610512565b91829182610848565b0390f35b610518565b5f80fd5b5f80fd5b5f80fd5b909182601f830112156108d85781359167ffffffffffffffff83116108d35760200192600183028401116108ce57565b61089a565b610896565b610892565b9060208282031261090e575f82013567ffffffffffffffff811161090957610905920161089e565b9091565b610520565b61051c565b5f0190565b346109475761093161092b3660046108dd565b90612a8c565b610939610512565b8061094381610913565b0390f35b610518565b3461097c5761095c3660046105cd565b610978610967612a98565b61096f610512565b91829182610848565b0390f35b610518565b346109af576109913660046105cd565b610999612c64565b6109a1610512565b806109ab81610913565b0390f35b610518565b1c90565b60ff1690565b6109ce9060086109d393026109b4565b6109b8565b90565b906109e191546109be565b90565b6109f060405f906109d6565b90565b34610a2357610a033660046105cd565b610a1f610a0e6109e4565b610a16610512565b91829182610583565b0390f35b610518565b9091606082840312610a5d57610a5a610a43845f8501610785565b93610a518160208601610785565b936040016107ab565b90565b61051c565b34610a9357610a8f610a7e610a78366004610a28565b91612c6e565b610a86610512565b91829182610583565b0390f35b610518565b916020610ab9929493610ab260408201965f83019061083b565b019061083b565b565b34610aec57610ad3610ace36600461081d565b612d9f565b90610ae8610adf610512565b92839283610a98565b0390f35b610518565b90565b610b08610b03610b0d92610af1565b610687565b610794565b90565b610b1b610e10610af4565b90565b610b26610b10565b90565b34610b5957610b393660046105cd565b610b55610b44610b1e565b610b4c610512565b91829182610848565b0390f35b610518565b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52602260045260245ffd5b9060016002830492168015610ba5575b6020831014610ba057565b610b71565b91607f1691610b95565b60209181520190565b5f5260205f2090565b905f9291805490610bdb610bd483610b85565b8094610baf565b916001811690815f14610c325750600114610bf6575b505050565b610c039192939450610bb8565b915f925b818410610c1a57505001905f8080610bf1565b60018160209295939554848601520191019290610c07565b92949550505060ff19168252151560200201905f8080610bf1565b90610c5791610bc1565b90565b634e487b7160e01b5f52604160045260245ffd5b90610c78906105f4565b810190811067ffffffffffffffff821117610c9257604052565b610c5a565b90610cb7610cb092610ca7610512565b93848092610c4d565b0383610c6e565b565b905f10610ccc57610cc990610c97565b90565b610b5e565b610cdd60455f90610cb9565b90565b610cf59160208201915f8184039101526106d8565b90565b34610d2857610d083660046105cd565b610d24610d13610cd1565b610d1b610512565b91829182610ce0565b0390f35b610518565b90565b610d3981610d2d565b03610d4057565b5f80fd5b90503590610d5182610d30565b565b90602082820312610d6c57610d69915f01610d44565b90565b61051c565b610d7a90610d2d565b9052565b9190610d91905f60208501940190610d71565b565b34610dc357610dbf610dae610da9366004610d53565b612fc0565b610db6610512565b91829182610d7e565b0390f35b610518565b34610df657610dd83660046105cd565b610de06134be565b610de8610512565b80610df281610913565b0390f35b610518565b9190604083820312610e235780610e17610e20925f8601610d44565b93602001610785565b90565b61051c565b34610e5757610e41610e3b366004610dfb565b906134f2565b610e49610512565b80610e5381610913565b0390f35b610518565b60ff1690565b610e6b90610e5c565b9052565b9190610e82905f60208501940190610e62565b565b34610eb457610e943660046105cd565b610eb0610e9f613521565b610ea7610512565b91829182610e6f565b0390f35b610518565b90602082820312610ed257610ecf915f016107ab565b90565b61051c565b634e487b7160e01b5f52603260045260245ffd5b50603090565b90565b610efd81610eeb565b821015610f1757610f0f600191610ef1565b910201905f90565b610ed7565b90565b610f2f906008610f3493026109b4565b610f1c565b90565b90610f429154610f1f565b90565b6010610f5081610eeb565b821015610f6d57610f6a91610f6491610ef4565b90610f37565b90565b5f80fd5b34610fa157610f9d610f8c610f87366004610eb9565b610f45565b610f94610512565b91829182610848565b0390f35b610518565b34610fd457610fb63660046105cd565b610fbe6135d2565b610fc6610512565b80610fd081610913565b0390f35b610518565b3461100957610fe93660046105cd565b611005610ff46135dc565b610ffc610512565b91829182610d7e565b0390f35b610518565b3461103d57611027611021366004610dfb565b906135f0565b61102f610512565b8061103981610913565b0390f35b610518565b346110735761106f61105e6110583660046107ba565b9061366d565b611066610512565b91829182610848565b0390f35b610518565b346110a6576110883660046105cd565b6110906136cb565b611098610512565b806110a281610913565b0390f35b610518565b346110da576110c46110be3660046107ba565b90613828565b6110cc610512565b806110d681610913565b0390f35b610518565b6110e8906106a6565b90565b906110f5906110df565b5f5260205260405f2090565b5f1c90565b61111261111791611101565b610f1c565b90565b6111249054611106565b90565b61113290600d6110eb565b61113d5f820161111a565b9161114a6001830161111a565b916111576002820161111a565b9161117060046111696003850161111a565b930161111a565b90565b909594926111be946111ad6111b7926111a360809661119960a088019c5f89019061083b565b602087019061083b565b604085019061083b565b606083019061083b565b019061083b565b565b346111f4576111f06111db6111d636600461081d565b611127565b916111e7959395610512565b95869586611173565b0390f35b610518565b61120560415f90610f37565b90565b34611238576112183660046105cd565b6112346112236111f9565b61122b610512565b91829182610848565b0390f35b610518565b3461126d5761124d3660046105cd565b611269611258613834565b611260610512565b91829182610848565b0390f35b610518565b346112a2576112823660046105cd565b61129e61128d6138f5565b611295610512565b9182918261062f565b0390f35b610518565b6112b090610765565b9052565b91906112c7905f602085019401906112a7565b565b346112f9576112f56112e46112df36600461081d565b613991565b6112ec610512565b918291826112b4565b0390f35b610518565b3461132e5761130e3660046105cd565b61132a6113196139b0565b611321610512565b91829182610583565b0390f35b610518565b346113615761134b61134636600461081d565b6139d9565b611353610512565b8061135d81610913565b0390f35b610518565b34611396576113763660046105cd565b6113926113816139ec565b611389610512565b91829182610583565b0390f35b610518565b90565b6113b26113ad6113b79261139b565b610687565b610794565b90565b6113c4603061139e565b90565b6113cf6113ba565b90565b34611402576113e23660046105cd565b6113fe6113ed6113c7565b6113f5610512565b91829182610848565b0390f35b610518565b346114375761143361142261141d36600461081d565b613a02565b61142a610512565b91829182610848565b0390f35b610518565b3461146a5761144c3660046105cd565b611454613ab9565b61145c610512565b8061146681610913565b0390f35b610518565b90565b61148661148161148b9261146f565b610687565b610794565b90565b6114a26a52b7d2dcc80cd2e4000000611472565b90565b6114ad61148e565b90565b346114e0576114c03660046105cd565b6114dc6114cb6114a5565b6114d3610512565b91829182610848565b0390f35b610518565b906114ef906110df565b5f5260205260405f2090565b6115119061150c600e915f926114e5565b6109d6565b90565b346115445761154061152f61152a36600461081d565b6114fb565b611537610512565b91829182610583565b0390f35b610518565b63ffffffff1690565b61155b90611549565b9052565b9190611572905f60208501940190611552565b565b346115a4576115a061158f61158a36600461081d565b613ac7565b611597610512565b9182918261155f565b0390f35b610518565b346115d9576115d56115c46115bf36600461081d565b613af2565b6115cc610512565b91829182610848565b0390f35b610518565b3461160e5761160a6115f96115f436600461081d565b613b10565b611601610512565b91829182610583565b0390f35b610518565b61161f60425f90610f37565b90565b34611652576116323660046105cd565b61164e61163d611613565b611645610512565b91829182610848565b0390f35b610518565b909594926116a29461169161169b9261168760809661167d60a088019c5f890190610576565b602087019061083b565b604085019061083b565b606083019061083b565b019061083b565b565b346116d8576116d46116bf6116ba36600461081d565b613b2f565b916116cb959395610512565b95869586611657565b0390f35b610518565b3461170d576117096116f86116f336600461081d565b613c9f565b611700610512565b91829182610848565b0390f35b610518565b34611740576117223660046105cd565b61172a613cd8565b611732610512565b8061173c81610913565b0390f35b610518565b60ff60f81b1690565b61175790611745565b9052565b5190565b60209181520190565b60200190565b61177790610794565b9052565b906117888160209361176e565b0190565b60200190565b906117af6117a96117a28461175b565b809361175f565b92611768565b905f5b8181106117bf5750505090565b9091926117d86117d2600192865161177b565b9461178c565b91019190916117b2565b939591946118336118286118479561181a61183d956118549c9a61180d60e08c01925f8d019061174e565b8a820360208c01526105fe565b9088820360408a01526105fe565b97606087019061083b565b60808501906112a7565b60a0830190610d71565b60c0818403910152611792565b90565b3461188e576118673660046105cd565b61188a611872613d5f565b93611881979597939193610512565b978897886117e2565b0390f35b610518565b346118c3576118bf6118ae6118a9366004610eb9565b613de9565b6118b6610512565b91829182610848565b0390f35b610518565b90565b6118df6118da6118e4926118c8565b610687565b610794565b90565b6118fc6b033b2e3c9fd0803ce80000006118cb565b90565b6119076118e7565b90565b3461193a5761191a3660046105cd565b6119366119256118ff565b61192d610512565b91829182610848565b0390f35b610518565b346119705761196c61195b611955366004610dfb565b90613e1a565b611963610512565b91829182610583565b0390f35b610518565b65ffffffffffff1690565b61198990611975565b9052565b91906119a0905f60208501940190611980565b565b346119d2576119b23660046105cd565b6119ce6119bd613e48565b6119c5610512565b9182918261198d565b0390f35b610518565b34611a07576119e73660046105cd565b611a036119f2613e5c565b6119fa610512565b9182918261062f565b0390f35b610518565b90565b611a23611a1e611a2892611a0c565b610687565b610794565b90565b611a3762015180611a0f565b90565b611a42611a2b565b90565b34611a7557611a553660046105cd565b611a71611a60611a3a565b611a68610512565b91829182610848565b0390f35b610518565b34611aaa57611aa6611a95611a9036600461081d565b613e72565b611a9d610512565b91829182610848565b0390f35b610518565b34611adf57611adb611aca611ac536600461081d565b613ecd565b611ad2610512565b91829182610848565b0390f35b610518565b90565b611afb611af6611b0092611ae4565b610687565b610794565b90565b611b186b02e87669c308736a04000000611ae7565b90565b611b23611b03565b90565b34611b5657611b363660046105cd565b611b52611b41611b1b565b611b49610512565b91829182610848565b0390f35b610518565b34611b8a57611b74611b6e3660046107ba565b9061404f565b611b7c610512565b80611b8681610913565b0390f35b610518565b9091606082840312611bc457611bc1611baa845f8501610785565b93611bb881602086016107ab565b936040016107ab565b90565b61051c565b34611bf857611be2611bdc366004611b8f565b916142d5565b611bea610512565b80611bf481610913565b0390f35b610518565b90565b5f1b90565b611c19611c14611c1e92611bfd565b611c00565b610d2d565b90565b611c2a5f611c05565b90565b611c35611c21565b90565b34611c6857611c483660046105cd565b611c64611c53611c2d565b611c5b610512565b91829182610d7e565b0390f35b610518565b60018060a01b031690565b611c88906008611c8d93026109b4565b611c6d565b90565b90611c9b9154611c78565b90565b611caa60445f90611c90565b90565b9190611cc0905f602085019401906106be565b565b34611cf257611cd23660046105cd565b611cee611cdd611c9e565b611ce5610512565b91829182611cad565b0390f35b610518565b34611d2757611d073660046105cd565b611d23611d126142e2565b611d1a610512565b91829182610583565b0390f35b610518565b611d3590610765565b90565b611d4181611d2c565b03611d4857565b5f80fd5b90503590611d5982611d38565b565b90602082820312611d7457611d71915f01611d4c565b90565b61051c565b34611da757611d91611d8c366004611d5b565b614439565b611d99610512565b80611da381610913565b0390f35b610518565b34611ddc57611dbc3660046105cd565b611dd8611dc7614463565b611dcf610512565b91829182610848565b0390f35b610518565b90565b611df8611df3611dfd92611de1565b610687565b610794565b90565b611e0c62278d00611de4565b90565b611e17611e00565b90565b34611e4a57611e2a3660046105cd565b611e46611e35611e0f565b611e3d610512565b91829182610848565b0390f35b610518565b34611e8057611e7c611e6b611e653660046107ba565b906144dd565b611e73610512565b91829182610583565b0390f35b610518565b90565b611e9c611e97611ea192611e85565b610687565b610794565b90565b611eb5670de0b6b3a7640000611e88565b90565b611ec0611ea4565b90565b34611ef357611ed33660046105cd565b611eef611ede611eb8565b611ee6610512565b91829182610848565b0390f35b610518565b50603090565b905090565b90565b60200190565b611f28611f22611f1b83611ef8565b8094611efe565b91611f03565b5f915b838310611f385750505050565b611f4e611f48600192845161177b565b92611f06565b92019190611f2b565b9190611f6b905f6106008501940190611f0c565b565b34611f9d57611f7d3660046105cd565b611f99611f88614604565b611f90610512565b91829182611f57565b0390f35b610518565b34611fd357611fcf611fbe611fb83660046107ba565b9061461a565b611fc6610512565b91829182610848565b0390f35b610518565b61200d61201494612003606094989795611ff9608086019a5f87019061083b565b602085019061083b565b604083019061083b565b0190610576565b565b3461204a576120263660046105cd565b612046612031614630565b9061203d949294610512565b94859485611fd8565b0390f35b610518565b3461207f5761207b61206a61206536600461081d565b614807565b612072610512565b91829182610848565b0390f35b610518565b346120b4576120943660046105cd565b6120b061209f61481c565b6120a7610512565b91829182610848565b0390f35b610518565b346120e9576120e56120d46120cf36600461081d565b614830565b6120dc610512565b91829182610848565b0390f35b610518565b6120f781610e5c565b036120fe57565b5f80fd5b9050359061210f826120ee565b565b909160c08284031261217057612129835f8401610785565b9261213781602085016107ab565b9261214582604083016107ab565b9261216d6121568460608501612102565b936121648160808601610d44565b9360a001610d44565b90565b61051c565b346121aa57612194612188366004612111565b949390939291926148ba565b61219c610512565b806121a681610913565b0390f35b610518565b60e08183031261221a576121c5825f8301610785565b926121d38360208401610785565b926121e181604085016107ab565b926121ef82606083016107ab565b926122176122008460808501612102565b9361220e8160a08601610d44565b9360c001610d44565b90565b61051c565b346122545761223e6122323660046121af565b95949094939193614a0e565b612246610512565b8061225081610913565b0390f35b610518565b346122885761227261226c366004610dfb565b90614b2c565b61227a610512565b8061228481610913565b0390f35b610518565b91906040838203126122b557806122a96122b2925f8601610785565b93602001610785565b90565b61051c565b346122eb576122e76122d66122d036600461228d565b90614b4e565b6122de610512565b91829182610848565b0390f35b610518565b7f6b9725f740f94b91b78060a1b17d1774656d381421a529ec98cdb013f4d9c25e90565b61231c6122f0565b90565b3461234f5761232f3660046105cd565b61234b61233a612314565b612342610512565b91829182610d7e565b0390f35b610518565b7f65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a90565b612380612354565b90565b346123b3576123933660046105cd565b6123af61239e612378565b6123a6610512565b91829182610d7e565b0390f35b610518565b6123c181611549565b036123c857565b5f80fd5b905035906123d9826123b8565b565b919060408382031261240357806123f7612400925f8601610785565b936020016123cc565b90565b61051c565b61241190611975565b9052565b60018060d01b031690565b61242990612415565b9052565b9060208061244f936124455f8201515f860190612408565b0151910190612420565b565b9190612464905f6040850194019061242d565b565b346124975761249361248261247c3660046123db565b90614bbc565b61248a610512565b91829182612451565b0390f35b610518565b6124a860435f90610f37565b90565b346124db576124bb3660046105cd565b6124d76124c661249c565b6124ce610512565b91829182610848565b0390f35b610518565b7fcce296b040332a080e6df13515a3ec2869e21cd20f7344af0987ddb938d8bd2190565b61250c6124e0565b90565b3461253f5761251f3660046105cd565b61253b61252a612504565b612532610512565b91829182610d7e565b0390f35b610518565b5f80fd5b5f90565b634e487b7160e01b5f52601160045260245ffd5b61256c61257291612415565b91612415565b019060018060d01b03821161258357565b61254c565b9061259b91612595612548565b50612560565b90565b6125aa6125b091612415565b91612415565b90039060018060d01b0382116125c257565b61254c565b906125da916125d4612548565b5061259e565b90565b5f90565b6125e96125dd565b50806126046125fe637965db0b60e01b610524565b91610524565b14908115612611575b5090565b61261b9150614bd2565b5f61260d565b606090565b60209181520190565b5f5260205f2090565b905f929180549061265261264b83610b85565b8094612626565b916001811690815f146126a9575060011461266d575b505050565b61267a919293945061262f565b915f925b81841061269157505001905f8080612668565b6001816020929593955484860152019101929061267e565b92949550505060ff19168252151560200201905f8080612668565b906126ce91612638565b90565b906126f16126ea926126e1610512565b938480926126c4565b0383610c6e565b565b6126fc906126d1565b90565b612707612621565b5061271260036126f3565b90565b5f90565b606090565b61272a61272f91611101565b611c6d565b90565b61273c905461271e565b90565b61274890610c97565b90565b612753612715565b5061275c612719565b506127676044612732565b90612772604561273f565b90565b612792916127816125dd565b5061278a614bf8565b919091614c05565b600190565b5f90565b5f6127b36127b9926127ab612797565b50600d6110eb565b0161111a565b90565b906127d6916127d16127cc6124e0565b614c15565b612a36565b565b5090565b601f602091010490565b1b90565b919060086128059102916127ff5f19846127e6565b926127e6565b9181191691161790565b61282361281e61282892610794565b610687565b610794565b90565b90565b919061284461283f61284c9361280f565b61282b565b9083546127ea565b9055565b6128629161285c612797565b9161282e565b565b5b818110612870575050565b8061287d5f600193612850565b01612865565b9190601f8111612893575b505050565b61289f6128c493610bb8565b9060206128ab846127dc565b830193106128cc575b6128bd906127dc565b0190612864565b5f808061288e565b91506128bd819290506128b4565b906128ea905f19906008026109b4565b191690565b816128f9916128da565b906002021790565b9161290c90826127d8565b9067ffffffffffffffff82116129cb576129308261292a8554610b85565b85612883565b5f90601f831160011461296357918091612952935f92612957575b50506128ef565b90555b565b90915001355f8061294b565b601f1983169161297285610bb8565b925f5b8181106129b357509160029391856001969410612999575b50505002019055612955565b6129a9910135601f8416906128da565b90555f808061298d565b91936020600181928787013581550195019201612975565b610c5a565b906129db9291612901565b565b90825f939282370152565b9190612a02816129fb81612a07956106cf565b80956129dd565b6105f4565b0190565b91612a25612a33949260408501908582035f8701526106d8565b9260208185039101526129e8565b90565b90612a41604561273f565b612a4e83839060456129d0565b919091612a877fb9a2088426f03b30a81c06428094fbfa9e2692739b3241af6b9ab1da4b5546be93612a7e610512565b93849384612a0b565b0390a1565b90612a96916127bc565b565b612aa0612797565b50612aab600261111a565b90565b612abe612ab96122f0565b614c15565b612ac6612b87565b565b612adc612ad7612ae192611bfd565b610687565b610794565b90565b612af8612af3612afd92611bfd565b610687565b61067c565b90565b612b0990612ae4565b90565b90612b1860ff91611c00565b9181191691161790565b612b2b90610571565b90565b90565b90612b46612b41612b4d92612b22565b612b2e565b8254612b0c565b9055565b90612b5d5f1991611c00565b9181191691161790565b90612b7c612b77612b839261280f565b61282b565b8254612b51565b9055565b612b91604161111a565b612ba3612b9d5f612ac8565b91610794565b03612c4857612bba612bb56044612732565b6106b2565b612bd4612bce612bc95f612b00565b610765565b91610765565b14612c2c57612be560016040612b31565b612bf0426041612b67565b42612c277f1194b034cfa9ab5807494a1d5c667d8b0e6e97f38888742aa3871a322034116091612c1e610512565b91829182610848565b0390a1565b5f633b0a48bd60e11b815280612c4460048201610913565b0390fd5b5f6338e93dbd60e11b815280612c6060048201610913565b0390fd5b612c6c612aae565b565b91612c9892612c7b6125dd565b50612c90612c87614bf8565b82908491614c69565b919091614cf5565b600190565b612ca6906106a6565b90565b5f80fd5b60e01b90565b90505190612cc082610797565b565b90602082820312612cdb57612cd8915f01612cb3565b90565b61051c565b612ce8610512565b3d5f823e3d90fd5b612cff612d0591939293610794565b92610794565b8203918211612d1057565b61254c565b90565b612d2c612d27612d3192612d15565b610687565b610794565b90565b612d43612d4991939293610794565b92610794565b91612d55838202610794565b928184041490151715612d6457565b61254c565b634e487b7160e01b5f52601260045260245ffd5b612d89612d8f91610794565b91610794565b908115612d9a570490565b612d69565b612da7612797565b91612db0612797565b91612dc75f612dc1600d84906110eb565b0161111a565b90612ddf6002612dd9600d84906110eb565b0161111a565b91612e186020612dee30612c9d565b63651fd26890612e0d8692612e01610512565b95869485938493612cad565b8352600483016112b4565b03915afa908115612f7157612e63916020915f91612f44575b5093612e3c30612c9d565b612e5863998955d3612e4c610512565b95869485938493612cad565b8352600483016112b4565b03915afa908115612f3f575f91612f11575b509181612e8a612e845f612ac8565b91610794565b11612ee0575b505081612ea5612e9f5f612ac8565b91610794565b11612eaf575b5050565b612ed8929350612ec2612ed39183612cf0565b612ecd612710612d18565b90612d34565b612d7d565b905f80612eab565b612f09929650612ef3612f049183612cf0565b612efe612710612d18565b90612d34565b612d7d565b935f80612e90565b612f32915060203d8111612f38575b612f2a8183610c6e565b810190612cc2565b5f612e75565b503d612f20565b612ce0565b612f649150823d8111612f6a575b612f5c8183610c6e565b810190612cc2565b5f612e31565b503d612f52565b612ce0565b5f90565b612f8390610d2d565b90565b90612f9090612f7a565b5f5260205260405f2090565b90565b612fab612fb091611101565b612f9c565b90565b612fbd9054612f9f565b90565b6001612fd9612fdf92612fd1612f76565b506005612f86565b01612fb3565b90565b612fea614d92565b612ff2612ff4565b565b612ffc614de8565b61300461300e565b61300c614e4d565b565b61301e6130196122f0565b614c15565b613026613158565b565b61303461303991611101565b6109b8565b90565b6130469054613028565b90565b60016130559101610794565b90565b61306761306d91939293610794565b92610794565b820180921161307857565b61254c565b613086906106a6565b90565b5f91031261309357565b61051c565b905f92918054906130b26130ab83610b85565b80946106cf565b916001811690815f1461310957506001146130cd575b505050565b6130da9192939450610bb8565b915f925b8184106130f157505001905f80806130c8565b600181602092959395548486015201910192906130de565b92949550505060ff19168252151560200201905f80806130c8565b61314861315594929361313e60608401955f8501906112a7565b602083019061083b565b6040818403910152613098565b90565b61316b613165604061303c565b15610571565b6134a2576131776142e2565b613486576131a06131924261318c604161111a565b90612cf0565b61319a611e00565b90612d7d565b426131cb6131c56131c06131b2614463565b6131ba610b10565b90612cf0565b610794565b91610794565b1061346a576131e4906131de604261111a565b90612cf0565b908161321261320c6132076131f76113ba565b613201604261111a565b90612cf0565b610794565b91610794565b11613447575b6132215f612ac8565b9061322b5f612ac8565b915b8261324061323a86610794565b91610794565b10156132875761327b6132819161327561326f6010613269613262604261111a565b8990613058565b90610ef4565b90610f37565b90613058565b92613049565b9161322d565b91509161329e613297604361111a565b8390613058565b6132b76132b16132ac61148e565b610794565b91610794565b1161342b576132d26132d9916132cd604261111a565b613058565b6042612b67565b6132f66132ef826132ea604361111a565b613058565b6043612b67565b6133096133023061307d565b8290614e61565b61332e6133153061307d565b6133276133226044612732565b6106b2565b8391614c05565b61334061333b6044612732565b6106b2565b6318b68b8c61334e3061307d565b8392604592813b15613426575f61337891613383829661336c610512565b98899788968795612cad565b855260048501613124565b03925af18015613421576133f5575b5061339d604261111a565b906133b06133ab6044612732565b6106b2565b906133db7f34b73d0c96e9ff4d5311434817c8ecc930e7d2782c5bde2e79dc44b0596755bb926110df565b926133f06133e7610512565b92839283610a98565b0390a2565b613414905f3d811161341a575b61340c8183610c6e565b810190613089565b5f613392565b503d613402565b612ce0565b612ca9565b5f6323064ebd60e01b81528061344360048201610913565b0390fd5b90506134646134546113ba565b61345e604261111a565b90612cf0565b90613218565b5f633d53c75360e01b81528061348260048201610913565b0390fd5b5f631155624b60e21b81528061349e60048201610913565b0390fd5b5f6319afc99d60e21b8152806134ba60048201610913565b0390fd5b6134c6612fe2565b565b906134e3916134de6134d982612fc0565b614c15565b6134e5565b565b906134ef91614ebf565b50565b906134fc916134c8565b565b5f90565b90565b61351961351461351e92613502565b610687565b610e5c565b90565b6135296134fe565b506135346012613505565b90565b6135476135426122f0565b614c15565b61354f613551565b565b61355b604161111a565b61356d6135675f612ac8565b91610794565b146135b65761357e60016040612b31565b7f4a792a0be42b5672faa40129fc6469072490775ca8d3c34e852d4d55d3a735a96135a7610512565b806135b181610913565b0390a1565b5f638f98404160e01b8152806135ce60048201610913565b0390fd5b6135da613537565b565b6135e4612f76565b506135ed614f6b565b90565b908061360b613605613600614bf8565b610765565b91610765565b0361361c5761361991615025565b50565b5f63334bd91960e11b81528061363460048201610913565b0390fd5b90613642906110df565b5f5260205260405f2090565b90565b61366561366061366a92612415565b610687565b610794565b90565b6136a49161369961369361368e61369f94613686612797565b50600a613638565b61364e565b91615106565b906151fc565b613651565b90565b6136b76136b2611c21565b614c15565b6136bf6136c1565b565b6136c9615383565b565b6136d36136a7565b565b906136e7916136e2614de8565b6136f1565b6136ef614e4d565b565b908161370d6137076137025f612b00565b610765565b91610765565b1461380c578061372561371f5f612ac8565b91610794565b146137f05761374761374161373c600e33906114e5565b61303c565b15610571565b6137d45761375433615390565b61376b6001613765600d33906110eb565b0161111a565b61377d61377783610794565b91610794565b106137b8576137b6916137b1826137ab600161379b600d33906110eb565b01916137a68361111a565b612cf0565b90612b67565b614e61565b565b5f631c959ed960e21b8152806137d060048201610913565b0390fd5b5f634417760960e11b8152806137ec60048201610913565b0390fd5b5f631f2a200560e01b81528061380860048201610913565b0390fd5b5f63d92e233d60e01b81528061382460048201610913565b0390fd5b90613832916136d5565b565b61383c612797565b5061385861384861148e565b613852604361111a565b90612cf0565b90565b9061386e613867610512565b9283610c6e565b565b67ffffffffffffffff811161388e5761388a6020916105f4565b0190565b610c5a565b906138a56138a083613870565b61385b565b918252565b5f7f6d6f64653d626c6f636b6e756d6265722666726f6d3d64656661756c74000000910152565b6138db601d613893565b906138e8602083016138aa565b565b6138f26138d1565b90565b6138fd612621565b50613906613e48565b61391f61391961391461555f565b611975565b91611975565b0361392f5761392c6138ea565b90565b5f6301bfc1c560e61b81528061394760048201610913565b0390fd5b5f90565b90613959906110df565b5f5260205260405f2090565b60018060a01b031690565b61397c61398191611101565b613965565b90565b61398e9054613970565b90565b6139a86139ad916139a061394b565b50600961394f565b613984565b90565b6139b86125dd565b506139c3604161111a565b6139d56139cf5f612ac8565b91610794565b1190565b6139ea906139e5614bf8565b615597565b565b6139f46125dd565b506139ff600f61303c565b90565b613a5990613a0e612797565b50613a266001613a20600d84906110eb565b0161111a565b90613a536004613a4d613a455f613a3f600d87906110eb565b0161111a565b93600d6110eb565b0161111a565b91615622565b90565b613a6c613a67612354565b614c15565b613a74613a76565b565b613a815f6040612b31565b7f73a5fc60aafeec8f139af22d98e62140e2ce914d1f155c692b427757c3e4014c613aaa610512565b80613ab481610913565b0390a1565b613ac1613a5c565b565b5f90565b613ad990613ad3613ac3565b506156cf565b90565b90613ae6906110df565b5f5260205260405f2090565b613b08613b0d91613b01612797565b505f613adc565b61111a565b90565b613b27613b2c91613b1f6125dd565b50600e6114e5565b61303c565b90565b90613b386125dd565b50613b41612797565b50613b4a612797565b50613b53612797565b50613b5c612797565b50613b71613b6c600e84906114e5565b61303c565b91613b885f613b82600d84906110eb565b0161111a565b91613ba06002613b9a600d85906110eb565b0161111a565b90613bd96020613baf30612c9d565b63651fd26890613bce8792613bc2610512565b95869485938493612cad565b8352600483016112b4565b03915afa908115613c9a57613c24916020915f91613c6d575b5094613bfd30612c9d565b613c1963998955d3613c0d610512565b95869485938493612cad565b8352600483016112b4565b03915afa908115613c68575f91613c3a575b5090565b613c5b915060203d8111613c61575b613c538183610c6e565b810190612cc2565b5f613c36565b503d613c49565b612ce0565b613c8d9150823d8111613c93575b613c858183610c6e565b810190612cc2565b5f613bf2565b503d613c7b565b612ce0565b613cb190613cab612797565b506156fe565b90565b613cc4613cbf612354565b614c15565b613ccc613cce565b565b613cd6615774565b565b613ce0613cb4565b565b5f90565b606090565b613cf4906106a6565b90565b67ffffffffffffffff8111613d0f5760208091020190565b610c5a565b90613d26613d2183613cf7565b61385b565b918252565b369037565b90613d55613d3d83613d14565b92602080613d4b8693613cf7565b9201910390613d2b565b565b600f60f81b90565b613d67613ce2565b50613d70612621565b50613d79612621565b50613d82612797565b50613d8b61394b565b50613d94612f76565b50613d9d613ce6565b50613da6615781565b90613daf6157c1565b904690613dbb30613ceb565b90613dc55f611c05565b90613dd7613dd25f612ac8565b613d30565b90613de0613d57565b96959493929190565b613e12613e1791613df8612797565b50613e0c613e06600b61364e565b91615106565b906151fc565b613651565b90565b613e41915f613e36613e3c93613e2e6125dd565b506005612f86565b016114e5565b61303c565b90565b5f90565b613e50613e44565b50613e5961555f565b90565b613e64612621565b50613e6f60046126f3565b90565b613eca90613e7e612797565b50613e966003613e90600d84906110eb565b0161111a565b90613ec46004613ebe613eb66002613eb0600d87906110eb565b0161111a565b93600d6110eb565b0161111a565b91615622565b90565b613ef4613eef613eea613ef993613ee2612797565b50600a613638565b61364e565b615801565b613651565b90565b90613f0e91613f09614de8565b613f18565b613f16614e4d565b565b9081613f34613f2e613f295f612b00565b610765565b91610765565b146140335780613f4c613f465f612ac8565b91610794565b1461401757613f6e613f68613f63600e33906114e5565b61303c565b15610571565b613ffb57613f7b33615390565b613f926003613f8c600d33906110eb565b0161111a565b613fa4613f9e83610794565b91610794565b10613fdf57613fdd91613fd882613fd26003613fc2600d33906110eb565b0191613fcd8361111a565b612cf0565b90612b67565b615876565b565b5f631c959ed960e21b815280613ff760048201610913565b0390fd5b5f634417760960e11b81528061401360048201610913565b0390fd5b5f631f2a200560e01b81528061402f60048201610913565b0390fd5b5f63d92e233d60e01b81528061404b60048201610913565b0390fd5b9061405991613efc565b565b90614076929161407161406c6124e0565b614c15565b614078565b565b8061409361408d6140885f612b00565b610765565b91610765565b146142b9576140b56140af6140aa600e84906114e5565b61303c565b15610571565b8061427e575b614222575b816140d36140cd5f612ac8565b91610794565b1480614208575b806141ee575b614193575b6140ee81615390565b614105825f6140ff600d85906110eb565b01612b67565b61411d836002614117600d85906110eb565b01612b67565b61413582600161412f600d85906110eb565b01612b67565b61414d836003614147600d85906110eb565b01612b67565b90916141797faa807d0abf30d91968c7478c66b6d82521a106af13eda036e2036da9af168958926110df565b9261418e614185610512565b92839283610a98565b0390a2565b6141a85f6141a3600e84906114e5565b612b31565b806141d37f02c2f0ba15b03f88b18f4832609a18cf35fc6b3f4546a9992076d7453d1334a8916110df565b906141dc610512565b806141e681610913565b0390a26140e5565b506142036141fe600e83906114e5565b61303c565b6140e0565b508261421c6142165f612ac8565b91610794565b146140da565b6142386001614233600e84906114e5565b612b31565b806142637f6cf28439a2daab1b265097227212a5b71e0a76f9ed85e3f815b5a6c3e218eb7f916110df565b9061426c610512565b8061427681610913565b0390a26140c0565b508161429261428c5f612ac8565b91610794565b11801561429f575b6140bb565b50826142b36142ad5f612ac8565b91610794565b1161429a565b5f63d92e233d60e01b8152806142d160048201610913565b0390fd5b906142e0929161405b565b565b6142ea6125dd565b506142f5604261111a565b61430e6143086143036113ba565b610794565b91610794565b101590565b61432c906143276143226124e0565b614c15565b614384565b565b9061433f60018060a01b0391611c00565b9181191691161790565b6143529061068a565b90565b61435e90614349565b90565b90565b9061437961437461438092614355565b614361565b825461432e565b9055565b61438d816106b2565b6143a76143a161439c5f612b00565b610765565b91610765565b1461441d576143d26143cc6143bc6044612732565b6143c7846044614364565b6106b2565b916106b2565b6144056143ff7f07015b6a9f05913148fd5faddf2acc9708f305937f3072ca2b4b46faa5d0898b936110df565b916110df565b9161440e610512565b8061441881610913565b0390a3565b5f63d92e233d60e01b81528061443560048201610913565b0390fd5b61444290614313565b565b90565b61445b61445661446092614444565b610687565b610794565b90565b61446b612797565b50614476604161111a565b6144886144825f612ac8565b91610794565b146144d1576144ce61449a604161111a565b6144c86144ba6144aa604261111a565b6144b46001614447565b90613058565b6144c2611e00565b90612d34565b90613058565b90565b6144da5f612ac8565b90565b6144fa916144e96125dd565b506144f2614bf8565b919091614cf5565b600190565b67ffffffffffffffff81116145145760200290565b610c5a565b61452561452a916144ff565b61385b565b90565b9061454b61453a83614519565b9261454584916144ff565b90613d2b565b565b614557603061452d565b90565b905090565b6145699054611106565b90565b60010190565b61458e61458861458183610eeb565b809461455a565b91610ef1565b5f915b83831061459e5750505050565b6145bb6145b56001926145b08561455f565b61177b565b9261456c565b92019190614591565b906145d28161060093614572565b0190565b906145f66145ef926145e6610512565b938480926145c4565b0383610c6e565b565b614601906145d6565b90565b61460c61454d565b5061461760106145f8565b90565b9061462d91614627612797565b5061366d565b90565b614638612797565b50614641612797565b5061464a612797565b506146536125dd565b5061465e604161111a565b61467061466a5f612ac8565b91610794565b146147e15761469a61468c42614686604161111a565b90612cf0565b614694611e00565b90612d7d565b906146dc6146a8604161111a565b6146d66146c86146b8604261111a565b6146c26001614447565b90613058565b6146d0611e00565b90612d34565b90613058565b6146e6604261111a565b6146ff6146f96146f46113ba565b610794565b91610794565b105f146147d35761472461471e6010614718604261111a565b90610ef4565b90610f37565b5b92614730604061303c565b90816147af575b5080614785575b80614759575b9161474f604261111a565b9193929193929190565b504261477e6147786147738461476d610b10565b90612cf0565b610794565b91610794565b1015614744565b50614790604261111a565b6147a96147a361479e6113ba565b610794565b91610794565b1061473e565b90506147cc6147c66147c1604261111a565b610794565b91610794565b115f614737565b6147dc5f612ac8565b614725565b5f905f915f916148036147fd6147f75f94612ac8565b95612ac8565b93612ac8565b9190565b61481990614813612797565b50613ecd565b90565b614824612797565b5061482d612a98565b90565b600261484961484f92614841612797565b50600d6110eb565b0161111a565b90565b7fe48329057bfd03d55e49b547132e39cffd9c1820ad7b9d4c5307691425d15adf90565b6148ab6148b2946148a1606094989795614897608086019a5f870190610d71565b60208501906112a7565b604083019061083b565b019061083b565b565b60200190565b93959490929195426148d46148ce89610794565b91610794565b1161494d579161493f916149469361493661494b989961491e6148f5614852565b61490f8b938b614903610512565b95869460208601614876565b60208201810382520382610c6e565b61493061492a826106cb565b916148b4565b206158d5565b929091926158f2565b918261593c565b615597565b565b614968875f918291632341d78760e11b835260048301610848565b0390fd5b7f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c990565b91946149d86149e2929897956149ce60a0966149c46149e99a6149ba60c08a019e5f8b0190610d71565b60208901906112a7565b60408701906112a7565b606085019061083b565b608083019061083b565b019061083b565b565b916020614a0c929493614a0560408201965f8301906112a7565b01906112a7565b565b969591939294909442614a29614a2383610794565b91610794565b11614ae35790614a92614a9b949392614a7a614a4361496c565b614a6b8c80948c91614a558d9161597f565b9192614a5f610512565b97889660208801614990565b60208201810382520382610c6e565b614a8c614a86826106cb565b916148b4565b206158d5565b929091926158f2565b80614aae614aa887610765565b91610765565b03614ac35750614ac19293919091614c05565b565b8490614adf5f9283926325c0072360e11b8452600484016149eb565b0390fd5b614afe905f91829163313c898160e11b835260048301610848565b0390fd5b90614b1d91614b18614b1382612fc0565b614c15565b614b1f565b565b90614b2991615025565b50565b90614b3691614b02565b565b90614b42906110df565b5f5260205260405f2090565b614b7391614b69614b6e92614b61612797565b506001614b38565b613adc565b61111a565b90565b614b80604061385b565b90565b5f90565b5f90565b614b93614b76565b9060208083614ba0614b83565b815201614bab614b87565b81525050565b614bb9614b8b565b90565b90614bcf91614bc9614bb1565b506159b2565b90565b614bda6125dd565b50614bf4614bee6301ffc9a760e01b610524565b91610524565b1490565b614c0061394b565b503390565b91614c1392916001926159da565b565b614c2790614c21614bf8565b90615b0c565b565b604090614c52614c599496959396614c4860608401985f8501906112a7565b602083019061083b565b019061083b565b565b90614c669103610794565b90565b929192614c77818390614b4e565b9081614c8c614c865f19610794565b91610794565b10614c99575b5050509050565b81614cac614ca687610794565b91610794565b10614cd257614cc99394614cc1919392614c5b565b905f926159da565b805f8080614c92565b50614cf1849291925f938493637dc7a0d960e11b855260048501614c29565b0390fd5b9182614d11614d0b614d065f612b00565b610765565b91610765565b14614d6b5781614d31614d2b614d265f612b00565b610765565b91610765565b14614d4457614d4292919091615b47565b565b614d67614d505f612b00565b5f91829163ec442f0560e01b8352600483016112b4565b0390fd5b614d8e614d775f612b00565b5f918291634b637e8f60e11b8352600483016112b4565b0390fd5b614d9a6139ec565b614da057565b5f63d93c066560e01b815280614db860048201610913565b0390fd5b90565b614dd3614dce614dd892614dbc565b610687565b610794565b90565b614de56002614dbf565b90565b614df2600c61111a565b614e0b614e05614e00614ddb565b610794565b91610794565b14614e2457614e22614e1b614ddb565b600c612b67565b565b5f633ee5aeb560e01b815280614e3c60048201610913565b0390fd5b614e4a6001614447565b90565b614e5f614e58614e40565b600c612b67565b565b80614e7c614e76614e715f612b00565b610765565b91610765565b14614e9857614e9691614e8e5f612b00565b919091615b47565b565b614ebb614ea45f612b00565b5f91829163ec442f0560e01b8352600483016112b4565b0390fd5b614ec76125dd565b50614edc614ed6828490613e1a565b15610571565b5f14614f6557614f046001614eff5f614ef760058690612f86565b0185906114e5565b612b31565b90614f0d614bf8565b90614f4a614f44614f3e7f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d95612f7a565b926110df565b926110df565b92614f53610512565b80614f5d81610913565b0390a4600190565b50505f90565b614f73612f76565b50614f7d30613ceb565b614faf614fa97f0000000000000000000000000000000000000000000000000000000000000000610765565b91610765565b1480614feb575b5f14614fe0577f000000000000000000000000000000000000000000000000000000000000000090565b614fe8615bc7565b90565b504661501f6150197f0000000000000000000000000000000000000000000000000000000000000000610794565b91610794565b14614fb6565b61502d6125dd565b50615039818390613e1a565b5f146150c1576150605f61505b5f61505360058690612f86565b0185906114e5565b612b31565b90615069614bf8565b906150a66150a061509a7ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b95612f7a565b926110df565b926110df565b926150af610512565b806150b981610913565b0390a4600190565b50505f90565b6150db6150d66150e092611975565b610687565b610794565b90565b9160206151049294936150fd60408201965f83019061083b565b0190611980565b565b61510e613e44565b50615117613e48565b8161512a615124836150c7565b91610794565b101561513d575061513a90615ccd565b90565b906151585f928392637669fc0f60e11b8452600484016150e3565b0390fd5b5490565b90565b61517761517261517c92615160565b610687565b610794565b90565b90565b65ffffffffffff1690565b61519961519e91611101565b615182565b90565b6151ab905461518d565b90565b60301c90565b60018060d01b031690565b6151cb6151d0916151ae565b6151b4565b90565b6151dd90546151bf565b90565b6151f46151ef6151f992611bfd565b610687565b612415565b90565b9061525090615209612548565b506152155f840161515c565b61521e5f612ac8565b90808061523461522e6005615163565b91610794565b116152b1575b509061524b5f86019391929361517f565b616305565b8061526361525d5f612ac8565b91610794565b145f146152795750506152755f6151e0565b5b90565b6152a65f916152a161529b846152ac9601926152956001614447565b90612cf0565b9161517f565b6162fb565b016151d3565b615276565b806152bf6152c59291615f90565b90612cf0565b90836152f76152f16152ec5f6152e6818c016152e1899161517f565b6162fb565b016151a1565b611975565b91611975565b105f146153085750905b905f61523a565b915061531e906153186001614447565b90613058565b615301565b61532b616394565b615333615335565b565b6153405f600f612b31565b615348614bf8565b61537e7f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa91615375610512565b918291826112b4565b0390a1565b61538b615323565b565b90565b61539e6153a391600d6110eb565b61538d565b6153af6004820161111a565b6153c16153bb5f612ac8565b91610794565b1461554f5761543d906153e0426153da6004840161111a565b90612cf0565b806153fa6153f46153ef611a2b565b610794565b91610794565b10155f1461543f575061541a6154115f830161111a565b60018301612b67565b6154326154296002830161111a565b60038301612b67565b5b6004429101612b67565b565b8061545261544c5f612ac8565b91610794565b1161545e575b50615433565b61554061552e6155499261551d6155146155036154f16154b36154825f8b0161111a565b6154948761548e611ea4565b90612d34565b6154ad61549f611a2b565b6154a7611ea4565b90612d34565b9161641c565b946154d26154c360028c0161111a565b916154cc611ea4565b90612d34565b6154eb6154dd611a2b565b6154e5611ea4565b90612d34565b9161641c565b936154fe60018a0161111a565b613058565b61550e5f890161111a565b9061661b565b60018701612b67565b6155296003860161111a565b613058565b61553a6002850161111a565b9061661b565b60038301612b67565b5f615458565b61555d906004429101612b67565b565b615567613e44565b5061557143615ccd565b90565b90565b9061558c615587615593926110df565b615574565b825461432e565b9055565b906156209161561a6155a882613991565b6155bd846155b86009869061394f565b615577565b828185906155fd6155f76155f17f3134e8a2e6d97e929a7e54011ea5485d7d196dd5f0ba4d4ef95803e8e3fc257f956110df565b926110df565b926110df565b92615606610512565b8061561081610913565b0390a49291616647565b9161665f565b565b909161562c612797565b508061564061563a5f612ac8565b91610794565b146156c05761564f9042612cf0565b8061566961566361565e611a2b565b610794565b91610794565b10156156bb5782916156ad6156b39261568e6156b89691615688611ea4565b90612d34565b6156a7615699611a2b565b6156a1611ea4565b90612d34565b9161641c565b90613058565b61661b565b90565b505090565b5050506156cc5f612ac8565b90565b6156f66156f16156ec6156fb936156e4613ac3565b50600a613638565b61364e565b61680d565b61688c565b90565b6157109061570a612797565b506168dd565b90565b61571b614d92565b615723615725565b565b6157316001600f612b31565b615739614bf8565b61576f7f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a25891615766610512565b918291826112b4565b0390a1565b61577c615713565b565b90565b615789612621565b506157be7f00000000000000000000000000000000000000000000000000000000000000006157b8600661577e565b906169f8565b90565b6157c9612621565b506157fe7f00000000000000000000000000000000000000000000000000000000000000006157f8600761577e565b906169f8565b90565b615809612548565b506158155f820161515c565b806158286158225f612ac8565b91610794565b145f1461583e57505061583a5f6151e0565b5b90565b61586b5f916158666158608461587196019261585a6001614447565b90612cf0565b9161517f565b6162fb565b016151d3565b61583b565b908161589261588c6158875f612b00565b610765565b91610765565b146158ae576158ac91906158a55f612b00565b9091615b47565b565b6158d16158ba5f612b00565b5f918291634b637e8f60e11b8352600483016112b4565b0390fd5b6158ef906158e1612f76565b506158ea614f6b565b616a46565b90565b9261590d926159169461590361394b565b5092909192616afc565b90929192616c27565b90565b91602061593a92949361593360408201965f8301906112a7565b019061083b565b565b6159458161597f565b9161595861595284610794565b91610794565b03615961575050565b61597b5f9283926301d4b62360e61b845260048401615919565b0390fd5b6159939061598b612797565b506008613adc565b6159af61599f8261111a565b916159a983613049565b90612b67565b90565b906159d26159cd6159d7936159c5614bb1565b50600a613638565b61364e565b616d89565b90565b9092816159f76159f16159ec5f612b00565b610765565b91610765565b14615ac25783615a17615a11615a0c5f612b00565b610765565b91610765565b14615a9b57615a3b83615a36615a2f60018690614b38565b8790613adc565b612b67565b615a45575b505050565b919091615a90615a7e615a787f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925936110df565b936110df565b93615a87610512565b91829182610848565b0390a35f8080615a40565b615abe615aa75f612b00565b5f918291634a1406b160e11b8352600483016112b4565b0390fd5b615ae5615ace5f612b00565b5f91829163e602df0560e01b8352600483016112b4565b0390fd5b916020615b0a929493615b0360408201965f8301906112a7565b0190610d71565b565b90615b21615b1b838390613e1a565b15610571565b615b29575050565b615b435f92839263e2517d3f60e01b845260048401615ae9565b0390fd5b91615b5492919091616daa565b565b7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f90565b90959492615bc594615bb4615bbe92615baa608096615ba060a088019c5f890190610d71565b6020870190610d71565b6040850190610d71565b606083019061083b565b01906112a7565b565b615bcf612f76565b50615bd8615b56565b615c4f7f000000000000000000000000000000000000000000000000000000000000000091615c407f000000000000000000000000000000000000000000000000000000000000000046615c2b30613ceb565b91615c34610512565b96879560208701615b7a565b60208201810382520382610c6e565b615c61615c5b826106cb565b916148b4565b2090565b615c79615c74615c7e9261139b565b610687565b610e5c565b90565b615c8a90615c65565b9052565b916020615caf929493615ca860408201965f830190615c81565b019061083b565b565b615cc5615cc0615cca92610794565b610687565b611975565b90565b615cd5613e44565b5080615cef615ce965ffffffffffff6150c7565b91610794565b11615d0057615cfd90615cb1565b90565b6030615d1c5f9283926306dfcc6560e41b845260048401615c8e565b0390fd5b90565b615d37615d32615d3c92615d20565b610687565b610794565b90565b90565b615d56615d51615d5b92615d3f565b610687565b610e5c565b90565b615d7d90615d77615d71615d8294610e5c565b91610794565b906109b4565b610794565b90565b90565b615d9c615d97615da192615d85565b610687565b610e5c565b90565b615dc390615dbd615db7615dc894610e5c565b91610794565b906127e6565b610794565b90565b90565b615de2615ddd615de792615dcb565b610687565b610794565b90565b90565b615e01615dfc615e0692615dea565b610687565b610e5c565b90565b90565b615e20615e1b615e2592615e09565b610687565b610794565b90565b90565b615e3f615e3a615e4492615e28565b610687565b610e5c565b90565b90565b615e5e615e59615e6392615e47565b610687565b610794565b90565b90565b615e7d615e78615e8292615e66565b610687565b610e5c565b90565b90565b615e9c615e97615ea192615e85565b610687565b610794565b90565b90565b615ebb615eb6615ec092615ea4565b610687565b610e5c565b90565b615ed7615ed2615edc92615e28565b610687565b610794565b90565b615ef3615eee615ef892614dbc565b610687565b610e5c565b90565b615f0f615f0a615f1492615ea4565b610687565b610794565b90565b615f2b615f26615f3092614444565b610687565b610e5c565b90565b90565b615f4a615f45615f4f92615f33565b610687565b610794565b90565b90615f5d9102610794565b90565b615f6c615f7291610794565b91610794565b908115615f7d570490565b612d69565b90615f8d9101610794565b90565b615f98612797565b5080615fad615fa76001614447565b91610794565b11156162f857806161c261619f61618f61617f61616f61615f61614f61613f61612f61611f61610f8b6161096161026161c89f6160e26160d26160f292615ff46001614447565b908061600c616006600160801b615d23565b91610794565b10156162ca575b8061602f61602968010000000000000000615dce565b91610794565b101561629c575b8061604e616048640100000000615e0c565b91610794565b101561626e575b8061606b61606562010000615e4a565b91610794565b1015616240575b80616087616081610100615e88565b91610794565b1015616212575b806160a261609c6010615ec3565b91610794565b10156161e4575b6160bc6160b66004615efb565b91610794565b10156161cb575b6160cd6003615f36565b615f52565b6160dc6001615f17565b90615d5e565b6160ec8186615f60565b90615f82565b6160fc6001615f17565b90615d5e565b8092615f60565b90615f82565b6161196001615f17565b90615d5e565b616129818c615f60565b90615f82565b6161396001615f17565b90615d5e565b616149818a615f60565b90615f82565b6161596001615f17565b90615d5e565b6161698188615f60565b90615f82565b6161796001615f17565b90615d5e565b6161898186615f60565b90615f82565b6161996001615f17565b90615d5e565b916161bc6161b66161b1858094615f60565b610794565b91610794565b11616e3a565b90614c5b565b90565b6161df906161d96001615f17565b90615da4565b6160c3565b6161fb61620c916161f56004615ea7565b90615d5e565b916162066002615edf565b90615da4565b906160a9565b61622961623a916162236008615e69565b90615d5e565b916162346004615ea7565b90615da4565b9061608e565b616257616268916162516010615e2b565b90615d5e565b916162626008615e69565b90615da4565b90616072565b6162856162969161627f6020615ded565b90615d5e565b916162906010615e2b565b90615da4565b90616055565b6162b36162c4916162ad6040615d88565b90615d5e565b916162be6020615ded565b90615da4565b90616036565b6162e16162f2916162db6080615d42565b90615d5e565b916162ec6040615d88565b90615da4565b90616013565b90565b5f5260205f200190565b93919092616311612797565b505b8161632661632083610794565b91610794565b101561638c57616337828290616e48565b9061634d5f6163478885906162fb565b016151a1565b61635f61635987611975565b91611975565b115f1461636f5750915b91616313565b929150616386906163806001614447565b90613058565b90616369565b925050915090565b6163a561639f6139ec565b15610571565b6163ab57565b5f638dfc202b60e01b8152806163c360048201610913565b0390fd5b6163db6163d66163e092613502565b610687565b610794565b90565b6163ed60126163c7565b90565b90565b61640761640261640c926163f0565b610687565b610794565b90565b61641960116163f3565b90565b929192616427612797565b50616433818390615f52565b9161643c612797565b505f1981830983808210910303918261645d6164575f612ac8565b91610794565b1461660a578561647561646f85610794565b91610794565b11156165d8576165cf92866165d59697936164c693616492612797565b50099085821190039403936001836164b35f6164ae8791612ac8565b614c5b565b1680809504960493805f03040190615f52565b17916165c96165ad61658961656561654161651d6164ee60036164e98991615f36565b615f52565b6164f86002614dbf565b18616517600261651261650c8b8590615f52565b91614dbf565b614c5b565b90615f52565b61653b60026165366165308a8590615f52565b91614dbf565b614c5b565b90615f52565b61655f600261655a616554898590615f52565b91614dbf565b614c5b565b90615f52565b616583600261657e616578888590615f52565b91614dbf565b614c5b565b90615f52565b6165a760026165a261659c878590615f52565b91614dbf565b614c5b565b90615f52565b916165c46165be6002928590615f52565b91614dbf565b614c5b565b90615f52565b90615f52565b90565b616605866165ee6165e85f612ac8565b91610794565b146165f76163e3565b6165ff61640f565b91616e76565b616e9a565b505050916166189192615f60565b90565b61664491616627612797565b508161663b61663583610794565b91610794565b10919091616e76565b90565b61665990616653612797565b50613af2565b90565b90565b9190918061667561666f85610765565b91610765565b1415806167f3575b616687575b505050565b806166a261669c6166975f612b00565b610765565b91610765565b03616763575b50816166c46166be6166b95f612b00565b610765565b91610765565b036166d0575b80616682565b61671761670a616711926166e6600a8690613638565b906167046166fe6166f8600193616f15565b9361364e565b9161665c565b90616f68565b9290613651565b91613651565b9190916167447fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a724926110df565b92616759616750610512565b92839283610a98565b0390a25f806166ca565b6167a26167a861679b616778600a8590613638565b600261679561678f61678989616f15565b9361364e565b9161665c565b90616f68565b9290613651565b91613651565b9190916167d57fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a724926110df565b926167ea6167e1610512565b92839283610a98565b0390a25f6166a8565b50816168076168015f612ac8565b91610794565b1161667d565b5f6168219161681a612797565b500161515c565b90565b61683861683361683d92611549565b610687565b610794565b90565b61684990615ded565b9052565b91602061686e92949361686760408201965f830190616840565b019061083b565b565b61688461687f61688992610794565b610687565b611549565b90565b616894613ac3565b50806168ac6168a663ffffffff616824565b91610794565b116168bd576168ba90616870565b90565b60206168d95f9283926306dfcc6560e41b84526004840161684d565b0390fd5b6168f46168f9916168ec612797565b506008613adc565b61111a565b90565b90565b61691361690e616918926168fc565b611c00565b610d2d565b90565b61692560ff6168ff565b90565b5f5260205f2090565b905f929180549061694b61694483610b85565b8094612626565b916001811690815f146169a25750600114616966575b505050565b6169739192939450616928565b915f925b81841061698a57505001905f8080616961565b60018160209295939554848601520191019290616977565b92949550505060ff19168252151560200201905f8080616961565b906169c791616931565b90565b906169ea6169e3926169da610512565b938480926169bd565b0383610c6e565b565b6169f5906169ca565b90565b90616a01612621565b50616a0b82612f7a565b616a24616a1e616a1961691b565b610d2d565b91610d2d565b14155f14616a395750616a3690616ff2565b90565b616a4391506169ec565b90565b604291616a51612f76565b50604051917f19010000000000000000000000000000000000000000000000000000000000008352600283015260228201522090565b5f90565b616a97616a9c91611101565b61280f565b90565b90565b616ab6616ab1616abb92616a9f565b610687565b610794565b90565b616af3616afa94616ae9606094989795616adf608086019a5f870190610d71565b6020850190610e62565b6040830190610d71565b0190610d71565b565b939293616b0761394b565b50616b10616a87565b50616b19612f76565b50616b2385616a8b565b616b55616b4f7f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0616aa2565b91610794565b11616be25790616b78602094955f94939293616b6f610512565b94859485616abe565b838052039060015afa15616bdd57616b905f51611c00565b80616bab616ba5616ba05f612b00565b610765565b91610765565b14616bc1575f91616bbb5f611c05565b91929190565b50616bcb5f612b00565b600191616bd75f611c05565b91929190565b612ce0565b505050616bee5f612b00565b9060039291929190565b634e487b7160e01b5f52602160045260245ffd5b60041115616c1657565b616bf8565b90616c2582616c0c565b565b80616c3a616c345f616c1b565b91616c1b565b145f14616c45575050565b80616c59616c536001616c1b565b91616c1b565b145f14616c7c575f63f645eedf60e01b815280616c7860048201610913565b0390fd5b80616c90616c8a6002616c1b565b91616c1b565b145f14616cbe57616cba616ca383616a8b565b5f91829163fce698f760e01b835260048301610848565b0390fd5b616cd1616ccb6003616c1b565b91616c1b565b14616cd95750565b616cf4905f9182916335e2f38360e21b835260048301610d7e565b0390fd5b5f5260205f2090565b616d0a8161515c565b821015616d2457616d1c600191616cf8565b910201905f90565b610ed7565b90616d3390611975565b9052565b90616d4190612415565b9052565b90616d7b616d725f616d55614b76565b94616d6c616d648383016151a1565b838801616d29565b016151d3565b60208401616d37565b565b616d8690616d45565b90565b616da7915f616da192616d9a614bb1565b5001616d01565b50616d7d565b90565b9291616db884838391617022565b83616dd3616dcd616dc85f612b00565b610765565b91610765565b14616de8575b616de692939190916171ac565b565b616df0612a98565b93616df9617191565b9480616e0d616e0788610794565b91610794565b11616e1a57509350616dd9565b8590616e365f928392630e58ae9360e11b845260048401610a98565b0390fd5b616e42612797565b50151590565b616e6d616e7392616e57612797565b508281169218616e676002614dbf565b90612d7d565b90613058565b90565b616e90616e969293616e86612797565b5080941891616e3a565b90615f52565b1890565b634e487b715f526020526024601cfd5b90565b616ec1616ebc616ec692616eaa565b610687565b610e5c565b90565b616ed290616ead565b9052565b916020616ef7929493616ef060408201965f830190616ec9565b019061083b565b565b616f0d616f08616f1292610794565b610687565b612415565b90565b616f1d612548565b5080616f37616f3160018060d01b03613651565b91610794565b11616f4857616f4590616ef9565b90565b60d0616f645f9283926306dfcc6560e41b845260048401616ed6565b0390fd5b90616f9e616fa49392616f79612548565b50616f82612548565b508093616f97616f90613e48565b9492615801565b9091617614565b9161726b565b91909190565b616fbe616fb9616fc392615dea565b610687565b610794565b90565b369037565b90616ff0616fd883613893565b92602080616fe68693613870565b9201910390616fc6565b565b616ffa612621565b50617004816172d5565b906170176170126020616faa565b616fcb565b918252602082015290565b9190918061704061703a6170355f612b00565b610765565b91610765565b145f146171215761706461705d83617058600261111a565b613058565b6002612b67565b5b8261708061707a6170755f612b00565b610765565b91610765565b145f146170f5576170a461709d83617098600261111a565b614c5b565b6002612b67565b5b9190916170f06170de6170d87fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef936110df565b936110df565b936170e7610512565b91829182610848565b0390a3565b61711c826171166171075f8790613adc565b916171118361111a565b615f82565b90612b67565b6170a5565b61713461712f5f8390613adc565b61111a565b8061714761714185610794565b91610794565b1061716f5761715a61716a918490614c5b565b6171655f8490613adc565b612b67565b617065565b9061718d9091925f93849363391434e360e21b855260048501614c29565b0390fd5b617199612797565b506171a960018060d01b03613651565b90565b916172046171fe61720b94806171d26171cc6171c75f612b00565b610765565b91610765565b1461723c575b846171f36171ed6171e85f612b00565b610765565b91610765565b1461720d575b613991565b92613991565b909161665f565b565b617235600b600261722f61722961722389616f15565b9361364e565b9161665c565b90616f68565b50506171f9565b617264600b600161725e61725861725289616f15565b9361364e565b9161665c565b90616f68565b50506171d8565b9161728f5f6172949461727c612548565b50617285612548565b500192919261517f565b6174c6565b91909190565b6172ae6172a96172b3926168fc565b610687565b610794565b90565b90565b6172cd6172c86172d2926172b6565b610687565b610794565b90565b6172ea6172ef916172e4612797565b50612f7a565b616a8b565b6172f960ff61729a565b168061730e617308601f6172b9565b91610794565b116173165790565b5f632cd44ac360e21b81528061732e60048201610913565b0390fd5b5490565b617340604061385b565b90565b5f5260205f2090565b61735581617332565b82101561736f57617367600191617343565b910201905f90565b610ed7565b61737e9051611975565b90565b9061739265ffffffffffff91611c00565b9181191691161790565b6173b06173ab6173b592611975565b610687565b611975565b90565b90565b906173d06173cb6173d79261739c565b6173b8565b8254617381565b9055565b6173e59051612415565b90565b60301b90565b9061740065ffffffffffff19916173e8565b9181191691161790565b61741e61741961742392612415565b610687565b612415565b90565b90565b9061743e6174396174459261740a565b617426565b82546173ee565b9055565b9061747360205f6174799461746b828201617465848801617374565b906173bb565b0192016173db565b90617429565b565b919061748c5761748a91617449565b565b610b5e565b90815491680100000000000000008310156174c157826174b99160016174bf9501815561734c565b9061747b565b565b610c5a565b909291926174d2612548565b506174db612548565b506174e582617332565b806174f86174f25f612ac8565b91610794565b115f146175c85761751e9061751884916175126001614447565b90612cf0565b906162fb565b9061752a5f83016151a1565b926175365f84016151d3565b938061754a61754485611975565b91611975565b116175ac5761756161755b84611975565b91611975565b145f1461757c575050617577905f859101617429565b5b9190565b6175a792506175a286617599617590617336565b945f8601616d29565b60208401616d37565b617491565b617578565b5f632520601d60e01b8152806175c460048201610913565b0390fd5b506175f3916175ee856175e56175dc617336565b945f8601616d29565b60208401616d37565b617491565b6175fc5f6151e0565b9190565b634e487b7160e01b5f52605160045260245ffd5b91909180600114617633576002036176005761762f916125c7565b905b565b5061763d91612588565b9061763156
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x13W[a%DV[a\0\x1D_5a\x05\x0CV[\x80c\x01\xFF\xC9\xA7\x14a\x05\x07W\x80c\x06\xFD\xDE\x03\x14a\x05\x02W\x80c\x07\xA1\xD5\xFA\x14a\x04\xFDW\x80c\t^\xA7\xB3\x14a\x04\xF8W\x80c\x0C\x05\xF8,\x14a\x04\xF3W\x80c\x13\xBE\xAA[\x14a\x04\xEEW\x80c\x18\x16\r\xDD\x14a\x04\xE9W\x80c\x1B\x02\xF8E\x14a\x04\xE4W\x80c\"\xA9}\x9C\x14a\x04\xDFW\x80c#\xB8r\xDD\x14a\x04\xDAW\x80c#\xE4`\xD2\x14a\x04\xD5W\x80c$:0\xCC\x14a\x04\xD0W\x80c$\x81\xBB\\\x14a\x04\xCBW\x80c$\x8A\x9C\xA3\x14a\x04\xC6W\x80c(N\x133\x14a\x04\xC1W\x80c//\xF1]\x14a\x04\xBCW\x80c1<\xE5g\x14a\x04\xB7W\x80c3M\x0B\xBD\x14a\x04\xB2W\x80c5\x9Bv\xFE\x14a\x04\xADW\x80c6D\xE5\x15\x14a\x04\xA8W\x80c6V\x8A\xBE\x14a\x04\xA3W\x80c:F\xB1\xA8\x14a\x04\x9EW\x80c?K\xA8:\x14a\x04\x99W\x80c@\xC1\x0F\x19\x14a\x04\x94W\x80cD\xE1\x81\xAA\x14a\x04\x8FW\x80cH\xB0\xDA\xA6\x14a\x04\x8AW\x80cK\xDD6\xCE\x14a\x04\x85W\x80cK\xF5\xD7\xE9\x14a\x04\x80W\x80cX|\xDE\x1E\x14a\x04{W\x80cZ\xDF\0!\x14a\x04vW\x80c\\\x19\xA9\\\x14a\x04qW\x80c\\\x97Z\xBB\x14a\x04lW\x80c_\x15\xC3\xC9\x14a\x04gW\x80ce\x1F\xD2h\x14a\x04bW\x80cl3\xBC\xED\x14a\x04]W\x80cl\xF0\x16%\x14a\x04XW\x80co\xC0c\xBE\x14a\x04SW\x80co\xCF\xFFE\x14a\x04NW\x80cp\xA0\x821\x14a\x04IW\x80crf\0\xCE\x14a\x04DW\x80cvg\x18\x08\x14a\x04?W\x80c|y\x0C\xAB\x14a\x04:W\x80c~\xCE\xBE\0\x14a\x045W\x80c\x84V\xCBY\x14a\x040W\x80c\x84\xB0\x19n\x14a\x04+W\x80c\x8ES\x9E\x8C\x14a\x04&W\x80c\x90-U\xA5\x14a\x04!W\x80c\x91\xD1HT\x14a\x04\x1CW\x80c\x91\xDD\xAD\xF4\x14a\x04\x17W\x80c\x95\xD8\x9BA\x14a\x04\x12W\x80c\x99\x12}\x9B\x14a\x04\rW\x80c\x99\x89U\xD3\x14a\x04\x08W\x80c\x9A\xB2N\xB0\x14a\x04\x03W\x80c\x9B~\xF6K\x14a\x03\xFEW\x80c\x9D\xC2\x9F\xAC\x14a\x03\xF9W\x80c\xA0\x8DVT\x14a\x03\xF4W\x80c\xA2\x17\xFD\xDF\x14a\x03\xEFW\x80c\xA3\xD4H[\x14a\x03\xEAW\x80c\xA4\xD7\xE3\x1D\x14a\x03\xE5W\x80c\xA5q\xE1\x84\x14a\x03\xE0W\x80c\xA5\xB3&\xBE\x14a\x03\xDBW\x80c\xA7\x0B\x9F\x0C\x14a\x03\xD6W\x80c\xA9\x05\x9C\xBB\x14a\x03\xD1W\x80c\xAE^\xCB\xC6\x14a\x03\xCCW\x80c\xAF*\xA6;\x14a\x03\xC7W\x80c\xB0\xCA%>\x14a\x03\xC2W\x80c\xBA\xBC9O\x14a\x03\xBDW\x80c\xBBMD6\x14a\x03\xB8W\x80c\xC0*\xE7T\x14a\x03\xB3W\x80c\xC1\xEBq7\x14a\x03\xAEW\x80c\xC3\xCD\xA5 \x14a\x03\xA9W\x80c\xD5\x05\xAC\xCF\x14a\x03\xA4W\x80c\xD5Gt\x1F\x14a\x03\x9FW\x80c\xDDb\xED>\x14a\x03\x9AW\x80c\xE3\xAB\xDF\xCB\x14a\x03\x95W\x80c\xE6:\xB1\xE9\x14a\x03\x90W\x80c\xF1\x12~\xD8\x14a\x03\x8BW\x80c\xF5\x08\xE1\x9D\x14a\x03\x86Wc\xF7^\x85\x12\x03a\0\x0EWa%\x0FV[a$\xABV[a$fV[a#\x83V[a#\x1FV[a\"\xBAV[a\"YV[a\"\x1FV[a!uV[a \xB9V[a \x84V[a OV[a \x16V[a\x1F\xA2V[a\x1FmV[a\x1E\xC3V[a\x1EOV[a\x1E\x1AV[a\x1D\xACV[a\x1DyV[a\x1C\xF7V[a\x1C\xC2V[a\x1C8V[a\x1B\xC9V[a\x1B[V[a\x1B&V[a\x1A\xAFV[a\x1AzV[a\x1AEV[a\x19\xD7V[a\x19\xA2V[a\x19?V[a\x19\nV[a\x18\x93V[a\x18WV[a\x17\x12V[a\x16\xDDV[a\x16\xA4V[a\x16\"V[a\x15\xDEV[a\x15\xA9V[a\x15tV[a\x15\x14V[a\x14\xB0V[a\x14<V[a\x14\x07V[a\x13\xD2V[a\x13fV[a\x133V[a\x12\xFEV[a\x12\xC9V[a\x12rV[a\x12=V[a\x12\x08V[a\x11\xC0V[a\x10\xABV[a\x10xV[a\x10BV[a\x10\x0EV[a\x0F\xD9V[a\x0F\xA6V[a\x0FqV[a\x0E\x84V[a\x0E(V[a\r\xC8V[a\r\x93V[a\x0C\xF8V[a\x0B)V[a\n\xBBV[a\nbV[a\t\xF3V[a\t\x81V[a\tLV[a\t\x18V[a\x08]V[a\x07\xE7V[a\x07/V[a\x06GV[a\x05\x98V[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x80\xFD[c\xFF\xFF\xFF\xFF`\xE0\x1B\x16\x90V[a\x059\x81a\x05$V[\x03a\x05@WV[_\x80\xFD[\x90P5\x90a\x05Q\x82a\x050V[V[\x90` \x82\x82\x03\x12a\x05lWa\x05i\x91_\x01a\x05DV[\x90V[a\x05\x1CV[\x15\x15\x90V[a\x05\x7F\x90a\x05qV[\x90RV[\x91\x90a\x05\x96\x90_` \x85\x01\x94\x01\x90a\x05vV[V[4a\x05\xC8Wa\x05\xC4a\x05\xB3a\x05\xAE6`\x04a\x05SV[a%\xE1V[a\x05\xBBa\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[_\x91\x03\x12a\x05\xD7WV[a\x05\x1CV[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[`\x1F\x80\x19\x91\x01\x16\x90V[a\x06\x1Da\x06&` \x93a\x06+\x93a\x06\x14\x81a\x05\xDCV[\x93\x84\x80\x93a\x05\xE0V[\x95\x86\x91\x01a\x05\xE9V[a\x05\xF4V[\x01\x90V[a\x06D\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x05\xFEV[\x90V[4a\x06wWa\x06W6`\x04a\x05\xCDV[a\x06sa\x06ba&\xFFV[a\x06ja\x05\x12V[\x91\x82\x91\x82a\x06/V[\x03\x90\xF3[a\x05\x18V[`\x01\x80`\xA0\x1B\x03\x16\x90V[\x90V[a\x06\x9Ea\x06\x99a\x06\xA3\x92a\x06|V[a\x06\x87V[a\x06|V[\x90V[a\x06\xAF\x90a\x06\x8AV[\x90V[a\x06\xBB\x90a\x06\xA6V[\x90V[a\x06\xC7\x90a\x06\xB2V[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[a\x06\xF7a\x07\0` \x93a\x07\x05\x93a\x06\xEE\x81a\x06\xCBV[\x93\x84\x80\x93a\x06\xCFV[\x95\x86\x91\x01a\x05\xE9V[a\x05\xF4V[\x01\x90V[\x91a\x07,\x92a\x07\x1F`@\x82\x01\x93_\x83\x01\x90a\x06\xBEV[` \x81\x84\x03\x91\x01Ra\x06\xD8V[\x90V[4a\x07`Wa\x07?6`\x04a\x05\xCDV[a\x07Ga'KV[\x90a\x07\\a\x07Sa\x05\x12V[\x92\x83\x92\x83a\x07\tV[\x03\x90\xF3[a\x05\x18V[a\x07n\x90a\x06|V[\x90V[a\x07z\x81a\x07eV[\x03a\x07\x81WV[_\x80\xFD[\x90P5\x90a\x07\x92\x82a\x07qV[V[\x90V[a\x07\xA0\x81a\x07\x94V[\x03a\x07\xA7WV[_\x80\xFD[\x90P5\x90a\x07\xB8\x82a\x07\x97V[V[\x91\x90`@\x83\x82\x03\x12a\x07\xE2W\x80a\x07\xD6a\x07\xDF\x92_\x86\x01a\x07\x85V[\x93` \x01a\x07\xABV[\x90V[a\x05\x1CV[4a\x08\x18Wa\x08\x14a\x08\x03a\x07\xFD6`\x04a\x07\xBAV[\x90a'uV[a\x08\x0Ba\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[\x90` \x82\x82\x03\x12a\x086Wa\x083\x91_\x01a\x07\x85V[\x90V[a\x05\x1CV[a\x08D\x90a\x07\x94V[\x90RV[\x91\x90a\x08[\x90_` \x85\x01\x94\x01\x90a\x08;V[V[4a\x08\x8DWa\x08\x89a\x08xa\x08s6`\x04a\x08\x1DV[a'\x9BV[a\x08\x80a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x08\xD8W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x08\xD3W` \x01\x92`\x01\x83\x02\x84\x01\x11a\x08\xCEWV[a\x08\x9AV[a\x08\x96V[a\x08\x92V[\x90` \x82\x82\x03\x12a\t\x0EW_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\t\tWa\t\x05\x92\x01a\x08\x9EV[\x90\x91V[a\x05 V[a\x05\x1CV[_\x01\x90V[4a\tGWa\t1a\t+6`\x04a\x08\xDDV[\x90a*\x8CV[a\t9a\x05\x12V[\x80a\tC\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\t|Wa\t\\6`\x04a\x05\xCDV[a\txa\tga*\x98V[a\toa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\t\xAFWa\t\x916`\x04a\x05\xCDV[a\t\x99a,dV[a\t\xA1a\x05\x12V[\x80a\t\xAB\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[\x1C\x90V[`\xFF\x16\x90V[a\t\xCE\x90`\x08a\t\xD3\x93\x02a\t\xB4V[a\t\xB8V[\x90V[\x90a\t\xE1\x91Ta\t\xBEV[\x90V[a\t\xF0`@_\x90a\t\xD6V[\x90V[4a\n#Wa\n\x036`\x04a\x05\xCDV[a\n\x1Fa\n\x0Ea\t\xE4V[a\n\x16a\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[\x90\x91``\x82\x84\x03\x12a\n]Wa\nZa\nC\x84_\x85\x01a\x07\x85V[\x93a\nQ\x81` \x86\x01a\x07\x85V[\x93`@\x01a\x07\xABV[\x90V[a\x05\x1CV[4a\n\x93Wa\n\x8Fa\n~a\nx6`\x04a\n(V[\x91a,nV[a\n\x86a\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[\x91` a\n\xB9\x92\x94\x93a\n\xB2`@\x82\x01\x96_\x83\x01\x90a\x08;V[\x01\x90a\x08;V[V[4a\n\xECWa\n\xD3a\n\xCE6`\x04a\x08\x1DV[a-\x9FV[\x90a\n\xE8a\n\xDFa\x05\x12V[\x92\x83\x92\x83a\n\x98V[\x03\x90\xF3[a\x05\x18V[\x90V[a\x0B\x08a\x0B\x03a\x0B\r\x92a\n\xF1V[a\x06\x87V[a\x07\x94V[\x90V[a\x0B\x1Ba\x0E\x10a\n\xF4V[\x90V[a\x0B&a\x0B\x10V[\x90V[4a\x0BYWa\x0B96`\x04a\x05\xCDV[a\x0BUa\x0BDa\x0B\x1EV[a\x0BLa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x0B\xA5W[` \x83\x10\x14a\x0B\xA0WV[a\x0BqV[\x91`\x7F\x16\x91a\x0B\x95V[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x0B\xDBa\x0B\xD4\x83a\x0B\x85V[\x80\x94a\x0B\xAFV[\x91`\x01\x81\x16\x90\x81_\x14a\x0C2WP`\x01\x14a\x0B\xF6W[PPPV[a\x0C\x03\x91\x92\x93\x94Pa\x0B\xB8V[\x91_\x92[\x81\x84\x10a\x0C\x1AWPP\x01\x90_\x80\x80a\x0B\xF1V[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x0C\x07V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x0B\xF1V[\x90a\x0CW\x91a\x0B\xC1V[\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x0Cx\x90a\x05\xF4V[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x0C\x92W`@RV[a\x0CZV[\x90a\x0C\xB7a\x0C\xB0\x92a\x0C\xA7a\x05\x12V[\x93\x84\x80\x92a\x0CMV[\x03\x83a\x0CnV[V[\x90_\x10a\x0C\xCCWa\x0C\xC9\x90a\x0C\x97V[\x90V[a\x0B^V[a\x0C\xDD`E_\x90a\x0C\xB9V[\x90V[a\x0C\xF5\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x06\xD8V[\x90V[4a\r(Wa\r\x086`\x04a\x05\xCDV[a\r$a\r\x13a\x0C\xD1V[a\r\x1Ba\x05\x12V[\x91\x82\x91\x82a\x0C\xE0V[\x03\x90\xF3[a\x05\x18V[\x90V[a\r9\x81a\r-V[\x03a\r@WV[_\x80\xFD[\x90P5\x90a\rQ\x82a\r0V[V[\x90` \x82\x82\x03\x12a\rlWa\ri\x91_\x01a\rDV[\x90V[a\x05\x1CV[a\rz\x90a\r-V[\x90RV[\x91\x90a\r\x91\x90_` \x85\x01\x94\x01\x90a\rqV[V[4a\r\xC3Wa\r\xBFa\r\xAEa\r\xA96`\x04a\rSV[a/\xC0V[a\r\xB6a\x05\x12V[\x91\x82\x91\x82a\r~V[\x03\x90\xF3[a\x05\x18V[4a\r\xF6Wa\r\xD86`\x04a\x05\xCDV[a\r\xE0a4\xBEV[a\r\xE8a\x05\x12V[\x80a\r\xF2\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[\x91\x90`@\x83\x82\x03\x12a\x0E#W\x80a\x0E\x17a\x0E \x92_\x86\x01a\rDV[\x93` \x01a\x07\x85V[\x90V[a\x05\x1CV[4a\x0EWWa\x0EAa\x0E;6`\x04a\r\xFBV[\x90a4\xF2V[a\x0EIa\x05\x12V[\x80a\x0ES\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[`\xFF\x16\x90V[a\x0Ek\x90a\x0E\\V[\x90RV[\x91\x90a\x0E\x82\x90_` \x85\x01\x94\x01\x90a\x0EbV[V[4a\x0E\xB4Wa\x0E\x946`\x04a\x05\xCDV[a\x0E\xB0a\x0E\x9Fa5!V[a\x0E\xA7a\x05\x12V[\x91\x82\x91\x82a\x0EoV[\x03\x90\xF3[a\x05\x18V[\x90` \x82\x82\x03\x12a\x0E\xD2Wa\x0E\xCF\x91_\x01a\x07\xABV[\x90V[a\x05\x1CV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[P`0\x90V[\x90V[a\x0E\xFD\x81a\x0E\xEBV[\x82\x10\x15a\x0F\x17Wa\x0F\x0F`\x01\x91a\x0E\xF1V[\x91\x02\x01\x90_\x90V[a\x0E\xD7V[\x90V[a\x0F/\x90`\x08a\x0F4\x93\x02a\t\xB4V[a\x0F\x1CV[\x90V[\x90a\x0FB\x91Ta\x0F\x1FV[\x90V[`\x10a\x0FP\x81a\x0E\xEBV[\x82\x10\x15a\x0FmWa\x0Fj\x91a\x0Fd\x91a\x0E\xF4V[\x90a\x0F7V[\x90V[_\x80\xFD[4a\x0F\xA1Wa\x0F\x9Da\x0F\x8Ca\x0F\x876`\x04a\x0E\xB9V[a\x0FEV[a\x0F\x94a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x0F\xD4Wa\x0F\xB66`\x04a\x05\xCDV[a\x0F\xBEa5\xD2V[a\x0F\xC6a\x05\x12V[\x80a\x0F\xD0\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\x10\tWa\x0F\xE96`\x04a\x05\xCDV[a\x10\x05a\x0F\xF4a5\xDCV[a\x0F\xFCa\x05\x12V[\x91\x82\x91\x82a\r~V[\x03\x90\xF3[a\x05\x18V[4a\x10=Wa\x10'a\x10!6`\x04a\r\xFBV[\x90a5\xF0V[a\x10/a\x05\x12V[\x80a\x109\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\x10sWa\x10oa\x10^a\x10X6`\x04a\x07\xBAV[\x90a6mV[a\x10fa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x10\xA6Wa\x10\x886`\x04a\x05\xCDV[a\x10\x90a6\xCBV[a\x10\x98a\x05\x12V[\x80a\x10\xA2\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\x10\xDAWa\x10\xC4a\x10\xBE6`\x04a\x07\xBAV[\x90a8(V[a\x10\xCCa\x05\x12V[\x80a\x10\xD6\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[a\x10\xE8\x90a\x06\xA6V[\x90V[\x90a\x10\xF5\x90a\x10\xDFV[_R` R`@_ \x90V[_\x1C\x90V[a\x11\x12a\x11\x17\x91a\x11\x01V[a\x0F\x1CV[\x90V[a\x11$\x90Ta\x11\x06V[\x90V[a\x112\x90`\ra\x10\xEBV[a\x11=_\x82\x01a\x11\x1AV[\x91a\x11J`\x01\x83\x01a\x11\x1AV[\x91a\x11W`\x02\x82\x01a\x11\x1AV[\x91a\x11p`\x04a\x11i`\x03\x85\x01a\x11\x1AV[\x93\x01a\x11\x1AV[\x90V[\x90\x95\x94\x92a\x11\xBE\x94a\x11\xADa\x11\xB7\x92a\x11\xA3`\x80\x96a\x11\x99`\xA0\x88\x01\x9C_\x89\x01\x90a\x08;V[` \x87\x01\x90a\x08;V[`@\x85\x01\x90a\x08;V[``\x83\x01\x90a\x08;V[\x01\x90a\x08;V[V[4a\x11\xF4Wa\x11\xF0a\x11\xDBa\x11\xD66`\x04a\x08\x1DV[a\x11'V[\x91a\x11\xE7\x95\x93\x95a\x05\x12V[\x95\x86\x95\x86a\x11sV[\x03\x90\xF3[a\x05\x18V[a\x12\x05`A_\x90a\x0F7V[\x90V[4a\x128Wa\x12\x186`\x04a\x05\xCDV[a\x124a\x12#a\x11\xF9V[a\x12+a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x12mWa\x12M6`\x04a\x05\xCDV[a\x12ia\x12Xa84V[a\x12`a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x12\xA2Wa\x12\x826`\x04a\x05\xCDV[a\x12\x9Ea\x12\x8Da8\xF5V[a\x12\x95a\x05\x12V[\x91\x82\x91\x82a\x06/V[\x03\x90\xF3[a\x05\x18V[a\x12\xB0\x90a\x07eV[\x90RV[\x91\x90a\x12\xC7\x90_` \x85\x01\x94\x01\x90a\x12\xA7V[V[4a\x12\xF9Wa\x12\xF5a\x12\xE4a\x12\xDF6`\x04a\x08\x1DV[a9\x91V[a\x12\xECa\x05\x12V[\x91\x82\x91\x82a\x12\xB4V[\x03\x90\xF3[a\x05\x18V[4a\x13.Wa\x13\x0E6`\x04a\x05\xCDV[a\x13*a\x13\x19a9\xB0V[a\x13!a\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[4a\x13aWa\x13Ka\x13F6`\x04a\x08\x1DV[a9\xD9V[a\x13Sa\x05\x12V[\x80a\x13]\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\x13\x96Wa\x13v6`\x04a\x05\xCDV[a\x13\x92a\x13\x81a9\xECV[a\x13\x89a\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[\x90V[a\x13\xB2a\x13\xADa\x13\xB7\x92a\x13\x9BV[a\x06\x87V[a\x07\x94V[\x90V[a\x13\xC4`0a\x13\x9EV[\x90V[a\x13\xCFa\x13\xBAV[\x90V[4a\x14\x02Wa\x13\xE26`\x04a\x05\xCDV[a\x13\xFEa\x13\xEDa\x13\xC7V[a\x13\xF5a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x147Wa\x143a\x14\"a\x14\x1D6`\x04a\x08\x1DV[a:\x02V[a\x14*a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x14jWa\x14L6`\x04a\x05\xCDV[a\x14Ta:\xB9V[a\x14\\a\x05\x12V[\x80a\x14f\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[\x90V[a\x14\x86a\x14\x81a\x14\x8B\x92a\x14oV[a\x06\x87V[a\x07\x94V[\x90V[a\x14\xA2jR\xB7\xD2\xDC\xC8\x0C\xD2\xE4\0\0\0a\x14rV[\x90V[a\x14\xADa\x14\x8EV[\x90V[4a\x14\xE0Wa\x14\xC06`\x04a\x05\xCDV[a\x14\xDCa\x14\xCBa\x14\xA5V[a\x14\xD3a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x90a\x14\xEF\x90a\x10\xDFV[_R` R`@_ \x90V[a\x15\x11\x90a\x15\x0C`\x0E\x91_\x92a\x14\xE5V[a\t\xD6V[\x90V[4a\x15DWa\x15@a\x15/a\x15*6`\x04a\x08\x1DV[a\x14\xFBV[a\x157a\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[c\xFF\xFF\xFF\xFF\x16\x90V[a\x15[\x90a\x15IV[\x90RV[\x91\x90a\x15r\x90_` \x85\x01\x94\x01\x90a\x15RV[V[4a\x15\xA4Wa\x15\xA0a\x15\x8Fa\x15\x8A6`\x04a\x08\x1DV[a:\xC7V[a\x15\x97a\x05\x12V[\x91\x82\x91\x82a\x15_V[\x03\x90\xF3[a\x05\x18V[4a\x15\xD9Wa\x15\xD5a\x15\xC4a\x15\xBF6`\x04a\x08\x1DV[a:\xF2V[a\x15\xCCa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x16\x0EWa\x16\na\x15\xF9a\x15\xF46`\x04a\x08\x1DV[a;\x10V[a\x16\x01a\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[a\x16\x1F`B_\x90a\x0F7V[\x90V[4a\x16RWa\x1626`\x04a\x05\xCDV[a\x16Na\x16=a\x16\x13V[a\x16Ea\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x90\x95\x94\x92a\x16\xA2\x94a\x16\x91a\x16\x9B\x92a\x16\x87`\x80\x96a\x16}`\xA0\x88\x01\x9C_\x89\x01\x90a\x05vV[` \x87\x01\x90a\x08;V[`@\x85\x01\x90a\x08;V[``\x83\x01\x90a\x08;V[\x01\x90a\x08;V[V[4a\x16\xD8Wa\x16\xD4a\x16\xBFa\x16\xBA6`\x04a\x08\x1DV[a;/V[\x91a\x16\xCB\x95\x93\x95a\x05\x12V[\x95\x86\x95\x86a\x16WV[\x03\x90\xF3[a\x05\x18V[4a\x17\rWa\x17\ta\x16\xF8a\x16\xF36`\x04a\x08\x1DV[a<\x9FV[a\x17\0a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x17@Wa\x17\"6`\x04a\x05\xCDV[a\x17*a<\xD8V[a\x172a\x05\x12V[\x80a\x17<\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[`\xFF`\xF8\x1B\x16\x90V[a\x17W\x90a\x17EV[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[` \x01\x90V[a\x17w\x90a\x07\x94V[\x90RV[\x90a\x17\x88\x81` \x93a\x17nV[\x01\x90V[` \x01\x90V[\x90a\x17\xAFa\x17\xA9a\x17\xA2\x84a\x17[V[\x80\x93a\x17_V[\x92a\x17hV[\x90_[\x81\x81\x10a\x17\xBFWPPP\x90V[\x90\x91\x92a\x17\xD8a\x17\xD2`\x01\x92\x86Qa\x17{V[\x94a\x17\x8CV[\x91\x01\x91\x90\x91a\x17\xB2V[\x93\x95\x91\x94a\x183a\x18(a\x18G\x95a\x18\x1Aa\x18=\x95a\x18T\x9C\x9Aa\x18\r`\xE0\x8C\x01\x92_\x8D\x01\x90a\x17NV[\x8A\x82\x03` \x8C\x01Ra\x05\xFEV[\x90\x88\x82\x03`@\x8A\x01Ra\x05\xFEV[\x97``\x87\x01\x90a\x08;V[`\x80\x85\x01\x90a\x12\xA7V[`\xA0\x83\x01\x90a\rqV[`\xC0\x81\x84\x03\x91\x01Ra\x17\x92V[\x90V[4a\x18\x8EWa\x18g6`\x04a\x05\xCDV[a\x18\x8Aa\x18ra=_V[\x93a\x18\x81\x97\x95\x97\x93\x91\x93a\x05\x12V[\x97\x88\x97\x88a\x17\xE2V[\x03\x90\xF3[a\x05\x18V[4a\x18\xC3Wa\x18\xBFa\x18\xAEa\x18\xA96`\x04a\x0E\xB9V[a=\xE9V[a\x18\xB6a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x90V[a\x18\xDFa\x18\xDAa\x18\xE4\x92a\x18\xC8V[a\x06\x87V[a\x07\x94V[\x90V[a\x18\xFCk\x03;.<\x9F\xD0\x80<\xE8\0\0\0a\x18\xCBV[\x90V[a\x19\x07a\x18\xE7V[\x90V[4a\x19:Wa\x19\x1A6`\x04a\x05\xCDV[a\x196a\x19%a\x18\xFFV[a\x19-a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x19pWa\x19la\x19[a\x19U6`\x04a\r\xFBV[\x90a>\x1AV[a\x19ca\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x19\x89\x90a\x19uV[\x90RV[\x91\x90a\x19\xA0\x90_` \x85\x01\x94\x01\x90a\x19\x80V[V[4a\x19\xD2Wa\x19\xB26`\x04a\x05\xCDV[a\x19\xCEa\x19\xBDa>HV[a\x19\xC5a\x05\x12V[\x91\x82\x91\x82a\x19\x8DV[\x03\x90\xF3[a\x05\x18V[4a\x1A\x07Wa\x19\xE76`\x04a\x05\xCDV[a\x1A\x03a\x19\xF2a>\\V[a\x19\xFAa\x05\x12V[\x91\x82\x91\x82a\x06/V[\x03\x90\xF3[a\x05\x18V[\x90V[a\x1A#a\x1A\x1Ea\x1A(\x92a\x1A\x0CV[a\x06\x87V[a\x07\x94V[\x90V[a\x1A7b\x01Q\x80a\x1A\x0FV[\x90V[a\x1ABa\x1A+V[\x90V[4a\x1AuWa\x1AU6`\x04a\x05\xCDV[a\x1Aqa\x1A`a\x1A:V[a\x1Aha\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x1A\xAAWa\x1A\xA6a\x1A\x95a\x1A\x906`\x04a\x08\x1DV[a>rV[a\x1A\x9Da\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x1A\xDFWa\x1A\xDBa\x1A\xCAa\x1A\xC56`\x04a\x08\x1DV[a>\xCDV[a\x1A\xD2a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x90V[a\x1A\xFBa\x1A\xF6a\x1B\0\x92a\x1A\xE4V[a\x06\x87V[a\x07\x94V[\x90V[a\x1B\x18k\x02\xE8vi\xC3\x08sj\x04\0\0\0a\x1A\xE7V[\x90V[a\x1B#a\x1B\x03V[\x90V[4a\x1BVWa\x1B66`\x04a\x05\xCDV[a\x1BRa\x1BAa\x1B\x1BV[a\x1BIa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x1B\x8AWa\x1Bta\x1Bn6`\x04a\x07\xBAV[\x90a@OV[a\x1B|a\x05\x12V[\x80a\x1B\x86\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[\x90\x91``\x82\x84\x03\x12a\x1B\xC4Wa\x1B\xC1a\x1B\xAA\x84_\x85\x01a\x07\x85V[\x93a\x1B\xB8\x81` \x86\x01a\x07\xABV[\x93`@\x01a\x07\xABV[\x90V[a\x05\x1CV[4a\x1B\xF8Wa\x1B\xE2a\x1B\xDC6`\x04a\x1B\x8FV[\x91aB\xD5V[a\x1B\xEAa\x05\x12V[\x80a\x1B\xF4\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[\x90V[_\x1B\x90V[a\x1C\x19a\x1C\x14a\x1C\x1E\x92a\x1B\xFDV[a\x1C\0V[a\r-V[\x90V[a\x1C*_a\x1C\x05V[\x90V[a\x1C5a\x1C!V[\x90V[4a\x1ChWa\x1CH6`\x04a\x05\xCDV[a\x1Cda\x1CSa\x1C-V[a\x1C[a\x05\x12V[\x91\x82\x91\x82a\r~V[\x03\x90\xF3[a\x05\x18V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x1C\x88\x90`\x08a\x1C\x8D\x93\x02a\t\xB4V[a\x1CmV[\x90V[\x90a\x1C\x9B\x91Ta\x1CxV[\x90V[a\x1C\xAA`D_\x90a\x1C\x90V[\x90V[\x91\x90a\x1C\xC0\x90_` \x85\x01\x94\x01\x90a\x06\xBEV[V[4a\x1C\xF2Wa\x1C\xD26`\x04a\x05\xCDV[a\x1C\xEEa\x1C\xDDa\x1C\x9EV[a\x1C\xE5a\x05\x12V[\x91\x82\x91\x82a\x1C\xADV[\x03\x90\xF3[a\x05\x18V[4a\x1D'Wa\x1D\x076`\x04a\x05\xCDV[a\x1D#a\x1D\x12aB\xE2V[a\x1D\x1Aa\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[a\x1D5\x90a\x07eV[\x90V[a\x1DA\x81a\x1D,V[\x03a\x1DHWV[_\x80\xFD[\x90P5\x90a\x1DY\x82a\x1D8V[V[\x90` \x82\x82\x03\x12a\x1DtWa\x1Dq\x91_\x01a\x1DLV[\x90V[a\x05\x1CV[4a\x1D\xA7Wa\x1D\x91a\x1D\x8C6`\x04a\x1D[V[aD9V[a\x1D\x99a\x05\x12V[\x80a\x1D\xA3\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\x1D\xDCWa\x1D\xBC6`\x04a\x05\xCDV[a\x1D\xD8a\x1D\xC7aDcV[a\x1D\xCFa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x90V[a\x1D\xF8a\x1D\xF3a\x1D\xFD\x92a\x1D\xE1V[a\x06\x87V[a\x07\x94V[\x90V[a\x1E\x0Cb'\x8D\0a\x1D\xE4V[\x90V[a\x1E\x17a\x1E\0V[\x90V[4a\x1EJWa\x1E*6`\x04a\x05\xCDV[a\x1EFa\x1E5a\x1E\x0FV[a\x1E=a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a\x1E\x80Wa\x1E|a\x1Eka\x1Ee6`\x04a\x07\xBAV[\x90aD\xDDV[a\x1Esa\x05\x12V[\x91\x82\x91\x82a\x05\x83V[\x03\x90\xF3[a\x05\x18V[\x90V[a\x1E\x9Ca\x1E\x97a\x1E\xA1\x92a\x1E\x85V[a\x06\x87V[a\x07\x94V[\x90V[a\x1E\xB5g\r\xE0\xB6\xB3\xA7d\0\0a\x1E\x88V[\x90V[a\x1E\xC0a\x1E\xA4V[\x90V[4a\x1E\xF3Wa\x1E\xD36`\x04a\x05\xCDV[a\x1E\xEFa\x1E\xDEa\x1E\xB8V[a\x1E\xE6a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[P`0\x90V[\x90P\x90V[\x90V[` \x01\x90V[a\x1F(a\x1F\"a\x1F\x1B\x83a\x1E\xF8V[\x80\x94a\x1E\xFEV[\x91a\x1F\x03V[_\x91[\x83\x83\x10a\x1F8WPPPPV[a\x1FNa\x1FH`\x01\x92\x84Qa\x17{V[\x92a\x1F\x06V[\x92\x01\x91\x90a\x1F+V[\x91\x90a\x1Fk\x90_a\x06\0\x85\x01\x94\x01\x90a\x1F\x0CV[V[4a\x1F\x9DWa\x1F}6`\x04a\x05\xCDV[a\x1F\x99a\x1F\x88aF\x04V[a\x1F\x90a\x05\x12V[\x91\x82\x91\x82a\x1FWV[\x03\x90\xF3[a\x05\x18V[4a\x1F\xD3Wa\x1F\xCFa\x1F\xBEa\x1F\xB86`\x04a\x07\xBAV[\x90aF\x1AV[a\x1F\xC6a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[a \ra \x14\x94a \x03``\x94\x98\x97\x95a\x1F\xF9`\x80\x86\x01\x9A_\x87\x01\x90a\x08;V[` \x85\x01\x90a\x08;V[`@\x83\x01\x90a\x08;V[\x01\x90a\x05vV[V[4a JWa &6`\x04a\x05\xCDV[a Fa 1aF0V[\x90a =\x94\x92\x94a\x05\x12V[\x94\x85\x94\x85a\x1F\xD8V[\x03\x90\xF3[a\x05\x18V[4a \x7FWa {a ja e6`\x04a\x08\x1DV[aH\x07V[a ra\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a \xB4Wa \x946`\x04a\x05\xCDV[a \xB0a \x9FaH\x1CV[a \xA7a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[4a \xE9Wa \xE5a \xD4a \xCF6`\x04a\x08\x1DV[aH0V[a \xDCa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[a \xF7\x81a\x0E\\V[\x03a \xFEWV[_\x80\xFD[\x90P5\x90a!\x0F\x82a \xEEV[V[\x90\x91`\xC0\x82\x84\x03\x12a!pWa!)\x83_\x84\x01a\x07\x85V[\x92a!7\x81` \x85\x01a\x07\xABV[\x92a!E\x82`@\x83\x01a\x07\xABV[\x92a!ma!V\x84``\x85\x01a!\x02V[\x93a!d\x81`\x80\x86\x01a\rDV[\x93`\xA0\x01a\rDV[\x90V[a\x05\x1CV[4a!\xAAWa!\x94a!\x886`\x04a!\x11V[\x94\x93\x90\x93\x92\x91\x92aH\xBAV[a!\x9Ca\x05\x12V[\x80a!\xA6\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[`\xE0\x81\x83\x03\x12a\"\x1AWa!\xC5\x82_\x83\x01a\x07\x85V[\x92a!\xD3\x83` \x84\x01a\x07\x85V[\x92a!\xE1\x81`@\x85\x01a\x07\xABV[\x92a!\xEF\x82``\x83\x01a\x07\xABV[\x92a\"\x17a\"\0\x84`\x80\x85\x01a!\x02V[\x93a\"\x0E\x81`\xA0\x86\x01a\rDV[\x93`\xC0\x01a\rDV[\x90V[a\x05\x1CV[4a\"TWa\">a\"26`\x04a!\xAFV[\x95\x94\x90\x94\x93\x91\x93aJ\x0EV[a\"Fa\x05\x12V[\x80a\"P\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[4a\"\x88Wa\"ra\"l6`\x04a\r\xFBV[\x90aK,V[a\"za\x05\x12V[\x80a\"\x84\x81a\t\x13V[\x03\x90\xF3[a\x05\x18V[\x91\x90`@\x83\x82\x03\x12a\"\xB5W\x80a\"\xA9a\"\xB2\x92_\x86\x01a\x07\x85V[\x93` \x01a\x07\x85V[\x90V[a\x05\x1CV[4a\"\xEBWa\"\xE7a\"\xD6a\"\xD06`\x04a\"\x8DV[\x90aKNV[a\"\xDEa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x7Fk\x97%\xF7@\xF9K\x91\xB7\x80`\xA1\xB1}\x17tem8\x14!\xA5)\xEC\x98\xCD\xB0\x13\xF4\xD9\xC2^\x90V[a#\x1Ca\"\xF0V[\x90V[4a#OWa#/6`\x04a\x05\xCDV[a#Ka#:a#\x14V[a#Ba\x05\x12V[\x91\x82\x91\x82a\r~V[\x03\x90\xF3[a\x05\x18V[\x7Fe\xD7\xA2\x8E2e\xB3zdt\x92\x9F3e!\xB32\xC1h\x1B\x93?l\xB9\xF37fsD\r\x86*\x90V[a#\x80a#TV[\x90V[4a#\xB3Wa#\x936`\x04a\x05\xCDV[a#\xAFa#\x9Ea#xV[a#\xA6a\x05\x12V[\x91\x82\x91\x82a\r~V[\x03\x90\xF3[a\x05\x18V[a#\xC1\x81a\x15IV[\x03a#\xC8WV[_\x80\xFD[\x90P5\x90a#\xD9\x82a#\xB8V[V[\x91\x90`@\x83\x82\x03\x12a$\x03W\x80a#\xF7a$\0\x92_\x86\x01a\x07\x85V[\x93` \x01a#\xCCV[\x90V[a\x05\x1CV[a$\x11\x90a\x19uV[\x90RV[`\x01\x80`\xD0\x1B\x03\x16\x90V[a$)\x90a$\x15V[\x90RV[\x90` \x80a$O\x93a$E_\x82\x01Q_\x86\x01\x90a$\x08V[\x01Q\x91\x01\x90a$ V[V[\x91\x90a$d\x90_`@\x85\x01\x94\x01\x90a$-V[V[4a$\x97Wa$\x93a$\x82a$|6`\x04a#\xDBV[\x90aK\xBCV[a$\x8Aa\x05\x12V[\x91\x82\x91\x82a$QV[\x03\x90\xF3[a\x05\x18V[a$\xA8`C_\x90a\x0F7V[\x90V[4a$\xDBWa$\xBB6`\x04a\x05\xCDV[a$\xD7a$\xC6a$\x9CV[a$\xCEa\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xF3[a\x05\x18V[\x7F\xCC\xE2\x96\xB0@3*\x08\x0Em\xF15\x15\xA3\xEC(i\xE2\x1C\xD2\x0FsD\xAF\t\x87\xDD\xB98\xD8\xBD!\x90V[a%\x0Ca$\xE0V[\x90V[4a%?Wa%\x1F6`\x04a\x05\xCDV[a%;a%*a%\x04V[a%2a\x05\x12V[\x91\x82\x91\x82a\r~V[\x03\x90\xF3[a\x05\x18V[_\x80\xFD[_\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a%la%r\x91a$\x15V[\x91a$\x15V[\x01\x90`\x01\x80`\xD0\x1B\x03\x82\x11a%\x83WV[a%LV[\x90a%\x9B\x91a%\x95a%HV[Pa%`V[\x90V[a%\xAAa%\xB0\x91a$\x15V[\x91a$\x15V[\x90\x03\x90`\x01\x80`\xD0\x1B\x03\x82\x11a%\xC2WV[a%LV[\x90a%\xDA\x91a%\xD4a%HV[Pa%\x9EV[\x90V[_\x90V[a%\xE9a%\xDDV[P\x80a&\x04a%\xFEcye\xDB\x0B`\xE0\x1Ba\x05$V[\x91a\x05$V[\x14\x90\x81\x15a&\x11W[P\x90V[a&\x1B\x91PaK\xD2V[_a&\rV[``\x90V[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a&Ra&K\x83a\x0B\x85V[\x80\x94a&&V[\x91`\x01\x81\x16\x90\x81_\x14a&\xA9WP`\x01\x14a&mW[PPPV[a&z\x91\x92\x93\x94Pa&/V[\x91_\x92[\x81\x84\x10a&\x91WPP\x01\x90_\x80\x80a&hV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a&~V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a&hV[\x90a&\xCE\x91a&8V[\x90V[\x90a&\xF1a&\xEA\x92a&\xE1a\x05\x12V[\x93\x84\x80\x92a&\xC4V[\x03\x83a\x0CnV[V[a&\xFC\x90a&\xD1V[\x90V[a'\x07a&!V[Pa'\x12`\x03a&\xF3V[\x90V[_\x90V[``\x90V[a'*a'/\x91a\x11\x01V[a\x1CmV[\x90V[a'<\x90Ta'\x1EV[\x90V[a'H\x90a\x0C\x97V[\x90V[a'Sa'\x15V[Pa'\\a'\x19V[Pa'g`Da'2V[\x90a'r`Ea'?V[\x90V[a'\x92\x91a'\x81a%\xDDV[Pa'\x8AaK\xF8V[\x91\x90\x91aL\x05V[`\x01\x90V[_\x90V[_a'\xB3a'\xB9\x92a'\xABa'\x97V[P`\ra\x10\xEBV[\x01a\x11\x1AV[\x90V[\x90a'\xD6\x91a'\xD1a'\xCCa$\xE0V[aL\x15V[a*6V[V[P\x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a(\x05\x91\x02\x91a'\xFF_\x19\x84a'\xE6V[\x92a'\xE6V[\x91\x81\x19\x16\x91\x16\x17\x90V[a(#a(\x1Ea((\x92a\x07\x94V[a\x06\x87V[a\x07\x94V[\x90V[\x90V[\x91\x90a(Da(?a(L\x93a(\x0FV[a(+V[\x90\x83Ta'\xEAV[\x90UV[a(b\x91a(\\a'\x97V[\x91a(.V[V[[\x81\x81\x10a(pWPPV[\x80a(}_`\x01\x93a(PV[\x01a(eV[\x91\x90`\x1F\x81\x11a(\x93W[PPPV[a(\x9Fa(\xC4\x93a\x0B\xB8V[\x90` a(\xAB\x84a'\xDCV[\x83\x01\x93\x10a(\xCCW[a(\xBD\x90a'\xDCV[\x01\x90a(dV[_\x80\x80a(\x8EV[\x91Pa(\xBD\x81\x92\x90Pa(\xB4V[\x90a(\xEA\x90_\x19\x90`\x08\x02a\t\xB4V[\x19\x16\x90V[\x81a(\xF9\x91a(\xDAV[\x90`\x02\x02\x17\x90V[\x91a)\x0C\x90\x82a'\xD8V[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a)\xCBWa)0\x82a)*\x85Ta\x0B\x85V[\x85a(\x83V[_\x90`\x1F\x83\x11`\x01\x14a)cW\x91\x80\x91a)R\x93_\x92a)WW[PPa(\xEFV[\x90U[V[\x90\x91P\x015_\x80a)KV[`\x1F\x19\x83\x16\x91a)r\x85a\x0B\xB8V[\x92_[\x81\x81\x10a)\xB3WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a)\x99W[PPP\x02\x01\x90Ua)UV[a)\xA9\x91\x015`\x1F\x84\x16\x90a(\xDAV[\x90U_\x80\x80a)\x8DV[\x91\x93` `\x01\x81\x92\x87\x87\x015\x81U\x01\x95\x01\x92\x01a)uV[a\x0CZV[\x90a)\xDB\x92\x91a)\x01V[V[\x90\x82_\x93\x92\x827\x01RV[\x91\x90a*\x02\x81a)\xFB\x81a*\x07\x95a\x06\xCFV[\x80\x95a)\xDDV[a\x05\xF4V[\x01\x90V[\x91a*%a*3\x94\x92`@\x85\x01\x90\x85\x82\x03_\x87\x01Ra\x06\xD8V[\x92` \x81\x85\x03\x91\x01Ra)\xE8V[\x90V[\x90a*A`Ea'?V[a*N\x83\x83\x90`Ea)\xD0V[\x91\x90\x91a*\x87\x7F\xB9\xA2\x08\x84&\xF0;0\xA8\x1C\x06B\x80\x94\xFB\xFA\x9E&\x92s\x9B2A\xAFk\x9A\xB1\xDAKUF\xBE\x93a*~a\x05\x12V[\x93\x84\x93\x84a*\x0BV[\x03\x90\xA1V[\x90a*\x96\x91a'\xBCV[V[a*\xA0a'\x97V[Pa*\xAB`\x02a\x11\x1AV[\x90V[a*\xBEa*\xB9a\"\xF0V[aL\x15V[a*\xC6a+\x87V[V[a*\xDCa*\xD7a*\xE1\x92a\x1B\xFDV[a\x06\x87V[a\x07\x94V[\x90V[a*\xF8a*\xF3a*\xFD\x92a\x1B\xFDV[a\x06\x87V[a\x06|V[\x90V[a+\t\x90a*\xE4V[\x90V[\x90a+\x18`\xFF\x91a\x1C\0V[\x91\x81\x19\x16\x91\x16\x17\x90V[a++\x90a\x05qV[\x90V[\x90V[\x90a+Fa+Aa+M\x92a+\"V[a+.V[\x82Ta+\x0CV[\x90UV[\x90a+]_\x19\x91a\x1C\0V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a+|a+wa+\x83\x92a(\x0FV[a(+V[\x82Ta+QV[\x90UV[a+\x91`Aa\x11\x1AV[a+\xA3a+\x9D_a*\xC8V[\x91a\x07\x94V[\x03a,HWa+\xBAa+\xB5`Da'2V[a\x06\xB2V[a+\xD4a+\xCEa+\xC9_a+\0V[a\x07eV[\x91a\x07eV[\x14a,,Wa+\xE5`\x01`@a+1V[a+\xF0B`Aa+gV[Ba,'\x7F\x11\x94\xB04\xCF\xA9\xABX\x07IJ\x1D\\f}\x8B\x0En\x97\xF3\x88\x88t*\xA3\x87\x1A2 4\x11`\x91a,\x1Ea\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xA1V[_c;\nH\xBD`\xE1\x1B\x81R\x80a,D`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c8\xE9=\xBD`\xE1\x1B\x81R\x80a,``\x04\x82\x01a\t\x13V[\x03\x90\xFD[a,la*\xAEV[V[\x91a,\x98\x92a,{a%\xDDV[Pa,\x90a,\x87aK\xF8V[\x82\x90\x84\x91aLiV[\x91\x90\x91aL\xF5V[`\x01\x90V[a,\xA6\x90a\x06\xA6V[\x90V[_\x80\xFD[`\xE0\x1B\x90V[\x90PQ\x90a,\xC0\x82a\x07\x97V[V[\x90` \x82\x82\x03\x12a,\xDBWa,\xD8\x91_\x01a,\xB3V[\x90V[a\x05\x1CV[a,\xE8a\x05\x12V[=_\x82>=\x90\xFD[a,\xFFa-\x05\x91\x93\x92\x93a\x07\x94V[\x92a\x07\x94V[\x82\x03\x91\x82\x11a-\x10WV[a%LV[\x90V[a-,a-'a-1\x92a-\x15V[a\x06\x87V[a\x07\x94V[\x90V[a-Ca-I\x91\x93\x92\x93a\x07\x94V[\x92a\x07\x94V[\x91a-U\x83\x82\x02a\x07\x94V[\x92\x81\x84\x04\x14\x90\x15\x17\x15a-dWV[a%LV[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[a-\x89a-\x8F\x91a\x07\x94V[\x91a\x07\x94V[\x90\x81\x15a-\x9AW\x04\x90V[a-iV[a-\xA7a'\x97V[\x91a-\xB0a'\x97V[\x91a-\xC7_a-\xC1`\r\x84\x90a\x10\xEBV[\x01a\x11\x1AV[\x90a-\xDF`\x02a-\xD9`\r\x84\x90a\x10\xEBV[\x01a\x11\x1AV[\x91a.\x18` a-\xEE0a,\x9DV[ce\x1F\xD2h\x90a.\r\x86\x92a.\x01a\x05\x12V[\x95\x86\x94\x85\x93\x84\x93a,\xADV[\x83R`\x04\x83\x01a\x12\xB4V[\x03\x91Z\xFA\x90\x81\x15a/qWa.c\x91` \x91_\x91a/DW[P\x93a.<0a,\x9DV[a.Xc\x99\x89U\xD3a.La\x05\x12V[\x95\x86\x94\x85\x93\x84\x93a,\xADV[\x83R`\x04\x83\x01a\x12\xB4V[\x03\x91Z\xFA\x90\x81\x15a/?W_\x91a/\x11W[P\x91\x81a.\x8Aa.\x84_a*\xC8V[\x91a\x07\x94V[\x11a.\xE0W[PP\x81a.\xA5a.\x9F_a*\xC8V[\x91a\x07\x94V[\x11a.\xAFW[PPV[a.\xD8\x92\x93Pa.\xC2a.\xD3\x91\x83a,\xF0V[a.\xCDa'\x10a-\x18V[\x90a-4V[a-}V[\x90_\x80a.\xABV[a/\t\x92\x96Pa.\xF3a/\x04\x91\x83a,\xF0V[a.\xFEa'\x10a-\x18V[\x90a-4V[a-}V[\x93_\x80a.\x90V[a/2\x91P` =\x81\x11a/8W[a/*\x81\x83a\x0CnV[\x81\x01\x90a,\xC2V[_a.uV[P=a/ V[a,\xE0V[a/d\x91P\x82=\x81\x11a/jW[a/\\\x81\x83a\x0CnV[\x81\x01\x90a,\xC2V[_a.1V[P=a/RV[a,\xE0V[_\x90V[a/\x83\x90a\r-V[\x90V[\x90a/\x90\x90a/zV[_R` R`@_ \x90V[\x90V[a/\xABa/\xB0\x91a\x11\x01V[a/\x9CV[\x90V[a/\xBD\x90Ta/\x9FV[\x90V[`\x01a/\xD9a/\xDF\x92a/\xD1a/vV[P`\x05a/\x86V[\x01a/\xB3V[\x90V[a/\xEAaM\x92V[a/\xF2a/\xF4V[V[a/\xFCaM\xE8V[a0\x04a0\x0EV[a0\x0CaNMV[V[a0\x1Ea0\x19a\"\xF0V[aL\x15V[a0&a1XV[V[a04a09\x91a\x11\x01V[a\t\xB8V[\x90V[a0F\x90Ta0(V[\x90V[`\x01a0U\x91\x01a\x07\x94V[\x90V[a0ga0m\x91\x93\x92\x93a\x07\x94V[\x92a\x07\x94V[\x82\x01\x80\x92\x11a0xWV[a%LV[a0\x86\x90a\x06\xA6V[\x90V[_\x91\x03\x12a0\x93WV[a\x05\x1CV[\x90_\x92\x91\x80T\x90a0\xB2a0\xAB\x83a\x0B\x85V[\x80\x94a\x06\xCFV[\x91`\x01\x81\x16\x90\x81_\x14a1\tWP`\x01\x14a0\xCDW[PPPV[a0\xDA\x91\x92\x93\x94Pa\x0B\xB8V[\x91_\x92[\x81\x84\x10a0\xF1WPP\x01\x90_\x80\x80a0\xC8V[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a0\xDEV[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a0\xC8V[a1Ha1U\x94\x92\x93a1>``\x84\x01\x95_\x85\x01\x90a\x12\xA7V[` \x83\x01\x90a\x08;V[`@\x81\x84\x03\x91\x01Ra0\x98V[\x90V[a1ka1e`@a0<V[\x15a\x05qV[a4\xA2Wa1waB\xE2V[a4\x86Wa1\xA0a1\x92Ba1\x8C`Aa\x11\x1AV[\x90a,\xF0V[a1\x9Aa\x1E\0V[\x90a-}V[Ba1\xCBa1\xC5a1\xC0a1\xB2aDcV[a1\xBAa\x0B\x10V[\x90a,\xF0V[a\x07\x94V[\x91a\x07\x94V[\x10a4jWa1\xE4\x90a1\xDE`Ba\x11\x1AV[\x90a,\xF0V[\x90\x81a2\x12a2\x0Ca2\x07a1\xF7a\x13\xBAV[a2\x01`Ba\x11\x1AV[\x90a,\xF0V[a\x07\x94V[\x91a\x07\x94V[\x11a4GW[a2!_a*\xC8V[\x90a2+_a*\xC8V[\x91[\x82a2@a2:\x86a\x07\x94V[\x91a\x07\x94V[\x10\x15a2\x87Wa2{a2\x81\x91a2ua2o`\x10a2ia2b`Ba\x11\x1AV[\x89\x90a0XV[\x90a\x0E\xF4V[\x90a\x0F7V[\x90a0XV[\x92a0IV[\x91a2-V[\x91P\x91a2\x9Ea2\x97`Ca\x11\x1AV[\x83\x90a0XV[a2\xB7a2\xB1a2\xACa\x14\x8EV[a\x07\x94V[\x91a\x07\x94V[\x11a4+Wa2\xD2a2\xD9\x91a2\xCD`Ba\x11\x1AV[a0XV[`Ba+gV[a2\xF6a2\xEF\x82a2\xEA`Ca\x11\x1AV[a0XV[`Ca+gV[a3\ta3\x020a0}V[\x82\x90aNaV[a3.a3\x150a0}V[a3'a3\"`Da'2V[a\x06\xB2V[\x83\x91aL\x05V[a3@a3;`Da'2V[a\x06\xB2V[c\x18\xB6\x8B\x8Ca3N0a0}V[\x83\x92`E\x92\x81;\x15a4&W_a3x\x91a3\x83\x82\x96a3la\x05\x12V[\x98\x89\x97\x88\x96\x87\x95a,\xADV[\x85R`\x04\x85\x01a1$V[\x03\x92Z\xF1\x80\x15a4!Wa3\xF5W[Pa3\x9D`Ba\x11\x1AV[\x90a3\xB0a3\xAB`Da'2V[a\x06\xB2V[\x90a3\xDB\x7F4\xB7=\x0C\x96\xE9\xFFMS\x11CH\x17\xC8\xEC\xC90\xE7\xD2x,[\xDE.y\xDCD\xB0YgU\xBB\x92a\x10\xDFV[\x92a3\xF0a3\xE7a\x05\x12V[\x92\x83\x92\x83a\n\x98V[\x03\x90\xA2V[a4\x14\x90_=\x81\x11a4\x1AW[a4\x0C\x81\x83a\x0CnV[\x81\x01\x90a0\x89V[_a3\x92V[P=a4\x02V[a,\xE0V[a,\xA9V[_c#\x06N\xBD`\xE0\x1B\x81R\x80a4C`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x90Pa4da4Ta\x13\xBAV[a4^`Ba\x11\x1AV[\x90a,\xF0V[\x90a2\x18V[_c=S\xC7S`\xE0\x1B\x81R\x80a4\x82`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c\x11UbK`\xE2\x1B\x81R\x80a4\x9E`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c\x19\xAF\xC9\x9D`\xE2\x1B\x81R\x80a4\xBA`\x04\x82\x01a\t\x13V[\x03\x90\xFD[a4\xC6a/\xE2V[V[\x90a4\xE3\x91a4\xDEa4\xD9\x82a/\xC0V[aL\x15V[a4\xE5V[V[\x90a4\xEF\x91aN\xBFV[PV[\x90a4\xFC\x91a4\xC8V[V[_\x90V[\x90V[a5\x19a5\x14a5\x1E\x92a5\x02V[a\x06\x87V[a\x0E\\V[\x90V[a5)a4\xFEV[Pa54`\x12a5\x05V[\x90V[a5Ga5Ba\"\xF0V[aL\x15V[a5Oa5QV[V[a5[`Aa\x11\x1AV[a5ma5g_a*\xC8V[\x91a\x07\x94V[\x14a5\xB6Wa5~`\x01`@a+1V[\x7FJy*\x0B\xE4+Vr\xFA\xA4\x01)\xFCdi\x07$\x90w\\\xA8\xD3\xC3N\x85-MU\xD3\xA75\xA9a5\xA7a\x05\x12V[\x80a5\xB1\x81a\t\x13V[\x03\x90\xA1V[_c\x8F\x98@A`\xE0\x1B\x81R\x80a5\xCE`\x04\x82\x01a\t\x13V[\x03\x90\xFD[a5\xDAa57V[V[a5\xE4a/vV[Pa5\xEDaOkV[\x90V[\x90\x80a6\x0Ba6\x05a6\0aK\xF8V[a\x07eV[\x91a\x07eV[\x03a6\x1CWa6\x19\x91aP%V[PV[_c3K\xD9\x19`\xE1\x1B\x81R\x80a64`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x90a6B\x90a\x10\xDFV[_R` R`@_ \x90V[\x90V[a6ea6`a6j\x92a$\x15V[a\x06\x87V[a\x07\x94V[\x90V[a6\xA4\x91a6\x99a6\x93a6\x8Ea6\x9F\x94a6\x86a'\x97V[P`\na68V[a6NV[\x91aQ\x06V[\x90aQ\xFCV[a6QV[\x90V[a6\xB7a6\xB2a\x1C!V[aL\x15V[a6\xBFa6\xC1V[V[a6\xC9aS\x83V[V[a6\xD3a6\xA7V[V[\x90a6\xE7\x91a6\xE2aM\xE8V[a6\xF1V[a6\xEFaNMV[V[\x90\x81a7\ra7\x07a7\x02_a+\0V[a\x07eV[\x91a\x07eV[\x14a8\x0CW\x80a7%a7\x1F_a*\xC8V[\x91a\x07\x94V[\x14a7\xF0Wa7Ga7Aa7<`\x0E3\x90a\x14\xE5V[a0<V[\x15a\x05qV[a7\xD4Wa7T3aS\x90V[a7k`\x01a7e`\r3\x90a\x10\xEBV[\x01a\x11\x1AV[a7}a7w\x83a\x07\x94V[\x91a\x07\x94V[\x10a7\xB8Wa7\xB6\x91a7\xB1\x82a7\xAB`\x01a7\x9B`\r3\x90a\x10\xEBV[\x01\x91a7\xA6\x83a\x11\x1AV[a,\xF0V[\x90a+gV[aNaV[V[_c\x1C\x95\x9E\xD9`\xE2\x1B\x81R\x80a7\xD0`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_cD\x17v\t`\xE1\x1B\x81R\x80a7\xEC`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a8\x08`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a8$`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x90a82\x91a6\xD5V[V[a8<a'\x97V[Pa8Xa8Ha\x14\x8EV[a8R`Ca\x11\x1AV[\x90a,\xF0V[\x90V[\x90a8na8ga\x05\x12V[\x92\x83a\x0CnV[V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a8\x8EWa8\x8A` \x91a\x05\xF4V[\x01\x90V[a\x0CZV[\x90a8\xA5a8\xA0\x83a8pV[a8[V[\x91\x82RV[_\x7Fmode=blocknumber&from=default\0\0\0\x91\x01RV[a8\xDB`\x1Da8\x93V[\x90a8\xE8` \x83\x01a8\xAAV[V[a8\xF2a8\xD1V[\x90V[a8\xFDa&!V[Pa9\x06a>HV[a9\x1Fa9\x19a9\x14aU_V[a\x19uV[\x91a\x19uV[\x03a9/Wa9,a8\xEAV[\x90V[_c\x01\xBF\xC1\xC5`\xE6\x1B\x81R\x80a9G`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_\x90V[\x90a9Y\x90a\x10\xDFV[_R` R`@_ \x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a9|a9\x81\x91a\x11\x01V[a9eV[\x90V[a9\x8E\x90Ta9pV[\x90V[a9\xA8a9\xAD\x91a9\xA0a9KV[P`\ta9OV[a9\x84V[\x90V[a9\xB8a%\xDDV[Pa9\xC3`Aa\x11\x1AV[a9\xD5a9\xCF_a*\xC8V[\x91a\x07\x94V[\x11\x90V[a9\xEA\x90a9\xE5aK\xF8V[aU\x97V[V[a9\xF4a%\xDDV[Pa9\xFF`\x0Fa0<V[\x90V[a:Y\x90a:\x0Ea'\x97V[Pa:&`\x01a: `\r\x84\x90a\x10\xEBV[\x01a\x11\x1AV[\x90a:S`\x04a:Ma:E_a:?`\r\x87\x90a\x10\xEBV[\x01a\x11\x1AV[\x93`\ra\x10\xEBV[\x01a\x11\x1AV[\x91aV\"V[\x90V[a:la:ga#TV[aL\x15V[a:ta:vV[V[a:\x81_`@a+1V[\x7Fs\xA5\xFC`\xAA\xFE\xEC\x8F\x13\x9A\xF2-\x98\xE6!@\xE2\xCE\x91M\x1F\x15\\i+BwW\xC3\xE4\x01La:\xAAa\x05\x12V[\x80a:\xB4\x81a\t\x13V[\x03\x90\xA1V[a:\xC1a:\\V[V[_\x90V[a:\xD9\x90a:\xD3a:\xC3V[PaV\xCFV[\x90V[\x90a:\xE6\x90a\x10\xDFV[_R` R`@_ \x90V[a;\x08a;\r\x91a;\x01a'\x97V[P_a:\xDCV[a\x11\x1AV[\x90V[a;'a;,\x91a;\x1Fa%\xDDV[P`\x0Ea\x14\xE5V[a0<V[\x90V[\x90a;8a%\xDDV[Pa;Aa'\x97V[Pa;Ja'\x97V[Pa;Sa'\x97V[Pa;\\a'\x97V[Pa;qa;l`\x0E\x84\x90a\x14\xE5V[a0<V[\x91a;\x88_a;\x82`\r\x84\x90a\x10\xEBV[\x01a\x11\x1AV[\x91a;\xA0`\x02a;\x9A`\r\x85\x90a\x10\xEBV[\x01a\x11\x1AV[\x90a;\xD9` a;\xAF0a,\x9DV[ce\x1F\xD2h\x90a;\xCE\x87\x92a;\xC2a\x05\x12V[\x95\x86\x94\x85\x93\x84\x93a,\xADV[\x83R`\x04\x83\x01a\x12\xB4V[\x03\x91Z\xFA\x90\x81\x15a<\x9AWa<$\x91` \x91_\x91a<mW[P\x94a;\xFD0a,\x9DV[a<\x19c\x99\x89U\xD3a<\ra\x05\x12V[\x95\x86\x94\x85\x93\x84\x93a,\xADV[\x83R`\x04\x83\x01a\x12\xB4V[\x03\x91Z\xFA\x90\x81\x15a<hW_\x91a<:W[P\x90V[a<[\x91P` =\x81\x11a<aW[a<S\x81\x83a\x0CnV[\x81\x01\x90a,\xC2V[_a<6V[P=a<IV[a,\xE0V[a<\x8D\x91P\x82=\x81\x11a<\x93W[a<\x85\x81\x83a\x0CnV[\x81\x01\x90a,\xC2V[_a;\xF2V[P=a<{V[a,\xE0V[a<\xB1\x90a<\xABa'\x97V[PaV\xFEV[\x90V[a<\xC4a<\xBFa#TV[aL\x15V[a<\xCCa<\xCEV[V[a<\xD6aWtV[V[a<\xE0a<\xB4V[V[_\x90V[``\x90V[a<\xF4\x90a\x06\xA6V[\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a=\x0FW` \x80\x91\x02\x01\x90V[a\x0CZV[\x90a=&a=!\x83a<\xF7V[a8[V[\x91\x82RV[6\x907V[\x90a=Ua==\x83a=\x14V[\x92` \x80a=K\x86\x93a<\xF7V[\x92\x01\x91\x03\x90a=+V[V[`\x0F`\xF8\x1B\x90V[a=ga<\xE2V[Pa=pa&!V[Pa=ya&!V[Pa=\x82a'\x97V[Pa=\x8Ba9KV[Pa=\x94a/vV[Pa=\x9Da<\xE6V[Pa=\xA6aW\x81V[\x90a=\xAFaW\xC1V[\x90F\x90a=\xBB0a<\xEBV[\x90a=\xC5_a\x1C\x05V[\x90a=\xD7a=\xD2_a*\xC8V[a=0V[\x90a=\xE0a=WV[\x96\x95\x94\x93\x92\x91\x90V[a>\x12a>\x17\x91a=\xF8a'\x97V[Pa>\x0Ca>\x06`\x0Ba6NV[\x91aQ\x06V[\x90aQ\xFCV[a6QV[\x90V[a>A\x91_a>6a><\x93a>.a%\xDDV[P`\x05a/\x86V[\x01a\x14\xE5V[a0<V[\x90V[_\x90V[a>Pa>DV[Pa>YaU_V[\x90V[a>da&!V[Pa>o`\x04a&\xF3V[\x90V[a>\xCA\x90a>~a'\x97V[Pa>\x96`\x03a>\x90`\r\x84\x90a\x10\xEBV[\x01a\x11\x1AV[\x90a>\xC4`\x04a>\xBEa>\xB6`\x02a>\xB0`\r\x87\x90a\x10\xEBV[\x01a\x11\x1AV[\x93`\ra\x10\xEBV[\x01a\x11\x1AV[\x91aV\"V[\x90V[a>\xF4a>\xEFa>\xEAa>\xF9\x93a>\xE2a'\x97V[P`\na68V[a6NV[aX\x01V[a6QV[\x90V[\x90a?\x0E\x91a?\taM\xE8V[a?\x18V[a?\x16aNMV[V[\x90\x81a?4a?.a?)_a+\0V[a\x07eV[\x91a\x07eV[\x14a@3W\x80a?La?F_a*\xC8V[\x91a\x07\x94V[\x14a@\x17Wa?na?ha?c`\x0E3\x90a\x14\xE5V[a0<V[\x15a\x05qV[a?\xFBWa?{3aS\x90V[a?\x92`\x03a?\x8C`\r3\x90a\x10\xEBV[\x01a\x11\x1AV[a?\xA4a?\x9E\x83a\x07\x94V[\x91a\x07\x94V[\x10a?\xDFWa?\xDD\x91a?\xD8\x82a?\xD2`\x03a?\xC2`\r3\x90a\x10\xEBV[\x01\x91a?\xCD\x83a\x11\x1AV[a,\xF0V[\x90a+gV[aXvV[V[_c\x1C\x95\x9E\xD9`\xE2\x1B\x81R\x80a?\xF7`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_cD\x17v\t`\xE1\x1B\x81R\x80a@\x13`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a@/`\x04\x82\x01a\t\x13V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a@K`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x90a@Y\x91a>\xFCV[V[\x90a@v\x92\x91a@qa@la$\xE0V[aL\x15V[a@xV[V[\x80a@\x93a@\x8Da@\x88_a+\0V[a\x07eV[\x91a\x07eV[\x14aB\xB9Wa@\xB5a@\xAFa@\xAA`\x0E\x84\x90a\x14\xE5V[a0<V[\x15a\x05qV[\x80aB~W[aB\"W[\x81a@\xD3a@\xCD_a*\xC8V[\x91a\x07\x94V[\x14\x80aB\x08W[\x80aA\xEEW[aA\x93W[a@\xEE\x81aS\x90V[aA\x05\x82_a@\xFF`\r\x85\x90a\x10\xEBV[\x01a+gV[aA\x1D\x83`\x02aA\x17`\r\x85\x90a\x10\xEBV[\x01a+gV[aA5\x82`\x01aA/`\r\x85\x90a\x10\xEBV[\x01a+gV[aAM\x83`\x03aAG`\r\x85\x90a\x10\xEBV[\x01a+gV[\x90\x91aAy\x7F\xAA\x80}\n\xBF0\xD9\x19h\xC7G\x8Cf\xB6\xD8%!\xA1\x06\xAF\x13\xED\xA06\xE2\x03m\xA9\xAF\x16\x89X\x92a\x10\xDFV[\x92aA\x8EaA\x85a\x05\x12V[\x92\x83\x92\x83a\n\x98V[\x03\x90\xA2V[aA\xA8_aA\xA3`\x0E\x84\x90a\x14\xE5V[a+1V[\x80aA\xD3\x7F\x02\xC2\xF0\xBA\x15\xB0?\x88\xB1\x8FH2`\x9A\x18\xCF5\xFCk?EF\xA9\x99 v\xD7E=\x134\xA8\x91a\x10\xDFV[\x90aA\xDCa\x05\x12V[\x80aA\xE6\x81a\t\x13V[\x03\x90\xA2a@\xE5V[PaB\x03aA\xFE`\x0E\x83\x90a\x14\xE5V[a0<V[a@\xE0V[P\x82aB\x1CaB\x16_a*\xC8V[\x91a\x07\x94V[\x14a@\xDAV[aB8`\x01aB3`\x0E\x84\x90a\x14\xE5V[a+1V[\x80aBc\x7Fl\xF2\x849\xA2\xDA\xAB\x1B&P\x97\"r\x12\xA5\xB7\x1E\nv\xF9\xED\x85\xE3\xF8\x15\xB5\xA6\xC3\xE2\x18\xEB\x7F\x91a\x10\xDFV[\x90aBla\x05\x12V[\x80aBv\x81a\t\x13V[\x03\x90\xA2a@\xC0V[P\x81aB\x92aB\x8C_a*\xC8V[\x91a\x07\x94V[\x11\x80\x15aB\x9FW[a@\xBBV[P\x82aB\xB3aB\xAD_a*\xC8V[\x91a\x07\x94V[\x11aB\x9AV[_c\xD9.#=`\xE0\x1B\x81R\x80aB\xD1`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x90aB\xE0\x92\x91a@[V[V[aB\xEAa%\xDDV[PaB\xF5`Ba\x11\x1AV[aC\x0EaC\x08aC\x03a\x13\xBAV[a\x07\x94V[\x91a\x07\x94V[\x10\x15\x90V[aC,\x90aC'aC\"a$\xE0V[aL\x15V[aC\x84V[V[\x90aC?`\x01\x80`\xA0\x1B\x03\x91a\x1C\0V[\x91\x81\x19\x16\x91\x16\x17\x90V[aCR\x90a\x06\x8AV[\x90V[aC^\x90aCIV[\x90V[\x90V[\x90aCyaCtaC\x80\x92aCUV[aCaV[\x82TaC.V[\x90UV[aC\x8D\x81a\x06\xB2V[aC\xA7aC\xA1aC\x9C_a+\0V[a\x07eV[\x91a\x07eV[\x14aD\x1DWaC\xD2aC\xCCaC\xBC`Da'2V[aC\xC7\x84`DaCdV[a\x06\xB2V[\x91a\x06\xB2V[aD\x05aC\xFF\x7F\x07\x01[j\x9F\x05\x911H\xFD_\xAD\xDF*\xCC\x97\x08\xF3\x05\x93\x7F0r\xCA+KF\xFA\xA5\xD0\x89\x8B\x93a\x10\xDFV[\x91a\x10\xDFV[\x91aD\x0Ea\x05\x12V[\x80aD\x18\x81a\t\x13V[\x03\x90\xA3V[_c\xD9.#=`\xE0\x1B\x81R\x80aD5`\x04\x82\x01a\t\x13V[\x03\x90\xFD[aDB\x90aC\x13V[V[\x90V[aD[aDVaD`\x92aDDV[a\x06\x87V[a\x07\x94V[\x90V[aDka'\x97V[PaDv`Aa\x11\x1AV[aD\x88aD\x82_a*\xC8V[\x91a\x07\x94V[\x14aD\xD1WaD\xCEaD\x9A`Aa\x11\x1AV[aD\xC8aD\xBAaD\xAA`Ba\x11\x1AV[aD\xB4`\x01aDGV[\x90a0XV[aD\xC2a\x1E\0V[\x90a-4V[\x90a0XV[\x90V[aD\xDA_a*\xC8V[\x90V[aD\xFA\x91aD\xE9a%\xDDV[PaD\xF2aK\xF8V[\x91\x90\x91aL\xF5V[`\x01\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11aE\x14W` \x02\x90V[a\x0CZV[aE%aE*\x91aD\xFFV[a8[V[\x90V[\x90aEKaE:\x83aE\x19V[\x92aEE\x84\x91aD\xFFV[\x90a=+V[V[aEW`0aE-V[\x90V[\x90P\x90V[aEi\x90Ta\x11\x06V[\x90V[`\x01\x01\x90V[aE\x8EaE\x88aE\x81\x83a\x0E\xEBV[\x80\x94aEZV[\x91a\x0E\xF1V[_\x91[\x83\x83\x10aE\x9EWPPPPV[aE\xBBaE\xB5`\x01\x92aE\xB0\x85aE_V[a\x17{V[\x92aElV[\x92\x01\x91\x90aE\x91V[\x90aE\xD2\x81a\x06\0\x93aErV[\x01\x90V[\x90aE\xF6aE\xEF\x92aE\xE6a\x05\x12V[\x93\x84\x80\x92aE\xC4V[\x03\x83a\x0CnV[V[aF\x01\x90aE\xD6V[\x90V[aF\x0CaEMV[PaF\x17`\x10aE\xF8V[\x90V[\x90aF-\x91aF'a'\x97V[Pa6mV[\x90V[aF8a'\x97V[PaFAa'\x97V[PaFJa'\x97V[PaFSa%\xDDV[PaF^`Aa\x11\x1AV[aFpaFj_a*\xC8V[\x91a\x07\x94V[\x14aG\xE1WaF\x9AaF\x8CBaF\x86`Aa\x11\x1AV[\x90a,\xF0V[aF\x94a\x1E\0V[\x90a-}V[\x90aF\xDCaF\xA8`Aa\x11\x1AV[aF\xD6aF\xC8aF\xB8`Ba\x11\x1AV[aF\xC2`\x01aDGV[\x90a0XV[aF\xD0a\x1E\0V[\x90a-4V[\x90a0XV[aF\xE6`Ba\x11\x1AV[aF\xFFaF\xF9aF\xF4a\x13\xBAV[a\x07\x94V[\x91a\x07\x94V[\x10_\x14aG\xD3WaG$aG\x1E`\x10aG\x18`Ba\x11\x1AV[\x90a\x0E\xF4V[\x90a\x0F7V[[\x92aG0`@a0<V[\x90\x81aG\xAFW[P\x80aG\x85W[\x80aGYW[\x91aGO`Ba\x11\x1AV[\x91\x93\x92\x91\x93\x92\x91\x90V[PBaG~aGxaGs\x84aGma\x0B\x10V[\x90a,\xF0V[a\x07\x94V[\x91a\x07\x94V[\x10\x15aGDV[PaG\x90`Ba\x11\x1AV[aG\xA9aG\xA3aG\x9Ea\x13\xBAV[a\x07\x94V[\x91a\x07\x94V[\x10aG>V[\x90PaG\xCCaG\xC6aG\xC1`Ba\x11\x1AV[a\x07\x94V[\x91a\x07\x94V[\x11_aG7V[aG\xDC_a*\xC8V[aG%V[_\x90_\x91_\x91aH\x03aG\xFDaG\xF7_\x94a*\xC8V[\x95a*\xC8V[\x93a*\xC8V[\x91\x90V[aH\x19\x90aH\x13a'\x97V[Pa>\xCDV[\x90V[aH$a'\x97V[PaH-a*\x98V[\x90V[`\x02aHIaHO\x92aHAa'\x97V[P`\ra\x10\xEBV[\x01a\x11\x1AV[\x90V[\x7F\xE4\x83)\x05{\xFD\x03\xD5^I\xB5G\x13.9\xCF\xFD\x9C\x18 \xAD{\x9DLS\x07i\x14%\xD1Z\xDF\x90V[aH\xABaH\xB2\x94aH\xA1``\x94\x98\x97\x95aH\x97`\x80\x86\x01\x9A_\x87\x01\x90a\rqV[` \x85\x01\x90a\x12\xA7V[`@\x83\x01\x90a\x08;V[\x01\x90a\x08;V[V[` \x01\x90V[\x93\x95\x94\x90\x92\x91\x95BaH\xD4aH\xCE\x89a\x07\x94V[\x91a\x07\x94V[\x11aIMW\x91aI?\x91aIF\x93aI6aIK\x98\x99aI\x1EaH\xF5aHRV[aI\x0F\x8B\x93\x8BaI\x03a\x05\x12V[\x95\x86\x94` \x86\x01aHvV[` \x82\x01\x81\x03\x82R\x03\x82a\x0CnV[aI0aI*\x82a\x06\xCBV[\x91aH\xB4V[ aX\xD5V[\x92\x90\x91\x92aX\xF2V[\x91\x82aY<V[aU\x97V[V[aIh\x87_\x91\x82\x91c#A\xD7\x87`\xE1\x1B\x83R`\x04\x83\x01a\x08HV[\x03\x90\xFD[\x7Fnq\xED\xAE\x12\xB1\xB9\x7FM\x1F`7\x0F\xEF\x10\x10_\xA2\xFA\xAE\x01&\x11J\x16\x9Cd\x84]a&\xC9\x90V[\x91\x94aI\xD8aI\xE2\x92\x98\x97\x95aI\xCE`\xA0\x96aI\xC4aI\xE9\x9AaI\xBA`\xC0\x8A\x01\x9E_\x8B\x01\x90a\rqV[` \x89\x01\x90a\x12\xA7V[`@\x87\x01\x90a\x12\xA7V[``\x85\x01\x90a\x08;V[`\x80\x83\x01\x90a\x08;V[\x01\x90a\x08;V[V[\x91` aJ\x0C\x92\x94\x93aJ\x05`@\x82\x01\x96_\x83\x01\x90a\x12\xA7V[\x01\x90a\x12\xA7V[V[\x96\x95\x91\x93\x92\x94\x90\x94BaJ)aJ#\x83a\x07\x94V[\x91a\x07\x94V[\x11aJ\xE3W\x90aJ\x92aJ\x9B\x94\x93\x92aJzaJCaIlV[aJk\x8C\x80\x94\x8C\x91aJU\x8D\x91aY\x7FV[\x91\x92aJ_a\x05\x12V[\x97\x88\x96` \x88\x01aI\x90V[` \x82\x01\x81\x03\x82R\x03\x82a\x0CnV[aJ\x8CaJ\x86\x82a\x06\xCBV[\x91aH\xB4V[ aX\xD5V[\x92\x90\x91\x92aX\xF2V[\x80aJ\xAEaJ\xA8\x87a\x07eV[\x91a\x07eV[\x03aJ\xC3WPaJ\xC1\x92\x93\x91\x90\x91aL\x05V[V[\x84\x90aJ\xDF_\x92\x83\x92c%\xC0\x07#`\xE1\x1B\x84R`\x04\x84\x01aI\xEBV[\x03\x90\xFD[aJ\xFE\x90_\x91\x82\x91c1<\x89\x81`\xE1\x1B\x83R`\x04\x83\x01a\x08HV[\x03\x90\xFD[\x90aK\x1D\x91aK\x18aK\x13\x82a/\xC0V[aL\x15V[aK\x1FV[V[\x90aK)\x91aP%V[PV[\x90aK6\x91aK\x02V[V[\x90aKB\x90a\x10\xDFV[_R` R`@_ \x90V[aKs\x91aKiaKn\x92aKaa'\x97V[P`\x01aK8V[a:\xDCV[a\x11\x1AV[\x90V[aK\x80`@a8[V[\x90V[_\x90V[_\x90V[aK\x93aKvV[\x90` \x80\x83aK\xA0aK\x83V[\x81R\x01aK\xABaK\x87V[\x81RPPV[aK\xB9aK\x8BV[\x90V[\x90aK\xCF\x91aK\xC9aK\xB1V[PaY\xB2V[\x90V[aK\xDAa%\xDDV[PaK\xF4aK\xEEc\x01\xFF\xC9\xA7`\xE0\x1Ba\x05$V[\x91a\x05$V[\x14\x90V[aL\0a9KV[P3\x90V[\x91aL\x13\x92\x91`\x01\x92aY\xDAV[V[aL'\x90aL!aK\xF8V[\x90a[\x0CV[V[`@\x90aLRaLY\x94\x96\x95\x93\x96aLH``\x84\x01\x98_\x85\x01\x90a\x12\xA7V[` \x83\x01\x90a\x08;V[\x01\x90a\x08;V[V[\x90aLf\x91\x03a\x07\x94V[\x90V[\x92\x91\x92aLw\x81\x83\x90aKNV[\x90\x81aL\x8CaL\x86_\x19a\x07\x94V[\x91a\x07\x94V[\x10aL\x99W[PPP\x90PV[\x81aL\xACaL\xA6\x87a\x07\x94V[\x91a\x07\x94V[\x10aL\xD2WaL\xC9\x93\x94aL\xC1\x91\x93\x92aL[V[\x90_\x92aY\xDAV[\x80_\x80\x80aL\x92V[PaL\xF1\x84\x92\x91\x92_\x93\x84\x93c}\xC7\xA0\xD9`\xE1\x1B\x85R`\x04\x85\x01aL)V[\x03\x90\xFD[\x91\x82aM\x11aM\x0BaM\x06_a+\0V[a\x07eV[\x91a\x07eV[\x14aMkW\x81aM1aM+aM&_a+\0V[a\x07eV[\x91a\x07eV[\x14aMDWaMB\x92\x91\x90\x91a[GV[V[aMgaMP_a+\0V[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x12\xB4V[\x03\x90\xFD[aM\x8EaMw_a+\0V[_\x91\x82\x91cKc~\x8F`\xE1\x1B\x83R`\x04\x83\x01a\x12\xB4V[\x03\x90\xFD[aM\x9Aa9\xECV[aM\xA0WV[_c\xD9<\x06e`\xE0\x1B\x81R\x80aM\xB8`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x90V[aM\xD3aM\xCEaM\xD8\x92aM\xBCV[a\x06\x87V[a\x07\x94V[\x90V[aM\xE5`\x02aM\xBFV[\x90V[aM\xF2`\x0Ca\x11\x1AV[aN\x0BaN\x05aN\0aM\xDBV[a\x07\x94V[\x91a\x07\x94V[\x14aN$WaN\"aN\x1BaM\xDBV[`\x0Ca+gV[V[_c>\xE5\xAE\xB5`\xE0\x1B\x81R\x80aN<`\x04\x82\x01a\t\x13V[\x03\x90\xFD[aNJ`\x01aDGV[\x90V[aN_aNXaN@V[`\x0Ca+gV[V[\x80aN|aNvaNq_a+\0V[a\x07eV[\x91a\x07eV[\x14aN\x98WaN\x96\x91aN\x8E_a+\0V[\x91\x90\x91a[GV[V[aN\xBBaN\xA4_a+\0V[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x12\xB4V[\x03\x90\xFD[aN\xC7a%\xDDV[PaN\xDCaN\xD6\x82\x84\x90a>\x1AV[\x15a\x05qV[_\x14aOeWaO\x04`\x01aN\xFF_aN\xF7`\x05\x86\x90a/\x86V[\x01\x85\x90a\x14\xE5V[a+1V[\x90aO\raK\xF8V[\x90aOJaODaO>\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a/zV[\x92a\x10\xDFV[\x92a\x10\xDFV[\x92aOSa\x05\x12V[\x80aO]\x81a\t\x13V[\x03\x90\xA4`\x01\x90V[PP_\x90V[aOsa/vV[PaO}0a<\xEBV[aO\xAFaO\xA9\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x07eV[\x91a\x07eV[\x14\x80aO\xEBW[_\x14aO\xE0W\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[aO\xE8a[\xC7V[\x90V[PFaP\x1FaP\x19\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x07\x94V[\x91a\x07\x94V[\x14aO\xB6V[aP-a%\xDDV[PaP9\x81\x83\x90a>\x1AV[_\x14aP\xC1WaP`_aP[_aPS`\x05\x86\x90a/\x86V[\x01\x85\x90a\x14\xE5V[a+1V[\x90aPiaK\xF8V[\x90aP\xA6aP\xA0aP\x9A\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x95a/zV[\x92a\x10\xDFV[\x92a\x10\xDFV[\x92aP\xAFa\x05\x12V[\x80aP\xB9\x81a\t\x13V[\x03\x90\xA4`\x01\x90V[PP_\x90V[aP\xDBaP\xD6aP\xE0\x92a\x19uV[a\x06\x87V[a\x07\x94V[\x90V[\x91` aQ\x04\x92\x94\x93aP\xFD`@\x82\x01\x96_\x83\x01\x90a\x08;V[\x01\x90a\x19\x80V[V[aQ\x0Ea>DV[PaQ\x17a>HV[\x81aQ*aQ$\x83aP\xC7V[\x91a\x07\x94V[\x10\x15aQ=WPaQ:\x90a\\\xCDV[\x90V[\x90aQX_\x92\x83\x92cvi\xFC\x0F`\xE1\x1B\x84R`\x04\x84\x01aP\xE3V[\x03\x90\xFD[T\x90V[\x90V[aQwaQraQ|\x92aQ`V[a\x06\x87V[a\x07\x94V[\x90V[\x90V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[aQ\x99aQ\x9E\x91a\x11\x01V[aQ\x82V[\x90V[aQ\xAB\x90TaQ\x8DV[\x90V[`0\x1C\x90V[`\x01\x80`\xD0\x1B\x03\x16\x90V[aQ\xCBaQ\xD0\x91aQ\xAEV[aQ\xB4V[\x90V[aQ\xDD\x90TaQ\xBFV[\x90V[aQ\xF4aQ\xEFaQ\xF9\x92a\x1B\xFDV[a\x06\x87V[a$\x15V[\x90V[\x90aRP\x90aR\ta%HV[PaR\x15_\x84\x01aQ\\V[aR\x1E_a*\xC8V[\x90\x80\x80aR4aR.`\x05aQcV[\x91a\x07\x94V[\x11aR\xB1W[P\x90aRK_\x86\x01\x93\x91\x92\x93aQ\x7FV[ac\x05V[\x80aRcaR]_a*\xC8V[\x91a\x07\x94V[\x14_\x14aRyWPPaRu_aQ\xE0V[[\x90V[aR\xA6_\x91aR\xA1aR\x9B\x84aR\xAC\x96\x01\x92aR\x95`\x01aDGV[\x90a,\xF0V[\x91aQ\x7FV[ab\xFBV[\x01aQ\xD3V[aRvV[\x80aR\xBFaR\xC5\x92\x91a_\x90V[\x90a,\xF0V[\x90\x83aR\xF7aR\xF1aR\xEC_aR\xE6\x81\x8C\x01aR\xE1\x89\x91aQ\x7FV[ab\xFBV[\x01aQ\xA1V[a\x19uV[\x91a\x19uV[\x10_\x14aS\x08WP\x90[\x90_aR:V[\x91PaS\x1E\x90aS\x18`\x01aDGV[\x90a0XV[aS\x01V[aS+ac\x94V[aS3aS5V[V[aS@_`\x0Fa+1V[aSHaK\xF8V[aS~\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA\x91aSua\x05\x12V[\x91\x82\x91\x82a\x12\xB4V[\x03\x90\xA1V[aS\x8BaS#V[V[\x90V[aS\x9EaS\xA3\x91`\ra\x10\xEBV[aS\x8DV[aS\xAF`\x04\x82\x01a\x11\x1AV[aS\xC1aS\xBB_a*\xC8V[\x91a\x07\x94V[\x14aUOWaT=\x90aS\xE0BaS\xDA`\x04\x84\x01a\x11\x1AV[\x90a,\xF0V[\x80aS\xFAaS\xF4aS\xEFa\x1A+V[a\x07\x94V[\x91a\x07\x94V[\x10\x15_\x14aT?WPaT\x1AaT\x11_\x83\x01a\x11\x1AV[`\x01\x83\x01a+gV[aT2aT)`\x02\x83\x01a\x11\x1AV[`\x03\x83\x01a+gV[[`\x04B\x91\x01a+gV[V[\x80aTRaTL_a*\xC8V[\x91a\x07\x94V[\x11aT^W[PaT3V[aU@aU.aUI\x92aU\x1DaU\x14aU\x03aT\xF1aT\xB3aT\x82_\x8B\x01a\x11\x1AV[aT\x94\x87aT\x8Ea\x1E\xA4V[\x90a-4V[aT\xADaT\x9Fa\x1A+V[aT\xA7a\x1E\xA4V[\x90a-4V[\x91ad\x1CV[\x94aT\xD2aT\xC3`\x02\x8C\x01a\x11\x1AV[\x91aT\xCCa\x1E\xA4V[\x90a-4V[aT\xEBaT\xDDa\x1A+V[aT\xE5a\x1E\xA4V[\x90a-4V[\x91ad\x1CV[\x93aT\xFE`\x01\x8A\x01a\x11\x1AV[a0XV[aU\x0E_\x89\x01a\x11\x1AV[\x90af\x1BV[`\x01\x87\x01a+gV[aU)`\x03\x86\x01a\x11\x1AV[a0XV[aU:`\x02\x85\x01a\x11\x1AV[\x90af\x1BV[`\x03\x83\x01a+gV[_aTXV[aU]\x90`\x04B\x91\x01a+gV[V[aUga>DV[PaUqCa\\\xCDV[\x90V[\x90V[\x90aU\x8CaU\x87aU\x93\x92a\x10\xDFV[aUtV[\x82TaC.V[\x90UV[\x90aV \x91aV\x1AaU\xA8\x82a9\x91V[aU\xBD\x84aU\xB8`\t\x86\x90a9OV[aUwV[\x82\x81\x85\x90aU\xFDaU\xF7aU\xF1\x7F14\xE8\xA2\xE6\xD9~\x92\x9A~T\x01\x1E\xA5H]}\x19m\xD5\xF0\xBAMN\xF9X\x03\xE8\xE3\xFC%\x7F\x95a\x10\xDFV[\x92a\x10\xDFV[\x92a\x10\xDFV[\x92aV\x06a\x05\x12V[\x80aV\x10\x81a\t\x13V[\x03\x90\xA4\x92\x91afGV[\x91af_V[V[\x90\x91aV,a'\x97V[P\x80aV@aV:_a*\xC8V[\x91a\x07\x94V[\x14aV\xC0WaVO\x90Ba,\xF0V[\x80aViaVcaV^a\x1A+V[a\x07\x94V[\x91a\x07\x94V[\x10\x15aV\xBBW\x82\x91aV\xADaV\xB3\x92aV\x8EaV\xB8\x96\x91aV\x88a\x1E\xA4V[\x90a-4V[aV\xA7aV\x99a\x1A+V[aV\xA1a\x1E\xA4V[\x90a-4V[\x91ad\x1CV[\x90a0XV[af\x1BV[\x90V[PP\x90V[PPPaV\xCC_a*\xC8V[\x90V[aV\xF6aV\xF1aV\xECaV\xFB\x93aV\xE4a:\xC3V[P`\na68V[a6NV[ah\rV[ah\x8CV[\x90V[aW\x10\x90aW\na'\x97V[Pah\xDDV[\x90V[aW\x1BaM\x92V[aW#aW%V[V[aW1`\x01`\x0Fa+1V[aW9aK\xF8V[aWo\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2X\x91aWfa\x05\x12V[\x91\x82\x91\x82a\x12\xB4V[\x03\x90\xA1V[aW|aW\x13V[V[\x90V[aW\x89a&!V[PaW\xBE\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0aW\xB8`\x06aW~V[\x90ai\xF8V[\x90V[aW\xC9a&!V[PaW\xFE\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0aW\xF8`\x07aW~V[\x90ai\xF8V[\x90V[aX\ta%HV[PaX\x15_\x82\x01aQ\\V[\x80aX(aX\"_a*\xC8V[\x91a\x07\x94V[\x14_\x14aX>WPPaX:_aQ\xE0V[[\x90V[aXk_\x91aXfaX`\x84aXq\x96\x01\x92aXZ`\x01aDGV[\x90a,\xF0V[\x91aQ\x7FV[ab\xFBV[\x01aQ\xD3V[aX;V[\x90\x81aX\x92aX\x8CaX\x87_a+\0V[a\x07eV[\x91a\x07eV[\x14aX\xAEWaX\xAC\x91\x90aX\xA5_a+\0V[\x90\x91a[GV[V[aX\xD1aX\xBA_a+\0V[_\x91\x82\x91cKc~\x8F`\xE1\x1B\x83R`\x04\x83\x01a\x12\xB4V[\x03\x90\xFD[aX\xEF\x90aX\xE1a/vV[PaX\xEAaOkV[ajFV[\x90V[\x92aY\r\x92aY\x16\x94aY\x03a9KV[P\x92\x90\x91\x92aj\xFCV[\x90\x92\x91\x92al'V[\x90V[\x91` aY:\x92\x94\x93aY3`@\x82\x01\x96_\x83\x01\x90a\x12\xA7V[\x01\x90a\x08;V[V[aYE\x81aY\x7FV[\x91aYXaYR\x84a\x07\x94V[\x91a\x07\x94V[\x03aYaWPPV[aY{_\x92\x83\x92c\x01\xD4\xB6#`\xE6\x1B\x84R`\x04\x84\x01aY\x19V[\x03\x90\xFD[aY\x93\x90aY\x8Ba'\x97V[P`\x08a:\xDCV[aY\xAFaY\x9F\x82a\x11\x1AV[\x91aY\xA9\x83a0IV[\x90a+gV[\x90V[\x90aY\xD2aY\xCDaY\xD7\x93aY\xC5aK\xB1V[P`\na68V[a6NV[am\x89V[\x90V[\x90\x92\x81aY\xF7aY\xF1aY\xEC_a+\0V[a\x07eV[\x91a\x07eV[\x14aZ\xC2W\x83aZ\x17aZ\x11aZ\x0C_a+\0V[a\x07eV[\x91a\x07eV[\x14aZ\x9BWaZ;\x83aZ6aZ/`\x01\x86\x90aK8V[\x87\x90a:\xDCV[a+gV[aZEW[PPPV[\x91\x90\x91aZ\x90aZ~aZx\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%\x93a\x10\xDFV[\x93a\x10\xDFV[\x93aZ\x87a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xA3_\x80\x80aZ@V[aZ\xBEaZ\xA7_a+\0V[_\x91\x82\x91cJ\x14\x06\xB1`\xE1\x1B\x83R`\x04\x83\x01a\x12\xB4V[\x03\x90\xFD[aZ\xE5aZ\xCE_a+\0V[_\x91\x82\x91c\xE6\x02\xDF\x05`\xE0\x1B\x83R`\x04\x83\x01a\x12\xB4V[\x03\x90\xFD[\x91` a[\n\x92\x94\x93a[\x03`@\x82\x01\x96_\x83\x01\x90a\x12\xA7V[\x01\x90a\rqV[V[\x90a[!a[\x1B\x83\x83\x90a>\x1AV[\x15a\x05qV[a[)WPPV[a[C_\x92\x83\x92c\xE2Q}?`\xE0\x1B\x84R`\x04\x84\x01aZ\xE9V[\x03\x90\xFD[\x91a[T\x92\x91\x90\x91am\xAAV[V[\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x90V[\x90\x95\x94\x92a[\xC5\x94a[\xB4a[\xBE\x92a[\xAA`\x80\x96a[\xA0`\xA0\x88\x01\x9C_\x89\x01\x90a\rqV[` \x87\x01\x90a\rqV[`@\x85\x01\x90a\rqV[``\x83\x01\x90a\x08;V[\x01\x90a\x12\xA7V[V[a[\xCFa/vV[Pa[\xD8a[VV[a\\O\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91a\\@\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0Fa\\+0a<\xEBV[\x91a\\4a\x05\x12V[\x96\x87\x95` \x87\x01a[zV[` \x82\x01\x81\x03\x82R\x03\x82a\x0CnV[a\\aa\\[\x82a\x06\xCBV[\x91aH\xB4V[ \x90V[a\\ya\\ta\\~\x92a\x13\x9BV[a\x06\x87V[a\x0E\\V[\x90V[a\\\x8A\x90a\\eV[\x90RV[\x91` a\\\xAF\x92\x94\x93a\\\xA8`@\x82\x01\x96_\x83\x01\x90a\\\x81V[\x01\x90a\x08;V[V[a\\\xC5a\\\xC0a\\\xCA\x92a\x07\x94V[a\x06\x87V[a\x19uV[\x90V[a\\\xD5a>DV[P\x80a\\\xEFa\\\xE9e\xFF\xFF\xFF\xFF\xFF\xFFaP\xC7V[\x91a\x07\x94V[\x11a]\0Wa\\\xFD\x90a\\\xB1V[\x90V[`0a]\x1C_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01a\\\x8EV[\x03\x90\xFD[\x90V[a]7a]2a]<\x92a] V[a\x06\x87V[a\x07\x94V[\x90V[\x90V[a]Va]Qa][\x92a]?V[a\x06\x87V[a\x0E\\V[\x90V[a]}\x90a]wa]qa]\x82\x94a\x0E\\V[\x91a\x07\x94V[\x90a\t\xB4V[a\x07\x94V[\x90V[\x90V[a]\x9Ca]\x97a]\xA1\x92a]\x85V[a\x06\x87V[a\x0E\\V[\x90V[a]\xC3\x90a]\xBDa]\xB7a]\xC8\x94a\x0E\\V[\x91a\x07\x94V[\x90a'\xE6V[a\x07\x94V[\x90V[\x90V[a]\xE2a]\xDDa]\xE7\x92a]\xCBV[a\x06\x87V[a\x07\x94V[\x90V[\x90V[a^\x01a]\xFCa^\x06\x92a]\xEAV[a\x06\x87V[a\x0E\\V[\x90V[\x90V[a^ a^\x1Ba^%\x92a^\tV[a\x06\x87V[a\x07\x94V[\x90V[\x90V[a^?a^:a^D\x92a^(V[a\x06\x87V[a\x0E\\V[\x90V[\x90V[a^^a^Ya^c\x92a^GV[a\x06\x87V[a\x07\x94V[\x90V[\x90V[a^}a^xa^\x82\x92a^fV[a\x06\x87V[a\x0E\\V[\x90V[\x90V[a^\x9Ca^\x97a^\xA1\x92a^\x85V[a\x06\x87V[a\x07\x94V[\x90V[\x90V[a^\xBBa^\xB6a^\xC0\x92a^\xA4V[a\x06\x87V[a\x0E\\V[\x90V[a^\xD7a^\xD2a^\xDC\x92a^(V[a\x06\x87V[a\x07\x94V[\x90V[a^\xF3a^\xEEa^\xF8\x92aM\xBCV[a\x06\x87V[a\x0E\\V[\x90V[a_\x0Fa_\na_\x14\x92a^\xA4V[a\x06\x87V[a\x07\x94V[\x90V[a_+a_&a_0\x92aDDV[a\x06\x87V[a\x0E\\V[\x90V[\x90V[a_Ja_Ea_O\x92a_3V[a\x06\x87V[a\x07\x94V[\x90V[\x90a_]\x91\x02a\x07\x94V[\x90V[a_la_r\x91a\x07\x94V[\x91a\x07\x94V[\x90\x81\x15a_}W\x04\x90V[a-iV[\x90a_\x8D\x91\x01a\x07\x94V[\x90V[a_\x98a'\x97V[P\x80a_\xADa_\xA7`\x01aDGV[\x91a\x07\x94V[\x11\x15ab\xF8W\x80aa\xC2aa\x9Faa\x8Faa\x7Faaoaa_aaOaa?aa/aa\x1Faa\x0F\x8Baa\taa\x02aa\xC8\x9Fa`\xE2a`\xD2a`\xF2\x92a_\xF4`\x01aDGV[\x90\x80a`\x0Ca`\x06`\x01`\x80\x1Ba]#V[\x91a\x07\x94V[\x10\x15ab\xCAW[\x80a`/a`)h\x01\0\0\0\0\0\0\0\0a]\xCEV[\x91a\x07\x94V[\x10\x15ab\x9CW[\x80a`Na`Hd\x01\0\0\0\0a^\x0CV[\x91a\x07\x94V[\x10\x15abnW[\x80a`ka`eb\x01\0\0a^JV[\x91a\x07\x94V[\x10\x15ab@W[\x80a`\x87a`\x81a\x01\0a^\x88V[\x91a\x07\x94V[\x10\x15ab\x12W[\x80a`\xA2a`\x9C`\x10a^\xC3V[\x91a\x07\x94V[\x10\x15aa\xE4W[a`\xBCa`\xB6`\x04a^\xFBV[\x91a\x07\x94V[\x10\x15aa\xCBW[a`\xCD`\x03a_6V[a_RV[a`\xDC`\x01a_\x17V[\x90a]^V[a`\xEC\x81\x86a_`V[\x90a_\x82V[a`\xFC`\x01a_\x17V[\x90a]^V[\x80\x92a_`V[\x90a_\x82V[aa\x19`\x01a_\x17V[\x90a]^V[aa)\x81\x8Ca_`V[\x90a_\x82V[aa9`\x01a_\x17V[\x90a]^V[aaI\x81\x8Aa_`V[\x90a_\x82V[aaY`\x01a_\x17V[\x90a]^V[aai\x81\x88a_`V[\x90a_\x82V[aay`\x01a_\x17V[\x90a]^V[aa\x89\x81\x86a_`V[\x90a_\x82V[aa\x99`\x01a_\x17V[\x90a]^V[\x91aa\xBCaa\xB6aa\xB1\x85\x80\x94a_`V[a\x07\x94V[\x91a\x07\x94V[\x11an:V[\x90aL[V[\x90V[aa\xDF\x90aa\xD9`\x01a_\x17V[\x90a]\xA4V[a`\xC3V[aa\xFBab\x0C\x91aa\xF5`\x04a^\xA7V[\x90a]^V[\x91ab\x06`\x02a^\xDFV[\x90a]\xA4V[\x90a`\xA9V[ab)ab:\x91ab#`\x08a^iV[\x90a]^V[\x91ab4`\x04a^\xA7V[\x90a]\xA4V[\x90a`\x8EV[abWabh\x91abQ`\x10a^+V[\x90a]^V[\x91abb`\x08a^iV[\x90a]\xA4V[\x90a`rV[ab\x85ab\x96\x91ab\x7F` a]\xEDV[\x90a]^V[\x91ab\x90`\x10a^+V[\x90a]\xA4V[\x90a`UV[ab\xB3ab\xC4\x91ab\xAD`@a]\x88V[\x90a]^V[\x91ab\xBE` a]\xEDV[\x90a]\xA4V[\x90a`6V[ab\xE1ab\xF2\x91ab\xDB`\x80a]BV[\x90a]^V[\x91ab\xEC`@a]\x88V[\x90a]\xA4V[\x90a`\x13V[\x90V[_R` _ \x01\x90V[\x93\x91\x90\x92ac\x11a'\x97V[P[\x81ac&ac \x83a\x07\x94V[\x91a\x07\x94V[\x10\x15ac\x8CWac7\x82\x82\x90anHV[\x90acM_acG\x88\x85\x90ab\xFBV[\x01aQ\xA1V[ac_acY\x87a\x19uV[\x91a\x19uV[\x11_\x14acoWP\x91[\x91ac\x13V[\x92\x91Pac\x86\x90ac\x80`\x01aDGV[\x90a0XV[\x90aciV[\x92PP\x91P\x90V[ac\xA5ac\x9Fa9\xECV[\x15a\x05qV[ac\xABWV[_c\x8D\xFC +`\xE0\x1B\x81R\x80ac\xC3`\x04\x82\x01a\t\x13V[\x03\x90\xFD[ac\xDBac\xD6ac\xE0\x92a5\x02V[a\x06\x87V[a\x07\x94V[\x90V[ac\xED`\x12ac\xC7V[\x90V[\x90V[ad\x07ad\x02ad\x0C\x92ac\xF0V[a\x06\x87V[a\x07\x94V[\x90V[ad\x19`\x11ac\xF3V[\x90V[\x92\x91\x92ad'a'\x97V[Pad3\x81\x83\x90a_RV[\x91ad<a'\x97V[P_\x19\x81\x83\t\x83\x80\x82\x10\x91\x03\x03\x91\x82ad]adW_a*\xC8V[\x91a\x07\x94V[\x14af\nW\x85aduado\x85a\x07\x94V[\x91a\x07\x94V[\x11\x15ae\xD8Wae\xCF\x92\x86ae\xD5\x96\x97\x93ad\xC6\x93ad\x92a'\x97V[P\t\x90\x85\x82\x11\x90\x03\x94\x03\x93`\x01\x83ad\xB3_ad\xAE\x87\x91a*\xC8V[aL[V[\x16\x80\x80\x95\x04\x96\x04\x93\x80_\x03\x04\x01\x90a_RV[\x17\x91ae\xC9ae\xADae\x89aeeaeAae\x1Dad\xEE`\x03ad\xE9\x89\x91a_6V[a_RV[ad\xF8`\x02aM\xBFV[\x18ae\x17`\x02ae\x12ae\x0C\x8B\x85\x90a_RV[\x91aM\xBFV[aL[V[\x90a_RV[ae;`\x02ae6ae0\x8A\x85\x90a_RV[\x91aM\xBFV[aL[V[\x90a_RV[ae_`\x02aeZaeT\x89\x85\x90a_RV[\x91aM\xBFV[aL[V[\x90a_RV[ae\x83`\x02ae~aex\x88\x85\x90a_RV[\x91aM\xBFV[aL[V[\x90a_RV[ae\xA7`\x02ae\xA2ae\x9C\x87\x85\x90a_RV[\x91aM\xBFV[aL[V[\x90a_RV[\x91ae\xC4ae\xBE`\x02\x92\x85\x90a_RV[\x91aM\xBFV[aL[V[\x90a_RV[\x90a_RV[\x90V[af\x05\x86ae\xEEae\xE8_a*\xC8V[\x91a\x07\x94V[\x14ae\xF7ac\xE3V[ae\xFFad\x0FV[\x91anvV[an\x9AV[PPP\x91af\x18\x91\x92a_`V[\x90V[afD\x91af'a'\x97V[P\x81af;af5\x83a\x07\x94V[\x91a\x07\x94V[\x10\x91\x90\x91anvV[\x90V[afY\x90afSa'\x97V[Pa:\xF2V[\x90V[\x90V[\x91\x90\x91\x80afuafo\x85a\x07eV[\x91a\x07eV[\x14\x15\x80ag\xF3W[af\x87W[PPPV[\x80af\xA2af\x9Caf\x97_a+\0V[a\x07eV[\x91a\x07eV[\x03agcW[P\x81af\xC4af\xBEaf\xB9_a+\0V[a\x07eV[\x91a\x07eV[\x03af\xD0W[\x80af\x82V[ag\x17ag\nag\x11\x92af\xE6`\n\x86\x90a68V[\x90ag\x04af\xFEaf\xF8`\x01\x93ao\x15V[\x93a6NV[\x91af\\V[\x90aohV[\x92\x90a6QV[\x91a6QV[\x91\x90\x91agD\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\x10\xDFV[\x92agYagPa\x05\x12V[\x92\x83\x92\x83a\n\x98V[\x03\x90\xA2_\x80af\xCAV[ag\xA2ag\xA8ag\x9Bagx`\n\x85\x90a68V[`\x02ag\x95ag\x8Fag\x89\x89ao\x15V[\x93a6NV[\x91af\\V[\x90aohV[\x92\x90a6QV[\x91a6QV[\x91\x90\x91ag\xD5\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\x10\xDFV[\x92ag\xEAag\xE1a\x05\x12V[\x92\x83\x92\x83a\n\x98V[\x03\x90\xA2_af\xA8V[P\x81ah\x07ah\x01_a*\xC8V[\x91a\x07\x94V[\x11af}V[_ah!\x91ah\x1Aa'\x97V[P\x01aQ\\V[\x90V[ah8ah3ah=\x92a\x15IV[a\x06\x87V[a\x07\x94V[\x90V[ahI\x90a]\xEDV[\x90RV[\x91` ahn\x92\x94\x93ahg`@\x82\x01\x96_\x83\x01\x90ah@V[\x01\x90a\x08;V[V[ah\x84ah\x7Fah\x89\x92a\x07\x94V[a\x06\x87V[a\x15IV[\x90V[ah\x94a:\xC3V[P\x80ah\xACah\xA6c\xFF\xFF\xFF\xFFah$V[\x91a\x07\x94V[\x11ah\xBDWah\xBA\x90ahpV[\x90V[` ah\xD9_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01ahMV[\x03\x90\xFD[ah\xF4ah\xF9\x91ah\xECa'\x97V[P`\x08a:\xDCV[a\x11\x1AV[\x90V[\x90V[ai\x13ai\x0Eai\x18\x92ah\xFCV[a\x1C\0V[a\r-V[\x90V[ai%`\xFFah\xFFV[\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90aiKaiD\x83a\x0B\x85V[\x80\x94a&&V[\x91`\x01\x81\x16\x90\x81_\x14ai\xA2WP`\x01\x14aifW[PPPV[ais\x91\x92\x93\x94Pai(V[\x91_\x92[\x81\x84\x10ai\x8AWPP\x01\x90_\x80\x80aiaV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90aiwV[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80aiaV[\x90ai\xC7\x91ai1V[\x90V[\x90ai\xEAai\xE3\x92ai\xDAa\x05\x12V[\x93\x84\x80\x92ai\xBDV[\x03\x83a\x0CnV[V[ai\xF5\x90ai\xCAV[\x90V[\x90aj\x01a&!V[Paj\x0B\x82a/zV[aj$aj\x1Eaj\x19ai\x1BV[a\r-V[\x91a\r-V[\x14\x15_\x14aj9WPaj6\x90ao\xF2V[\x90V[ajC\x91Pai\xECV[\x90V[`B\x91ajQa/vV[P`@Q\x91\x7F\x19\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83R`\x02\x83\x01R`\"\x82\x01R \x90V[_\x90V[aj\x97aj\x9C\x91a\x11\x01V[a(\x0FV[\x90V[\x90V[aj\xB6aj\xB1aj\xBB\x92aj\x9FV[a\x06\x87V[a\x07\x94V[\x90V[aj\xF3aj\xFA\x94aj\xE9``\x94\x98\x97\x95aj\xDF`\x80\x86\x01\x9A_\x87\x01\x90a\rqV[` \x85\x01\x90a\x0EbV[`@\x83\x01\x90a\rqV[\x01\x90a\rqV[V[\x93\x92\x93ak\x07a9KV[Pak\x10aj\x87V[Pak\x19a/vV[Pak#\x85aj\x8BV[akUakO\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0aj\xA2V[\x91a\x07\x94V[\x11ak\xE2W\x90akx` \x94\x95_\x94\x93\x92\x93akoa\x05\x12V[\x94\x85\x94\x85aj\xBEV[\x83\x80R\x03\x90`\x01Z\xFA\x15ak\xDDWak\x90_Qa\x1C\0V[\x80ak\xABak\xA5ak\xA0_a+\0V[a\x07eV[\x91a\x07eV[\x14ak\xC1W_\x91ak\xBB_a\x1C\x05V[\x91\x92\x91\x90V[Pak\xCB_a+\0V[`\x01\x91ak\xD7_a\x1C\x05V[\x91\x92\x91\x90V[a,\xE0V[PPPak\xEE_a+\0V[\x90`\x03\x92\x91\x92\x91\x90V[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x04\x11\x15al\x16WV[ak\xF8V[\x90al%\x82al\x0CV[V[\x80al:al4_al\x1BV[\x91al\x1BV[\x14_\x14alEWPPV[\x80alYalS`\x01al\x1BV[\x91al\x1BV[\x14_\x14al|W_c\xF6E\xEE\xDF`\xE0\x1B\x81R\x80alx`\x04\x82\x01a\t\x13V[\x03\x90\xFD[\x80al\x90al\x8A`\x02al\x1BV[\x91al\x1BV[\x14_\x14al\xBEWal\xBAal\xA3\x83aj\x8BV[_\x91\x82\x91c\xFC\xE6\x98\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x08HV[\x03\x90\xFD[al\xD1al\xCB`\x03al\x1BV[\x91al\x1BV[\x14al\xD9WPV[al\xF4\x90_\x91\x82\x91c5\xE2\xF3\x83`\xE2\x1B\x83R`\x04\x83\x01a\r~V[\x03\x90\xFD[_R` _ \x90V[am\n\x81aQ\\V[\x82\x10\x15am$Wam\x1C`\x01\x91al\xF8V[\x91\x02\x01\x90_\x90V[a\x0E\xD7V[\x90am3\x90a\x19uV[\x90RV[\x90amA\x90a$\x15V[\x90RV[\x90am{amr_amUaKvV[\x94amlamd\x83\x83\x01aQ\xA1V[\x83\x88\x01am)V[\x01aQ\xD3V[` \x84\x01am7V[V[am\x86\x90amEV[\x90V[am\xA7\x91_am\xA1\x92am\x9AaK\xB1V[P\x01am\x01V[Pam}V[\x90V[\x92\x91am\xB8\x84\x83\x83\x91ap\"V[\x83am\xD3am\xCDam\xC8_a+\0V[a\x07eV[\x91a\x07eV[\x14am\xE8W[am\xE6\x92\x93\x91\x90\x91aq\xACV[V[am\xF0a*\x98V[\x93am\xF9aq\x91V[\x94\x80an\ran\x07\x88a\x07\x94V[\x91a\x07\x94V[\x11an\x1AWP\x93Pam\xD9V[\x85\x90an6_\x92\x83\x92c\x0EX\xAE\x93`\xE1\x1B\x84R`\x04\x84\x01a\n\x98V[\x03\x90\xFD[anBa'\x97V[P\x15\x15\x90V[anmans\x92anWa'\x97V[P\x82\x81\x16\x92\x18ang`\x02aM\xBFV[\x90a-}V[\x90a0XV[\x90V[an\x90an\x96\x92\x93an\x86a'\x97V[P\x80\x94\x18\x91an:V[\x90a_RV[\x18\x90V[cNH{q_R` R`$`\x1C\xFD[\x90V[an\xC1an\xBCan\xC6\x92an\xAAV[a\x06\x87V[a\x0E\\V[\x90V[an\xD2\x90an\xADV[\x90RV[\x91` an\xF7\x92\x94\x93an\xF0`@\x82\x01\x96_\x83\x01\x90an\xC9V[\x01\x90a\x08;V[V[ao\rao\x08ao\x12\x92a\x07\x94V[a\x06\x87V[a$\x15V[\x90V[ao\x1Da%HV[P\x80ao7ao1`\x01\x80`\xD0\x1B\x03a6QV[\x91a\x07\x94V[\x11aoHWaoE\x90an\xF9V[\x90V[`\xD0aod_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01an\xD6V[\x03\x90\xFD[\x90ao\x9Eao\xA4\x93\x92aoya%HV[Pao\x82a%HV[P\x80\x93ao\x97ao\x90a>HV[\x94\x92aX\x01V[\x90\x91av\x14V[\x91arkV[\x91\x90\x91\x90V[ao\xBEao\xB9ao\xC3\x92a]\xEAV[a\x06\x87V[a\x07\x94V[\x90V[6\x907V[\x90ao\xF0ao\xD8\x83a8\x93V[\x92` \x80ao\xE6\x86\x93a8pV[\x92\x01\x91\x03\x90ao\xC6V[V[ao\xFAa&!V[Pap\x04\x81ar\xD5V[\x90ap\x17ap\x12` ao\xAAV[ao\xCBV[\x91\x82R` \x82\x01R\x90V[\x91\x90\x91\x80ap@ap:ap5_a+\0V[a\x07eV[\x91a\x07eV[\x14_\x14aq!Wapdap]\x83apX`\x02a\x11\x1AV[a0XV[`\x02a+gV[[\x82ap\x80apzapu_a+\0V[a\x07eV[\x91a\x07eV[\x14_\x14ap\xF5Wap\xA4ap\x9D\x83ap\x98`\x02a\x11\x1AV[aL[V[`\x02a+gV[[\x91\x90\x91ap\xF0ap\xDEap\xD8\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x93a\x10\xDFV[\x93a\x10\xDFV[\x93ap\xE7a\x05\x12V[\x91\x82\x91\x82a\x08HV[\x03\x90\xA3V[aq\x1C\x82aq\x16aq\x07_\x87\x90a:\xDCV[\x91aq\x11\x83a\x11\x1AV[a_\x82V[\x90a+gV[ap\xA5V[aq4aq/_\x83\x90a:\xDCV[a\x11\x1AV[\x80aqGaqA\x85a\x07\x94V[\x91a\x07\x94V[\x10aqoWaqZaqj\x91\x84\x90aL[V[aqe_\x84\x90a:\xDCV[a+gV[apeV[\x90aq\x8D\x90\x91\x92_\x93\x84\x93c9\x144\xE3`\xE2\x1B\x85R`\x04\x85\x01aL)V[\x03\x90\xFD[aq\x99a'\x97V[Paq\xA9`\x01\x80`\xD0\x1B\x03a6QV[\x90V[\x91ar\x04aq\xFEar\x0B\x94\x80aq\xD2aq\xCCaq\xC7_a+\0V[a\x07eV[\x91a\x07eV[\x14ar<W[\x84aq\xF3aq\xEDaq\xE8_a+\0V[a\x07eV[\x91a\x07eV[\x14ar\rW[a9\x91V[\x92a9\x91V[\x90\x91af_V[V[ar5`\x0B`\x02ar/ar)ar#\x89ao\x15V[\x93a6NV[\x91af\\V[\x90aohV[PPaq\xF9V[ard`\x0B`\x01ar^arXarR\x89ao\x15V[\x93a6NV[\x91af\\V[\x90aohV[PPaq\xD8V[\x91ar\x8F_ar\x94\x94ar|a%HV[Par\x85a%HV[P\x01\x92\x91\x92aQ\x7FV[at\xC6V[\x91\x90\x91\x90V[ar\xAEar\xA9ar\xB3\x92ah\xFCV[a\x06\x87V[a\x07\x94V[\x90V[\x90V[ar\xCDar\xC8ar\xD2\x92ar\xB6V[a\x06\x87V[a\x07\x94V[\x90V[ar\xEAar\xEF\x91ar\xE4a'\x97V[Pa/zV[aj\x8BV[ar\xF9`\xFFar\x9AV[\x16\x80as\x0Eas\x08`\x1Far\xB9V[\x91a\x07\x94V[\x11as\x16W\x90V[_c,\xD4J\xC3`\xE2\x1B\x81R\x80as.`\x04\x82\x01a\t\x13V[\x03\x90\xFD[T\x90V[as@`@a8[V[\x90V[_R` _ \x90V[asU\x81as2V[\x82\x10\x15asoWasg`\x01\x91asCV[\x91\x02\x01\x90_\x90V[a\x0E\xD7V[as~\x90Qa\x19uV[\x90V[\x90as\x92e\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x1C\0V[\x91\x81\x19\x16\x91\x16\x17\x90V[as\xB0as\xABas\xB5\x92a\x19uV[a\x06\x87V[a\x19uV[\x90V[\x90V[\x90as\xD0as\xCBas\xD7\x92as\x9CV[as\xB8V[\x82Tas\x81V[\x90UV[as\xE5\x90Qa$\x15V[\x90V[`0\x1B\x90V[\x90at\0e\xFF\xFF\xFF\xFF\xFF\xFF\x19\x91as\xE8V[\x91\x81\x19\x16\x91\x16\x17\x90V[at\x1Eat\x19at#\x92a$\x15V[a\x06\x87V[a$\x15V[\x90V[\x90V[\x90at>at9atE\x92at\nV[at&V[\x82Tas\xEEV[\x90UV[\x90ats` _aty\x94atk\x82\x82\x01ate\x84\x88\x01astV[\x90as\xBBV[\x01\x92\x01as\xDBV[\x90at)V[V[\x91\x90at\x8CWat\x8A\x91atIV[V[a\x0B^V[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15at\xC1W\x82at\xB9\x91`\x01at\xBF\x95\x01\x81UasLV[\x90at{V[V[a\x0CZV[\x90\x92\x91\x92at\xD2a%HV[Pat\xDBa%HV[Pat\xE5\x82as2V[\x80at\xF8at\xF2_a*\xC8V[\x91a\x07\x94V[\x11_\x14au\xC8Wau\x1E\x90au\x18\x84\x91au\x12`\x01aDGV[\x90a,\xF0V[\x90ab\xFBV[\x90au*_\x83\x01aQ\xA1V[\x92au6_\x84\x01aQ\xD3V[\x93\x80auJauD\x85a\x19uV[\x91a\x19uV[\x11au\xACWauaau[\x84a\x19uV[\x91a\x19uV[\x14_\x14au|WPPauw\x90_\x85\x91\x01at)V[[\x91\x90V[au\xA7\x92Pau\xA2\x86au\x99au\x90as6V[\x94_\x86\x01am)V[` \x84\x01am7V[at\x91V[auxV[_c% `\x1D`\xE0\x1B\x81R\x80au\xC4`\x04\x82\x01a\t\x13V[\x03\x90\xFD[Pau\xF3\x91au\xEE\x85au\xE5au\xDCas6V[\x94_\x86\x01am)V[` \x84\x01am7V[at\x91V[au\xFC_aQ\xE0V[\x91\x90V[cNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[\x91\x90\x91\x80`\x01\x14av3W`\x02\x03av\0Wav/\x91a%\xC7V[\x90[V[Pav=\x91a%\x88V[\x90av1V",
    );
    /**Custom error with signature `AccessControlBadConfirmation()` and selector `0x6697b232`.
```solidity
error AccessControlBadConfirmation();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlBadConfirmation {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlBadConfirmation>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlBadConfirmation) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlBadConfirmation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlBadConfirmation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlBadConfirmation()";
            const SELECTOR: [u8; 4] = [102u8, 151u8, 178u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `AccessControlUnauthorizedAccount(address,bytes32)` and selector `0xe2517d3f`.
```solidity
error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub neededRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlUnauthorizedAccount) -> Self {
                (value.account, value.neededRole)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    neededRole: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlUnauthorizedAccount(address,bytes32)";
            const SELECTOR: [u8; 4] = [226u8, 81u8, 125u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.neededRole),
                )
            }
        }
    };
    /**Custom error with signature `AllEmissionsCompleted()` and selector `0x4555892c`.
```solidity
error AllEmissionsCompleted();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AllEmissionsCompleted {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AllEmissionsCompleted> for UnderlyingRustTuple<'_> {
            fn from(value: AllEmissionsCompleted) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AllEmissionsCompleted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AllEmissionsCompleted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AllEmissionsCompleted()";
            const SELECTOR: [u8; 4] = [69u8, 85u8, 137u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `BridgeNotAuthorized()` and selector `0x882eec12`.
```solidity
error BridgeNotAuthorized();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BridgeNotAuthorized {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BridgeNotAuthorized> for UnderlyingRustTuple<'_> {
            fn from(value: BridgeNotAuthorized) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BridgeNotAuthorized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BridgeNotAuthorized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BridgeNotAuthorized()";
            const SELECTOR: [u8; 4] = [136u8, 46u8, 236u8, 18u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `BridgeNotConfigured()` and selector `0x7614917a`.
```solidity
error BridgeNotConfigured();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BridgeNotConfigured {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BridgeNotConfigured> for UnderlyingRustTuple<'_> {
            fn from(value: BridgeNotConfigured) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BridgeNotConfigured {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BridgeNotConfigured {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BridgeNotConfigured()";
            const SELECTOR: [u8; 4] = [118u8, 20u8, 145u8, 122u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `CheckpointUnorderedInsertion()` and selector `0x2520601d`.
```solidity
error CheckpointUnorderedInsertion();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CheckpointUnorderedInsertion {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CheckpointUnorderedInsertion>
        for UnderlyingRustTuple<'_> {
            fn from(value: CheckpointUnorderedInsertion) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for CheckpointUnorderedInsertion {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CheckpointUnorderedInsertion {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CheckpointUnorderedInsertion()";
            const SELECTOR: [u8; 4] = [37u8, 32u8, 96u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignature()` and selector `0xf645eedf`.
```solidity
error ECDSAInvalidSignature();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignature {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignature> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignature) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignature()";
            const SELECTOR: [u8; 4] = [246u8, 69u8, 238u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureLength(uint256)` and selector `0xfce698f7`.
```solidity
error ECDSAInvalidSignatureLength(uint256 length);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureLength {
        #[allow(missing_docs)]
        pub length: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureLength>
        for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureLength) -> Self {
                (value.length,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ECDSAInvalidSignatureLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { length: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureLength(uint256)";
            const SELECTOR: [u8; 4] = [252u8, 230u8, 152u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.length),
                )
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureS(bytes32)` and selector `0xd78bce0c`.
```solidity
error ECDSAInvalidSignatureS(bytes32 s);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureS {
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureS> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureS) -> Self {
                (value.s,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignatureS {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { s: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureS {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureS(bytes32)";
            const SELECTOR: [u8; 4] = [215u8, 139u8, 206u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
        }
    };
    /**Custom error with signature `ERC20ExceededSafeSupply(uint256,uint256)` and selector `0x1cb15d26`.
```solidity
error ERC20ExceededSafeSupply(uint256 increasedSupply, uint256 cap);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20ExceededSafeSupply {
        #[allow(missing_docs)]
        pub increasedSupply: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub cap: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20ExceededSafeSupply> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20ExceededSafeSupply) -> Self {
                (value.increasedSupply, value.cap)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20ExceededSafeSupply {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    increasedSupply: tuple.0,
                    cap: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20ExceededSafeSupply {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20ExceededSafeSupply(uint256,uint256)";
            const SELECTOR: [u8; 4] = [28u8, 177u8, 93u8, 38u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.increasedSupply),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.cap),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InsufficientAllowance(address,uint256,uint256)` and selector `0xfb8f41b2`.
```solidity
error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InsufficientAllowance {
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub allowance: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub needed: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InsufficientAllowance>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InsufficientAllowance) -> Self {
                (value.spender, value.allowance, value.needed)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC20InsufficientAllowance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    spender: tuple.0,
                    allowance: tuple.1,
                    needed: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InsufficientAllowance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InsufficientAllowance(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [251u8, 143u8, 65u8, 178u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allowance),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.needed),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InsufficientBalance(address,uint256,uint256)` and selector `0xe450d38c`.
```solidity
error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InsufficientBalance {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub balance: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub needed: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InsufficientBalance>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InsufficientBalance) -> Self {
                (value.sender, value.balance, value.needed)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC20InsufficientBalance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    sender: tuple.0,
                    balance: tuple.1,
                    needed: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InsufficientBalance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InsufficientBalance(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [228u8, 80u8, 211u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.balance),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.needed),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidApprover(address)` and selector `0xe602df05`.
```solidity
error ERC20InvalidApprover(address approver);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidApprover {
        #[allow(missing_docs)]
        pub approver: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidApprover> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidApprover) -> Self {
                (value.approver,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidApprover {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { approver: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidApprover {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidApprover(address)";
            const SELECTOR: [u8; 4] = [230u8, 2u8, 223u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.approver,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidReceiver(address)` and selector `0xec442f05`.
```solidity
error ERC20InvalidReceiver(address receiver);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidReceiver {
        #[allow(missing_docs)]
        pub receiver: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidReceiver> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidReceiver) -> Self {
                (value.receiver,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidReceiver {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { receiver: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidReceiver {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidReceiver(address)";
            const SELECTOR: [u8; 4] = [236u8, 68u8, 47u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.receiver,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidSender(address)` and selector `0x96c6fd1e`.
```solidity
error ERC20InvalidSender(address sender);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidSender {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidSender> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidSender) -> Self {
                (value.sender,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidSender {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { sender: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidSender {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidSender(address)";
            const SELECTOR: [u8; 4] = [150u8, 198u8, 253u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidSpender(address)` and selector `0x94280d62`.
```solidity
error ERC20InvalidSpender(address spender);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidSpender {
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidSpender> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidSpender) -> Self {
                (value.spender,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidSpender {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { spender: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidSpender {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidSpender(address)";
            const SELECTOR: [u8; 4] = [148u8, 40u8, 13u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC2612ExpiredSignature(uint256)` and selector `0x62791302`.
```solidity
error ERC2612ExpiredSignature(uint256 deadline);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC2612ExpiredSignature {
        #[allow(missing_docs)]
        pub deadline: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC2612ExpiredSignature> for UnderlyingRustTuple<'_> {
            fn from(value: ERC2612ExpiredSignature) -> Self {
                (value.deadline,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC2612ExpiredSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { deadline: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC2612ExpiredSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC2612ExpiredSignature(uint256)";
            const SELECTOR: [u8; 4] = [98u8, 121u8, 19u8, 2u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.deadline),
                )
            }
        }
    };
    /**Custom error with signature `ERC2612InvalidSigner(address,address)` and selector `0x4b800e46`.
```solidity
error ERC2612InvalidSigner(address signer, address owner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC2612InvalidSigner {
        #[allow(missing_docs)]
        pub signer: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC2612InvalidSigner> for UnderlyingRustTuple<'_> {
            fn from(value: ERC2612InvalidSigner) -> Self {
                (value.signer, value.owner)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC2612InvalidSigner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    signer: tuple.0,
                    owner: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC2612InvalidSigner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC2612InvalidSigner(address,address)";
            const SELECTOR: [u8; 4] = [75u8, 128u8, 14u8, 70u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signer,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC5805FutureLookup(uint256,uint48)` and selector `0xecd3f81e`.
```solidity
error ERC5805FutureLookup(uint256 timepoint, uint48 clock);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC5805FutureLookup {
        #[allow(missing_docs)]
        pub timepoint: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub clock: alloy::sol_types::private::primitives::aliases::U48,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<48>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U48,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC5805FutureLookup> for UnderlyingRustTuple<'_> {
            fn from(value: ERC5805FutureLookup) -> Self {
                (value.timepoint, value.clock)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC5805FutureLookup {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    timepoint: tuple.0,
                    clock: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC5805FutureLookup {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC5805FutureLookup(uint256,uint48)";
            const SELECTOR: [u8; 4] = [236u8, 211u8, 248u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.timepoint),
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(&self.clock),
                )
            }
        }
    };
    /**Custom error with signature `ERC6372InconsistentClock()` and selector `0x6ff07140`.
```solidity
error ERC6372InconsistentClock();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC6372InconsistentClock {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC6372InconsistentClock>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC6372InconsistentClock) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC6372InconsistentClock {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC6372InconsistentClock {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC6372InconsistentClock()";
            const SELECTOR: [u8; 4] = [111u8, 240u8, 113u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmissionTooEarly()` and selector `0x3d53c753`.
```solidity
error EmissionTooEarly();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmissionTooEarly {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmissionTooEarly> for UnderlyingRustTuple<'_> {
            fn from(value: EmissionTooEarly) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmissionTooEarly {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmissionTooEarly {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmissionTooEarly()";
            const SELECTOR: [u8; 4] = [61u8, 83u8, 199u8, 83u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmissionsAlreadyStarted()` and selector `0x71d27b7a`.
```solidity
error EmissionsAlreadyStarted();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmissionsAlreadyStarted {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmissionsAlreadyStarted> for UnderlyingRustTuple<'_> {
            fn from(value: EmissionsAlreadyStarted) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmissionsAlreadyStarted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmissionsAlreadyStarted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmissionsAlreadyStarted()";
            const SELECTOR: [u8; 4] = [113u8, 210u8, 123u8, 122u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmissionsNotActive()` and selector `0x66bf2674`.
```solidity
error EmissionsNotActive();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmissionsNotActive {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmissionsNotActive> for UnderlyingRustTuple<'_> {
            fn from(value: EmissionsNotActive) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmissionsNotActive {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmissionsNotActive {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmissionsNotActive()";
            const SELECTOR: [u8; 4] = [102u8, 191u8, 38u8, 116u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmissionsNotStarted()` and selector `0x8f984041`.
```solidity
error EmissionsNotStarted();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmissionsNotStarted {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmissionsNotStarted> for UnderlyingRustTuple<'_> {
            fn from(value: EmissionsNotStarted) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmissionsNotStarted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmissionsNotStarted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmissionsNotStarted()";
            const SELECTOR: [u8; 4] = [143u8, 152u8, 64u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EnforcedPause()` and selector `0xd93c0665`.
```solidity
error EnforcedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EnforcedPause {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EnforcedPause> for UnderlyingRustTuple<'_> {
            fn from(value: EnforcedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EnforcedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EnforcedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EnforcedPause()";
            const SELECTOR: [u8; 4] = [217u8, 60u8, 6u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ExceedsEmissionsSupply()` and selector `0x23064ebd`.
```solidity
error ExceedsEmissionsSupply();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExceedsEmissionsSupply {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExceedsEmissionsSupply> for UnderlyingRustTuple<'_> {
            fn from(value: ExceedsEmissionsSupply) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ExceedsEmissionsSupply {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ExceedsEmissionsSupply {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ExceedsEmissionsSupply()";
            const SELECTOR: [u8; 4] = [35u8, 6u8, 78u8, 189u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ExpectedPause()` and selector `0x8dfc202b`.
```solidity
error ExpectedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExpectedPause {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExpectedPause> for UnderlyingRustTuple<'_> {
            fn from(value: ExpectedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ExpectedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ExpectedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ExpectedPause()";
            const SELECTOR: [u8; 4] = [141u8, 252u8, 32u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InsufficientLimit()` and selector `0x72567b64`.
```solidity
error InsufficientLimit();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientLimit {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientLimit> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientLimit) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientLimit {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientLimit {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientLimit()";
            const SELECTOR: [u8; 4] = [114u8, 86u8, 123u8, 100u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidAccountNonce(address,uint256)` and selector `0x752d88c0`.
```solidity
error InvalidAccountNonce(address account, uint256 currentNonce);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidAccountNonce {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub currentNonce: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidAccountNonce> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidAccountNonce) -> Self {
                (value.account, value.currentNonce)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidAccountNonce {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    currentNonce: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidAccountNonce {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidAccountNonce(address,uint256)";
            const SELECTOR: [u8; 4] = [117u8, 45u8, 136u8, 192u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.currentNonce),
                )
            }
        }
    };
    /**Custom error with signature `InvalidShortString()` and selector `0xb3512b0c`.
```solidity
error InvalidShortString();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidShortString {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidShortString> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidShortString) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidShortString {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidShortString {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidShortString()";
            const SELECTOR: [u8; 4] = [179u8, 81u8, 43u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ReentrancyGuardReentrantCall()` and selector `0x3ee5aeb5`.
```solidity
error ReentrancyGuardReentrantCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ReentrancyGuardReentrantCall {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ReentrancyGuardReentrantCall>
        for UnderlyingRustTuple<'_> {
            fn from(value: ReentrancyGuardReentrantCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ReentrancyGuardReentrantCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ReentrancyGuardReentrantCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ReentrancyGuardReentrantCall()";
            const SELECTOR: [u8; 4] = [62u8, 229u8, 174u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `SafeCastOverflowedUintDowncast(uint8,uint256)` and selector `0x6dfcc650`.
```solidity
error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SafeCastOverflowedUintDowncast {
        #[allow(missing_docs)]
        pub bits: u8,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            u8,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SafeCastOverflowedUintDowncast>
        for UnderlyingRustTuple<'_> {
            fn from(value: SafeCastOverflowedUintDowncast) -> Self {
                (value.bits, value.value)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SafeCastOverflowedUintDowncast {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    bits: tuple.0,
                    value: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SafeCastOverflowedUintDowncast {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SafeCastOverflowedUintDowncast(uint8,uint256)";
            const SELECTOR: [u8; 4] = [109u8, 252u8, 198u8, 80u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.bits),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
        }
    };
    /**Custom error with signature `StringTooLong(string)` and selector `0x305a27a9`.
```solidity
error StringTooLong(string str);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct StringTooLong {
        #[allow(missing_docs)]
        pub str: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<StringTooLong> for UnderlyingRustTuple<'_> {
            fn from(value: StringTooLong) -> Self {
                (value.str,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for StringTooLong {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { str: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for StringTooLong {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "StringTooLong(string)";
            const SELECTOR: [u8; 4] = [48u8, 90u8, 39u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.str,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `VotesExpiredSignature(uint256)` and selector `0x4683af0e`.
```solidity
error VotesExpiredSignature(uint256 expiry);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct VotesExpiredSignature {
        #[allow(missing_docs)]
        pub expiry: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<VotesExpiredSignature> for UnderlyingRustTuple<'_> {
            fn from(value: VotesExpiredSignature) -> Self {
                (value.expiry,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for VotesExpiredSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { expiry: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for VotesExpiredSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "VotesExpiredSignature(uint256)";
            const SELECTOR: [u8; 4] = [70u8, 131u8, 175u8, 14u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expiry),
                )
            }
        }
    };
    /**Custom error with signature `ZeroAddress()` and selector `0xd92e233d`.
```solidity
error ZeroAddress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAddress {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAddress> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAddress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAddress()";
            const SELECTOR: [u8; 4] = [217u8, 46u8, 35u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ZeroAmount()` and selector `0x1f2a2005`.
```solidity
error ZeroAmount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAmount {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAmount> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAmount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAmount()";
            const SELECTOR: [u8; 4] = [31u8, 42u8, 32u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Event with signature `Approval(address,address,uint256)` and selector `0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925`.
```solidity
event Approval(address indexed owner, address indexed spender, uint256 value);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Approval {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Approval {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Approval(address,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                140u8,
                91u8,
                225u8,
                229u8,
                235u8,
                236u8,
                125u8,
                91u8,
                209u8,
                79u8,
                113u8,
                66u8,
                125u8,
                30u8,
                132u8,
                243u8,
                221u8,
                3u8,
                20u8,
                192u8,
                247u8,
                178u8,
                41u8,
                30u8,
                91u8,
                32u8,
                10u8,
                200u8,
                199u8,
                195u8,
                185u8,
                37u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    owner: topics.1,
                    spender: topics.2,
                    value: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.owner.clone(), self.spender.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.owner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.spender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Approval {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Approval> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Approval) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeAuthorized(address)` and selector `0x6cf28439a2daab1b265097227212a5b71e0a76f9ed85e3f815b5a6c3e218eb7f`.
```solidity
event BridgeAuthorized(address indexed bridge);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeAuthorized {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeAuthorized {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeAuthorized(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                108u8,
                242u8,
                132u8,
                57u8,
                162u8,
                218u8,
                171u8,
                27u8,
                38u8,
                80u8,
                151u8,
                34u8,
                114u8,
                18u8,
                165u8,
                183u8,
                30u8,
                10u8,
                118u8,
                249u8,
                237u8,
                133u8,
                227u8,
                248u8,
                21u8,
                181u8,
                166u8,
                195u8,
                226u8,
                24u8,
                235u8,
                127u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { bridge: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.bridge.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridge,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeAuthorized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeAuthorized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeAuthorized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeDataUpdated(bytes,bytes)` and selector `0xb9a2088426f03b30a81c06428094fbfa9e2692739b3241af6b9ab1da4b5546be`.
```solidity
event BridgeDataUpdated(bytes oldData, bytes newData);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeDataUpdated {
        #[allow(missing_docs)]
        pub oldData: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub newData: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeDataUpdated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Bytes,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "BridgeDataUpdated(bytes,bytes)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                185u8,
                162u8,
                8u8,
                132u8,
                38u8,
                240u8,
                59u8,
                48u8,
                168u8,
                28u8,
                6u8,
                66u8,
                128u8,
                148u8,
                251u8,
                250u8,
                158u8,
                38u8,
                146u8,
                115u8,
                155u8,
                50u8,
                65u8,
                175u8,
                107u8,
                154u8,
                177u8,
                218u8,
                75u8,
                85u8,
                70u8,
                190u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldData: data.0,
                    newData: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.oldData,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.newData,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeDataUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeDataUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeDataUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeDeauthorized(address)` and selector `0x02c2f0ba15b03f88b18f4832609a18cf35fc6b3f4546a9992076d7453d1334a8`.
```solidity
event BridgeDeauthorized(address indexed bridge);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeDeauthorized {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeDeauthorized {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeDeauthorized(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                2u8,
                194u8,
                240u8,
                186u8,
                21u8,
                176u8,
                63u8,
                136u8,
                177u8,
                143u8,
                72u8,
                50u8,
                96u8,
                154u8,
                24u8,
                207u8,
                53u8,
                252u8,
                107u8,
                63u8,
                69u8,
                70u8,
                169u8,
                153u8,
                32u8,
                118u8,
                215u8,
                69u8,
                61u8,
                19u8,
                52u8,
                168u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { bridge: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.bridge.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridge,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeDeauthorized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeDeauthorized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeDeauthorized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeLimitsSet(address,uint256,uint256)` and selector `0xaa807d0abf30d91968c7478c66b6d82521a106af13eda036e2036da9af168958`.
```solidity
event BridgeLimitsSet(address indexed bridge, uint256 mintingLimit, uint256 burningLimit);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeLimitsSet {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub mintingLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub burningLimit: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeLimitsSet {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeLimitsSet(address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                170u8,
                128u8,
                125u8,
                10u8,
                191u8,
                48u8,
                217u8,
                25u8,
                104u8,
                199u8,
                71u8,
                140u8,
                102u8,
                182u8,
                216u8,
                37u8,
                33u8,
                161u8,
                6u8,
                175u8,
                19u8,
                237u8,
                160u8,
                54u8,
                226u8,
                3u8,
                109u8,
                169u8,
                175u8,
                22u8,
                137u8,
                88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    bridge: topics.1,
                    mintingLimit: data.0,
                    burningLimit: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.mintingLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.burningLimit),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.bridge.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridge,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeLimitsSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeLimitsSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeLimitsSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeProxyUpdated(address,address)` and selector `0x07015b6a9f05913148fd5faddf2acc9708f305937f3072ca2b4b46faa5d0898b`.
```solidity
event BridgeProxyUpdated(address indexed oldProxy, address indexed newProxy);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeProxyUpdated {
        #[allow(missing_docs)]
        pub oldProxy: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newProxy: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeProxyUpdated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeProxyUpdated(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                7u8,
                1u8,
                91u8,
                106u8,
                159u8,
                5u8,
                145u8,
                49u8,
                72u8,
                253u8,
                95u8,
                173u8,
                223u8,
                42u8,
                204u8,
                151u8,
                8u8,
                243u8,
                5u8,
                147u8,
                127u8,
                48u8,
                114u8,
                202u8,
                43u8,
                75u8,
                70u8,
                250u8,
                165u8,
                208u8,
                137u8,
                139u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldProxy: topics.1,
                    newProxy: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.oldProxy.clone(),
                    self.newProxy.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.oldProxy,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newProxy,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeProxyUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeProxyUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeProxyUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `DelegateChanged(address,address,address)` and selector `0x3134e8a2e6d97e929a7e54011ea5485d7d196dd5f0ba4d4ef95803e8e3fc257f`.
```solidity
event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DelegateChanged {
        #[allow(missing_docs)]
        pub delegator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub fromDelegate: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub toDelegate: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DelegateChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "DelegateChanged(address,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                49u8,
                52u8,
                232u8,
                162u8,
                230u8,
                217u8,
                126u8,
                146u8,
                154u8,
                126u8,
                84u8,
                1u8,
                30u8,
                165u8,
                72u8,
                93u8,
                125u8,
                25u8,
                109u8,
                213u8,
                240u8,
                186u8,
                77u8,
                78u8,
                249u8,
                88u8,
                3u8,
                232u8,
                227u8,
                252u8,
                37u8,
                127u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    delegator: topics.1,
                    fromDelegate: topics.2,
                    toDelegate: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.delegator.clone(),
                    self.fromDelegate.clone(),
                    self.toDelegate.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.delegator,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.fromDelegate,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.toDelegate,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DelegateChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DelegateChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &DelegateChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `DelegateVotesChanged(address,uint256,uint256)` and selector `0xdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a724`.
```solidity
event DelegateVotesChanged(address indexed delegate, uint256 previousVotes, uint256 newVotes);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DelegateVotesChanged {
        #[allow(missing_docs)]
        pub delegate: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub previousVotes: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub newVotes: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DelegateVotesChanged {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "DelegateVotesChanged(address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                222u8,
                194u8,
                186u8,
                205u8,
                210u8,
                240u8,
                91u8,
                89u8,
                222u8,
                52u8,
                218u8,
                155u8,
                82u8,
                61u8,
                255u8,
                139u8,
                228u8,
                46u8,
                94u8,
                56u8,
                232u8,
                24u8,
                200u8,
                47u8,
                219u8,
                11u8,
                174u8,
                119u8,
                67u8,
                135u8,
                167u8,
                36u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    delegate: topics.1,
                    previousVotes: data.0,
                    newVotes: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.previousVotes),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newVotes),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.delegate.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.delegate,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DelegateVotesChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DelegateVotesChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &DelegateVotesChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EIP712DomainChanged()` and selector `0x0a6387c9ea3628b88a633bb4f3b151770f70085117a15f9bf3787cda53f13d31`.
```solidity
event EIP712DomainChanged();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EIP712DomainChanged {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EIP712DomainChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "EIP712DomainChanged()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                10u8,
                99u8,
                135u8,
                201u8,
                234u8,
                54u8,
                40u8,
                184u8,
                138u8,
                99u8,
                59u8,
                180u8,
                243u8,
                177u8,
                81u8,
                119u8,
                15u8,
                112u8,
                8u8,
                81u8,
                23u8,
                161u8,
                95u8,
                155u8,
                243u8,
                120u8,
                124u8,
                218u8,
                83u8,
                241u8,
                61u8,
                49u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EIP712DomainChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EIP712DomainChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EIP712DomainChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EmissionMinted(uint256,uint256,address)` and selector `0x34b73d0c96e9ff4d5311434817c8ecc930e7d2782c5bde2e79dc44b0596755bb`.
```solidity
event EmissionMinted(uint256 epoch, uint256 amount, address indexed destination);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EmissionMinted {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub destination: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EmissionMinted {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "EmissionMinted(uint256,uint256,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                52u8,
                183u8,
                61u8,
                12u8,
                150u8,
                233u8,
                255u8,
                77u8,
                83u8,
                17u8,
                67u8,
                72u8,
                23u8,
                200u8,
                236u8,
                201u8,
                48u8,
                231u8,
                210u8,
                120u8,
                44u8,
                91u8,
                222u8,
                46u8,
                121u8,
                220u8,
                68u8,
                176u8,
                89u8,
                103u8,
                85u8,
                187u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    epoch: data.0,
                    amount: data.1,
                    destination: topics.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epoch),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.destination.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.destination,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EmissionMinted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EmissionMinted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EmissionMinted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EmissionsPaused()` and selector `0x73a5fc60aafeec8f139af22d98e62140e2ce914d1f155c692b427757c3e4014c`.
```solidity
event EmissionsPaused();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EmissionsPaused {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EmissionsPaused {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "EmissionsPaused()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                115u8,
                165u8,
                252u8,
                96u8,
                170u8,
                254u8,
                236u8,
                143u8,
                19u8,
                154u8,
                242u8,
                45u8,
                152u8,
                230u8,
                33u8,
                64u8,
                226u8,
                206u8,
                145u8,
                77u8,
                31u8,
                21u8,
                92u8,
                105u8,
                43u8,
                66u8,
                119u8,
                87u8,
                195u8,
                228u8,
                1u8,
                76u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EmissionsPaused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EmissionsPaused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EmissionsPaused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EmissionsResumed()` and selector `0x4a792a0be42b5672faa40129fc6469072490775ca8d3c34e852d4d55d3a735a9`.
```solidity
event EmissionsResumed();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EmissionsResumed {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EmissionsResumed {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "EmissionsResumed()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                74u8,
                121u8,
                42u8,
                11u8,
                228u8,
                43u8,
                86u8,
                114u8,
                250u8,
                164u8,
                1u8,
                41u8,
                252u8,
                100u8,
                105u8,
                7u8,
                36u8,
                144u8,
                119u8,
                92u8,
                168u8,
                211u8,
                195u8,
                78u8,
                133u8,
                45u8,
                77u8,
                85u8,
                211u8,
                167u8,
                53u8,
                169u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EmissionsResumed {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EmissionsResumed> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EmissionsResumed) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EmissionsStarted(uint256)` and selector `0x1194b034cfa9ab5807494a1d5c667d8b0e6e97f38888742aa3871a3220341160`.
```solidity
event EmissionsStarted(uint256 startTime);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EmissionsStarted {
        #[allow(missing_docs)]
        pub startTime: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EmissionsStarted {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "EmissionsStarted(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                17u8,
                148u8,
                176u8,
                52u8,
                207u8,
                169u8,
                171u8,
                88u8,
                7u8,
                73u8,
                74u8,
                29u8,
                92u8,
                102u8,
                125u8,
                139u8,
                14u8,
                110u8,
                151u8,
                243u8,
                136u8,
                136u8,
                116u8,
                42u8,
                163u8,
                135u8,
                26u8,
                50u8,
                32u8,
                52u8,
                17u8,
                96u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { startTime: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.startTime),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EmissionsStarted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EmissionsStarted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EmissionsStarted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Paused(address)` and selector `0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258`.
```solidity
event Paused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Paused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Paused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Paused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                98u8,
                231u8,
                140u8,
                234u8,
                1u8,
                190u8,
                227u8,
                32u8,
                205u8,
                78u8,
                66u8,
                2u8,
                112u8,
                181u8,
                234u8,
                116u8,
                0u8,
                13u8,
                17u8,
                176u8,
                201u8,
                247u8,
                71u8,
                84u8,
                235u8,
                219u8,
                252u8,
                84u8,
                75u8,
                5u8,
                162u8,
                88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Paused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Paused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Paused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleAdminChanged(bytes32,bytes32,bytes32)` and selector `0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff`.
```solidity
event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleAdminChanged {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub previousAdminRole: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newAdminRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleAdminChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "RoleAdminChanged(bytes32,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    previousAdminRole: topics.2,
                    newAdminRole: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.previousAdminRole.clone(),
                    self.newAdminRole.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.previousAdminRole);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newAdminRole);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleAdminChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleAdminChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleAdminChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleGranted(bytes32,address,address)` and selector `0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d`.
```solidity
event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleGranted {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleGranted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleGranted(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleGranted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleGranted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleGranted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleRevoked(bytes32,address,address)` and selector `0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b`.
```solidity
event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleRevoked {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleRevoked(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Transfer(address,address,uint256)` and selector `0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef`.
```solidity
event Transfer(address indexed from, address indexed to, uint256 value);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Transfer {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Transfer {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Transfer(address,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                221u8,
                242u8,
                82u8,
                173u8,
                27u8,
                226u8,
                200u8,
                155u8,
                105u8,
                194u8,
                176u8,
                104u8,
                252u8,
                55u8,
                141u8,
                170u8,
                149u8,
                43u8,
                167u8,
                241u8,
                99u8,
                196u8,
                161u8,
                22u8,
                40u8,
                245u8,
                90u8,
                77u8,
                245u8,
                35u8,
                179u8,
                239u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    from: topics.1,
                    to: topics.2,
                    value: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.from.clone(), self.to.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.from,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.to,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Transfer {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Transfer> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Transfer) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Unpaused(address)` and selector `0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa`.
```solidity
event Unpaused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Unpaused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Unpaused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Unpaused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                93u8,
                185u8,
                238u8,
                10u8,
                73u8,
                91u8,
                242u8,
                230u8,
                255u8,
                156u8,
                145u8,
                167u8,
                131u8,
                76u8,
                27u8,
                164u8,
                253u8,
                210u8,
                68u8,
                165u8,
                232u8,
                170u8,
                78u8,
                83u8,
                123u8,
                211u8,
                138u8,
                234u8,
                228u8,
                176u8,
                115u8,
                170u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Unpaused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Unpaused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Unpaused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address defaultAdmin, address syndFoundationAddress, address emissionsManager, address pauser);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub defaultAdmin: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub syndFoundationAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub emissionsManager: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub pauser: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (
                        value.defaultAdmin,
                        value.syndFoundationAddress,
                        value.emissionsManager,
                        value.pauser,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        defaultAdmin: tuple.0,
                        syndFoundationAddress: tuple.1,
                        emissionsManager: tuple.2,
                        pauser: tuple.3,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.defaultAdmin,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.syndFoundationAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.emissionsManager,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.pauser,
                    ),
                )
            }
        }
    };
    /**Function with signature `BRIDGE_LIMIT_DURATION()` and selector `0x99127d9b`.
```solidity
function BRIDGE_LIMIT_DURATION() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_LIMIT_DURATIONCall {}
    ///Container type for the return parameters of the [`BRIDGE_LIMIT_DURATION()`](BRIDGE_LIMIT_DURATIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_LIMIT_DURATIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_LIMIT_DURATIONCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_LIMIT_DURATIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_LIMIT_DURATIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_LIMIT_DURATIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_LIMIT_DURATIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_LIMIT_DURATIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for BRIDGE_LIMIT_DURATIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = BRIDGE_LIMIT_DURATIONReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BRIDGE_LIMIT_DURATION()";
            const SELECTOR: [u8; 4] = [153u8, 18u8, 125u8, 155u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `BRIDGE_MANAGER_ROLE()` and selector `0xf75e8512`.
```solidity
function BRIDGE_MANAGER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_MANAGER_ROLECall {}
    ///Container type for the return parameters of the [`BRIDGE_MANAGER_ROLE()`](BRIDGE_MANAGER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_MANAGER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_MANAGER_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_MANAGER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_MANAGER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_MANAGER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_MANAGER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_MANAGER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for BRIDGE_MANAGER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = BRIDGE_MANAGER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BRIDGE_MANAGER_ROLE()";
            const SELECTOR: [u8; 4] = [247u8, 94u8, 133u8, 18u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `CLOCK_MODE()` and selector `0x4bf5d7e9`.
```solidity
function CLOCK_MODE() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CLOCK_MODECall {}
    ///Container type for the return parameters of the [`CLOCK_MODE()`](CLOCK_MODECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CLOCK_MODEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CLOCK_MODECall> for UnderlyingRustTuple<'_> {
                fn from(value: CLOCK_MODECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for CLOCK_MODECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CLOCK_MODEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: CLOCK_MODEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for CLOCK_MODEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for CLOCK_MODECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = CLOCK_MODEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CLOCK_MODE()";
            const SELECTOR: [u8; 4] = [75u8, 245u8, 215u8, 233u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `DEFAULT_ADMIN_ROLE()` and selector `0xa217fddf`.
```solidity
function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLECall {}
    ///Container type for the return parameters of the [`DEFAULT_ADMIN_ROLE()`](DEFAULT_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEFAULT_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DEFAULT_ADMIN_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEFAULT_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [162u8, 23u8, 253u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `DOMAIN_SEPARATOR()` and selector `0x3644e515`.
```solidity
function DOMAIN_SEPARATOR() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DOMAIN_SEPARATORCall {}
    ///Container type for the return parameters of the [`DOMAIN_SEPARATOR()`](DOMAIN_SEPARATORCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DOMAIN_SEPARATORReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DOMAIN_SEPARATORCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DOMAIN_SEPARATORCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DOMAIN_SEPARATORCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DOMAIN_SEPARATORReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DOMAIN_SEPARATORReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DOMAIN_SEPARATORReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DOMAIN_SEPARATORCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DOMAIN_SEPARATORReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DOMAIN_SEPARATOR()";
            const SELECTOR: [u8; 4] = [54u8, 68u8, 229u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSIONS_MANAGER_ROLE()` and selector `0xe3abdfcb`.
```solidity
function EMISSIONS_MANAGER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_MANAGER_ROLECall {}
    ///Container type for the return parameters of the [`EMISSIONS_MANAGER_ROLE()`](EMISSIONS_MANAGER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_MANAGER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_MANAGER_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_MANAGER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSIONS_MANAGER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_MANAGER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_MANAGER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSIONS_MANAGER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSIONS_MANAGER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSIONS_MANAGER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSIONS_MANAGER_ROLE()";
            const SELECTOR: [u8; 4] = [227u8, 171u8, 223u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSIONS_SUPPLY()` and selector `0x6cf01625`.
```solidity
function EMISSIONS_SUPPLY() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_SUPPLYCall {}
    ///Container type for the return parameters of the [`EMISSIONS_SUPPLY()`](EMISSIONS_SUPPLYCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_SUPPLYReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_SUPPLYCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_SUPPLYCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSIONS_SUPPLYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_SUPPLYReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_SUPPLYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSIONS_SUPPLYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSIONS_SUPPLYCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSIONS_SUPPLYReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSIONS_SUPPLY()";
            const SELECTOR: [u8; 4] = [108u8, 240u8, 22u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSION_BUFFER_TIME()` and selector `0x243a30cc`.
```solidity
function EMISSION_BUFFER_TIME() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_BUFFER_TIMECall {}
    ///Container type for the return parameters of the [`EMISSION_BUFFER_TIME()`](EMISSION_BUFFER_TIMECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_BUFFER_TIMEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_BUFFER_TIMECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_BUFFER_TIMECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_BUFFER_TIMECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_BUFFER_TIMEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_BUFFER_TIMEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_BUFFER_TIMEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSION_BUFFER_TIMECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSION_BUFFER_TIMEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSION_BUFFER_TIME()";
            const SELECTOR: [u8; 4] = [36u8, 58u8, 48u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EPOCH_DURATION()` and selector `0xa70b9f0c`.
```solidity
function EPOCH_DURATION() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EPOCH_DURATIONCall {}
    ///Container type for the return parameters of the [`EPOCH_DURATION()`](EPOCH_DURATIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EPOCH_DURATIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EPOCH_DURATIONCall> for UnderlyingRustTuple<'_> {
                fn from(value: EPOCH_DURATIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for EPOCH_DURATIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EPOCH_DURATIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EPOCH_DURATIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EPOCH_DURATIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EPOCH_DURATIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EPOCH_DURATIONReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EPOCH_DURATION()";
            const SELECTOR: [u8; 4] = [167u8, 11u8, 159u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `INITIAL_MINT_SUPPLY()` and selector `0x9b7ef64b`.
```solidity
function INITIAL_MINT_SUPPLY() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct INITIAL_MINT_SUPPLYCall {}
    ///Container type for the return parameters of the [`INITIAL_MINT_SUPPLY()`](INITIAL_MINT_SUPPLYCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct INITIAL_MINT_SUPPLYReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<INITIAL_MINT_SUPPLYCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: INITIAL_MINT_SUPPLYCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for INITIAL_MINT_SUPPLYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<INITIAL_MINT_SUPPLYReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: INITIAL_MINT_SUPPLYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for INITIAL_MINT_SUPPLYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for INITIAL_MINT_SUPPLYCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = INITIAL_MINT_SUPPLYReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "INITIAL_MINT_SUPPLY()";
            const SELECTOR: [u8; 4] = [155u8, 126u8, 246u8, 75u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `PAUSER_ROLE()` and selector `0xe63ab1e9`.
```solidity
function PAUSER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PAUSER_ROLECall {}
    ///Container type for the return parameters of the [`PAUSER_ROLE()`](PAUSER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PAUSER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PAUSER_ROLECall> for UnderlyingRustTuple<'_> {
                fn from(value: PAUSER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for PAUSER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PAUSER_ROLEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: PAUSER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for PAUSER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for PAUSER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = PAUSER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PAUSER_ROLE()";
            const SELECTOR: [u8; 4] = [230u8, 58u8, 177u8, 233u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `PRECISION_MULTIPLIER()` and selector `0xae5ecbc6`.
```solidity
function PRECISION_MULTIPLIER() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PRECISION_MULTIPLIERCall {}
    ///Container type for the return parameters of the [`PRECISION_MULTIPLIER()`](PRECISION_MULTIPLIERCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PRECISION_MULTIPLIERReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PRECISION_MULTIPLIERCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: PRECISION_MULTIPLIERCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for PRECISION_MULTIPLIERCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PRECISION_MULTIPLIERReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: PRECISION_MULTIPLIERReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for PRECISION_MULTIPLIERReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for PRECISION_MULTIPLIERCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = PRECISION_MULTIPLIERReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PRECISION_MULTIPLIER()";
            const SELECTOR: [u8; 4] = [174u8, 94u8, 203u8, 198u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `TOTAL_EPOCHS()` and selector `0x5f15c3c9`.
```solidity
function TOTAL_EPOCHS() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_EPOCHSCall {}
    ///Container type for the return parameters of the [`TOTAL_EPOCHS()`](TOTAL_EPOCHSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_EPOCHSReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_EPOCHSCall> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_EPOCHSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_EPOCHSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_EPOCHSReturn> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_EPOCHSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_EPOCHSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for TOTAL_EPOCHSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = TOTAL_EPOCHSReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TOTAL_EPOCHS()";
            const SELECTOR: [u8; 4] = [95u8, 21u8, 195u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `TOTAL_SUPPLY()` and selector `0x902d55a5`.
```solidity
function TOTAL_SUPPLY() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_SUPPLYCall {}
    ///Container type for the return parameters of the [`TOTAL_SUPPLY()`](TOTAL_SUPPLYCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_SUPPLYReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_SUPPLYCall> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_SUPPLYCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_SUPPLYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_SUPPLYReturn> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_SUPPLYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_SUPPLYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for TOTAL_SUPPLYCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = TOTAL_SUPPLYReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TOTAL_SUPPLY()";
            const SELECTOR: [u8; 4] = [144u8, 45u8, 85u8, 165u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `allowance(address,address)` and selector `0xdd62ed3e`.
```solidity
function allowance(address owner, address spender) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allowanceCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`allowance(address,address)`](allowanceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allowanceReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowanceCall> for UnderlyingRustTuple<'_> {
                fn from(value: allowanceCall) -> Self {
                    (value.owner, value.spender)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for allowanceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        spender: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowanceReturn> for UnderlyingRustTuple<'_> {
                fn from(value: allowanceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for allowanceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for allowanceCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = allowanceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "allowance(address,address)";
            const SELECTOR: [u8; 4] = [221u8, 98u8, 237u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `approve(address,uint256)` and selector `0x095ea7b3`.
```solidity
function approve(address spender, uint256 value) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveCall {
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`approve(address,uint256)`](approveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveCall> for UnderlyingRustTuple<'_> {
                fn from(value: approveCall) -> Self {
                    (value.spender, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        spender: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveReturn> for UnderlyingRustTuple<'_> {
                fn from(value: approveReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for approveCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = approveReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "approve(address,uint256)";
            const SELECTOR: [u8; 4] = [9u8, 94u8, 167u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `authorizedBridges(address)` and selector `0x6fc063be`.
```solidity
function authorizedBridges(address) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct authorizedBridgesCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`authorizedBridges(address)`](authorizedBridgesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct authorizedBridgesReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<authorizedBridgesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: authorizedBridgesCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for authorizedBridgesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<authorizedBridgesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: authorizedBridgesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for authorizedBridgesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for authorizedBridgesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = authorizedBridgesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "authorizedBridges(address)";
            const SELECTOR: [u8; 4] = [111u8, 192u8, 99u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `balanceOf(address)` and selector `0x70a08231`.
```solidity
function balanceOf(address account) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`balanceOf(address)`](balanceOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfCall> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfReturn> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for balanceOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = balanceOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "balanceOf(address)";
            const SELECTOR: [u8; 4] = [112u8, 160u8, 130u8, 49u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeData()` and selector `0x2481bb5c`.
```solidity
function bridgeData() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeDataCall {}
    ///Container type for the return parameters of the [`bridgeData()`](bridgeDataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeDataReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeDataCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeDataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeDataReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeDataReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeDataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeDataReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeData()";
            const SELECTOR: [u8; 4] = [36u8, 129u8, 187u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeLimits(address)` and selector `0x44e181aa`.
```solidity
function bridgeLimits(address) external view returns (uint256 mintingMaxLimit, uint256 mintingCurrentLimit, uint256 burningMaxLimit, uint256 burningCurrentLimit, uint256 lastUpdate);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeLimitsCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`bridgeLimits(address)`](bridgeLimitsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeLimitsReturn {
        #[allow(missing_docs)]
        pub mintingMaxLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub mintingCurrentLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub burningMaxLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub burningCurrentLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub lastUpdate: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeLimitsCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeLimitsCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeLimitsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeLimitsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeLimitsReturn) -> Self {
                    (
                        value.mintingMaxLimit,
                        value.mintingCurrentLimit,
                        value.burningMaxLimit,
                        value.burningCurrentLimit,
                        value.lastUpdate,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeLimitsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        mintingMaxLimit: tuple.0,
                        mintingCurrentLimit: tuple.1,
                        burningMaxLimit: tuple.2,
                        burningCurrentLimit: tuple.3,
                        lastUpdate: tuple.4,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeLimitsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeLimitsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeLimits(address)";
            const SELECTOR: [u8; 4] = [68u8, 225u8, 129u8, 170u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeProxy()` and selector `0xa3d4485b`.
```solidity
function bridgeProxy() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeProxyCall {}
    ///Container type for the return parameters of the [`bridgeProxy()`](bridgeProxyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeProxyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeProxyCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeProxyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeProxyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeProxyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeProxyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeProxyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeProxyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeProxyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeProxy()";
            const SELECTOR: [u8; 4] = [163u8, 212u8, 72u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `burn(address,uint256)` and selector `0x9dc29fac`.
```solidity
function burn(address _user, uint256 _amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burnCall {
        #[allow(missing_docs)]
        pub _user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`burn(address,uint256)`](burnCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burnReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burnCall> for UnderlyingRustTuple<'_> {
                fn from(value: burnCall) -> Self {
                    (value._user, value._amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for burnCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _user: tuple.0,
                        _amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burnReturn> for UnderlyingRustTuple<'_> {
                fn from(value: burnReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for burnReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for burnCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = burnReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "burn(address,uint256)";
            const SELECTOR: [u8; 4] = [157u8, 194u8, 159u8, 172u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `burningCurrentLimitOf(address)` and selector `0x998955d3`.
```solidity
function burningCurrentLimitOf(address _bridge) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burningCurrentLimitOfCall {
        #[allow(missing_docs)]
        pub _bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`burningCurrentLimitOf(address)`](burningCurrentLimitOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burningCurrentLimitOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burningCurrentLimitOfCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: burningCurrentLimitOfCall) -> Self {
                    (value._bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for burningCurrentLimitOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burningCurrentLimitOfReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: burningCurrentLimitOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for burningCurrentLimitOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for burningCurrentLimitOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = burningCurrentLimitOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "burningCurrentLimitOf(address)";
            const SELECTOR: [u8; 4] = [153u8, 137u8, 85u8, 211u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `burningMaxLimitOf(address)` and selector `0xc1eb7137`.
```solidity
function burningMaxLimitOf(address _bridge) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burningMaxLimitOfCall {
        #[allow(missing_docs)]
        pub _bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`burningMaxLimitOf(address)`](burningMaxLimitOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burningMaxLimitOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burningMaxLimitOfCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: burningMaxLimitOfCall) -> Self {
                    (value._bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for burningMaxLimitOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burningMaxLimitOfReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: burningMaxLimitOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for burningMaxLimitOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for burningMaxLimitOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = burningMaxLimitOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "burningMaxLimitOf(address)";
            const SELECTOR: [u8; 4] = [193u8, 235u8, 113u8, 55u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `checkpoints(address,uint32)` and selector `0xf1127ed8`.
```solidity
function checkpoints(address account, uint32 pos) external view returns (Checkpoints.Checkpoint208 memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkpointsCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub pos: u32,
    }
    ///Container type for the return parameters of the [`checkpoints(address,uint32)`](checkpointsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkpointsReturn {
        #[allow(missing_docs)]
        pub _0: <Checkpoints::Checkpoint208 as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, u32);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkpointsCall> for UnderlyingRustTuple<'_> {
                fn from(value: checkpointsCall) -> Self {
                    (value.account, value.pos)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for checkpointsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        account: tuple.0,
                        pos: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Checkpoints::Checkpoint208,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Checkpoints::Checkpoint208 as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkpointsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: checkpointsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for checkpointsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkpointsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkpointsReturn;
            type ReturnTuple<'a> = (Checkpoints::Checkpoint208,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkpoints(address,uint32)";
            const SELECTOR: [u8; 4] = [241u8, 18u8, 126u8, 216u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.pos),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `clock()` and selector `0x91ddadf4`.
```solidity
function clock() external view returns (uint48);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct clockCall {}
    ///Container type for the return parameters of the [`clock()`](clockCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct clockReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U48,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<clockCall> for UnderlyingRustTuple<'_> {
                fn from(value: clockCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for clockCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U48,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<clockReturn> for UnderlyingRustTuple<'_> {
                fn from(value: clockReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for clockReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for clockCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = clockReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "clock()";
            const SELECTOR: [u8; 4] = [145u8, 221u8, 173u8, 244u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `currentEpoch()` and selector `0x76671808`.
```solidity
function currentEpoch() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct currentEpochCall {}
    ///Container type for the return parameters of the [`currentEpoch()`](currentEpochCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct currentEpochReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<currentEpochCall> for UnderlyingRustTuple<'_> {
                fn from(value: currentEpochCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for currentEpochCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<currentEpochReturn> for UnderlyingRustTuple<'_> {
                fn from(value: currentEpochReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for currentEpochReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for currentEpochCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = currentEpochReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "currentEpoch()";
            const SELECTOR: [u8; 4] = [118u8, 103u8, 24u8, 8u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `decimals()` and selector `0x313ce567`.
```solidity
function decimals() external view returns (uint8);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decimalsCall {}
    ///Container type for the return parameters of the [`decimals()`](decimalsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decimalsReturn {
        #[allow(missing_docs)]
        pub _0: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decimalsCall> for UnderlyingRustTuple<'_> {
                fn from(value: decimalsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for decimalsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decimalsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: decimalsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for decimalsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for decimalsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = decimalsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "decimals()";
            const SELECTOR: [u8; 4] = [49u8, 60u8, 229u8, 103u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `delegate(address)` and selector `0x5c19a95c`.
```solidity
function delegate(address delegatee) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateCall {
        #[allow(missing_docs)]
        pub delegatee: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`delegate(address)`](delegateCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateCall> for UnderlyingRustTuple<'_> {
                fn from(value: delegateCall) -> Self {
                    (value.delegatee,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegateCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { delegatee: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateReturn> for UnderlyingRustTuple<'_> {
                fn from(value: delegateReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegateReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for delegateCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = delegateReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "delegate(address)";
            const SELECTOR: [u8; 4] = [92u8, 25u8, 169u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.delegatee,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)` and selector `0xc3cda520`.
```solidity
function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateBySigCall {
        #[allow(missing_docs)]
        pub delegatee: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub expiry: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub v: u8,
        #[allow(missing_docs)]
        pub r: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)`](delegateBySigCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateBySigReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                u8,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateBySigCall> for UnderlyingRustTuple<'_> {
                fn from(value: delegateBySigCall) -> Self {
                    (
                        value.delegatee,
                        value.nonce,
                        value.expiry,
                        value.v,
                        value.r,
                        value.s,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegateBySigCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        delegatee: tuple.0,
                        nonce: tuple.1,
                        expiry: tuple.2,
                        v: tuple.3,
                        r: tuple.4,
                        s: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateBySigReturn> for UnderlyingRustTuple<'_> {
                fn from(value: delegateBySigReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegateBySigReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for delegateBySigCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = delegateBySigReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [195u8, 205u8, 165u8, 32u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.delegatee,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expiry),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.v),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.r),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `delegates(address)` and selector `0x587cde1e`.
```solidity
function delegates(address account) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegatesCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`delegates(address)`](delegatesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegatesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegatesCall> for UnderlyingRustTuple<'_> {
                fn from(value: delegatesCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegatesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegatesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: delegatesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegatesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for delegatesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = delegatesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "delegates(address)";
            const SELECTOR: [u8; 4] = [88u8, 124u8, 222u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `eip712Domain()` and selector `0x84b0196e`.
```solidity
function eip712Domain() external view returns (bytes1 fields, string memory name, string memory version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] memory extensions);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eip712DomainCall {}
    ///Container type for the return parameters of the [`eip712Domain()`](eip712DomainCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eip712DomainReturn {
        #[allow(missing_docs)]
        pub fields: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub name: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub version: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub verifyingContract: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub salt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub extensions: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eip712DomainCall> for UnderlyingRustTuple<'_> {
                fn from(value: eip712DomainCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eip712DomainCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eip712DomainReturn> for UnderlyingRustTuple<'_> {
                fn from(value: eip712DomainReturn) -> Self {
                    (
                        value.fields,
                        value.name,
                        value.version,
                        value.chainId,
                        value.verifyingContract,
                        value.salt,
                        value.extensions,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eip712DomainReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        fields: tuple.0,
                        name: tuple.1,
                        version: tuple.2,
                        chainId: tuple.3,
                        verifyingContract: tuple.4,
                        salt: tuple.5,
                        extensions: tuple.6,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for eip712DomainCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = eip712DomainReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "eip712Domain()";
            const SELECTOR: [u8; 4] = [132u8, 176u8, 25u8, 110u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionSchedule(uint256)` and selector `0x334d0bbd`.
```solidity
function emissionSchedule(uint256) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionScheduleCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`emissionSchedule(uint256)`](emissionScheduleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionScheduleReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionScheduleCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionScheduleCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionScheduleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionScheduleReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionScheduleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionScheduleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionScheduleCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionScheduleReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionSchedule(uint256)";
            const SELECTOR: [u8; 4] = [51u8, 77u8, 11u8, 189u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionsActive()` and selector `0x22a97d9c`.
```solidity
function emissionsActive() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsActiveCall {}
    ///Container type for the return parameters of the [`emissionsActive()`](emissionsActiveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsActiveReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsActiveCall> for UnderlyingRustTuple<'_> {
                fn from(value: emissionsActiveCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for emissionsActiveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsActiveReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsActiveReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsActiveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionsActiveCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionsActiveReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionsActive()";
            const SELECTOR: [u8; 4] = [34u8, 169u8, 125u8, 156u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionsEnded()` and selector `0xa4d7e31d`.
```solidity
function emissionsEnded() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsEndedCall {}
    ///Container type for the return parameters of the [`emissionsEnded()`](emissionsEndedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsEndedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsEndedCall> for UnderlyingRustTuple<'_> {
                fn from(value: emissionsEndedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for emissionsEndedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsEndedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsEndedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsEndedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionsEndedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionsEndedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionsEnded()";
            const SELECTOR: [u8; 4] = [164u8, 215u8, 227u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionsStartTime()` and selector `0x48b0daa6`.
```solidity
function emissionsStartTime() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartTimeCall {}
    ///Container type for the return parameters of the [`emissionsStartTime()`](emissionsStartTimeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartTimeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartTimeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartTimeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartTimeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartTimeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartTimeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartTimeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionsStartTimeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionsStartTimeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionsStartTime()";
            const SELECTOR: [u8; 4] = [72u8, 176u8, 218u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionsStarted()` and selector `0x5adf0021`.
```solidity
function emissionsStarted() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartedCall {}
    ///Container type for the return parameters of the [`emissionsStarted()`](emissionsStartedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionsStartedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionsStartedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionsStarted()";
            const SELECTOR: [u8; 4] = [90u8, 223u8, 0u8, 33u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBridgeConfiguration()` and selector `0x07a1d5fa`.
```solidity
function getBridgeConfiguration() external view returns (address proxy, bytes memory data);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeConfigurationCall {}
    ///Container type for the return parameters of the [`getBridgeConfiguration()`](getBridgeConfigurationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeConfigurationReturn {
        #[allow(missing_docs)]
        pub proxy: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeConfigurationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeConfigurationCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeConfigurationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeConfigurationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeConfigurationReturn) -> Self {
                    (value.proxy, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeConfigurationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        proxy: tuple.0,
                        data: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBridgeConfigurationCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBridgeConfigurationReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBridgeConfiguration()";
            const SELECTOR: [u8; 4] = [7u8, 161u8, 213u8, 250u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBridgeInfo(address)` and selector `0x7c790cab`.
```solidity
function getBridgeInfo(address bridge) external view returns (bool authorized, uint256 mintingMax, uint256 mintingCurrent, uint256 burningMax, uint256 burningCurrent);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeInfoCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getBridgeInfo(address)`](getBridgeInfoCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeInfoReturn {
        #[allow(missing_docs)]
        pub authorized: bool,
        #[allow(missing_docs)]
        pub mintingMax: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub mintingCurrent: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub burningMax: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub burningCurrent: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeInfoCall> for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeInfoCall) -> Self {
                    (value.bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBridgeInfoCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                bool,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeInfoReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeInfoReturn) -> Self {
                    (
                        value.authorized,
                        value.mintingMax,
                        value.mintingCurrent,
                        value.burningMax,
                        value.burningCurrent,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBridgeInfoReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        authorized: tuple.0,
                        mintingMax: tuple.1,
                        mintingCurrent: tuple.2,
                        burningMax: tuple.3,
                        burningCurrent: tuple.4,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBridgeInfoCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBridgeInfoReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBridgeInfo(address)";
            const SELECTOR: [u8; 4] = [124u8, 121u8, 12u8, 171u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBridgeUtilization(address)` and selector `0x23e460d2`.
```solidity
function getBridgeUtilization(address bridge) external view returns (uint256 mintingUtilization, uint256 burningUtilization);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeUtilizationCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getBridgeUtilization(address)`](getBridgeUtilizationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeUtilizationReturn {
        #[allow(missing_docs)]
        pub mintingUtilization: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub burningUtilization: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeUtilizationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeUtilizationCall) -> Self {
                    (value.bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeUtilizationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeUtilizationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeUtilizationReturn) -> Self {
                    (value.mintingUtilization, value.burningUtilization)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeUtilizationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        mintingUtilization: tuple.0,
                        burningUtilization: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBridgeUtilizationCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBridgeUtilizationReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBridgeUtilization(address)";
            const SELECTOR: [u8; 4] = [35u8, 228u8, 96u8, 210u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getCurrentEpochInfo()` and selector `0xbabc394f`.
```solidity
function getCurrentEpochInfo() external view returns (uint256 epoch, uint256 nextEmissionTime, uint256 nextEmissionAmount, bool canMintEmission);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentEpochInfoCall {}
    ///Container type for the return parameters of the [`getCurrentEpochInfo()`](getCurrentEpochInfoCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentEpochInfoReturn {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nextEmissionTime: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nextEmissionAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub canMintEmission: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentEpochInfoCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentEpochInfoCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentEpochInfoCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                bool,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentEpochInfoReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentEpochInfoReturn) -> Self {
                    (
                        value.epoch,
                        value.nextEmissionTime,
                        value.nextEmissionAmount,
                        value.canMintEmission,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentEpochInfoReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epoch: tuple.0,
                        nextEmissionTime: tuple.1,
                        nextEmissionAmount: tuple.2,
                        canMintEmission: tuple.3,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCurrentEpochInfoCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getCurrentEpochInfoReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bool,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCurrentEpochInfo()";
            const SELECTOR: [u8; 4] = [186u8, 188u8, 57u8, 79u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getCurrentTotalSupply()` and selector `0xc02ae754`.
```solidity
function getCurrentTotalSupply() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentTotalSupplyCall {}
    ///Container type for the return parameters of the [`getCurrentTotalSupply()`](getCurrentTotalSupplyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentTotalSupplyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentTotalSupplyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentTotalSupplyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentTotalSupplyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentTotalSupplyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentTotalSupplyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentTotalSupplyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCurrentTotalSupplyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getCurrentTotalSupplyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCurrentTotalSupply()";
            const SELECTOR: [u8; 4] = [192u8, 42u8, 231u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getEmissionSchedule()` and selector `0xaf2aa63b`.
```solidity
function getEmissionSchedule() external view returns (uint256[48] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEmissionScheduleCall {}
    ///Container type for the return parameters of the [`getEmissionSchedule()`](getEmissionScheduleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEmissionScheduleReturn {
        #[allow(missing_docs)]
        pub _0: [alloy::sol_types::private::primitives::aliases::U256; 48usize],
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEmissionScheduleCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getEmissionScheduleCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getEmissionScheduleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    48usize,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                [alloy::sol_types::private::primitives::aliases::U256; 48usize],
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEmissionScheduleReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getEmissionScheduleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getEmissionScheduleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getEmissionScheduleCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getEmissionScheduleReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    48usize,
                >,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getEmissionSchedule()";
            const SELECTOR: [u8; 4] = [175u8, 42u8, 166u8, 59u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getNextEmissionTime()` and selector `0xa5b326be`.
```solidity
function getNextEmissionTime() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getNextEmissionTimeCall {}
    ///Container type for the return parameters of the [`getNextEmissionTime()`](getNextEmissionTimeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getNextEmissionTimeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getNextEmissionTimeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getNextEmissionTimeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getNextEmissionTimeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getNextEmissionTimeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getNextEmissionTimeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getNextEmissionTimeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getNextEmissionTimeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getNextEmissionTimeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getNextEmissionTime()";
            const SELECTOR: [u8; 4] = [165u8, 179u8, 38u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getPastTotalSupply(uint256)` and selector `0x8e539e8c`.
```solidity
function getPastTotalSupply(uint256 timepoint) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastTotalSupplyCall {
        #[allow(missing_docs)]
        pub timepoint: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getPastTotalSupply(uint256)`](getPastTotalSupplyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastTotalSupplyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastTotalSupplyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPastTotalSupplyCall) -> Self {
                    (value.timepoint,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPastTotalSupplyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { timepoint: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastTotalSupplyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPastTotalSupplyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPastTotalSupplyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPastTotalSupplyCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPastTotalSupplyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPastTotalSupply(uint256)";
            const SELECTOR: [u8; 4] = [142u8, 83u8, 158u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.timepoint),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getPastVotes(address,uint256)` and selector `0x3a46b1a8`.
```solidity
function getPastVotes(address account, uint256 timepoint) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastVotesCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub timepoint: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getPastVotes(address,uint256)`](getPastVotesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastVotesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastVotesCall> for UnderlyingRustTuple<'_> {
                fn from(value: getPastVotesCall) -> Self {
                    (value.account, value.timepoint)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getPastVotesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        account: tuple.0,
                        timepoint: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastVotesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getPastVotesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getPastVotesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPastVotesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPastVotesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPastVotes(address,uint256)";
            const SELECTOR: [u8; 4] = [58u8, 70u8, 177u8, 168u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.timepoint),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getPastVotingPower(address,uint256)` and selector `0xb0ca253e`.
```solidity
function getPastVotingPower(address account, uint256 blockNumber) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastVotingPowerCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub blockNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getPastVotingPower(address,uint256)`](getPastVotingPowerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastVotingPowerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastVotingPowerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPastVotingPowerCall) -> Self {
                    (value.account, value.blockNumber)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPastVotingPowerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        account: tuple.0,
                        blockNumber: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastVotingPowerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPastVotingPowerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPastVotingPowerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPastVotingPowerCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPastVotingPowerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPastVotingPower(address,uint256)";
            const SELECTOR: [u8; 4] = [176u8, 202u8, 37u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNumber),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRemainingEmissions()` and selector `0x4bdd36ce`.
```solidity
function getRemainingEmissions() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRemainingEmissionsCall {}
    ///Container type for the return parameters of the [`getRemainingEmissions()`](getRemainingEmissionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRemainingEmissionsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRemainingEmissionsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRemainingEmissionsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRemainingEmissionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRemainingEmissionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRemainingEmissionsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRemainingEmissionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRemainingEmissionsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRemainingEmissionsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRemainingEmissions()";
            const SELECTOR: [u8; 4] = [75u8, 221u8, 54u8, 206u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRoleAdmin(bytes32)` and selector `0x248a9ca3`.
```solidity
function getRoleAdmin(bytes32 role) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getRoleAdmin(bytes32)`](getRoleAdminCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleAdminCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRoleAdminReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleAdmin(bytes32)";
            const SELECTOR: [u8; 4] = [36u8, 138u8, 156u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getVotes(address)` and selector `0x9ab24eb0`.
```solidity
function getVotes(address account) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVotesCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getVotes(address)`](getVotesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVotesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVotesCall> for UnderlyingRustTuple<'_> {
                fn from(value: getVotesCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVotesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVotesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getVotesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVotesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getVotesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getVotesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getVotes(address)";
            const SELECTOR: [u8; 4] = [154u8, 178u8, 78u8, 176u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getVotingPower(address)` and selector `0xbb4d4436`.
```solidity
function getVotingPower(address account) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVotingPowerCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getVotingPower(address)`](getVotingPowerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVotingPowerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVotingPowerCall> for UnderlyingRustTuple<'_> {
                fn from(value: getVotingPowerCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVotingPowerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVotingPowerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getVotingPowerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getVotingPowerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getVotingPowerCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getVotingPowerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getVotingPower(address)";
            const SELECTOR: [u8; 4] = [187u8, 77u8, 68u8, 54u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `grantRole(bytes32,address)` and selector `0x2f2ff15d`.
```solidity
function grantRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`grantRole(bytes32,address)`](grantRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for grantRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = grantRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "grantRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [47u8, 47u8, 241u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `hasRole(bytes32,address)` and selector `0x91d14854`.
```solidity
function hasRole(bytes32 role, address account) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`hasRole(bytes32,address)`](hasRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = hasRoleReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [145u8, 209u8, 72u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isBridge(address)` and selector `0x726600ce`.
```solidity
function isBridge(address bridge) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isBridgeCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`isBridge(address)`](isBridgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isBridgeReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isBridgeCall> for UnderlyingRustTuple<'_> {
                fn from(value: isBridgeCall) -> Self {
                    (value.bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isBridgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isBridgeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isBridgeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isBridgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isBridgeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isBridgeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isBridge(address)";
            const SELECTOR: [u8; 4] = [114u8, 102u8, 0u8, 206u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `mint(address,uint256)` and selector `0x40c10f19`.
```solidity
function mint(address _user, uint256 _amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintCall {
        #[allow(missing_docs)]
        pub _user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`mint(address,uint256)`](mintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintCall> for UnderlyingRustTuple<'_> {
                fn from(value: mintCall) -> Self {
                    (value._user, value._amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _user: tuple.0,
                        _amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintReturn> for UnderlyingRustTuple<'_> {
                fn from(value: mintReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mintCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mintReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mint(address,uint256)";
            const SELECTOR: [u8; 4] = [64u8, 193u8, 15u8, 25u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._user,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `mintEmission()` and selector `0x284e1333`.
```solidity
function mintEmission() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintEmissionCall {}
    ///Container type for the return parameters of the [`mintEmission()`](mintEmissionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintEmissionReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintEmissionCall> for UnderlyingRustTuple<'_> {
                fn from(value: mintEmissionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintEmissionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintEmissionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: mintEmissionReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintEmissionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mintEmissionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mintEmissionReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mintEmission()";
            const SELECTOR: [u8; 4] = [40u8, 78u8, 19u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `mintingCurrentLimitOf(address)` and selector `0x651fd268`.
```solidity
function mintingCurrentLimitOf(address _bridge) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintingCurrentLimitOfCall {
        #[allow(missing_docs)]
        pub _bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`mintingCurrentLimitOf(address)`](mintingCurrentLimitOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintingCurrentLimitOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintingCurrentLimitOfCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: mintingCurrentLimitOfCall) -> Self {
                    (value._bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for mintingCurrentLimitOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintingCurrentLimitOfReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: mintingCurrentLimitOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for mintingCurrentLimitOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mintingCurrentLimitOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mintingCurrentLimitOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mintingCurrentLimitOf(address)";
            const SELECTOR: [u8; 4] = [101u8, 31u8, 210u8, 104u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `mintingMaxLimitOf(address)` and selector `0x0c05f82c`.
```solidity
function mintingMaxLimitOf(address _bridge) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintingMaxLimitOfCall {
        #[allow(missing_docs)]
        pub _bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`mintingMaxLimitOf(address)`](mintingMaxLimitOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintingMaxLimitOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintingMaxLimitOfCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: mintingMaxLimitOfCall) -> Self {
                    (value._bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for mintingMaxLimitOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintingMaxLimitOfReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: mintingMaxLimitOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for mintingMaxLimitOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mintingMaxLimitOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mintingMaxLimitOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mintingMaxLimitOf(address)";
            const SELECTOR: [u8; 4] = [12u8, 5u8, 248u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `name()` and selector `0x06fdde03`.
```solidity
function name() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nameCall {}
    ///Container type for the return parameters of the [`name()`](nameCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nameReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nameCall> for UnderlyingRustTuple<'_> {
                fn from(value: nameCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nameCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nameReturn> for UnderlyingRustTuple<'_> {
                fn from(value: nameReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nameReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for nameCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = nameReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "name()";
            const SELECTOR: [u8; 4] = [6u8, 253u8, 222u8, 3u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `nonces(address)` and selector `0x7ecebe00`.
```solidity
function nonces(address owner) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct noncesCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`nonces(address)`](noncesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct noncesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<noncesCall> for UnderlyingRustTuple<'_> {
                fn from(value: noncesCall) -> Self {
                    (value.owner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for noncesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { owner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<noncesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: noncesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for noncesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for noncesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = noncesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "nonces(address)";
            const SELECTOR: [u8; 4] = [126u8, 206u8, 190u8, 0u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `numCheckpoints(address)` and selector `0x6fcfff45`.
```solidity
function numCheckpoints(address account) external view returns (uint32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct numCheckpointsCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`numCheckpoints(address)`](numCheckpointsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct numCheckpointsReturn {
        #[allow(missing_docs)]
        pub _0: u32,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<numCheckpointsCall> for UnderlyingRustTuple<'_> {
                fn from(value: numCheckpointsCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for numCheckpointsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<numCheckpointsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: numCheckpointsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for numCheckpointsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for numCheckpointsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = numCheckpointsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "numCheckpoints(address)";
            const SELECTOR: [u8; 4] = [111u8, 207u8, 255u8, 69u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `pause()` and selector `0x8456cb59`.
```solidity
function pause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseCall {}
    ///Container type for the return parameters of the [`pause()`](pauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pause()";
            const SELECTOR: [u8; 4] = [132u8, 86u8, 203u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `pauseEmissions()` and selector `0x6c33bced`.
```solidity
function pauseEmissions() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseEmissionsCall {}
    ///Container type for the return parameters of the [`pauseEmissions()`](pauseEmissionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseEmissionsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseEmissionsCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseEmissionsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseEmissionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseEmissionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: pauseEmissionsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for pauseEmissionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseEmissionsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseEmissionsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pauseEmissions()";
            const SELECTOR: [u8; 4] = [108u8, 51u8, 188u8, 237u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `paused()` and selector `0x5c975abb`.
```solidity
function paused() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedCall {}
    ///Container type for the return parameters of the [`paused()`](pausedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedCall> for UnderlyingRustTuple<'_> {
                fn from(value: pausedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pausedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pausedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pausedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "paused()";
            const SELECTOR: [u8; 4] = [92u8, 151u8, 90u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `permit(address,address,uint256,uint256,uint8,bytes32,bytes32)` and selector `0xd505accf`.
```solidity
function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct permitCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub deadline: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub v: u8,
        #[allow(missing_docs)]
        pub r: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`permit(address,address,uint256,uint256,uint8,bytes32,bytes32)`](permitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct permitReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                u8,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<permitCall> for UnderlyingRustTuple<'_> {
                fn from(value: permitCall) -> Self {
                    (
                        value.owner,
                        value.spender,
                        value.value,
                        value.deadline,
                        value.v,
                        value.r,
                        value.s,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for permitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        spender: tuple.1,
                        value: tuple.2,
                        deadline: tuple.3,
                        v: tuple.4,
                        r: tuple.5,
                        s: tuple.6,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<permitReturn> for UnderlyingRustTuple<'_> {
                fn from(value: permitReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for permitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for permitCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = permitReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [213u8, 5u8, 172u8, 207u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.deadline),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.v),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.r),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `renounceRole(bytes32,address)` and selector `0x36568abe`.
```solidity
function renounceRole(bytes32 role, address callerConfirmation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub callerConfirmation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`renounceRole(bytes32,address)`](renounceRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleCall) -> Self {
                    (value.role, value.callerConfirmation)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        callerConfirmation: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [54u8, 86u8, 138u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callerConfirmation,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `resumeEmissions()` and selector `0x359b76fe`.
```solidity
function resumeEmissions() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resumeEmissionsCall {}
    ///Container type for the return parameters of the [`resumeEmissions()`](resumeEmissionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resumeEmissionsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resumeEmissionsCall> for UnderlyingRustTuple<'_> {
                fn from(value: resumeEmissionsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for resumeEmissionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resumeEmissionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: resumeEmissionsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for resumeEmissionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for resumeEmissionsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = resumeEmissionsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "resumeEmissions()";
            const SELECTOR: [u8; 4] = [53u8, 155u8, 118u8, 254u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `revokeRole(bytes32,address)` and selector `0xd547741f`.
```solidity
function revokeRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeRole(bytes32,address)`](revokeRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [213u8, 71u8, 116u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBridgeData(bytes)` and selector `0x13beaa5b`.
```solidity
function setBridgeData(bytes memory _bridgeData) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeDataCall {
        #[allow(missing_docs)]
        pub _bridgeData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`setBridgeData(bytes)`](setBridgeDataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeDataReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeDataCall> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeDataCall) -> Self {
                    (value._bridgeData,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgeDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridgeData: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeDataReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeDataReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgeDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBridgeDataCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBridgeDataReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBridgeData(bytes)";
            const SELECTOR: [u8; 4] = [19u8, 190u8, 170u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self._bridgeData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBridgeProxy(address)` and selector `0xa571e184`.
```solidity
function setBridgeProxy(address _bridgeProxy) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeProxyCall {
        #[allow(missing_docs)]
        pub _bridgeProxy: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setBridgeProxy(address)`](setBridgeProxyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeProxyReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeProxyCall> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeProxyCall) -> Self {
                    (value._bridgeProxy,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgeProxyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridgeProxy: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeProxyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeProxyReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setBridgeProxyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBridgeProxyCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBridgeProxyReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBridgeProxy(address)";
            const SELECTOR: [u8; 4] = [165u8, 113u8, 225u8, 132u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridgeProxy,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setLimits(address,uint256,uint256)` and selector `0xa08d5654`.
```solidity
function setLimits(address _bridge, uint256 _mintingLimit, uint256 _burningLimit) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setLimitsCall {
        #[allow(missing_docs)]
        pub _bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _mintingLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _burningLimit: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setLimits(address,uint256,uint256)`](setLimitsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setLimitsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setLimitsCall> for UnderlyingRustTuple<'_> {
                fn from(value: setLimitsCall) -> Self {
                    (value._bridge, value._mintingLimit, value._burningLimit)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setLimitsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _bridge: tuple.0,
                        _mintingLimit: tuple.1,
                        _burningLimit: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setLimitsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setLimitsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setLimitsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setLimitsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setLimitsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setLimits(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [160u8, 141u8, 86u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridge,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._mintingLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._burningLimit),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `startEmissions()` and selector `0x1b02f845`.
```solidity
function startEmissions() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startEmissionsCall {}
    ///Container type for the return parameters of the [`startEmissions()`](startEmissionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startEmissionsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startEmissionsCall> for UnderlyingRustTuple<'_> {
                fn from(value: startEmissionsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for startEmissionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startEmissionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: startEmissionsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for startEmissionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for startEmissionsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = startEmissionsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "startEmissions()";
            const SELECTOR: [u8; 4] = [27u8, 2u8, 248u8, 69u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
```solidity
function supportsInterface(bytes4 interfaceId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceCall {
        #[allow(missing_docs)]
        pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
    }
    ///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceCall) -> Self {
                    (value.interfaceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { interfaceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportsInterfaceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = supportsInterfaceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportsInterface(bytes4)";
            const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.interfaceId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `symbol()` and selector `0x95d89b41`.
```solidity
function symbol() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct symbolCall {}
    ///Container type for the return parameters of the [`symbol()`](symbolCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct symbolReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<symbolCall> for UnderlyingRustTuple<'_> {
                fn from(value: symbolCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for symbolCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<symbolReturn> for UnderlyingRustTuple<'_> {
                fn from(value: symbolReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for symbolReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for symbolCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = symbolReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "symbol()";
            const SELECTOR: [u8; 4] = [149u8, 216u8, 155u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `totalEmissionsMinted()` and selector `0xf508e19d`.
```solidity
function totalEmissionsMinted() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalEmissionsMintedCall {}
    ///Container type for the return parameters of the [`totalEmissionsMinted()`](totalEmissionsMintedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalEmissionsMintedReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalEmissionsMintedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: totalEmissionsMintedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for totalEmissionsMintedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalEmissionsMintedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: totalEmissionsMintedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for totalEmissionsMintedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for totalEmissionsMintedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = totalEmissionsMintedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "totalEmissionsMinted()";
            const SELECTOR: [u8; 4] = [245u8, 8u8, 225u8, 157u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `totalSupply()` and selector `0x18160ddd`.
```solidity
function totalSupply() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalSupplyCall {}
    ///Container type for the return parameters of the [`totalSupply()`](totalSupplyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalSupplyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalSupplyCall> for UnderlyingRustTuple<'_> {
                fn from(value: totalSupplyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalSupplyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalSupplyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: totalSupplyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalSupplyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for totalSupplyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = totalSupplyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "totalSupply()";
            const SELECTOR: [u8; 4] = [24u8, 22u8, 13u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transfer(address,uint256)` and selector `0xa9059cbb`.
```solidity
function transfer(address to, uint256 value) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferCall {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`transfer(address,uint256)`](transferCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferCall> for UnderlyingRustTuple<'_> {
                fn from(value: transferCall) -> Self {
                    (value.to, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferReturn> for UnderlyingRustTuple<'_> {
                fn from(value: transferReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transfer(address,uint256)";
            const SELECTOR: [u8; 4] = [169u8, 5u8, 156u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transferFrom(address,address,uint256)` and selector `0x23b872dd`.
```solidity
function transferFrom(address from, address to, uint256 value) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferFromCall {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`transferFrom(address,address,uint256)`](transferFromCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferFromReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferFromCall> for UnderlyingRustTuple<'_> {
                fn from(value: transferFromCall) -> Self {
                    (value.from, value.to, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        from: tuple.0,
                        to: tuple.1,
                        value: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferFromReturn> for UnderlyingRustTuple<'_> {
                fn from(value: transferFromReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferFromCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferFromReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferFrom(address,address,uint256)";
            const SELECTOR: [u8; 4] = [35u8, 184u8, 114u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `unpause()` and selector `0x3f4ba83a`.
```solidity
function unpause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseCall {}
    ///Container type for the return parameters of the [`unpause()`](unpauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unpauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = unpauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unpause()";
            const SELECTOR: [u8; 4] = [63u8, 75u8, 168u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`SyndicateToken`](self) function calls.
    pub enum SyndicateTokenCalls {
        #[allow(missing_docs)]
        BRIDGE_LIMIT_DURATION(BRIDGE_LIMIT_DURATIONCall),
        #[allow(missing_docs)]
        BRIDGE_MANAGER_ROLE(BRIDGE_MANAGER_ROLECall),
        #[allow(missing_docs)]
        CLOCK_MODE(CLOCK_MODECall),
        #[allow(missing_docs)]
        DEFAULT_ADMIN_ROLE(DEFAULT_ADMIN_ROLECall),
        #[allow(missing_docs)]
        DOMAIN_SEPARATOR(DOMAIN_SEPARATORCall),
        #[allow(missing_docs)]
        EMISSIONS_MANAGER_ROLE(EMISSIONS_MANAGER_ROLECall),
        #[allow(missing_docs)]
        EMISSIONS_SUPPLY(EMISSIONS_SUPPLYCall),
        #[allow(missing_docs)]
        EMISSION_BUFFER_TIME(EMISSION_BUFFER_TIMECall),
        #[allow(missing_docs)]
        EPOCH_DURATION(EPOCH_DURATIONCall),
        #[allow(missing_docs)]
        INITIAL_MINT_SUPPLY(INITIAL_MINT_SUPPLYCall),
        #[allow(missing_docs)]
        PAUSER_ROLE(PAUSER_ROLECall),
        #[allow(missing_docs)]
        PRECISION_MULTIPLIER(PRECISION_MULTIPLIERCall),
        #[allow(missing_docs)]
        TOTAL_EPOCHS(TOTAL_EPOCHSCall),
        #[allow(missing_docs)]
        TOTAL_SUPPLY(TOTAL_SUPPLYCall),
        #[allow(missing_docs)]
        allowance(allowanceCall),
        #[allow(missing_docs)]
        approve(approveCall),
        #[allow(missing_docs)]
        authorizedBridges(authorizedBridgesCall),
        #[allow(missing_docs)]
        balanceOf(balanceOfCall),
        #[allow(missing_docs)]
        bridgeData(bridgeDataCall),
        #[allow(missing_docs)]
        bridgeLimits(bridgeLimitsCall),
        #[allow(missing_docs)]
        bridgeProxy(bridgeProxyCall),
        #[allow(missing_docs)]
        burn(burnCall),
        #[allow(missing_docs)]
        burningCurrentLimitOf(burningCurrentLimitOfCall),
        #[allow(missing_docs)]
        burningMaxLimitOf(burningMaxLimitOfCall),
        #[allow(missing_docs)]
        checkpoints(checkpointsCall),
        #[allow(missing_docs)]
        clock(clockCall),
        #[allow(missing_docs)]
        currentEpoch(currentEpochCall),
        #[allow(missing_docs)]
        decimals(decimalsCall),
        #[allow(missing_docs)]
        delegate(delegateCall),
        #[allow(missing_docs)]
        delegateBySig(delegateBySigCall),
        #[allow(missing_docs)]
        delegates(delegatesCall),
        #[allow(missing_docs)]
        eip712Domain(eip712DomainCall),
        #[allow(missing_docs)]
        emissionSchedule(emissionScheduleCall),
        #[allow(missing_docs)]
        emissionsActive(emissionsActiveCall),
        #[allow(missing_docs)]
        emissionsEnded(emissionsEndedCall),
        #[allow(missing_docs)]
        emissionsStartTime(emissionsStartTimeCall),
        #[allow(missing_docs)]
        emissionsStarted(emissionsStartedCall),
        #[allow(missing_docs)]
        getBridgeConfiguration(getBridgeConfigurationCall),
        #[allow(missing_docs)]
        getBridgeInfo(getBridgeInfoCall),
        #[allow(missing_docs)]
        getBridgeUtilization(getBridgeUtilizationCall),
        #[allow(missing_docs)]
        getCurrentEpochInfo(getCurrentEpochInfoCall),
        #[allow(missing_docs)]
        getCurrentTotalSupply(getCurrentTotalSupplyCall),
        #[allow(missing_docs)]
        getEmissionSchedule(getEmissionScheduleCall),
        #[allow(missing_docs)]
        getNextEmissionTime(getNextEmissionTimeCall),
        #[allow(missing_docs)]
        getPastTotalSupply(getPastTotalSupplyCall),
        #[allow(missing_docs)]
        getPastVotes(getPastVotesCall),
        #[allow(missing_docs)]
        getPastVotingPower(getPastVotingPowerCall),
        #[allow(missing_docs)]
        getRemainingEmissions(getRemainingEmissionsCall),
        #[allow(missing_docs)]
        getRoleAdmin(getRoleAdminCall),
        #[allow(missing_docs)]
        getVotes(getVotesCall),
        #[allow(missing_docs)]
        getVotingPower(getVotingPowerCall),
        #[allow(missing_docs)]
        grantRole(grantRoleCall),
        #[allow(missing_docs)]
        hasRole(hasRoleCall),
        #[allow(missing_docs)]
        isBridge(isBridgeCall),
        #[allow(missing_docs)]
        mint(mintCall),
        #[allow(missing_docs)]
        mintEmission(mintEmissionCall),
        #[allow(missing_docs)]
        mintingCurrentLimitOf(mintingCurrentLimitOfCall),
        #[allow(missing_docs)]
        mintingMaxLimitOf(mintingMaxLimitOfCall),
        #[allow(missing_docs)]
        name(nameCall),
        #[allow(missing_docs)]
        nonces(noncesCall),
        #[allow(missing_docs)]
        numCheckpoints(numCheckpointsCall),
        #[allow(missing_docs)]
        pause(pauseCall),
        #[allow(missing_docs)]
        pauseEmissions(pauseEmissionsCall),
        #[allow(missing_docs)]
        paused(pausedCall),
        #[allow(missing_docs)]
        permit(permitCall),
        #[allow(missing_docs)]
        renounceRole(renounceRoleCall),
        #[allow(missing_docs)]
        resumeEmissions(resumeEmissionsCall),
        #[allow(missing_docs)]
        revokeRole(revokeRoleCall),
        #[allow(missing_docs)]
        setBridgeData(setBridgeDataCall),
        #[allow(missing_docs)]
        setBridgeProxy(setBridgeProxyCall),
        #[allow(missing_docs)]
        setLimits(setLimitsCall),
        #[allow(missing_docs)]
        startEmissions(startEmissionsCall),
        #[allow(missing_docs)]
        supportsInterface(supportsInterfaceCall),
        #[allow(missing_docs)]
        symbol(symbolCall),
        #[allow(missing_docs)]
        totalEmissionsMinted(totalEmissionsMintedCall),
        #[allow(missing_docs)]
        totalSupply(totalSupplyCall),
        #[allow(missing_docs)]
        transfer(transferCall),
        #[allow(missing_docs)]
        transferFrom(transferFromCall),
        #[allow(missing_docs)]
        unpause(unpauseCall),
    }
    #[automatically_derived]
    impl SyndicateTokenCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 255u8, 201u8, 167u8],
            [6u8, 253u8, 222u8, 3u8],
            [7u8, 161u8, 213u8, 250u8],
            [9u8, 94u8, 167u8, 179u8],
            [12u8, 5u8, 248u8, 44u8],
            [19u8, 190u8, 170u8, 91u8],
            [24u8, 22u8, 13u8, 221u8],
            [27u8, 2u8, 248u8, 69u8],
            [34u8, 169u8, 125u8, 156u8],
            [35u8, 184u8, 114u8, 221u8],
            [35u8, 228u8, 96u8, 210u8],
            [36u8, 58u8, 48u8, 204u8],
            [36u8, 129u8, 187u8, 92u8],
            [36u8, 138u8, 156u8, 163u8],
            [40u8, 78u8, 19u8, 51u8],
            [47u8, 47u8, 241u8, 93u8],
            [49u8, 60u8, 229u8, 103u8],
            [51u8, 77u8, 11u8, 189u8],
            [53u8, 155u8, 118u8, 254u8],
            [54u8, 68u8, 229u8, 21u8],
            [54u8, 86u8, 138u8, 190u8],
            [58u8, 70u8, 177u8, 168u8],
            [63u8, 75u8, 168u8, 58u8],
            [64u8, 193u8, 15u8, 25u8],
            [68u8, 225u8, 129u8, 170u8],
            [72u8, 176u8, 218u8, 166u8],
            [75u8, 221u8, 54u8, 206u8],
            [75u8, 245u8, 215u8, 233u8],
            [88u8, 124u8, 222u8, 30u8],
            [90u8, 223u8, 0u8, 33u8],
            [92u8, 25u8, 169u8, 92u8],
            [92u8, 151u8, 90u8, 187u8],
            [95u8, 21u8, 195u8, 201u8],
            [101u8, 31u8, 210u8, 104u8],
            [108u8, 51u8, 188u8, 237u8],
            [108u8, 240u8, 22u8, 37u8],
            [111u8, 192u8, 99u8, 190u8],
            [111u8, 207u8, 255u8, 69u8],
            [112u8, 160u8, 130u8, 49u8],
            [114u8, 102u8, 0u8, 206u8],
            [118u8, 103u8, 24u8, 8u8],
            [124u8, 121u8, 12u8, 171u8],
            [126u8, 206u8, 190u8, 0u8],
            [132u8, 86u8, 203u8, 89u8],
            [132u8, 176u8, 25u8, 110u8],
            [142u8, 83u8, 158u8, 140u8],
            [144u8, 45u8, 85u8, 165u8],
            [145u8, 209u8, 72u8, 84u8],
            [145u8, 221u8, 173u8, 244u8],
            [149u8, 216u8, 155u8, 65u8],
            [153u8, 18u8, 125u8, 155u8],
            [153u8, 137u8, 85u8, 211u8],
            [154u8, 178u8, 78u8, 176u8],
            [155u8, 126u8, 246u8, 75u8],
            [157u8, 194u8, 159u8, 172u8],
            [160u8, 141u8, 86u8, 84u8],
            [162u8, 23u8, 253u8, 223u8],
            [163u8, 212u8, 72u8, 91u8],
            [164u8, 215u8, 227u8, 29u8],
            [165u8, 113u8, 225u8, 132u8],
            [165u8, 179u8, 38u8, 190u8],
            [167u8, 11u8, 159u8, 12u8],
            [169u8, 5u8, 156u8, 187u8],
            [174u8, 94u8, 203u8, 198u8],
            [175u8, 42u8, 166u8, 59u8],
            [176u8, 202u8, 37u8, 62u8],
            [186u8, 188u8, 57u8, 79u8],
            [187u8, 77u8, 68u8, 54u8],
            [192u8, 42u8, 231u8, 84u8],
            [193u8, 235u8, 113u8, 55u8],
            [195u8, 205u8, 165u8, 32u8],
            [213u8, 5u8, 172u8, 207u8],
            [213u8, 71u8, 116u8, 31u8],
            [221u8, 98u8, 237u8, 62u8],
            [227u8, 171u8, 223u8, 203u8],
            [230u8, 58u8, 177u8, 233u8],
            [241u8, 18u8, 126u8, 216u8],
            [245u8, 8u8, 225u8, 157u8],
            [247u8, 94u8, 133u8, 18u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndicateTokenCalls {
        const NAME: &'static str = "SyndicateTokenCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 79usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::BRIDGE_LIMIT_DURATION(_) => {
                    <BRIDGE_LIMIT_DURATIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::BRIDGE_MANAGER_ROLE(_) => {
                    <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::CLOCK_MODE(_) => {
                    <CLOCK_MODECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DEFAULT_ADMIN_ROLE(_) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DOMAIN_SEPARATOR(_) => {
                    <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSIONS_MANAGER_ROLE(_) => {
                    <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSIONS_SUPPLY(_) => {
                    <EMISSIONS_SUPPLYCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSION_BUFFER_TIME(_) => {
                    <EMISSION_BUFFER_TIMECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EPOCH_DURATION(_) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::INITIAL_MINT_SUPPLY(_) => {
                    <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::PAUSER_ROLE(_) => {
                    <PAUSER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::PRECISION_MULTIPLIER(_) => {
                    <PRECISION_MULTIPLIERCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::TOTAL_EPOCHS(_) => {
                    <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::TOTAL_SUPPLY(_) => {
                    <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::allowance(_) => {
                    <allowanceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::approve(_) => <approveCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::authorizedBridges(_) => {
                    <authorizedBridgesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::balanceOf(_) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeData(_) => {
                    <bridgeDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeLimits(_) => {
                    <bridgeLimitsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeProxy(_) => {
                    <bridgeProxyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::burn(_) => <burnCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::burningCurrentLimitOf(_) => {
                    <burningCurrentLimitOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::burningMaxLimitOf(_) => {
                    <burningMaxLimitOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkpoints(_) => {
                    <checkpointsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::clock(_) => <clockCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::currentEpoch(_) => {
                    <currentEpochCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::decimals(_) => <decimalsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::delegate(_) => <delegateCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::delegateBySig(_) => {
                    <delegateBySigCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::delegates(_) => {
                    <delegatesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::eip712Domain(_) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionSchedule(_) => {
                    <emissionScheduleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionsActive(_) => {
                    <emissionsActiveCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionsEnded(_) => {
                    <emissionsEndedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionsStartTime(_) => {
                    <emissionsStartTimeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionsStarted(_) => {
                    <emissionsStartedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBridgeConfiguration(_) => {
                    <getBridgeConfigurationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBridgeInfo(_) => {
                    <getBridgeInfoCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBridgeUtilization(_) => {
                    <getBridgeUtilizationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCurrentEpochInfo(_) => {
                    <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCurrentTotalSupply(_) => {
                    <getCurrentTotalSupplyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getEmissionSchedule(_) => {
                    <getEmissionScheduleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getNextEmissionTime(_) => {
                    <getNextEmissionTimeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPastTotalSupply(_) => {
                    <getPastTotalSupplyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPastVotes(_) => {
                    <getPastVotesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPastVotingPower(_) => {
                    <getPastVotingPowerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRemainingEmissions(_) => {
                    <getRemainingEmissionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleAdmin(_) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getVotes(_) => <getVotesCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getVotingPower(_) => {
                    <getVotingPowerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::grantRole(_) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasRole(_) => <hasRoleCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::isBridge(_) => <isBridgeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::mint(_) => <mintCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::mintEmission(_) => {
                    <mintEmissionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::mintingCurrentLimitOf(_) => {
                    <mintingCurrentLimitOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::mintingMaxLimitOf(_) => {
                    <mintingMaxLimitOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::name(_) => <nameCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::nonces(_) => <noncesCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::numCheckpoints(_) => {
                    <numCheckpointsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::pause(_) => <pauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pauseEmissions(_) => {
                    <pauseEmissionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::paused(_) => <pausedCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::permit(_) => <permitCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::renounceRole(_) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::resumeEmissions(_) => {
                    <resumeEmissionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeRole(_) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBridgeData(_) => {
                    <setBridgeDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBridgeProxy(_) => {
                    <setBridgeProxyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setLimits(_) => {
                    <setLimitsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::startEmissions(_) => {
                    <startEmissionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::supportsInterface(_) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::symbol(_) => <symbolCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::totalEmissionsMinted(_) => {
                    <totalEmissionsMintedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::totalSupply(_) => {
                    <totalSupplyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transfer(_) => <transferCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::transferFrom(_) => {
                    <transferFromCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::unpause(_) => <unpauseCall as alloy_sol_types::SolCall>::SELECTOR,
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<SyndicateTokenCalls>] = &[
                {
                    fn supportsInterface(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn name(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <nameCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::name)
                    }
                    name
                },
                {
                    fn getBridgeConfiguration(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getBridgeConfigurationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getBridgeConfiguration)
                    }
                    getBridgeConfiguration
                },
                {
                    fn approve(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <approveCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::approve)
                    }
                    approve
                },
                {
                    fn mintingMaxLimitOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <mintingMaxLimitOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::mintingMaxLimitOf)
                    }
                    mintingMaxLimitOf
                },
                {
                    fn setBridgeData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <setBridgeDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::setBridgeData)
                    }
                    setBridgeData
                },
                {
                    fn totalSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <totalSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::totalSupply)
                    }
                    totalSupply
                },
                {
                    fn startEmissions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <startEmissionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::startEmissions)
                    }
                    startEmissions
                },
                {
                    fn emissionsActive(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <emissionsActiveCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::emissionsActive)
                    }
                    emissionsActive
                },
                {
                    fn transferFrom(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <transferFromCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::transferFrom)
                    }
                    transferFrom
                },
                {
                    fn getBridgeUtilization(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getBridgeUtilizationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getBridgeUtilization)
                    }
                    getBridgeUtilization
                },
                {
                    fn EMISSION_BUFFER_TIME(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <EMISSION_BUFFER_TIMECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::EMISSION_BUFFER_TIME)
                    }
                    EMISSION_BUFFER_TIME
                },
                {
                    fn bridgeData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <bridgeDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::bridgeData)
                    }
                    bridgeData
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn mintEmission(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <mintEmissionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::mintEmission)
                    }
                    mintEmission
                },
                {
                    fn grantRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn decimals(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <decimalsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::decimals)
                    }
                    decimals
                },
                {
                    fn emissionSchedule(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <emissionScheduleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::emissionSchedule)
                    }
                    emissionSchedule
                },
                {
                    fn resumeEmissions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <resumeEmissionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::resumeEmissions)
                    }
                    resumeEmissions
                },
                {
                    fn DOMAIN_SEPARATOR(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::DOMAIN_SEPARATOR)
                    }
                    DOMAIN_SEPARATOR
                },
                {
                    fn renounceRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn getPastVotes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getPastVotesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getPastVotes)
                    }
                    getPastVotes
                },
                {
                    fn unpause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <unpauseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::unpause)
                    }
                    unpause
                },
                {
                    fn mint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <mintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::mint)
                    }
                    mint
                },
                {
                    fn bridgeLimits(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <bridgeLimitsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::bridgeLimits)
                    }
                    bridgeLimits
                },
                {
                    fn emissionsStartTime(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <emissionsStartTimeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::emissionsStartTime)
                    }
                    emissionsStartTime
                },
                {
                    fn getRemainingEmissions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getRemainingEmissionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getRemainingEmissions)
                    }
                    getRemainingEmissions
                },
                {
                    fn CLOCK_MODE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <CLOCK_MODECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::CLOCK_MODE)
                    }
                    CLOCK_MODE
                },
                {
                    fn delegates(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <delegatesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::delegates)
                    }
                    delegates
                },
                {
                    fn emissionsStarted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <emissionsStartedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::emissionsStarted)
                    }
                    emissionsStarted
                },
                {
                    fn delegate(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <delegateCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::delegate)
                    }
                    delegate
                },
                {
                    fn paused(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <pausedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::paused)
                    }
                    paused
                },
                {
                    fn TOTAL_EPOCHS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::TOTAL_EPOCHS)
                    }
                    TOTAL_EPOCHS
                },
                {
                    fn mintingCurrentLimitOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <mintingCurrentLimitOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::mintingCurrentLimitOf)
                    }
                    mintingCurrentLimitOf
                },
                {
                    fn pauseEmissions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <pauseEmissionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::pauseEmissions)
                    }
                    pauseEmissions
                },
                {
                    fn EMISSIONS_SUPPLY(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <EMISSIONS_SUPPLYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::EMISSIONS_SUPPLY)
                    }
                    EMISSIONS_SUPPLY
                },
                {
                    fn authorizedBridges(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <authorizedBridgesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::authorizedBridges)
                    }
                    authorizedBridges
                },
                {
                    fn numCheckpoints(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <numCheckpointsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::numCheckpoints)
                    }
                    numCheckpoints
                },
                {
                    fn balanceOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <balanceOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::balanceOf)
                    }
                    balanceOf
                },
                {
                    fn isBridge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <isBridgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::isBridge)
                    }
                    isBridge
                },
                {
                    fn currentEpoch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <currentEpochCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::currentEpoch)
                    }
                    currentEpoch
                },
                {
                    fn getBridgeInfo(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getBridgeInfoCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getBridgeInfo)
                    }
                    getBridgeInfo
                },
                {
                    fn nonces(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <noncesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::nonces)
                    }
                    nonces
                },
                {
                    fn pause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <pauseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::pause)
                    }
                    pause
                },
                {
                    fn eip712Domain(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <eip712DomainCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::eip712Domain)
                    }
                    eip712Domain
                },
                {
                    fn getPastTotalSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getPastTotalSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getPastTotalSupply)
                    }
                    getPastTotalSupply
                },
                {
                    fn TOTAL_SUPPLY(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::TOTAL_SUPPLY)
                    }
                    TOTAL_SUPPLY
                },
                {
                    fn hasRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn clock(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <clockCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::clock)
                    }
                    clock
                },
                {
                    fn symbol(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <symbolCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::symbol)
                    }
                    symbol
                },
                {
                    fn BRIDGE_LIMIT_DURATION(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <BRIDGE_LIMIT_DURATIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::BRIDGE_LIMIT_DURATION)
                    }
                    BRIDGE_LIMIT_DURATION
                },
                {
                    fn burningCurrentLimitOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <burningCurrentLimitOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::burningCurrentLimitOf)
                    }
                    burningCurrentLimitOf
                },
                {
                    fn getVotes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getVotesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getVotes)
                    }
                    getVotes
                },
                {
                    fn INITIAL_MINT_SUPPLY(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::INITIAL_MINT_SUPPLY)
                    }
                    INITIAL_MINT_SUPPLY
                },
                {
                    fn burn(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <burnCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::burn)
                    }
                    burn
                },
                {
                    fn setLimits(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <setLimitsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::setLimits)
                    }
                    setLimits
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn bridgeProxy(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <bridgeProxyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::bridgeProxy)
                    }
                    bridgeProxy
                },
                {
                    fn emissionsEnded(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <emissionsEndedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::emissionsEnded)
                    }
                    emissionsEnded
                },
                {
                    fn setBridgeProxy(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <setBridgeProxyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::setBridgeProxy)
                    }
                    setBridgeProxy
                },
                {
                    fn getNextEmissionTime(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getNextEmissionTimeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getNextEmissionTime)
                    }
                    getNextEmissionTime
                },
                {
                    fn EPOCH_DURATION(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::EPOCH_DURATION)
                    }
                    EPOCH_DURATION
                },
                {
                    fn transfer(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <transferCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::transfer)
                    }
                    transfer
                },
                {
                    fn PRECISION_MULTIPLIER(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <PRECISION_MULTIPLIERCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::PRECISION_MULTIPLIER)
                    }
                    PRECISION_MULTIPLIER
                },
                {
                    fn getEmissionSchedule(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getEmissionScheduleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getEmissionSchedule)
                    }
                    getEmissionSchedule
                },
                {
                    fn getPastVotingPower(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getPastVotingPowerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getPastVotingPower)
                    }
                    getPastVotingPower
                },
                {
                    fn getCurrentEpochInfo(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getCurrentEpochInfo)
                    }
                    getCurrentEpochInfo
                },
                {
                    fn getVotingPower(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getVotingPowerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getVotingPower)
                    }
                    getVotingPower
                },
                {
                    fn getCurrentTotalSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <getCurrentTotalSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::getCurrentTotalSupply)
                    }
                    getCurrentTotalSupply
                },
                {
                    fn burningMaxLimitOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <burningMaxLimitOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::burningMaxLimitOf)
                    }
                    burningMaxLimitOf
                },
                {
                    fn delegateBySig(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <delegateBySigCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::delegateBySig)
                    }
                    delegateBySig
                },
                {
                    fn permit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <permitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::permit)
                    }
                    permit
                },
                {
                    fn revokeRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn allowance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <allowanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::allowance)
                    }
                    allowance
                },
                {
                    fn EMISSIONS_MANAGER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::EMISSIONS_MANAGER_ROLE)
                    }
                    EMISSIONS_MANAGER_ROLE
                },
                {
                    fn PAUSER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <PAUSER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::PAUSER_ROLE)
                    }
                    PAUSER_ROLE
                },
                {
                    fn checkpoints(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <checkpointsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::checkpoints)
                    }
                    checkpoints
                },
                {
                    fn totalEmissionsMinted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <totalEmissionsMintedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::totalEmissionsMinted)
                    }
                    totalEmissionsMinted
                },
                {
                    fn BRIDGE_MANAGER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCalls> {
                        <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCalls::BRIDGE_MANAGER_ROLE)
                    }
                    BRIDGE_MANAGER_ROLE
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::BRIDGE_LIMIT_DURATION(inner) => {
                    <BRIDGE_LIMIT_DURATIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BRIDGE_MANAGER_ROLE(inner) => {
                    <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CLOCK_MODE(inner) => {
                    <CLOCK_MODECall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DOMAIN_SEPARATOR(inner) => {
                    <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSIONS_MANAGER_ROLE(inner) => {
                    <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSIONS_SUPPLY(inner) => {
                    <EMISSIONS_SUPPLYCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSION_BUFFER_TIME(inner) => {
                    <EMISSION_BUFFER_TIMECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EPOCH_DURATION(inner) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::INITIAL_MINT_SUPPLY(inner) => {
                    <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PAUSER_ROLE(inner) => {
                    <PAUSER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PRECISION_MULTIPLIER(inner) => {
                    <PRECISION_MULTIPLIERCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TOTAL_EPOCHS(inner) => {
                    <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TOTAL_SUPPLY(inner) => {
                    <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::allowance(inner) => {
                    <allowanceCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::approve(inner) => {
                    <approveCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::authorizedBridges(inner) => {
                    <authorizedBridgesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::bridgeData(inner) => {
                    <bridgeDataCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::bridgeLimits(inner) => {
                    <bridgeLimitsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bridgeProxy(inner) => {
                    <bridgeProxyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::burn(inner) => {
                    <burnCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::burningCurrentLimitOf(inner) => {
                    <burningCurrentLimitOfCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::burningMaxLimitOf(inner) => {
                    <burningMaxLimitOfCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::checkpoints(inner) => {
                    <checkpointsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::clock(inner) => {
                    <clockCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::currentEpoch(inner) => {
                    <currentEpochCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::decimals(inner) => {
                    <decimalsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::delegate(inner) => {
                    <delegateCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::delegateBySig(inner) => {
                    <delegateBySigCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::delegates(inner) => {
                    <delegatesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::eip712Domain(inner) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionSchedule(inner) => {
                    <emissionScheduleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionsActive(inner) => {
                    <emissionsActiveCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionsEnded(inner) => {
                    <emissionsEndedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionsStartTime(inner) => {
                    <emissionsStartTimeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionsStarted(inner) => {
                    <emissionsStartedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBridgeConfiguration(inner) => {
                    <getBridgeConfigurationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBridgeInfo(inner) => {
                    <getBridgeInfoCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBridgeUtilization(inner) => {
                    <getBridgeUtilizationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getCurrentEpochInfo(inner) => {
                    <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getCurrentTotalSupply(inner) => {
                    <getCurrentTotalSupplyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getEmissionSchedule(inner) => {
                    <getEmissionScheduleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getNextEmissionTime(inner) => {
                    <getNextEmissionTimeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPastTotalSupply(inner) => {
                    <getPastTotalSupplyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPastVotes(inner) => {
                    <getPastVotesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPastVotingPower(inner) => {
                    <getPastVotingPowerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRemainingEmissions(inner) => {
                    <getRemainingEmissionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getVotes(inner) => {
                    <getVotesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getVotingPower(inner) => {
                    <getVotingPowerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isBridge(inner) => {
                    <isBridgeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::mint(inner) => {
                    <mintCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::mintEmission(inner) => {
                    <mintEmissionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::mintingCurrentLimitOf(inner) => {
                    <mintingCurrentLimitOfCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::mintingMaxLimitOf(inner) => {
                    <mintingMaxLimitOfCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::name(inner) => {
                    <nameCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::nonces(inner) => {
                    <noncesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::numCheckpoints(inner) => {
                    <numCheckpointsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::pauseEmissions(inner) => {
                    <pauseEmissionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::permit(inner) => {
                    <permitCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::resumeEmissions(inner) => {
                    <resumeEmissionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setBridgeData(inner) => {
                    <setBridgeDataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setBridgeProxy(inner) => {
                    <setBridgeProxyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setLimits(inner) => {
                    <setLimitsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::startEmissions(inner) => {
                    <startEmissionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::symbol(inner) => {
                    <symbolCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::totalEmissionsMinted(inner) => {
                    <totalEmissionsMintedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::totalSupply(inner) => {
                    <totalSupplyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transfer(inner) => {
                    <transferCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::transferFrom(inner) => {
                    <transferFromCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::BRIDGE_LIMIT_DURATION(inner) => {
                    <BRIDGE_LIMIT_DURATIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BRIDGE_MANAGER_ROLE(inner) => {
                    <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CLOCK_MODE(inner) => {
                    <CLOCK_MODECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DOMAIN_SEPARATOR(inner) => {
                    <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSIONS_MANAGER_ROLE(inner) => {
                    <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSIONS_SUPPLY(inner) => {
                    <EMISSIONS_SUPPLYCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSION_BUFFER_TIME(inner) => {
                    <EMISSION_BUFFER_TIMECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EPOCH_DURATION(inner) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::INITIAL_MINT_SUPPLY(inner) => {
                    <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PAUSER_ROLE(inner) => {
                    <PAUSER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PRECISION_MULTIPLIER(inner) => {
                    <PRECISION_MULTIPLIERCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TOTAL_EPOCHS(inner) => {
                    <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TOTAL_SUPPLY(inner) => {
                    <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::allowance(inner) => {
                    <allowanceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::approve(inner) => {
                    <approveCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::authorizedBridges(inner) => {
                    <authorizedBridgesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeData(inner) => {
                    <bridgeDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeLimits(inner) => {
                    <bridgeLimitsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeProxy(inner) => {
                    <bridgeProxyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::burn(inner) => {
                    <burnCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::burningCurrentLimitOf(inner) => {
                    <burningCurrentLimitOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::burningMaxLimitOf(inner) => {
                    <burningMaxLimitOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkpoints(inner) => {
                    <checkpointsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::clock(inner) => {
                    <clockCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::currentEpoch(inner) => {
                    <currentEpochCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::decimals(inner) => {
                    <decimalsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::delegate(inner) => {
                    <delegateCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::delegateBySig(inner) => {
                    <delegateBySigCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::delegates(inner) => {
                    <delegatesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::eip712Domain(inner) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionSchedule(inner) => {
                    <emissionScheduleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionsActive(inner) => {
                    <emissionsActiveCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionsEnded(inner) => {
                    <emissionsEndedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionsStartTime(inner) => {
                    <emissionsStartTimeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionsStarted(inner) => {
                    <emissionsStartedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBridgeConfiguration(inner) => {
                    <getBridgeConfigurationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBridgeInfo(inner) => {
                    <getBridgeInfoCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBridgeUtilization(inner) => {
                    <getBridgeUtilizationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getCurrentEpochInfo(inner) => {
                    <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getCurrentTotalSupply(inner) => {
                    <getCurrentTotalSupplyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getEmissionSchedule(inner) => {
                    <getEmissionScheduleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getNextEmissionTime(inner) => {
                    <getNextEmissionTimeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPastTotalSupply(inner) => {
                    <getPastTotalSupplyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPastVotes(inner) => {
                    <getPastVotesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPastVotingPower(inner) => {
                    <getPastVotingPowerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRemainingEmissions(inner) => {
                    <getRemainingEmissionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getVotes(inner) => {
                    <getVotesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getVotingPower(inner) => {
                    <getVotingPowerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::isBridge(inner) => {
                    <isBridgeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::mint(inner) => {
                    <mintCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::mintEmission(inner) => {
                    <mintEmissionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::mintingCurrentLimitOf(inner) => {
                    <mintingCurrentLimitOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::mintingMaxLimitOf(inner) => {
                    <mintingMaxLimitOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::name(inner) => {
                    <nameCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::nonces(inner) => {
                    <noncesCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::numCheckpoints(inner) => {
                    <numCheckpointsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pauseEmissions(inner) => {
                    <pauseEmissionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::permit(inner) => {
                    <permitCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::resumeEmissions(inner) => {
                    <resumeEmissionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBridgeData(inner) => {
                    <setBridgeDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBridgeProxy(inner) => {
                    <setBridgeProxyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setLimits(inner) => {
                    <setLimitsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::startEmissions(inner) => {
                    <startEmissionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::symbol(inner) => {
                    <symbolCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::totalEmissionsMinted(inner) => {
                    <totalEmissionsMintedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::totalSupply(inner) => {
                    <totalSupplyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transfer(inner) => {
                    <transferCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferFrom(inner) => {
                    <transferFromCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
            }
        }
    }
    ///Container for all the [`SyndicateToken`](self) custom errors.
    pub enum SyndicateTokenErrors {
        #[allow(missing_docs)]
        AccessControlBadConfirmation(AccessControlBadConfirmation),
        #[allow(missing_docs)]
        AccessControlUnauthorizedAccount(AccessControlUnauthorizedAccount),
        #[allow(missing_docs)]
        AllEmissionsCompleted(AllEmissionsCompleted),
        #[allow(missing_docs)]
        BridgeNotAuthorized(BridgeNotAuthorized),
        #[allow(missing_docs)]
        BridgeNotConfigured(BridgeNotConfigured),
        #[allow(missing_docs)]
        CheckpointUnorderedInsertion(CheckpointUnorderedInsertion),
        #[allow(missing_docs)]
        ECDSAInvalidSignature(ECDSAInvalidSignature),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureLength(ECDSAInvalidSignatureLength),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureS(ECDSAInvalidSignatureS),
        #[allow(missing_docs)]
        ERC20ExceededSafeSupply(ERC20ExceededSafeSupply),
        #[allow(missing_docs)]
        ERC20InsufficientAllowance(ERC20InsufficientAllowance),
        #[allow(missing_docs)]
        ERC20InsufficientBalance(ERC20InsufficientBalance),
        #[allow(missing_docs)]
        ERC20InvalidApprover(ERC20InvalidApprover),
        #[allow(missing_docs)]
        ERC20InvalidReceiver(ERC20InvalidReceiver),
        #[allow(missing_docs)]
        ERC20InvalidSender(ERC20InvalidSender),
        #[allow(missing_docs)]
        ERC20InvalidSpender(ERC20InvalidSpender),
        #[allow(missing_docs)]
        ERC2612ExpiredSignature(ERC2612ExpiredSignature),
        #[allow(missing_docs)]
        ERC2612InvalidSigner(ERC2612InvalidSigner),
        #[allow(missing_docs)]
        ERC5805FutureLookup(ERC5805FutureLookup),
        #[allow(missing_docs)]
        ERC6372InconsistentClock(ERC6372InconsistentClock),
        #[allow(missing_docs)]
        EmissionTooEarly(EmissionTooEarly),
        #[allow(missing_docs)]
        EmissionsAlreadyStarted(EmissionsAlreadyStarted),
        #[allow(missing_docs)]
        EmissionsNotActive(EmissionsNotActive),
        #[allow(missing_docs)]
        EmissionsNotStarted(EmissionsNotStarted),
        #[allow(missing_docs)]
        EnforcedPause(EnforcedPause),
        #[allow(missing_docs)]
        ExceedsEmissionsSupply(ExceedsEmissionsSupply),
        #[allow(missing_docs)]
        ExpectedPause(ExpectedPause),
        #[allow(missing_docs)]
        InsufficientLimit(InsufficientLimit),
        #[allow(missing_docs)]
        InvalidAccountNonce(InvalidAccountNonce),
        #[allow(missing_docs)]
        InvalidShortString(InvalidShortString),
        #[allow(missing_docs)]
        ReentrancyGuardReentrantCall(ReentrancyGuardReentrantCall),
        #[allow(missing_docs)]
        SafeCastOverflowedUintDowncast(SafeCastOverflowedUintDowncast),
        #[allow(missing_docs)]
        StringTooLong(StringTooLong),
        #[allow(missing_docs)]
        VotesExpiredSignature(VotesExpiredSignature),
        #[allow(missing_docs)]
        ZeroAddress(ZeroAddress),
        #[allow(missing_docs)]
        ZeroAmount(ZeroAmount),
    }
    #[automatically_derived]
    impl SyndicateTokenErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [28u8, 177u8, 93u8, 38u8],
            [31u8, 42u8, 32u8, 5u8],
            [35u8, 6u8, 78u8, 189u8],
            [37u8, 32u8, 96u8, 29u8],
            [48u8, 90u8, 39u8, 169u8],
            [61u8, 83u8, 199u8, 83u8],
            [62u8, 229u8, 174u8, 181u8],
            [69u8, 85u8, 137u8, 44u8],
            [70u8, 131u8, 175u8, 14u8],
            [75u8, 128u8, 14u8, 70u8],
            [98u8, 121u8, 19u8, 2u8],
            [102u8, 151u8, 178u8, 50u8],
            [102u8, 191u8, 38u8, 116u8],
            [109u8, 252u8, 198u8, 80u8],
            [111u8, 240u8, 113u8, 64u8],
            [113u8, 210u8, 123u8, 122u8],
            [114u8, 86u8, 123u8, 100u8],
            [117u8, 45u8, 136u8, 192u8],
            [118u8, 20u8, 145u8, 122u8],
            [136u8, 46u8, 236u8, 18u8],
            [141u8, 252u8, 32u8, 43u8],
            [143u8, 152u8, 64u8, 65u8],
            [148u8, 40u8, 13u8, 98u8],
            [150u8, 198u8, 253u8, 30u8],
            [179u8, 81u8, 43u8, 12u8],
            [215u8, 139u8, 206u8, 12u8],
            [217u8, 46u8, 35u8, 61u8],
            [217u8, 60u8, 6u8, 101u8],
            [226u8, 81u8, 125u8, 63u8],
            [228u8, 80u8, 211u8, 140u8],
            [230u8, 2u8, 223u8, 5u8],
            [236u8, 68u8, 47u8, 5u8],
            [236u8, 211u8, 248u8, 30u8],
            [246u8, 69u8, 238u8, 223u8],
            [251u8, 143u8, 65u8, 178u8],
            [252u8, 230u8, 152u8, 247u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndicateTokenErrors {
        const NAME: &'static str = "SyndicateTokenErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 36usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AccessControlBadConfirmation(_) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AccessControlUnauthorizedAccount(_) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AllEmissionsCompleted(_) => {
                    <AllEmissionsCompleted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BridgeNotAuthorized(_) => {
                    <BridgeNotAuthorized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BridgeNotConfigured(_) => {
                    <BridgeNotConfigured as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CheckpointUnorderedInsertion(_) => {
                    <CheckpointUnorderedInsertion as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignature(_) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureLength(_) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureS(_) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20ExceededSafeSupply(_) => {
                    <ERC20ExceededSafeSupply as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InsufficientAllowance(_) => {
                    <ERC20InsufficientAllowance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InsufficientBalance(_) => {
                    <ERC20InsufficientBalance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidApprover(_) => {
                    <ERC20InvalidApprover as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidReceiver(_) => {
                    <ERC20InvalidReceiver as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidSender(_) => {
                    <ERC20InvalidSender as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidSpender(_) => {
                    <ERC20InvalidSpender as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC2612ExpiredSignature(_) => {
                    <ERC2612ExpiredSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC2612InvalidSigner(_) => {
                    <ERC2612InvalidSigner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC5805FutureLookup(_) => {
                    <ERC5805FutureLookup as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC6372InconsistentClock(_) => {
                    <ERC6372InconsistentClock as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmissionTooEarly(_) => {
                    <EmissionTooEarly as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmissionsAlreadyStarted(_) => {
                    <EmissionsAlreadyStarted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmissionsNotActive(_) => {
                    <EmissionsNotActive as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmissionsNotStarted(_) => {
                    <EmissionsNotStarted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EnforcedPause(_) => {
                    <EnforcedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ExceedsEmissionsSupply(_) => {
                    <ExceedsEmissionsSupply as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ExpectedPause(_) => {
                    <ExpectedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientLimit(_) => {
                    <InsufficientLimit as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidAccountNonce(_) => {
                    <InvalidAccountNonce as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidShortString(_) => {
                    <InvalidShortString as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ReentrancyGuardReentrantCall(_) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SafeCastOverflowedUintDowncast(_) => {
                    <SafeCastOverflowedUintDowncast as alloy_sol_types::SolError>::SELECTOR
                }
                Self::StringTooLong(_) => {
                    <StringTooLong as alloy_sol_types::SolError>::SELECTOR
                }
                Self::VotesExpiredSignature(_) => {
                    <VotesExpiredSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAddress(_) => {
                    <ZeroAddress as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAmount(_) => {
                    <ZeroAmount as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<SyndicateTokenErrors>] = &[
                {
                    fn ERC20ExceededSafeSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20ExceededSafeSupply as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20ExceededSafeSupply)
                    }
                    ERC20ExceededSafeSupply
                },
                {
                    fn ZeroAmount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ZeroAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ZeroAmount)
                    }
                    ZeroAmount
                },
                {
                    fn ExceedsEmissionsSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ExceedsEmissionsSupply as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ExceedsEmissionsSupply)
                    }
                    ExceedsEmissionsSupply
                },
                {
                    fn CheckpointUnorderedInsertion(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <CheckpointUnorderedInsertion as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::CheckpointUnorderedInsertion)
                    }
                    CheckpointUnorderedInsertion
                },
                {
                    fn StringTooLong(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <StringTooLong as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::StringTooLong)
                    }
                    StringTooLong
                },
                {
                    fn EmissionTooEarly(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <EmissionTooEarly as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::EmissionTooEarly)
                    }
                    EmissionTooEarly
                },
                {
                    fn ReentrancyGuardReentrantCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ReentrancyGuardReentrantCall)
                    }
                    ReentrancyGuardReentrantCall
                },
                {
                    fn AllEmissionsCompleted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <AllEmissionsCompleted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::AllEmissionsCompleted)
                    }
                    AllEmissionsCompleted
                },
                {
                    fn VotesExpiredSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <VotesExpiredSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::VotesExpiredSignature)
                    }
                    VotesExpiredSignature
                },
                {
                    fn ERC2612InvalidSigner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC2612InvalidSigner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC2612InvalidSigner)
                    }
                    ERC2612InvalidSigner
                },
                {
                    fn ERC2612ExpiredSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC2612ExpiredSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC2612ExpiredSignature)
                    }
                    ERC2612ExpiredSignature
                },
                {
                    fn AccessControlBadConfirmation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::AccessControlBadConfirmation)
                    }
                    AccessControlBadConfirmation
                },
                {
                    fn EmissionsNotActive(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <EmissionsNotActive as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::EmissionsNotActive)
                    }
                    EmissionsNotActive
                },
                {
                    fn SafeCastOverflowedUintDowncast(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <SafeCastOverflowedUintDowncast as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::SafeCastOverflowedUintDowncast)
                    }
                    SafeCastOverflowedUintDowncast
                },
                {
                    fn ERC6372InconsistentClock(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC6372InconsistentClock as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC6372InconsistentClock)
                    }
                    ERC6372InconsistentClock
                },
                {
                    fn EmissionsAlreadyStarted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <EmissionsAlreadyStarted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::EmissionsAlreadyStarted)
                    }
                    EmissionsAlreadyStarted
                },
                {
                    fn InsufficientLimit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <InsufficientLimit as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::InsufficientLimit)
                    }
                    InsufficientLimit
                },
                {
                    fn InvalidAccountNonce(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <InvalidAccountNonce as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::InvalidAccountNonce)
                    }
                    InvalidAccountNonce
                },
                {
                    fn BridgeNotConfigured(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <BridgeNotConfigured as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::BridgeNotConfigured)
                    }
                    BridgeNotConfigured
                },
                {
                    fn BridgeNotAuthorized(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <BridgeNotAuthorized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::BridgeNotAuthorized)
                    }
                    BridgeNotAuthorized
                },
                {
                    fn ExpectedPause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ExpectedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ExpectedPause)
                    }
                    ExpectedPause
                },
                {
                    fn EmissionsNotStarted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <EmissionsNotStarted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::EmissionsNotStarted)
                    }
                    EmissionsNotStarted
                },
                {
                    fn ERC20InvalidSpender(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InvalidSpender as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InvalidSpender)
                    }
                    ERC20InvalidSpender
                },
                {
                    fn ERC20InvalidSender(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InvalidSender as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InvalidSender)
                    }
                    ERC20InvalidSender
                },
                {
                    fn InvalidShortString(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <InvalidShortString as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::InvalidShortString)
                    }
                    InvalidShortString
                },
                {
                    fn ECDSAInvalidSignatureS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ECDSAInvalidSignatureS)
                    }
                    ECDSAInvalidSignatureS
                },
                {
                    fn ZeroAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ZeroAddress as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ZeroAddress)
                    }
                    ZeroAddress
                },
                {
                    fn EnforcedPause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <EnforcedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::EnforcedPause)
                    }
                    EnforcedPause
                },
                {
                    fn AccessControlUnauthorizedAccount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::AccessControlUnauthorizedAccount)
                    }
                    AccessControlUnauthorizedAccount
                },
                {
                    fn ERC20InsufficientBalance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InsufficientBalance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InsufficientBalance)
                    }
                    ERC20InsufficientBalance
                },
                {
                    fn ERC20InvalidApprover(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InvalidApprover as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InvalidApprover)
                    }
                    ERC20InvalidApprover
                },
                {
                    fn ERC20InvalidReceiver(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InvalidReceiver as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InvalidReceiver)
                    }
                    ERC20InvalidReceiver
                },
                {
                    fn ERC5805FutureLookup(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC5805FutureLookup as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC5805FutureLookup)
                    }
                    ERC5805FutureLookup
                },
                {
                    fn ECDSAInvalidSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ECDSAInvalidSignature)
                    }
                    ECDSAInvalidSignature
                },
                {
                    fn ERC20InsufficientAllowance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ERC20InsufficientAllowance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ERC20InsufficientAllowance)
                    }
                    ERC20InsufficientAllowance
                },
                {
                    fn ECDSAInvalidSignatureLength(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenErrors> {
                        <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenErrors::ECDSAInvalidSignatureLength)
                    }
                    ECDSAInvalidSignatureLength
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AllEmissionsCompleted(inner) => {
                    <AllEmissionsCompleted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BridgeNotAuthorized(inner) => {
                    <BridgeNotAuthorized as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BridgeNotConfigured(inner) => {
                    <BridgeNotConfigured as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CheckpointUnorderedInsertion(inner) => {
                    <CheckpointUnorderedInsertion as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20ExceededSafeSupply(inner) => {
                    <ERC20ExceededSafeSupply as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InsufficientAllowance(inner) => {
                    <ERC20InsufficientAllowance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InsufficientBalance(inner) => {
                    <ERC20InsufficientBalance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidApprover(inner) => {
                    <ERC20InvalidApprover as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidReceiver(inner) => {
                    <ERC20InvalidReceiver as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidSender(inner) => {
                    <ERC20InvalidSender as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidSpender(inner) => {
                    <ERC20InvalidSpender as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC2612ExpiredSignature(inner) => {
                    <ERC2612ExpiredSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC2612InvalidSigner(inner) => {
                    <ERC2612InvalidSigner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC5805FutureLookup(inner) => {
                    <ERC5805FutureLookup as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC6372InconsistentClock(inner) => {
                    <ERC6372InconsistentClock as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmissionTooEarly(inner) => {
                    <EmissionTooEarly as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmissionsAlreadyStarted(inner) => {
                    <EmissionsAlreadyStarted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmissionsNotActive(inner) => {
                    <EmissionsNotActive as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmissionsNotStarted(inner) => {
                    <EmissionsNotStarted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ExceedsEmissionsSupply(inner) => {
                    <ExceedsEmissionsSupply as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InsufficientLimit(inner) => {
                    <InsufficientLimit as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidAccountNonce(inner) => {
                    <InvalidAccountNonce as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidShortString(inner) => {
                    <InvalidShortString as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ReentrancyGuardReentrantCall(inner) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SafeCastOverflowedUintDowncast(inner) => {
                    <SafeCastOverflowedUintDowncast as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::StringTooLong(inner) => {
                    <StringTooLong as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::VotesExpiredSignature(inner) => {
                    <VotesExpiredSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ZeroAmount(inner) => {
                    <ZeroAmount as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AllEmissionsCompleted(inner) => {
                    <AllEmissionsCompleted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BridgeNotAuthorized(inner) => {
                    <BridgeNotAuthorized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BridgeNotConfigured(inner) => {
                    <BridgeNotConfigured as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CheckpointUnorderedInsertion(inner) => {
                    <CheckpointUnorderedInsertion as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20ExceededSafeSupply(inner) => {
                    <ERC20ExceededSafeSupply as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InsufficientAllowance(inner) => {
                    <ERC20InsufficientAllowance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InsufficientBalance(inner) => {
                    <ERC20InsufficientBalance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidApprover(inner) => {
                    <ERC20InvalidApprover as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidReceiver(inner) => {
                    <ERC20InvalidReceiver as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidSender(inner) => {
                    <ERC20InvalidSender as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidSpender(inner) => {
                    <ERC20InvalidSpender as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC2612ExpiredSignature(inner) => {
                    <ERC2612ExpiredSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC2612InvalidSigner(inner) => {
                    <ERC2612InvalidSigner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC5805FutureLookup(inner) => {
                    <ERC5805FutureLookup as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC6372InconsistentClock(inner) => {
                    <ERC6372InconsistentClock as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmissionTooEarly(inner) => {
                    <EmissionTooEarly as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmissionsAlreadyStarted(inner) => {
                    <EmissionsAlreadyStarted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmissionsNotActive(inner) => {
                    <EmissionsNotActive as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmissionsNotStarted(inner) => {
                    <EmissionsNotStarted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ExceedsEmissionsSupply(inner) => {
                    <ExceedsEmissionsSupply as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientLimit(inner) => {
                    <InsufficientLimit as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidAccountNonce(inner) => {
                    <InvalidAccountNonce as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidShortString(inner) => {
                    <InvalidShortString as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ReentrancyGuardReentrantCall(inner) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SafeCastOverflowedUintDowncast(inner) => {
                    <SafeCastOverflowedUintDowncast as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::StringTooLong(inner) => {
                    <StringTooLong as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::VotesExpiredSignature(inner) => {
                    <VotesExpiredSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAmount(inner) => {
                    <ZeroAmount as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
            }
        }
    }
    ///Container for all the [`SyndicateToken`](self) events.
    pub enum SyndicateTokenEvents {
        #[allow(missing_docs)]
        Approval(Approval),
        #[allow(missing_docs)]
        BridgeAuthorized(BridgeAuthorized),
        #[allow(missing_docs)]
        BridgeDataUpdated(BridgeDataUpdated),
        #[allow(missing_docs)]
        BridgeDeauthorized(BridgeDeauthorized),
        #[allow(missing_docs)]
        BridgeLimitsSet(BridgeLimitsSet),
        #[allow(missing_docs)]
        BridgeProxyUpdated(BridgeProxyUpdated),
        #[allow(missing_docs)]
        DelegateChanged(DelegateChanged),
        #[allow(missing_docs)]
        DelegateVotesChanged(DelegateVotesChanged),
        #[allow(missing_docs)]
        EIP712DomainChanged(EIP712DomainChanged),
        #[allow(missing_docs)]
        EmissionMinted(EmissionMinted),
        #[allow(missing_docs)]
        EmissionsPaused(EmissionsPaused),
        #[allow(missing_docs)]
        EmissionsResumed(EmissionsResumed),
        #[allow(missing_docs)]
        EmissionsStarted(EmissionsStarted),
        #[allow(missing_docs)]
        Paused(Paused),
        #[allow(missing_docs)]
        RoleAdminChanged(RoleAdminChanged),
        #[allow(missing_docs)]
        RoleGranted(RoleGranted),
        #[allow(missing_docs)]
        RoleRevoked(RoleRevoked),
        #[allow(missing_docs)]
        Transfer(Transfer),
        #[allow(missing_docs)]
        Unpaused(Unpaused),
    }
    #[automatically_derived]
    impl SyndicateTokenEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                2u8,
                194u8,
                240u8,
                186u8,
                21u8,
                176u8,
                63u8,
                136u8,
                177u8,
                143u8,
                72u8,
                50u8,
                96u8,
                154u8,
                24u8,
                207u8,
                53u8,
                252u8,
                107u8,
                63u8,
                69u8,
                70u8,
                169u8,
                153u8,
                32u8,
                118u8,
                215u8,
                69u8,
                61u8,
                19u8,
                52u8,
                168u8,
            ],
            [
                7u8,
                1u8,
                91u8,
                106u8,
                159u8,
                5u8,
                145u8,
                49u8,
                72u8,
                253u8,
                95u8,
                173u8,
                223u8,
                42u8,
                204u8,
                151u8,
                8u8,
                243u8,
                5u8,
                147u8,
                127u8,
                48u8,
                114u8,
                202u8,
                43u8,
                75u8,
                70u8,
                250u8,
                165u8,
                208u8,
                137u8,
                139u8,
            ],
            [
                10u8,
                99u8,
                135u8,
                201u8,
                234u8,
                54u8,
                40u8,
                184u8,
                138u8,
                99u8,
                59u8,
                180u8,
                243u8,
                177u8,
                81u8,
                119u8,
                15u8,
                112u8,
                8u8,
                81u8,
                23u8,
                161u8,
                95u8,
                155u8,
                243u8,
                120u8,
                124u8,
                218u8,
                83u8,
                241u8,
                61u8,
                49u8,
            ],
            [
                17u8,
                148u8,
                176u8,
                52u8,
                207u8,
                169u8,
                171u8,
                88u8,
                7u8,
                73u8,
                74u8,
                29u8,
                92u8,
                102u8,
                125u8,
                139u8,
                14u8,
                110u8,
                151u8,
                243u8,
                136u8,
                136u8,
                116u8,
                42u8,
                163u8,
                135u8,
                26u8,
                50u8,
                32u8,
                52u8,
                17u8,
                96u8,
            ],
            [
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ],
            [
                49u8,
                52u8,
                232u8,
                162u8,
                230u8,
                217u8,
                126u8,
                146u8,
                154u8,
                126u8,
                84u8,
                1u8,
                30u8,
                165u8,
                72u8,
                93u8,
                125u8,
                25u8,
                109u8,
                213u8,
                240u8,
                186u8,
                77u8,
                78u8,
                249u8,
                88u8,
                3u8,
                232u8,
                227u8,
                252u8,
                37u8,
                127u8,
            ],
            [
                52u8,
                183u8,
                61u8,
                12u8,
                150u8,
                233u8,
                255u8,
                77u8,
                83u8,
                17u8,
                67u8,
                72u8,
                23u8,
                200u8,
                236u8,
                201u8,
                48u8,
                231u8,
                210u8,
                120u8,
                44u8,
                91u8,
                222u8,
                46u8,
                121u8,
                220u8,
                68u8,
                176u8,
                89u8,
                103u8,
                85u8,
                187u8,
            ],
            [
                74u8,
                121u8,
                42u8,
                11u8,
                228u8,
                43u8,
                86u8,
                114u8,
                250u8,
                164u8,
                1u8,
                41u8,
                252u8,
                100u8,
                105u8,
                7u8,
                36u8,
                144u8,
                119u8,
                92u8,
                168u8,
                211u8,
                195u8,
                78u8,
                133u8,
                45u8,
                77u8,
                85u8,
                211u8,
                167u8,
                53u8,
                169u8,
            ],
            [
                93u8,
                185u8,
                238u8,
                10u8,
                73u8,
                91u8,
                242u8,
                230u8,
                255u8,
                156u8,
                145u8,
                167u8,
                131u8,
                76u8,
                27u8,
                164u8,
                253u8,
                210u8,
                68u8,
                165u8,
                232u8,
                170u8,
                78u8,
                83u8,
                123u8,
                211u8,
                138u8,
                234u8,
                228u8,
                176u8,
                115u8,
                170u8,
            ],
            [
                98u8,
                231u8,
                140u8,
                234u8,
                1u8,
                190u8,
                227u8,
                32u8,
                205u8,
                78u8,
                66u8,
                2u8,
                112u8,
                181u8,
                234u8,
                116u8,
                0u8,
                13u8,
                17u8,
                176u8,
                201u8,
                247u8,
                71u8,
                84u8,
                235u8,
                219u8,
                252u8,
                84u8,
                75u8,
                5u8,
                162u8,
                88u8,
            ],
            [
                108u8,
                242u8,
                132u8,
                57u8,
                162u8,
                218u8,
                171u8,
                27u8,
                38u8,
                80u8,
                151u8,
                34u8,
                114u8,
                18u8,
                165u8,
                183u8,
                30u8,
                10u8,
                118u8,
                249u8,
                237u8,
                133u8,
                227u8,
                248u8,
                21u8,
                181u8,
                166u8,
                195u8,
                226u8,
                24u8,
                235u8,
                127u8,
            ],
            [
                115u8,
                165u8,
                252u8,
                96u8,
                170u8,
                254u8,
                236u8,
                143u8,
                19u8,
                154u8,
                242u8,
                45u8,
                152u8,
                230u8,
                33u8,
                64u8,
                226u8,
                206u8,
                145u8,
                77u8,
                31u8,
                21u8,
                92u8,
                105u8,
                43u8,
                66u8,
                119u8,
                87u8,
                195u8,
                228u8,
                1u8,
                76u8,
            ],
            [
                140u8,
                91u8,
                225u8,
                229u8,
                235u8,
                236u8,
                125u8,
                91u8,
                209u8,
                79u8,
                113u8,
                66u8,
                125u8,
                30u8,
                132u8,
                243u8,
                221u8,
                3u8,
                20u8,
                192u8,
                247u8,
                178u8,
                41u8,
                30u8,
                91u8,
                32u8,
                10u8,
                200u8,
                199u8,
                195u8,
                185u8,
                37u8,
            ],
            [
                170u8,
                128u8,
                125u8,
                10u8,
                191u8,
                48u8,
                217u8,
                25u8,
                104u8,
                199u8,
                71u8,
                140u8,
                102u8,
                182u8,
                216u8,
                37u8,
                33u8,
                161u8,
                6u8,
                175u8,
                19u8,
                237u8,
                160u8,
                54u8,
                226u8,
                3u8,
                109u8,
                169u8,
                175u8,
                22u8,
                137u8,
                88u8,
            ],
            [
                185u8,
                162u8,
                8u8,
                132u8,
                38u8,
                240u8,
                59u8,
                48u8,
                168u8,
                28u8,
                6u8,
                66u8,
                128u8,
                148u8,
                251u8,
                250u8,
                158u8,
                38u8,
                146u8,
                115u8,
                155u8,
                50u8,
                65u8,
                175u8,
                107u8,
                154u8,
                177u8,
                218u8,
                75u8,
                85u8,
                70u8,
                190u8,
            ],
            [
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ],
            [
                221u8,
                242u8,
                82u8,
                173u8,
                27u8,
                226u8,
                200u8,
                155u8,
                105u8,
                194u8,
                176u8,
                104u8,
                252u8,
                55u8,
                141u8,
                170u8,
                149u8,
                43u8,
                167u8,
                241u8,
                99u8,
                196u8,
                161u8,
                22u8,
                40u8,
                245u8,
                90u8,
                77u8,
                245u8,
                35u8,
                179u8,
                239u8,
            ],
            [
                222u8,
                194u8,
                186u8,
                205u8,
                210u8,
                240u8,
                91u8,
                89u8,
                222u8,
                52u8,
                218u8,
                155u8,
                82u8,
                61u8,
                255u8,
                139u8,
                228u8,
                46u8,
                94u8,
                56u8,
                232u8,
                24u8,
                200u8,
                47u8,
                219u8,
                11u8,
                174u8,
                119u8,
                67u8,
                135u8,
                167u8,
                36u8,
            ],
            [
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for SyndicateTokenEvents {
        const NAME: &'static str = "SyndicateTokenEvents";
        const COUNT: usize = 19usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<Approval as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Approval as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Approval)
                }
                Some(<BridgeAuthorized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <BridgeAuthorized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeAuthorized)
                }
                Some(
                    <BridgeDataUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BridgeDataUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeDataUpdated)
                }
                Some(
                    <BridgeDeauthorized as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BridgeDeauthorized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeDeauthorized)
                }
                Some(<BridgeLimitsSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <BridgeLimitsSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeLimitsSet)
                }
                Some(
                    <BridgeProxyUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BridgeProxyUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeProxyUpdated)
                }
                Some(<DelegateChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <DelegateChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::DelegateChanged)
                }
                Some(
                    <DelegateVotesChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <DelegateVotesChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::DelegateVotesChanged)
                }
                Some(
                    <EIP712DomainChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <EIP712DomainChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EIP712DomainChanged)
                }
                Some(<EmissionMinted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EmissionMinted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EmissionMinted)
                }
                Some(<EmissionsPaused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EmissionsPaused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EmissionsPaused)
                }
                Some(<EmissionsResumed as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EmissionsResumed as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EmissionsResumed)
                }
                Some(<EmissionsStarted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EmissionsStarted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EmissionsStarted)
                }
                Some(<Paused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Paused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Paused)
                }
                Some(<RoleAdminChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleAdminChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleAdminChanged)
                }
                Some(<RoleGranted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleGranted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleGranted)
                }
                Some(<RoleRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleRevoked)
                }
                Some(<Transfer as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Transfer as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Transfer)
                }
                Some(<Unpaused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Unpaused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Unpaused)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for SyndicateTokenEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Approval(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeAuthorized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeDataUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeDeauthorized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeLimitsSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeProxyUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DelegateChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DelegateVotesChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EIP712DomainChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EmissionMinted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EmissionsPaused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EmissionsResumed(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EmissionsStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Transfer(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Approval(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeAuthorized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeDataUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeDeauthorized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeLimitsSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeProxyUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DelegateChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DelegateVotesChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EIP712DomainChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EmissionMinted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EmissionsPaused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EmissionsResumed(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EmissionsStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Transfer(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`SyndicateToken`](self) contract instance.

See the [wrapper's documentation](`SyndicateTokenInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> SyndicateTokenInstance<T, P, N> {
        SyndicateTokenInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        defaultAdmin: alloy::sol_types::private::Address,
        syndFoundationAddress: alloy::sol_types::private::Address,
        emissionsManager: alloy::sol_types::private::Address,
        pauser: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<SyndicateTokenInstance<T, P, N>>,
    > {
        SyndicateTokenInstance::<
            T,
            P,
            N,
        >::deploy(
            provider,
            defaultAdmin,
            syndFoundationAddress,
            emissionsManager,
            pauser,
        )
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        defaultAdmin: alloy::sol_types::private::Address,
        syndFoundationAddress: alloy::sol_types::private::Address,
        emissionsManager: alloy::sol_types::private::Address,
        pauser: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        SyndicateTokenInstance::<
            T,
            P,
            N,
        >::deploy_builder(
            provider,
            defaultAdmin,
            syndFoundationAddress,
            emissionsManager,
            pauser,
        )
    }
    /**A [`SyndicateToken`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`SyndicateToken`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct SyndicateTokenInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for SyndicateTokenInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("SyndicateTokenInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyndicateTokenInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`SyndicateToken`](self) contract instance.

See the [wrapper's documentation](`SyndicateTokenInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            defaultAdmin: alloy::sol_types::private::Address,
            syndFoundationAddress: alloy::sol_types::private::Address,
            emissionsManager: alloy::sol_types::private::Address,
            pauser: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<SyndicateTokenInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(
                provider,
                defaultAdmin,
                syndFoundationAddress,
                emissionsManager,
                pauser,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            defaultAdmin: alloy::sol_types::private::Address,
            syndFoundationAddress: alloy::sol_types::private::Address,
            emissionsManager: alloy::sol_types::private::Address,
            pauser: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            defaultAdmin,
                            syndFoundationAddress,
                            emissionsManager,
                            pauser,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> SyndicateTokenInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> SyndicateTokenInstance<T, P, N> {
            SyndicateTokenInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyndicateTokenInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`BRIDGE_LIMIT_DURATION`] function.
        pub fn BRIDGE_LIMIT_DURATION(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, BRIDGE_LIMIT_DURATIONCall, N> {
            self.call_builder(&BRIDGE_LIMIT_DURATIONCall {})
        }
        ///Creates a new call builder for the [`BRIDGE_MANAGER_ROLE`] function.
        pub fn BRIDGE_MANAGER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, BRIDGE_MANAGER_ROLECall, N> {
            self.call_builder(&BRIDGE_MANAGER_ROLECall {})
        }
        ///Creates a new call builder for the [`CLOCK_MODE`] function.
        pub fn CLOCK_MODE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, CLOCK_MODECall, N> {
            self.call_builder(&CLOCK_MODECall {})
        }
        ///Creates a new call builder for the [`DEFAULT_ADMIN_ROLE`] function.
        pub fn DEFAULT_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, DEFAULT_ADMIN_ROLECall, N> {
            self.call_builder(&DEFAULT_ADMIN_ROLECall {})
        }
        ///Creates a new call builder for the [`DOMAIN_SEPARATOR`] function.
        pub fn DOMAIN_SEPARATOR(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, DOMAIN_SEPARATORCall, N> {
            self.call_builder(&DOMAIN_SEPARATORCall {})
        }
        ///Creates a new call builder for the [`EMISSIONS_MANAGER_ROLE`] function.
        pub fn EMISSIONS_MANAGER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSIONS_MANAGER_ROLECall, N> {
            self.call_builder(&EMISSIONS_MANAGER_ROLECall {})
        }
        ///Creates a new call builder for the [`EMISSIONS_SUPPLY`] function.
        pub fn EMISSIONS_SUPPLY(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSIONS_SUPPLYCall, N> {
            self.call_builder(&EMISSIONS_SUPPLYCall {})
        }
        ///Creates a new call builder for the [`EMISSION_BUFFER_TIME`] function.
        pub fn EMISSION_BUFFER_TIME(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSION_BUFFER_TIMECall, N> {
            self.call_builder(&EMISSION_BUFFER_TIMECall {})
        }
        ///Creates a new call builder for the [`EPOCH_DURATION`] function.
        pub fn EPOCH_DURATION(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EPOCH_DURATIONCall, N> {
            self.call_builder(&EPOCH_DURATIONCall {})
        }
        ///Creates a new call builder for the [`INITIAL_MINT_SUPPLY`] function.
        pub fn INITIAL_MINT_SUPPLY(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, INITIAL_MINT_SUPPLYCall, N> {
            self.call_builder(&INITIAL_MINT_SUPPLYCall {})
        }
        ///Creates a new call builder for the [`PAUSER_ROLE`] function.
        pub fn PAUSER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, PAUSER_ROLECall, N> {
            self.call_builder(&PAUSER_ROLECall {})
        }
        ///Creates a new call builder for the [`PRECISION_MULTIPLIER`] function.
        pub fn PRECISION_MULTIPLIER(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, PRECISION_MULTIPLIERCall, N> {
            self.call_builder(&PRECISION_MULTIPLIERCall {})
        }
        ///Creates a new call builder for the [`TOTAL_EPOCHS`] function.
        pub fn TOTAL_EPOCHS(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, TOTAL_EPOCHSCall, N> {
            self.call_builder(&TOTAL_EPOCHSCall {})
        }
        ///Creates a new call builder for the [`TOTAL_SUPPLY`] function.
        pub fn TOTAL_SUPPLY(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, TOTAL_SUPPLYCall, N> {
            self.call_builder(&TOTAL_SUPPLYCall {})
        }
        ///Creates a new call builder for the [`allowance`] function.
        pub fn allowance(
            &self,
            owner: alloy::sol_types::private::Address,
            spender: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, allowanceCall, N> {
            self.call_builder(&allowanceCall { owner, spender })
        }
        ///Creates a new call builder for the [`approve`] function.
        pub fn approve(
            &self,
            spender: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, approveCall, N> {
            self.call_builder(&approveCall { spender, value })
        }
        ///Creates a new call builder for the [`authorizedBridges`] function.
        pub fn authorizedBridges(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, authorizedBridgesCall, N> {
            self.call_builder(&authorizedBridgesCall { _0 })
        }
        ///Creates a new call builder for the [`balanceOf`] function.
        pub fn balanceOf(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, balanceOfCall, N> {
            self.call_builder(&balanceOfCall { account })
        }
        ///Creates a new call builder for the [`bridgeData`] function.
        pub fn bridgeData(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeDataCall, N> {
            self.call_builder(&bridgeDataCall {})
        }
        ///Creates a new call builder for the [`bridgeLimits`] function.
        pub fn bridgeLimits(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeLimitsCall, N> {
            self.call_builder(&bridgeLimitsCall { _0 })
        }
        ///Creates a new call builder for the [`bridgeProxy`] function.
        pub fn bridgeProxy(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeProxyCall, N> {
            self.call_builder(&bridgeProxyCall {})
        }
        ///Creates a new call builder for the [`burn`] function.
        pub fn burn(
            &self,
            _user: alloy::sol_types::private::Address,
            _amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, burnCall, N> {
            self.call_builder(&burnCall { _user, _amount })
        }
        ///Creates a new call builder for the [`burningCurrentLimitOf`] function.
        pub fn burningCurrentLimitOf(
            &self,
            _bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, burningCurrentLimitOfCall, N> {
            self.call_builder(
                &burningCurrentLimitOfCall {
                    _bridge,
                },
            )
        }
        ///Creates a new call builder for the [`burningMaxLimitOf`] function.
        pub fn burningMaxLimitOf(
            &self,
            _bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, burningMaxLimitOfCall, N> {
            self.call_builder(&burningMaxLimitOfCall { _bridge })
        }
        ///Creates a new call builder for the [`checkpoints`] function.
        pub fn checkpoints(
            &self,
            account: alloy::sol_types::private::Address,
            pos: u32,
        ) -> alloy_contract::SolCallBuilder<T, &P, checkpointsCall, N> {
            self.call_builder(&checkpointsCall { account, pos })
        }
        ///Creates a new call builder for the [`clock`] function.
        pub fn clock(&self) -> alloy_contract::SolCallBuilder<T, &P, clockCall, N> {
            self.call_builder(&clockCall {})
        }
        ///Creates a new call builder for the [`currentEpoch`] function.
        pub fn currentEpoch(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, currentEpochCall, N> {
            self.call_builder(&currentEpochCall {})
        }
        ///Creates a new call builder for the [`decimals`] function.
        pub fn decimals(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, decimalsCall, N> {
            self.call_builder(&decimalsCall {})
        }
        ///Creates a new call builder for the [`delegate`] function.
        pub fn delegate(
            &self,
            delegatee: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, delegateCall, N> {
            self.call_builder(&delegateCall { delegatee })
        }
        ///Creates a new call builder for the [`delegateBySig`] function.
        pub fn delegateBySig(
            &self,
            delegatee: alloy::sol_types::private::Address,
            nonce: alloy::sol_types::private::primitives::aliases::U256,
            expiry: alloy::sol_types::private::primitives::aliases::U256,
            v: u8,
            r: alloy::sol_types::private::FixedBytes<32>,
            s: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, delegateBySigCall, N> {
            self.call_builder(
                &delegateBySigCall {
                    delegatee,
                    nonce,
                    expiry,
                    v,
                    r,
                    s,
                },
            )
        }
        ///Creates a new call builder for the [`delegates`] function.
        pub fn delegates(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, delegatesCall, N> {
            self.call_builder(&delegatesCall { account })
        }
        ///Creates a new call builder for the [`eip712Domain`] function.
        pub fn eip712Domain(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, eip712DomainCall, N> {
            self.call_builder(&eip712DomainCall {})
        }
        ///Creates a new call builder for the [`emissionSchedule`] function.
        pub fn emissionSchedule(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionScheduleCall, N> {
            self.call_builder(&emissionScheduleCall { _0 })
        }
        ///Creates a new call builder for the [`emissionsActive`] function.
        pub fn emissionsActive(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionsActiveCall, N> {
            self.call_builder(&emissionsActiveCall {})
        }
        ///Creates a new call builder for the [`emissionsEnded`] function.
        pub fn emissionsEnded(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionsEndedCall, N> {
            self.call_builder(&emissionsEndedCall {})
        }
        ///Creates a new call builder for the [`emissionsStartTime`] function.
        pub fn emissionsStartTime(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionsStartTimeCall, N> {
            self.call_builder(&emissionsStartTimeCall {})
        }
        ///Creates a new call builder for the [`emissionsStarted`] function.
        pub fn emissionsStarted(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionsStartedCall, N> {
            self.call_builder(&emissionsStartedCall {})
        }
        ///Creates a new call builder for the [`getBridgeConfiguration`] function.
        pub fn getBridgeConfiguration(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBridgeConfigurationCall, N> {
            self.call_builder(&getBridgeConfigurationCall {})
        }
        ///Creates a new call builder for the [`getBridgeInfo`] function.
        pub fn getBridgeInfo(
            &self,
            bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBridgeInfoCall, N> {
            self.call_builder(&getBridgeInfoCall { bridge })
        }
        ///Creates a new call builder for the [`getBridgeUtilization`] function.
        pub fn getBridgeUtilization(
            &self,
            bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBridgeUtilizationCall, N> {
            self.call_builder(&getBridgeUtilizationCall { bridge })
        }
        ///Creates a new call builder for the [`getCurrentEpochInfo`] function.
        pub fn getCurrentEpochInfo(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getCurrentEpochInfoCall, N> {
            self.call_builder(&getCurrentEpochInfoCall {})
        }
        ///Creates a new call builder for the [`getCurrentTotalSupply`] function.
        pub fn getCurrentTotalSupply(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getCurrentTotalSupplyCall, N> {
            self.call_builder(&getCurrentTotalSupplyCall {})
        }
        ///Creates a new call builder for the [`getEmissionSchedule`] function.
        pub fn getEmissionSchedule(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getEmissionScheduleCall, N> {
            self.call_builder(&getEmissionScheduleCall {})
        }
        ///Creates a new call builder for the [`getNextEmissionTime`] function.
        pub fn getNextEmissionTime(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getNextEmissionTimeCall, N> {
            self.call_builder(&getNextEmissionTimeCall {})
        }
        ///Creates a new call builder for the [`getPastTotalSupply`] function.
        pub fn getPastTotalSupply(
            &self,
            timepoint: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getPastTotalSupplyCall, N> {
            self.call_builder(
                &getPastTotalSupplyCall {
                    timepoint,
                },
            )
        }
        ///Creates a new call builder for the [`getPastVotes`] function.
        pub fn getPastVotes(
            &self,
            account: alloy::sol_types::private::Address,
            timepoint: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getPastVotesCall, N> {
            self.call_builder(
                &getPastVotesCall {
                    account,
                    timepoint,
                },
            )
        }
        ///Creates a new call builder for the [`getPastVotingPower`] function.
        pub fn getPastVotingPower(
            &self,
            account: alloy::sol_types::private::Address,
            blockNumber: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getPastVotingPowerCall, N> {
            self.call_builder(
                &getPastVotingPowerCall {
                    account,
                    blockNumber,
                },
            )
        }
        ///Creates a new call builder for the [`getRemainingEmissions`] function.
        pub fn getRemainingEmissions(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRemainingEmissionsCall, N> {
            self.call_builder(&getRemainingEmissionsCall {})
        }
        ///Creates a new call builder for the [`getRoleAdmin`] function.
        pub fn getRoleAdmin(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRoleAdminCall, N> {
            self.call_builder(&getRoleAdminCall { role })
        }
        ///Creates a new call builder for the [`getVotes`] function.
        pub fn getVotes(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getVotesCall, N> {
            self.call_builder(&getVotesCall { account })
        }
        ///Creates a new call builder for the [`getVotingPower`] function.
        pub fn getVotingPower(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getVotingPowerCall, N> {
            self.call_builder(&getVotingPowerCall { account })
        }
        ///Creates a new call builder for the [`grantRole`] function.
        pub fn grantRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, grantRoleCall, N> {
            self.call_builder(&grantRoleCall { role, account })
        }
        ///Creates a new call builder for the [`hasRole`] function.
        pub fn hasRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, hasRoleCall, N> {
            self.call_builder(&hasRoleCall { role, account })
        }
        ///Creates a new call builder for the [`isBridge`] function.
        pub fn isBridge(
            &self,
            bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, isBridgeCall, N> {
            self.call_builder(&isBridgeCall { bridge })
        }
        ///Creates a new call builder for the [`mint`] function.
        pub fn mint(
            &self,
            _user: alloy::sol_types::private::Address,
            _amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, mintCall, N> {
            self.call_builder(&mintCall { _user, _amount })
        }
        ///Creates a new call builder for the [`mintEmission`] function.
        pub fn mintEmission(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, mintEmissionCall, N> {
            self.call_builder(&mintEmissionCall {})
        }
        ///Creates a new call builder for the [`mintingCurrentLimitOf`] function.
        pub fn mintingCurrentLimitOf(
            &self,
            _bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, mintingCurrentLimitOfCall, N> {
            self.call_builder(
                &mintingCurrentLimitOfCall {
                    _bridge,
                },
            )
        }
        ///Creates a new call builder for the [`mintingMaxLimitOf`] function.
        pub fn mintingMaxLimitOf(
            &self,
            _bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, mintingMaxLimitOfCall, N> {
            self.call_builder(&mintingMaxLimitOfCall { _bridge })
        }
        ///Creates a new call builder for the [`name`] function.
        pub fn name(&self) -> alloy_contract::SolCallBuilder<T, &P, nameCall, N> {
            self.call_builder(&nameCall {})
        }
        ///Creates a new call builder for the [`nonces`] function.
        pub fn nonces(
            &self,
            owner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, noncesCall, N> {
            self.call_builder(&noncesCall { owner })
        }
        ///Creates a new call builder for the [`numCheckpoints`] function.
        pub fn numCheckpoints(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, numCheckpointsCall, N> {
            self.call_builder(&numCheckpointsCall { account })
        }
        ///Creates a new call builder for the [`pause`] function.
        pub fn pause(&self) -> alloy_contract::SolCallBuilder<T, &P, pauseCall, N> {
            self.call_builder(&pauseCall {})
        }
        ///Creates a new call builder for the [`pauseEmissions`] function.
        pub fn pauseEmissions(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, pauseEmissionsCall, N> {
            self.call_builder(&pauseEmissionsCall {})
        }
        ///Creates a new call builder for the [`paused`] function.
        pub fn paused(&self) -> alloy_contract::SolCallBuilder<T, &P, pausedCall, N> {
            self.call_builder(&pausedCall {})
        }
        ///Creates a new call builder for the [`permit`] function.
        pub fn permit(
            &self,
            owner: alloy::sol_types::private::Address,
            spender: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
            deadline: alloy::sol_types::private::primitives::aliases::U256,
            v: u8,
            r: alloy::sol_types::private::FixedBytes<32>,
            s: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, permitCall, N> {
            self.call_builder(
                &permitCall {
                    owner,
                    spender,
                    value,
                    deadline,
                    v,
                    r,
                    s,
                },
            )
        }
        ///Creates a new call builder for the [`renounceRole`] function.
        pub fn renounceRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            callerConfirmation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceRoleCall, N> {
            self.call_builder(
                &renounceRoleCall {
                    role,
                    callerConfirmation,
                },
            )
        }
        ///Creates a new call builder for the [`resumeEmissions`] function.
        pub fn resumeEmissions(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, resumeEmissionsCall, N> {
            self.call_builder(&resumeEmissionsCall {})
        }
        ///Creates a new call builder for the [`revokeRole`] function.
        pub fn revokeRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, revokeRoleCall, N> {
            self.call_builder(&revokeRoleCall { role, account })
        }
        ///Creates a new call builder for the [`setBridgeData`] function.
        pub fn setBridgeData(
            &self,
            _bridgeData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBridgeDataCall, N> {
            self.call_builder(&setBridgeDataCall { _bridgeData })
        }
        ///Creates a new call builder for the [`setBridgeProxy`] function.
        pub fn setBridgeProxy(
            &self,
            _bridgeProxy: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBridgeProxyCall, N> {
            self.call_builder(&setBridgeProxyCall { _bridgeProxy })
        }
        ///Creates a new call builder for the [`setLimits`] function.
        pub fn setLimits(
            &self,
            _bridge: alloy::sol_types::private::Address,
            _mintingLimit: alloy::sol_types::private::primitives::aliases::U256,
            _burningLimit: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, setLimitsCall, N> {
            self.call_builder(
                &setLimitsCall {
                    _bridge,
                    _mintingLimit,
                    _burningLimit,
                },
            )
        }
        ///Creates a new call builder for the [`startEmissions`] function.
        pub fn startEmissions(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, startEmissionsCall, N> {
            self.call_builder(&startEmissionsCall {})
        }
        ///Creates a new call builder for the [`supportsInterface`] function.
        pub fn supportsInterface(
            &self,
            interfaceId: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<T, &P, supportsInterfaceCall, N> {
            self.call_builder(
                &supportsInterfaceCall {
                    interfaceId,
                },
            )
        }
        ///Creates a new call builder for the [`symbol`] function.
        pub fn symbol(&self) -> alloy_contract::SolCallBuilder<T, &P, symbolCall, N> {
            self.call_builder(&symbolCall {})
        }
        ///Creates a new call builder for the [`totalEmissionsMinted`] function.
        pub fn totalEmissionsMinted(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, totalEmissionsMintedCall, N> {
            self.call_builder(&totalEmissionsMintedCall {})
        }
        ///Creates a new call builder for the [`totalSupply`] function.
        pub fn totalSupply(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, totalSupplyCall, N> {
            self.call_builder(&totalSupplyCall {})
        }
        ///Creates a new call builder for the [`transfer`] function.
        pub fn transfer(
            &self,
            to: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferCall, N> {
            self.call_builder(&transferCall { to, value })
        }
        ///Creates a new call builder for the [`transferFrom`] function.
        pub fn transferFrom(
            &self,
            from: alloy::sol_types::private::Address,
            to: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferFromCall, N> {
            self.call_builder(
                &transferFromCall {
                    from,
                    to,
                    value,
                },
            )
        }
        ///Creates a new call builder for the [`unpause`] function.
        pub fn unpause(&self) -> alloy_contract::SolCallBuilder<T, &P, unpauseCall, N> {
            self.call_builder(&unpauseCall {})
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyndicateTokenInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`Approval`] event.
        pub fn Approval_filter(&self) -> alloy_contract::Event<T, &P, Approval, N> {
            self.event_filter::<Approval>()
        }
        ///Creates a new event filter for the [`BridgeAuthorized`] event.
        pub fn BridgeAuthorized_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeAuthorized, N> {
            self.event_filter::<BridgeAuthorized>()
        }
        ///Creates a new event filter for the [`BridgeDataUpdated`] event.
        pub fn BridgeDataUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeDataUpdated, N> {
            self.event_filter::<BridgeDataUpdated>()
        }
        ///Creates a new event filter for the [`BridgeDeauthorized`] event.
        pub fn BridgeDeauthorized_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeDeauthorized, N> {
            self.event_filter::<BridgeDeauthorized>()
        }
        ///Creates a new event filter for the [`BridgeLimitsSet`] event.
        pub fn BridgeLimitsSet_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeLimitsSet, N> {
            self.event_filter::<BridgeLimitsSet>()
        }
        ///Creates a new event filter for the [`BridgeProxyUpdated`] event.
        pub fn BridgeProxyUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeProxyUpdated, N> {
            self.event_filter::<BridgeProxyUpdated>()
        }
        ///Creates a new event filter for the [`DelegateChanged`] event.
        pub fn DelegateChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, DelegateChanged, N> {
            self.event_filter::<DelegateChanged>()
        }
        ///Creates a new event filter for the [`DelegateVotesChanged`] event.
        pub fn DelegateVotesChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, DelegateVotesChanged, N> {
            self.event_filter::<DelegateVotesChanged>()
        }
        ///Creates a new event filter for the [`EIP712DomainChanged`] event.
        pub fn EIP712DomainChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EIP712DomainChanged, N> {
            self.event_filter::<EIP712DomainChanged>()
        }
        ///Creates a new event filter for the [`EmissionMinted`] event.
        pub fn EmissionMinted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EmissionMinted, N> {
            self.event_filter::<EmissionMinted>()
        }
        ///Creates a new event filter for the [`EmissionsPaused`] event.
        pub fn EmissionsPaused_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EmissionsPaused, N> {
            self.event_filter::<EmissionsPaused>()
        }
        ///Creates a new event filter for the [`EmissionsResumed`] event.
        pub fn EmissionsResumed_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EmissionsResumed, N> {
            self.event_filter::<EmissionsResumed>()
        }
        ///Creates a new event filter for the [`EmissionsStarted`] event.
        pub fn EmissionsStarted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EmissionsStarted, N> {
            self.event_filter::<EmissionsStarted>()
        }
        ///Creates a new event filter for the [`Paused`] event.
        pub fn Paused_filter(&self) -> alloy_contract::Event<T, &P, Paused, N> {
            self.event_filter::<Paused>()
        }
        ///Creates a new event filter for the [`RoleAdminChanged`] event.
        pub fn RoleAdminChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleAdminChanged, N> {
            self.event_filter::<RoleAdminChanged>()
        }
        ///Creates a new event filter for the [`RoleGranted`] event.
        pub fn RoleGranted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleGranted, N> {
            self.event_filter::<RoleGranted>()
        }
        ///Creates a new event filter for the [`RoleRevoked`] event.
        pub fn RoleRevoked_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleRevoked, N> {
            self.event_filter::<RoleRevoked>()
        }
        ///Creates a new event filter for the [`Transfer`] event.
        pub fn Transfer_filter(&self) -> alloy_contract::Event<T, &P, Transfer, N> {
            self.event_filter::<Transfer>()
        }
        ///Creates a new event filter for the [`Unpaused`] event.
        pub fn Unpaused_filter(&self) -> alloy_contract::Event<T, &P, Unpaused, N> {
            self.event_filter::<Unpaused>()
        }
    }
}
