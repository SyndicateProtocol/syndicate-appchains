/**

Generated by the following Solidity interface...
```solidity
interface SyndicateTokenEmissionScheduler {
    error AccessControlBadConfirmation();
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
    error AllEmissionsCompleted();
    error BridgeNotConfigured();
    error EmissionTooEarly();
    error EmissionsAlreadyStarted();
    error EmissionsNotStarted();
    error EnforcedPause();
    error ExpectedPause();
    error ReentrancyGuardReentrantCall();
    error SafeERC20FailedOperation(address token);
    error ZeroAddress();

    event BridgeDataUpdated(bytes oldData, bytes newData);
    event BridgeProxyUpdated(address indexed oldProxy, address indexed newProxy);
    event EmissionMinted(uint256 epoch, uint256 amount, address indexed destination);
    event EmissionsStarted(uint256 startTime);
    event Paused(address account);
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
    event Unpaused(address account);

    constructor(address _syndicateToken, address defaultAdmin, address emissionsManager, address pauser);

    function BRIDGE_MANAGER_ROLE() external view returns (bytes32);
    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
    function EMISSIONS_MANAGER_ROLE() external view returns (bytes32);
    function EMISSION_BUFFER_TIME() external view returns (uint256);
    function EPOCH_DURATION() external view returns (uint256);
    function PAUSER_ROLE() external view returns (bytes32);
    function TOTAL_EPOCHS() external view returns (uint256);
    function bridgeData() external view returns (bytes memory);
    function bridgeProxy() external view returns (address);
    function currentEpoch() external view returns (uint256);
    function emissionSchedule(uint256) external view returns (uint256);
    function emissionsEnded() external view returns (bool);
    function emissionsStartTime() external view returns (uint256);
    function emissionsStarted() external view returns (bool);
    function getBridgeConfiguration() external view returns (address proxy, bytes memory data);
    function getCurrentEpochInfo() external view returns (uint256 epoch, uint256 nextEmissionTime, uint256 nextEmissionAmount, bool canMintEmission);
    function getEmissionSchedule() external view returns (uint256[48] memory);
    function getNextEmissionTime() external view returns (uint256);
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function grantRole(bytes32 role, address account) external;
    function hasRole(bytes32 role, address account) external view returns (bool);
    function mintEmission() external;
    function pause() external;
    function paused() external view returns (bool);
    function renounceRole(bytes32 role, address callerConfirmation) external;
    function revokeRole(bytes32 role, address account) external;
    function setBridgeData(bytes memory _bridgeData) external;
    function setBridgeProxy(address _bridgeProxy) external;
    function startEmissions() external;
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
    function syndicateToken() external view returns (address);
    function totalEmissionsMinted() external view returns (uint256);
    function unpause() external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "_syndicateToken",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "defaultAdmin",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "emissionsManager",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "pauser",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "BRIDGE_MANAGER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DEFAULT_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSIONS_MANAGER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSION_BUFFER_TIME",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EPOCH_DURATION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "PAUSER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "TOTAL_EPOCHS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeData",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeProxy",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IBridgeProxy"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "currentEpoch",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionSchedule",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionsEnded",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionsStartTime",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "emissionsStarted",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBridgeConfiguration",
    "inputs": [],
    "outputs": [
      {
        "name": "proxy",
        "type": "address",
        "internalType": "contract IBridgeProxy"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCurrentEpochInfo",
    "inputs": [],
    "outputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nextEmissionTime",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nextEmissionAmount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "canMintEmission",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getEmissionSchedule",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256[48]",
        "internalType": "uint256[48]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getNextEmissionTime",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleAdmin",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "grantRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "hasRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "mintEmission",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "pause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "paused",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "renounceRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "callerConfirmation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBridgeData",
    "inputs": [
      {
        "name": "_bridgeData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBridgeProxy",
    "inputs": [
      {
        "name": "_bridgeProxy",
        "type": "address",
        "internalType": "contract IBridgeProxy"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "startEmissions",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "syndicateToken",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract ISyndicateTokenMintable"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "totalEmissionsMinted",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "unpause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "BridgeDataUpdated",
    "inputs": [
      {
        "name": "oldData",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      },
      {
        "name": "newData",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeProxyUpdated",
    "inputs": [
      {
        "name": "oldProxy",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newProxy",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EmissionMinted",
    "inputs": [
      {
        "name": "epoch",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "destination",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EmissionsStarted",
    "inputs": [
      {
        "name": "startTime",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Paused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleAdminChanged",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "previousAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleGranted",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleRevoked",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Unpaused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AccessControlBadConfirmation",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AccessControlUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "neededRole",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "AllEmissionsCompleted",
    "inputs": []
  },
  {
    "type": "error",
    "name": "BridgeNotConfigured",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmissionTooEarly",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmissionsAlreadyStarted",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmissionsNotStarted",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EnforcedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ExpectedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ReentrancyGuardReentrantCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SafeERC20FailedOperation",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ZeroAddress",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod SyndicateTokenEmissionScheduler {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a0604052346100515761001d61001461013e565b92919091610265565b610025610056565b612b49610aee8239608051818181610a9c01528181611afc01528181611b7a0152611bd80152612b4990f35b61005c565b60405190565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b9061008890610060565b810190811060018060401b038211176100a057604052565b61006a565b906100b86100b1610056565b928361007e565b565b5f80fd5b60018060a01b031690565b6100d2906100be565b90565b6100de816100c9565b036100e557565b5f80fd5b905051906100f6826100d5565b565b6080818303126101395761010e825f83016100e9565b9261013661011f84602085016100e9565b9361012d81604086016100e9565b936060016100e9565b90565b6100ba565b61015c61363780380380610151816100a5565b9283398101906100f8565b90919293565b90565b90565b61017c61017761018192610162565b610165565b6100be565b90565b61018d90610168565b90565b5f0190565b6101a96101a46101ae926100be565b610165565b6100be565b90565b6101ba90610195565b90565b6101c6906101b1565b90565b90565b5f1b90565b6101e56101e06101ea92610162565b6101cc565b6101c9565b90565b6101f65f6101d1565b90565b7f6b9725f740f94b91b78060a1b17d1774656d381421a529ec98cdb013f4d9c25e90565b7fcce296b040332a080e6df13515a3ec2869e21cd20f7344af0987ddb938d8bd2190565b7f65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a90565b929190610270610441565b8361028b6102856102805f610184565b6100c9565b916100c9565b146103a157806102ab6102a56102a05f610184565b6100c9565b916100c9565b1461038557816102cb6102c56102c05f610184565b6100c9565b916100c9565b1461036957826102eb6102e56102e05f610184565b6100c9565b916100c9565b1461034d5761032661033492610303610342966101bd565b6080526103186103116101ed565b8490610508565b506103216101f9565b610508565b5061032f61021d565b610508565b5061033d610241565b610508565b5061034b6108a8565b565b5f63d92e233d60e01b81528061036560048201610190565b0390fd5b5f63d92e233d60e01b81528061038160048201610190565b0390fd5b5f63d92e233d60e01b81528061039d60048201610190565b0390fd5b5f63d92e233d60e01b8152806103b960048201610190565b0390fd5b90565b90565b6103d76103d26103dc926103bd565b610165565b6103c0565b90565b6103e960016103c3565b90565b906103f85f19916101cc565b9181191691161790565b61041661041161041b926103c0565b610165565b6103c0565b90565b90565b9061043661043161043d92610402565b61041e565b82546103ec565b9055565b6104496104a7565b61045b6104546103df565b6002610421565b565b9061046960ff916101cc565b9181191691161790565b151590565b61048190610473565b90565b90565b9061049c6104976104a392610478565b610484565b825461045d565b9055565b6104b25f6001610487565b565b5f90565b6104c1906101c9565b90565b906104ce906104b8565b5f5260205260405f2090565b6104e390610195565b90565b6104ef906104da565b90565b906104fc906104e6565b5f5260205260405f2090565b6105106104b4565b5061052561051f828490610ab3565b15610473565b5f146105ad5761054c60016105475f61053f8186906104c4565b0185906104f2565b610487565b90610555610ae0565b9061059261058c6105867f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d956104b8565b926104e6565b926104e6565b9261059b610056565b806105a581610190565b0390a4600190565b50505f90565b60018060401b0381116105c65760200290565b61006a565b6105d76105dc916105b3565b6100a5565b90565b90565b6105f66105f16105fb926105df565b610165565b6103c0565b90565b90610608906103c0565b9052565b90565b61062361061e6106289261060c565b610165565b6103c0565b90565b90565b61064261063d6106479261062b565b610165565b6103c0565b90565b90565b61066161065c6106669261064a565b610165565b6103c0565b90565b90565b61068061067b61068592610669565b610165565b6103c0565b90565b90565b61069f61069a6106a492610688565b610165565b6103c0565b90565b90565b6106be6106b96106c3926106a7565b610165565b6103c0565b90565b90565b6106dd6106d86106e2926106c6565b610165565b6103c0565b90565b6106f96106f46106fe92610162565b610165565b6103c0565b90565b600161070d91016103c0565b90565b90565b61072761072261072c92610710565b610165565b6103c0565b90565b90565b61074661074161074b9261072f565b610165565b6103c0565b90565b634e487b7160e01b5f52601160045260245ffd5b610771610777919392936103c0565b926103c0565b916107838382026103c0565b92818404149015171561079257565b61074e565b6107a66107ac919392936103c0565b926103c0565b82018092116107b757565b61074e565b90565b6107d36107ce6107d8926107bc565b610165565b6103c0565b90565b6107e560306107bf565b90565b634e487b7160e01b5f52603260045260245ffd5b50600890565b9061080c826107fc565b81101561081a576020020190565b6107e8565b61082990516103c0565b90565b50603090565b90565b61083e8161082c565b82101561085857610850600191610832565b910201905f90565b6107e8565b1b90565b9190600861087c9102916108765f198461085d565b9261085d565b9181191691161790565b919061089c6108976108a493610402565b61041e565b908354610861565b9055565b6108b260086105cb565b6108d16108c96a059bd65a1eca6db65800006105e2565b5f83016105fe565b6108f16108e86a035d809c78dfdb6d68000061060f565b602083016105fe565b6109116109086a0204e6e009f3b7c3a0000061062e565b604083016105fe565b6109316109286a0136242005f8a17560000061064d565b606083016105fe565b61095061094769ba15acd061fa79a0000061066c565b608083016105fe565b61096f610966696fa6d26648cb4cf0000061068b565b60a083016105fe565b61098e6109856942fd5e2c49dda83800006106aa565b60c083016105fe565b6109ad6109a46928319ee75f84fe8800006106c9565b60e083016105fe565b6109b65f6106e5565b915b826109cc6109c66008610713565b916103c0565b1015610a82576109db5f6106e5565b5b806109f06109ea6006610732565b916103c0565b1015610a7157610a3e90610a18610a1186610a0b6006610732565b90610762565b8290610797565b80610a32610a2c610a276107db565b6103c0565b916103c0565b10610a43575b50610701565b6109dc565b610a6b90610a65610a5d610a58888a90610802565b61081f565b916003610835565b90610886565b5f610a38565b5091610a7c90610701565b916109b8565b915050565b5f1c90565b60ff1690565b610a9e610aa391610a87565b610a8c565b90565b610ab09054610a92565b90565b610ad9915f610ace610ad493610ac76104b4565b50826104c4565b016104f2565b610aa6565b90565b5f90565b610ae8610adc565b50339056fe60806040526004361015610013575b6111a4565b61001d5f3561022c565b806301ffc9a71461022757806307a1d5fa1461022257806313beaa5b1461021d5780631b02f84514610218578063243a30cc146102135780632481bb5c1461020e578063248a9ca314610209578063284e1333146102045780632f2ff15d146101ff578063334d0bbd146101fa57806336568abe146101f55780633f4ba83a146101f057806348b0daa6146101eb5780635adf0021146101e65780635bdf6ca1146101e15780635c975abb146101dc5780635f15c3c9146101d757806376671808146101d25780638456cb59146101cd57806391d14854146101c8578063a217fddf146101c3578063a3d4485b146101be578063a4d7e31d146101b9578063a571e184146101b4578063a5b326be146101af578063a70b9f0c146101aa578063af2aa63b146101a5578063babc394f146101a0578063d547741f1461019b578063e3abdfcb14610196578063e63ab1e914610191578063f508e19d1461018c5763f75e85120361000e5761116f565b61110b565b6110c7565b611063565b611000565b610fc7565b610f54565b610e8c565b610e1e565b610deb565b610d69565b610d34565b610caa565b610c39565b610c06565b610bd1565b610b8d565b610b21565b610aec565b610a65565b610a30565b6109ee565b6109ba565b610985565b610872565b6107e3565b6107ae565b610713565b610544565b6104b4565b610480565b6103c4565b6102b8565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b63ffffffff60e01b1690565b61025981610244565b0361026057565b5f80fd5b9050359061027182610250565b565b9060208282031261028c57610289915f01610264565b90565b61023c565b151590565b61029f90610291565b9052565b91906102b6905f60208501940190610296565b565b346102e8576102e46102d36102ce366004610273565b6111ac565b6102db610232565b918291826102a3565b0390f35b610238565b5f9103126102f757565b61023c565b60018060a01b031690565b90565b61031e610319610323926102fc565b610307565b6102fc565b90565b61032f9061030a565b90565b61033b90610326565b90565b61034790610332565b9052565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b61038c61039560209361039a936103838161034b565b9384809361034f565b95869101610358565b610363565b0190565b916103c1926103b460408201935f83019061033e565b602081840391015261036d565b90565b346103f5576103d43660046102ed565b6103dc611227565b906103f16103e8610232565b9283928361039e565b0390f35b610238565b5f80fd5b5f80fd5b5f80fd5b909182601f830112156104405781359167ffffffffffffffff831161043b57602001926001830284011161043657565b610402565b6103fe565b6103fa565b90602082820312610476575f82013567ffffffffffffffff81116104715761046d9201610406565b9091565b610240565b61023c565b5f0190565b346104af57610499610493366004610445565b90611525565b6104a1610232565b806104ab8161047b565b0390f35b610238565b346104e2576104c43660046102ed565b6104cc6116b7565b6104d4610232565b806104de8161047b565b0390f35b610238565b90565b90565b6105016104fc610506926104e7565b610307565b6104ea565b90565b610514610e106104ed565b90565b61051f610509565b90565b61052b906104ea565b9052565b9190610542905f60208501940190610522565b565b34610574576105543660046102ed565b61057061055f610517565b610567610232565b9182918261052f565b0390f35b610238565b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52602260045260245ffd5b90600160028304921680156105c0575b60208310146105bb57565b61058c565b91607f16916105b0565b60209181520190565b5f5260205f2090565b905f92918054906105f66105ef836105a0565b80946105ca565b916001811690815f1461064d5750600114610611575b505050565b61061e91929394506105d3565b915f925b81841061063557505001905f808061060c565b60018160209295939554848601520191019290610622565b92949550505060ff19168252151560200201905f808061060c565b90610672916105dc565b90565b634e487b7160e01b5f52604160045260245ffd5b9061069390610363565b810190811067ffffffffffffffff8211176106ad57604052565b610675565b906106d26106cb926106c2610232565b93848092610668565b0383610689565b565b905f106106e7576106e4906106b2565b90565b610579565b6106f860375f906106d4565b90565b6107109160208201915f81840391015261036d565b90565b34610743576107233660046102ed565b61073f61072e6106ec565b610736610232565b918291826106fb565b0390f35b610238565b90565b61075481610748565b0361075b57565b5f80fd5b9050359061076c8261074b565b565b9060208282031261078757610784915f0161075f565b90565b61023c565b61079590610748565b9052565b91906107ac905f6020850194019061078c565b565b346107de576107da6107c96107c436600461076e565b61170b565b6107d1610232565b91829182610799565b0390f35b610238565b34610811576107f33660046102ed565b6107fb611d86565b610803610232565b8061080d8161047b565b0390f35b610238565b61081f906102fc565b90565b61082b81610816565b0361083257565b5f80fd5b9050359061084382610822565b565b919060408382031261086d578061086161086a925f860161075f565b93602001610836565b90565b61023c565b346108a15761088b610885366004610845565b90611dba565b610893610232565b8061089d8161047b565b0390f35b610238565b6108af816104ea565b036108b657565b5f80fd5b905035906108c7826108a6565b565b906020828203126108e2576108df915f016108ba565b90565b61023c565b634e487b7160e01b5f52603260045260245ffd5b50603090565b90565b61090d816108fb565b8210156109275761091f600191610901565b910201905f90565b6108e7565b1c90565b90565b610943906008610948930261092c565b610930565b90565b906109569154610933565b90565b6003610964816108fb565b8210156109815761097e9161097891610904565b9061094b565b90565b5f80fd5b346109b5576109b16109a061099b3660046108c9565b610959565b6109a8610232565b9182918261052f565b0390f35b610238565b346109e9576109d36109cd366004610845565b90611dc6565b6109db610232565b806109e58161047b565b0390f35b610238565b34610a1c576109fe3660046102ed565b610a06611e32565b610a0e610232565b80610a188161047b565b0390f35b610238565b610a2d60335f9061094b565b90565b34610a6057610a403660046102ed565b610a5c610a4b610a21565b610a53610232565b9182918261052f565b0390f35b610238565b34610a9557610a753660046102ed565b610a91610a80611e3c565b610a88610232565b918291826102a3565b0390f35b610238565b7f000000000000000000000000000000000000000000000000000000000000000090565b610ac790610326565b90565b610ad390610abe565b9052565b9190610aea905f60208501940190610aca565b565b34610b1c57610afc3660046102ed565b610b18610b07610a9a565b610b0f610232565b91829182610ad7565b0390f35b610238565b34610b5157610b313660046102ed565b610b4d610b3c611e8c565b610b44610232565b918291826102a3565b0390f35b610238565b90565b610b6d610b68610b7292610b56565b610307565b6104ea565b90565b610b7f6030610b59565b90565b610b8a610b75565b90565b34610bbd57610b9d3660046102ed565b610bb9610ba8610b82565b610bb0610232565b9182918261052f565b0390f35b610238565b610bce60345f9061094b565b90565b34610c0157610be13660046102ed565b610bfd610bec610bc2565b610bf4610232565b9182918261052f565b0390f35b610238565b34610c3457610c163660046102ed565b610c1e611ec6565b610c26610232565b80610c308161047b565b0390f35b610238565b34610c6a57610c66610c55610c4f366004610845565b90611ee6565b610c5d610232565b918291826102a3565b0390f35b610238565b90565b5f1b90565b610c8b610c86610c9092610c6f565b610c72565b610748565b90565b610c9c5f610c77565b90565b610ca7610c93565b90565b34610cda57610cba3660046102ed565b610cd6610cc5610c9f565b610ccd610232565b91829182610799565b0390f35b610238565b60018060a01b031690565b610cfa906008610cff930261092c565b610cdf565b90565b90610d0d9154610cea565b90565b610d1c60365f90610d02565b90565b9190610d32905f6020850194019061033e565b565b34610d6457610d443660046102ed565b610d60610d4f610d10565b610d57610232565b91829182610d1f565b0390f35b610238565b34610d9957610d793660046102ed565b610d95610d84611f0f565b610d8c610232565b918291826102a3565b0390f35b610238565b610da790610816565b90565b610db381610d9e565b03610dba57565b5f80fd5b90503590610dcb82610daa565b565b90602082820312610de657610de3915f01610dbe565b90565b61023c565b34610e1957610e03610dfe366004610dcd565b612066565b610e0b610232565b80610e158161047b565b0390f35b610238565b34610e4e57610e2e3660046102ed565b610e4a610e396120c5565b610e41610232565b9182918261052f565b0390f35b610238565b90565b610e6a610e65610e6f92610e53565b610307565b6104ea565b90565b610e7e62278d00610e56565b90565b610e89610e72565b90565b34610ebc57610e9c3660046102ed565b610eb8610ea7610e81565b610eaf610232565b9182918261052f565b0390f35b610238565b50603090565b905090565b90565b610ed8906104ea565b9052565b90610ee981602093610ecf565b0190565b60200190565b610f0f610f09610f0283610ec1565b8094610ec7565b91610ecc565b5f915b838310610f1f5750505050565b610f35610f2f6001928451610edc565b92610eed565b92019190610f12565b9190610f52905f6106008501940190610ef3565b565b34610f8457610f643660046102ed565b610f80610f6f61225e565b610f77610232565b91829182610f3e565b0390f35b610238565b610fbe610fc594610fb4606094989795610faa608086019a5f870190610522565b6020850190610522565b6040830190610522565b0190610296565b565b34610ffb57610fd73660046102ed565b610ff7610fe2612274565b90610fee949294610232565b94859485610f89565b0390f35b610238565b3461102f57611019611013366004610845565b906124a5565b611021610232565b8061102b8161047b565b0390f35b610238565b7f6b9725f740f94b91b78060a1b17d1774656d381421a529ec98cdb013f4d9c25e90565b611060611034565b90565b34611093576110733660046102ed565b61108f61107e611058565b611086610232565b91829182610799565b0390f35b610238565b7f65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a90565b6110c4611098565b90565b346110f7576110d73660046102ed565b6110f36110e26110bc565b6110ea610232565b91829182610799565b0390f35b610238565b61110860355f9061094b565b90565b3461113b5761111b3660046102ed565b6111376111266110fc565b61112e610232565b9182918261052f565b0390f35b610238565b7fcce296b040332a080e6df13515a3ec2869e21cd20f7344af0987ddb938d8bd2190565b61116c611140565b90565b3461119f5761117f3660046102ed565b61119b61118a611164565b611192610232565b91829182610799565b0390f35b610238565b5f80fd5b5f90565b6111b46111a8565b50806111cf6111c9637965db0b60e01b610244565b91610244565b149081156111dc575b5090565b6111e691506124b1565b5f6111d8565b5f90565b606090565b5f1c90565b61120661120b916111f5565b610cdf565b90565b61121890546111fa565b90565b611224906106b2565b90565b61122f6111ec565b506112386111f0565b50611243603661120e565b9061124e603761121b565b90565b9061126b91611266611261611140565b6124d7565b6114cf565b565b5090565b601f602091010490565b1b90565b9190600861129a9102916112945f198461127b565b9261127b565b9181191691161790565b6112b86112b36112bd926104ea565b610307565b6104ea565b90565b90565b91906112d96112d46112e1936112a4565b6112c0565b90835461127f565b9055565b5f90565b6112fb916112f56112e5565b916112c3565b565b5b818110611309575050565b806113165f6001936112e9565b016112fe565b9190601f811161132c575b505050565b61133861135d936105d3565b90602061134484611271565b83019310611365575b61135690611271565b01906112fd565b5f8080611327565b91506113568192905061134d565b90611383905f199060080261092c565b191690565b8161139291611373565b906002021790565b916113a5908261126d565b9067ffffffffffffffff8211611464576113c9826113c385546105a0565b8561131c565b5f90601f83116001146113fc579180916113eb935f926113f0575b5050611388565b90555b565b90915001355f806113e4565b601f1983169161140b856105d3565b925f5b81811061144c57509160029391856001969410611432575b505050020190556113ee565b611442910135601f841690611373565b90555f8080611426565b9193602060018192878701358155019501920161140e565b610675565b90611474929161139a565b565b90825f939282370152565b919061149b81611494816114a09561034f565b8095611476565b610363565b0190565b916114be6114cc949260408501908582035f87015261036d565b926020818503910152611481565b90565b906114da603761121b565b6114e78383906037611469565b9190916115207fb9a2088426f03b30a81c06428094fbfa9e2692739b3241af6b9ab1da4b5546be93611517610232565b938493846114a4565b0390a1565b9061152f91611251565b565b61154161153c611034565b6124d7565b6115496115e6565b565b61155761155c916111f5565b610930565b90565b611569905461154b565b90565b61158061157b61158592610c6f565b610307565b6104ea565b90565b61159c6115976115a192610c6f565b610307565b6102fc565b90565b6115ad90611588565b90565b906115bc5f1991610c72565b9181191691161790565b906115db6115d66115e2926112a4565b6112c0565b82546115b0565b9055565b6115f0603361155f565b6116026115fc5f61156c565b916104ea565b0361169b57611619611614603661120e565b610332565b61163361162d6116285f6115a4565b610816565b91610816565b1461167f576116434260336115c6565b4261167a7f1194b034cfa9ab5807494a1d5c667d8b0e6e97f38888742aa3871a322034116091611671610232565b9182918261052f565b0390a1565b5f633b0a48bd60e11b8152806116976004820161047b565b0390fd5b5f6338e93dbd60e11b8152806116b36004820161047b565b0390fd5b6116bf611531565b565b5f90565b6116ce90610748565b90565b906116db906116c5565b5f5260205260405f2090565b90565b6116f66116fb916111f5565b6116e7565b90565b61170890546116ea565b90565b60016117236117299261171c6116c1565b505f6116d1565b016116fe565b90565b6117346124eb565b61173c61173e565b565b611746612541565b61174e611758565b6117566125a6565b565b611768611763611034565b6124d7565b611770611981565b565b634e487b7160e01b5f52601160045260245ffd5b61179561179b919392936104ea565b926104ea565b82039182116117a657565b611772565b634e487b7160e01b5f52601260045260245ffd5b6117cb6117d1916104ea565b916104ea565b9081156117dc570490565b6117ab565b60016117ed91016104ea565b90565b6117ff611805919392936104ea565b926104ea565b820180921161181057565b611772565b61181e90610326565b90565b5f80fd5b60e01b90565b5f91031261183557565b61023c565b61184390610816565b9052565b91602061186892949361186160408201965f83019061183a565b0190610522565b565b611872610232565b3d5f823e3d90fd5b6118839061030a565b90565b61188f9061187a565b90565b905f92918054906118ac6118a5836105a0565b809461034f565b916001811690815f1461190357506001146118c7575b505050565b6118d491929394506105d3565b915f925b8184106118eb57505001905f80806118c2565b600181602092959395548486015201910192906118d8565b92949550505060ff19168252151560200201905f80806118c2565b61194261194f94929361193860608401955f85019061183a565b6020830190610522565b6040818403910152611892565b90565b61195b90610326565b90565b91602061197f92949361197860408201965f830190610522565b0190610522565b565b61198b603361155f565b61199d6119975f61156c565b916104ea565b14611d6a576119aa611f0f565b611d4e576119d36119c5426119bf603361155f565b90611786565b6119cd610e72565b906117bf565b426119fe6119f86119f36119e56120c5565b6119ed610509565b90611786565b6104ea565b916104ea565b10611d3257611a1790611a11603461155f565b90611786565b9081611a45611a3f611a3a611a2a610b75565b611a34603461155f565b90611786565b6104ea565b916104ea565b11611d0f575b611a545f61156c565b90611a5e5f61156c565b915b82611a73611a6d866104ea565b916104ea565b1015611aba57611aae611ab491611aa8611aa26003611a9c611a95603461155f565b89906117f0565b90610904565b9061094b565b906117f0565b926117e1565b91611a60565b915091611ad3611ada91611ace603461155f565b6117f0565b60346115c6565b611af7611af082611aeb603561155f565b6117f0565b60356115c6565b611b207f0000000000000000000000000000000000000000000000000000000000000000610abe565b6340c10f19611b2e30611815565b8392803b15611d0a57611b545f8094611b5f611b48610232565b97889687958694611825565b845260048401611847565b03925af18015611d0557611cd9575b50611bbc611ba3611b9e7f0000000000000000000000000000000000000000000000000000000000000000610abe565b611886565b611bb5611bb0603661120e565b610332565b839161261b565b611bce611bc9603661120e565b610332565b6318b68b8c611bfc7f0000000000000000000000000000000000000000000000000000000000000000610abe565b8392603792813b15611cd4575f611c2691611c318296611c1a610232565b98899788968795611825565b85526004850161191e565b03925af18015611ccf57611ca3575b50611c4b603461155f565b90611c5e611c59603661120e565b610332565b90611c897f34b73d0c96e9ff4d5311434817c8ecc930e7d2782c5bde2e79dc44b0596755bb92611952565b92611c9e611c95610232565b9283928361195e565b0390a2565b611cc2905f3d8111611cc8575b611cba8183610689565b81019061182b565b5f611c40565b503d611cb0565b61186a565b611821565b611cf8905f3d8111611cfe575b611cf08183610689565b81019061182b565b5f611b6e565b503d611ce6565b61186a565b611821565b9050611d2c611d1c610b75565b611d26603461155f565b90611786565b90611a4b565b5f633d53c75360e01b815280611d4a6004820161047b565b0390fd5b5f631155624b60e21b815280611d666004820161047b565b0390fd5b5f638f98404160e01b815280611d826004820161047b565b0390fd5b611d8e61172c565b565b90611dab91611da6611da18261170b565b6124d7565b611dad565b565b90611db79161271c565b50565b90611dc491611d90565b565b9080611de1611ddb611dd66127cb565b610816565b91610816565b03611df257611def916127d8565b50565b5f63334bd91960e11b815280611e0a6004820161047b565b0390fd5b611e1e611e19610c93565b6124d7565b611e26611e28565b565b611e306128ee565b565b611e3a611e0e565b565b611e446111a8565b50611e4f603361155f565b611e61611e5b5f61156c565b916104ea565b1190565b60ff1690565b611e77611e7c916111f5565b611e65565b90565b611e899054611e6b565b90565b611e946111a8565b50611e9f6001611e7f565b90565b611eb2611ead611098565b6124d7565b611eba611ebc565b565b611ec4612958565b565b611ece611ea2565b565b90611eda90611952565b5f5260205260405f2090565b611f0c915f611f01611f0793611efa6111a8565b50826116d1565b01611ed0565b611e7f565b90565b611f176111a8565b50611f22603461155f565b611f3b611f35611f30610b75565b6104ea565b916104ea565b101590565b611f5990611f54611f4f611140565b6124d7565b611fb1565b565b90611f6c60018060a01b0391610c72565b9181191691161790565b611f7f9061030a565b90565b611f8b90611f76565b90565b90565b90611fa6611fa1611fad92611f82565b611f8e565b8254611f5b565b9055565b611fba81610332565b611fd4611fce611fc95f6115a4565b610816565b91610816565b1461204a57611fff611ff9611fe9603661120e565b611ff4846036611f91565b610332565b91610332565b61203261202c7f07015b6a9f05913148fd5faddf2acc9708f305937f3072ca2b4b46faa5d0898b93611952565b91611952565b9161203b610232565b806120458161047b565b0390a3565b5f63d92e233d60e01b8152806120626004820161047b565b0390fd5b61206f90611f40565b565b90565b61208861208361208d92612071565b610307565b6104ea565b90565b61209f6120a5919392936104ea565b926104ea565b916120b18382026104ea565b9281840414901517156120c057565b611772565b6120cd6112e5565b506120d8603361155f565b6120ea6120e45f61156c565b916104ea565b14612133576121306120fc603361155f565b61212a61211c61210c603461155f565b6121166001612074565b906117f0565b612124610e72565b90612090565b906117f0565b90565b61213c5f61156c565b90565b9061215261214b610232565b9283610689565b565b67ffffffffffffffff81116121695760200290565b610675565b61217a61217f91612154565b61213f565b90565b369037565b906121a56121948361216e565b9261219f8491612154565b90612182565b565b6121b16030612187565b90565b905090565b6121c3905461154b565b90565b60010190565b6121e86121e26121db836108fb565b80946121b4565b91610901565b5f915b8383106121f85750505050565b61221561220f60019261220a856121b9565b610edc565b926121c6565b920191906121eb565b9061222c81610600936121cc565b0190565b9061225061224992612240610232565b9384809261221e565b0383610689565b565b61225b90612230565b90565b6122666121a7565b506122716003612252565b90565b61227c6112e5565b506122856112e5565b5061228e6112e5565b506122976111a8565b506122a2603361155f565b6122b46122ae5f61156c565b916104ea565b14612455576122de6122d0426122ca603361155f565b90611786565b6122d8610e72565b906117bf565b906123206122ec603361155f565b61231a61230c6122fc603461155f565b6123066001612074565b906117f0565b612314610e72565b90612090565b906117f0565b61232a603461155f565b61234361233d612338610b75565b6104ea565b916104ea565b105f1461244757612368612362600361235c603461155f565b90610904565b9061094b565b5b92612374603361155f565b6123866123805f61156c565b916104ea565b119081612423575b50806123f9575b806123cd575b806123b6575b916123ac603461155f565b9193929193929190565b506123c86123c2611e8c565b15610291565b6123a1565b50426123f26123ec6123e7846123e1610509565b90611786565b6104ea565b916104ea565b101561239b565b50612404603461155f565b61241d612417612412610b75565b6104ea565b916104ea565b10612395565b905061244061243a612435603461155f565b6104ea565b916104ea565b115f61238e565b6124505f61156c565b612369565b5f905f915f9161247761247161246b5f9461156c565b9561156c565b9361156c565b9190565b906124969161249161248c8261170b565b6124d7565b612498565b565b906124a2916127d8565b50565b906124af9161247b565b565b6124b96111a8565b506124d36124cd6301ffc9a760e01b610244565b91610244565b1490565b6124e9906124e36127cb565b90612985565b565b6124f3611e8c565b6124f957565b5f63d93c066560e01b8152806125116004820161047b565b0390fd5b90565b61252c61252761253192612515565b610307565b6104ea565b90565b61253e6002612518565b90565b61254b600261155f565b61256461255e612559612534565b6104ea565b916104ea565b1461257d5761257b612574612534565b60026115c6565b565b5f633ee5aeb560e01b8152806125956004820161047b565b0390fd5b6125a36001612074565b90565b6125b86125b1612599565b60026115c6565b565b6125c390610326565b90565b63ffffffff1690565b6125e36125de6125e8926125c6565b611825565b610244565b90565b6125f49061156c565b9052565b91602061261992949361261260408201965f83019061183a565b01906125eb565b565b909161265e60049161264f63095ea7b36126368793916125cf565b9261263f610232565b9586946020860190815201611847565b60208201810382520382610689565b9061267361266d8284906129c0565b15610291565b61267d575b505050565b6126ca60046126cf946126c584916126b663095ea7b361269d5f916125cf565b926126a6610232565b96879460208601908152016125f8565b60208201810382520383610689565b612a62565b612a62565b5f8080612678565b906126e360ff91610c72565b9181191691161790565b6126f690610291565b90565b90565b9061271161270c612718926126ed565b6126f9565b82546126d7565b9055565b6127246111a8565b50612739612733828490611ee6565b15610291565b5f146127c157612760600161275b5f6127538186906116d1565b018590611ed0565b6126fc565b906127696127cb565b906127a66127a061279a7f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d956116c5565b92611952565b92611952565b926127af610232565b806127b98161047b565b0390a4600190565b50505f90565b5f90565b6127d36127c7565b503390565b6127e06111a8565b506127ec818390611ee6565b5f14612873576128125f61280d5f6128058186906116d1565b018590611ed0565b6126fc565b9061281b6127cb565b9061285861285261284c7ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b956116c5565b92611952565b92611952565b92612861610232565b8061286b8161047b565b0390a4600190565b50505f90565b612881612b16565b6128896128a0565b565b919061289e905f6020850194019061183a565b565b6128ab5f60016126fc565b6128b36127cb565b6128e97f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa916128e0610232565b9182918261288b565b0390a1565b6128f6612879565b565b6129006124eb565b61290861290a565b565b6129156001806126fc565b61291d6127cb565b6129537f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2589161294a610232565b9182918261288b565b0390a1565b6129606128f8565b565b91602061298392949361297c60408201965f83019061183a565b019061078c565b565b9061299a612994838390611ee6565b15610291565b6129a2575050565b6129bc5f92839263e2517d3f60e01b845260048401612962565b0390fd5b905f6020916129cd6111a8565b506129d66111a8565b506129df6112e5565b506129e86112e5565b50828151910182855af13d915f51919283612a04575b50505090565b90919250612a1a612a145f61156c565b916104ea565b145f14612a4857612a2b91506125ba565b3b612a3e612a385f61156c565b916104ea565b115b5f80806129fe565b50612a5c612a566001612074565b916104ea565b14612a40565b905f602091612a6f6112e5565b50612a786112e5565b50828151910182855af115612b0b573d5f5190612a9d612a975f61156c565b916104ea565b145f14612af15750612aae816125ba565b3b612ac1612abb5f61156c565b916104ea565b145b612aca5750565b612ad6612aed916125ba565b5f918291635274afe760e01b83526004830161288b565b0390fd5b612b04612afe6001612074565b916104ea565b1415612ac3565b6040513d5f823e3d90fd5b612b27612b21611e8c565b15610291565b612b2d57565b5f638dfc202b60e01b815280612b456004820161047b565b0390fd
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0`@R4a\0QWa\0\x1Da\0\x14a\x01>V[\x92\x91\x90\x91a\x02eV[a\0%a\0VV[a+Ia\n\xEE\x829`\x80Q\x81\x81\x81a\n\x9C\x01R\x81\x81a\x1A\xFC\x01R\x81\x81a\x1Bz\x01Ra\x1B\xD8\x01Ra+I\x90\xF3[a\0\\V[`@Q\x90V[_\x80\xFD[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\0\x88\x90a\0`V[\x81\x01\x90\x81\x10`\x01\x80`@\x1B\x03\x82\x11\x17a\0\xA0W`@RV[a\0jV[\x90a\0\xB8a\0\xB1a\0VV[\x92\x83a\0~V[V[_\x80\xFD[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\0\xD2\x90a\0\xBEV[\x90V[a\0\xDE\x81a\0\xC9V[\x03a\0\xE5WV[_\x80\xFD[\x90PQ\x90a\0\xF6\x82a\0\xD5V[V[`\x80\x81\x83\x03\x12a\x019Wa\x01\x0E\x82_\x83\x01a\0\xE9V[\x92a\x016a\x01\x1F\x84` \x85\x01a\0\xE9V[\x93a\x01-\x81`@\x86\x01a\0\xE9V[\x93``\x01a\0\xE9V[\x90V[a\0\xBAV[a\x01\\a67\x808\x03\x80a\x01Q\x81a\0\xA5V[\x92\x839\x81\x01\x90a\0\xF8V[\x90\x91\x92\x93V[\x90V[\x90V[a\x01|a\x01wa\x01\x81\x92a\x01bV[a\x01eV[a\0\xBEV[\x90V[a\x01\x8D\x90a\x01hV[\x90V[_\x01\x90V[a\x01\xA9a\x01\xA4a\x01\xAE\x92a\0\xBEV[a\x01eV[a\0\xBEV[\x90V[a\x01\xBA\x90a\x01\x95V[\x90V[a\x01\xC6\x90a\x01\xB1V[\x90V[\x90V[_\x1B\x90V[a\x01\xE5a\x01\xE0a\x01\xEA\x92a\x01bV[a\x01\xCCV[a\x01\xC9V[\x90V[a\x01\xF6_a\x01\xD1V[\x90V[\x7Fk\x97%\xF7@\xF9K\x91\xB7\x80`\xA1\xB1}\x17tem8\x14!\xA5)\xEC\x98\xCD\xB0\x13\xF4\xD9\xC2^\x90V[\x7F\xCC\xE2\x96\xB0@3*\x08\x0Em\xF15\x15\xA3\xEC(i\xE2\x1C\xD2\x0FsD\xAF\t\x87\xDD\xB98\xD8\xBD!\x90V[\x7Fe\xD7\xA2\x8E2e\xB3zdt\x92\x9F3e!\xB32\xC1h\x1B\x93?l\xB9\xF37fsD\r\x86*\x90V[\x92\x91\x90a\x02pa\x04AV[\x83a\x02\x8Ba\x02\x85a\x02\x80_a\x01\x84V[a\0\xC9V[\x91a\0\xC9V[\x14a\x03\xA1W\x80a\x02\xABa\x02\xA5a\x02\xA0_a\x01\x84V[a\0\xC9V[\x91a\0\xC9V[\x14a\x03\x85W\x81a\x02\xCBa\x02\xC5a\x02\xC0_a\x01\x84V[a\0\xC9V[\x91a\0\xC9V[\x14a\x03iW\x82a\x02\xEBa\x02\xE5a\x02\xE0_a\x01\x84V[a\0\xC9V[\x91a\0\xC9V[\x14a\x03MWa\x03&a\x034\x92a\x03\x03a\x03B\x96a\x01\xBDV[`\x80Ra\x03\x18a\x03\x11a\x01\xEDV[\x84\x90a\x05\x08V[Pa\x03!a\x01\xF9V[a\x05\x08V[Pa\x03/a\x02\x1DV[a\x05\x08V[Pa\x03=a\x02AV[a\x05\x08V[Pa\x03Ka\x08\xA8V[V[_c\xD9.#=`\xE0\x1B\x81R\x80a\x03e`\x04\x82\x01a\x01\x90V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a\x03\x81`\x04\x82\x01a\x01\x90V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a\x03\x9D`\x04\x82\x01a\x01\x90V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a\x03\xB9`\x04\x82\x01a\x01\x90V[\x03\x90\xFD[\x90V[\x90V[a\x03\xD7a\x03\xD2a\x03\xDC\x92a\x03\xBDV[a\x01eV[a\x03\xC0V[\x90V[a\x03\xE9`\x01a\x03\xC3V[\x90V[\x90a\x03\xF8_\x19\x91a\x01\xCCV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x04\x16a\x04\x11a\x04\x1B\x92a\x03\xC0V[a\x01eV[a\x03\xC0V[\x90V[\x90V[\x90a\x046a\x041a\x04=\x92a\x04\x02V[a\x04\x1EV[\x82Ta\x03\xECV[\x90UV[a\x04Ia\x04\xA7V[a\x04[a\x04Ta\x03\xDFV[`\x02a\x04!V[V[\x90a\x04i`\xFF\x91a\x01\xCCV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x15\x15\x90V[a\x04\x81\x90a\x04sV[\x90V[\x90V[\x90a\x04\x9Ca\x04\x97a\x04\xA3\x92a\x04xV[a\x04\x84V[\x82Ta\x04]V[\x90UV[a\x04\xB2_`\x01a\x04\x87V[V[_\x90V[a\x04\xC1\x90a\x01\xC9V[\x90V[\x90a\x04\xCE\x90a\x04\xB8V[_R` R`@_ \x90V[a\x04\xE3\x90a\x01\x95V[\x90V[a\x04\xEF\x90a\x04\xDAV[\x90V[\x90a\x04\xFC\x90a\x04\xE6V[_R` R`@_ \x90V[a\x05\x10a\x04\xB4V[Pa\x05%a\x05\x1F\x82\x84\x90a\n\xB3V[\x15a\x04sV[_\x14a\x05\xADWa\x05L`\x01a\x05G_a\x05?\x81\x86\x90a\x04\xC4V[\x01\x85\x90a\x04\xF2V[a\x04\x87V[\x90a\x05Ua\n\xE0V[\x90a\x05\x92a\x05\x8Ca\x05\x86\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a\x04\xB8V[\x92a\x04\xE6V[\x92a\x04\xE6V[\x92a\x05\x9Ba\0VV[\x80a\x05\xA5\x81a\x01\x90V[\x03\x90\xA4`\x01\x90V[PP_\x90V[`\x01\x80`@\x1B\x03\x81\x11a\x05\xC6W` \x02\x90V[a\0jV[a\x05\xD7a\x05\xDC\x91a\x05\xB3V[a\0\xA5V[\x90V[\x90V[a\x05\xF6a\x05\xF1a\x05\xFB\x92a\x05\xDFV[a\x01eV[a\x03\xC0V[\x90V[\x90a\x06\x08\x90a\x03\xC0V[\x90RV[\x90V[a\x06#a\x06\x1Ea\x06(\x92a\x06\x0CV[a\x01eV[a\x03\xC0V[\x90V[\x90V[a\x06Ba\x06=a\x06G\x92a\x06+V[a\x01eV[a\x03\xC0V[\x90V[\x90V[a\x06aa\x06\\a\x06f\x92a\x06JV[a\x01eV[a\x03\xC0V[\x90V[\x90V[a\x06\x80a\x06{a\x06\x85\x92a\x06iV[a\x01eV[a\x03\xC0V[\x90V[\x90V[a\x06\x9Fa\x06\x9Aa\x06\xA4\x92a\x06\x88V[a\x01eV[a\x03\xC0V[\x90V[\x90V[a\x06\xBEa\x06\xB9a\x06\xC3\x92a\x06\xA7V[a\x01eV[a\x03\xC0V[\x90V[\x90V[a\x06\xDDa\x06\xD8a\x06\xE2\x92a\x06\xC6V[a\x01eV[a\x03\xC0V[\x90V[a\x06\xF9a\x06\xF4a\x06\xFE\x92a\x01bV[a\x01eV[a\x03\xC0V[\x90V[`\x01a\x07\r\x91\x01a\x03\xC0V[\x90V[\x90V[a\x07'a\x07\"a\x07,\x92a\x07\x10V[a\x01eV[a\x03\xC0V[\x90V[\x90V[a\x07Fa\x07Aa\x07K\x92a\x07/V[a\x01eV[a\x03\xC0V[\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\x07qa\x07w\x91\x93\x92\x93a\x03\xC0V[\x92a\x03\xC0V[\x91a\x07\x83\x83\x82\x02a\x03\xC0V[\x92\x81\x84\x04\x14\x90\x15\x17\x15a\x07\x92WV[a\x07NV[a\x07\xA6a\x07\xAC\x91\x93\x92\x93a\x03\xC0V[\x92a\x03\xC0V[\x82\x01\x80\x92\x11a\x07\xB7WV[a\x07NV[\x90V[a\x07\xD3a\x07\xCEa\x07\xD8\x92a\x07\xBCV[a\x01eV[a\x03\xC0V[\x90V[a\x07\xE5`0a\x07\xBFV[\x90V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[P`\x08\x90V[\x90a\x08\x0C\x82a\x07\xFCV[\x81\x10\x15a\x08\x1AW` \x02\x01\x90V[a\x07\xE8V[a\x08)\x90Qa\x03\xC0V[\x90V[P`0\x90V[\x90V[a\x08>\x81a\x08,V[\x82\x10\x15a\x08XWa\x08P`\x01\x91a\x082V[\x91\x02\x01\x90_\x90V[a\x07\xE8V[\x1B\x90V[\x91\x90`\x08a\x08|\x91\x02\x91a\x08v_\x19\x84a\x08]V[\x92a\x08]V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x91\x90a\x08\x9Ca\x08\x97a\x08\xA4\x93a\x04\x02V[a\x04\x1EV[\x90\x83Ta\x08aV[\x90UV[a\x08\xB2`\x08a\x05\xCBV[a\x08\xD1a\x08\xC9j\x05\x9B\xD6Z\x1E\xCAm\xB6X\0\0a\x05\xE2V[_\x83\x01a\x05\xFEV[a\x08\xF1a\x08\xE8j\x03]\x80\x9Cx\xDF\xDBmh\0\0a\x06\x0FV[` \x83\x01a\x05\xFEV[a\t\x11a\t\x08j\x02\x04\xE6\xE0\t\xF3\xB7\xC3\xA0\0\0a\x06.V[`@\x83\x01a\x05\xFEV[a\t1a\t(j\x016$ \x05\xF8\xA1u`\0\0a\x06MV[``\x83\x01a\x05\xFEV[a\tPa\tGi\xBA\x15\xAC\xD0a\xFAy\xA0\0\0a\x06lV[`\x80\x83\x01a\x05\xFEV[a\toa\tfio\xA6\xD2fH\xCBL\xF0\0\0a\x06\x8BV[`\xA0\x83\x01a\x05\xFEV[a\t\x8Ea\t\x85iB\xFD^,I\xDD\xA88\0\0a\x06\xAAV[`\xC0\x83\x01a\x05\xFEV[a\t\xADa\t\xA4i(1\x9E\xE7_\x84\xFE\x88\0\0a\x06\xC9V[`\xE0\x83\x01a\x05\xFEV[a\t\xB6_a\x06\xE5V[\x91[\x82a\t\xCCa\t\xC6`\x08a\x07\x13V[\x91a\x03\xC0V[\x10\x15a\n\x82Wa\t\xDB_a\x06\xE5V[[\x80a\t\xF0a\t\xEA`\x06a\x072V[\x91a\x03\xC0V[\x10\x15a\nqWa\n>\x90a\n\x18a\n\x11\x86a\n\x0B`\x06a\x072V[\x90a\x07bV[\x82\x90a\x07\x97V[\x80a\n2a\n,a\n'a\x07\xDBV[a\x03\xC0V[\x91a\x03\xC0V[\x10a\nCW[Pa\x07\x01V[a\t\xDCV[a\nk\x90a\nea\n]a\nX\x88\x8A\x90a\x08\x02V[a\x08\x1FV[\x91`\x03a\x085V[\x90a\x08\x86V[_a\n8V[P\x91a\n|\x90a\x07\x01V[\x91a\t\xB8V[\x91PPV[_\x1C\x90V[`\xFF\x16\x90V[a\n\x9Ea\n\xA3\x91a\n\x87V[a\n\x8CV[\x90V[a\n\xB0\x90Ta\n\x92V[\x90V[a\n\xD9\x91_a\n\xCEa\n\xD4\x93a\n\xC7a\x04\xB4V[P\x82a\x04\xC4V[\x01a\x04\xF2V[a\n\xA6V[\x90V[_\x90V[a\n\xE8a\n\xDCV[P3\x90V\xFE`\x80`@R`\x046\x10\x15a\0\x13W[a\x11\xA4V[a\0\x1D_5a\x02,V[\x80c\x01\xFF\xC9\xA7\x14a\x02'W\x80c\x07\xA1\xD5\xFA\x14a\x02\"W\x80c\x13\xBE\xAA[\x14a\x02\x1DW\x80c\x1B\x02\xF8E\x14a\x02\x18W\x80c$:0\xCC\x14a\x02\x13W\x80c$\x81\xBB\\\x14a\x02\x0EW\x80c$\x8A\x9C\xA3\x14a\x02\tW\x80c(N\x133\x14a\x02\x04W\x80c//\xF1]\x14a\x01\xFFW\x80c3M\x0B\xBD\x14a\x01\xFAW\x80c6V\x8A\xBE\x14a\x01\xF5W\x80c?K\xA8:\x14a\x01\xF0W\x80cH\xB0\xDA\xA6\x14a\x01\xEBW\x80cZ\xDF\0!\x14a\x01\xE6W\x80c[\xDFl\xA1\x14a\x01\xE1W\x80c\\\x97Z\xBB\x14a\x01\xDCW\x80c_\x15\xC3\xC9\x14a\x01\xD7W\x80cvg\x18\x08\x14a\x01\xD2W\x80c\x84V\xCBY\x14a\x01\xCDW\x80c\x91\xD1HT\x14a\x01\xC8W\x80c\xA2\x17\xFD\xDF\x14a\x01\xC3W\x80c\xA3\xD4H[\x14a\x01\xBEW\x80c\xA4\xD7\xE3\x1D\x14a\x01\xB9W\x80c\xA5q\xE1\x84\x14a\x01\xB4W\x80c\xA5\xB3&\xBE\x14a\x01\xAFW\x80c\xA7\x0B\x9F\x0C\x14a\x01\xAAW\x80c\xAF*\xA6;\x14a\x01\xA5W\x80c\xBA\xBC9O\x14a\x01\xA0W\x80c\xD5Gt\x1F\x14a\x01\x9BW\x80c\xE3\xAB\xDF\xCB\x14a\x01\x96W\x80c\xE6:\xB1\xE9\x14a\x01\x91W\x80c\xF5\x08\xE1\x9D\x14a\x01\x8CWc\xF7^\x85\x12\x03a\0\x0EWa\x11oV[a\x11\x0BV[a\x10\xC7V[a\x10cV[a\x10\0V[a\x0F\xC7V[a\x0FTV[a\x0E\x8CV[a\x0E\x1EV[a\r\xEBV[a\riV[a\r4V[a\x0C\xAAV[a\x0C9V[a\x0C\x06V[a\x0B\xD1V[a\x0B\x8DV[a\x0B!V[a\n\xECV[a\neV[a\n0V[a\t\xEEV[a\t\xBAV[a\t\x85V[a\x08rV[a\x07\xE3V[a\x07\xAEV[a\x07\x13V[a\x05DV[a\x04\xB4V[a\x04\x80V[a\x03\xC4V[a\x02\xB8V[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x80\xFD[c\xFF\xFF\xFF\xFF`\xE0\x1B\x16\x90V[a\x02Y\x81a\x02DV[\x03a\x02`WV[_\x80\xFD[\x90P5\x90a\x02q\x82a\x02PV[V[\x90` \x82\x82\x03\x12a\x02\x8CWa\x02\x89\x91_\x01a\x02dV[\x90V[a\x02<V[\x15\x15\x90V[a\x02\x9F\x90a\x02\x91V[\x90RV[\x91\x90a\x02\xB6\x90_` \x85\x01\x94\x01\x90a\x02\x96V[V[4a\x02\xE8Wa\x02\xE4a\x02\xD3a\x02\xCE6`\x04a\x02sV[a\x11\xACV[a\x02\xDBa\x022V[\x91\x82\x91\x82a\x02\xA3V[\x03\x90\xF3[a\x028V[_\x91\x03\x12a\x02\xF7WV[a\x02<V[`\x01\x80`\xA0\x1B\x03\x16\x90V[\x90V[a\x03\x1Ea\x03\x19a\x03#\x92a\x02\xFCV[a\x03\x07V[a\x02\xFCV[\x90V[a\x03/\x90a\x03\nV[\x90V[a\x03;\x90a\x03&V[\x90V[a\x03G\x90a\x032V[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[`\x1F\x80\x19\x91\x01\x16\x90V[a\x03\x8Ca\x03\x95` \x93a\x03\x9A\x93a\x03\x83\x81a\x03KV[\x93\x84\x80\x93a\x03OV[\x95\x86\x91\x01a\x03XV[a\x03cV[\x01\x90V[\x91a\x03\xC1\x92a\x03\xB4`@\x82\x01\x93_\x83\x01\x90a\x03>V[` \x81\x84\x03\x91\x01Ra\x03mV[\x90V[4a\x03\xF5Wa\x03\xD46`\x04a\x02\xEDV[a\x03\xDCa\x12'V[\x90a\x03\xF1a\x03\xE8a\x022V[\x92\x83\x92\x83a\x03\x9EV[\x03\x90\xF3[a\x028V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x04@W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x04;W` \x01\x92`\x01\x83\x02\x84\x01\x11a\x046WV[a\x04\x02V[a\x03\xFEV[a\x03\xFAV[\x90` \x82\x82\x03\x12a\x04vW_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04qWa\x04m\x92\x01a\x04\x06V[\x90\x91V[a\x02@V[a\x02<V[_\x01\x90V[4a\x04\xAFWa\x04\x99a\x04\x936`\x04a\x04EV[\x90a\x15%V[a\x04\xA1a\x022V[\x80a\x04\xAB\x81a\x04{V[\x03\x90\xF3[a\x028V[4a\x04\xE2Wa\x04\xC46`\x04a\x02\xEDV[a\x04\xCCa\x16\xB7V[a\x04\xD4a\x022V[\x80a\x04\xDE\x81a\x04{V[\x03\x90\xF3[a\x028V[\x90V[\x90V[a\x05\x01a\x04\xFCa\x05\x06\x92a\x04\xE7V[a\x03\x07V[a\x04\xEAV[\x90V[a\x05\x14a\x0E\x10a\x04\xEDV[\x90V[a\x05\x1Fa\x05\tV[\x90V[a\x05+\x90a\x04\xEAV[\x90RV[\x91\x90a\x05B\x90_` \x85\x01\x94\x01\x90a\x05\"V[V[4a\x05tWa\x05T6`\x04a\x02\xEDV[a\x05pa\x05_a\x05\x17V[a\x05ga\x022V[\x91\x82\x91\x82a\x05/V[\x03\x90\xF3[a\x028V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x05\xC0W[` \x83\x10\x14a\x05\xBBWV[a\x05\x8CV[\x91`\x7F\x16\x91a\x05\xB0V[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x05\xF6a\x05\xEF\x83a\x05\xA0V[\x80\x94a\x05\xCAV[\x91`\x01\x81\x16\x90\x81_\x14a\x06MWP`\x01\x14a\x06\x11W[PPPV[a\x06\x1E\x91\x92\x93\x94Pa\x05\xD3V[\x91_\x92[\x81\x84\x10a\x065WPP\x01\x90_\x80\x80a\x06\x0CV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x06\"V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x06\x0CV[\x90a\x06r\x91a\x05\xDCV[\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x06\x93\x90a\x03cV[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x06\xADW`@RV[a\x06uV[\x90a\x06\xD2a\x06\xCB\x92a\x06\xC2a\x022V[\x93\x84\x80\x92a\x06hV[\x03\x83a\x06\x89V[V[\x90_\x10a\x06\xE7Wa\x06\xE4\x90a\x06\xB2V[\x90V[a\x05yV[a\x06\xF8`7_\x90a\x06\xD4V[\x90V[a\x07\x10\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x03mV[\x90V[4a\x07CWa\x07#6`\x04a\x02\xEDV[a\x07?a\x07.a\x06\xECV[a\x076a\x022V[\x91\x82\x91\x82a\x06\xFBV[\x03\x90\xF3[a\x028V[\x90V[a\x07T\x81a\x07HV[\x03a\x07[WV[_\x80\xFD[\x90P5\x90a\x07l\x82a\x07KV[V[\x90` \x82\x82\x03\x12a\x07\x87Wa\x07\x84\x91_\x01a\x07_V[\x90V[a\x02<V[a\x07\x95\x90a\x07HV[\x90RV[\x91\x90a\x07\xAC\x90_` \x85\x01\x94\x01\x90a\x07\x8CV[V[4a\x07\xDEWa\x07\xDAa\x07\xC9a\x07\xC46`\x04a\x07nV[a\x17\x0BV[a\x07\xD1a\x022V[\x91\x82\x91\x82a\x07\x99V[\x03\x90\xF3[a\x028V[4a\x08\x11Wa\x07\xF36`\x04a\x02\xEDV[a\x07\xFBa\x1D\x86V[a\x08\x03a\x022V[\x80a\x08\r\x81a\x04{V[\x03\x90\xF3[a\x028V[a\x08\x1F\x90a\x02\xFCV[\x90V[a\x08+\x81a\x08\x16V[\x03a\x082WV[_\x80\xFD[\x90P5\x90a\x08C\x82a\x08\"V[V[\x91\x90`@\x83\x82\x03\x12a\x08mW\x80a\x08aa\x08j\x92_\x86\x01a\x07_V[\x93` \x01a\x086V[\x90V[a\x02<V[4a\x08\xA1Wa\x08\x8Ba\x08\x856`\x04a\x08EV[\x90a\x1D\xBAV[a\x08\x93a\x022V[\x80a\x08\x9D\x81a\x04{V[\x03\x90\xF3[a\x028V[a\x08\xAF\x81a\x04\xEAV[\x03a\x08\xB6WV[_\x80\xFD[\x90P5\x90a\x08\xC7\x82a\x08\xA6V[V[\x90` \x82\x82\x03\x12a\x08\xE2Wa\x08\xDF\x91_\x01a\x08\xBAV[\x90V[a\x02<V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[P`0\x90V[\x90V[a\t\r\x81a\x08\xFBV[\x82\x10\x15a\t'Wa\t\x1F`\x01\x91a\t\x01V[\x91\x02\x01\x90_\x90V[a\x08\xE7V[\x1C\x90V[\x90V[a\tC\x90`\x08a\tH\x93\x02a\t,V[a\t0V[\x90V[\x90a\tV\x91Ta\t3V[\x90V[`\x03a\td\x81a\x08\xFBV[\x82\x10\x15a\t\x81Wa\t~\x91a\tx\x91a\t\x04V[\x90a\tKV[\x90V[_\x80\xFD[4a\t\xB5Wa\t\xB1a\t\xA0a\t\x9B6`\x04a\x08\xC9V[a\tYV[a\t\xA8a\x022V[\x91\x82\x91\x82a\x05/V[\x03\x90\xF3[a\x028V[4a\t\xE9Wa\t\xD3a\t\xCD6`\x04a\x08EV[\x90a\x1D\xC6V[a\t\xDBa\x022V[\x80a\t\xE5\x81a\x04{V[\x03\x90\xF3[a\x028V[4a\n\x1CWa\t\xFE6`\x04a\x02\xEDV[a\n\x06a\x1E2V[a\n\x0Ea\x022V[\x80a\n\x18\x81a\x04{V[\x03\x90\xF3[a\x028V[a\n-`3_\x90a\tKV[\x90V[4a\n`Wa\n@6`\x04a\x02\xEDV[a\n\\a\nKa\n!V[a\nSa\x022V[\x91\x82\x91\x82a\x05/V[\x03\x90\xF3[a\x028V[4a\n\x95Wa\nu6`\x04a\x02\xEDV[a\n\x91a\n\x80a\x1E<V[a\n\x88a\x022V[\x91\x82\x91\x82a\x02\xA3V[\x03\x90\xF3[a\x028V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[a\n\xC7\x90a\x03&V[\x90V[a\n\xD3\x90a\n\xBEV[\x90RV[\x91\x90a\n\xEA\x90_` \x85\x01\x94\x01\x90a\n\xCAV[V[4a\x0B\x1CWa\n\xFC6`\x04a\x02\xEDV[a\x0B\x18a\x0B\x07a\n\x9AV[a\x0B\x0Fa\x022V[\x91\x82\x91\x82a\n\xD7V[\x03\x90\xF3[a\x028V[4a\x0BQWa\x0B16`\x04a\x02\xEDV[a\x0BMa\x0B<a\x1E\x8CV[a\x0BDa\x022V[\x91\x82\x91\x82a\x02\xA3V[\x03\x90\xF3[a\x028V[\x90V[a\x0Bma\x0Bha\x0Br\x92a\x0BVV[a\x03\x07V[a\x04\xEAV[\x90V[a\x0B\x7F`0a\x0BYV[\x90V[a\x0B\x8Aa\x0BuV[\x90V[4a\x0B\xBDWa\x0B\x9D6`\x04a\x02\xEDV[a\x0B\xB9a\x0B\xA8a\x0B\x82V[a\x0B\xB0a\x022V[\x91\x82\x91\x82a\x05/V[\x03\x90\xF3[a\x028V[a\x0B\xCE`4_\x90a\tKV[\x90V[4a\x0C\x01Wa\x0B\xE16`\x04a\x02\xEDV[a\x0B\xFDa\x0B\xECa\x0B\xC2V[a\x0B\xF4a\x022V[\x91\x82\x91\x82a\x05/V[\x03\x90\xF3[a\x028V[4a\x0C4Wa\x0C\x166`\x04a\x02\xEDV[a\x0C\x1Ea\x1E\xC6V[a\x0C&a\x022V[\x80a\x0C0\x81a\x04{V[\x03\x90\xF3[a\x028V[4a\x0CjWa\x0Cfa\x0CUa\x0CO6`\x04a\x08EV[\x90a\x1E\xE6V[a\x0C]a\x022V[\x91\x82\x91\x82a\x02\xA3V[\x03\x90\xF3[a\x028V[\x90V[_\x1B\x90V[a\x0C\x8Ba\x0C\x86a\x0C\x90\x92a\x0CoV[a\x0CrV[a\x07HV[\x90V[a\x0C\x9C_a\x0CwV[\x90V[a\x0C\xA7a\x0C\x93V[\x90V[4a\x0C\xDAWa\x0C\xBA6`\x04a\x02\xEDV[a\x0C\xD6a\x0C\xC5a\x0C\x9FV[a\x0C\xCDa\x022V[\x91\x82\x91\x82a\x07\x99V[\x03\x90\xF3[a\x028V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x0C\xFA\x90`\x08a\x0C\xFF\x93\x02a\t,V[a\x0C\xDFV[\x90V[\x90a\r\r\x91Ta\x0C\xEAV[\x90V[a\r\x1C`6_\x90a\r\x02V[\x90V[\x91\x90a\r2\x90_` \x85\x01\x94\x01\x90a\x03>V[V[4a\rdWa\rD6`\x04a\x02\xEDV[a\r`a\rOa\r\x10V[a\rWa\x022V[\x91\x82\x91\x82a\r\x1FV[\x03\x90\xF3[a\x028V[4a\r\x99Wa\ry6`\x04a\x02\xEDV[a\r\x95a\r\x84a\x1F\x0FV[a\r\x8Ca\x022V[\x91\x82\x91\x82a\x02\xA3V[\x03\x90\xF3[a\x028V[a\r\xA7\x90a\x08\x16V[\x90V[a\r\xB3\x81a\r\x9EV[\x03a\r\xBAWV[_\x80\xFD[\x90P5\x90a\r\xCB\x82a\r\xAAV[V[\x90` \x82\x82\x03\x12a\r\xE6Wa\r\xE3\x91_\x01a\r\xBEV[\x90V[a\x02<V[4a\x0E\x19Wa\x0E\x03a\r\xFE6`\x04a\r\xCDV[a fV[a\x0E\x0Ba\x022V[\x80a\x0E\x15\x81a\x04{V[\x03\x90\xF3[a\x028V[4a\x0ENWa\x0E.6`\x04a\x02\xEDV[a\x0EJa\x0E9a \xC5V[a\x0EAa\x022V[\x91\x82\x91\x82a\x05/V[\x03\x90\xF3[a\x028V[\x90V[a\x0Eja\x0Eea\x0Eo\x92a\x0ESV[a\x03\x07V[a\x04\xEAV[\x90V[a\x0E~b'\x8D\0a\x0EVV[\x90V[a\x0E\x89a\x0ErV[\x90V[4a\x0E\xBCWa\x0E\x9C6`\x04a\x02\xEDV[a\x0E\xB8a\x0E\xA7a\x0E\x81V[a\x0E\xAFa\x022V[\x91\x82\x91\x82a\x05/V[\x03\x90\xF3[a\x028V[P`0\x90V[\x90P\x90V[\x90V[a\x0E\xD8\x90a\x04\xEAV[\x90RV[\x90a\x0E\xE9\x81` \x93a\x0E\xCFV[\x01\x90V[` \x01\x90V[a\x0F\x0Fa\x0F\ta\x0F\x02\x83a\x0E\xC1V[\x80\x94a\x0E\xC7V[\x91a\x0E\xCCV[_\x91[\x83\x83\x10a\x0F\x1FWPPPPV[a\x0F5a\x0F/`\x01\x92\x84Qa\x0E\xDCV[\x92a\x0E\xEDV[\x92\x01\x91\x90a\x0F\x12V[\x91\x90a\x0FR\x90_a\x06\0\x85\x01\x94\x01\x90a\x0E\xF3V[V[4a\x0F\x84Wa\x0Fd6`\x04a\x02\xEDV[a\x0F\x80a\x0Foa\"^V[a\x0Fwa\x022V[\x91\x82\x91\x82a\x0F>V[\x03\x90\xF3[a\x028V[a\x0F\xBEa\x0F\xC5\x94a\x0F\xB4``\x94\x98\x97\x95a\x0F\xAA`\x80\x86\x01\x9A_\x87\x01\x90a\x05\"V[` \x85\x01\x90a\x05\"V[`@\x83\x01\x90a\x05\"V[\x01\x90a\x02\x96V[V[4a\x0F\xFBWa\x0F\xD76`\x04a\x02\xEDV[a\x0F\xF7a\x0F\xE2a\"tV[\x90a\x0F\xEE\x94\x92\x94a\x022V[\x94\x85\x94\x85a\x0F\x89V[\x03\x90\xF3[a\x028V[4a\x10/Wa\x10\x19a\x10\x136`\x04a\x08EV[\x90a$\xA5V[a\x10!a\x022V[\x80a\x10+\x81a\x04{V[\x03\x90\xF3[a\x028V[\x7Fk\x97%\xF7@\xF9K\x91\xB7\x80`\xA1\xB1}\x17tem8\x14!\xA5)\xEC\x98\xCD\xB0\x13\xF4\xD9\xC2^\x90V[a\x10`a\x104V[\x90V[4a\x10\x93Wa\x10s6`\x04a\x02\xEDV[a\x10\x8Fa\x10~a\x10XV[a\x10\x86a\x022V[\x91\x82\x91\x82a\x07\x99V[\x03\x90\xF3[a\x028V[\x7Fe\xD7\xA2\x8E2e\xB3zdt\x92\x9F3e!\xB32\xC1h\x1B\x93?l\xB9\xF37fsD\r\x86*\x90V[a\x10\xC4a\x10\x98V[\x90V[4a\x10\xF7Wa\x10\xD76`\x04a\x02\xEDV[a\x10\xF3a\x10\xE2a\x10\xBCV[a\x10\xEAa\x022V[\x91\x82\x91\x82a\x07\x99V[\x03\x90\xF3[a\x028V[a\x11\x08`5_\x90a\tKV[\x90V[4a\x11;Wa\x11\x1B6`\x04a\x02\xEDV[a\x117a\x11&a\x10\xFCV[a\x11.a\x022V[\x91\x82\x91\x82a\x05/V[\x03\x90\xF3[a\x028V[\x7F\xCC\xE2\x96\xB0@3*\x08\x0Em\xF15\x15\xA3\xEC(i\xE2\x1C\xD2\x0FsD\xAF\t\x87\xDD\xB98\xD8\xBD!\x90V[a\x11la\x11@V[\x90V[4a\x11\x9FWa\x11\x7F6`\x04a\x02\xEDV[a\x11\x9Ba\x11\x8Aa\x11dV[a\x11\x92a\x022V[\x91\x82\x91\x82a\x07\x99V[\x03\x90\xF3[a\x028V[_\x80\xFD[_\x90V[a\x11\xB4a\x11\xA8V[P\x80a\x11\xCFa\x11\xC9cye\xDB\x0B`\xE0\x1Ba\x02DV[\x91a\x02DV[\x14\x90\x81\x15a\x11\xDCW[P\x90V[a\x11\xE6\x91Pa$\xB1V[_a\x11\xD8V[_\x90V[``\x90V[_\x1C\x90V[a\x12\x06a\x12\x0B\x91a\x11\xF5V[a\x0C\xDFV[\x90V[a\x12\x18\x90Ta\x11\xFAV[\x90V[a\x12$\x90a\x06\xB2V[\x90V[a\x12/a\x11\xECV[Pa\x128a\x11\xF0V[Pa\x12C`6a\x12\x0EV[\x90a\x12N`7a\x12\x1BV[\x90V[\x90a\x12k\x91a\x12fa\x12aa\x11@V[a$\xD7V[a\x14\xCFV[V[P\x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a\x12\x9A\x91\x02\x91a\x12\x94_\x19\x84a\x12{V[\x92a\x12{V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x12\xB8a\x12\xB3a\x12\xBD\x92a\x04\xEAV[a\x03\x07V[a\x04\xEAV[\x90V[\x90V[\x91\x90a\x12\xD9a\x12\xD4a\x12\xE1\x93a\x12\xA4V[a\x12\xC0V[\x90\x83Ta\x12\x7FV[\x90UV[_\x90V[a\x12\xFB\x91a\x12\xF5a\x12\xE5V[\x91a\x12\xC3V[V[[\x81\x81\x10a\x13\tWPPV[\x80a\x13\x16_`\x01\x93a\x12\xE9V[\x01a\x12\xFEV[\x91\x90`\x1F\x81\x11a\x13,W[PPPV[a\x138a\x13]\x93a\x05\xD3V[\x90` a\x13D\x84a\x12qV[\x83\x01\x93\x10a\x13eW[a\x13V\x90a\x12qV[\x01\x90a\x12\xFDV[_\x80\x80a\x13'V[\x91Pa\x13V\x81\x92\x90Pa\x13MV[\x90a\x13\x83\x90_\x19\x90`\x08\x02a\t,V[\x19\x16\x90V[\x81a\x13\x92\x91a\x13sV[\x90`\x02\x02\x17\x90V[\x91a\x13\xA5\x90\x82a\x12mV[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x14dWa\x13\xC9\x82a\x13\xC3\x85Ta\x05\xA0V[\x85a\x13\x1CV[_\x90`\x1F\x83\x11`\x01\x14a\x13\xFCW\x91\x80\x91a\x13\xEB\x93_\x92a\x13\xF0W[PPa\x13\x88V[\x90U[V[\x90\x91P\x015_\x80a\x13\xE4V[`\x1F\x19\x83\x16\x91a\x14\x0B\x85a\x05\xD3V[\x92_[\x81\x81\x10a\x14LWP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\x142W[PPP\x02\x01\x90Ua\x13\xEEV[a\x14B\x91\x015`\x1F\x84\x16\x90a\x13sV[\x90U_\x80\x80a\x14&V[\x91\x93` `\x01\x81\x92\x87\x87\x015\x81U\x01\x95\x01\x92\x01a\x14\x0EV[a\x06uV[\x90a\x14t\x92\x91a\x13\x9AV[V[\x90\x82_\x93\x92\x827\x01RV[\x91\x90a\x14\x9B\x81a\x14\x94\x81a\x14\xA0\x95a\x03OV[\x80\x95a\x14vV[a\x03cV[\x01\x90V[\x91a\x14\xBEa\x14\xCC\x94\x92`@\x85\x01\x90\x85\x82\x03_\x87\x01Ra\x03mV[\x92` \x81\x85\x03\x91\x01Ra\x14\x81V[\x90V[\x90a\x14\xDA`7a\x12\x1BV[a\x14\xE7\x83\x83\x90`7a\x14iV[\x91\x90\x91a\x15 \x7F\xB9\xA2\x08\x84&\xF0;0\xA8\x1C\x06B\x80\x94\xFB\xFA\x9E&\x92s\x9B2A\xAFk\x9A\xB1\xDAKUF\xBE\x93a\x15\x17a\x022V[\x93\x84\x93\x84a\x14\xA4V[\x03\x90\xA1V[\x90a\x15/\x91a\x12QV[V[a\x15Aa\x15<a\x104V[a$\xD7V[a\x15Ia\x15\xE6V[V[a\x15Wa\x15\\\x91a\x11\xF5V[a\t0V[\x90V[a\x15i\x90Ta\x15KV[\x90V[a\x15\x80a\x15{a\x15\x85\x92a\x0CoV[a\x03\x07V[a\x04\xEAV[\x90V[a\x15\x9Ca\x15\x97a\x15\xA1\x92a\x0CoV[a\x03\x07V[a\x02\xFCV[\x90V[a\x15\xAD\x90a\x15\x88V[\x90V[\x90a\x15\xBC_\x19\x91a\x0CrV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a\x15\xDBa\x15\xD6a\x15\xE2\x92a\x12\xA4V[a\x12\xC0V[\x82Ta\x15\xB0V[\x90UV[a\x15\xF0`3a\x15_V[a\x16\x02a\x15\xFC_a\x15lV[\x91a\x04\xEAV[\x03a\x16\x9BWa\x16\x19a\x16\x14`6a\x12\x0EV[a\x032V[a\x163a\x16-a\x16(_a\x15\xA4V[a\x08\x16V[\x91a\x08\x16V[\x14a\x16\x7FWa\x16CB`3a\x15\xC6V[Ba\x16z\x7F\x11\x94\xB04\xCF\xA9\xABX\x07IJ\x1D\\f}\x8B\x0En\x97\xF3\x88\x88t*\xA3\x87\x1A2 4\x11`\x91a\x16qa\x022V[\x91\x82\x91\x82a\x05/V[\x03\x90\xA1V[_c;\nH\xBD`\xE1\x1B\x81R\x80a\x16\x97`\x04\x82\x01a\x04{V[\x03\x90\xFD[_c8\xE9=\xBD`\xE1\x1B\x81R\x80a\x16\xB3`\x04\x82\x01a\x04{V[\x03\x90\xFD[a\x16\xBFa\x151V[V[_\x90V[a\x16\xCE\x90a\x07HV[\x90V[\x90a\x16\xDB\x90a\x16\xC5V[_R` R`@_ \x90V[\x90V[a\x16\xF6a\x16\xFB\x91a\x11\xF5V[a\x16\xE7V[\x90V[a\x17\x08\x90Ta\x16\xEAV[\x90V[`\x01a\x17#a\x17)\x92a\x17\x1Ca\x16\xC1V[P_a\x16\xD1V[\x01a\x16\xFEV[\x90V[a\x174a$\xEBV[a\x17<a\x17>V[V[a\x17Fa%AV[a\x17Na\x17XV[a\x17Va%\xA6V[V[a\x17ha\x17ca\x104V[a$\xD7V[a\x17pa\x19\x81V[V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\x17\x95a\x17\x9B\x91\x93\x92\x93a\x04\xEAV[\x92a\x04\xEAV[\x82\x03\x91\x82\x11a\x17\xA6WV[a\x17rV[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[a\x17\xCBa\x17\xD1\x91a\x04\xEAV[\x91a\x04\xEAV[\x90\x81\x15a\x17\xDCW\x04\x90V[a\x17\xABV[`\x01a\x17\xED\x91\x01a\x04\xEAV[\x90V[a\x17\xFFa\x18\x05\x91\x93\x92\x93a\x04\xEAV[\x92a\x04\xEAV[\x82\x01\x80\x92\x11a\x18\x10WV[a\x17rV[a\x18\x1E\x90a\x03&V[\x90V[_\x80\xFD[`\xE0\x1B\x90V[_\x91\x03\x12a\x185WV[a\x02<V[a\x18C\x90a\x08\x16V[\x90RV[\x91` a\x18h\x92\x94\x93a\x18a`@\x82\x01\x96_\x83\x01\x90a\x18:V[\x01\x90a\x05\"V[V[a\x18ra\x022V[=_\x82>=\x90\xFD[a\x18\x83\x90a\x03\nV[\x90V[a\x18\x8F\x90a\x18zV[\x90V[\x90_\x92\x91\x80T\x90a\x18\xACa\x18\xA5\x83a\x05\xA0V[\x80\x94a\x03OV[\x91`\x01\x81\x16\x90\x81_\x14a\x19\x03WP`\x01\x14a\x18\xC7W[PPPV[a\x18\xD4\x91\x92\x93\x94Pa\x05\xD3V[\x91_\x92[\x81\x84\x10a\x18\xEBWPP\x01\x90_\x80\x80a\x18\xC2V[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x18\xD8V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x18\xC2V[a\x19Ba\x19O\x94\x92\x93a\x198``\x84\x01\x95_\x85\x01\x90a\x18:V[` \x83\x01\x90a\x05\"V[`@\x81\x84\x03\x91\x01Ra\x18\x92V[\x90V[a\x19[\x90a\x03&V[\x90V[\x91` a\x19\x7F\x92\x94\x93a\x19x`@\x82\x01\x96_\x83\x01\x90a\x05\"V[\x01\x90a\x05\"V[V[a\x19\x8B`3a\x15_V[a\x19\x9Da\x19\x97_a\x15lV[\x91a\x04\xEAV[\x14a\x1DjWa\x19\xAAa\x1F\x0FV[a\x1DNWa\x19\xD3a\x19\xC5Ba\x19\xBF`3a\x15_V[\x90a\x17\x86V[a\x19\xCDa\x0ErV[\x90a\x17\xBFV[Ba\x19\xFEa\x19\xF8a\x19\xF3a\x19\xE5a \xC5V[a\x19\xEDa\x05\tV[\x90a\x17\x86V[a\x04\xEAV[\x91a\x04\xEAV[\x10a\x1D2Wa\x1A\x17\x90a\x1A\x11`4a\x15_V[\x90a\x17\x86V[\x90\x81a\x1AEa\x1A?a\x1A:a\x1A*a\x0BuV[a\x1A4`4a\x15_V[\x90a\x17\x86V[a\x04\xEAV[\x91a\x04\xEAV[\x11a\x1D\x0FW[a\x1AT_a\x15lV[\x90a\x1A^_a\x15lV[\x91[\x82a\x1Asa\x1Am\x86a\x04\xEAV[\x91a\x04\xEAV[\x10\x15a\x1A\xBAWa\x1A\xAEa\x1A\xB4\x91a\x1A\xA8a\x1A\xA2`\x03a\x1A\x9Ca\x1A\x95`4a\x15_V[\x89\x90a\x17\xF0V[\x90a\t\x04V[\x90a\tKV[\x90a\x17\xF0V[\x92a\x17\xE1V[\x91a\x1A`V[\x91P\x91a\x1A\xD3a\x1A\xDA\x91a\x1A\xCE`4a\x15_V[a\x17\xF0V[`4a\x15\xC6V[a\x1A\xF7a\x1A\xF0\x82a\x1A\xEB`5a\x15_V[a\x17\xF0V[`5a\x15\xC6V[a\x1B \x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\n\xBEV[c@\xC1\x0F\x19a\x1B.0a\x18\x15V[\x83\x92\x80;\x15a\x1D\nWa\x1BT_\x80\x94a\x1B_a\x1BHa\x022V[\x97\x88\x96\x87\x95\x86\x94a\x18%V[\x84R`\x04\x84\x01a\x18GV[\x03\x92Z\xF1\x80\x15a\x1D\x05Wa\x1C\xD9W[Pa\x1B\xBCa\x1B\xA3a\x1B\x9E\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\n\xBEV[a\x18\x86V[a\x1B\xB5a\x1B\xB0`6a\x12\x0EV[a\x032V[\x83\x91a&\x1BV[a\x1B\xCEa\x1B\xC9`6a\x12\x0EV[a\x032V[c\x18\xB6\x8B\x8Ca\x1B\xFC\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\n\xBEV[\x83\x92`7\x92\x81;\x15a\x1C\xD4W_a\x1C&\x91a\x1C1\x82\x96a\x1C\x1Aa\x022V[\x98\x89\x97\x88\x96\x87\x95a\x18%V[\x85R`\x04\x85\x01a\x19\x1EV[\x03\x92Z\xF1\x80\x15a\x1C\xCFWa\x1C\xA3W[Pa\x1CK`4a\x15_V[\x90a\x1C^a\x1CY`6a\x12\x0EV[a\x032V[\x90a\x1C\x89\x7F4\xB7=\x0C\x96\xE9\xFFMS\x11CH\x17\xC8\xEC\xC90\xE7\xD2x,[\xDE.y\xDCD\xB0YgU\xBB\x92a\x19RV[\x92a\x1C\x9Ea\x1C\x95a\x022V[\x92\x83\x92\x83a\x19^V[\x03\x90\xA2V[a\x1C\xC2\x90_=\x81\x11a\x1C\xC8W[a\x1C\xBA\x81\x83a\x06\x89V[\x81\x01\x90a\x18+V[_a\x1C@V[P=a\x1C\xB0V[a\x18jV[a\x18!V[a\x1C\xF8\x90_=\x81\x11a\x1C\xFEW[a\x1C\xF0\x81\x83a\x06\x89V[\x81\x01\x90a\x18+V[_a\x1BnV[P=a\x1C\xE6V[a\x18jV[a\x18!V[\x90Pa\x1D,a\x1D\x1Ca\x0BuV[a\x1D&`4a\x15_V[\x90a\x17\x86V[\x90a\x1AKV[_c=S\xC7S`\xE0\x1B\x81R\x80a\x1DJ`\x04\x82\x01a\x04{V[\x03\x90\xFD[_c\x11UbK`\xE2\x1B\x81R\x80a\x1Df`\x04\x82\x01a\x04{V[\x03\x90\xFD[_c\x8F\x98@A`\xE0\x1B\x81R\x80a\x1D\x82`\x04\x82\x01a\x04{V[\x03\x90\xFD[a\x1D\x8Ea\x17,V[V[\x90a\x1D\xAB\x91a\x1D\xA6a\x1D\xA1\x82a\x17\x0BV[a$\xD7V[a\x1D\xADV[V[\x90a\x1D\xB7\x91a'\x1CV[PV[\x90a\x1D\xC4\x91a\x1D\x90V[V[\x90\x80a\x1D\xE1a\x1D\xDBa\x1D\xD6a'\xCBV[a\x08\x16V[\x91a\x08\x16V[\x03a\x1D\xF2Wa\x1D\xEF\x91a'\xD8V[PV[_c3K\xD9\x19`\xE1\x1B\x81R\x80a\x1E\n`\x04\x82\x01a\x04{V[\x03\x90\xFD[a\x1E\x1Ea\x1E\x19a\x0C\x93V[a$\xD7V[a\x1E&a\x1E(V[V[a\x1E0a(\xEEV[V[a\x1E:a\x1E\x0EV[V[a\x1EDa\x11\xA8V[Pa\x1EO`3a\x15_V[a\x1Eaa\x1E[_a\x15lV[\x91a\x04\xEAV[\x11\x90V[`\xFF\x16\x90V[a\x1Ewa\x1E|\x91a\x11\xF5V[a\x1EeV[\x90V[a\x1E\x89\x90Ta\x1EkV[\x90V[a\x1E\x94a\x11\xA8V[Pa\x1E\x9F`\x01a\x1E\x7FV[\x90V[a\x1E\xB2a\x1E\xADa\x10\x98V[a$\xD7V[a\x1E\xBAa\x1E\xBCV[V[a\x1E\xC4a)XV[V[a\x1E\xCEa\x1E\xA2V[V[\x90a\x1E\xDA\x90a\x19RV[_R` R`@_ \x90V[a\x1F\x0C\x91_a\x1F\x01a\x1F\x07\x93a\x1E\xFAa\x11\xA8V[P\x82a\x16\xD1V[\x01a\x1E\xD0V[a\x1E\x7FV[\x90V[a\x1F\x17a\x11\xA8V[Pa\x1F\"`4a\x15_V[a\x1F;a\x1F5a\x1F0a\x0BuV[a\x04\xEAV[\x91a\x04\xEAV[\x10\x15\x90V[a\x1FY\x90a\x1FTa\x1FOa\x11@V[a$\xD7V[a\x1F\xB1V[V[\x90a\x1Fl`\x01\x80`\xA0\x1B\x03\x91a\x0CrV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x1F\x7F\x90a\x03\nV[\x90V[a\x1F\x8B\x90a\x1FvV[\x90V[\x90V[\x90a\x1F\xA6a\x1F\xA1a\x1F\xAD\x92a\x1F\x82V[a\x1F\x8EV[\x82Ta\x1F[V[\x90UV[a\x1F\xBA\x81a\x032V[a\x1F\xD4a\x1F\xCEa\x1F\xC9_a\x15\xA4V[a\x08\x16V[\x91a\x08\x16V[\x14a JWa\x1F\xFFa\x1F\xF9a\x1F\xE9`6a\x12\x0EV[a\x1F\xF4\x84`6a\x1F\x91V[a\x032V[\x91a\x032V[a 2a ,\x7F\x07\x01[j\x9F\x05\x911H\xFD_\xAD\xDF*\xCC\x97\x08\xF3\x05\x93\x7F0r\xCA+KF\xFA\xA5\xD0\x89\x8B\x93a\x19RV[\x91a\x19RV[\x91a ;a\x022V[\x80a E\x81a\x04{V[\x03\x90\xA3V[_c\xD9.#=`\xE0\x1B\x81R\x80a b`\x04\x82\x01a\x04{V[\x03\x90\xFD[a o\x90a\x1F@V[V[\x90V[a \x88a \x83a \x8D\x92a qV[a\x03\x07V[a\x04\xEAV[\x90V[a \x9Fa \xA5\x91\x93\x92\x93a\x04\xEAV[\x92a\x04\xEAV[\x91a \xB1\x83\x82\x02a\x04\xEAV[\x92\x81\x84\x04\x14\x90\x15\x17\x15a \xC0WV[a\x17rV[a \xCDa\x12\xE5V[Pa \xD8`3a\x15_V[a \xEAa \xE4_a\x15lV[\x91a\x04\xEAV[\x14a!3Wa!0a \xFC`3a\x15_V[a!*a!\x1Ca!\x0C`4a\x15_V[a!\x16`\x01a tV[\x90a\x17\xF0V[a!$a\x0ErV[\x90a \x90V[\x90a\x17\xF0V[\x90V[a!<_a\x15lV[\x90V[\x90a!Ra!Ka\x022V[\x92\x83a\x06\x89V[V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a!iW` \x02\x90V[a\x06uV[a!za!\x7F\x91a!TV[a!?V[\x90V[6\x907V[\x90a!\xA5a!\x94\x83a!nV[\x92a!\x9F\x84\x91a!TV[\x90a!\x82V[V[a!\xB1`0a!\x87V[\x90V[\x90P\x90V[a!\xC3\x90Ta\x15KV[\x90V[`\x01\x01\x90V[a!\xE8a!\xE2a!\xDB\x83a\x08\xFBV[\x80\x94a!\xB4V[\x91a\t\x01V[_\x91[\x83\x83\x10a!\xF8WPPPPV[a\"\x15a\"\x0F`\x01\x92a\"\n\x85a!\xB9V[a\x0E\xDCV[\x92a!\xC6V[\x92\x01\x91\x90a!\xEBV[\x90a\",\x81a\x06\0\x93a!\xCCV[\x01\x90V[\x90a\"Pa\"I\x92a\"@a\x022V[\x93\x84\x80\x92a\"\x1EV[\x03\x83a\x06\x89V[V[a\"[\x90a\"0V[\x90V[a\"fa!\xA7V[Pa\"q`\x03a\"RV[\x90V[a\"|a\x12\xE5V[Pa\"\x85a\x12\xE5V[Pa\"\x8Ea\x12\xE5V[Pa\"\x97a\x11\xA8V[Pa\"\xA2`3a\x15_V[a\"\xB4a\"\xAE_a\x15lV[\x91a\x04\xEAV[\x14a$UWa\"\xDEa\"\xD0Ba\"\xCA`3a\x15_V[\x90a\x17\x86V[a\"\xD8a\x0ErV[\x90a\x17\xBFV[\x90a# a\"\xEC`3a\x15_V[a#\x1Aa#\x0Ca\"\xFC`4a\x15_V[a#\x06`\x01a tV[\x90a\x17\xF0V[a#\x14a\x0ErV[\x90a \x90V[\x90a\x17\xF0V[a#*`4a\x15_V[a#Ca#=a#8a\x0BuV[a\x04\xEAV[\x91a\x04\xEAV[\x10_\x14a$GWa#ha#b`\x03a#\\`4a\x15_V[\x90a\t\x04V[\x90a\tKV[[\x92a#t`3a\x15_V[a#\x86a#\x80_a\x15lV[\x91a\x04\xEAV[\x11\x90\x81a$#W[P\x80a#\xF9W[\x80a#\xCDW[\x80a#\xB6W[\x91a#\xAC`4a\x15_V[\x91\x93\x92\x91\x93\x92\x91\x90V[Pa#\xC8a#\xC2a\x1E\x8CV[\x15a\x02\x91V[a#\xA1V[PBa#\xF2a#\xECa#\xE7\x84a#\xE1a\x05\tV[\x90a\x17\x86V[a\x04\xEAV[\x91a\x04\xEAV[\x10\x15a#\x9BV[Pa$\x04`4a\x15_V[a$\x1Da$\x17a$\x12a\x0BuV[a\x04\xEAV[\x91a\x04\xEAV[\x10a#\x95V[\x90Pa$@a$:a$5`4a\x15_V[a\x04\xEAV[\x91a\x04\xEAV[\x11_a#\x8EV[a$P_a\x15lV[a#iV[_\x90_\x91_\x91a$wa$qa$k_\x94a\x15lV[\x95a\x15lV[\x93a\x15lV[\x91\x90V[\x90a$\x96\x91a$\x91a$\x8C\x82a\x17\x0BV[a$\xD7V[a$\x98V[V[\x90a$\xA2\x91a'\xD8V[PV[\x90a$\xAF\x91a${V[V[a$\xB9a\x11\xA8V[Pa$\xD3a$\xCDc\x01\xFF\xC9\xA7`\xE0\x1Ba\x02DV[\x91a\x02DV[\x14\x90V[a$\xE9\x90a$\xE3a'\xCBV[\x90a)\x85V[V[a$\xF3a\x1E\x8CV[a$\xF9WV[_c\xD9<\x06e`\xE0\x1B\x81R\x80a%\x11`\x04\x82\x01a\x04{V[\x03\x90\xFD[\x90V[a%,a%'a%1\x92a%\x15V[a\x03\x07V[a\x04\xEAV[\x90V[a%>`\x02a%\x18V[\x90V[a%K`\x02a\x15_V[a%da%^a%Ya%4V[a\x04\xEAV[\x91a\x04\xEAV[\x14a%}Wa%{a%ta%4V[`\x02a\x15\xC6V[V[_c>\xE5\xAE\xB5`\xE0\x1B\x81R\x80a%\x95`\x04\x82\x01a\x04{V[\x03\x90\xFD[a%\xA3`\x01a tV[\x90V[a%\xB8a%\xB1a%\x99V[`\x02a\x15\xC6V[V[a%\xC3\x90a\x03&V[\x90V[c\xFF\xFF\xFF\xFF\x16\x90V[a%\xE3a%\xDEa%\xE8\x92a%\xC6V[a\x18%V[a\x02DV[\x90V[a%\xF4\x90a\x15lV[\x90RV[\x91` a&\x19\x92\x94\x93a&\x12`@\x82\x01\x96_\x83\x01\x90a\x18:V[\x01\x90a%\xEBV[V[\x90\x91a&^`\x04\x91a&Oc\t^\xA7\xB3a&6\x87\x93\x91a%\xCFV[\x92a&?a\x022V[\x95\x86\x94` \x86\x01\x90\x81R\x01a\x18GV[` \x82\x01\x81\x03\x82R\x03\x82a\x06\x89V[\x90a&sa&m\x82\x84\x90a)\xC0V[\x15a\x02\x91V[a&}W[PPPV[a&\xCA`\x04a&\xCF\x94a&\xC5\x84\x91a&\xB6c\t^\xA7\xB3a&\x9D_\x91a%\xCFV[\x92a&\xA6a\x022V[\x96\x87\x94` \x86\x01\x90\x81R\x01a%\xF8V[` \x82\x01\x81\x03\x82R\x03\x83a\x06\x89V[a*bV[a*bV[_\x80\x80a&xV[\x90a&\xE3`\xFF\x91a\x0CrV[\x91\x81\x19\x16\x91\x16\x17\x90V[a&\xF6\x90a\x02\x91V[\x90V[\x90V[\x90a'\x11a'\x0Ca'\x18\x92a&\xEDV[a&\xF9V[\x82Ta&\xD7V[\x90UV[a'$a\x11\xA8V[Pa'9a'3\x82\x84\x90a\x1E\xE6V[\x15a\x02\x91V[_\x14a'\xC1Wa'``\x01a'[_a'S\x81\x86\x90a\x16\xD1V[\x01\x85\x90a\x1E\xD0V[a&\xFCV[\x90a'ia'\xCBV[\x90a'\xA6a'\xA0a'\x9A\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a\x16\xC5V[\x92a\x19RV[\x92a\x19RV[\x92a'\xAFa\x022V[\x80a'\xB9\x81a\x04{V[\x03\x90\xA4`\x01\x90V[PP_\x90V[_\x90V[a'\xD3a'\xC7V[P3\x90V[a'\xE0a\x11\xA8V[Pa'\xEC\x81\x83\x90a\x1E\xE6V[_\x14a(sWa(\x12_a(\r_a(\x05\x81\x86\x90a\x16\xD1V[\x01\x85\x90a\x1E\xD0V[a&\xFCV[\x90a(\x1Ba'\xCBV[\x90a(Xa(Ra(L\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x95a\x16\xC5V[\x92a\x19RV[\x92a\x19RV[\x92a(aa\x022V[\x80a(k\x81a\x04{V[\x03\x90\xA4`\x01\x90V[PP_\x90V[a(\x81a+\x16V[a(\x89a(\xA0V[V[\x91\x90a(\x9E\x90_` \x85\x01\x94\x01\x90a\x18:V[V[a(\xAB_`\x01a&\xFCV[a(\xB3a'\xCBV[a(\xE9\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA\x91a(\xE0a\x022V[\x91\x82\x91\x82a(\x8BV[\x03\x90\xA1V[a(\xF6a(yV[V[a)\0a$\xEBV[a)\x08a)\nV[V[a)\x15`\x01\x80a&\xFCV[a)\x1Da'\xCBV[a)S\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2X\x91a)Ja\x022V[\x91\x82\x91\x82a(\x8BV[\x03\x90\xA1V[a)`a(\xF8V[V[\x91` a)\x83\x92\x94\x93a)|`@\x82\x01\x96_\x83\x01\x90a\x18:V[\x01\x90a\x07\x8CV[V[\x90a)\x9Aa)\x94\x83\x83\x90a\x1E\xE6V[\x15a\x02\x91V[a)\xA2WPPV[a)\xBC_\x92\x83\x92c\xE2Q}?`\xE0\x1B\x84R`\x04\x84\x01a)bV[\x03\x90\xFD[\x90_` \x91a)\xCDa\x11\xA8V[Pa)\xD6a\x11\xA8V[Pa)\xDFa\x12\xE5V[Pa)\xE8a\x12\xE5V[P\x82\x81Q\x91\x01\x82\x85Z\xF1=\x91_Q\x91\x92\x83a*\x04W[PPP\x90V[\x90\x91\x92Pa*\x1Aa*\x14_a\x15lV[\x91a\x04\xEAV[\x14_\x14a*HWa*+\x91Pa%\xBAV[;a*>a*8_a\x15lV[\x91a\x04\xEAV[\x11[_\x80\x80a)\xFEV[Pa*\\a*V`\x01a tV[\x91a\x04\xEAV[\x14a*@V[\x90_` \x91a*oa\x12\xE5V[Pa*xa\x12\xE5V[P\x82\x81Q\x91\x01\x82\x85Z\xF1\x15a+\x0BW=_Q\x90a*\x9Da*\x97_a\x15lV[\x91a\x04\xEAV[\x14_\x14a*\xF1WPa*\xAE\x81a%\xBAV[;a*\xC1a*\xBB_a\x15lV[\x91a\x04\xEAV[\x14[a*\xCAWPV[a*\xD6a*\xED\x91a%\xBAV[_\x91\x82\x91cRt\xAF\xE7`\xE0\x1B\x83R`\x04\x83\x01a(\x8BV[\x03\x90\xFD[a+\x04a*\xFE`\x01a tV[\x91a\x04\xEAV[\x14\x15a*\xC3V[`@Q=_\x82>=\x90\xFD[a+'a+!a\x1E\x8CV[\x15a\x02\x91V[a+-WV[_c\x8D\xFC +`\xE0\x1B\x81R\x80a+E`\x04\x82\x01a\x04{V[\x03\x90\xFD",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361015610013575b6111a4565b61001d5f3561022c565b806301ffc9a71461022757806307a1d5fa1461022257806313beaa5b1461021d5780631b02f84514610218578063243a30cc146102135780632481bb5c1461020e578063248a9ca314610209578063284e1333146102045780632f2ff15d146101ff578063334d0bbd146101fa57806336568abe146101f55780633f4ba83a146101f057806348b0daa6146101eb5780635adf0021146101e65780635bdf6ca1146101e15780635c975abb146101dc5780635f15c3c9146101d757806376671808146101d25780638456cb59146101cd57806391d14854146101c8578063a217fddf146101c3578063a3d4485b146101be578063a4d7e31d146101b9578063a571e184146101b4578063a5b326be146101af578063a70b9f0c146101aa578063af2aa63b146101a5578063babc394f146101a0578063d547741f1461019b578063e3abdfcb14610196578063e63ab1e914610191578063f508e19d1461018c5763f75e85120361000e5761116f565b61110b565b6110c7565b611063565b611000565b610fc7565b610f54565b610e8c565b610e1e565b610deb565b610d69565b610d34565b610caa565b610c39565b610c06565b610bd1565b610b8d565b610b21565b610aec565b610a65565b610a30565b6109ee565b6109ba565b610985565b610872565b6107e3565b6107ae565b610713565b610544565b6104b4565b610480565b6103c4565b6102b8565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b63ffffffff60e01b1690565b61025981610244565b0361026057565b5f80fd5b9050359061027182610250565b565b9060208282031261028c57610289915f01610264565b90565b61023c565b151590565b61029f90610291565b9052565b91906102b6905f60208501940190610296565b565b346102e8576102e46102d36102ce366004610273565b6111ac565b6102db610232565b918291826102a3565b0390f35b610238565b5f9103126102f757565b61023c565b60018060a01b031690565b90565b61031e610319610323926102fc565b610307565b6102fc565b90565b61032f9061030a565b90565b61033b90610326565b90565b61034790610332565b9052565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b61038c61039560209361039a936103838161034b565b9384809361034f565b95869101610358565b610363565b0190565b916103c1926103b460408201935f83019061033e565b602081840391015261036d565b90565b346103f5576103d43660046102ed565b6103dc611227565b906103f16103e8610232565b9283928361039e565b0390f35b610238565b5f80fd5b5f80fd5b5f80fd5b909182601f830112156104405781359167ffffffffffffffff831161043b57602001926001830284011161043657565b610402565b6103fe565b6103fa565b90602082820312610476575f82013567ffffffffffffffff81116104715761046d9201610406565b9091565b610240565b61023c565b5f0190565b346104af57610499610493366004610445565b90611525565b6104a1610232565b806104ab8161047b565b0390f35b610238565b346104e2576104c43660046102ed565b6104cc6116b7565b6104d4610232565b806104de8161047b565b0390f35b610238565b90565b90565b6105016104fc610506926104e7565b610307565b6104ea565b90565b610514610e106104ed565b90565b61051f610509565b90565b61052b906104ea565b9052565b9190610542905f60208501940190610522565b565b34610574576105543660046102ed565b61057061055f610517565b610567610232565b9182918261052f565b0390f35b610238565b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52602260045260245ffd5b90600160028304921680156105c0575b60208310146105bb57565b61058c565b91607f16916105b0565b60209181520190565b5f5260205f2090565b905f92918054906105f66105ef836105a0565b80946105ca565b916001811690815f1461064d5750600114610611575b505050565b61061e91929394506105d3565b915f925b81841061063557505001905f808061060c565b60018160209295939554848601520191019290610622565b92949550505060ff19168252151560200201905f808061060c565b90610672916105dc565b90565b634e487b7160e01b5f52604160045260245ffd5b9061069390610363565b810190811067ffffffffffffffff8211176106ad57604052565b610675565b906106d26106cb926106c2610232565b93848092610668565b0383610689565b565b905f106106e7576106e4906106b2565b90565b610579565b6106f860375f906106d4565b90565b6107109160208201915f81840391015261036d565b90565b34610743576107233660046102ed565b61073f61072e6106ec565b610736610232565b918291826106fb565b0390f35b610238565b90565b61075481610748565b0361075b57565b5f80fd5b9050359061076c8261074b565b565b9060208282031261078757610784915f0161075f565b90565b61023c565b61079590610748565b9052565b91906107ac905f6020850194019061078c565b565b346107de576107da6107c96107c436600461076e565b61170b565b6107d1610232565b91829182610799565b0390f35b610238565b34610811576107f33660046102ed565b6107fb611d86565b610803610232565b8061080d8161047b565b0390f35b610238565b61081f906102fc565b90565b61082b81610816565b0361083257565b5f80fd5b9050359061084382610822565b565b919060408382031261086d578061086161086a925f860161075f565b93602001610836565b90565b61023c565b346108a15761088b610885366004610845565b90611dba565b610893610232565b8061089d8161047b565b0390f35b610238565b6108af816104ea565b036108b657565b5f80fd5b905035906108c7826108a6565b565b906020828203126108e2576108df915f016108ba565b90565b61023c565b634e487b7160e01b5f52603260045260245ffd5b50603090565b90565b61090d816108fb565b8210156109275761091f600191610901565b910201905f90565b6108e7565b1c90565b90565b610943906008610948930261092c565b610930565b90565b906109569154610933565b90565b6003610964816108fb565b8210156109815761097e9161097891610904565b9061094b565b90565b5f80fd5b346109b5576109b16109a061099b3660046108c9565b610959565b6109a8610232565b9182918261052f565b0390f35b610238565b346109e9576109d36109cd366004610845565b90611dc6565b6109db610232565b806109e58161047b565b0390f35b610238565b34610a1c576109fe3660046102ed565b610a06611e32565b610a0e610232565b80610a188161047b565b0390f35b610238565b610a2d60335f9061094b565b90565b34610a6057610a403660046102ed565b610a5c610a4b610a21565b610a53610232565b9182918261052f565b0390f35b610238565b34610a9557610a753660046102ed565b610a91610a80611e3c565b610a88610232565b918291826102a3565b0390f35b610238565b7f000000000000000000000000000000000000000000000000000000000000000090565b610ac790610326565b90565b610ad390610abe565b9052565b9190610aea905f60208501940190610aca565b565b34610b1c57610afc3660046102ed565b610b18610b07610a9a565b610b0f610232565b91829182610ad7565b0390f35b610238565b34610b5157610b313660046102ed565b610b4d610b3c611e8c565b610b44610232565b918291826102a3565b0390f35b610238565b90565b610b6d610b68610b7292610b56565b610307565b6104ea565b90565b610b7f6030610b59565b90565b610b8a610b75565b90565b34610bbd57610b9d3660046102ed565b610bb9610ba8610b82565b610bb0610232565b9182918261052f565b0390f35b610238565b610bce60345f9061094b565b90565b34610c0157610be13660046102ed565b610bfd610bec610bc2565b610bf4610232565b9182918261052f565b0390f35b610238565b34610c3457610c163660046102ed565b610c1e611ec6565b610c26610232565b80610c308161047b565b0390f35b610238565b34610c6a57610c66610c55610c4f366004610845565b90611ee6565b610c5d610232565b918291826102a3565b0390f35b610238565b90565b5f1b90565b610c8b610c86610c9092610c6f565b610c72565b610748565b90565b610c9c5f610c77565b90565b610ca7610c93565b90565b34610cda57610cba3660046102ed565b610cd6610cc5610c9f565b610ccd610232565b91829182610799565b0390f35b610238565b60018060a01b031690565b610cfa906008610cff930261092c565b610cdf565b90565b90610d0d9154610cea565b90565b610d1c60365f90610d02565b90565b9190610d32905f6020850194019061033e565b565b34610d6457610d443660046102ed565b610d60610d4f610d10565b610d57610232565b91829182610d1f565b0390f35b610238565b34610d9957610d793660046102ed565b610d95610d84611f0f565b610d8c610232565b918291826102a3565b0390f35b610238565b610da790610816565b90565b610db381610d9e565b03610dba57565b5f80fd5b90503590610dcb82610daa565b565b90602082820312610de657610de3915f01610dbe565b90565b61023c565b34610e1957610e03610dfe366004610dcd565b612066565b610e0b610232565b80610e158161047b565b0390f35b610238565b34610e4e57610e2e3660046102ed565b610e4a610e396120c5565b610e41610232565b9182918261052f565b0390f35b610238565b90565b610e6a610e65610e6f92610e53565b610307565b6104ea565b90565b610e7e62278d00610e56565b90565b610e89610e72565b90565b34610ebc57610e9c3660046102ed565b610eb8610ea7610e81565b610eaf610232565b9182918261052f565b0390f35b610238565b50603090565b905090565b90565b610ed8906104ea565b9052565b90610ee981602093610ecf565b0190565b60200190565b610f0f610f09610f0283610ec1565b8094610ec7565b91610ecc565b5f915b838310610f1f5750505050565b610f35610f2f6001928451610edc565b92610eed565b92019190610f12565b9190610f52905f6106008501940190610ef3565b565b34610f8457610f643660046102ed565b610f80610f6f61225e565b610f77610232565b91829182610f3e565b0390f35b610238565b610fbe610fc594610fb4606094989795610faa608086019a5f870190610522565b6020850190610522565b6040830190610522565b0190610296565b565b34610ffb57610fd73660046102ed565b610ff7610fe2612274565b90610fee949294610232565b94859485610f89565b0390f35b610238565b3461102f57611019611013366004610845565b906124a5565b611021610232565b8061102b8161047b565b0390f35b610238565b7f6b9725f740f94b91b78060a1b17d1774656d381421a529ec98cdb013f4d9c25e90565b611060611034565b90565b34611093576110733660046102ed565b61108f61107e611058565b611086610232565b91829182610799565b0390f35b610238565b7f65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a90565b6110c4611098565b90565b346110f7576110d73660046102ed565b6110f36110e26110bc565b6110ea610232565b91829182610799565b0390f35b610238565b61110860355f9061094b565b90565b3461113b5761111b3660046102ed565b6111376111266110fc565b61112e610232565b9182918261052f565b0390f35b610238565b7fcce296b040332a080e6df13515a3ec2869e21cd20f7344af0987ddb938d8bd2190565b61116c611140565b90565b3461119f5761117f3660046102ed565b61119b61118a611164565b611192610232565b91829182610799565b0390f35b610238565b5f80fd5b5f90565b6111b46111a8565b50806111cf6111c9637965db0b60e01b610244565b91610244565b149081156111dc575b5090565b6111e691506124b1565b5f6111d8565b5f90565b606090565b5f1c90565b61120661120b916111f5565b610cdf565b90565b61121890546111fa565b90565b611224906106b2565b90565b61122f6111ec565b506112386111f0565b50611243603661120e565b9061124e603761121b565b90565b9061126b91611266611261611140565b6124d7565b6114cf565b565b5090565b601f602091010490565b1b90565b9190600861129a9102916112945f198461127b565b9261127b565b9181191691161790565b6112b86112b36112bd926104ea565b610307565b6104ea565b90565b90565b91906112d96112d46112e1936112a4565b6112c0565b90835461127f565b9055565b5f90565b6112fb916112f56112e5565b916112c3565b565b5b818110611309575050565b806113165f6001936112e9565b016112fe565b9190601f811161132c575b505050565b61133861135d936105d3565b90602061134484611271565b83019310611365575b61135690611271565b01906112fd565b5f8080611327565b91506113568192905061134d565b90611383905f199060080261092c565b191690565b8161139291611373565b906002021790565b916113a5908261126d565b9067ffffffffffffffff8211611464576113c9826113c385546105a0565b8561131c565b5f90601f83116001146113fc579180916113eb935f926113f0575b5050611388565b90555b565b90915001355f806113e4565b601f1983169161140b856105d3565b925f5b81811061144c57509160029391856001969410611432575b505050020190556113ee565b611442910135601f841690611373565b90555f8080611426565b9193602060018192878701358155019501920161140e565b610675565b90611474929161139a565b565b90825f939282370152565b919061149b81611494816114a09561034f565b8095611476565b610363565b0190565b916114be6114cc949260408501908582035f87015261036d565b926020818503910152611481565b90565b906114da603761121b565b6114e78383906037611469565b9190916115207fb9a2088426f03b30a81c06428094fbfa9e2692739b3241af6b9ab1da4b5546be93611517610232565b938493846114a4565b0390a1565b9061152f91611251565b565b61154161153c611034565b6124d7565b6115496115e6565b565b61155761155c916111f5565b610930565b90565b611569905461154b565b90565b61158061157b61158592610c6f565b610307565b6104ea565b90565b61159c6115976115a192610c6f565b610307565b6102fc565b90565b6115ad90611588565b90565b906115bc5f1991610c72565b9181191691161790565b906115db6115d66115e2926112a4565b6112c0565b82546115b0565b9055565b6115f0603361155f565b6116026115fc5f61156c565b916104ea565b0361169b57611619611614603661120e565b610332565b61163361162d6116285f6115a4565b610816565b91610816565b1461167f576116434260336115c6565b4261167a7f1194b034cfa9ab5807494a1d5c667d8b0e6e97f38888742aa3871a322034116091611671610232565b9182918261052f565b0390a1565b5f633b0a48bd60e11b8152806116976004820161047b565b0390fd5b5f6338e93dbd60e11b8152806116b36004820161047b565b0390fd5b6116bf611531565b565b5f90565b6116ce90610748565b90565b906116db906116c5565b5f5260205260405f2090565b90565b6116f66116fb916111f5565b6116e7565b90565b61170890546116ea565b90565b60016117236117299261171c6116c1565b505f6116d1565b016116fe565b90565b6117346124eb565b61173c61173e565b565b611746612541565b61174e611758565b6117566125a6565b565b611768611763611034565b6124d7565b611770611981565b565b634e487b7160e01b5f52601160045260245ffd5b61179561179b919392936104ea565b926104ea565b82039182116117a657565b611772565b634e487b7160e01b5f52601260045260245ffd5b6117cb6117d1916104ea565b916104ea565b9081156117dc570490565b6117ab565b60016117ed91016104ea565b90565b6117ff611805919392936104ea565b926104ea565b820180921161181057565b611772565b61181e90610326565b90565b5f80fd5b60e01b90565b5f91031261183557565b61023c565b61184390610816565b9052565b91602061186892949361186160408201965f83019061183a565b0190610522565b565b611872610232565b3d5f823e3d90fd5b6118839061030a565b90565b61188f9061187a565b90565b905f92918054906118ac6118a5836105a0565b809461034f565b916001811690815f1461190357506001146118c7575b505050565b6118d491929394506105d3565b915f925b8184106118eb57505001905f80806118c2565b600181602092959395548486015201910192906118d8565b92949550505060ff19168252151560200201905f80806118c2565b61194261194f94929361193860608401955f85019061183a565b6020830190610522565b6040818403910152611892565b90565b61195b90610326565b90565b91602061197f92949361197860408201965f830190610522565b0190610522565b565b61198b603361155f565b61199d6119975f61156c565b916104ea565b14611d6a576119aa611f0f565b611d4e576119d36119c5426119bf603361155f565b90611786565b6119cd610e72565b906117bf565b426119fe6119f86119f36119e56120c5565b6119ed610509565b90611786565b6104ea565b916104ea565b10611d3257611a1790611a11603461155f565b90611786565b9081611a45611a3f611a3a611a2a610b75565b611a34603461155f565b90611786565b6104ea565b916104ea565b11611d0f575b611a545f61156c565b90611a5e5f61156c565b915b82611a73611a6d866104ea565b916104ea565b1015611aba57611aae611ab491611aa8611aa26003611a9c611a95603461155f565b89906117f0565b90610904565b9061094b565b906117f0565b926117e1565b91611a60565b915091611ad3611ada91611ace603461155f565b6117f0565b60346115c6565b611af7611af082611aeb603561155f565b6117f0565b60356115c6565b611b207f0000000000000000000000000000000000000000000000000000000000000000610abe565b6340c10f19611b2e30611815565b8392803b15611d0a57611b545f8094611b5f611b48610232565b97889687958694611825565b845260048401611847565b03925af18015611d0557611cd9575b50611bbc611ba3611b9e7f0000000000000000000000000000000000000000000000000000000000000000610abe565b611886565b611bb5611bb0603661120e565b610332565b839161261b565b611bce611bc9603661120e565b610332565b6318b68b8c611bfc7f0000000000000000000000000000000000000000000000000000000000000000610abe565b8392603792813b15611cd4575f611c2691611c318296611c1a610232565b98899788968795611825565b85526004850161191e565b03925af18015611ccf57611ca3575b50611c4b603461155f565b90611c5e611c59603661120e565b610332565b90611c897f34b73d0c96e9ff4d5311434817c8ecc930e7d2782c5bde2e79dc44b0596755bb92611952565b92611c9e611c95610232565b9283928361195e565b0390a2565b611cc2905f3d8111611cc8575b611cba8183610689565b81019061182b565b5f611c40565b503d611cb0565b61186a565b611821565b611cf8905f3d8111611cfe575b611cf08183610689565b81019061182b565b5f611b6e565b503d611ce6565b61186a565b611821565b9050611d2c611d1c610b75565b611d26603461155f565b90611786565b90611a4b565b5f633d53c75360e01b815280611d4a6004820161047b565b0390fd5b5f631155624b60e21b815280611d666004820161047b565b0390fd5b5f638f98404160e01b815280611d826004820161047b565b0390fd5b611d8e61172c565b565b90611dab91611da6611da18261170b565b6124d7565b611dad565b565b90611db79161271c565b50565b90611dc491611d90565b565b9080611de1611ddb611dd66127cb565b610816565b91610816565b03611df257611def916127d8565b50565b5f63334bd91960e11b815280611e0a6004820161047b565b0390fd5b611e1e611e19610c93565b6124d7565b611e26611e28565b565b611e306128ee565b565b611e3a611e0e565b565b611e446111a8565b50611e4f603361155f565b611e61611e5b5f61156c565b916104ea565b1190565b60ff1690565b611e77611e7c916111f5565b611e65565b90565b611e899054611e6b565b90565b611e946111a8565b50611e9f6001611e7f565b90565b611eb2611ead611098565b6124d7565b611eba611ebc565b565b611ec4612958565b565b611ece611ea2565b565b90611eda90611952565b5f5260205260405f2090565b611f0c915f611f01611f0793611efa6111a8565b50826116d1565b01611ed0565b611e7f565b90565b611f176111a8565b50611f22603461155f565b611f3b611f35611f30610b75565b6104ea565b916104ea565b101590565b611f5990611f54611f4f611140565b6124d7565b611fb1565b565b90611f6c60018060a01b0391610c72565b9181191691161790565b611f7f9061030a565b90565b611f8b90611f76565b90565b90565b90611fa6611fa1611fad92611f82565b611f8e565b8254611f5b565b9055565b611fba81610332565b611fd4611fce611fc95f6115a4565b610816565b91610816565b1461204a57611fff611ff9611fe9603661120e565b611ff4846036611f91565b610332565b91610332565b61203261202c7f07015b6a9f05913148fd5faddf2acc9708f305937f3072ca2b4b46faa5d0898b93611952565b91611952565b9161203b610232565b806120458161047b565b0390a3565b5f63d92e233d60e01b8152806120626004820161047b565b0390fd5b61206f90611f40565b565b90565b61208861208361208d92612071565b610307565b6104ea565b90565b61209f6120a5919392936104ea565b926104ea565b916120b18382026104ea565b9281840414901517156120c057565b611772565b6120cd6112e5565b506120d8603361155f565b6120ea6120e45f61156c565b916104ea565b14612133576121306120fc603361155f565b61212a61211c61210c603461155f565b6121166001612074565b906117f0565b612124610e72565b90612090565b906117f0565b90565b61213c5f61156c565b90565b9061215261214b610232565b9283610689565b565b67ffffffffffffffff81116121695760200290565b610675565b61217a61217f91612154565b61213f565b90565b369037565b906121a56121948361216e565b9261219f8491612154565b90612182565b565b6121b16030612187565b90565b905090565b6121c3905461154b565b90565b60010190565b6121e86121e26121db836108fb565b80946121b4565b91610901565b5f915b8383106121f85750505050565b61221561220f60019261220a856121b9565b610edc565b926121c6565b920191906121eb565b9061222c81610600936121cc565b0190565b9061225061224992612240610232565b9384809261221e565b0383610689565b565b61225b90612230565b90565b6122666121a7565b506122716003612252565b90565b61227c6112e5565b506122856112e5565b5061228e6112e5565b506122976111a8565b506122a2603361155f565b6122b46122ae5f61156c565b916104ea565b14612455576122de6122d0426122ca603361155f565b90611786565b6122d8610e72565b906117bf565b906123206122ec603361155f565b61231a61230c6122fc603461155f565b6123066001612074565b906117f0565b612314610e72565b90612090565b906117f0565b61232a603461155f565b61234361233d612338610b75565b6104ea565b916104ea565b105f1461244757612368612362600361235c603461155f565b90610904565b9061094b565b5b92612374603361155f565b6123866123805f61156c565b916104ea565b119081612423575b50806123f9575b806123cd575b806123b6575b916123ac603461155f565b9193929193929190565b506123c86123c2611e8c565b15610291565b6123a1565b50426123f26123ec6123e7846123e1610509565b90611786565b6104ea565b916104ea565b101561239b565b50612404603461155f565b61241d612417612412610b75565b6104ea565b916104ea565b10612395565b905061244061243a612435603461155f565b6104ea565b916104ea565b115f61238e565b6124505f61156c565b612369565b5f905f915f9161247761247161246b5f9461156c565b9561156c565b9361156c565b9190565b906124969161249161248c8261170b565b6124d7565b612498565b565b906124a2916127d8565b50565b906124af9161247b565b565b6124b96111a8565b506124d36124cd6301ffc9a760e01b610244565b91610244565b1490565b6124e9906124e36127cb565b90612985565b565b6124f3611e8c565b6124f957565b5f63d93c066560e01b8152806125116004820161047b565b0390fd5b90565b61252c61252761253192612515565b610307565b6104ea565b90565b61253e6002612518565b90565b61254b600261155f565b61256461255e612559612534565b6104ea565b916104ea565b1461257d5761257b612574612534565b60026115c6565b565b5f633ee5aeb560e01b8152806125956004820161047b565b0390fd5b6125a36001612074565b90565b6125b86125b1612599565b60026115c6565b565b6125c390610326565b90565b63ffffffff1690565b6125e36125de6125e8926125c6565b611825565b610244565b90565b6125f49061156c565b9052565b91602061261992949361261260408201965f83019061183a565b01906125eb565b565b909161265e60049161264f63095ea7b36126368793916125cf565b9261263f610232565b9586946020860190815201611847565b60208201810382520382610689565b9061267361266d8284906129c0565b15610291565b61267d575b505050565b6126ca60046126cf946126c584916126b663095ea7b361269d5f916125cf565b926126a6610232565b96879460208601908152016125f8565b60208201810382520383610689565b612a62565b612a62565b5f8080612678565b906126e360ff91610c72565b9181191691161790565b6126f690610291565b90565b90565b9061271161270c612718926126ed565b6126f9565b82546126d7565b9055565b6127246111a8565b50612739612733828490611ee6565b15610291565b5f146127c157612760600161275b5f6127538186906116d1565b018590611ed0565b6126fc565b906127696127cb565b906127a66127a061279a7f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d956116c5565b92611952565b92611952565b926127af610232565b806127b98161047b565b0390a4600190565b50505f90565b5f90565b6127d36127c7565b503390565b6127e06111a8565b506127ec818390611ee6565b5f14612873576128125f61280d5f6128058186906116d1565b018590611ed0565b6126fc565b9061281b6127cb565b9061285861285261284c7ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b956116c5565b92611952565b92611952565b92612861610232565b8061286b8161047b565b0390a4600190565b50505f90565b612881612b16565b6128896128a0565b565b919061289e905f6020850194019061183a565b565b6128ab5f60016126fc565b6128b36127cb565b6128e97f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa916128e0610232565b9182918261288b565b0390a1565b6128f6612879565b565b6129006124eb565b61290861290a565b565b6129156001806126fc565b61291d6127cb565b6129537f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2589161294a610232565b9182918261288b565b0390a1565b6129606128f8565b565b91602061298392949361297c60408201965f83019061183a565b019061078c565b565b9061299a612994838390611ee6565b15610291565b6129a2575050565b6129bc5f92839263e2517d3f60e01b845260048401612962565b0390fd5b905f6020916129cd6111a8565b506129d66111a8565b506129df6112e5565b506129e86112e5565b50828151910182855af13d915f51919283612a04575b50505090565b90919250612a1a612a145f61156c565b916104ea565b145f14612a4857612a2b91506125ba565b3b612a3e612a385f61156c565b916104ea565b115b5f80806129fe565b50612a5c612a566001612074565b916104ea565b14612a40565b905f602091612a6f6112e5565b50612a786112e5565b50828151910182855af115612b0b573d5f5190612a9d612a975f61156c565b916104ea565b145f14612af15750612aae816125ba565b3b612ac1612abb5f61156c565b916104ea565b145b612aca5750565b612ad6612aed916125ba565b5f918291635274afe760e01b83526004830161288b565b0390fd5b612b04612afe6001612074565b916104ea565b1415612ac3565b6040513d5f823e3d90fd5b612b27612b21611e8c565b15610291565b612b2d57565b5f638dfc202b60e01b815280612b456004820161047b565b0390fd
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x13W[a\x11\xA4V[a\0\x1D_5a\x02,V[\x80c\x01\xFF\xC9\xA7\x14a\x02'W\x80c\x07\xA1\xD5\xFA\x14a\x02\"W\x80c\x13\xBE\xAA[\x14a\x02\x1DW\x80c\x1B\x02\xF8E\x14a\x02\x18W\x80c$:0\xCC\x14a\x02\x13W\x80c$\x81\xBB\\\x14a\x02\x0EW\x80c$\x8A\x9C\xA3\x14a\x02\tW\x80c(N\x133\x14a\x02\x04W\x80c//\xF1]\x14a\x01\xFFW\x80c3M\x0B\xBD\x14a\x01\xFAW\x80c6V\x8A\xBE\x14a\x01\xF5W\x80c?K\xA8:\x14a\x01\xF0W\x80cH\xB0\xDA\xA6\x14a\x01\xEBW\x80cZ\xDF\0!\x14a\x01\xE6W\x80c[\xDFl\xA1\x14a\x01\xE1W\x80c\\\x97Z\xBB\x14a\x01\xDCW\x80c_\x15\xC3\xC9\x14a\x01\xD7W\x80cvg\x18\x08\x14a\x01\xD2W\x80c\x84V\xCBY\x14a\x01\xCDW\x80c\x91\xD1HT\x14a\x01\xC8W\x80c\xA2\x17\xFD\xDF\x14a\x01\xC3W\x80c\xA3\xD4H[\x14a\x01\xBEW\x80c\xA4\xD7\xE3\x1D\x14a\x01\xB9W\x80c\xA5q\xE1\x84\x14a\x01\xB4W\x80c\xA5\xB3&\xBE\x14a\x01\xAFW\x80c\xA7\x0B\x9F\x0C\x14a\x01\xAAW\x80c\xAF*\xA6;\x14a\x01\xA5W\x80c\xBA\xBC9O\x14a\x01\xA0W\x80c\xD5Gt\x1F\x14a\x01\x9BW\x80c\xE3\xAB\xDF\xCB\x14a\x01\x96W\x80c\xE6:\xB1\xE9\x14a\x01\x91W\x80c\xF5\x08\xE1\x9D\x14a\x01\x8CWc\xF7^\x85\x12\x03a\0\x0EWa\x11oV[a\x11\x0BV[a\x10\xC7V[a\x10cV[a\x10\0V[a\x0F\xC7V[a\x0FTV[a\x0E\x8CV[a\x0E\x1EV[a\r\xEBV[a\riV[a\r4V[a\x0C\xAAV[a\x0C9V[a\x0C\x06V[a\x0B\xD1V[a\x0B\x8DV[a\x0B!V[a\n\xECV[a\neV[a\n0V[a\t\xEEV[a\t\xBAV[a\t\x85V[a\x08rV[a\x07\xE3V[a\x07\xAEV[a\x07\x13V[a\x05DV[a\x04\xB4V[a\x04\x80V[a\x03\xC4V[a\x02\xB8V[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x80\xFD[c\xFF\xFF\xFF\xFF`\xE0\x1B\x16\x90V[a\x02Y\x81a\x02DV[\x03a\x02`WV[_\x80\xFD[\x90P5\x90a\x02q\x82a\x02PV[V[\x90` \x82\x82\x03\x12a\x02\x8CWa\x02\x89\x91_\x01a\x02dV[\x90V[a\x02<V[\x15\x15\x90V[a\x02\x9F\x90a\x02\x91V[\x90RV[\x91\x90a\x02\xB6\x90_` \x85\x01\x94\x01\x90a\x02\x96V[V[4a\x02\xE8Wa\x02\xE4a\x02\xD3a\x02\xCE6`\x04a\x02sV[a\x11\xACV[a\x02\xDBa\x022V[\x91\x82\x91\x82a\x02\xA3V[\x03\x90\xF3[a\x028V[_\x91\x03\x12a\x02\xF7WV[a\x02<V[`\x01\x80`\xA0\x1B\x03\x16\x90V[\x90V[a\x03\x1Ea\x03\x19a\x03#\x92a\x02\xFCV[a\x03\x07V[a\x02\xFCV[\x90V[a\x03/\x90a\x03\nV[\x90V[a\x03;\x90a\x03&V[\x90V[a\x03G\x90a\x032V[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[`\x1F\x80\x19\x91\x01\x16\x90V[a\x03\x8Ca\x03\x95` \x93a\x03\x9A\x93a\x03\x83\x81a\x03KV[\x93\x84\x80\x93a\x03OV[\x95\x86\x91\x01a\x03XV[a\x03cV[\x01\x90V[\x91a\x03\xC1\x92a\x03\xB4`@\x82\x01\x93_\x83\x01\x90a\x03>V[` \x81\x84\x03\x91\x01Ra\x03mV[\x90V[4a\x03\xF5Wa\x03\xD46`\x04a\x02\xEDV[a\x03\xDCa\x12'V[\x90a\x03\xF1a\x03\xE8a\x022V[\x92\x83\x92\x83a\x03\x9EV[\x03\x90\xF3[a\x028V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x04@W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x04;W` \x01\x92`\x01\x83\x02\x84\x01\x11a\x046WV[a\x04\x02V[a\x03\xFEV[a\x03\xFAV[\x90` \x82\x82\x03\x12a\x04vW_\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04qWa\x04m\x92\x01a\x04\x06V[\x90\x91V[a\x02@V[a\x02<V[_\x01\x90V[4a\x04\xAFWa\x04\x99a\x04\x936`\x04a\x04EV[\x90a\x15%V[a\x04\xA1a\x022V[\x80a\x04\xAB\x81a\x04{V[\x03\x90\xF3[a\x028V[4a\x04\xE2Wa\x04\xC46`\x04a\x02\xEDV[a\x04\xCCa\x16\xB7V[a\x04\xD4a\x022V[\x80a\x04\xDE\x81a\x04{V[\x03\x90\xF3[a\x028V[\x90V[\x90V[a\x05\x01a\x04\xFCa\x05\x06\x92a\x04\xE7V[a\x03\x07V[a\x04\xEAV[\x90V[a\x05\x14a\x0E\x10a\x04\xEDV[\x90V[a\x05\x1Fa\x05\tV[\x90V[a\x05+\x90a\x04\xEAV[\x90RV[\x91\x90a\x05B\x90_` \x85\x01\x94\x01\x90a\x05\"V[V[4a\x05tWa\x05T6`\x04a\x02\xEDV[a\x05pa\x05_a\x05\x17V[a\x05ga\x022V[\x91\x82\x91\x82a\x05/V[\x03\x90\xF3[a\x028V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x05\xC0W[` \x83\x10\x14a\x05\xBBWV[a\x05\x8CV[\x91`\x7F\x16\x91a\x05\xB0V[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x05\xF6a\x05\xEF\x83a\x05\xA0V[\x80\x94a\x05\xCAV[\x91`\x01\x81\x16\x90\x81_\x14a\x06MWP`\x01\x14a\x06\x11W[PPPV[a\x06\x1E\x91\x92\x93\x94Pa\x05\xD3V[\x91_\x92[\x81\x84\x10a\x065WPP\x01\x90_\x80\x80a\x06\x0CV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x06\"V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x06\x0CV[\x90a\x06r\x91a\x05\xDCV[\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x06\x93\x90a\x03cV[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x06\xADW`@RV[a\x06uV[\x90a\x06\xD2a\x06\xCB\x92a\x06\xC2a\x022V[\x93\x84\x80\x92a\x06hV[\x03\x83a\x06\x89V[V[\x90_\x10a\x06\xE7Wa\x06\xE4\x90a\x06\xB2V[\x90V[a\x05yV[a\x06\xF8`7_\x90a\x06\xD4V[\x90V[a\x07\x10\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x03mV[\x90V[4a\x07CWa\x07#6`\x04a\x02\xEDV[a\x07?a\x07.a\x06\xECV[a\x076a\x022V[\x91\x82\x91\x82a\x06\xFBV[\x03\x90\xF3[a\x028V[\x90V[a\x07T\x81a\x07HV[\x03a\x07[WV[_\x80\xFD[\x90P5\x90a\x07l\x82a\x07KV[V[\x90` \x82\x82\x03\x12a\x07\x87Wa\x07\x84\x91_\x01a\x07_V[\x90V[a\x02<V[a\x07\x95\x90a\x07HV[\x90RV[\x91\x90a\x07\xAC\x90_` \x85\x01\x94\x01\x90a\x07\x8CV[V[4a\x07\xDEWa\x07\xDAa\x07\xC9a\x07\xC46`\x04a\x07nV[a\x17\x0BV[a\x07\xD1a\x022V[\x91\x82\x91\x82a\x07\x99V[\x03\x90\xF3[a\x028V[4a\x08\x11Wa\x07\xF36`\x04a\x02\xEDV[a\x07\xFBa\x1D\x86V[a\x08\x03a\x022V[\x80a\x08\r\x81a\x04{V[\x03\x90\xF3[a\x028V[a\x08\x1F\x90a\x02\xFCV[\x90V[a\x08+\x81a\x08\x16V[\x03a\x082WV[_\x80\xFD[\x90P5\x90a\x08C\x82a\x08\"V[V[\x91\x90`@\x83\x82\x03\x12a\x08mW\x80a\x08aa\x08j\x92_\x86\x01a\x07_V[\x93` \x01a\x086V[\x90V[a\x02<V[4a\x08\xA1Wa\x08\x8Ba\x08\x856`\x04a\x08EV[\x90a\x1D\xBAV[a\x08\x93a\x022V[\x80a\x08\x9D\x81a\x04{V[\x03\x90\xF3[a\x028V[a\x08\xAF\x81a\x04\xEAV[\x03a\x08\xB6WV[_\x80\xFD[\x90P5\x90a\x08\xC7\x82a\x08\xA6V[V[\x90` \x82\x82\x03\x12a\x08\xE2Wa\x08\xDF\x91_\x01a\x08\xBAV[\x90V[a\x02<V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[P`0\x90V[\x90V[a\t\r\x81a\x08\xFBV[\x82\x10\x15a\t'Wa\t\x1F`\x01\x91a\t\x01V[\x91\x02\x01\x90_\x90V[a\x08\xE7V[\x1C\x90V[\x90V[a\tC\x90`\x08a\tH\x93\x02a\t,V[a\t0V[\x90V[\x90a\tV\x91Ta\t3V[\x90V[`\x03a\td\x81a\x08\xFBV[\x82\x10\x15a\t\x81Wa\t~\x91a\tx\x91a\t\x04V[\x90a\tKV[\x90V[_\x80\xFD[4a\t\xB5Wa\t\xB1a\t\xA0a\t\x9B6`\x04a\x08\xC9V[a\tYV[a\t\xA8a\x022V[\x91\x82\x91\x82a\x05/V[\x03\x90\xF3[a\x028V[4a\t\xE9Wa\t\xD3a\t\xCD6`\x04a\x08EV[\x90a\x1D\xC6V[a\t\xDBa\x022V[\x80a\t\xE5\x81a\x04{V[\x03\x90\xF3[a\x028V[4a\n\x1CWa\t\xFE6`\x04a\x02\xEDV[a\n\x06a\x1E2V[a\n\x0Ea\x022V[\x80a\n\x18\x81a\x04{V[\x03\x90\xF3[a\x028V[a\n-`3_\x90a\tKV[\x90V[4a\n`Wa\n@6`\x04a\x02\xEDV[a\n\\a\nKa\n!V[a\nSa\x022V[\x91\x82\x91\x82a\x05/V[\x03\x90\xF3[a\x028V[4a\n\x95Wa\nu6`\x04a\x02\xEDV[a\n\x91a\n\x80a\x1E<V[a\n\x88a\x022V[\x91\x82\x91\x82a\x02\xA3V[\x03\x90\xF3[a\x028V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[a\n\xC7\x90a\x03&V[\x90V[a\n\xD3\x90a\n\xBEV[\x90RV[\x91\x90a\n\xEA\x90_` \x85\x01\x94\x01\x90a\n\xCAV[V[4a\x0B\x1CWa\n\xFC6`\x04a\x02\xEDV[a\x0B\x18a\x0B\x07a\n\x9AV[a\x0B\x0Fa\x022V[\x91\x82\x91\x82a\n\xD7V[\x03\x90\xF3[a\x028V[4a\x0BQWa\x0B16`\x04a\x02\xEDV[a\x0BMa\x0B<a\x1E\x8CV[a\x0BDa\x022V[\x91\x82\x91\x82a\x02\xA3V[\x03\x90\xF3[a\x028V[\x90V[a\x0Bma\x0Bha\x0Br\x92a\x0BVV[a\x03\x07V[a\x04\xEAV[\x90V[a\x0B\x7F`0a\x0BYV[\x90V[a\x0B\x8Aa\x0BuV[\x90V[4a\x0B\xBDWa\x0B\x9D6`\x04a\x02\xEDV[a\x0B\xB9a\x0B\xA8a\x0B\x82V[a\x0B\xB0a\x022V[\x91\x82\x91\x82a\x05/V[\x03\x90\xF3[a\x028V[a\x0B\xCE`4_\x90a\tKV[\x90V[4a\x0C\x01Wa\x0B\xE16`\x04a\x02\xEDV[a\x0B\xFDa\x0B\xECa\x0B\xC2V[a\x0B\xF4a\x022V[\x91\x82\x91\x82a\x05/V[\x03\x90\xF3[a\x028V[4a\x0C4Wa\x0C\x166`\x04a\x02\xEDV[a\x0C\x1Ea\x1E\xC6V[a\x0C&a\x022V[\x80a\x0C0\x81a\x04{V[\x03\x90\xF3[a\x028V[4a\x0CjWa\x0Cfa\x0CUa\x0CO6`\x04a\x08EV[\x90a\x1E\xE6V[a\x0C]a\x022V[\x91\x82\x91\x82a\x02\xA3V[\x03\x90\xF3[a\x028V[\x90V[_\x1B\x90V[a\x0C\x8Ba\x0C\x86a\x0C\x90\x92a\x0CoV[a\x0CrV[a\x07HV[\x90V[a\x0C\x9C_a\x0CwV[\x90V[a\x0C\xA7a\x0C\x93V[\x90V[4a\x0C\xDAWa\x0C\xBA6`\x04a\x02\xEDV[a\x0C\xD6a\x0C\xC5a\x0C\x9FV[a\x0C\xCDa\x022V[\x91\x82\x91\x82a\x07\x99V[\x03\x90\xF3[a\x028V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x0C\xFA\x90`\x08a\x0C\xFF\x93\x02a\t,V[a\x0C\xDFV[\x90V[\x90a\r\r\x91Ta\x0C\xEAV[\x90V[a\r\x1C`6_\x90a\r\x02V[\x90V[\x91\x90a\r2\x90_` \x85\x01\x94\x01\x90a\x03>V[V[4a\rdWa\rD6`\x04a\x02\xEDV[a\r`a\rOa\r\x10V[a\rWa\x022V[\x91\x82\x91\x82a\r\x1FV[\x03\x90\xF3[a\x028V[4a\r\x99Wa\ry6`\x04a\x02\xEDV[a\r\x95a\r\x84a\x1F\x0FV[a\r\x8Ca\x022V[\x91\x82\x91\x82a\x02\xA3V[\x03\x90\xF3[a\x028V[a\r\xA7\x90a\x08\x16V[\x90V[a\r\xB3\x81a\r\x9EV[\x03a\r\xBAWV[_\x80\xFD[\x90P5\x90a\r\xCB\x82a\r\xAAV[V[\x90` \x82\x82\x03\x12a\r\xE6Wa\r\xE3\x91_\x01a\r\xBEV[\x90V[a\x02<V[4a\x0E\x19Wa\x0E\x03a\r\xFE6`\x04a\r\xCDV[a fV[a\x0E\x0Ba\x022V[\x80a\x0E\x15\x81a\x04{V[\x03\x90\xF3[a\x028V[4a\x0ENWa\x0E.6`\x04a\x02\xEDV[a\x0EJa\x0E9a \xC5V[a\x0EAa\x022V[\x91\x82\x91\x82a\x05/V[\x03\x90\xF3[a\x028V[\x90V[a\x0Eja\x0Eea\x0Eo\x92a\x0ESV[a\x03\x07V[a\x04\xEAV[\x90V[a\x0E~b'\x8D\0a\x0EVV[\x90V[a\x0E\x89a\x0ErV[\x90V[4a\x0E\xBCWa\x0E\x9C6`\x04a\x02\xEDV[a\x0E\xB8a\x0E\xA7a\x0E\x81V[a\x0E\xAFa\x022V[\x91\x82\x91\x82a\x05/V[\x03\x90\xF3[a\x028V[P`0\x90V[\x90P\x90V[\x90V[a\x0E\xD8\x90a\x04\xEAV[\x90RV[\x90a\x0E\xE9\x81` \x93a\x0E\xCFV[\x01\x90V[` \x01\x90V[a\x0F\x0Fa\x0F\ta\x0F\x02\x83a\x0E\xC1V[\x80\x94a\x0E\xC7V[\x91a\x0E\xCCV[_\x91[\x83\x83\x10a\x0F\x1FWPPPPV[a\x0F5a\x0F/`\x01\x92\x84Qa\x0E\xDCV[\x92a\x0E\xEDV[\x92\x01\x91\x90a\x0F\x12V[\x91\x90a\x0FR\x90_a\x06\0\x85\x01\x94\x01\x90a\x0E\xF3V[V[4a\x0F\x84Wa\x0Fd6`\x04a\x02\xEDV[a\x0F\x80a\x0Foa\"^V[a\x0Fwa\x022V[\x91\x82\x91\x82a\x0F>V[\x03\x90\xF3[a\x028V[a\x0F\xBEa\x0F\xC5\x94a\x0F\xB4``\x94\x98\x97\x95a\x0F\xAA`\x80\x86\x01\x9A_\x87\x01\x90a\x05\"V[` \x85\x01\x90a\x05\"V[`@\x83\x01\x90a\x05\"V[\x01\x90a\x02\x96V[V[4a\x0F\xFBWa\x0F\xD76`\x04a\x02\xEDV[a\x0F\xF7a\x0F\xE2a\"tV[\x90a\x0F\xEE\x94\x92\x94a\x022V[\x94\x85\x94\x85a\x0F\x89V[\x03\x90\xF3[a\x028V[4a\x10/Wa\x10\x19a\x10\x136`\x04a\x08EV[\x90a$\xA5V[a\x10!a\x022V[\x80a\x10+\x81a\x04{V[\x03\x90\xF3[a\x028V[\x7Fk\x97%\xF7@\xF9K\x91\xB7\x80`\xA1\xB1}\x17tem8\x14!\xA5)\xEC\x98\xCD\xB0\x13\xF4\xD9\xC2^\x90V[a\x10`a\x104V[\x90V[4a\x10\x93Wa\x10s6`\x04a\x02\xEDV[a\x10\x8Fa\x10~a\x10XV[a\x10\x86a\x022V[\x91\x82\x91\x82a\x07\x99V[\x03\x90\xF3[a\x028V[\x7Fe\xD7\xA2\x8E2e\xB3zdt\x92\x9F3e!\xB32\xC1h\x1B\x93?l\xB9\xF37fsD\r\x86*\x90V[a\x10\xC4a\x10\x98V[\x90V[4a\x10\xF7Wa\x10\xD76`\x04a\x02\xEDV[a\x10\xF3a\x10\xE2a\x10\xBCV[a\x10\xEAa\x022V[\x91\x82\x91\x82a\x07\x99V[\x03\x90\xF3[a\x028V[a\x11\x08`5_\x90a\tKV[\x90V[4a\x11;Wa\x11\x1B6`\x04a\x02\xEDV[a\x117a\x11&a\x10\xFCV[a\x11.a\x022V[\x91\x82\x91\x82a\x05/V[\x03\x90\xF3[a\x028V[\x7F\xCC\xE2\x96\xB0@3*\x08\x0Em\xF15\x15\xA3\xEC(i\xE2\x1C\xD2\x0FsD\xAF\t\x87\xDD\xB98\xD8\xBD!\x90V[a\x11la\x11@V[\x90V[4a\x11\x9FWa\x11\x7F6`\x04a\x02\xEDV[a\x11\x9Ba\x11\x8Aa\x11dV[a\x11\x92a\x022V[\x91\x82\x91\x82a\x07\x99V[\x03\x90\xF3[a\x028V[_\x80\xFD[_\x90V[a\x11\xB4a\x11\xA8V[P\x80a\x11\xCFa\x11\xC9cye\xDB\x0B`\xE0\x1Ba\x02DV[\x91a\x02DV[\x14\x90\x81\x15a\x11\xDCW[P\x90V[a\x11\xE6\x91Pa$\xB1V[_a\x11\xD8V[_\x90V[``\x90V[_\x1C\x90V[a\x12\x06a\x12\x0B\x91a\x11\xF5V[a\x0C\xDFV[\x90V[a\x12\x18\x90Ta\x11\xFAV[\x90V[a\x12$\x90a\x06\xB2V[\x90V[a\x12/a\x11\xECV[Pa\x128a\x11\xF0V[Pa\x12C`6a\x12\x0EV[\x90a\x12N`7a\x12\x1BV[\x90V[\x90a\x12k\x91a\x12fa\x12aa\x11@V[a$\xD7V[a\x14\xCFV[V[P\x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a\x12\x9A\x91\x02\x91a\x12\x94_\x19\x84a\x12{V[\x92a\x12{V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x12\xB8a\x12\xB3a\x12\xBD\x92a\x04\xEAV[a\x03\x07V[a\x04\xEAV[\x90V[\x90V[\x91\x90a\x12\xD9a\x12\xD4a\x12\xE1\x93a\x12\xA4V[a\x12\xC0V[\x90\x83Ta\x12\x7FV[\x90UV[_\x90V[a\x12\xFB\x91a\x12\xF5a\x12\xE5V[\x91a\x12\xC3V[V[[\x81\x81\x10a\x13\tWPPV[\x80a\x13\x16_`\x01\x93a\x12\xE9V[\x01a\x12\xFEV[\x91\x90`\x1F\x81\x11a\x13,W[PPPV[a\x138a\x13]\x93a\x05\xD3V[\x90` a\x13D\x84a\x12qV[\x83\x01\x93\x10a\x13eW[a\x13V\x90a\x12qV[\x01\x90a\x12\xFDV[_\x80\x80a\x13'V[\x91Pa\x13V\x81\x92\x90Pa\x13MV[\x90a\x13\x83\x90_\x19\x90`\x08\x02a\t,V[\x19\x16\x90V[\x81a\x13\x92\x91a\x13sV[\x90`\x02\x02\x17\x90V[\x91a\x13\xA5\x90\x82a\x12mV[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x14dWa\x13\xC9\x82a\x13\xC3\x85Ta\x05\xA0V[\x85a\x13\x1CV[_\x90`\x1F\x83\x11`\x01\x14a\x13\xFCW\x91\x80\x91a\x13\xEB\x93_\x92a\x13\xF0W[PPa\x13\x88V[\x90U[V[\x90\x91P\x015_\x80a\x13\xE4V[`\x1F\x19\x83\x16\x91a\x14\x0B\x85a\x05\xD3V[\x92_[\x81\x81\x10a\x14LWP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\x142W[PPP\x02\x01\x90Ua\x13\xEEV[a\x14B\x91\x015`\x1F\x84\x16\x90a\x13sV[\x90U_\x80\x80a\x14&V[\x91\x93` `\x01\x81\x92\x87\x87\x015\x81U\x01\x95\x01\x92\x01a\x14\x0EV[a\x06uV[\x90a\x14t\x92\x91a\x13\x9AV[V[\x90\x82_\x93\x92\x827\x01RV[\x91\x90a\x14\x9B\x81a\x14\x94\x81a\x14\xA0\x95a\x03OV[\x80\x95a\x14vV[a\x03cV[\x01\x90V[\x91a\x14\xBEa\x14\xCC\x94\x92`@\x85\x01\x90\x85\x82\x03_\x87\x01Ra\x03mV[\x92` \x81\x85\x03\x91\x01Ra\x14\x81V[\x90V[\x90a\x14\xDA`7a\x12\x1BV[a\x14\xE7\x83\x83\x90`7a\x14iV[\x91\x90\x91a\x15 \x7F\xB9\xA2\x08\x84&\xF0;0\xA8\x1C\x06B\x80\x94\xFB\xFA\x9E&\x92s\x9B2A\xAFk\x9A\xB1\xDAKUF\xBE\x93a\x15\x17a\x022V[\x93\x84\x93\x84a\x14\xA4V[\x03\x90\xA1V[\x90a\x15/\x91a\x12QV[V[a\x15Aa\x15<a\x104V[a$\xD7V[a\x15Ia\x15\xE6V[V[a\x15Wa\x15\\\x91a\x11\xF5V[a\t0V[\x90V[a\x15i\x90Ta\x15KV[\x90V[a\x15\x80a\x15{a\x15\x85\x92a\x0CoV[a\x03\x07V[a\x04\xEAV[\x90V[a\x15\x9Ca\x15\x97a\x15\xA1\x92a\x0CoV[a\x03\x07V[a\x02\xFCV[\x90V[a\x15\xAD\x90a\x15\x88V[\x90V[\x90a\x15\xBC_\x19\x91a\x0CrV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a\x15\xDBa\x15\xD6a\x15\xE2\x92a\x12\xA4V[a\x12\xC0V[\x82Ta\x15\xB0V[\x90UV[a\x15\xF0`3a\x15_V[a\x16\x02a\x15\xFC_a\x15lV[\x91a\x04\xEAV[\x03a\x16\x9BWa\x16\x19a\x16\x14`6a\x12\x0EV[a\x032V[a\x163a\x16-a\x16(_a\x15\xA4V[a\x08\x16V[\x91a\x08\x16V[\x14a\x16\x7FWa\x16CB`3a\x15\xC6V[Ba\x16z\x7F\x11\x94\xB04\xCF\xA9\xABX\x07IJ\x1D\\f}\x8B\x0En\x97\xF3\x88\x88t*\xA3\x87\x1A2 4\x11`\x91a\x16qa\x022V[\x91\x82\x91\x82a\x05/V[\x03\x90\xA1V[_c;\nH\xBD`\xE1\x1B\x81R\x80a\x16\x97`\x04\x82\x01a\x04{V[\x03\x90\xFD[_c8\xE9=\xBD`\xE1\x1B\x81R\x80a\x16\xB3`\x04\x82\x01a\x04{V[\x03\x90\xFD[a\x16\xBFa\x151V[V[_\x90V[a\x16\xCE\x90a\x07HV[\x90V[\x90a\x16\xDB\x90a\x16\xC5V[_R` R`@_ \x90V[\x90V[a\x16\xF6a\x16\xFB\x91a\x11\xF5V[a\x16\xE7V[\x90V[a\x17\x08\x90Ta\x16\xEAV[\x90V[`\x01a\x17#a\x17)\x92a\x17\x1Ca\x16\xC1V[P_a\x16\xD1V[\x01a\x16\xFEV[\x90V[a\x174a$\xEBV[a\x17<a\x17>V[V[a\x17Fa%AV[a\x17Na\x17XV[a\x17Va%\xA6V[V[a\x17ha\x17ca\x104V[a$\xD7V[a\x17pa\x19\x81V[V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\x17\x95a\x17\x9B\x91\x93\x92\x93a\x04\xEAV[\x92a\x04\xEAV[\x82\x03\x91\x82\x11a\x17\xA6WV[a\x17rV[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[a\x17\xCBa\x17\xD1\x91a\x04\xEAV[\x91a\x04\xEAV[\x90\x81\x15a\x17\xDCW\x04\x90V[a\x17\xABV[`\x01a\x17\xED\x91\x01a\x04\xEAV[\x90V[a\x17\xFFa\x18\x05\x91\x93\x92\x93a\x04\xEAV[\x92a\x04\xEAV[\x82\x01\x80\x92\x11a\x18\x10WV[a\x17rV[a\x18\x1E\x90a\x03&V[\x90V[_\x80\xFD[`\xE0\x1B\x90V[_\x91\x03\x12a\x185WV[a\x02<V[a\x18C\x90a\x08\x16V[\x90RV[\x91` a\x18h\x92\x94\x93a\x18a`@\x82\x01\x96_\x83\x01\x90a\x18:V[\x01\x90a\x05\"V[V[a\x18ra\x022V[=_\x82>=\x90\xFD[a\x18\x83\x90a\x03\nV[\x90V[a\x18\x8F\x90a\x18zV[\x90V[\x90_\x92\x91\x80T\x90a\x18\xACa\x18\xA5\x83a\x05\xA0V[\x80\x94a\x03OV[\x91`\x01\x81\x16\x90\x81_\x14a\x19\x03WP`\x01\x14a\x18\xC7W[PPPV[a\x18\xD4\x91\x92\x93\x94Pa\x05\xD3V[\x91_\x92[\x81\x84\x10a\x18\xEBWPP\x01\x90_\x80\x80a\x18\xC2V[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x18\xD8V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x18\xC2V[a\x19Ba\x19O\x94\x92\x93a\x198``\x84\x01\x95_\x85\x01\x90a\x18:V[` \x83\x01\x90a\x05\"V[`@\x81\x84\x03\x91\x01Ra\x18\x92V[\x90V[a\x19[\x90a\x03&V[\x90V[\x91` a\x19\x7F\x92\x94\x93a\x19x`@\x82\x01\x96_\x83\x01\x90a\x05\"V[\x01\x90a\x05\"V[V[a\x19\x8B`3a\x15_V[a\x19\x9Da\x19\x97_a\x15lV[\x91a\x04\xEAV[\x14a\x1DjWa\x19\xAAa\x1F\x0FV[a\x1DNWa\x19\xD3a\x19\xC5Ba\x19\xBF`3a\x15_V[\x90a\x17\x86V[a\x19\xCDa\x0ErV[\x90a\x17\xBFV[Ba\x19\xFEa\x19\xF8a\x19\xF3a\x19\xE5a \xC5V[a\x19\xEDa\x05\tV[\x90a\x17\x86V[a\x04\xEAV[\x91a\x04\xEAV[\x10a\x1D2Wa\x1A\x17\x90a\x1A\x11`4a\x15_V[\x90a\x17\x86V[\x90\x81a\x1AEa\x1A?a\x1A:a\x1A*a\x0BuV[a\x1A4`4a\x15_V[\x90a\x17\x86V[a\x04\xEAV[\x91a\x04\xEAV[\x11a\x1D\x0FW[a\x1AT_a\x15lV[\x90a\x1A^_a\x15lV[\x91[\x82a\x1Asa\x1Am\x86a\x04\xEAV[\x91a\x04\xEAV[\x10\x15a\x1A\xBAWa\x1A\xAEa\x1A\xB4\x91a\x1A\xA8a\x1A\xA2`\x03a\x1A\x9Ca\x1A\x95`4a\x15_V[\x89\x90a\x17\xF0V[\x90a\t\x04V[\x90a\tKV[\x90a\x17\xF0V[\x92a\x17\xE1V[\x91a\x1A`V[\x91P\x91a\x1A\xD3a\x1A\xDA\x91a\x1A\xCE`4a\x15_V[a\x17\xF0V[`4a\x15\xC6V[a\x1A\xF7a\x1A\xF0\x82a\x1A\xEB`5a\x15_V[a\x17\xF0V[`5a\x15\xC6V[a\x1B \x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\n\xBEV[c@\xC1\x0F\x19a\x1B.0a\x18\x15V[\x83\x92\x80;\x15a\x1D\nWa\x1BT_\x80\x94a\x1B_a\x1BHa\x022V[\x97\x88\x96\x87\x95\x86\x94a\x18%V[\x84R`\x04\x84\x01a\x18GV[\x03\x92Z\xF1\x80\x15a\x1D\x05Wa\x1C\xD9W[Pa\x1B\xBCa\x1B\xA3a\x1B\x9E\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\n\xBEV[a\x18\x86V[a\x1B\xB5a\x1B\xB0`6a\x12\x0EV[a\x032V[\x83\x91a&\x1BV[a\x1B\xCEa\x1B\xC9`6a\x12\x0EV[a\x032V[c\x18\xB6\x8B\x8Ca\x1B\xFC\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\n\xBEV[\x83\x92`7\x92\x81;\x15a\x1C\xD4W_a\x1C&\x91a\x1C1\x82\x96a\x1C\x1Aa\x022V[\x98\x89\x97\x88\x96\x87\x95a\x18%V[\x85R`\x04\x85\x01a\x19\x1EV[\x03\x92Z\xF1\x80\x15a\x1C\xCFWa\x1C\xA3W[Pa\x1CK`4a\x15_V[\x90a\x1C^a\x1CY`6a\x12\x0EV[a\x032V[\x90a\x1C\x89\x7F4\xB7=\x0C\x96\xE9\xFFMS\x11CH\x17\xC8\xEC\xC90\xE7\xD2x,[\xDE.y\xDCD\xB0YgU\xBB\x92a\x19RV[\x92a\x1C\x9Ea\x1C\x95a\x022V[\x92\x83\x92\x83a\x19^V[\x03\x90\xA2V[a\x1C\xC2\x90_=\x81\x11a\x1C\xC8W[a\x1C\xBA\x81\x83a\x06\x89V[\x81\x01\x90a\x18+V[_a\x1C@V[P=a\x1C\xB0V[a\x18jV[a\x18!V[a\x1C\xF8\x90_=\x81\x11a\x1C\xFEW[a\x1C\xF0\x81\x83a\x06\x89V[\x81\x01\x90a\x18+V[_a\x1BnV[P=a\x1C\xE6V[a\x18jV[a\x18!V[\x90Pa\x1D,a\x1D\x1Ca\x0BuV[a\x1D&`4a\x15_V[\x90a\x17\x86V[\x90a\x1AKV[_c=S\xC7S`\xE0\x1B\x81R\x80a\x1DJ`\x04\x82\x01a\x04{V[\x03\x90\xFD[_c\x11UbK`\xE2\x1B\x81R\x80a\x1Df`\x04\x82\x01a\x04{V[\x03\x90\xFD[_c\x8F\x98@A`\xE0\x1B\x81R\x80a\x1D\x82`\x04\x82\x01a\x04{V[\x03\x90\xFD[a\x1D\x8Ea\x17,V[V[\x90a\x1D\xAB\x91a\x1D\xA6a\x1D\xA1\x82a\x17\x0BV[a$\xD7V[a\x1D\xADV[V[\x90a\x1D\xB7\x91a'\x1CV[PV[\x90a\x1D\xC4\x91a\x1D\x90V[V[\x90\x80a\x1D\xE1a\x1D\xDBa\x1D\xD6a'\xCBV[a\x08\x16V[\x91a\x08\x16V[\x03a\x1D\xF2Wa\x1D\xEF\x91a'\xD8V[PV[_c3K\xD9\x19`\xE1\x1B\x81R\x80a\x1E\n`\x04\x82\x01a\x04{V[\x03\x90\xFD[a\x1E\x1Ea\x1E\x19a\x0C\x93V[a$\xD7V[a\x1E&a\x1E(V[V[a\x1E0a(\xEEV[V[a\x1E:a\x1E\x0EV[V[a\x1EDa\x11\xA8V[Pa\x1EO`3a\x15_V[a\x1Eaa\x1E[_a\x15lV[\x91a\x04\xEAV[\x11\x90V[`\xFF\x16\x90V[a\x1Ewa\x1E|\x91a\x11\xF5V[a\x1EeV[\x90V[a\x1E\x89\x90Ta\x1EkV[\x90V[a\x1E\x94a\x11\xA8V[Pa\x1E\x9F`\x01a\x1E\x7FV[\x90V[a\x1E\xB2a\x1E\xADa\x10\x98V[a$\xD7V[a\x1E\xBAa\x1E\xBCV[V[a\x1E\xC4a)XV[V[a\x1E\xCEa\x1E\xA2V[V[\x90a\x1E\xDA\x90a\x19RV[_R` R`@_ \x90V[a\x1F\x0C\x91_a\x1F\x01a\x1F\x07\x93a\x1E\xFAa\x11\xA8V[P\x82a\x16\xD1V[\x01a\x1E\xD0V[a\x1E\x7FV[\x90V[a\x1F\x17a\x11\xA8V[Pa\x1F\"`4a\x15_V[a\x1F;a\x1F5a\x1F0a\x0BuV[a\x04\xEAV[\x91a\x04\xEAV[\x10\x15\x90V[a\x1FY\x90a\x1FTa\x1FOa\x11@V[a$\xD7V[a\x1F\xB1V[V[\x90a\x1Fl`\x01\x80`\xA0\x1B\x03\x91a\x0CrV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x1F\x7F\x90a\x03\nV[\x90V[a\x1F\x8B\x90a\x1FvV[\x90V[\x90V[\x90a\x1F\xA6a\x1F\xA1a\x1F\xAD\x92a\x1F\x82V[a\x1F\x8EV[\x82Ta\x1F[V[\x90UV[a\x1F\xBA\x81a\x032V[a\x1F\xD4a\x1F\xCEa\x1F\xC9_a\x15\xA4V[a\x08\x16V[\x91a\x08\x16V[\x14a JWa\x1F\xFFa\x1F\xF9a\x1F\xE9`6a\x12\x0EV[a\x1F\xF4\x84`6a\x1F\x91V[a\x032V[\x91a\x032V[a 2a ,\x7F\x07\x01[j\x9F\x05\x911H\xFD_\xAD\xDF*\xCC\x97\x08\xF3\x05\x93\x7F0r\xCA+KF\xFA\xA5\xD0\x89\x8B\x93a\x19RV[\x91a\x19RV[\x91a ;a\x022V[\x80a E\x81a\x04{V[\x03\x90\xA3V[_c\xD9.#=`\xE0\x1B\x81R\x80a b`\x04\x82\x01a\x04{V[\x03\x90\xFD[a o\x90a\x1F@V[V[\x90V[a \x88a \x83a \x8D\x92a qV[a\x03\x07V[a\x04\xEAV[\x90V[a \x9Fa \xA5\x91\x93\x92\x93a\x04\xEAV[\x92a\x04\xEAV[\x91a \xB1\x83\x82\x02a\x04\xEAV[\x92\x81\x84\x04\x14\x90\x15\x17\x15a \xC0WV[a\x17rV[a \xCDa\x12\xE5V[Pa \xD8`3a\x15_V[a \xEAa \xE4_a\x15lV[\x91a\x04\xEAV[\x14a!3Wa!0a \xFC`3a\x15_V[a!*a!\x1Ca!\x0C`4a\x15_V[a!\x16`\x01a tV[\x90a\x17\xF0V[a!$a\x0ErV[\x90a \x90V[\x90a\x17\xF0V[\x90V[a!<_a\x15lV[\x90V[\x90a!Ra!Ka\x022V[\x92\x83a\x06\x89V[V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a!iW` \x02\x90V[a\x06uV[a!za!\x7F\x91a!TV[a!?V[\x90V[6\x907V[\x90a!\xA5a!\x94\x83a!nV[\x92a!\x9F\x84\x91a!TV[\x90a!\x82V[V[a!\xB1`0a!\x87V[\x90V[\x90P\x90V[a!\xC3\x90Ta\x15KV[\x90V[`\x01\x01\x90V[a!\xE8a!\xE2a!\xDB\x83a\x08\xFBV[\x80\x94a!\xB4V[\x91a\t\x01V[_\x91[\x83\x83\x10a!\xF8WPPPPV[a\"\x15a\"\x0F`\x01\x92a\"\n\x85a!\xB9V[a\x0E\xDCV[\x92a!\xC6V[\x92\x01\x91\x90a!\xEBV[\x90a\",\x81a\x06\0\x93a!\xCCV[\x01\x90V[\x90a\"Pa\"I\x92a\"@a\x022V[\x93\x84\x80\x92a\"\x1EV[\x03\x83a\x06\x89V[V[a\"[\x90a\"0V[\x90V[a\"fa!\xA7V[Pa\"q`\x03a\"RV[\x90V[a\"|a\x12\xE5V[Pa\"\x85a\x12\xE5V[Pa\"\x8Ea\x12\xE5V[Pa\"\x97a\x11\xA8V[Pa\"\xA2`3a\x15_V[a\"\xB4a\"\xAE_a\x15lV[\x91a\x04\xEAV[\x14a$UWa\"\xDEa\"\xD0Ba\"\xCA`3a\x15_V[\x90a\x17\x86V[a\"\xD8a\x0ErV[\x90a\x17\xBFV[\x90a# a\"\xEC`3a\x15_V[a#\x1Aa#\x0Ca\"\xFC`4a\x15_V[a#\x06`\x01a tV[\x90a\x17\xF0V[a#\x14a\x0ErV[\x90a \x90V[\x90a\x17\xF0V[a#*`4a\x15_V[a#Ca#=a#8a\x0BuV[a\x04\xEAV[\x91a\x04\xEAV[\x10_\x14a$GWa#ha#b`\x03a#\\`4a\x15_V[\x90a\t\x04V[\x90a\tKV[[\x92a#t`3a\x15_V[a#\x86a#\x80_a\x15lV[\x91a\x04\xEAV[\x11\x90\x81a$#W[P\x80a#\xF9W[\x80a#\xCDW[\x80a#\xB6W[\x91a#\xAC`4a\x15_V[\x91\x93\x92\x91\x93\x92\x91\x90V[Pa#\xC8a#\xC2a\x1E\x8CV[\x15a\x02\x91V[a#\xA1V[PBa#\xF2a#\xECa#\xE7\x84a#\xE1a\x05\tV[\x90a\x17\x86V[a\x04\xEAV[\x91a\x04\xEAV[\x10\x15a#\x9BV[Pa$\x04`4a\x15_V[a$\x1Da$\x17a$\x12a\x0BuV[a\x04\xEAV[\x91a\x04\xEAV[\x10a#\x95V[\x90Pa$@a$:a$5`4a\x15_V[a\x04\xEAV[\x91a\x04\xEAV[\x11_a#\x8EV[a$P_a\x15lV[a#iV[_\x90_\x91_\x91a$wa$qa$k_\x94a\x15lV[\x95a\x15lV[\x93a\x15lV[\x91\x90V[\x90a$\x96\x91a$\x91a$\x8C\x82a\x17\x0BV[a$\xD7V[a$\x98V[V[\x90a$\xA2\x91a'\xD8V[PV[\x90a$\xAF\x91a${V[V[a$\xB9a\x11\xA8V[Pa$\xD3a$\xCDc\x01\xFF\xC9\xA7`\xE0\x1Ba\x02DV[\x91a\x02DV[\x14\x90V[a$\xE9\x90a$\xE3a'\xCBV[\x90a)\x85V[V[a$\xF3a\x1E\x8CV[a$\xF9WV[_c\xD9<\x06e`\xE0\x1B\x81R\x80a%\x11`\x04\x82\x01a\x04{V[\x03\x90\xFD[\x90V[a%,a%'a%1\x92a%\x15V[a\x03\x07V[a\x04\xEAV[\x90V[a%>`\x02a%\x18V[\x90V[a%K`\x02a\x15_V[a%da%^a%Ya%4V[a\x04\xEAV[\x91a\x04\xEAV[\x14a%}Wa%{a%ta%4V[`\x02a\x15\xC6V[V[_c>\xE5\xAE\xB5`\xE0\x1B\x81R\x80a%\x95`\x04\x82\x01a\x04{V[\x03\x90\xFD[a%\xA3`\x01a tV[\x90V[a%\xB8a%\xB1a%\x99V[`\x02a\x15\xC6V[V[a%\xC3\x90a\x03&V[\x90V[c\xFF\xFF\xFF\xFF\x16\x90V[a%\xE3a%\xDEa%\xE8\x92a%\xC6V[a\x18%V[a\x02DV[\x90V[a%\xF4\x90a\x15lV[\x90RV[\x91` a&\x19\x92\x94\x93a&\x12`@\x82\x01\x96_\x83\x01\x90a\x18:V[\x01\x90a%\xEBV[V[\x90\x91a&^`\x04\x91a&Oc\t^\xA7\xB3a&6\x87\x93\x91a%\xCFV[\x92a&?a\x022V[\x95\x86\x94` \x86\x01\x90\x81R\x01a\x18GV[` \x82\x01\x81\x03\x82R\x03\x82a\x06\x89V[\x90a&sa&m\x82\x84\x90a)\xC0V[\x15a\x02\x91V[a&}W[PPPV[a&\xCA`\x04a&\xCF\x94a&\xC5\x84\x91a&\xB6c\t^\xA7\xB3a&\x9D_\x91a%\xCFV[\x92a&\xA6a\x022V[\x96\x87\x94` \x86\x01\x90\x81R\x01a%\xF8V[` \x82\x01\x81\x03\x82R\x03\x83a\x06\x89V[a*bV[a*bV[_\x80\x80a&xV[\x90a&\xE3`\xFF\x91a\x0CrV[\x91\x81\x19\x16\x91\x16\x17\x90V[a&\xF6\x90a\x02\x91V[\x90V[\x90V[\x90a'\x11a'\x0Ca'\x18\x92a&\xEDV[a&\xF9V[\x82Ta&\xD7V[\x90UV[a'$a\x11\xA8V[Pa'9a'3\x82\x84\x90a\x1E\xE6V[\x15a\x02\x91V[_\x14a'\xC1Wa'``\x01a'[_a'S\x81\x86\x90a\x16\xD1V[\x01\x85\x90a\x1E\xD0V[a&\xFCV[\x90a'ia'\xCBV[\x90a'\xA6a'\xA0a'\x9A\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a\x16\xC5V[\x92a\x19RV[\x92a\x19RV[\x92a'\xAFa\x022V[\x80a'\xB9\x81a\x04{V[\x03\x90\xA4`\x01\x90V[PP_\x90V[_\x90V[a'\xD3a'\xC7V[P3\x90V[a'\xE0a\x11\xA8V[Pa'\xEC\x81\x83\x90a\x1E\xE6V[_\x14a(sWa(\x12_a(\r_a(\x05\x81\x86\x90a\x16\xD1V[\x01\x85\x90a\x1E\xD0V[a&\xFCV[\x90a(\x1Ba'\xCBV[\x90a(Xa(Ra(L\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x95a\x16\xC5V[\x92a\x19RV[\x92a\x19RV[\x92a(aa\x022V[\x80a(k\x81a\x04{V[\x03\x90\xA4`\x01\x90V[PP_\x90V[a(\x81a+\x16V[a(\x89a(\xA0V[V[\x91\x90a(\x9E\x90_` \x85\x01\x94\x01\x90a\x18:V[V[a(\xAB_`\x01a&\xFCV[a(\xB3a'\xCBV[a(\xE9\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA\x91a(\xE0a\x022V[\x91\x82\x91\x82a(\x8BV[\x03\x90\xA1V[a(\xF6a(yV[V[a)\0a$\xEBV[a)\x08a)\nV[V[a)\x15`\x01\x80a&\xFCV[a)\x1Da'\xCBV[a)S\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2X\x91a)Ja\x022V[\x91\x82\x91\x82a(\x8BV[\x03\x90\xA1V[a)`a(\xF8V[V[\x91` a)\x83\x92\x94\x93a)|`@\x82\x01\x96_\x83\x01\x90a\x18:V[\x01\x90a\x07\x8CV[V[\x90a)\x9Aa)\x94\x83\x83\x90a\x1E\xE6V[\x15a\x02\x91V[a)\xA2WPPV[a)\xBC_\x92\x83\x92c\xE2Q}?`\xE0\x1B\x84R`\x04\x84\x01a)bV[\x03\x90\xFD[\x90_` \x91a)\xCDa\x11\xA8V[Pa)\xD6a\x11\xA8V[Pa)\xDFa\x12\xE5V[Pa)\xE8a\x12\xE5V[P\x82\x81Q\x91\x01\x82\x85Z\xF1=\x91_Q\x91\x92\x83a*\x04W[PPP\x90V[\x90\x91\x92Pa*\x1Aa*\x14_a\x15lV[\x91a\x04\xEAV[\x14_\x14a*HWa*+\x91Pa%\xBAV[;a*>a*8_a\x15lV[\x91a\x04\xEAV[\x11[_\x80\x80a)\xFEV[Pa*\\a*V`\x01a tV[\x91a\x04\xEAV[\x14a*@V[\x90_` \x91a*oa\x12\xE5V[Pa*xa\x12\xE5V[P\x82\x81Q\x91\x01\x82\x85Z\xF1\x15a+\x0BW=_Q\x90a*\x9Da*\x97_a\x15lV[\x91a\x04\xEAV[\x14_\x14a*\xF1WPa*\xAE\x81a%\xBAV[;a*\xC1a*\xBB_a\x15lV[\x91a\x04\xEAV[\x14[a*\xCAWPV[a*\xD6a*\xED\x91a%\xBAV[_\x91\x82\x91cRt\xAF\xE7`\xE0\x1B\x83R`\x04\x83\x01a(\x8BV[\x03\x90\xFD[a+\x04a*\xFE`\x01a tV[\x91a\x04\xEAV[\x14\x15a*\xC3V[`@Q=_\x82>=\x90\xFD[a+'a+!a\x1E\x8CV[\x15a\x02\x91V[a+-WV[_c\x8D\xFC +`\xE0\x1B\x81R\x80a+E`\x04\x82\x01a\x04{V[\x03\x90\xFD",
    );
    /**Custom error with signature `AccessControlBadConfirmation()` and selector `0x6697b232`.
```solidity
error AccessControlBadConfirmation();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlBadConfirmation {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlBadConfirmation>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlBadConfirmation) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlBadConfirmation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlBadConfirmation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlBadConfirmation()";
            const SELECTOR: [u8; 4] = [102u8, 151u8, 178u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `AccessControlUnauthorizedAccount(address,bytes32)` and selector `0xe2517d3f`.
```solidity
error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub neededRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlUnauthorizedAccount) -> Self {
                (value.account, value.neededRole)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    neededRole: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlUnauthorizedAccount(address,bytes32)";
            const SELECTOR: [u8; 4] = [226u8, 81u8, 125u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.neededRole),
                )
            }
        }
    };
    /**Custom error with signature `AllEmissionsCompleted()` and selector `0x4555892c`.
```solidity
error AllEmissionsCompleted();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AllEmissionsCompleted {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AllEmissionsCompleted> for UnderlyingRustTuple<'_> {
            fn from(value: AllEmissionsCompleted) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AllEmissionsCompleted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AllEmissionsCompleted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AllEmissionsCompleted()";
            const SELECTOR: [u8; 4] = [69u8, 85u8, 137u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `BridgeNotConfigured()` and selector `0x7614917a`.
```solidity
error BridgeNotConfigured();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BridgeNotConfigured {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BridgeNotConfigured> for UnderlyingRustTuple<'_> {
            fn from(value: BridgeNotConfigured) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BridgeNotConfigured {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BridgeNotConfigured {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BridgeNotConfigured()";
            const SELECTOR: [u8; 4] = [118u8, 20u8, 145u8, 122u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmissionTooEarly()` and selector `0x3d53c753`.
```solidity
error EmissionTooEarly();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmissionTooEarly {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmissionTooEarly> for UnderlyingRustTuple<'_> {
            fn from(value: EmissionTooEarly) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmissionTooEarly {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmissionTooEarly {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmissionTooEarly()";
            const SELECTOR: [u8; 4] = [61u8, 83u8, 199u8, 83u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmissionsAlreadyStarted()` and selector `0x71d27b7a`.
```solidity
error EmissionsAlreadyStarted();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmissionsAlreadyStarted {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmissionsAlreadyStarted> for UnderlyingRustTuple<'_> {
            fn from(value: EmissionsAlreadyStarted) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmissionsAlreadyStarted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmissionsAlreadyStarted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmissionsAlreadyStarted()";
            const SELECTOR: [u8; 4] = [113u8, 210u8, 123u8, 122u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EmissionsNotStarted()` and selector `0x8f984041`.
```solidity
error EmissionsNotStarted();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EmissionsNotStarted {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EmissionsNotStarted> for UnderlyingRustTuple<'_> {
            fn from(value: EmissionsNotStarted) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EmissionsNotStarted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EmissionsNotStarted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EmissionsNotStarted()";
            const SELECTOR: [u8; 4] = [143u8, 152u8, 64u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EnforcedPause()` and selector `0xd93c0665`.
```solidity
error EnforcedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EnforcedPause {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EnforcedPause> for UnderlyingRustTuple<'_> {
            fn from(value: EnforcedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EnforcedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EnforcedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EnforcedPause()";
            const SELECTOR: [u8; 4] = [217u8, 60u8, 6u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ExpectedPause()` and selector `0x8dfc202b`.
```solidity
error ExpectedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExpectedPause {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExpectedPause> for UnderlyingRustTuple<'_> {
            fn from(value: ExpectedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ExpectedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ExpectedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ExpectedPause()";
            const SELECTOR: [u8; 4] = [141u8, 252u8, 32u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ReentrancyGuardReentrantCall()` and selector `0x3ee5aeb5`.
```solidity
error ReentrancyGuardReentrantCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ReentrancyGuardReentrantCall {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ReentrancyGuardReentrantCall>
        for UnderlyingRustTuple<'_> {
            fn from(value: ReentrancyGuardReentrantCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ReentrancyGuardReentrantCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ReentrancyGuardReentrantCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ReentrancyGuardReentrantCall()";
            const SELECTOR: [u8; 4] = [62u8, 229u8, 174u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `SafeERC20FailedOperation(address)` and selector `0x5274afe7`.
```solidity
error SafeERC20FailedOperation(address token);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SafeERC20FailedOperation {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SafeERC20FailedOperation>
        for UnderlyingRustTuple<'_> {
            fn from(value: SafeERC20FailedOperation) -> Self {
                (value.token,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SafeERC20FailedOperation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { token: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SafeERC20FailedOperation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SafeERC20FailedOperation(address)";
            const SELECTOR: [u8; 4] = [82u8, 116u8, 175u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ZeroAddress()` and selector `0xd92e233d`.
```solidity
error ZeroAddress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAddress {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAddress> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAddress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAddress()";
            const SELECTOR: [u8; 4] = [217u8, 46u8, 35u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Event with signature `BridgeDataUpdated(bytes,bytes)` and selector `0xb9a2088426f03b30a81c06428094fbfa9e2692739b3241af6b9ab1da4b5546be`.
```solidity
event BridgeDataUpdated(bytes oldData, bytes newData);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeDataUpdated {
        #[allow(missing_docs)]
        pub oldData: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub newData: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeDataUpdated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Bytes,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "BridgeDataUpdated(bytes,bytes)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                185u8,
                162u8,
                8u8,
                132u8,
                38u8,
                240u8,
                59u8,
                48u8,
                168u8,
                28u8,
                6u8,
                66u8,
                128u8,
                148u8,
                251u8,
                250u8,
                158u8,
                38u8,
                146u8,
                115u8,
                155u8,
                50u8,
                65u8,
                175u8,
                107u8,
                154u8,
                177u8,
                218u8,
                75u8,
                85u8,
                70u8,
                190u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldData: data.0,
                    newData: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.oldData,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.newData,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeDataUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeDataUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeDataUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeProxyUpdated(address,address)` and selector `0x07015b6a9f05913148fd5faddf2acc9708f305937f3072ca2b4b46faa5d0898b`.
```solidity
event BridgeProxyUpdated(address indexed oldProxy, address indexed newProxy);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeProxyUpdated {
        #[allow(missing_docs)]
        pub oldProxy: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newProxy: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeProxyUpdated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeProxyUpdated(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                7u8,
                1u8,
                91u8,
                106u8,
                159u8,
                5u8,
                145u8,
                49u8,
                72u8,
                253u8,
                95u8,
                173u8,
                223u8,
                42u8,
                204u8,
                151u8,
                8u8,
                243u8,
                5u8,
                147u8,
                127u8,
                48u8,
                114u8,
                202u8,
                43u8,
                75u8,
                70u8,
                250u8,
                165u8,
                208u8,
                137u8,
                139u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldProxy: topics.1,
                    newProxy: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.oldProxy.clone(),
                    self.newProxy.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.oldProxy,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newProxy,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeProxyUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeProxyUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeProxyUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EmissionMinted(uint256,uint256,address)` and selector `0x34b73d0c96e9ff4d5311434817c8ecc930e7d2782c5bde2e79dc44b0596755bb`.
```solidity
event EmissionMinted(uint256 epoch, uint256 amount, address indexed destination);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EmissionMinted {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub destination: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EmissionMinted {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "EmissionMinted(uint256,uint256,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                52u8,
                183u8,
                61u8,
                12u8,
                150u8,
                233u8,
                255u8,
                77u8,
                83u8,
                17u8,
                67u8,
                72u8,
                23u8,
                200u8,
                236u8,
                201u8,
                48u8,
                231u8,
                210u8,
                120u8,
                44u8,
                91u8,
                222u8,
                46u8,
                121u8,
                220u8,
                68u8,
                176u8,
                89u8,
                103u8,
                85u8,
                187u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    epoch: data.0,
                    amount: data.1,
                    destination: topics.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epoch),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.destination.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.destination,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EmissionMinted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EmissionMinted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EmissionMinted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EmissionsStarted(uint256)` and selector `0x1194b034cfa9ab5807494a1d5c667d8b0e6e97f38888742aa3871a3220341160`.
```solidity
event EmissionsStarted(uint256 startTime);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EmissionsStarted {
        #[allow(missing_docs)]
        pub startTime: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EmissionsStarted {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "EmissionsStarted(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                17u8,
                148u8,
                176u8,
                52u8,
                207u8,
                169u8,
                171u8,
                88u8,
                7u8,
                73u8,
                74u8,
                29u8,
                92u8,
                102u8,
                125u8,
                139u8,
                14u8,
                110u8,
                151u8,
                243u8,
                136u8,
                136u8,
                116u8,
                42u8,
                163u8,
                135u8,
                26u8,
                50u8,
                32u8,
                52u8,
                17u8,
                96u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { startTime: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.startTime),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EmissionsStarted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EmissionsStarted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EmissionsStarted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Paused(address)` and selector `0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258`.
```solidity
event Paused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Paused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Paused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Paused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                98u8,
                231u8,
                140u8,
                234u8,
                1u8,
                190u8,
                227u8,
                32u8,
                205u8,
                78u8,
                66u8,
                2u8,
                112u8,
                181u8,
                234u8,
                116u8,
                0u8,
                13u8,
                17u8,
                176u8,
                201u8,
                247u8,
                71u8,
                84u8,
                235u8,
                219u8,
                252u8,
                84u8,
                75u8,
                5u8,
                162u8,
                88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Paused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Paused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Paused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleAdminChanged(bytes32,bytes32,bytes32)` and selector `0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff`.
```solidity
event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleAdminChanged {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub previousAdminRole: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newAdminRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleAdminChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "RoleAdminChanged(bytes32,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    previousAdminRole: topics.2,
                    newAdminRole: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.previousAdminRole.clone(),
                    self.newAdminRole.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.previousAdminRole);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newAdminRole);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleAdminChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleAdminChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleAdminChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleGranted(bytes32,address,address)` and selector `0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d`.
```solidity
event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleGranted {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleGranted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleGranted(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleGranted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleGranted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleGranted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleRevoked(bytes32,address,address)` and selector `0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b`.
```solidity
event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleRevoked {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleRevoked(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Unpaused(address)` and selector `0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa`.
```solidity
event Unpaused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Unpaused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Unpaused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Unpaused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                93u8,
                185u8,
                238u8,
                10u8,
                73u8,
                91u8,
                242u8,
                230u8,
                255u8,
                156u8,
                145u8,
                167u8,
                131u8,
                76u8,
                27u8,
                164u8,
                253u8,
                210u8,
                68u8,
                165u8,
                232u8,
                170u8,
                78u8,
                83u8,
                123u8,
                211u8,
                138u8,
                234u8,
                228u8,
                176u8,
                115u8,
                170u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Unpaused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Unpaused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Unpaused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address _syndicateToken, address defaultAdmin, address emissionsManager, address pauser);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub _syndicateToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub defaultAdmin: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub emissionsManager: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub pauser: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (
                        value._syndicateToken,
                        value.defaultAdmin,
                        value.emissionsManager,
                        value.pauser,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _syndicateToken: tuple.0,
                        defaultAdmin: tuple.1,
                        emissionsManager: tuple.2,
                        pauser: tuple.3,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._syndicateToken,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.defaultAdmin,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.emissionsManager,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.pauser,
                    ),
                )
            }
        }
    };
    /**Function with signature `BRIDGE_MANAGER_ROLE()` and selector `0xf75e8512`.
```solidity
function BRIDGE_MANAGER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_MANAGER_ROLECall {}
    ///Container type for the return parameters of the [`BRIDGE_MANAGER_ROLE()`](BRIDGE_MANAGER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_MANAGER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_MANAGER_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_MANAGER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_MANAGER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_MANAGER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_MANAGER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_MANAGER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for BRIDGE_MANAGER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = BRIDGE_MANAGER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BRIDGE_MANAGER_ROLE()";
            const SELECTOR: [u8; 4] = [247u8, 94u8, 133u8, 18u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `DEFAULT_ADMIN_ROLE()` and selector `0xa217fddf`.
```solidity
function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLECall {}
    ///Container type for the return parameters of the [`DEFAULT_ADMIN_ROLE()`](DEFAULT_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEFAULT_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DEFAULT_ADMIN_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEFAULT_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [162u8, 23u8, 253u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSIONS_MANAGER_ROLE()` and selector `0xe3abdfcb`.
```solidity
function EMISSIONS_MANAGER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_MANAGER_ROLECall {}
    ///Container type for the return parameters of the [`EMISSIONS_MANAGER_ROLE()`](EMISSIONS_MANAGER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSIONS_MANAGER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_MANAGER_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_MANAGER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSIONS_MANAGER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSIONS_MANAGER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSIONS_MANAGER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSIONS_MANAGER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSIONS_MANAGER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSIONS_MANAGER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSIONS_MANAGER_ROLE()";
            const SELECTOR: [u8; 4] = [227u8, 171u8, 223u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSION_BUFFER_TIME()` and selector `0x243a30cc`.
```solidity
function EMISSION_BUFFER_TIME() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_BUFFER_TIMECall {}
    ///Container type for the return parameters of the [`EMISSION_BUFFER_TIME()`](EMISSION_BUFFER_TIMECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_BUFFER_TIMEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_BUFFER_TIMECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_BUFFER_TIMECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_BUFFER_TIMECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_BUFFER_TIMEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_BUFFER_TIMEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_BUFFER_TIMEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSION_BUFFER_TIMECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSION_BUFFER_TIMEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSION_BUFFER_TIME()";
            const SELECTOR: [u8; 4] = [36u8, 58u8, 48u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EPOCH_DURATION()` and selector `0xa70b9f0c`.
```solidity
function EPOCH_DURATION() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EPOCH_DURATIONCall {}
    ///Container type for the return parameters of the [`EPOCH_DURATION()`](EPOCH_DURATIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EPOCH_DURATIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EPOCH_DURATIONCall> for UnderlyingRustTuple<'_> {
                fn from(value: EPOCH_DURATIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for EPOCH_DURATIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EPOCH_DURATIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EPOCH_DURATIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EPOCH_DURATIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EPOCH_DURATIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EPOCH_DURATIONReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EPOCH_DURATION()";
            const SELECTOR: [u8; 4] = [167u8, 11u8, 159u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `PAUSER_ROLE()` and selector `0xe63ab1e9`.
```solidity
function PAUSER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PAUSER_ROLECall {}
    ///Container type for the return parameters of the [`PAUSER_ROLE()`](PAUSER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PAUSER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PAUSER_ROLECall> for UnderlyingRustTuple<'_> {
                fn from(value: PAUSER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for PAUSER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PAUSER_ROLEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: PAUSER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for PAUSER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for PAUSER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = PAUSER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PAUSER_ROLE()";
            const SELECTOR: [u8; 4] = [230u8, 58u8, 177u8, 233u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `TOTAL_EPOCHS()` and selector `0x5f15c3c9`.
```solidity
function TOTAL_EPOCHS() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_EPOCHSCall {}
    ///Container type for the return parameters of the [`TOTAL_EPOCHS()`](TOTAL_EPOCHSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_EPOCHSReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_EPOCHSCall> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_EPOCHSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_EPOCHSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_EPOCHSReturn> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_EPOCHSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_EPOCHSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for TOTAL_EPOCHSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = TOTAL_EPOCHSReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TOTAL_EPOCHS()";
            const SELECTOR: [u8; 4] = [95u8, 21u8, 195u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeData()` and selector `0x2481bb5c`.
```solidity
function bridgeData() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeDataCall {}
    ///Container type for the return parameters of the [`bridgeData()`](bridgeDataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeDataReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeDataCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeDataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeDataReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeDataReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeDataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeDataReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeData()";
            const SELECTOR: [u8; 4] = [36u8, 129u8, 187u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeProxy()` and selector `0xa3d4485b`.
```solidity
function bridgeProxy() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeProxyCall {}
    ///Container type for the return parameters of the [`bridgeProxy()`](bridgeProxyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeProxyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeProxyCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeProxyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeProxyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeProxyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeProxyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeProxyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeProxyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeProxyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeProxy()";
            const SELECTOR: [u8; 4] = [163u8, 212u8, 72u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `currentEpoch()` and selector `0x76671808`.
```solidity
function currentEpoch() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct currentEpochCall {}
    ///Container type for the return parameters of the [`currentEpoch()`](currentEpochCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct currentEpochReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<currentEpochCall> for UnderlyingRustTuple<'_> {
                fn from(value: currentEpochCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for currentEpochCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<currentEpochReturn> for UnderlyingRustTuple<'_> {
                fn from(value: currentEpochReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for currentEpochReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for currentEpochCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = currentEpochReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "currentEpoch()";
            const SELECTOR: [u8; 4] = [118u8, 103u8, 24u8, 8u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionSchedule(uint256)` and selector `0x334d0bbd`.
```solidity
function emissionSchedule(uint256) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionScheduleCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`emissionSchedule(uint256)`](emissionScheduleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionScheduleReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionScheduleCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionScheduleCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionScheduleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionScheduleReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionScheduleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionScheduleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionScheduleCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionScheduleReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionSchedule(uint256)";
            const SELECTOR: [u8; 4] = [51u8, 77u8, 11u8, 189u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionsEnded()` and selector `0xa4d7e31d`.
```solidity
function emissionsEnded() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsEndedCall {}
    ///Container type for the return parameters of the [`emissionsEnded()`](emissionsEndedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsEndedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsEndedCall> for UnderlyingRustTuple<'_> {
                fn from(value: emissionsEndedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for emissionsEndedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsEndedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsEndedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsEndedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionsEndedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionsEndedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionsEnded()";
            const SELECTOR: [u8; 4] = [164u8, 215u8, 227u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionsStartTime()` and selector `0x48b0daa6`.
```solidity
function emissionsStartTime() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartTimeCall {}
    ///Container type for the return parameters of the [`emissionsStartTime()`](emissionsStartTimeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartTimeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartTimeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartTimeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartTimeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartTimeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartTimeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartTimeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionsStartTimeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionsStartTimeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionsStartTime()";
            const SELECTOR: [u8; 4] = [72u8, 176u8, 218u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `emissionsStarted()` and selector `0x5adf0021`.
```solidity
function emissionsStarted() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartedCall {}
    ///Container type for the return parameters of the [`emissionsStarted()`](emissionsStartedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct emissionsStartedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<emissionsStartedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: emissionsStartedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for emissionsStartedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for emissionsStartedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = emissionsStartedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "emissionsStarted()";
            const SELECTOR: [u8; 4] = [90u8, 223u8, 0u8, 33u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBridgeConfiguration()` and selector `0x07a1d5fa`.
```solidity
function getBridgeConfiguration() external view returns (address proxy, bytes memory data);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeConfigurationCall {}
    ///Container type for the return parameters of the [`getBridgeConfiguration()`](getBridgeConfigurationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeConfigurationReturn {
        #[allow(missing_docs)]
        pub proxy: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeConfigurationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeConfigurationCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeConfigurationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeConfigurationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeConfigurationReturn) -> Self {
                    (value.proxy, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeConfigurationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        proxy: tuple.0,
                        data: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBridgeConfigurationCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBridgeConfigurationReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBridgeConfiguration()";
            const SELECTOR: [u8; 4] = [7u8, 161u8, 213u8, 250u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getCurrentEpochInfo()` and selector `0xbabc394f`.
```solidity
function getCurrentEpochInfo() external view returns (uint256 epoch, uint256 nextEmissionTime, uint256 nextEmissionAmount, bool canMintEmission);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentEpochInfoCall {}
    ///Container type for the return parameters of the [`getCurrentEpochInfo()`](getCurrentEpochInfoCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentEpochInfoReturn {
        #[allow(missing_docs)]
        pub epoch: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nextEmissionTime: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nextEmissionAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub canMintEmission: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentEpochInfoCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentEpochInfoCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentEpochInfoCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                bool,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentEpochInfoReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentEpochInfoReturn) -> Self {
                    (
                        value.epoch,
                        value.nextEmissionTime,
                        value.nextEmissionAmount,
                        value.canMintEmission,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentEpochInfoReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        epoch: tuple.0,
                        nextEmissionTime: tuple.1,
                        nextEmissionAmount: tuple.2,
                        canMintEmission: tuple.3,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCurrentEpochInfoCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getCurrentEpochInfoReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bool,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCurrentEpochInfo()";
            const SELECTOR: [u8; 4] = [186u8, 188u8, 57u8, 79u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getEmissionSchedule()` and selector `0xaf2aa63b`.
```solidity
function getEmissionSchedule() external view returns (uint256[48] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEmissionScheduleCall {}
    ///Container type for the return parameters of the [`getEmissionSchedule()`](getEmissionScheduleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEmissionScheduleReturn {
        #[allow(missing_docs)]
        pub _0: [alloy::sol_types::private::primitives::aliases::U256; 48usize],
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEmissionScheduleCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getEmissionScheduleCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getEmissionScheduleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    48usize,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                [alloy::sol_types::private::primitives::aliases::U256; 48usize],
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEmissionScheduleReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getEmissionScheduleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getEmissionScheduleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getEmissionScheduleCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getEmissionScheduleReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    48usize,
                >,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getEmissionSchedule()";
            const SELECTOR: [u8; 4] = [175u8, 42u8, 166u8, 59u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getNextEmissionTime()` and selector `0xa5b326be`.
```solidity
function getNextEmissionTime() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getNextEmissionTimeCall {}
    ///Container type for the return parameters of the [`getNextEmissionTime()`](getNextEmissionTimeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getNextEmissionTimeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getNextEmissionTimeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getNextEmissionTimeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getNextEmissionTimeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getNextEmissionTimeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getNextEmissionTimeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getNextEmissionTimeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getNextEmissionTimeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getNextEmissionTimeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getNextEmissionTime()";
            const SELECTOR: [u8; 4] = [165u8, 179u8, 38u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRoleAdmin(bytes32)` and selector `0x248a9ca3`.
```solidity
function getRoleAdmin(bytes32 role) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getRoleAdmin(bytes32)`](getRoleAdminCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleAdminCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRoleAdminReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleAdmin(bytes32)";
            const SELECTOR: [u8; 4] = [36u8, 138u8, 156u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `grantRole(bytes32,address)` and selector `0x2f2ff15d`.
```solidity
function grantRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`grantRole(bytes32,address)`](grantRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for grantRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = grantRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "grantRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [47u8, 47u8, 241u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `hasRole(bytes32,address)` and selector `0x91d14854`.
```solidity
function hasRole(bytes32 role, address account) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`hasRole(bytes32,address)`](hasRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = hasRoleReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [145u8, 209u8, 72u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `mintEmission()` and selector `0x284e1333`.
```solidity
function mintEmission() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintEmissionCall {}
    ///Container type for the return parameters of the [`mintEmission()`](mintEmissionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintEmissionReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintEmissionCall> for UnderlyingRustTuple<'_> {
                fn from(value: mintEmissionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintEmissionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintEmissionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: mintEmissionReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintEmissionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mintEmissionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mintEmissionReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mintEmission()";
            const SELECTOR: [u8; 4] = [40u8, 78u8, 19u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `pause()` and selector `0x8456cb59`.
```solidity
function pause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseCall {}
    ///Container type for the return parameters of the [`pause()`](pauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pause()";
            const SELECTOR: [u8; 4] = [132u8, 86u8, 203u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `paused()` and selector `0x5c975abb`.
```solidity
function paused() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedCall {}
    ///Container type for the return parameters of the [`paused()`](pausedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedCall> for UnderlyingRustTuple<'_> {
                fn from(value: pausedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pausedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pausedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pausedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "paused()";
            const SELECTOR: [u8; 4] = [92u8, 151u8, 90u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `renounceRole(bytes32,address)` and selector `0x36568abe`.
```solidity
function renounceRole(bytes32 role, address callerConfirmation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub callerConfirmation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`renounceRole(bytes32,address)`](renounceRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleCall) -> Self {
                    (value.role, value.callerConfirmation)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        callerConfirmation: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [54u8, 86u8, 138u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callerConfirmation,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `revokeRole(bytes32,address)` and selector `0xd547741f`.
```solidity
function revokeRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeRole(bytes32,address)`](revokeRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [213u8, 71u8, 116u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBridgeData(bytes)` and selector `0x13beaa5b`.
```solidity
function setBridgeData(bytes memory _bridgeData) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeDataCall {
        #[allow(missing_docs)]
        pub _bridgeData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`setBridgeData(bytes)`](setBridgeDataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeDataReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeDataCall> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeDataCall) -> Self {
                    (value._bridgeData,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgeDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridgeData: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeDataReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeDataReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgeDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBridgeDataCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBridgeDataReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBridgeData(bytes)";
            const SELECTOR: [u8; 4] = [19u8, 190u8, 170u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self._bridgeData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBridgeProxy(address)` and selector `0xa571e184`.
```solidity
function setBridgeProxy(address _bridgeProxy) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeProxyCall {
        #[allow(missing_docs)]
        pub _bridgeProxy: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setBridgeProxy(address)`](setBridgeProxyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeProxyReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeProxyCall> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeProxyCall) -> Self {
                    (value._bridgeProxy,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgeProxyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _bridgeProxy: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeProxyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeProxyReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setBridgeProxyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBridgeProxyCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBridgeProxyReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBridgeProxy(address)";
            const SELECTOR: [u8; 4] = [165u8, 113u8, 225u8, 132u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridgeProxy,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `startEmissions()` and selector `0x1b02f845`.
```solidity
function startEmissions() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startEmissionsCall {}
    ///Container type for the return parameters of the [`startEmissions()`](startEmissionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startEmissionsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startEmissionsCall> for UnderlyingRustTuple<'_> {
                fn from(value: startEmissionsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for startEmissionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startEmissionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: startEmissionsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for startEmissionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for startEmissionsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = startEmissionsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "startEmissions()";
            const SELECTOR: [u8; 4] = [27u8, 2u8, 248u8, 69u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
```solidity
function supportsInterface(bytes4 interfaceId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceCall {
        #[allow(missing_docs)]
        pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
    }
    ///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceCall) -> Self {
                    (value.interfaceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { interfaceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportsInterfaceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = supportsInterfaceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportsInterface(bytes4)";
            const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.interfaceId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `syndicateToken()` and selector `0x5bdf6ca1`.
```solidity
function syndicateToken() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct syndicateTokenCall {}
    ///Container type for the return parameters of the [`syndicateToken()`](syndicateTokenCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct syndicateTokenReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<syndicateTokenCall> for UnderlyingRustTuple<'_> {
                fn from(value: syndicateTokenCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for syndicateTokenCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<syndicateTokenReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: syndicateTokenReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for syndicateTokenReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for syndicateTokenCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = syndicateTokenReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "syndicateToken()";
            const SELECTOR: [u8; 4] = [91u8, 223u8, 108u8, 161u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `totalEmissionsMinted()` and selector `0xf508e19d`.
```solidity
function totalEmissionsMinted() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalEmissionsMintedCall {}
    ///Container type for the return parameters of the [`totalEmissionsMinted()`](totalEmissionsMintedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalEmissionsMintedReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalEmissionsMintedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: totalEmissionsMintedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for totalEmissionsMintedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalEmissionsMintedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: totalEmissionsMintedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for totalEmissionsMintedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for totalEmissionsMintedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = totalEmissionsMintedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "totalEmissionsMinted()";
            const SELECTOR: [u8; 4] = [245u8, 8u8, 225u8, 157u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `unpause()` and selector `0x3f4ba83a`.
```solidity
function unpause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseCall {}
    ///Container type for the return parameters of the [`unpause()`](unpauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unpauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = unpauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unpause()";
            const SELECTOR: [u8; 4] = [63u8, 75u8, 168u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`SyndicateTokenEmissionScheduler`](self) function calls.
    pub enum SyndicateTokenEmissionSchedulerCalls {
        #[allow(missing_docs)]
        BRIDGE_MANAGER_ROLE(BRIDGE_MANAGER_ROLECall),
        #[allow(missing_docs)]
        DEFAULT_ADMIN_ROLE(DEFAULT_ADMIN_ROLECall),
        #[allow(missing_docs)]
        EMISSIONS_MANAGER_ROLE(EMISSIONS_MANAGER_ROLECall),
        #[allow(missing_docs)]
        EMISSION_BUFFER_TIME(EMISSION_BUFFER_TIMECall),
        #[allow(missing_docs)]
        EPOCH_DURATION(EPOCH_DURATIONCall),
        #[allow(missing_docs)]
        PAUSER_ROLE(PAUSER_ROLECall),
        #[allow(missing_docs)]
        TOTAL_EPOCHS(TOTAL_EPOCHSCall),
        #[allow(missing_docs)]
        bridgeData(bridgeDataCall),
        #[allow(missing_docs)]
        bridgeProxy(bridgeProxyCall),
        #[allow(missing_docs)]
        currentEpoch(currentEpochCall),
        #[allow(missing_docs)]
        emissionSchedule(emissionScheduleCall),
        #[allow(missing_docs)]
        emissionsEnded(emissionsEndedCall),
        #[allow(missing_docs)]
        emissionsStartTime(emissionsStartTimeCall),
        #[allow(missing_docs)]
        emissionsStarted(emissionsStartedCall),
        #[allow(missing_docs)]
        getBridgeConfiguration(getBridgeConfigurationCall),
        #[allow(missing_docs)]
        getCurrentEpochInfo(getCurrentEpochInfoCall),
        #[allow(missing_docs)]
        getEmissionSchedule(getEmissionScheduleCall),
        #[allow(missing_docs)]
        getNextEmissionTime(getNextEmissionTimeCall),
        #[allow(missing_docs)]
        getRoleAdmin(getRoleAdminCall),
        #[allow(missing_docs)]
        grantRole(grantRoleCall),
        #[allow(missing_docs)]
        hasRole(hasRoleCall),
        #[allow(missing_docs)]
        mintEmission(mintEmissionCall),
        #[allow(missing_docs)]
        pause(pauseCall),
        #[allow(missing_docs)]
        paused(pausedCall),
        #[allow(missing_docs)]
        renounceRole(renounceRoleCall),
        #[allow(missing_docs)]
        revokeRole(revokeRoleCall),
        #[allow(missing_docs)]
        setBridgeData(setBridgeDataCall),
        #[allow(missing_docs)]
        setBridgeProxy(setBridgeProxyCall),
        #[allow(missing_docs)]
        startEmissions(startEmissionsCall),
        #[allow(missing_docs)]
        supportsInterface(supportsInterfaceCall),
        #[allow(missing_docs)]
        syndicateToken(syndicateTokenCall),
        #[allow(missing_docs)]
        totalEmissionsMinted(totalEmissionsMintedCall),
        #[allow(missing_docs)]
        unpause(unpauseCall),
    }
    #[automatically_derived]
    impl SyndicateTokenEmissionSchedulerCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 255u8, 201u8, 167u8],
            [7u8, 161u8, 213u8, 250u8],
            [19u8, 190u8, 170u8, 91u8],
            [27u8, 2u8, 248u8, 69u8],
            [36u8, 58u8, 48u8, 204u8],
            [36u8, 129u8, 187u8, 92u8],
            [36u8, 138u8, 156u8, 163u8],
            [40u8, 78u8, 19u8, 51u8],
            [47u8, 47u8, 241u8, 93u8],
            [51u8, 77u8, 11u8, 189u8],
            [54u8, 86u8, 138u8, 190u8],
            [63u8, 75u8, 168u8, 58u8],
            [72u8, 176u8, 218u8, 166u8],
            [90u8, 223u8, 0u8, 33u8],
            [91u8, 223u8, 108u8, 161u8],
            [92u8, 151u8, 90u8, 187u8],
            [95u8, 21u8, 195u8, 201u8],
            [118u8, 103u8, 24u8, 8u8],
            [132u8, 86u8, 203u8, 89u8],
            [145u8, 209u8, 72u8, 84u8],
            [162u8, 23u8, 253u8, 223u8],
            [163u8, 212u8, 72u8, 91u8],
            [164u8, 215u8, 227u8, 29u8],
            [165u8, 113u8, 225u8, 132u8],
            [165u8, 179u8, 38u8, 190u8],
            [167u8, 11u8, 159u8, 12u8],
            [175u8, 42u8, 166u8, 59u8],
            [186u8, 188u8, 57u8, 79u8],
            [213u8, 71u8, 116u8, 31u8],
            [227u8, 171u8, 223u8, 203u8],
            [230u8, 58u8, 177u8, 233u8],
            [245u8, 8u8, 225u8, 157u8],
            [247u8, 94u8, 133u8, 18u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndicateTokenEmissionSchedulerCalls {
        const NAME: &'static str = "SyndicateTokenEmissionSchedulerCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 33usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::BRIDGE_MANAGER_ROLE(_) => {
                    <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DEFAULT_ADMIN_ROLE(_) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSIONS_MANAGER_ROLE(_) => {
                    <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSION_BUFFER_TIME(_) => {
                    <EMISSION_BUFFER_TIMECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EPOCH_DURATION(_) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::PAUSER_ROLE(_) => {
                    <PAUSER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::TOTAL_EPOCHS(_) => {
                    <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeData(_) => {
                    <bridgeDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeProxy(_) => {
                    <bridgeProxyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::currentEpoch(_) => {
                    <currentEpochCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionSchedule(_) => {
                    <emissionScheduleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionsEnded(_) => {
                    <emissionsEndedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionsStartTime(_) => {
                    <emissionsStartTimeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::emissionsStarted(_) => {
                    <emissionsStartedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBridgeConfiguration(_) => {
                    <getBridgeConfigurationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCurrentEpochInfo(_) => {
                    <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getEmissionSchedule(_) => {
                    <getEmissionScheduleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getNextEmissionTime(_) => {
                    <getNextEmissionTimeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleAdmin(_) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::grantRole(_) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasRole(_) => <hasRoleCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::mintEmission(_) => {
                    <mintEmissionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::pause(_) => <pauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::paused(_) => <pausedCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::renounceRole(_) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeRole(_) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBridgeData(_) => {
                    <setBridgeDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBridgeProxy(_) => {
                    <setBridgeProxyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::startEmissions(_) => {
                    <startEmissionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::supportsInterface(_) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::syndicateToken(_) => {
                    <syndicateTokenCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::totalEmissionsMinted(_) => {
                    <totalEmissionsMintedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::unpause(_) => <unpauseCall as alloy_sol_types::SolCall>::SELECTOR,
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls>] = &[
                {
                    fn supportsInterface(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn getBridgeConfiguration(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <getBridgeConfigurationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerCalls::getBridgeConfiguration,
                            )
                    }
                    getBridgeConfiguration
                },
                {
                    fn setBridgeData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <setBridgeDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerCalls::setBridgeData)
                    }
                    setBridgeData
                },
                {
                    fn startEmissions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <startEmissionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerCalls::startEmissions)
                    }
                    startEmissions
                },
                {
                    fn EMISSION_BUFFER_TIME(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <EMISSION_BUFFER_TIMECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerCalls::EMISSION_BUFFER_TIME,
                            )
                    }
                    EMISSION_BUFFER_TIME
                },
                {
                    fn bridgeData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <bridgeDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerCalls::bridgeData)
                    }
                    bridgeData
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn mintEmission(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <mintEmissionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerCalls::mintEmission)
                    }
                    mintEmission
                },
                {
                    fn grantRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn emissionSchedule(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <emissionScheduleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerCalls::emissionSchedule)
                    }
                    emissionSchedule
                },
                {
                    fn renounceRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn unpause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <unpauseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerCalls::unpause)
                    }
                    unpause
                },
                {
                    fn emissionsStartTime(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <emissionsStartTimeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerCalls::emissionsStartTime,
                            )
                    }
                    emissionsStartTime
                },
                {
                    fn emissionsStarted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <emissionsStartedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerCalls::emissionsStarted)
                    }
                    emissionsStarted
                },
                {
                    fn syndicateToken(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <syndicateTokenCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerCalls::syndicateToken)
                    }
                    syndicateToken
                },
                {
                    fn paused(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <pausedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerCalls::paused)
                    }
                    paused
                },
                {
                    fn TOTAL_EPOCHS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerCalls::TOTAL_EPOCHS)
                    }
                    TOTAL_EPOCHS
                },
                {
                    fn currentEpoch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <currentEpochCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerCalls::currentEpoch)
                    }
                    currentEpoch
                },
                {
                    fn pause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <pauseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerCalls::pause)
                    }
                    pause
                },
                {
                    fn hasRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerCalls::DEFAULT_ADMIN_ROLE,
                            )
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn bridgeProxy(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <bridgeProxyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerCalls::bridgeProxy)
                    }
                    bridgeProxy
                },
                {
                    fn emissionsEnded(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <emissionsEndedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerCalls::emissionsEnded)
                    }
                    emissionsEnded
                },
                {
                    fn setBridgeProxy(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <setBridgeProxyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerCalls::setBridgeProxy)
                    }
                    setBridgeProxy
                },
                {
                    fn getNextEmissionTime(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <getNextEmissionTimeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerCalls::getNextEmissionTime,
                            )
                    }
                    getNextEmissionTime
                },
                {
                    fn EPOCH_DURATION(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerCalls::EPOCH_DURATION)
                    }
                    EPOCH_DURATION
                },
                {
                    fn getEmissionSchedule(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <getEmissionScheduleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerCalls::getEmissionSchedule,
                            )
                    }
                    getEmissionSchedule
                },
                {
                    fn getCurrentEpochInfo(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerCalls::getCurrentEpochInfo,
                            )
                    }
                    getCurrentEpochInfo
                },
                {
                    fn revokeRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn EMISSIONS_MANAGER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerCalls::EMISSIONS_MANAGER_ROLE,
                            )
                    }
                    EMISSIONS_MANAGER_ROLE
                },
                {
                    fn PAUSER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <PAUSER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerCalls::PAUSER_ROLE)
                    }
                    PAUSER_ROLE
                },
                {
                    fn totalEmissionsMinted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <totalEmissionsMintedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerCalls::totalEmissionsMinted,
                            )
                    }
                    totalEmissionsMinted
                },
                {
                    fn BRIDGE_MANAGER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerCalls> {
                        <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerCalls::BRIDGE_MANAGER_ROLE,
                            )
                    }
                    BRIDGE_MANAGER_ROLE
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::BRIDGE_MANAGER_ROLE(inner) => {
                    <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSIONS_MANAGER_ROLE(inner) => {
                    <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSION_BUFFER_TIME(inner) => {
                    <EMISSION_BUFFER_TIMECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EPOCH_DURATION(inner) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PAUSER_ROLE(inner) => {
                    <PAUSER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TOTAL_EPOCHS(inner) => {
                    <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bridgeData(inner) => {
                    <bridgeDataCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::bridgeProxy(inner) => {
                    <bridgeProxyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::currentEpoch(inner) => {
                    <currentEpochCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionSchedule(inner) => {
                    <emissionScheduleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionsEnded(inner) => {
                    <emissionsEndedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionsStartTime(inner) => {
                    <emissionsStartTimeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::emissionsStarted(inner) => {
                    <emissionsStartedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBridgeConfiguration(inner) => {
                    <getBridgeConfigurationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getCurrentEpochInfo(inner) => {
                    <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getEmissionSchedule(inner) => {
                    <getEmissionScheduleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getNextEmissionTime(inner) => {
                    <getNextEmissionTimeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::mintEmission(inner) => {
                    <mintEmissionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setBridgeData(inner) => {
                    <setBridgeDataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setBridgeProxy(inner) => {
                    <setBridgeProxyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::startEmissions(inner) => {
                    <startEmissionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::syndicateToken(inner) => {
                    <syndicateTokenCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::totalEmissionsMinted(inner) => {
                    <totalEmissionsMintedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::BRIDGE_MANAGER_ROLE(inner) => {
                    <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSIONS_MANAGER_ROLE(inner) => {
                    <EMISSIONS_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSION_BUFFER_TIME(inner) => {
                    <EMISSION_BUFFER_TIMECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EPOCH_DURATION(inner) => {
                    <EPOCH_DURATIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PAUSER_ROLE(inner) => {
                    <PAUSER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TOTAL_EPOCHS(inner) => {
                    <TOTAL_EPOCHSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeData(inner) => {
                    <bridgeDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeProxy(inner) => {
                    <bridgeProxyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::currentEpoch(inner) => {
                    <currentEpochCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionSchedule(inner) => {
                    <emissionScheduleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionsEnded(inner) => {
                    <emissionsEndedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionsStartTime(inner) => {
                    <emissionsStartTimeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::emissionsStarted(inner) => {
                    <emissionsStartedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBridgeConfiguration(inner) => {
                    <getBridgeConfigurationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getCurrentEpochInfo(inner) => {
                    <getCurrentEpochInfoCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getEmissionSchedule(inner) => {
                    <getEmissionScheduleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getNextEmissionTime(inner) => {
                    <getNextEmissionTimeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::mintEmission(inner) => {
                    <mintEmissionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBridgeData(inner) => {
                    <setBridgeDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBridgeProxy(inner) => {
                    <setBridgeProxyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::startEmissions(inner) => {
                    <startEmissionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::syndicateToken(inner) => {
                    <syndicateTokenCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::totalEmissionsMinted(inner) => {
                    <totalEmissionsMintedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
            }
        }
    }
    ///Container for all the [`SyndicateTokenEmissionScheduler`](self) custom errors.
    pub enum SyndicateTokenEmissionSchedulerErrors {
        #[allow(missing_docs)]
        AccessControlBadConfirmation(AccessControlBadConfirmation),
        #[allow(missing_docs)]
        AccessControlUnauthorizedAccount(AccessControlUnauthorizedAccount),
        #[allow(missing_docs)]
        AllEmissionsCompleted(AllEmissionsCompleted),
        #[allow(missing_docs)]
        BridgeNotConfigured(BridgeNotConfigured),
        #[allow(missing_docs)]
        EmissionTooEarly(EmissionTooEarly),
        #[allow(missing_docs)]
        EmissionsAlreadyStarted(EmissionsAlreadyStarted),
        #[allow(missing_docs)]
        EmissionsNotStarted(EmissionsNotStarted),
        #[allow(missing_docs)]
        EnforcedPause(EnforcedPause),
        #[allow(missing_docs)]
        ExpectedPause(ExpectedPause),
        #[allow(missing_docs)]
        ReentrancyGuardReentrantCall(ReentrancyGuardReentrantCall),
        #[allow(missing_docs)]
        SafeERC20FailedOperation(SafeERC20FailedOperation),
        #[allow(missing_docs)]
        ZeroAddress(ZeroAddress),
    }
    #[automatically_derived]
    impl SyndicateTokenEmissionSchedulerErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [61u8, 83u8, 199u8, 83u8],
            [62u8, 229u8, 174u8, 181u8],
            [69u8, 85u8, 137u8, 44u8],
            [82u8, 116u8, 175u8, 231u8],
            [102u8, 151u8, 178u8, 50u8],
            [113u8, 210u8, 123u8, 122u8],
            [118u8, 20u8, 145u8, 122u8],
            [141u8, 252u8, 32u8, 43u8],
            [143u8, 152u8, 64u8, 65u8],
            [217u8, 46u8, 35u8, 61u8],
            [217u8, 60u8, 6u8, 101u8],
            [226u8, 81u8, 125u8, 63u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndicateTokenEmissionSchedulerErrors {
        const NAME: &'static str = "SyndicateTokenEmissionSchedulerErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 12usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AccessControlBadConfirmation(_) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AccessControlUnauthorizedAccount(_) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AllEmissionsCompleted(_) => {
                    <AllEmissionsCompleted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BridgeNotConfigured(_) => {
                    <BridgeNotConfigured as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmissionTooEarly(_) => {
                    <EmissionTooEarly as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmissionsAlreadyStarted(_) => {
                    <EmissionsAlreadyStarted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EmissionsNotStarted(_) => {
                    <EmissionsNotStarted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EnforcedPause(_) => {
                    <EnforcedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ExpectedPause(_) => {
                    <ExpectedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ReentrancyGuardReentrantCall(_) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SafeERC20FailedOperation(_) => {
                    <SafeERC20FailedOperation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAddress(_) => {
                    <ZeroAddress as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerErrors>] = &[
                {
                    fn EmissionTooEarly(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerErrors> {
                        <EmissionTooEarly as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerErrors::EmissionTooEarly)
                    }
                    EmissionTooEarly
                },
                {
                    fn ReentrancyGuardReentrantCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerErrors> {
                        <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerErrors::ReentrancyGuardReentrantCall,
                            )
                    }
                    ReentrancyGuardReentrantCall
                },
                {
                    fn AllEmissionsCompleted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerErrors> {
                        <AllEmissionsCompleted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerErrors::AllEmissionsCompleted,
                            )
                    }
                    AllEmissionsCompleted
                },
                {
                    fn SafeERC20FailedOperation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerErrors> {
                        <SafeERC20FailedOperation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerErrors::SafeERC20FailedOperation,
                            )
                    }
                    SafeERC20FailedOperation
                },
                {
                    fn AccessControlBadConfirmation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerErrors> {
                        <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerErrors::AccessControlBadConfirmation,
                            )
                    }
                    AccessControlBadConfirmation
                },
                {
                    fn EmissionsAlreadyStarted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerErrors> {
                        <EmissionsAlreadyStarted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerErrors::EmissionsAlreadyStarted,
                            )
                    }
                    EmissionsAlreadyStarted
                },
                {
                    fn BridgeNotConfigured(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerErrors> {
                        <BridgeNotConfigured as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerErrors::BridgeNotConfigured,
                            )
                    }
                    BridgeNotConfigured
                },
                {
                    fn ExpectedPause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerErrors> {
                        <ExpectedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerErrors::ExpectedPause)
                    }
                    ExpectedPause
                },
                {
                    fn EmissionsNotStarted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerErrors> {
                        <EmissionsNotStarted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerErrors::EmissionsNotStarted,
                            )
                    }
                    EmissionsNotStarted
                },
                {
                    fn ZeroAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerErrors> {
                        <ZeroAddress as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerErrors::ZeroAddress)
                    }
                    ZeroAddress
                },
                {
                    fn EnforcedPause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerErrors> {
                        <EnforcedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenEmissionSchedulerErrors::EnforcedPause)
                    }
                    EnforcedPause
                },
                {
                    fn AccessControlUnauthorizedAccount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenEmissionSchedulerErrors> {
                        <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenEmissionSchedulerErrors::AccessControlUnauthorizedAccount,
                            )
                    }
                    AccessControlUnauthorizedAccount
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AllEmissionsCompleted(inner) => {
                    <AllEmissionsCompleted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BridgeNotConfigured(inner) => {
                    <BridgeNotConfigured as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmissionTooEarly(inner) => {
                    <EmissionTooEarly as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmissionsAlreadyStarted(inner) => {
                    <EmissionsAlreadyStarted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EmissionsNotStarted(inner) => {
                    <EmissionsNotStarted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ReentrancyGuardReentrantCall(inner) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SafeERC20FailedOperation(inner) => {
                    <SafeERC20FailedOperation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AllEmissionsCompleted(inner) => {
                    <AllEmissionsCompleted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BridgeNotConfigured(inner) => {
                    <BridgeNotConfigured as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmissionTooEarly(inner) => {
                    <EmissionTooEarly as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmissionsAlreadyStarted(inner) => {
                    <EmissionsAlreadyStarted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EmissionsNotStarted(inner) => {
                    <EmissionsNotStarted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ReentrancyGuardReentrantCall(inner) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SafeERC20FailedOperation(inner) => {
                    <SafeERC20FailedOperation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`SyndicateTokenEmissionScheduler`](self) events.
    pub enum SyndicateTokenEmissionSchedulerEvents {
        #[allow(missing_docs)]
        BridgeDataUpdated(BridgeDataUpdated),
        #[allow(missing_docs)]
        BridgeProxyUpdated(BridgeProxyUpdated),
        #[allow(missing_docs)]
        EmissionMinted(EmissionMinted),
        #[allow(missing_docs)]
        EmissionsStarted(EmissionsStarted),
        #[allow(missing_docs)]
        Paused(Paused),
        #[allow(missing_docs)]
        RoleAdminChanged(RoleAdminChanged),
        #[allow(missing_docs)]
        RoleGranted(RoleGranted),
        #[allow(missing_docs)]
        RoleRevoked(RoleRevoked),
        #[allow(missing_docs)]
        Unpaused(Unpaused),
    }
    #[automatically_derived]
    impl SyndicateTokenEmissionSchedulerEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                7u8,
                1u8,
                91u8,
                106u8,
                159u8,
                5u8,
                145u8,
                49u8,
                72u8,
                253u8,
                95u8,
                173u8,
                223u8,
                42u8,
                204u8,
                151u8,
                8u8,
                243u8,
                5u8,
                147u8,
                127u8,
                48u8,
                114u8,
                202u8,
                43u8,
                75u8,
                70u8,
                250u8,
                165u8,
                208u8,
                137u8,
                139u8,
            ],
            [
                17u8,
                148u8,
                176u8,
                52u8,
                207u8,
                169u8,
                171u8,
                88u8,
                7u8,
                73u8,
                74u8,
                29u8,
                92u8,
                102u8,
                125u8,
                139u8,
                14u8,
                110u8,
                151u8,
                243u8,
                136u8,
                136u8,
                116u8,
                42u8,
                163u8,
                135u8,
                26u8,
                50u8,
                32u8,
                52u8,
                17u8,
                96u8,
            ],
            [
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ],
            [
                52u8,
                183u8,
                61u8,
                12u8,
                150u8,
                233u8,
                255u8,
                77u8,
                83u8,
                17u8,
                67u8,
                72u8,
                23u8,
                200u8,
                236u8,
                201u8,
                48u8,
                231u8,
                210u8,
                120u8,
                44u8,
                91u8,
                222u8,
                46u8,
                121u8,
                220u8,
                68u8,
                176u8,
                89u8,
                103u8,
                85u8,
                187u8,
            ],
            [
                93u8,
                185u8,
                238u8,
                10u8,
                73u8,
                91u8,
                242u8,
                230u8,
                255u8,
                156u8,
                145u8,
                167u8,
                131u8,
                76u8,
                27u8,
                164u8,
                253u8,
                210u8,
                68u8,
                165u8,
                232u8,
                170u8,
                78u8,
                83u8,
                123u8,
                211u8,
                138u8,
                234u8,
                228u8,
                176u8,
                115u8,
                170u8,
            ],
            [
                98u8,
                231u8,
                140u8,
                234u8,
                1u8,
                190u8,
                227u8,
                32u8,
                205u8,
                78u8,
                66u8,
                2u8,
                112u8,
                181u8,
                234u8,
                116u8,
                0u8,
                13u8,
                17u8,
                176u8,
                201u8,
                247u8,
                71u8,
                84u8,
                235u8,
                219u8,
                252u8,
                84u8,
                75u8,
                5u8,
                162u8,
                88u8,
            ],
            [
                185u8,
                162u8,
                8u8,
                132u8,
                38u8,
                240u8,
                59u8,
                48u8,
                168u8,
                28u8,
                6u8,
                66u8,
                128u8,
                148u8,
                251u8,
                250u8,
                158u8,
                38u8,
                146u8,
                115u8,
                155u8,
                50u8,
                65u8,
                175u8,
                107u8,
                154u8,
                177u8,
                218u8,
                75u8,
                85u8,
                70u8,
                190u8,
            ],
            [
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ],
            [
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for SyndicateTokenEmissionSchedulerEvents {
        const NAME: &'static str = "SyndicateTokenEmissionSchedulerEvents";
        const COUNT: usize = 9usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <BridgeDataUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BridgeDataUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeDataUpdated)
                }
                Some(
                    <BridgeProxyUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BridgeProxyUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeProxyUpdated)
                }
                Some(<EmissionMinted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EmissionMinted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EmissionMinted)
                }
                Some(<EmissionsStarted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EmissionsStarted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EmissionsStarted)
                }
                Some(<Paused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Paused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Paused)
                }
                Some(<RoleAdminChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleAdminChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleAdminChanged)
                }
                Some(<RoleGranted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleGranted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleGranted)
                }
                Some(<RoleRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleRevoked)
                }
                Some(<Unpaused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Unpaused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Unpaused)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData
    for SyndicateTokenEmissionSchedulerEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::BridgeDataUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeProxyUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EmissionMinted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EmissionsStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::BridgeDataUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeProxyUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EmissionMinted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EmissionsStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`SyndicateTokenEmissionScheduler`](self) contract instance.

See the [wrapper's documentation](`SyndicateTokenEmissionSchedulerInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> SyndicateTokenEmissionSchedulerInstance<T, P, N> {
        SyndicateTokenEmissionSchedulerInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        _syndicateToken: alloy::sol_types::private::Address,
        defaultAdmin: alloy::sol_types::private::Address,
        emissionsManager: alloy::sol_types::private::Address,
        pauser: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<SyndicateTokenEmissionSchedulerInstance<T, P, N>>,
    > {
        SyndicateTokenEmissionSchedulerInstance::<
            T,
            P,
            N,
        >::deploy(provider, _syndicateToken, defaultAdmin, emissionsManager, pauser)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        _syndicateToken: alloy::sol_types::private::Address,
        defaultAdmin: alloy::sol_types::private::Address,
        emissionsManager: alloy::sol_types::private::Address,
        pauser: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        SyndicateTokenEmissionSchedulerInstance::<
            T,
            P,
            N,
        >::deploy_builder(
            provider,
            _syndicateToken,
            defaultAdmin,
            emissionsManager,
            pauser,
        )
    }
    /**A [`SyndicateTokenEmissionScheduler`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`SyndicateTokenEmissionScheduler`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct SyndicateTokenEmissionSchedulerInstance<
        T,
        P,
        N = alloy_contract::private::Ethereum,
    > {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug
    for SyndicateTokenEmissionSchedulerInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("SyndicateTokenEmissionSchedulerInstance")
                .field(&self.address)
                .finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyndicateTokenEmissionSchedulerInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`SyndicateTokenEmissionScheduler`](self) contract instance.

See the [wrapper's documentation](`SyndicateTokenEmissionSchedulerInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            _syndicateToken: alloy::sol_types::private::Address,
            defaultAdmin: alloy::sol_types::private::Address,
            emissionsManager: alloy::sol_types::private::Address,
            pauser: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<SyndicateTokenEmissionSchedulerInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(
                provider,
                _syndicateToken,
                defaultAdmin,
                emissionsManager,
                pauser,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            _syndicateToken: alloy::sol_types::private::Address,
            defaultAdmin: alloy::sol_types::private::Address,
            emissionsManager: alloy::sol_types::private::Address,
            pauser: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            _syndicateToken,
                            defaultAdmin,
                            emissionsManager,
                            pauser,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<
        T,
        P: ::core::clone::Clone,
        N,
    > SyndicateTokenEmissionSchedulerInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(
            self,
        ) -> SyndicateTokenEmissionSchedulerInstance<T, P, N> {
            SyndicateTokenEmissionSchedulerInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyndicateTokenEmissionSchedulerInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`BRIDGE_MANAGER_ROLE`] function.
        pub fn BRIDGE_MANAGER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, BRIDGE_MANAGER_ROLECall, N> {
            self.call_builder(&BRIDGE_MANAGER_ROLECall {})
        }
        ///Creates a new call builder for the [`DEFAULT_ADMIN_ROLE`] function.
        pub fn DEFAULT_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, DEFAULT_ADMIN_ROLECall, N> {
            self.call_builder(&DEFAULT_ADMIN_ROLECall {})
        }
        ///Creates a new call builder for the [`EMISSIONS_MANAGER_ROLE`] function.
        pub fn EMISSIONS_MANAGER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSIONS_MANAGER_ROLECall, N> {
            self.call_builder(&EMISSIONS_MANAGER_ROLECall {})
        }
        ///Creates a new call builder for the [`EMISSION_BUFFER_TIME`] function.
        pub fn EMISSION_BUFFER_TIME(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSION_BUFFER_TIMECall, N> {
            self.call_builder(&EMISSION_BUFFER_TIMECall {})
        }
        ///Creates a new call builder for the [`EPOCH_DURATION`] function.
        pub fn EPOCH_DURATION(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EPOCH_DURATIONCall, N> {
            self.call_builder(&EPOCH_DURATIONCall {})
        }
        ///Creates a new call builder for the [`PAUSER_ROLE`] function.
        pub fn PAUSER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, PAUSER_ROLECall, N> {
            self.call_builder(&PAUSER_ROLECall {})
        }
        ///Creates a new call builder for the [`TOTAL_EPOCHS`] function.
        pub fn TOTAL_EPOCHS(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, TOTAL_EPOCHSCall, N> {
            self.call_builder(&TOTAL_EPOCHSCall {})
        }
        ///Creates a new call builder for the [`bridgeData`] function.
        pub fn bridgeData(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeDataCall, N> {
            self.call_builder(&bridgeDataCall {})
        }
        ///Creates a new call builder for the [`bridgeProxy`] function.
        pub fn bridgeProxy(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeProxyCall, N> {
            self.call_builder(&bridgeProxyCall {})
        }
        ///Creates a new call builder for the [`currentEpoch`] function.
        pub fn currentEpoch(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, currentEpochCall, N> {
            self.call_builder(&currentEpochCall {})
        }
        ///Creates a new call builder for the [`emissionSchedule`] function.
        pub fn emissionSchedule(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionScheduleCall, N> {
            self.call_builder(&emissionScheduleCall { _0 })
        }
        ///Creates a new call builder for the [`emissionsEnded`] function.
        pub fn emissionsEnded(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionsEndedCall, N> {
            self.call_builder(&emissionsEndedCall {})
        }
        ///Creates a new call builder for the [`emissionsStartTime`] function.
        pub fn emissionsStartTime(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionsStartTimeCall, N> {
            self.call_builder(&emissionsStartTimeCall {})
        }
        ///Creates a new call builder for the [`emissionsStarted`] function.
        pub fn emissionsStarted(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, emissionsStartedCall, N> {
            self.call_builder(&emissionsStartedCall {})
        }
        ///Creates a new call builder for the [`getBridgeConfiguration`] function.
        pub fn getBridgeConfiguration(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBridgeConfigurationCall, N> {
            self.call_builder(&getBridgeConfigurationCall {})
        }
        ///Creates a new call builder for the [`getCurrentEpochInfo`] function.
        pub fn getCurrentEpochInfo(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getCurrentEpochInfoCall, N> {
            self.call_builder(&getCurrentEpochInfoCall {})
        }
        ///Creates a new call builder for the [`getEmissionSchedule`] function.
        pub fn getEmissionSchedule(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getEmissionScheduleCall, N> {
            self.call_builder(&getEmissionScheduleCall {})
        }
        ///Creates a new call builder for the [`getNextEmissionTime`] function.
        pub fn getNextEmissionTime(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getNextEmissionTimeCall, N> {
            self.call_builder(&getNextEmissionTimeCall {})
        }
        ///Creates a new call builder for the [`getRoleAdmin`] function.
        pub fn getRoleAdmin(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRoleAdminCall, N> {
            self.call_builder(&getRoleAdminCall { role })
        }
        ///Creates a new call builder for the [`grantRole`] function.
        pub fn grantRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, grantRoleCall, N> {
            self.call_builder(&grantRoleCall { role, account })
        }
        ///Creates a new call builder for the [`hasRole`] function.
        pub fn hasRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, hasRoleCall, N> {
            self.call_builder(&hasRoleCall { role, account })
        }
        ///Creates a new call builder for the [`mintEmission`] function.
        pub fn mintEmission(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, mintEmissionCall, N> {
            self.call_builder(&mintEmissionCall {})
        }
        ///Creates a new call builder for the [`pause`] function.
        pub fn pause(&self) -> alloy_contract::SolCallBuilder<T, &P, pauseCall, N> {
            self.call_builder(&pauseCall {})
        }
        ///Creates a new call builder for the [`paused`] function.
        pub fn paused(&self) -> alloy_contract::SolCallBuilder<T, &P, pausedCall, N> {
            self.call_builder(&pausedCall {})
        }
        ///Creates a new call builder for the [`renounceRole`] function.
        pub fn renounceRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            callerConfirmation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceRoleCall, N> {
            self.call_builder(
                &renounceRoleCall {
                    role,
                    callerConfirmation,
                },
            )
        }
        ///Creates a new call builder for the [`revokeRole`] function.
        pub fn revokeRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, revokeRoleCall, N> {
            self.call_builder(&revokeRoleCall { role, account })
        }
        ///Creates a new call builder for the [`setBridgeData`] function.
        pub fn setBridgeData(
            &self,
            _bridgeData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBridgeDataCall, N> {
            self.call_builder(&setBridgeDataCall { _bridgeData })
        }
        ///Creates a new call builder for the [`setBridgeProxy`] function.
        pub fn setBridgeProxy(
            &self,
            _bridgeProxy: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBridgeProxyCall, N> {
            self.call_builder(&setBridgeProxyCall { _bridgeProxy })
        }
        ///Creates a new call builder for the [`startEmissions`] function.
        pub fn startEmissions(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, startEmissionsCall, N> {
            self.call_builder(&startEmissionsCall {})
        }
        ///Creates a new call builder for the [`supportsInterface`] function.
        pub fn supportsInterface(
            &self,
            interfaceId: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<T, &P, supportsInterfaceCall, N> {
            self.call_builder(
                &supportsInterfaceCall {
                    interfaceId,
                },
            )
        }
        ///Creates a new call builder for the [`syndicateToken`] function.
        pub fn syndicateToken(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, syndicateTokenCall, N> {
            self.call_builder(&syndicateTokenCall {})
        }
        ///Creates a new call builder for the [`totalEmissionsMinted`] function.
        pub fn totalEmissionsMinted(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, totalEmissionsMintedCall, N> {
            self.call_builder(&totalEmissionsMintedCall {})
        }
        ///Creates a new call builder for the [`unpause`] function.
        pub fn unpause(&self) -> alloy_contract::SolCallBuilder<T, &P, unpauseCall, N> {
            self.call_builder(&unpauseCall {})
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyndicateTokenEmissionSchedulerInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`BridgeDataUpdated`] event.
        pub fn BridgeDataUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeDataUpdated, N> {
            self.event_filter::<BridgeDataUpdated>()
        }
        ///Creates a new event filter for the [`BridgeProxyUpdated`] event.
        pub fn BridgeProxyUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeProxyUpdated, N> {
            self.event_filter::<BridgeProxyUpdated>()
        }
        ///Creates a new event filter for the [`EmissionMinted`] event.
        pub fn EmissionMinted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EmissionMinted, N> {
            self.event_filter::<EmissionMinted>()
        }
        ///Creates a new event filter for the [`EmissionsStarted`] event.
        pub fn EmissionsStarted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EmissionsStarted, N> {
            self.event_filter::<EmissionsStarted>()
        }
        ///Creates a new event filter for the [`Paused`] event.
        pub fn Paused_filter(&self) -> alloy_contract::Event<T, &P, Paused, N> {
            self.event_filter::<Paused>()
        }
        ///Creates a new event filter for the [`RoleAdminChanged`] event.
        pub fn RoleAdminChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleAdminChanged, N> {
            self.event_filter::<RoleAdminChanged>()
        }
        ///Creates a new event filter for the [`RoleGranted`] event.
        pub fn RoleGranted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleGranted, N> {
            self.event_filter::<RoleGranted>()
        }
        ///Creates a new event filter for the [`RoleRevoked`] event.
        pub fn RoleRevoked_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleRevoked, N> {
            self.event_filter::<RoleRevoked>()
        }
        ///Creates a new event filter for the [`Unpaused`] event.
        pub fn Unpaused_filter(&self) -> alloy_contract::Event<T, &P, Unpaused, N> {
            self.event_filter::<Unpaused>()
        }
    }
}
