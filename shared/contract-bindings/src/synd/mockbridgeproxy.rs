/**

Generated by the following Solidity interface...
```solidity
interface MockBridgeProxy {
    error AccessControlBadConfirmation();
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
    error BridgeCallFailed(string reason);
    error BridgeNotActive();
    error ExcessiveAmount();
    error ReentrancyGuardReentrantCall();
    error SafeERC20FailedOperation(address token);
    error UnauthorizedCaller();
    error ZeroAddress();
    error ZeroAmount();

    event BridgeExecuted(address indexed token, uint256 amount, address indexed target);
    event BridgeStatusUpdated(bool active);
    event BridgeTargetUpdated(address indexed oldTarget, address indexed newTarget);
    event DailyLimitReset(uint256 day, uint256 previousUsed);
    event DailyLimitUpdated(uint256 oldLimit, uint256 newLimit);
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    constructor(address admin, address caller, address bridgeTarget, uint256 maxSingleTransfer, uint256 dailyLimit);

    function BRIDGE_ADMIN_ROLE() external view returns (bytes32);
    function BRIDGE_CALLER_ROLE() external view returns (bytes32);
    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
    function bridgeActive() external view returns (bool);
    function bridgeName() external view returns (string memory);
    function bridgeTarget() external view returns (address);
    function dailyLimit() external view returns (uint256);
    function dailyUsed() external view returns (uint256);
    function executeBridge(address token, uint256 amount, bytes memory dynamicData) external;
    function getBridgeInfo() external view returns (string memory name, address target, bool active);
    function getDailyUsage() external view returns (uint256 used, uint256 limit, uint256 remaining);
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function grantRole(bytes32 role, address account) external;
    function hasRole(bytes32 role, address account) external view returns (bool);
    function lastExecutedAmount() external view returns (uint256);
    function lastExecutedData() external view returns (bytes memory);
    function lastExecutedToken() external view returns (address);
    function lastResetDay() external view returns (uint256);
    function maxSingleTransfer() external view returns (uint256);
    function recoverTokens(address token, uint256 amount, address to) external;
    function renounceRole(bytes32 role, address callerConfirmation) external;
    function revokeRole(bytes32 role, address account) external;
    function setBridgeActive(bool active) external;
    function setBridgeTarget(address target) external;
    function setDailyLimit(uint256 limit) external;
    function setMaxSingleTransfer(uint256 amount) external;
    function setShouldRevert(bool _shouldRevert) external;
    function shouldRevert() external view returns (bool);
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "admin",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "bridgeTarget",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "maxSingleTransfer",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "dailyLimit",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "BRIDGE_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "BRIDGE_CALLER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DEFAULT_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeActive",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeName",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeTarget",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "dailyLimit",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "dailyUsed",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "executeBridge",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "dynamicData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getBridgeInfo",
    "inputs": [],
    "outputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "active",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getDailyUsage",
    "inputs": [],
    "outputs": [
      {
        "name": "used",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "limit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "remaining",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleAdmin",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "grantRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "hasRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "lastExecutedAmount",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "lastExecutedData",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "lastExecutedToken",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "lastResetDay",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "maxSingleTransfer",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "recoverTokens",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "callerConfirmation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBridgeActive",
    "inputs": [
      {
        "name": "active",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBridgeTarget",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setDailyLimit",
    "inputs": [
      {
        "name": "limit",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setMaxSingleTransfer",
    "inputs": [
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setShouldRevert",
    "inputs": [
      {
        "name": "_shouldRevert",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "shouldRevert",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "event",
    "name": "BridgeExecuted",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "target",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeStatusUpdated",
    "inputs": [
      {
        "name": "active",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeTargetUpdated",
    "inputs": [
      {
        "name": "oldTarget",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newTarget",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DailyLimitReset",
    "inputs": [
      {
        "name": "day",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "previousUsed",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DailyLimitUpdated",
    "inputs": [
      {
        "name": "oldLimit",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "newLimit",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleAdminChanged",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "previousAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleGranted",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleRevoked",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AccessControlBadConfirmation",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AccessControlUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "neededRole",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "BridgeCallFailed",
    "inputs": [
      {
        "name": "reason",
        "type": "string",
        "internalType": "string"
      }
    ]
  },
  {
    "type": "error",
    "name": "BridgeNotActive",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ExcessiveAmount",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ReentrancyGuardReentrantCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SafeERC20FailedOperation",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "UnauthorizedCaller",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroAddress",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroAmount",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod MockBridgeProxy {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6080604052346100335761001d610014610156565b939290926101fe565b610025610038565b612294610929823961229490f35b61003e565b60405190565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b9061006a90610042565b810190811060018060401b0382111761008257604052565b61004c565b9061009a610093610038565b9283610060565b565b5f80fd5b60018060a01b031690565b6100b4906100a0565b90565b6100c0816100ab565b036100c757565b5f80fd5b905051906100d8826100b7565b565b90565b6100e6816100da565b036100ed57565b5f80fd5b905051906100fe826100dd565b565b919060a08382031261015157610118815f85016100cb565b9261012682602083016100cb565b9261014e61013784604085016100cb565b9361014581606086016100f1565b936080016100f1565b90565b61009c565b610174612bbd8038038061016981610087565b928339810190610100565b9091929394565b60018060401b03811161019757610193602091610042565b0190565b61004c565b906101ae6101a98361017b565b610087565b918252565b5f7f4d6f636b20427269646765000000000000000000000000000000000000000000910152565b6101e4600b61019c565b906101f1602083016101b3565b565b6101fb6101da565b90565b916102179492939161020e6101f3565b91929394610665565b565b90565b90565b61023361022e61023892610219565b61021c565b6100a0565b90565b6102449061021f565b90565b5f0190565b90565b5f1b90565b61026861026361026d92610219565b61024f565b61024c565b90565b6102795f610254565b90565b7f751b795d24b92e3d92d1d0d8f2885f4e9c9c269da350af36ae6b49069babf4bf90565b7fc074beb46b251f73c0fec16eba75d6bc0042d09ee17a740ebbee308dbf87f82f90565b5190565b634e487b7160e01b5f52602260045260245ffd5b90600160028304921680156102fc575b60208310146102f757565b6102c8565b91607f16916102ec565b5f5260205f2090565b601f602091010490565b1b90565b919060086103389102916103325f1984610319565b92610319565b9181191691161790565b61035661035161035b926100da565b61021c565b6100da565b90565b90565b919061037761037261037f93610342565b61035e565b90835461031d565b9055565b5f90565b61039991610393610383565b91610361565b565b5b8181106103a7575050565b806103b45f600193610387565b0161039c565b9190601f81116103ca575b505050565b6103d66103fb93610306565b9060206103e28461030f565b83019310610403575b6103f49061030f565b019061039b565b5f80806103c5565b91506103f4819290506103eb565b1c90565b90610425905f1990600802610411565b191690565b8161043491610415565b906002021790565b90610446816102c4565b9060018060401b038211610504576104688261046285546102dc565b856103ba565b602090601f831160011461049c5791809161048b935f92610490575b505061042a565b90555b565b90915001515f80610484565b601f198316916104ab85610306565b925f5b8181106104ec575091600293918560019694106104d2575b5050500201905561048e565b6104e2910151601f841690610415565b90555f80806104c6565b919360206001819287870151815501950192016104ae565b61004c565b906105139161043c565b565b9061052660018060a01b039161024f565b9181191691161790565b61054461053f610549926100a0565b61021c565b6100a0565b90565b61055590610530565b90565b6105619061054c565b90565b90565b9061057c61057761058392610558565b610564565b8254610515565b9055565b906105935f199161024f565b9181191691161790565b906105b26105ad6105b992610342565b61035e565b8254610587565b9055565b60a01b90565b906105d260ff60a01b916105bd565b9181191691161790565b151590565b6105ea906105dc565b90565b90565b9061060561060061060c926105e1565b6105ed565b82546105c3565b9055565b90565b61062761062261062c92610610565b61021c565b6100da565b90565b634e487b7160e01b5f52601260045260245ffd5b61064f610655916100da565b916100da565b908115610660570490565b61062f565b9094939192610672610791565b8161068d6106876106825f61023b565b6100ab565b916100ab565b148015610743575b610727576106e46106f2946106dc6106f9986106ce6106eb966106c06106b9610270565b8290610817565b506106c961027c565b610817565b506106d76102a0565b610817565b506007610509565b6002610567565b600361059d565b600461059d565b610705600160026105f0565b61072561071e4261071862015180610613565b90610643565b600661059d565b565b5f63d92e233d60e01b81528061073f60048201610247565b0390fd5b508561075f6107596107545f61023b565b6100ab565b916100ab565b14610695565b90565b61077c61077761078192610765565b61021c565b6100da565b90565b61078e6001610768565b90565b6107a361079c610784565b600161059d565b565b5f90565b6107b29061024c565b90565b906107bf906107a9565b5f5260205260405f2090565b906107d590610558565b5f5260205260405f2090565b906107ed60ff9161024f565b9181191691161790565b9061080c610807610813926105e1565b6105ed565b82546107e1565b9055565b61081f6107a5565b5061083461082e8284906108ee565b156105dc565b5f146108bc5761085b60016108565f61084e8186906107b5565b0185906107cb565b6107f7565b9061086461091b565b906108a161089b6108957f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d956107a9565b92610558565b92610558565b926108aa610038565b806108b481610247565b0390a4600190565b50505f90565b5f1c90565b60ff1690565b6108d96108de916108c2565b6108c7565b90565b6108eb90546108cd565b90565b610914915f61090961090f936109026107a5565b50826107b5565b016107cb565b6108e1565b90565b5f90565b610923610917565b50339056fe60806040526004361015610013575b61105c565b61001d5f356101ec565b806301ffc9a7146101e75780631033b4cc146101e2578063118c38c7146101dd5780631259a5c8146101d857806318b68b8c146101d3578063248a9ca3146101ce5780632f2ff15d146101c95780633462fac3146101c457806336568abe146101bf57806336b089d8146101ba5780635ab1d61c146101b557806361b0a56e146101b057806363221490146101ab57806365d7a3c9146101a657806367eeba0c146101a15780636813d7871461019c5780636bcc8c141461019757806391d1485414610192578063a217fddf1461018d578063b16e784914610188578063b20d30a914610183578063c9f5b63e1461017e578063cc3dc06114610179578063d3072d8214610174578063d547741f1461016f578063ead93c8f1461016a578063ede7cebd14610165578063f681a862146101605763fb8c4b510361000e57611024565b610fbd565b610f76565b610f0c565b610ec8565b610e93565b610e23565b610ca4565b610c62565b610c2d565b610b96565b610b25565b610af2565b610aa1565b610a6c565b610a28565b610808565b6107b6565b610749565b6106d3565b610690565b61065b565b6105f8565b610596565b61051e565b6103ea565b6103a6565b61031d565b610278565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b63ffffffff60e01b1690565b61021981610204565b0361022057565b5f80fd5b9050359061023182610210565b565b9060208282031261024c57610249915f01610224565b90565b6101fc565b151590565b61025f90610251565b9052565b9190610276905f60208501940190610256565b565b346102a8576102a461029361028e366004610233565b611064565b61029b6101f2565b91829182610263565b0390f35b6101f8565b5f9103126102b757565b6101fc565b1c90565b90565b6102d39060086102d893026102bc565b6102c0565b90565b906102e691546102c3565b90565b6102f560055f906102db565b90565b90565b610304906102f8565b9052565b919061031b905f602085019401906102fb565b565b3461034d5761032d3660046102ad565b6103496103386102e9565b6103406101f2565b91829182610308565b0390f35b6101f8565b7f751b795d24b92e3d92d1d0d8f2885f4e9c9c269da350af36ae6b49069babf4bf90565b61037e610352565b90565b90565b61038d90610381565b9052565b91906103a4905f60208501940190610384565b565b346103d6576103b63660046102ad565b6103d26103c1610376565b6103c96101f2565b91829182610391565b0390f35b6101f8565b6103e760065f906102db565b90565b3461041a576103fa3660046102ad565b6104166104056103db565b61040d6101f2565b91829182610308565b0390f35b6101f8565b60018060a01b031690565b6104339061041f565b90565b61043f8161042a565b0361044657565b5f80fd5b9050359061045782610436565b565b610462816102f8565b0361046957565b5f80fd5b9050359061047a82610459565b565b5f80fd5b5f80fd5b5f80fd5b909182601f830112156104c25781359167ffffffffffffffff83116104bd5760200192600183028401116104b857565b610484565b610480565b61047c565b91606083830312610514576104de825f850161044a565b926104ec836020830161046d565b92604082013567ffffffffffffffff811161050f5761050b9201610488565b9091565b610200565b6101fc565b5f0190565b346105505761053a6105313660046104c7565b92919091611492565b6105426101f2565b8061054c81610519565b0390f35b6101f8565b61055e81610381565b0361056557565b5f80fd5b9050359061057682610555565b565b906020828203126105915761058e915f01610569565b90565b6101fc565b346105c6576105c26105b16105ac366004610578565b6114ea565b6105b96101f2565b91829182610391565b0390f35b6101f8565b91906040838203126105f357806105e76105f0925f8601610569565b9360200161044a565b90565b6101fc565b346106275761061161060b3660046105cb565b90611535565b6106196101f2565b8061062381610519565b0390f35b6101f8565b7fc074beb46b251f73c0fec16eba75d6bc0042d09ee17a740ebbee308dbf87f82f90565b61065861062c565b90565b3461068b5761066b3660046102ad565b610687610676610650565b61067e6101f2565b91829182610391565b0390f35b6101f8565b346106bf576106a96106a33660046105cb565b90611541565b6106b16101f2565b806106bb81610519565b0390f35b6101f8565b6106d060035f906102db565b90565b34610703576106e33660046102ad565b6106ff6106ee6106c4565b6106f66101f2565b91829182610308565b0390f35b6101f8565b61071181610251565b0361071857565b5f80fd5b9050359061072982610708565b565b9060208282031261074457610741915f0161071c565b90565b6101fc565b346107775761076161075c36600461072b565b611638565b6107696101f2565b8061077381610519565b0390f35b6101f8565b90916060828403126107b1576107ae610797845f850161044a565b936107a5816020860161046d565b9360400161044a565b90565b6101fc565b346107e5576107cf6107c936600461077c565b916116b4565b6107d76101f2565b806107e181610519565b0390f35b6101f8565b9060208282031261080357610800915f0161046d565b90565b6101fc565b346108365761082061081b3660046107ea565b6116e9565b6108286101f2565b8061083281610519565b0390f35b6101f8565b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52602260045260245ffd5b9060016002830492168015610882575b602083101461087d57565b61084e565b91607f1691610872565b60209181520190565b5f5260205f2090565b905f92918054906108b86108b183610862565b809461088c565b916001811690815f1461090f57506001146108d3575b505050565b6108e09192939450610895565b915f925b8184106108f757505001905f80806108ce565b600181602092959395548486015201910192906108e4565b92949550505060ff19168252151560200201905f80806108ce565b906109349161089e565b90565b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b9061095f90610937565b810190811067ffffffffffffffff82111761097957604052565b610941565b9061099e6109979261098e6101f2565b9384809261092a565b0383610955565b565b905f106109b3576109b09061097e565b90565b61083b565b6109c460075f906109a0565b90565b5190565b60209181520190565b90825f9392825e0152565b6109fe610a07602093610a0c936109f5816109c7565b938480936109cb565b958691016109d4565b610937565b0190565b610a259160208201915f8184039101526109df565b90565b34610a5857610a383660046102ad565b610a54610a436109b8565b610a4b6101f2565b91829182610a10565b0390f35b6101f8565b610a6960045f906102db565b90565b34610a9c57610a7c3660046102ad565b610a98610a87610a5d565b610a8f6101f2565b91829182610308565b0390f35b6101f8565b34610acf57610ab9610ab436600461072b565b61172a565b610ac16101f2565b80610acb81610519565b0390f35b6101f8565b90602082820312610aed57610aea915f0161044a565b90565b6101fc565b34610b2057610b0a610b05366004610ad4565b61182d565b610b126101f2565b80610b1c81610519565b0390f35b6101f8565b34610b5657610b52610b41610b3b3660046105cb565b9061186f565b610b496101f2565b91829182610263565b0390f35b6101f8565b90565b5f1b90565b610b77610b72610b7c92610b5b565b610b5e565b610381565b90565b610b885f610b63565b90565b610b93610b7f565b90565b34610bc657610ba63660046102ad565b610bc2610bb1610b8b565b610bb96101f2565b91829182610391565b0390f35b6101f8565b60018060a01b031690565b610be6906008610beb93026102bc565b610bcb565b90565b90610bf99154610bd6565b90565b610c08600a5f90610bee565b90565b610c149061042a565b9052565b9190610c2b905f60208501940190610c0b565b565b34610c5d57610c3d3660046102ad565b610c59610c48610bfc565b610c506101f2565b91829182610c18565b0390f35b6101f8565b34610c9057610c7a610c753660046107ea565b611927565b610c826101f2565b80610c8c81610519565b0390f35b6101f8565b610ca160025f90610bee565b90565b34610cd457610cb43660046102ad565b610cd0610cbf610c95565b610cc76101f2565b91829182610c18565b0390f35b6101f8565b60209181520190565b5f5260205f2090565b905f9291805490610d05610cfe83610862565b8094610cd9565b916001811690815f14610d5c5750600114610d20575b505050565b610d2d9192939450610ce2565b915f925b818410610d4457505001905f8080610d1b565b60018160209295939554848601520191019290610d31565b92949550505060ff19168252151560200201905f8080610d1b565b90610d8191610ceb565b90565b90610da4610d9d92610d946101f2565b93848092610d77565b0383610955565b565b905f10610db957610db690610d84565b90565b61083b565b610dca600b5f90610da6565b90565b5190565b60209181520190565b610df9610e02602093610e0793610df081610dcd565b93848093610dd1565b958691016109d4565b610937565b0190565b610e209160208201915f818403910152610dda565b90565b34610e5357610e333660046102ad565b610e4f610e3e610dbe565b610e466101f2565b91829182610e0b565b0390f35b6101f8565b60ff1690565b610e6e906008610e7393026102bc565b610e58565b90565b90610e819154610e5e565b90565b610e9060085f90610e76565b90565b34610ec357610ea33660046102ad565b610ebf610eae610e84565b610eb66101f2565b91829182610263565b0390f35b6101f8565b34610ef757610ee1610edb3660046105cb565b9061195c565b610ee96101f2565b80610ef381610519565b0390f35b6101f8565b610f096002601490610e76565b90565b34610f3c57610f1c3660046102ad565b610f38610f27610efc565b610f2f6101f2565b91829182610263565b0390f35b6101f8565b604090610f6d610f62610f749597969460608401908482035f8601526109df565b966020830190610c0b565b0190610256565b565b34610fa957610f863660046102ad565b610fa5610f9161197d565b610f9c9391936101f2565b93849384610f41565b0390f35b6101f8565b610fba60095f906102db565b90565b34610fed57610fcd3660046102ad565b610fe9610fd8610fae565b610fe06101f2565b91829182610308565b0390f35b6101f8565b60409061101b611022949695939661101160608401985f8501906102fb565b60208301906102fb565b01906102fb565b565b34611057576110343660046102ad565b61105361103f6119e6565b61104a9391936101f2565b93849384610ff2565b0390f35b6101f8565b5f80fd5b5f90565b61106c611060565b5080611087611081637965db0b60e01b610204565b91610204565b14908115611094575b5090565b61109e9150611a74565b5f611090565b906110b89392916110b3611ac6565b6110e9565b6110c0611b4a565b565b60a01c90565b6110d46110d9916110c2565b610e58565b90565b6110e690546110c8565b90565b9291906110ff6110f960026110dc565b15610251565b61110e5761110c9361112a565b565b5f633df5105960e11b81528061112660048201610519565b0390fd5b92919061114861114261113b61062c565b339061186f565b15610251565b61115757611155936112e7565b565b5f635c427cd960e01b81528061116f60048201610519565b0390fd5b90565b61118a61118561118f92610b5b565b611173565b61041f565b90565b61119b90611176565b90565b6111b26111ad6111b792610b5b565b611173565b6102f8565b90565b5f1c90565b6111cb6111d0916111ba565b6102c0565b90565b6111dd90546111bf565b90565b634e487b7160e01b5f52601160045260245ffd5b611203611209919392936102f8565b926102f8565b820180921161121457565b6111e0565b61122d6112286112329261041f565b611173565b61041f565b90565b61123e90611219565b90565b61124a90611235565b90565b61125690611219565b90565b6112629061124d565b90565b906112715f1991610b5e565b9181191691161790565b61128f61128a611294926102f8565b611173565b6102f8565b90565b90565b906112af6112aa6112b69261127b565b611297565b8254611265565b9055565b6112c66112cb916111ba565b610bcb565b90565b6112d890546112ba565b90565b6112e49061124d565b90565b91929092826113066113006112fb5f611192565b61042a565b9161042a565b14611476578361131e6113185f61119e565b916102f8565b1461145a578361133f61133961133460036111d3565b6102f8565b916102f8565b1161143e5761134c611bb3565b61136061135960056111d3565b85906111f4565b61137b61137561137060046111d3565b6102f8565b916102f8565b11611422576113ad916113a261139085611241565b3361139a30611259565b908892611cbf565b839185909192611f4e565b6113ca6113c3836113be60056111d3565b6111f4565b600561129a565b6113d460026112ce565b9061141d61140b6114057f3dba401dc1abbf017086864b33ba815f53ab3cdbb9366ba6bcd8ec342ddd98e8936112db565b936112db565b936114146101f2565b91829182610308565b0390a3565b5f631c345a2f60e21b81528061143a60048201610519565b0390fd5b5f631c345a2f60e21b81528061145660048201610519565b0390fd5b5f631f2a200560e01b81528061147260048201610519565b0390fd5b5f63d92e233d60e01b81528061148e60048201610519565b0390fd5b9061149e9392916110a4565b565b5f90565b6114ad90610381565b90565b906114ba906114a4565b5f5260205260405f2090565b90565b6114d56114da916111ba565b6114c6565b90565b6114e790546114c9565b90565b6001611502611508926114fb6114a0565b505f6114b0565b016114dd565b90565b906115269161152161151c826114ea565b611fa4565b611528565b565b9061153291611fb8565b50565b9061153f9161150b565b565b908061155c611556611551612063565b61042a565b9161042a565b0361156d5761156a91612070565b50565b5f63334bd91960e11b81528061158560048201610519565b0390fd5b6115a29061159d611598610352565b611fa4565b6115f2565b565b60a01b90565b906115b960ff60a01b916115a4565b9181191691161790565b6115cc90610251565b90565b90565b906115e76115e26115ee926115c3565b6115cf565b82546115aa565b9055565b6115fd8160026115d2565b6116337fb3418989d06835b5c215eebb4d54ed6be7bbb66eb4807164740a2e082fa782d59161162a6101f2565b91829182610263565b0390a1565b61164190611589565b565b9061165e9291611659611654610b7f565b611fa4565b611660565b565b91908161167d6116776116725f611192565b61042a565b9161042a565b146116985761168e61169693611241565b919091612134565b565b5f63d92e233d60e01b8152806116b060048201610519565b0390fd5b906116bf9291611643565b565b6116da906116d56116d0610352565b611fa4565b6116dc565b565b6116e790600361129a565b565b6116f2906116c1565b565b9061170060ff91610b5e565b9181191691161790565b9061171f61171a611726926115c3565b6115cf565b82546116f4565b9055565b61173590600861170a565b565b6117509061174b611746610352565b611fa4565b611790565b565b9061176360018060a01b0391610b5e565b9181191691161790565b90565b9061178561178061178c926112db565b61176d565b8254611752565b9055565b806117ab6117a56117a05f611192565b61042a565b9161042a565b14611811576117ba60026112ce565b6117c5826002611770565b906117f96117f37fb07f8b1b85042d74022c867c836edeb0bcd70e135b0042390d2b1fd108298069936112db565b916112db565b916118026101f2565b8061180c81610519565b0390a3565b5f63d92e233d60e01b81528061182960048201610519565b0390fd5b61183690611737565b565b90611842906112db565b5f5260205260405f2090565b61185a61185f916111ba565b610e58565b90565b61186c905461184e565b90565b611895915f61188a61189093611883611060565b50826114b0565b01611838565b611862565b90565b6118b1906118ac6118a7610352565b611fa4565b6118d6565b565b9160206118d49294936118cd60408201965f8301906102fb565b01906102fb565b565b6118e060046111d3565b6118eb82600461129a565b907f207c4cbdf55ec315a13f0d5e047732ec5d947da056e706593aa509909941cedf916119226119196101f2565b928392836118b3565b0390a1565b61193090611898565b565b9061194d91611948611943826114ea565b611fa4565b61194f565b565b9061195991612070565b50565b9061196691611932565b565b606090565b5f90565b61197a9061097e565b90565b611985611968565b5061198e61196d565b50611997611060565b5060076119a460026112ce565b916119b86119b260026110dc565b92611971565b929190565b5f90565b6119d06119d6919392936102f8565b926102f8565b82039182116119e157565b6111e0565b6119ee6119bd565b506119f76119bd565b50611a006119bd565b50611a0b60056111d3565b611a1560046111d3565b91611a2060046111d3565b611a3b611a35611a3060056111d3565b6102f8565b916102f8565b115f14611a6657611a5f611a4f60046111d3565b611a5960056111d3565b906119c1565b5b91929190565b611a6f5f61119e565b611a60565b611a7c611060565b50611a96611a906301ffc9a760e01b610204565b91610204565b1490565b90565b611ab1611aac611ab692611a9a565b611173565b6102f8565b90565b611ac36002611a9d565b90565b611ad060016111d3565b611ae9611ae3611ade611ab9565b6102f8565b916102f8565b14611b0257611b00611af9611ab9565b600161129a565b565b5f633ee5aeb560e01b815280611b1a60048201610519565b0390fd5b90565b611b35611b30611b3a92611b1e565b611173565b6102f8565b90565b611b476001611b21565b90565b611b5c611b55611b3d565b600161129a565b565b90565b611b75611b70611b7a92611b5e565b611173565b6102f8565b90565b634e487b7160e01b5f52601260045260245ffd5b611b9d611ba3916102f8565b916102f8565b908115611bae570490565b611b7d565b611bc942611bc362015180611b61565b90611b91565b80611be5611bdf611bda60066111d3565b6102f8565b916102f8565b11611bee575b50565b80611c5091611bfd60056111d3565b7fda4e39dd56d72c2ee3d132e0146bc39e905e78e3bc64c40190421c7b2bcef2ab91611c33611c2a6101f2565b928392836118b3565b0390a1611c49611c425f61119e565b600561129a565b600661129a565b5f611beb565b611c5f9061124d565b90565b63ffffffff1690565b60e01b90565b611c85611c80611c8a92611c62565b611c6b565b610204565b90565b604090611cb6611cbd9496959396611cac60608401985f850190610c0b565b6020830190610c0b565b01906102fb565b565b600492611cf9611d0d9593611d089394611ce06323b872dd92949192611c71565b93611ce96101f2565b9788956020870190815201611c8d565b60208201810382520383610955565b612182565b565b5f7f4d6f636b2062726964676520657865637574696f6e206661696c656400000000910152565b611d43601c6020926109cb565b611d4c81611d0f565b0190565b611d659060208101905f818303910152611d36565b90565b5090565b601f602091010490565b1b90565b91906008611d95910291611d8f5f1984611d76565b92611d76565b9181191691161790565b9190611db5611db0611dbd9361127b565b611297565b908354611d7a565b9055565b611dd391611dcd6119bd565b91611d9f565b565b5b818110611de1575050565b80611dee5f600193611dc1565b01611dd6565b9190601f8111611e04575b505050565b611e10611e3593610ce2565b906020611e1c84611d6c565b83019310611e3d575b611e2e90611d6c565b0190611dd5565b5f8080611dff565b9150611e2e81929050611e25565b90611e5b905f19906008026102bc565b191690565b81611e6a91611e4b565b906002021790565b91611e7d9082611d68565b9067ffffffffffffffff8211611f3c57611ea182611e9b8554610862565b85611df4565b5f90601f8311600114611ed457918091611ec3935f92611ec8575b5050611e60565b90555b565b90915001355f80611ebc565b601f19831691611ee385610ce2565b925f5b818110611f2457509160029391856001969410611f0a575b50505002019055611ec6565b611f1a910135601f841690611e4b565b90555f8080611efe565b91936020600181928787013581550195019201611ee6565b610941565b90611f4c9291611e72565b565b92919092611f5c6008611862565b611f8257611f8093611f72611f7992600a611770565b600961129a565b600b611f41565b565b611f8a6101f2565b62461bcd60e51b815280611fa060048201611d50565b0390fd5b611fb690611fb0612063565b90612259565b565b611fc0611060565b50611fd5611fcf82849061186f565b15610251565b5f1461205d57611ffc6001611ff75f611fef8186906114b0565b018590611838565b61170a565b90612005612063565b9061204261203c6120367f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d956114a4565b926112db565b926112db565b9261204b6101f2565b8061205581610519565b0390a4600190565b50505f90565b61206b61196d565b503390565b612078611060565b5061208481839061186f565b5f1461210b576120aa5f6120a55f61209d8186906114b0565b018590611838565b61170a565b906120b3612063565b906120f06120ea6120e47ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b956114a4565b926112db565b926112db565b926120f96101f2565b8061210381610519565b0390a4600190565b50505f90565b91602061213292949361212b60408201965f830190610c0b565b01906102fb565b565b9061217b6121809361216c6004949361215363a9059cbb919391611c71565b9261215c6101f2565b9687946020860190815201612111565b60208201810382520383610955565b612182565b565b905f60209161218f6119bd565b506121986119bd565b50828151910182855af11561222b573d5f51906121bd6121b75f61119e565b916102f8565b145f1461221157506121ce81611c56565b3b6121e16121db5f61119e565b916102f8565b145b6121ea5750565b6121f661220d91611c56565b5f918291635274afe760e01b835260048301610c18565b0390fd5b61222461221e6001611b21565b916102f8565b14156121e3565b6040513d5f823e3d90fd5b91602061225792949361225060408201965f830190610c0b565b0190610384565b565b9061226e61226883839061186f565b15610251565b612276575050565b6122905f92839263e2517d3f60e01b845260048401612236565b0390fd
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4a\x003Wa\0\x1Da\0\x14a\x01VV[\x93\x92\x90\x92a\x01\xFEV[a\0%a\08V[a\"\x94a\t)\x829a\"\x94\x90\xF3[a\0>V[`@Q\x90V[_\x80\xFD[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\0j\x90a\0BV[\x81\x01\x90\x81\x10`\x01\x80`@\x1B\x03\x82\x11\x17a\0\x82W`@RV[a\0LV[\x90a\0\x9Aa\0\x93a\08V[\x92\x83a\0`V[V[_\x80\xFD[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\0\xB4\x90a\0\xA0V[\x90V[a\0\xC0\x81a\0\xABV[\x03a\0\xC7WV[_\x80\xFD[\x90PQ\x90a\0\xD8\x82a\0\xB7V[V[\x90V[a\0\xE6\x81a\0\xDAV[\x03a\0\xEDWV[_\x80\xFD[\x90PQ\x90a\0\xFE\x82a\0\xDDV[V[\x91\x90`\xA0\x83\x82\x03\x12a\x01QWa\x01\x18\x81_\x85\x01a\0\xCBV[\x92a\x01&\x82` \x83\x01a\0\xCBV[\x92a\x01Na\x017\x84`@\x85\x01a\0\xCBV[\x93a\x01E\x81``\x86\x01a\0\xF1V[\x93`\x80\x01a\0\xF1V[\x90V[a\0\x9CV[a\x01ta+\xBD\x808\x03\x80a\x01i\x81a\0\x87V[\x92\x839\x81\x01\x90a\x01\0V[\x90\x91\x92\x93\x94V[`\x01\x80`@\x1B\x03\x81\x11a\x01\x97Wa\x01\x93` \x91a\0BV[\x01\x90V[a\0LV[\x90a\x01\xAEa\x01\xA9\x83a\x01{V[a\0\x87V[\x91\x82RV[_\x7FMock Bridge\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x01\xE4`\x0Ba\x01\x9CV[\x90a\x01\xF1` \x83\x01a\x01\xB3V[V[a\x01\xFBa\x01\xDAV[\x90V[\x91a\x02\x17\x94\x92\x93\x91a\x02\x0Ea\x01\xF3V[\x91\x92\x93\x94a\x06eV[V[\x90V[\x90V[a\x023a\x02.a\x028\x92a\x02\x19V[a\x02\x1CV[a\0\xA0V[\x90V[a\x02D\x90a\x02\x1FV[\x90V[_\x01\x90V[\x90V[_\x1B\x90V[a\x02ha\x02ca\x02m\x92a\x02\x19V[a\x02OV[a\x02LV[\x90V[a\x02y_a\x02TV[\x90V[\x7Fu\x1By]$\xB9.=\x92\xD1\xD0\xD8\xF2\x88_N\x9C\x9C&\x9D\xA3P\xAF6\xAEkI\x06\x9B\xAB\xF4\xBF\x90V[\x7F\xC0t\xBE\xB4k%\x1Fs\xC0\xFE\xC1n\xBAu\xD6\xBC\0B\xD0\x9E\xE1zt\x0E\xBB\xEE0\x8D\xBF\x87\xF8/\x90V[Q\x90V[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x02\xFCW[` \x83\x10\x14a\x02\xF7WV[a\x02\xC8V[\x91`\x7F\x16\x91a\x02\xECV[_R` _ \x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a\x038\x91\x02\x91a\x032_\x19\x84a\x03\x19V[\x92a\x03\x19V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x03Va\x03Qa\x03[\x92a\0\xDAV[a\x02\x1CV[a\0\xDAV[\x90V[\x90V[\x91\x90a\x03wa\x03ra\x03\x7F\x93a\x03BV[a\x03^V[\x90\x83Ta\x03\x1DV[\x90UV[_\x90V[a\x03\x99\x91a\x03\x93a\x03\x83V[\x91a\x03aV[V[[\x81\x81\x10a\x03\xA7WPPV[\x80a\x03\xB4_`\x01\x93a\x03\x87V[\x01a\x03\x9CV[\x91\x90`\x1F\x81\x11a\x03\xCAW[PPPV[a\x03\xD6a\x03\xFB\x93a\x03\x06V[\x90` a\x03\xE2\x84a\x03\x0FV[\x83\x01\x93\x10a\x04\x03W[a\x03\xF4\x90a\x03\x0FV[\x01\x90a\x03\x9BV[_\x80\x80a\x03\xC5V[\x91Pa\x03\xF4\x81\x92\x90Pa\x03\xEBV[\x1C\x90V[\x90a\x04%\x90_\x19\x90`\x08\x02a\x04\x11V[\x19\x16\x90V[\x81a\x044\x91a\x04\x15V[\x90`\x02\x02\x17\x90V[\x90a\x04F\x81a\x02\xC4V[\x90`\x01\x80`@\x1B\x03\x82\x11a\x05\x04Wa\x04h\x82a\x04b\x85Ta\x02\xDCV[\x85a\x03\xBAV[` \x90`\x1F\x83\x11`\x01\x14a\x04\x9CW\x91\x80\x91a\x04\x8B\x93_\x92a\x04\x90W[PPa\x04*V[\x90U[V[\x90\x91P\x01Q_\x80a\x04\x84V[`\x1F\x19\x83\x16\x91a\x04\xAB\x85a\x03\x06V[\x92_[\x81\x81\x10a\x04\xECWP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\x04\xD2W[PPP\x02\x01\x90Ua\x04\x8EV[a\x04\xE2\x91\x01Q`\x1F\x84\x16\x90a\x04\x15V[\x90U_\x80\x80a\x04\xC6V[\x91\x93` `\x01\x81\x92\x87\x87\x01Q\x81U\x01\x95\x01\x92\x01a\x04\xAEV[a\0LV[\x90a\x05\x13\x91a\x04<V[V[\x90a\x05&`\x01\x80`\xA0\x1B\x03\x91a\x02OV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x05Da\x05?a\x05I\x92a\0\xA0V[a\x02\x1CV[a\0\xA0V[\x90V[a\x05U\x90a\x050V[\x90V[a\x05a\x90a\x05LV[\x90V[\x90V[\x90a\x05|a\x05wa\x05\x83\x92a\x05XV[a\x05dV[\x82Ta\x05\x15V[\x90UV[\x90a\x05\x93_\x19\x91a\x02OV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a\x05\xB2a\x05\xADa\x05\xB9\x92a\x03BV[a\x03^V[\x82Ta\x05\x87V[\x90UV[`\xA0\x1B\x90V[\x90a\x05\xD2`\xFF`\xA0\x1B\x91a\x05\xBDV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x15\x15\x90V[a\x05\xEA\x90a\x05\xDCV[\x90V[\x90V[\x90a\x06\x05a\x06\0a\x06\x0C\x92a\x05\xE1V[a\x05\xEDV[\x82Ta\x05\xC3V[\x90UV[\x90V[a\x06'a\x06\"a\x06,\x92a\x06\x10V[a\x02\x1CV[a\0\xDAV[\x90V[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[a\x06Oa\x06U\x91a\0\xDAV[\x91a\0\xDAV[\x90\x81\x15a\x06`W\x04\x90V[a\x06/V[\x90\x94\x93\x91\x92a\x06ra\x07\x91V[\x81a\x06\x8Da\x06\x87a\x06\x82_a\x02;V[a\0\xABV[\x91a\0\xABV[\x14\x80\x15a\x07CW[a\x07'Wa\x06\xE4a\x06\xF2\x94a\x06\xDCa\x06\xF9\x98a\x06\xCEa\x06\xEB\x96a\x06\xC0a\x06\xB9a\x02pV[\x82\x90a\x08\x17V[Pa\x06\xC9a\x02|V[a\x08\x17V[Pa\x06\xD7a\x02\xA0V[a\x08\x17V[P`\x07a\x05\tV[`\x02a\x05gV[`\x03a\x05\x9DV[`\x04a\x05\x9DV[a\x07\x05`\x01`\x02a\x05\xF0V[a\x07%a\x07\x1EBa\x07\x18b\x01Q\x80a\x06\x13V[\x90a\x06CV[`\x06a\x05\x9DV[V[_c\xD9.#=`\xE0\x1B\x81R\x80a\x07?`\x04\x82\x01a\x02GV[\x03\x90\xFD[P\x85a\x07_a\x07Ya\x07T_a\x02;V[a\0\xABV[\x91a\0\xABV[\x14a\x06\x95V[\x90V[a\x07|a\x07wa\x07\x81\x92a\x07eV[a\x02\x1CV[a\0\xDAV[\x90V[a\x07\x8E`\x01a\x07hV[\x90V[a\x07\xA3a\x07\x9Ca\x07\x84V[`\x01a\x05\x9DV[V[_\x90V[a\x07\xB2\x90a\x02LV[\x90V[\x90a\x07\xBF\x90a\x07\xA9V[_R` R`@_ \x90V[\x90a\x07\xD5\x90a\x05XV[_R` R`@_ \x90V[\x90a\x07\xED`\xFF\x91a\x02OV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a\x08\x0Ca\x08\x07a\x08\x13\x92a\x05\xE1V[a\x05\xEDV[\x82Ta\x07\xE1V[\x90UV[a\x08\x1Fa\x07\xA5V[Pa\x084a\x08.\x82\x84\x90a\x08\xEEV[\x15a\x05\xDCV[_\x14a\x08\xBCWa\x08[`\x01a\x08V_a\x08N\x81\x86\x90a\x07\xB5V[\x01\x85\x90a\x07\xCBV[a\x07\xF7V[\x90a\x08da\t\x1BV[\x90a\x08\xA1a\x08\x9Ba\x08\x95\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a\x07\xA9V[\x92a\x05XV[\x92a\x05XV[\x92a\x08\xAAa\08V[\x80a\x08\xB4\x81a\x02GV[\x03\x90\xA4`\x01\x90V[PP_\x90V[_\x1C\x90V[`\xFF\x16\x90V[a\x08\xD9a\x08\xDE\x91a\x08\xC2V[a\x08\xC7V[\x90V[a\x08\xEB\x90Ta\x08\xCDV[\x90V[a\t\x14\x91_a\t\ta\t\x0F\x93a\t\x02a\x07\xA5V[P\x82a\x07\xB5V[\x01a\x07\xCBV[a\x08\xE1V[\x90V[_\x90V[a\t#a\t\x17V[P3\x90V\xFE`\x80`@R`\x046\x10\x15a\0\x13W[a\x10\\V[a\0\x1D_5a\x01\xECV[\x80c\x01\xFF\xC9\xA7\x14a\x01\xE7W\x80c\x103\xB4\xCC\x14a\x01\xE2W\x80c\x11\x8C8\xC7\x14a\x01\xDDW\x80c\x12Y\xA5\xC8\x14a\x01\xD8W\x80c\x18\xB6\x8B\x8C\x14a\x01\xD3W\x80c$\x8A\x9C\xA3\x14a\x01\xCEW\x80c//\xF1]\x14a\x01\xC9W\x80c4b\xFA\xC3\x14a\x01\xC4W\x80c6V\x8A\xBE\x14a\x01\xBFW\x80c6\xB0\x89\xD8\x14a\x01\xBAW\x80cZ\xB1\xD6\x1C\x14a\x01\xB5W\x80ca\xB0\xA5n\x14a\x01\xB0W\x80cc\"\x14\x90\x14a\x01\xABW\x80ce\xD7\xA3\xC9\x14a\x01\xA6W\x80cg\xEE\xBA\x0C\x14a\x01\xA1W\x80ch\x13\xD7\x87\x14a\x01\x9CW\x80ck\xCC\x8C\x14\x14a\x01\x97W\x80c\x91\xD1HT\x14a\x01\x92W\x80c\xA2\x17\xFD\xDF\x14a\x01\x8DW\x80c\xB1nxI\x14a\x01\x88W\x80c\xB2\r0\xA9\x14a\x01\x83W\x80c\xC9\xF5\xB6>\x14a\x01~W\x80c\xCC=\xC0a\x14a\x01yW\x80c\xD3\x07-\x82\x14a\x01tW\x80c\xD5Gt\x1F\x14a\x01oW\x80c\xEA\xD9<\x8F\x14a\x01jW\x80c\xED\xE7\xCE\xBD\x14a\x01eW\x80c\xF6\x81\xA8b\x14a\x01`Wc\xFB\x8CKQ\x03a\0\x0EWa\x10$V[a\x0F\xBDV[a\x0FvV[a\x0F\x0CV[a\x0E\xC8V[a\x0E\x93V[a\x0E#V[a\x0C\xA4V[a\x0CbV[a\x0C-V[a\x0B\x96V[a\x0B%V[a\n\xF2V[a\n\xA1V[a\nlV[a\n(V[a\x08\x08V[a\x07\xB6V[a\x07IV[a\x06\xD3V[a\x06\x90V[a\x06[V[a\x05\xF8V[a\x05\x96V[a\x05\x1EV[a\x03\xEAV[a\x03\xA6V[a\x03\x1DV[a\x02xV[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x80\xFD[c\xFF\xFF\xFF\xFF`\xE0\x1B\x16\x90V[a\x02\x19\x81a\x02\x04V[\x03a\x02 WV[_\x80\xFD[\x90P5\x90a\x021\x82a\x02\x10V[V[\x90` \x82\x82\x03\x12a\x02LWa\x02I\x91_\x01a\x02$V[\x90V[a\x01\xFCV[\x15\x15\x90V[a\x02_\x90a\x02QV[\x90RV[\x91\x90a\x02v\x90_` \x85\x01\x94\x01\x90a\x02VV[V[4a\x02\xA8Wa\x02\xA4a\x02\x93a\x02\x8E6`\x04a\x023V[a\x10dV[a\x02\x9Ba\x01\xF2V[\x91\x82\x91\x82a\x02cV[\x03\x90\xF3[a\x01\xF8V[_\x91\x03\x12a\x02\xB7WV[a\x01\xFCV[\x1C\x90V[\x90V[a\x02\xD3\x90`\x08a\x02\xD8\x93\x02a\x02\xBCV[a\x02\xC0V[\x90V[\x90a\x02\xE6\x91Ta\x02\xC3V[\x90V[a\x02\xF5`\x05_\x90a\x02\xDBV[\x90V[\x90V[a\x03\x04\x90a\x02\xF8V[\x90RV[\x91\x90a\x03\x1B\x90_` \x85\x01\x94\x01\x90a\x02\xFBV[V[4a\x03MWa\x03-6`\x04a\x02\xADV[a\x03Ia\x038a\x02\xE9V[a\x03@a\x01\xF2V[\x91\x82\x91\x82a\x03\x08V[\x03\x90\xF3[a\x01\xF8V[\x7Fu\x1By]$\xB9.=\x92\xD1\xD0\xD8\xF2\x88_N\x9C\x9C&\x9D\xA3P\xAF6\xAEkI\x06\x9B\xAB\xF4\xBF\x90V[a\x03~a\x03RV[\x90V[\x90V[a\x03\x8D\x90a\x03\x81V[\x90RV[\x91\x90a\x03\xA4\x90_` \x85\x01\x94\x01\x90a\x03\x84V[V[4a\x03\xD6Wa\x03\xB66`\x04a\x02\xADV[a\x03\xD2a\x03\xC1a\x03vV[a\x03\xC9a\x01\xF2V[\x91\x82\x91\x82a\x03\x91V[\x03\x90\xF3[a\x01\xF8V[a\x03\xE7`\x06_\x90a\x02\xDBV[\x90V[4a\x04\x1AWa\x03\xFA6`\x04a\x02\xADV[a\x04\x16a\x04\x05a\x03\xDBV[a\x04\ra\x01\xF2V[\x91\x82\x91\x82a\x03\x08V[\x03\x90\xF3[a\x01\xF8V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x043\x90a\x04\x1FV[\x90V[a\x04?\x81a\x04*V[\x03a\x04FWV[_\x80\xFD[\x90P5\x90a\x04W\x82a\x046V[V[a\x04b\x81a\x02\xF8V[\x03a\x04iWV[_\x80\xFD[\x90P5\x90a\x04z\x82a\x04YV[V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x04\xC2W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x04\xBDW` \x01\x92`\x01\x83\x02\x84\x01\x11a\x04\xB8WV[a\x04\x84V[a\x04\x80V[a\x04|V[\x91``\x83\x83\x03\x12a\x05\x14Wa\x04\xDE\x82_\x85\x01a\x04JV[\x92a\x04\xEC\x83` \x83\x01a\x04mV[\x92`@\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x05\x0FWa\x05\x0B\x92\x01a\x04\x88V[\x90\x91V[a\x02\0V[a\x01\xFCV[_\x01\x90V[4a\x05PWa\x05:a\x0516`\x04a\x04\xC7V[\x92\x91\x90\x91a\x14\x92V[a\x05Ba\x01\xF2V[\x80a\x05L\x81a\x05\x19V[\x03\x90\xF3[a\x01\xF8V[a\x05^\x81a\x03\x81V[\x03a\x05eWV[_\x80\xFD[\x90P5\x90a\x05v\x82a\x05UV[V[\x90` \x82\x82\x03\x12a\x05\x91Wa\x05\x8E\x91_\x01a\x05iV[\x90V[a\x01\xFCV[4a\x05\xC6Wa\x05\xC2a\x05\xB1a\x05\xAC6`\x04a\x05xV[a\x14\xEAV[a\x05\xB9a\x01\xF2V[\x91\x82\x91\x82a\x03\x91V[\x03\x90\xF3[a\x01\xF8V[\x91\x90`@\x83\x82\x03\x12a\x05\xF3W\x80a\x05\xE7a\x05\xF0\x92_\x86\x01a\x05iV[\x93` \x01a\x04JV[\x90V[a\x01\xFCV[4a\x06'Wa\x06\x11a\x06\x0B6`\x04a\x05\xCBV[\x90a\x155V[a\x06\x19a\x01\xF2V[\x80a\x06#\x81a\x05\x19V[\x03\x90\xF3[a\x01\xF8V[\x7F\xC0t\xBE\xB4k%\x1Fs\xC0\xFE\xC1n\xBAu\xD6\xBC\0B\xD0\x9E\xE1zt\x0E\xBB\xEE0\x8D\xBF\x87\xF8/\x90V[a\x06Xa\x06,V[\x90V[4a\x06\x8BWa\x06k6`\x04a\x02\xADV[a\x06\x87a\x06va\x06PV[a\x06~a\x01\xF2V[\x91\x82\x91\x82a\x03\x91V[\x03\x90\xF3[a\x01\xF8V[4a\x06\xBFWa\x06\xA9a\x06\xA36`\x04a\x05\xCBV[\x90a\x15AV[a\x06\xB1a\x01\xF2V[\x80a\x06\xBB\x81a\x05\x19V[\x03\x90\xF3[a\x01\xF8V[a\x06\xD0`\x03_\x90a\x02\xDBV[\x90V[4a\x07\x03Wa\x06\xE36`\x04a\x02\xADV[a\x06\xFFa\x06\xEEa\x06\xC4V[a\x06\xF6a\x01\xF2V[\x91\x82\x91\x82a\x03\x08V[\x03\x90\xF3[a\x01\xF8V[a\x07\x11\x81a\x02QV[\x03a\x07\x18WV[_\x80\xFD[\x90P5\x90a\x07)\x82a\x07\x08V[V[\x90` \x82\x82\x03\x12a\x07DWa\x07A\x91_\x01a\x07\x1CV[\x90V[a\x01\xFCV[4a\x07wWa\x07aa\x07\\6`\x04a\x07+V[a\x168V[a\x07ia\x01\xF2V[\x80a\x07s\x81a\x05\x19V[\x03\x90\xF3[a\x01\xF8V[\x90\x91``\x82\x84\x03\x12a\x07\xB1Wa\x07\xAEa\x07\x97\x84_\x85\x01a\x04JV[\x93a\x07\xA5\x81` \x86\x01a\x04mV[\x93`@\x01a\x04JV[\x90V[a\x01\xFCV[4a\x07\xE5Wa\x07\xCFa\x07\xC96`\x04a\x07|V[\x91a\x16\xB4V[a\x07\xD7a\x01\xF2V[\x80a\x07\xE1\x81a\x05\x19V[\x03\x90\xF3[a\x01\xF8V[\x90` \x82\x82\x03\x12a\x08\x03Wa\x08\0\x91_\x01a\x04mV[\x90V[a\x01\xFCV[4a\x086Wa\x08 a\x08\x1B6`\x04a\x07\xEAV[a\x16\xE9V[a\x08(a\x01\xF2V[\x80a\x082\x81a\x05\x19V[\x03\x90\xF3[a\x01\xF8V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x08\x82W[` \x83\x10\x14a\x08}WV[a\x08NV[\x91`\x7F\x16\x91a\x08rV[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x08\xB8a\x08\xB1\x83a\x08bV[\x80\x94a\x08\x8CV[\x91`\x01\x81\x16\x90\x81_\x14a\t\x0FWP`\x01\x14a\x08\xD3W[PPPV[a\x08\xE0\x91\x92\x93\x94Pa\x08\x95V[\x91_\x92[\x81\x84\x10a\x08\xF7WPP\x01\x90_\x80\x80a\x08\xCEV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x08\xE4V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x08\xCEV[\x90a\t4\x91a\x08\x9EV[\x90V[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\t_\x90a\t7V[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\tyW`@RV[a\tAV[\x90a\t\x9Ea\t\x97\x92a\t\x8Ea\x01\xF2V[\x93\x84\x80\x92a\t*V[\x03\x83a\tUV[V[\x90_\x10a\t\xB3Wa\t\xB0\x90a\t~V[\x90V[a\x08;V[a\t\xC4`\x07_\x90a\t\xA0V[\x90V[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[a\t\xFEa\n\x07` \x93a\n\x0C\x93a\t\xF5\x81a\t\xC7V[\x93\x84\x80\x93a\t\xCBV[\x95\x86\x91\x01a\t\xD4V[a\t7V[\x01\x90V[a\n%\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\t\xDFV[\x90V[4a\nXWa\n86`\x04a\x02\xADV[a\nTa\nCa\t\xB8V[a\nKa\x01\xF2V[\x91\x82\x91\x82a\n\x10V[\x03\x90\xF3[a\x01\xF8V[a\ni`\x04_\x90a\x02\xDBV[\x90V[4a\n\x9CWa\n|6`\x04a\x02\xADV[a\n\x98a\n\x87a\n]V[a\n\x8Fa\x01\xF2V[\x91\x82\x91\x82a\x03\x08V[\x03\x90\xF3[a\x01\xF8V[4a\n\xCFWa\n\xB9a\n\xB46`\x04a\x07+V[a\x17*V[a\n\xC1a\x01\xF2V[\x80a\n\xCB\x81a\x05\x19V[\x03\x90\xF3[a\x01\xF8V[\x90` \x82\x82\x03\x12a\n\xEDWa\n\xEA\x91_\x01a\x04JV[\x90V[a\x01\xFCV[4a\x0B Wa\x0B\na\x0B\x056`\x04a\n\xD4V[a\x18-V[a\x0B\x12a\x01\xF2V[\x80a\x0B\x1C\x81a\x05\x19V[\x03\x90\xF3[a\x01\xF8V[4a\x0BVWa\x0BRa\x0BAa\x0B;6`\x04a\x05\xCBV[\x90a\x18oV[a\x0BIa\x01\xF2V[\x91\x82\x91\x82a\x02cV[\x03\x90\xF3[a\x01\xF8V[\x90V[_\x1B\x90V[a\x0Bwa\x0Bra\x0B|\x92a\x0B[V[a\x0B^V[a\x03\x81V[\x90V[a\x0B\x88_a\x0BcV[\x90V[a\x0B\x93a\x0B\x7FV[\x90V[4a\x0B\xC6Wa\x0B\xA66`\x04a\x02\xADV[a\x0B\xC2a\x0B\xB1a\x0B\x8BV[a\x0B\xB9a\x01\xF2V[\x91\x82\x91\x82a\x03\x91V[\x03\x90\xF3[a\x01\xF8V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x0B\xE6\x90`\x08a\x0B\xEB\x93\x02a\x02\xBCV[a\x0B\xCBV[\x90V[\x90a\x0B\xF9\x91Ta\x0B\xD6V[\x90V[a\x0C\x08`\n_\x90a\x0B\xEEV[\x90V[a\x0C\x14\x90a\x04*V[\x90RV[\x91\x90a\x0C+\x90_` \x85\x01\x94\x01\x90a\x0C\x0BV[V[4a\x0C]Wa\x0C=6`\x04a\x02\xADV[a\x0CYa\x0CHa\x0B\xFCV[a\x0CPa\x01\xF2V[\x91\x82\x91\x82a\x0C\x18V[\x03\x90\xF3[a\x01\xF8V[4a\x0C\x90Wa\x0Cza\x0Cu6`\x04a\x07\xEAV[a\x19'V[a\x0C\x82a\x01\xF2V[\x80a\x0C\x8C\x81a\x05\x19V[\x03\x90\xF3[a\x01\xF8V[a\x0C\xA1`\x02_\x90a\x0B\xEEV[\x90V[4a\x0C\xD4Wa\x0C\xB46`\x04a\x02\xADV[a\x0C\xD0a\x0C\xBFa\x0C\x95V[a\x0C\xC7a\x01\xF2V[\x91\x82\x91\x82a\x0C\x18V[\x03\x90\xF3[a\x01\xF8V[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\r\x05a\x0C\xFE\x83a\x08bV[\x80\x94a\x0C\xD9V[\x91`\x01\x81\x16\x90\x81_\x14a\r\\WP`\x01\x14a\r W[PPPV[a\r-\x91\x92\x93\x94Pa\x0C\xE2V[\x91_\x92[\x81\x84\x10a\rDWPP\x01\x90_\x80\x80a\r\x1BV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\r1V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\r\x1BV[\x90a\r\x81\x91a\x0C\xEBV[\x90V[\x90a\r\xA4a\r\x9D\x92a\r\x94a\x01\xF2V[\x93\x84\x80\x92a\rwV[\x03\x83a\tUV[V[\x90_\x10a\r\xB9Wa\r\xB6\x90a\r\x84V[\x90V[a\x08;V[a\r\xCA`\x0B_\x90a\r\xA6V[\x90V[Q\x90V[` \x91\x81R\x01\x90V[a\r\xF9a\x0E\x02` \x93a\x0E\x07\x93a\r\xF0\x81a\r\xCDV[\x93\x84\x80\x93a\r\xD1V[\x95\x86\x91\x01a\t\xD4V[a\t7V[\x01\x90V[a\x0E \x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\r\xDAV[\x90V[4a\x0ESWa\x0E36`\x04a\x02\xADV[a\x0EOa\x0E>a\r\xBEV[a\x0EFa\x01\xF2V[\x91\x82\x91\x82a\x0E\x0BV[\x03\x90\xF3[a\x01\xF8V[`\xFF\x16\x90V[a\x0En\x90`\x08a\x0Es\x93\x02a\x02\xBCV[a\x0EXV[\x90V[\x90a\x0E\x81\x91Ta\x0E^V[\x90V[a\x0E\x90`\x08_\x90a\x0EvV[\x90V[4a\x0E\xC3Wa\x0E\xA36`\x04a\x02\xADV[a\x0E\xBFa\x0E\xAEa\x0E\x84V[a\x0E\xB6a\x01\xF2V[\x91\x82\x91\x82a\x02cV[\x03\x90\xF3[a\x01\xF8V[4a\x0E\xF7Wa\x0E\xE1a\x0E\xDB6`\x04a\x05\xCBV[\x90a\x19\\V[a\x0E\xE9a\x01\xF2V[\x80a\x0E\xF3\x81a\x05\x19V[\x03\x90\xF3[a\x01\xF8V[a\x0F\t`\x02`\x14\x90a\x0EvV[\x90V[4a\x0F<Wa\x0F\x1C6`\x04a\x02\xADV[a\x0F8a\x0F'a\x0E\xFCV[a\x0F/a\x01\xF2V[\x91\x82\x91\x82a\x02cV[\x03\x90\xF3[a\x01\xF8V[`@\x90a\x0Fma\x0Fba\x0Ft\x95\x97\x96\x94``\x84\x01\x90\x84\x82\x03_\x86\x01Ra\t\xDFV[\x96` \x83\x01\x90a\x0C\x0BV[\x01\x90a\x02VV[V[4a\x0F\xA9Wa\x0F\x866`\x04a\x02\xADV[a\x0F\xA5a\x0F\x91a\x19}V[a\x0F\x9C\x93\x91\x93a\x01\xF2V[\x93\x84\x93\x84a\x0FAV[\x03\x90\xF3[a\x01\xF8V[a\x0F\xBA`\t_\x90a\x02\xDBV[\x90V[4a\x0F\xEDWa\x0F\xCD6`\x04a\x02\xADV[a\x0F\xE9a\x0F\xD8a\x0F\xAEV[a\x0F\xE0a\x01\xF2V[\x91\x82\x91\x82a\x03\x08V[\x03\x90\xF3[a\x01\xF8V[`@\x90a\x10\x1Ba\x10\"\x94\x96\x95\x93\x96a\x10\x11``\x84\x01\x98_\x85\x01\x90a\x02\xFBV[` \x83\x01\x90a\x02\xFBV[\x01\x90a\x02\xFBV[V[4a\x10WWa\x1046`\x04a\x02\xADV[a\x10Sa\x10?a\x19\xE6V[a\x10J\x93\x91\x93a\x01\xF2V[\x93\x84\x93\x84a\x0F\xF2V[\x03\x90\xF3[a\x01\xF8V[_\x80\xFD[_\x90V[a\x10la\x10`V[P\x80a\x10\x87a\x10\x81cye\xDB\x0B`\xE0\x1Ba\x02\x04V[\x91a\x02\x04V[\x14\x90\x81\x15a\x10\x94W[P\x90V[a\x10\x9E\x91Pa\x1AtV[_a\x10\x90V[\x90a\x10\xB8\x93\x92\x91a\x10\xB3a\x1A\xC6V[a\x10\xE9V[a\x10\xC0a\x1BJV[V[`\xA0\x1C\x90V[a\x10\xD4a\x10\xD9\x91a\x10\xC2V[a\x0EXV[\x90V[a\x10\xE6\x90Ta\x10\xC8V[\x90V[\x92\x91\x90a\x10\xFFa\x10\xF9`\x02a\x10\xDCV[\x15a\x02QV[a\x11\x0EWa\x11\x0C\x93a\x11*V[V[_c=\xF5\x10Y`\xE1\x1B\x81R\x80a\x11&`\x04\x82\x01a\x05\x19V[\x03\x90\xFD[\x92\x91\x90a\x11Ha\x11Ba\x11;a\x06,V[3\x90a\x18oV[\x15a\x02QV[a\x11WWa\x11U\x93a\x12\xE7V[V[_c\\B|\xD9`\xE0\x1B\x81R\x80a\x11o`\x04\x82\x01a\x05\x19V[\x03\x90\xFD[\x90V[a\x11\x8Aa\x11\x85a\x11\x8F\x92a\x0B[V[a\x11sV[a\x04\x1FV[\x90V[a\x11\x9B\x90a\x11vV[\x90V[a\x11\xB2a\x11\xADa\x11\xB7\x92a\x0B[V[a\x11sV[a\x02\xF8V[\x90V[_\x1C\x90V[a\x11\xCBa\x11\xD0\x91a\x11\xBAV[a\x02\xC0V[\x90V[a\x11\xDD\x90Ta\x11\xBFV[\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\x12\x03a\x12\t\x91\x93\x92\x93a\x02\xF8V[\x92a\x02\xF8V[\x82\x01\x80\x92\x11a\x12\x14WV[a\x11\xE0V[a\x12-a\x12(a\x122\x92a\x04\x1FV[a\x11sV[a\x04\x1FV[\x90V[a\x12>\x90a\x12\x19V[\x90V[a\x12J\x90a\x125V[\x90V[a\x12V\x90a\x12\x19V[\x90V[a\x12b\x90a\x12MV[\x90V[\x90a\x12q_\x19\x91a\x0B^V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x12\x8Fa\x12\x8Aa\x12\x94\x92a\x02\xF8V[a\x11sV[a\x02\xF8V[\x90V[\x90V[\x90a\x12\xAFa\x12\xAAa\x12\xB6\x92a\x12{V[a\x12\x97V[\x82Ta\x12eV[\x90UV[a\x12\xC6a\x12\xCB\x91a\x11\xBAV[a\x0B\xCBV[\x90V[a\x12\xD8\x90Ta\x12\xBAV[\x90V[a\x12\xE4\x90a\x12MV[\x90V[\x91\x92\x90\x92\x82a\x13\x06a\x13\0a\x12\xFB_a\x11\x92V[a\x04*V[\x91a\x04*V[\x14a\x14vW\x83a\x13\x1Ea\x13\x18_a\x11\x9EV[\x91a\x02\xF8V[\x14a\x14ZW\x83a\x13?a\x139a\x134`\x03a\x11\xD3V[a\x02\xF8V[\x91a\x02\xF8V[\x11a\x14>Wa\x13La\x1B\xB3V[a\x13`a\x13Y`\x05a\x11\xD3V[\x85\x90a\x11\xF4V[a\x13{a\x13ua\x13p`\x04a\x11\xD3V[a\x02\xF8V[\x91a\x02\xF8V[\x11a\x14\"Wa\x13\xAD\x91a\x13\xA2a\x13\x90\x85a\x12AV[3a\x13\x9A0a\x12YV[\x90\x88\x92a\x1C\xBFV[\x83\x91\x85\x90\x91\x92a\x1FNV[a\x13\xCAa\x13\xC3\x83a\x13\xBE`\x05a\x11\xD3V[a\x11\xF4V[`\x05a\x12\x9AV[a\x13\xD4`\x02a\x12\xCEV[\x90a\x14\x1Da\x14\x0Ba\x14\x05\x7F=\xBA@\x1D\xC1\xAB\xBF\x01p\x86\x86K3\xBA\x81_S\xAB<\xDB\xB96k\xA6\xBC\xD8\xEC4-\xDD\x98\xE8\x93a\x12\xDBV[\x93a\x12\xDBV[\x93a\x14\x14a\x01\xF2V[\x91\x82\x91\x82a\x03\x08V[\x03\x90\xA3V[_c\x1C4Z/`\xE2\x1B\x81R\x80a\x14:`\x04\x82\x01a\x05\x19V[\x03\x90\xFD[_c\x1C4Z/`\xE2\x1B\x81R\x80a\x14V`\x04\x82\x01a\x05\x19V[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a\x14r`\x04\x82\x01a\x05\x19V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a\x14\x8E`\x04\x82\x01a\x05\x19V[\x03\x90\xFD[\x90a\x14\x9E\x93\x92\x91a\x10\xA4V[V[_\x90V[a\x14\xAD\x90a\x03\x81V[\x90V[\x90a\x14\xBA\x90a\x14\xA4V[_R` R`@_ \x90V[\x90V[a\x14\xD5a\x14\xDA\x91a\x11\xBAV[a\x14\xC6V[\x90V[a\x14\xE7\x90Ta\x14\xC9V[\x90V[`\x01a\x15\x02a\x15\x08\x92a\x14\xFBa\x14\xA0V[P_a\x14\xB0V[\x01a\x14\xDDV[\x90V[\x90a\x15&\x91a\x15!a\x15\x1C\x82a\x14\xEAV[a\x1F\xA4V[a\x15(V[V[\x90a\x152\x91a\x1F\xB8V[PV[\x90a\x15?\x91a\x15\x0BV[V[\x90\x80a\x15\\a\x15Va\x15Qa cV[a\x04*V[\x91a\x04*V[\x03a\x15mWa\x15j\x91a pV[PV[_c3K\xD9\x19`\xE1\x1B\x81R\x80a\x15\x85`\x04\x82\x01a\x05\x19V[\x03\x90\xFD[a\x15\xA2\x90a\x15\x9Da\x15\x98a\x03RV[a\x1F\xA4V[a\x15\xF2V[V[`\xA0\x1B\x90V[\x90a\x15\xB9`\xFF`\xA0\x1B\x91a\x15\xA4V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x15\xCC\x90a\x02QV[\x90V[\x90V[\x90a\x15\xE7a\x15\xE2a\x15\xEE\x92a\x15\xC3V[a\x15\xCFV[\x82Ta\x15\xAAV[\x90UV[a\x15\xFD\x81`\x02a\x15\xD2V[a\x163\x7F\xB3A\x89\x89\xD0h5\xB5\xC2\x15\xEE\xBBMT\xEDk\xE7\xBB\xB6n\xB4\x80qdt\n.\x08/\xA7\x82\xD5\x91a\x16*a\x01\xF2V[\x91\x82\x91\x82a\x02cV[\x03\x90\xA1V[a\x16A\x90a\x15\x89V[V[\x90a\x16^\x92\x91a\x16Ya\x16Ta\x0B\x7FV[a\x1F\xA4V[a\x16`V[V[\x91\x90\x81a\x16}a\x16wa\x16r_a\x11\x92V[a\x04*V[\x91a\x04*V[\x14a\x16\x98Wa\x16\x8Ea\x16\x96\x93a\x12AV[\x91\x90\x91a!4V[V[_c\xD9.#=`\xE0\x1B\x81R\x80a\x16\xB0`\x04\x82\x01a\x05\x19V[\x03\x90\xFD[\x90a\x16\xBF\x92\x91a\x16CV[V[a\x16\xDA\x90a\x16\xD5a\x16\xD0a\x03RV[a\x1F\xA4V[a\x16\xDCV[V[a\x16\xE7\x90`\x03a\x12\x9AV[V[a\x16\xF2\x90a\x16\xC1V[V[\x90a\x17\0`\xFF\x91a\x0B^V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a\x17\x1Fa\x17\x1Aa\x17&\x92a\x15\xC3V[a\x15\xCFV[\x82Ta\x16\xF4V[\x90UV[a\x175\x90`\x08a\x17\nV[V[a\x17P\x90a\x17Ka\x17Fa\x03RV[a\x1F\xA4V[a\x17\x90V[V[\x90a\x17c`\x01\x80`\xA0\x1B\x03\x91a\x0B^V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90V[\x90a\x17\x85a\x17\x80a\x17\x8C\x92a\x12\xDBV[a\x17mV[\x82Ta\x17RV[\x90UV[\x80a\x17\xABa\x17\xA5a\x17\xA0_a\x11\x92V[a\x04*V[\x91a\x04*V[\x14a\x18\x11Wa\x17\xBA`\x02a\x12\xCEV[a\x17\xC5\x82`\x02a\x17pV[\x90a\x17\xF9a\x17\xF3\x7F\xB0\x7F\x8B\x1B\x85\x04-t\x02,\x86|\x83n\xDE\xB0\xBC\xD7\x0E\x13[\0B9\r+\x1F\xD1\x08)\x80i\x93a\x12\xDBV[\x91a\x12\xDBV[\x91a\x18\x02a\x01\xF2V[\x80a\x18\x0C\x81a\x05\x19V[\x03\x90\xA3V[_c\xD9.#=`\xE0\x1B\x81R\x80a\x18)`\x04\x82\x01a\x05\x19V[\x03\x90\xFD[a\x186\x90a\x177V[V[\x90a\x18B\x90a\x12\xDBV[_R` R`@_ \x90V[a\x18Za\x18_\x91a\x11\xBAV[a\x0EXV[\x90V[a\x18l\x90Ta\x18NV[\x90V[a\x18\x95\x91_a\x18\x8Aa\x18\x90\x93a\x18\x83a\x10`V[P\x82a\x14\xB0V[\x01a\x188V[a\x18bV[\x90V[a\x18\xB1\x90a\x18\xACa\x18\xA7a\x03RV[a\x1F\xA4V[a\x18\xD6V[V[\x91` a\x18\xD4\x92\x94\x93a\x18\xCD`@\x82\x01\x96_\x83\x01\x90a\x02\xFBV[\x01\x90a\x02\xFBV[V[a\x18\xE0`\x04a\x11\xD3V[a\x18\xEB\x82`\x04a\x12\x9AV[\x90\x7F |L\xBD\xF5^\xC3\x15\xA1?\r^\x04w2\xEC]\x94}\xA0V\xE7\x06Y:\xA5\t\x90\x99A\xCE\xDF\x91a\x19\"a\x19\x19a\x01\xF2V[\x92\x83\x92\x83a\x18\xB3V[\x03\x90\xA1V[a\x190\x90a\x18\x98V[V[\x90a\x19M\x91a\x19Ha\x19C\x82a\x14\xEAV[a\x1F\xA4V[a\x19OV[V[\x90a\x19Y\x91a pV[PV[\x90a\x19f\x91a\x192V[V[``\x90V[_\x90V[a\x19z\x90a\t~V[\x90V[a\x19\x85a\x19hV[Pa\x19\x8Ea\x19mV[Pa\x19\x97a\x10`V[P`\x07a\x19\xA4`\x02a\x12\xCEV[\x91a\x19\xB8a\x19\xB2`\x02a\x10\xDCV[\x92a\x19qV[\x92\x91\x90V[_\x90V[a\x19\xD0a\x19\xD6\x91\x93\x92\x93a\x02\xF8V[\x92a\x02\xF8V[\x82\x03\x91\x82\x11a\x19\xE1WV[a\x11\xE0V[a\x19\xEEa\x19\xBDV[Pa\x19\xF7a\x19\xBDV[Pa\x1A\0a\x19\xBDV[Pa\x1A\x0B`\x05a\x11\xD3V[a\x1A\x15`\x04a\x11\xD3V[\x91a\x1A `\x04a\x11\xD3V[a\x1A;a\x1A5a\x1A0`\x05a\x11\xD3V[a\x02\xF8V[\x91a\x02\xF8V[\x11_\x14a\x1AfWa\x1A_a\x1AO`\x04a\x11\xD3V[a\x1AY`\x05a\x11\xD3V[\x90a\x19\xC1V[[\x91\x92\x91\x90V[a\x1Ao_a\x11\x9EV[a\x1A`V[a\x1A|a\x10`V[Pa\x1A\x96a\x1A\x90c\x01\xFF\xC9\xA7`\xE0\x1Ba\x02\x04V[\x91a\x02\x04V[\x14\x90V[\x90V[a\x1A\xB1a\x1A\xACa\x1A\xB6\x92a\x1A\x9AV[a\x11sV[a\x02\xF8V[\x90V[a\x1A\xC3`\x02a\x1A\x9DV[\x90V[a\x1A\xD0`\x01a\x11\xD3V[a\x1A\xE9a\x1A\xE3a\x1A\xDEa\x1A\xB9V[a\x02\xF8V[\x91a\x02\xF8V[\x14a\x1B\x02Wa\x1B\0a\x1A\xF9a\x1A\xB9V[`\x01a\x12\x9AV[V[_c>\xE5\xAE\xB5`\xE0\x1B\x81R\x80a\x1B\x1A`\x04\x82\x01a\x05\x19V[\x03\x90\xFD[\x90V[a\x1B5a\x1B0a\x1B:\x92a\x1B\x1EV[a\x11sV[a\x02\xF8V[\x90V[a\x1BG`\x01a\x1B!V[\x90V[a\x1B\\a\x1BUa\x1B=V[`\x01a\x12\x9AV[V[\x90V[a\x1Bua\x1Bpa\x1Bz\x92a\x1B^V[a\x11sV[a\x02\xF8V[\x90V[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[a\x1B\x9Da\x1B\xA3\x91a\x02\xF8V[\x91a\x02\xF8V[\x90\x81\x15a\x1B\xAEW\x04\x90V[a\x1B}V[a\x1B\xC9Ba\x1B\xC3b\x01Q\x80a\x1BaV[\x90a\x1B\x91V[\x80a\x1B\xE5a\x1B\xDFa\x1B\xDA`\x06a\x11\xD3V[a\x02\xF8V[\x91a\x02\xF8V[\x11a\x1B\xEEW[PV[\x80a\x1CP\x91a\x1B\xFD`\x05a\x11\xD3V[\x7F\xDAN9\xDDV\xD7,.\xE3\xD12\xE0\x14k\xC3\x9E\x90^x\xE3\xBCd\xC4\x01\x90B\x1C{+\xCE\xF2\xAB\x91a\x1C3a\x1C*a\x01\xF2V[\x92\x83\x92\x83a\x18\xB3V[\x03\x90\xA1a\x1CIa\x1CB_a\x11\x9EV[`\x05a\x12\x9AV[`\x06a\x12\x9AV[_a\x1B\xEBV[a\x1C_\x90a\x12MV[\x90V[c\xFF\xFF\xFF\xFF\x16\x90V[`\xE0\x1B\x90V[a\x1C\x85a\x1C\x80a\x1C\x8A\x92a\x1CbV[a\x1CkV[a\x02\x04V[\x90V[`@\x90a\x1C\xB6a\x1C\xBD\x94\x96\x95\x93\x96a\x1C\xAC``\x84\x01\x98_\x85\x01\x90a\x0C\x0BV[` \x83\x01\x90a\x0C\x0BV[\x01\x90a\x02\xFBV[V[`\x04\x92a\x1C\xF9a\x1D\r\x95\x93a\x1D\x08\x93\x94a\x1C\xE0c#\xB8r\xDD\x92\x94\x91\x92a\x1CqV[\x93a\x1C\xE9a\x01\xF2V[\x97\x88\x95` \x87\x01\x90\x81R\x01a\x1C\x8DV[` \x82\x01\x81\x03\x82R\x03\x83a\tUV[a!\x82V[V[_\x7FMock bridge execution failed\0\0\0\0\x91\x01RV[a\x1DC`\x1C` \x92a\t\xCBV[a\x1DL\x81a\x1D\x0FV[\x01\x90V[a\x1De\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x1D6V[\x90V[P\x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a\x1D\x95\x91\x02\x91a\x1D\x8F_\x19\x84a\x1DvV[\x92a\x1DvV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x91\x90a\x1D\xB5a\x1D\xB0a\x1D\xBD\x93a\x12{V[a\x12\x97V[\x90\x83Ta\x1DzV[\x90UV[a\x1D\xD3\x91a\x1D\xCDa\x19\xBDV[\x91a\x1D\x9FV[V[[\x81\x81\x10a\x1D\xE1WPPV[\x80a\x1D\xEE_`\x01\x93a\x1D\xC1V[\x01a\x1D\xD6V[\x91\x90`\x1F\x81\x11a\x1E\x04W[PPPV[a\x1E\x10a\x1E5\x93a\x0C\xE2V[\x90` a\x1E\x1C\x84a\x1DlV[\x83\x01\x93\x10a\x1E=W[a\x1E.\x90a\x1DlV[\x01\x90a\x1D\xD5V[_\x80\x80a\x1D\xFFV[\x91Pa\x1E.\x81\x92\x90Pa\x1E%V[\x90a\x1E[\x90_\x19\x90`\x08\x02a\x02\xBCV[\x19\x16\x90V[\x81a\x1Ej\x91a\x1EKV[\x90`\x02\x02\x17\x90V[\x91a\x1E}\x90\x82a\x1DhV[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x1F<Wa\x1E\xA1\x82a\x1E\x9B\x85Ta\x08bV[\x85a\x1D\xF4V[_\x90`\x1F\x83\x11`\x01\x14a\x1E\xD4W\x91\x80\x91a\x1E\xC3\x93_\x92a\x1E\xC8W[PPa\x1E`V[\x90U[V[\x90\x91P\x015_\x80a\x1E\xBCV[`\x1F\x19\x83\x16\x91a\x1E\xE3\x85a\x0C\xE2V[\x92_[\x81\x81\x10a\x1F$WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\x1F\nW[PPP\x02\x01\x90Ua\x1E\xC6V[a\x1F\x1A\x91\x015`\x1F\x84\x16\x90a\x1EKV[\x90U_\x80\x80a\x1E\xFEV[\x91\x93` `\x01\x81\x92\x87\x87\x015\x81U\x01\x95\x01\x92\x01a\x1E\xE6V[a\tAV[\x90a\x1FL\x92\x91a\x1ErV[V[\x92\x91\x90\x92a\x1F\\`\x08a\x18bV[a\x1F\x82Wa\x1F\x80\x93a\x1Fra\x1Fy\x92`\na\x17pV[`\ta\x12\x9AV[`\x0Ba\x1FAV[V[a\x1F\x8Aa\x01\xF2V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x1F\xA0`\x04\x82\x01a\x1DPV[\x03\x90\xFD[a\x1F\xB6\x90a\x1F\xB0a cV[\x90a\"YV[V[a\x1F\xC0a\x10`V[Pa\x1F\xD5a\x1F\xCF\x82\x84\x90a\x18oV[\x15a\x02QV[_\x14a ]Wa\x1F\xFC`\x01a\x1F\xF7_a\x1F\xEF\x81\x86\x90a\x14\xB0V[\x01\x85\x90a\x188V[a\x17\nV[\x90a \x05a cV[\x90a Ba <a 6\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a\x14\xA4V[\x92a\x12\xDBV[\x92a\x12\xDBV[\x92a Ka\x01\xF2V[\x80a U\x81a\x05\x19V[\x03\x90\xA4`\x01\x90V[PP_\x90V[a ka\x19mV[P3\x90V[a xa\x10`V[Pa \x84\x81\x83\x90a\x18oV[_\x14a!\x0BWa \xAA_a \xA5_a \x9D\x81\x86\x90a\x14\xB0V[\x01\x85\x90a\x188V[a\x17\nV[\x90a \xB3a cV[\x90a \xF0a \xEAa \xE4\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x95a\x14\xA4V[\x92a\x12\xDBV[\x92a\x12\xDBV[\x92a \xF9a\x01\xF2V[\x80a!\x03\x81a\x05\x19V[\x03\x90\xA4`\x01\x90V[PP_\x90V[\x91` a!2\x92\x94\x93a!+`@\x82\x01\x96_\x83\x01\x90a\x0C\x0BV[\x01\x90a\x02\xFBV[V[\x90a!{a!\x80\x93a!l`\x04\x94\x93a!Sc\xA9\x05\x9C\xBB\x91\x93\x91a\x1CqV[\x92a!\\a\x01\xF2V[\x96\x87\x94` \x86\x01\x90\x81R\x01a!\x11V[` \x82\x01\x81\x03\x82R\x03\x83a\tUV[a!\x82V[V[\x90_` \x91a!\x8Fa\x19\xBDV[Pa!\x98a\x19\xBDV[P\x82\x81Q\x91\x01\x82\x85Z\xF1\x15a\"+W=_Q\x90a!\xBDa!\xB7_a\x11\x9EV[\x91a\x02\xF8V[\x14_\x14a\"\x11WPa!\xCE\x81a\x1CVV[;a!\xE1a!\xDB_a\x11\x9EV[\x91a\x02\xF8V[\x14[a!\xEAWPV[a!\xF6a\"\r\x91a\x1CVV[_\x91\x82\x91cRt\xAF\xE7`\xE0\x1B\x83R`\x04\x83\x01a\x0C\x18V[\x03\x90\xFD[a\"$a\"\x1E`\x01a\x1B!V[\x91a\x02\xF8V[\x14\x15a!\xE3V[`@Q=_\x82>=\x90\xFD[\x91` a\"W\x92\x94\x93a\"P`@\x82\x01\x96_\x83\x01\x90a\x0C\x0BV[\x01\x90a\x03\x84V[V[\x90a\"na\"h\x83\x83\x90a\x18oV[\x15a\x02QV[a\"vWPPV[a\"\x90_\x92\x83\x92c\xE2Q}?`\xE0\x1B\x84R`\x04\x84\x01a\"6V[\x03\x90\xFD",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361015610013575b61105c565b61001d5f356101ec565b806301ffc9a7146101e75780631033b4cc146101e2578063118c38c7146101dd5780631259a5c8146101d857806318b68b8c146101d3578063248a9ca3146101ce5780632f2ff15d146101c95780633462fac3146101c457806336568abe146101bf57806336b089d8146101ba5780635ab1d61c146101b557806361b0a56e146101b057806363221490146101ab57806365d7a3c9146101a657806367eeba0c146101a15780636813d7871461019c5780636bcc8c141461019757806391d1485414610192578063a217fddf1461018d578063b16e784914610188578063b20d30a914610183578063c9f5b63e1461017e578063cc3dc06114610179578063d3072d8214610174578063d547741f1461016f578063ead93c8f1461016a578063ede7cebd14610165578063f681a862146101605763fb8c4b510361000e57611024565b610fbd565b610f76565b610f0c565b610ec8565b610e93565b610e23565b610ca4565b610c62565b610c2d565b610b96565b610b25565b610af2565b610aa1565b610a6c565b610a28565b610808565b6107b6565b610749565b6106d3565b610690565b61065b565b6105f8565b610596565b61051e565b6103ea565b6103a6565b61031d565b610278565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b63ffffffff60e01b1690565b61021981610204565b0361022057565b5f80fd5b9050359061023182610210565b565b9060208282031261024c57610249915f01610224565b90565b6101fc565b151590565b61025f90610251565b9052565b9190610276905f60208501940190610256565b565b346102a8576102a461029361028e366004610233565b611064565b61029b6101f2565b91829182610263565b0390f35b6101f8565b5f9103126102b757565b6101fc565b1c90565b90565b6102d39060086102d893026102bc565b6102c0565b90565b906102e691546102c3565b90565b6102f560055f906102db565b90565b90565b610304906102f8565b9052565b919061031b905f602085019401906102fb565b565b3461034d5761032d3660046102ad565b6103496103386102e9565b6103406101f2565b91829182610308565b0390f35b6101f8565b7f751b795d24b92e3d92d1d0d8f2885f4e9c9c269da350af36ae6b49069babf4bf90565b61037e610352565b90565b90565b61038d90610381565b9052565b91906103a4905f60208501940190610384565b565b346103d6576103b63660046102ad565b6103d26103c1610376565b6103c96101f2565b91829182610391565b0390f35b6101f8565b6103e760065f906102db565b90565b3461041a576103fa3660046102ad565b6104166104056103db565b61040d6101f2565b91829182610308565b0390f35b6101f8565b60018060a01b031690565b6104339061041f565b90565b61043f8161042a565b0361044657565b5f80fd5b9050359061045782610436565b565b610462816102f8565b0361046957565b5f80fd5b9050359061047a82610459565b565b5f80fd5b5f80fd5b5f80fd5b909182601f830112156104c25781359167ffffffffffffffff83116104bd5760200192600183028401116104b857565b610484565b610480565b61047c565b91606083830312610514576104de825f850161044a565b926104ec836020830161046d565b92604082013567ffffffffffffffff811161050f5761050b9201610488565b9091565b610200565b6101fc565b5f0190565b346105505761053a6105313660046104c7565b92919091611492565b6105426101f2565b8061054c81610519565b0390f35b6101f8565b61055e81610381565b0361056557565b5f80fd5b9050359061057682610555565b565b906020828203126105915761058e915f01610569565b90565b6101fc565b346105c6576105c26105b16105ac366004610578565b6114ea565b6105b96101f2565b91829182610391565b0390f35b6101f8565b91906040838203126105f357806105e76105f0925f8601610569565b9360200161044a565b90565b6101fc565b346106275761061161060b3660046105cb565b90611535565b6106196101f2565b8061062381610519565b0390f35b6101f8565b7fc074beb46b251f73c0fec16eba75d6bc0042d09ee17a740ebbee308dbf87f82f90565b61065861062c565b90565b3461068b5761066b3660046102ad565b610687610676610650565b61067e6101f2565b91829182610391565b0390f35b6101f8565b346106bf576106a96106a33660046105cb565b90611541565b6106b16101f2565b806106bb81610519565b0390f35b6101f8565b6106d060035f906102db565b90565b34610703576106e33660046102ad565b6106ff6106ee6106c4565b6106f66101f2565b91829182610308565b0390f35b6101f8565b61071181610251565b0361071857565b5f80fd5b9050359061072982610708565b565b9060208282031261074457610741915f0161071c565b90565b6101fc565b346107775761076161075c36600461072b565b611638565b6107696101f2565b8061077381610519565b0390f35b6101f8565b90916060828403126107b1576107ae610797845f850161044a565b936107a5816020860161046d565b9360400161044a565b90565b6101fc565b346107e5576107cf6107c936600461077c565b916116b4565b6107d76101f2565b806107e181610519565b0390f35b6101f8565b9060208282031261080357610800915f0161046d565b90565b6101fc565b346108365761082061081b3660046107ea565b6116e9565b6108286101f2565b8061083281610519565b0390f35b6101f8565b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52602260045260245ffd5b9060016002830492168015610882575b602083101461087d57565b61084e565b91607f1691610872565b60209181520190565b5f5260205f2090565b905f92918054906108b86108b183610862565b809461088c565b916001811690815f1461090f57506001146108d3575b505050565b6108e09192939450610895565b915f925b8184106108f757505001905f80806108ce565b600181602092959395548486015201910192906108e4565b92949550505060ff19168252151560200201905f80806108ce565b906109349161089e565b90565b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b9061095f90610937565b810190811067ffffffffffffffff82111761097957604052565b610941565b9061099e6109979261098e6101f2565b9384809261092a565b0383610955565b565b905f106109b3576109b09061097e565b90565b61083b565b6109c460075f906109a0565b90565b5190565b60209181520190565b90825f9392825e0152565b6109fe610a07602093610a0c936109f5816109c7565b938480936109cb565b958691016109d4565b610937565b0190565b610a259160208201915f8184039101526109df565b90565b34610a5857610a383660046102ad565b610a54610a436109b8565b610a4b6101f2565b91829182610a10565b0390f35b6101f8565b610a6960045f906102db565b90565b34610a9c57610a7c3660046102ad565b610a98610a87610a5d565b610a8f6101f2565b91829182610308565b0390f35b6101f8565b34610acf57610ab9610ab436600461072b565b61172a565b610ac16101f2565b80610acb81610519565b0390f35b6101f8565b90602082820312610aed57610aea915f0161044a565b90565b6101fc565b34610b2057610b0a610b05366004610ad4565b61182d565b610b126101f2565b80610b1c81610519565b0390f35b6101f8565b34610b5657610b52610b41610b3b3660046105cb565b9061186f565b610b496101f2565b91829182610263565b0390f35b6101f8565b90565b5f1b90565b610b77610b72610b7c92610b5b565b610b5e565b610381565b90565b610b885f610b63565b90565b610b93610b7f565b90565b34610bc657610ba63660046102ad565b610bc2610bb1610b8b565b610bb96101f2565b91829182610391565b0390f35b6101f8565b60018060a01b031690565b610be6906008610beb93026102bc565b610bcb565b90565b90610bf99154610bd6565b90565b610c08600a5f90610bee565b90565b610c149061042a565b9052565b9190610c2b905f60208501940190610c0b565b565b34610c5d57610c3d3660046102ad565b610c59610c48610bfc565b610c506101f2565b91829182610c18565b0390f35b6101f8565b34610c9057610c7a610c753660046107ea565b611927565b610c826101f2565b80610c8c81610519565b0390f35b6101f8565b610ca160025f90610bee565b90565b34610cd457610cb43660046102ad565b610cd0610cbf610c95565b610cc76101f2565b91829182610c18565b0390f35b6101f8565b60209181520190565b5f5260205f2090565b905f9291805490610d05610cfe83610862565b8094610cd9565b916001811690815f14610d5c5750600114610d20575b505050565b610d2d9192939450610ce2565b915f925b818410610d4457505001905f8080610d1b565b60018160209295939554848601520191019290610d31565b92949550505060ff19168252151560200201905f8080610d1b565b90610d8191610ceb565b90565b90610da4610d9d92610d946101f2565b93848092610d77565b0383610955565b565b905f10610db957610db690610d84565b90565b61083b565b610dca600b5f90610da6565b90565b5190565b60209181520190565b610df9610e02602093610e0793610df081610dcd565b93848093610dd1565b958691016109d4565b610937565b0190565b610e209160208201915f818403910152610dda565b90565b34610e5357610e333660046102ad565b610e4f610e3e610dbe565b610e466101f2565b91829182610e0b565b0390f35b6101f8565b60ff1690565b610e6e906008610e7393026102bc565b610e58565b90565b90610e819154610e5e565b90565b610e9060085f90610e76565b90565b34610ec357610ea33660046102ad565b610ebf610eae610e84565b610eb66101f2565b91829182610263565b0390f35b6101f8565b34610ef757610ee1610edb3660046105cb565b9061195c565b610ee96101f2565b80610ef381610519565b0390f35b6101f8565b610f096002601490610e76565b90565b34610f3c57610f1c3660046102ad565b610f38610f27610efc565b610f2f6101f2565b91829182610263565b0390f35b6101f8565b604090610f6d610f62610f749597969460608401908482035f8601526109df565b966020830190610c0b565b0190610256565b565b34610fa957610f863660046102ad565b610fa5610f9161197d565b610f9c9391936101f2565b93849384610f41565b0390f35b6101f8565b610fba60095f906102db565b90565b34610fed57610fcd3660046102ad565b610fe9610fd8610fae565b610fe06101f2565b91829182610308565b0390f35b6101f8565b60409061101b611022949695939661101160608401985f8501906102fb565b60208301906102fb565b01906102fb565b565b34611057576110343660046102ad565b61105361103f6119e6565b61104a9391936101f2565b93849384610ff2565b0390f35b6101f8565b5f80fd5b5f90565b61106c611060565b5080611087611081637965db0b60e01b610204565b91610204565b14908115611094575b5090565b61109e9150611a74565b5f611090565b906110b89392916110b3611ac6565b6110e9565b6110c0611b4a565b565b60a01c90565b6110d46110d9916110c2565b610e58565b90565b6110e690546110c8565b90565b9291906110ff6110f960026110dc565b15610251565b61110e5761110c9361112a565b565b5f633df5105960e11b81528061112660048201610519565b0390fd5b92919061114861114261113b61062c565b339061186f565b15610251565b61115757611155936112e7565b565b5f635c427cd960e01b81528061116f60048201610519565b0390fd5b90565b61118a61118561118f92610b5b565b611173565b61041f565b90565b61119b90611176565b90565b6111b26111ad6111b792610b5b565b611173565b6102f8565b90565b5f1c90565b6111cb6111d0916111ba565b6102c0565b90565b6111dd90546111bf565b90565b634e487b7160e01b5f52601160045260245ffd5b611203611209919392936102f8565b926102f8565b820180921161121457565b6111e0565b61122d6112286112329261041f565b611173565b61041f565b90565b61123e90611219565b90565b61124a90611235565b90565b61125690611219565b90565b6112629061124d565b90565b906112715f1991610b5e565b9181191691161790565b61128f61128a611294926102f8565b611173565b6102f8565b90565b90565b906112af6112aa6112b69261127b565b611297565b8254611265565b9055565b6112c66112cb916111ba565b610bcb565b90565b6112d890546112ba565b90565b6112e49061124d565b90565b91929092826113066113006112fb5f611192565b61042a565b9161042a565b14611476578361131e6113185f61119e565b916102f8565b1461145a578361133f61133961133460036111d3565b6102f8565b916102f8565b1161143e5761134c611bb3565b61136061135960056111d3565b85906111f4565b61137b61137561137060046111d3565b6102f8565b916102f8565b11611422576113ad916113a261139085611241565b3361139a30611259565b908892611cbf565b839185909192611f4e565b6113ca6113c3836113be60056111d3565b6111f4565b600561129a565b6113d460026112ce565b9061141d61140b6114057f3dba401dc1abbf017086864b33ba815f53ab3cdbb9366ba6bcd8ec342ddd98e8936112db565b936112db565b936114146101f2565b91829182610308565b0390a3565b5f631c345a2f60e21b81528061143a60048201610519565b0390fd5b5f631c345a2f60e21b81528061145660048201610519565b0390fd5b5f631f2a200560e01b81528061147260048201610519565b0390fd5b5f63d92e233d60e01b81528061148e60048201610519565b0390fd5b9061149e9392916110a4565b565b5f90565b6114ad90610381565b90565b906114ba906114a4565b5f5260205260405f2090565b90565b6114d56114da916111ba565b6114c6565b90565b6114e790546114c9565b90565b6001611502611508926114fb6114a0565b505f6114b0565b016114dd565b90565b906115269161152161151c826114ea565b611fa4565b611528565b565b9061153291611fb8565b50565b9061153f9161150b565b565b908061155c611556611551612063565b61042a565b9161042a565b0361156d5761156a91612070565b50565b5f63334bd91960e11b81528061158560048201610519565b0390fd5b6115a29061159d611598610352565b611fa4565b6115f2565b565b60a01b90565b906115b960ff60a01b916115a4565b9181191691161790565b6115cc90610251565b90565b90565b906115e76115e26115ee926115c3565b6115cf565b82546115aa565b9055565b6115fd8160026115d2565b6116337fb3418989d06835b5c215eebb4d54ed6be7bbb66eb4807164740a2e082fa782d59161162a6101f2565b91829182610263565b0390a1565b61164190611589565b565b9061165e9291611659611654610b7f565b611fa4565b611660565b565b91908161167d6116776116725f611192565b61042a565b9161042a565b146116985761168e61169693611241565b919091612134565b565b5f63d92e233d60e01b8152806116b060048201610519565b0390fd5b906116bf9291611643565b565b6116da906116d56116d0610352565b611fa4565b6116dc565b565b6116e790600361129a565b565b6116f2906116c1565b565b9061170060ff91610b5e565b9181191691161790565b9061171f61171a611726926115c3565b6115cf565b82546116f4565b9055565b61173590600861170a565b565b6117509061174b611746610352565b611fa4565b611790565b565b9061176360018060a01b0391610b5e565b9181191691161790565b90565b9061178561178061178c926112db565b61176d565b8254611752565b9055565b806117ab6117a56117a05f611192565b61042a565b9161042a565b14611811576117ba60026112ce565b6117c5826002611770565b906117f96117f37fb07f8b1b85042d74022c867c836edeb0bcd70e135b0042390d2b1fd108298069936112db565b916112db565b916118026101f2565b8061180c81610519565b0390a3565b5f63d92e233d60e01b81528061182960048201610519565b0390fd5b61183690611737565b565b90611842906112db565b5f5260205260405f2090565b61185a61185f916111ba565b610e58565b90565b61186c905461184e565b90565b611895915f61188a61189093611883611060565b50826114b0565b01611838565b611862565b90565b6118b1906118ac6118a7610352565b611fa4565b6118d6565b565b9160206118d49294936118cd60408201965f8301906102fb565b01906102fb565b565b6118e060046111d3565b6118eb82600461129a565b907f207c4cbdf55ec315a13f0d5e047732ec5d947da056e706593aa509909941cedf916119226119196101f2565b928392836118b3565b0390a1565b61193090611898565b565b9061194d91611948611943826114ea565b611fa4565b61194f565b565b9061195991612070565b50565b9061196691611932565b565b606090565b5f90565b61197a9061097e565b90565b611985611968565b5061198e61196d565b50611997611060565b5060076119a460026112ce565b916119b86119b260026110dc565b92611971565b929190565b5f90565b6119d06119d6919392936102f8565b926102f8565b82039182116119e157565b6111e0565b6119ee6119bd565b506119f76119bd565b50611a006119bd565b50611a0b60056111d3565b611a1560046111d3565b91611a2060046111d3565b611a3b611a35611a3060056111d3565b6102f8565b916102f8565b115f14611a6657611a5f611a4f60046111d3565b611a5960056111d3565b906119c1565b5b91929190565b611a6f5f61119e565b611a60565b611a7c611060565b50611a96611a906301ffc9a760e01b610204565b91610204565b1490565b90565b611ab1611aac611ab692611a9a565b611173565b6102f8565b90565b611ac36002611a9d565b90565b611ad060016111d3565b611ae9611ae3611ade611ab9565b6102f8565b916102f8565b14611b0257611b00611af9611ab9565b600161129a565b565b5f633ee5aeb560e01b815280611b1a60048201610519565b0390fd5b90565b611b35611b30611b3a92611b1e565b611173565b6102f8565b90565b611b476001611b21565b90565b611b5c611b55611b3d565b600161129a565b565b90565b611b75611b70611b7a92611b5e565b611173565b6102f8565b90565b634e487b7160e01b5f52601260045260245ffd5b611b9d611ba3916102f8565b916102f8565b908115611bae570490565b611b7d565b611bc942611bc362015180611b61565b90611b91565b80611be5611bdf611bda60066111d3565b6102f8565b916102f8565b11611bee575b50565b80611c5091611bfd60056111d3565b7fda4e39dd56d72c2ee3d132e0146bc39e905e78e3bc64c40190421c7b2bcef2ab91611c33611c2a6101f2565b928392836118b3565b0390a1611c49611c425f61119e565b600561129a565b600661129a565b5f611beb565b611c5f9061124d565b90565b63ffffffff1690565b60e01b90565b611c85611c80611c8a92611c62565b611c6b565b610204565b90565b604090611cb6611cbd9496959396611cac60608401985f850190610c0b565b6020830190610c0b565b01906102fb565b565b600492611cf9611d0d9593611d089394611ce06323b872dd92949192611c71565b93611ce96101f2565b9788956020870190815201611c8d565b60208201810382520383610955565b612182565b565b5f7f4d6f636b2062726964676520657865637574696f6e206661696c656400000000910152565b611d43601c6020926109cb565b611d4c81611d0f565b0190565b611d659060208101905f818303910152611d36565b90565b5090565b601f602091010490565b1b90565b91906008611d95910291611d8f5f1984611d76565b92611d76565b9181191691161790565b9190611db5611db0611dbd9361127b565b611297565b908354611d7a565b9055565b611dd391611dcd6119bd565b91611d9f565b565b5b818110611de1575050565b80611dee5f600193611dc1565b01611dd6565b9190601f8111611e04575b505050565b611e10611e3593610ce2565b906020611e1c84611d6c565b83019310611e3d575b611e2e90611d6c565b0190611dd5565b5f8080611dff565b9150611e2e81929050611e25565b90611e5b905f19906008026102bc565b191690565b81611e6a91611e4b565b906002021790565b91611e7d9082611d68565b9067ffffffffffffffff8211611f3c57611ea182611e9b8554610862565b85611df4565b5f90601f8311600114611ed457918091611ec3935f92611ec8575b5050611e60565b90555b565b90915001355f80611ebc565b601f19831691611ee385610ce2565b925f5b818110611f2457509160029391856001969410611f0a575b50505002019055611ec6565b611f1a910135601f841690611e4b565b90555f8080611efe565b91936020600181928787013581550195019201611ee6565b610941565b90611f4c9291611e72565b565b92919092611f5c6008611862565b611f8257611f8093611f72611f7992600a611770565b600961129a565b600b611f41565b565b611f8a6101f2565b62461bcd60e51b815280611fa060048201611d50565b0390fd5b611fb690611fb0612063565b90612259565b565b611fc0611060565b50611fd5611fcf82849061186f565b15610251565b5f1461205d57611ffc6001611ff75f611fef8186906114b0565b018590611838565b61170a565b90612005612063565b9061204261203c6120367f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d956114a4565b926112db565b926112db565b9261204b6101f2565b8061205581610519565b0390a4600190565b50505f90565b61206b61196d565b503390565b612078611060565b5061208481839061186f565b5f1461210b576120aa5f6120a55f61209d8186906114b0565b018590611838565b61170a565b906120b3612063565b906120f06120ea6120e47ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b956114a4565b926112db565b926112db565b926120f96101f2565b8061210381610519565b0390a4600190565b50505f90565b91602061213292949361212b60408201965f830190610c0b565b01906102fb565b565b9061217b6121809361216c6004949361215363a9059cbb919391611c71565b9261215c6101f2565b9687946020860190815201612111565b60208201810382520383610955565b612182565b565b905f60209161218f6119bd565b506121986119bd565b50828151910182855af11561222b573d5f51906121bd6121b75f61119e565b916102f8565b145f1461221157506121ce81611c56565b3b6121e16121db5f61119e565b916102f8565b145b6121ea5750565b6121f661220d91611c56565b5f918291635274afe760e01b835260048301610c18565b0390fd5b61222461221e6001611b21565b916102f8565b14156121e3565b6040513d5f823e3d90fd5b91602061225792949361225060408201965f830190610c0b565b0190610384565b565b9061226e61226883839061186f565b15610251565b612276575050565b6122905f92839263e2517d3f60e01b845260048401612236565b0390fd
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x13W[a\x10\\V[a\0\x1D_5a\x01\xECV[\x80c\x01\xFF\xC9\xA7\x14a\x01\xE7W\x80c\x103\xB4\xCC\x14a\x01\xE2W\x80c\x11\x8C8\xC7\x14a\x01\xDDW\x80c\x12Y\xA5\xC8\x14a\x01\xD8W\x80c\x18\xB6\x8B\x8C\x14a\x01\xD3W\x80c$\x8A\x9C\xA3\x14a\x01\xCEW\x80c//\xF1]\x14a\x01\xC9W\x80c4b\xFA\xC3\x14a\x01\xC4W\x80c6V\x8A\xBE\x14a\x01\xBFW\x80c6\xB0\x89\xD8\x14a\x01\xBAW\x80cZ\xB1\xD6\x1C\x14a\x01\xB5W\x80ca\xB0\xA5n\x14a\x01\xB0W\x80cc\"\x14\x90\x14a\x01\xABW\x80ce\xD7\xA3\xC9\x14a\x01\xA6W\x80cg\xEE\xBA\x0C\x14a\x01\xA1W\x80ch\x13\xD7\x87\x14a\x01\x9CW\x80ck\xCC\x8C\x14\x14a\x01\x97W\x80c\x91\xD1HT\x14a\x01\x92W\x80c\xA2\x17\xFD\xDF\x14a\x01\x8DW\x80c\xB1nxI\x14a\x01\x88W\x80c\xB2\r0\xA9\x14a\x01\x83W\x80c\xC9\xF5\xB6>\x14a\x01~W\x80c\xCC=\xC0a\x14a\x01yW\x80c\xD3\x07-\x82\x14a\x01tW\x80c\xD5Gt\x1F\x14a\x01oW\x80c\xEA\xD9<\x8F\x14a\x01jW\x80c\xED\xE7\xCE\xBD\x14a\x01eW\x80c\xF6\x81\xA8b\x14a\x01`Wc\xFB\x8CKQ\x03a\0\x0EWa\x10$V[a\x0F\xBDV[a\x0FvV[a\x0F\x0CV[a\x0E\xC8V[a\x0E\x93V[a\x0E#V[a\x0C\xA4V[a\x0CbV[a\x0C-V[a\x0B\x96V[a\x0B%V[a\n\xF2V[a\n\xA1V[a\nlV[a\n(V[a\x08\x08V[a\x07\xB6V[a\x07IV[a\x06\xD3V[a\x06\x90V[a\x06[V[a\x05\xF8V[a\x05\x96V[a\x05\x1EV[a\x03\xEAV[a\x03\xA6V[a\x03\x1DV[a\x02xV[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x80\xFD[c\xFF\xFF\xFF\xFF`\xE0\x1B\x16\x90V[a\x02\x19\x81a\x02\x04V[\x03a\x02 WV[_\x80\xFD[\x90P5\x90a\x021\x82a\x02\x10V[V[\x90` \x82\x82\x03\x12a\x02LWa\x02I\x91_\x01a\x02$V[\x90V[a\x01\xFCV[\x15\x15\x90V[a\x02_\x90a\x02QV[\x90RV[\x91\x90a\x02v\x90_` \x85\x01\x94\x01\x90a\x02VV[V[4a\x02\xA8Wa\x02\xA4a\x02\x93a\x02\x8E6`\x04a\x023V[a\x10dV[a\x02\x9Ba\x01\xF2V[\x91\x82\x91\x82a\x02cV[\x03\x90\xF3[a\x01\xF8V[_\x91\x03\x12a\x02\xB7WV[a\x01\xFCV[\x1C\x90V[\x90V[a\x02\xD3\x90`\x08a\x02\xD8\x93\x02a\x02\xBCV[a\x02\xC0V[\x90V[\x90a\x02\xE6\x91Ta\x02\xC3V[\x90V[a\x02\xF5`\x05_\x90a\x02\xDBV[\x90V[\x90V[a\x03\x04\x90a\x02\xF8V[\x90RV[\x91\x90a\x03\x1B\x90_` \x85\x01\x94\x01\x90a\x02\xFBV[V[4a\x03MWa\x03-6`\x04a\x02\xADV[a\x03Ia\x038a\x02\xE9V[a\x03@a\x01\xF2V[\x91\x82\x91\x82a\x03\x08V[\x03\x90\xF3[a\x01\xF8V[\x7Fu\x1By]$\xB9.=\x92\xD1\xD0\xD8\xF2\x88_N\x9C\x9C&\x9D\xA3P\xAF6\xAEkI\x06\x9B\xAB\xF4\xBF\x90V[a\x03~a\x03RV[\x90V[\x90V[a\x03\x8D\x90a\x03\x81V[\x90RV[\x91\x90a\x03\xA4\x90_` \x85\x01\x94\x01\x90a\x03\x84V[V[4a\x03\xD6Wa\x03\xB66`\x04a\x02\xADV[a\x03\xD2a\x03\xC1a\x03vV[a\x03\xC9a\x01\xF2V[\x91\x82\x91\x82a\x03\x91V[\x03\x90\xF3[a\x01\xF8V[a\x03\xE7`\x06_\x90a\x02\xDBV[\x90V[4a\x04\x1AWa\x03\xFA6`\x04a\x02\xADV[a\x04\x16a\x04\x05a\x03\xDBV[a\x04\ra\x01\xF2V[\x91\x82\x91\x82a\x03\x08V[\x03\x90\xF3[a\x01\xF8V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x043\x90a\x04\x1FV[\x90V[a\x04?\x81a\x04*V[\x03a\x04FWV[_\x80\xFD[\x90P5\x90a\x04W\x82a\x046V[V[a\x04b\x81a\x02\xF8V[\x03a\x04iWV[_\x80\xFD[\x90P5\x90a\x04z\x82a\x04YV[V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x04\xC2W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x04\xBDW` \x01\x92`\x01\x83\x02\x84\x01\x11a\x04\xB8WV[a\x04\x84V[a\x04\x80V[a\x04|V[\x91``\x83\x83\x03\x12a\x05\x14Wa\x04\xDE\x82_\x85\x01a\x04JV[\x92a\x04\xEC\x83` \x83\x01a\x04mV[\x92`@\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x05\x0FWa\x05\x0B\x92\x01a\x04\x88V[\x90\x91V[a\x02\0V[a\x01\xFCV[_\x01\x90V[4a\x05PWa\x05:a\x0516`\x04a\x04\xC7V[\x92\x91\x90\x91a\x14\x92V[a\x05Ba\x01\xF2V[\x80a\x05L\x81a\x05\x19V[\x03\x90\xF3[a\x01\xF8V[a\x05^\x81a\x03\x81V[\x03a\x05eWV[_\x80\xFD[\x90P5\x90a\x05v\x82a\x05UV[V[\x90` \x82\x82\x03\x12a\x05\x91Wa\x05\x8E\x91_\x01a\x05iV[\x90V[a\x01\xFCV[4a\x05\xC6Wa\x05\xC2a\x05\xB1a\x05\xAC6`\x04a\x05xV[a\x14\xEAV[a\x05\xB9a\x01\xF2V[\x91\x82\x91\x82a\x03\x91V[\x03\x90\xF3[a\x01\xF8V[\x91\x90`@\x83\x82\x03\x12a\x05\xF3W\x80a\x05\xE7a\x05\xF0\x92_\x86\x01a\x05iV[\x93` \x01a\x04JV[\x90V[a\x01\xFCV[4a\x06'Wa\x06\x11a\x06\x0B6`\x04a\x05\xCBV[\x90a\x155V[a\x06\x19a\x01\xF2V[\x80a\x06#\x81a\x05\x19V[\x03\x90\xF3[a\x01\xF8V[\x7F\xC0t\xBE\xB4k%\x1Fs\xC0\xFE\xC1n\xBAu\xD6\xBC\0B\xD0\x9E\xE1zt\x0E\xBB\xEE0\x8D\xBF\x87\xF8/\x90V[a\x06Xa\x06,V[\x90V[4a\x06\x8BWa\x06k6`\x04a\x02\xADV[a\x06\x87a\x06va\x06PV[a\x06~a\x01\xF2V[\x91\x82\x91\x82a\x03\x91V[\x03\x90\xF3[a\x01\xF8V[4a\x06\xBFWa\x06\xA9a\x06\xA36`\x04a\x05\xCBV[\x90a\x15AV[a\x06\xB1a\x01\xF2V[\x80a\x06\xBB\x81a\x05\x19V[\x03\x90\xF3[a\x01\xF8V[a\x06\xD0`\x03_\x90a\x02\xDBV[\x90V[4a\x07\x03Wa\x06\xE36`\x04a\x02\xADV[a\x06\xFFa\x06\xEEa\x06\xC4V[a\x06\xF6a\x01\xF2V[\x91\x82\x91\x82a\x03\x08V[\x03\x90\xF3[a\x01\xF8V[a\x07\x11\x81a\x02QV[\x03a\x07\x18WV[_\x80\xFD[\x90P5\x90a\x07)\x82a\x07\x08V[V[\x90` \x82\x82\x03\x12a\x07DWa\x07A\x91_\x01a\x07\x1CV[\x90V[a\x01\xFCV[4a\x07wWa\x07aa\x07\\6`\x04a\x07+V[a\x168V[a\x07ia\x01\xF2V[\x80a\x07s\x81a\x05\x19V[\x03\x90\xF3[a\x01\xF8V[\x90\x91``\x82\x84\x03\x12a\x07\xB1Wa\x07\xAEa\x07\x97\x84_\x85\x01a\x04JV[\x93a\x07\xA5\x81` \x86\x01a\x04mV[\x93`@\x01a\x04JV[\x90V[a\x01\xFCV[4a\x07\xE5Wa\x07\xCFa\x07\xC96`\x04a\x07|V[\x91a\x16\xB4V[a\x07\xD7a\x01\xF2V[\x80a\x07\xE1\x81a\x05\x19V[\x03\x90\xF3[a\x01\xF8V[\x90` \x82\x82\x03\x12a\x08\x03Wa\x08\0\x91_\x01a\x04mV[\x90V[a\x01\xFCV[4a\x086Wa\x08 a\x08\x1B6`\x04a\x07\xEAV[a\x16\xE9V[a\x08(a\x01\xF2V[\x80a\x082\x81a\x05\x19V[\x03\x90\xF3[a\x01\xF8V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x08\x82W[` \x83\x10\x14a\x08}WV[a\x08NV[\x91`\x7F\x16\x91a\x08rV[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x08\xB8a\x08\xB1\x83a\x08bV[\x80\x94a\x08\x8CV[\x91`\x01\x81\x16\x90\x81_\x14a\t\x0FWP`\x01\x14a\x08\xD3W[PPPV[a\x08\xE0\x91\x92\x93\x94Pa\x08\x95V[\x91_\x92[\x81\x84\x10a\x08\xF7WPP\x01\x90_\x80\x80a\x08\xCEV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x08\xE4V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x08\xCEV[\x90a\t4\x91a\x08\x9EV[\x90V[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\t_\x90a\t7V[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\tyW`@RV[a\tAV[\x90a\t\x9Ea\t\x97\x92a\t\x8Ea\x01\xF2V[\x93\x84\x80\x92a\t*V[\x03\x83a\tUV[V[\x90_\x10a\t\xB3Wa\t\xB0\x90a\t~V[\x90V[a\x08;V[a\t\xC4`\x07_\x90a\t\xA0V[\x90V[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[a\t\xFEa\n\x07` \x93a\n\x0C\x93a\t\xF5\x81a\t\xC7V[\x93\x84\x80\x93a\t\xCBV[\x95\x86\x91\x01a\t\xD4V[a\t7V[\x01\x90V[a\n%\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\t\xDFV[\x90V[4a\nXWa\n86`\x04a\x02\xADV[a\nTa\nCa\t\xB8V[a\nKa\x01\xF2V[\x91\x82\x91\x82a\n\x10V[\x03\x90\xF3[a\x01\xF8V[a\ni`\x04_\x90a\x02\xDBV[\x90V[4a\n\x9CWa\n|6`\x04a\x02\xADV[a\n\x98a\n\x87a\n]V[a\n\x8Fa\x01\xF2V[\x91\x82\x91\x82a\x03\x08V[\x03\x90\xF3[a\x01\xF8V[4a\n\xCFWa\n\xB9a\n\xB46`\x04a\x07+V[a\x17*V[a\n\xC1a\x01\xF2V[\x80a\n\xCB\x81a\x05\x19V[\x03\x90\xF3[a\x01\xF8V[\x90` \x82\x82\x03\x12a\n\xEDWa\n\xEA\x91_\x01a\x04JV[\x90V[a\x01\xFCV[4a\x0B Wa\x0B\na\x0B\x056`\x04a\n\xD4V[a\x18-V[a\x0B\x12a\x01\xF2V[\x80a\x0B\x1C\x81a\x05\x19V[\x03\x90\xF3[a\x01\xF8V[4a\x0BVWa\x0BRa\x0BAa\x0B;6`\x04a\x05\xCBV[\x90a\x18oV[a\x0BIa\x01\xF2V[\x91\x82\x91\x82a\x02cV[\x03\x90\xF3[a\x01\xF8V[\x90V[_\x1B\x90V[a\x0Bwa\x0Bra\x0B|\x92a\x0B[V[a\x0B^V[a\x03\x81V[\x90V[a\x0B\x88_a\x0BcV[\x90V[a\x0B\x93a\x0B\x7FV[\x90V[4a\x0B\xC6Wa\x0B\xA66`\x04a\x02\xADV[a\x0B\xC2a\x0B\xB1a\x0B\x8BV[a\x0B\xB9a\x01\xF2V[\x91\x82\x91\x82a\x03\x91V[\x03\x90\xF3[a\x01\xF8V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x0B\xE6\x90`\x08a\x0B\xEB\x93\x02a\x02\xBCV[a\x0B\xCBV[\x90V[\x90a\x0B\xF9\x91Ta\x0B\xD6V[\x90V[a\x0C\x08`\n_\x90a\x0B\xEEV[\x90V[a\x0C\x14\x90a\x04*V[\x90RV[\x91\x90a\x0C+\x90_` \x85\x01\x94\x01\x90a\x0C\x0BV[V[4a\x0C]Wa\x0C=6`\x04a\x02\xADV[a\x0CYa\x0CHa\x0B\xFCV[a\x0CPa\x01\xF2V[\x91\x82\x91\x82a\x0C\x18V[\x03\x90\xF3[a\x01\xF8V[4a\x0C\x90Wa\x0Cza\x0Cu6`\x04a\x07\xEAV[a\x19'V[a\x0C\x82a\x01\xF2V[\x80a\x0C\x8C\x81a\x05\x19V[\x03\x90\xF3[a\x01\xF8V[a\x0C\xA1`\x02_\x90a\x0B\xEEV[\x90V[4a\x0C\xD4Wa\x0C\xB46`\x04a\x02\xADV[a\x0C\xD0a\x0C\xBFa\x0C\x95V[a\x0C\xC7a\x01\xF2V[\x91\x82\x91\x82a\x0C\x18V[\x03\x90\xF3[a\x01\xF8V[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\r\x05a\x0C\xFE\x83a\x08bV[\x80\x94a\x0C\xD9V[\x91`\x01\x81\x16\x90\x81_\x14a\r\\WP`\x01\x14a\r W[PPPV[a\r-\x91\x92\x93\x94Pa\x0C\xE2V[\x91_\x92[\x81\x84\x10a\rDWPP\x01\x90_\x80\x80a\r\x1BV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\r1V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\r\x1BV[\x90a\r\x81\x91a\x0C\xEBV[\x90V[\x90a\r\xA4a\r\x9D\x92a\r\x94a\x01\xF2V[\x93\x84\x80\x92a\rwV[\x03\x83a\tUV[V[\x90_\x10a\r\xB9Wa\r\xB6\x90a\r\x84V[\x90V[a\x08;V[a\r\xCA`\x0B_\x90a\r\xA6V[\x90V[Q\x90V[` \x91\x81R\x01\x90V[a\r\xF9a\x0E\x02` \x93a\x0E\x07\x93a\r\xF0\x81a\r\xCDV[\x93\x84\x80\x93a\r\xD1V[\x95\x86\x91\x01a\t\xD4V[a\t7V[\x01\x90V[a\x0E \x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\r\xDAV[\x90V[4a\x0ESWa\x0E36`\x04a\x02\xADV[a\x0EOa\x0E>a\r\xBEV[a\x0EFa\x01\xF2V[\x91\x82\x91\x82a\x0E\x0BV[\x03\x90\xF3[a\x01\xF8V[`\xFF\x16\x90V[a\x0En\x90`\x08a\x0Es\x93\x02a\x02\xBCV[a\x0EXV[\x90V[\x90a\x0E\x81\x91Ta\x0E^V[\x90V[a\x0E\x90`\x08_\x90a\x0EvV[\x90V[4a\x0E\xC3Wa\x0E\xA36`\x04a\x02\xADV[a\x0E\xBFa\x0E\xAEa\x0E\x84V[a\x0E\xB6a\x01\xF2V[\x91\x82\x91\x82a\x02cV[\x03\x90\xF3[a\x01\xF8V[4a\x0E\xF7Wa\x0E\xE1a\x0E\xDB6`\x04a\x05\xCBV[\x90a\x19\\V[a\x0E\xE9a\x01\xF2V[\x80a\x0E\xF3\x81a\x05\x19V[\x03\x90\xF3[a\x01\xF8V[a\x0F\t`\x02`\x14\x90a\x0EvV[\x90V[4a\x0F<Wa\x0F\x1C6`\x04a\x02\xADV[a\x0F8a\x0F'a\x0E\xFCV[a\x0F/a\x01\xF2V[\x91\x82\x91\x82a\x02cV[\x03\x90\xF3[a\x01\xF8V[`@\x90a\x0Fma\x0Fba\x0Ft\x95\x97\x96\x94``\x84\x01\x90\x84\x82\x03_\x86\x01Ra\t\xDFV[\x96` \x83\x01\x90a\x0C\x0BV[\x01\x90a\x02VV[V[4a\x0F\xA9Wa\x0F\x866`\x04a\x02\xADV[a\x0F\xA5a\x0F\x91a\x19}V[a\x0F\x9C\x93\x91\x93a\x01\xF2V[\x93\x84\x93\x84a\x0FAV[\x03\x90\xF3[a\x01\xF8V[a\x0F\xBA`\t_\x90a\x02\xDBV[\x90V[4a\x0F\xEDWa\x0F\xCD6`\x04a\x02\xADV[a\x0F\xE9a\x0F\xD8a\x0F\xAEV[a\x0F\xE0a\x01\xF2V[\x91\x82\x91\x82a\x03\x08V[\x03\x90\xF3[a\x01\xF8V[`@\x90a\x10\x1Ba\x10\"\x94\x96\x95\x93\x96a\x10\x11``\x84\x01\x98_\x85\x01\x90a\x02\xFBV[` \x83\x01\x90a\x02\xFBV[\x01\x90a\x02\xFBV[V[4a\x10WWa\x1046`\x04a\x02\xADV[a\x10Sa\x10?a\x19\xE6V[a\x10J\x93\x91\x93a\x01\xF2V[\x93\x84\x93\x84a\x0F\xF2V[\x03\x90\xF3[a\x01\xF8V[_\x80\xFD[_\x90V[a\x10la\x10`V[P\x80a\x10\x87a\x10\x81cye\xDB\x0B`\xE0\x1Ba\x02\x04V[\x91a\x02\x04V[\x14\x90\x81\x15a\x10\x94W[P\x90V[a\x10\x9E\x91Pa\x1AtV[_a\x10\x90V[\x90a\x10\xB8\x93\x92\x91a\x10\xB3a\x1A\xC6V[a\x10\xE9V[a\x10\xC0a\x1BJV[V[`\xA0\x1C\x90V[a\x10\xD4a\x10\xD9\x91a\x10\xC2V[a\x0EXV[\x90V[a\x10\xE6\x90Ta\x10\xC8V[\x90V[\x92\x91\x90a\x10\xFFa\x10\xF9`\x02a\x10\xDCV[\x15a\x02QV[a\x11\x0EWa\x11\x0C\x93a\x11*V[V[_c=\xF5\x10Y`\xE1\x1B\x81R\x80a\x11&`\x04\x82\x01a\x05\x19V[\x03\x90\xFD[\x92\x91\x90a\x11Ha\x11Ba\x11;a\x06,V[3\x90a\x18oV[\x15a\x02QV[a\x11WWa\x11U\x93a\x12\xE7V[V[_c\\B|\xD9`\xE0\x1B\x81R\x80a\x11o`\x04\x82\x01a\x05\x19V[\x03\x90\xFD[\x90V[a\x11\x8Aa\x11\x85a\x11\x8F\x92a\x0B[V[a\x11sV[a\x04\x1FV[\x90V[a\x11\x9B\x90a\x11vV[\x90V[a\x11\xB2a\x11\xADa\x11\xB7\x92a\x0B[V[a\x11sV[a\x02\xF8V[\x90V[_\x1C\x90V[a\x11\xCBa\x11\xD0\x91a\x11\xBAV[a\x02\xC0V[\x90V[a\x11\xDD\x90Ta\x11\xBFV[\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\x12\x03a\x12\t\x91\x93\x92\x93a\x02\xF8V[\x92a\x02\xF8V[\x82\x01\x80\x92\x11a\x12\x14WV[a\x11\xE0V[a\x12-a\x12(a\x122\x92a\x04\x1FV[a\x11sV[a\x04\x1FV[\x90V[a\x12>\x90a\x12\x19V[\x90V[a\x12J\x90a\x125V[\x90V[a\x12V\x90a\x12\x19V[\x90V[a\x12b\x90a\x12MV[\x90V[\x90a\x12q_\x19\x91a\x0B^V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x12\x8Fa\x12\x8Aa\x12\x94\x92a\x02\xF8V[a\x11sV[a\x02\xF8V[\x90V[\x90V[\x90a\x12\xAFa\x12\xAAa\x12\xB6\x92a\x12{V[a\x12\x97V[\x82Ta\x12eV[\x90UV[a\x12\xC6a\x12\xCB\x91a\x11\xBAV[a\x0B\xCBV[\x90V[a\x12\xD8\x90Ta\x12\xBAV[\x90V[a\x12\xE4\x90a\x12MV[\x90V[\x91\x92\x90\x92\x82a\x13\x06a\x13\0a\x12\xFB_a\x11\x92V[a\x04*V[\x91a\x04*V[\x14a\x14vW\x83a\x13\x1Ea\x13\x18_a\x11\x9EV[\x91a\x02\xF8V[\x14a\x14ZW\x83a\x13?a\x139a\x134`\x03a\x11\xD3V[a\x02\xF8V[\x91a\x02\xF8V[\x11a\x14>Wa\x13La\x1B\xB3V[a\x13`a\x13Y`\x05a\x11\xD3V[\x85\x90a\x11\xF4V[a\x13{a\x13ua\x13p`\x04a\x11\xD3V[a\x02\xF8V[\x91a\x02\xF8V[\x11a\x14\"Wa\x13\xAD\x91a\x13\xA2a\x13\x90\x85a\x12AV[3a\x13\x9A0a\x12YV[\x90\x88\x92a\x1C\xBFV[\x83\x91\x85\x90\x91\x92a\x1FNV[a\x13\xCAa\x13\xC3\x83a\x13\xBE`\x05a\x11\xD3V[a\x11\xF4V[`\x05a\x12\x9AV[a\x13\xD4`\x02a\x12\xCEV[\x90a\x14\x1Da\x14\x0Ba\x14\x05\x7F=\xBA@\x1D\xC1\xAB\xBF\x01p\x86\x86K3\xBA\x81_S\xAB<\xDB\xB96k\xA6\xBC\xD8\xEC4-\xDD\x98\xE8\x93a\x12\xDBV[\x93a\x12\xDBV[\x93a\x14\x14a\x01\xF2V[\x91\x82\x91\x82a\x03\x08V[\x03\x90\xA3V[_c\x1C4Z/`\xE2\x1B\x81R\x80a\x14:`\x04\x82\x01a\x05\x19V[\x03\x90\xFD[_c\x1C4Z/`\xE2\x1B\x81R\x80a\x14V`\x04\x82\x01a\x05\x19V[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a\x14r`\x04\x82\x01a\x05\x19V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a\x14\x8E`\x04\x82\x01a\x05\x19V[\x03\x90\xFD[\x90a\x14\x9E\x93\x92\x91a\x10\xA4V[V[_\x90V[a\x14\xAD\x90a\x03\x81V[\x90V[\x90a\x14\xBA\x90a\x14\xA4V[_R` R`@_ \x90V[\x90V[a\x14\xD5a\x14\xDA\x91a\x11\xBAV[a\x14\xC6V[\x90V[a\x14\xE7\x90Ta\x14\xC9V[\x90V[`\x01a\x15\x02a\x15\x08\x92a\x14\xFBa\x14\xA0V[P_a\x14\xB0V[\x01a\x14\xDDV[\x90V[\x90a\x15&\x91a\x15!a\x15\x1C\x82a\x14\xEAV[a\x1F\xA4V[a\x15(V[V[\x90a\x152\x91a\x1F\xB8V[PV[\x90a\x15?\x91a\x15\x0BV[V[\x90\x80a\x15\\a\x15Va\x15Qa cV[a\x04*V[\x91a\x04*V[\x03a\x15mWa\x15j\x91a pV[PV[_c3K\xD9\x19`\xE1\x1B\x81R\x80a\x15\x85`\x04\x82\x01a\x05\x19V[\x03\x90\xFD[a\x15\xA2\x90a\x15\x9Da\x15\x98a\x03RV[a\x1F\xA4V[a\x15\xF2V[V[`\xA0\x1B\x90V[\x90a\x15\xB9`\xFF`\xA0\x1B\x91a\x15\xA4V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x15\xCC\x90a\x02QV[\x90V[\x90V[\x90a\x15\xE7a\x15\xE2a\x15\xEE\x92a\x15\xC3V[a\x15\xCFV[\x82Ta\x15\xAAV[\x90UV[a\x15\xFD\x81`\x02a\x15\xD2V[a\x163\x7F\xB3A\x89\x89\xD0h5\xB5\xC2\x15\xEE\xBBMT\xEDk\xE7\xBB\xB6n\xB4\x80qdt\n.\x08/\xA7\x82\xD5\x91a\x16*a\x01\xF2V[\x91\x82\x91\x82a\x02cV[\x03\x90\xA1V[a\x16A\x90a\x15\x89V[V[\x90a\x16^\x92\x91a\x16Ya\x16Ta\x0B\x7FV[a\x1F\xA4V[a\x16`V[V[\x91\x90\x81a\x16}a\x16wa\x16r_a\x11\x92V[a\x04*V[\x91a\x04*V[\x14a\x16\x98Wa\x16\x8Ea\x16\x96\x93a\x12AV[\x91\x90\x91a!4V[V[_c\xD9.#=`\xE0\x1B\x81R\x80a\x16\xB0`\x04\x82\x01a\x05\x19V[\x03\x90\xFD[\x90a\x16\xBF\x92\x91a\x16CV[V[a\x16\xDA\x90a\x16\xD5a\x16\xD0a\x03RV[a\x1F\xA4V[a\x16\xDCV[V[a\x16\xE7\x90`\x03a\x12\x9AV[V[a\x16\xF2\x90a\x16\xC1V[V[\x90a\x17\0`\xFF\x91a\x0B^V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a\x17\x1Fa\x17\x1Aa\x17&\x92a\x15\xC3V[a\x15\xCFV[\x82Ta\x16\xF4V[\x90UV[a\x175\x90`\x08a\x17\nV[V[a\x17P\x90a\x17Ka\x17Fa\x03RV[a\x1F\xA4V[a\x17\x90V[V[\x90a\x17c`\x01\x80`\xA0\x1B\x03\x91a\x0B^V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90V[\x90a\x17\x85a\x17\x80a\x17\x8C\x92a\x12\xDBV[a\x17mV[\x82Ta\x17RV[\x90UV[\x80a\x17\xABa\x17\xA5a\x17\xA0_a\x11\x92V[a\x04*V[\x91a\x04*V[\x14a\x18\x11Wa\x17\xBA`\x02a\x12\xCEV[a\x17\xC5\x82`\x02a\x17pV[\x90a\x17\xF9a\x17\xF3\x7F\xB0\x7F\x8B\x1B\x85\x04-t\x02,\x86|\x83n\xDE\xB0\xBC\xD7\x0E\x13[\0B9\r+\x1F\xD1\x08)\x80i\x93a\x12\xDBV[\x91a\x12\xDBV[\x91a\x18\x02a\x01\xF2V[\x80a\x18\x0C\x81a\x05\x19V[\x03\x90\xA3V[_c\xD9.#=`\xE0\x1B\x81R\x80a\x18)`\x04\x82\x01a\x05\x19V[\x03\x90\xFD[a\x186\x90a\x177V[V[\x90a\x18B\x90a\x12\xDBV[_R` R`@_ \x90V[a\x18Za\x18_\x91a\x11\xBAV[a\x0EXV[\x90V[a\x18l\x90Ta\x18NV[\x90V[a\x18\x95\x91_a\x18\x8Aa\x18\x90\x93a\x18\x83a\x10`V[P\x82a\x14\xB0V[\x01a\x188V[a\x18bV[\x90V[a\x18\xB1\x90a\x18\xACa\x18\xA7a\x03RV[a\x1F\xA4V[a\x18\xD6V[V[\x91` a\x18\xD4\x92\x94\x93a\x18\xCD`@\x82\x01\x96_\x83\x01\x90a\x02\xFBV[\x01\x90a\x02\xFBV[V[a\x18\xE0`\x04a\x11\xD3V[a\x18\xEB\x82`\x04a\x12\x9AV[\x90\x7F |L\xBD\xF5^\xC3\x15\xA1?\r^\x04w2\xEC]\x94}\xA0V\xE7\x06Y:\xA5\t\x90\x99A\xCE\xDF\x91a\x19\"a\x19\x19a\x01\xF2V[\x92\x83\x92\x83a\x18\xB3V[\x03\x90\xA1V[a\x190\x90a\x18\x98V[V[\x90a\x19M\x91a\x19Ha\x19C\x82a\x14\xEAV[a\x1F\xA4V[a\x19OV[V[\x90a\x19Y\x91a pV[PV[\x90a\x19f\x91a\x192V[V[``\x90V[_\x90V[a\x19z\x90a\t~V[\x90V[a\x19\x85a\x19hV[Pa\x19\x8Ea\x19mV[Pa\x19\x97a\x10`V[P`\x07a\x19\xA4`\x02a\x12\xCEV[\x91a\x19\xB8a\x19\xB2`\x02a\x10\xDCV[\x92a\x19qV[\x92\x91\x90V[_\x90V[a\x19\xD0a\x19\xD6\x91\x93\x92\x93a\x02\xF8V[\x92a\x02\xF8V[\x82\x03\x91\x82\x11a\x19\xE1WV[a\x11\xE0V[a\x19\xEEa\x19\xBDV[Pa\x19\xF7a\x19\xBDV[Pa\x1A\0a\x19\xBDV[Pa\x1A\x0B`\x05a\x11\xD3V[a\x1A\x15`\x04a\x11\xD3V[\x91a\x1A `\x04a\x11\xD3V[a\x1A;a\x1A5a\x1A0`\x05a\x11\xD3V[a\x02\xF8V[\x91a\x02\xF8V[\x11_\x14a\x1AfWa\x1A_a\x1AO`\x04a\x11\xD3V[a\x1AY`\x05a\x11\xD3V[\x90a\x19\xC1V[[\x91\x92\x91\x90V[a\x1Ao_a\x11\x9EV[a\x1A`V[a\x1A|a\x10`V[Pa\x1A\x96a\x1A\x90c\x01\xFF\xC9\xA7`\xE0\x1Ba\x02\x04V[\x91a\x02\x04V[\x14\x90V[\x90V[a\x1A\xB1a\x1A\xACa\x1A\xB6\x92a\x1A\x9AV[a\x11sV[a\x02\xF8V[\x90V[a\x1A\xC3`\x02a\x1A\x9DV[\x90V[a\x1A\xD0`\x01a\x11\xD3V[a\x1A\xE9a\x1A\xE3a\x1A\xDEa\x1A\xB9V[a\x02\xF8V[\x91a\x02\xF8V[\x14a\x1B\x02Wa\x1B\0a\x1A\xF9a\x1A\xB9V[`\x01a\x12\x9AV[V[_c>\xE5\xAE\xB5`\xE0\x1B\x81R\x80a\x1B\x1A`\x04\x82\x01a\x05\x19V[\x03\x90\xFD[\x90V[a\x1B5a\x1B0a\x1B:\x92a\x1B\x1EV[a\x11sV[a\x02\xF8V[\x90V[a\x1BG`\x01a\x1B!V[\x90V[a\x1B\\a\x1BUa\x1B=V[`\x01a\x12\x9AV[V[\x90V[a\x1Bua\x1Bpa\x1Bz\x92a\x1B^V[a\x11sV[a\x02\xF8V[\x90V[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[a\x1B\x9Da\x1B\xA3\x91a\x02\xF8V[\x91a\x02\xF8V[\x90\x81\x15a\x1B\xAEW\x04\x90V[a\x1B}V[a\x1B\xC9Ba\x1B\xC3b\x01Q\x80a\x1BaV[\x90a\x1B\x91V[\x80a\x1B\xE5a\x1B\xDFa\x1B\xDA`\x06a\x11\xD3V[a\x02\xF8V[\x91a\x02\xF8V[\x11a\x1B\xEEW[PV[\x80a\x1CP\x91a\x1B\xFD`\x05a\x11\xD3V[\x7F\xDAN9\xDDV\xD7,.\xE3\xD12\xE0\x14k\xC3\x9E\x90^x\xE3\xBCd\xC4\x01\x90B\x1C{+\xCE\xF2\xAB\x91a\x1C3a\x1C*a\x01\xF2V[\x92\x83\x92\x83a\x18\xB3V[\x03\x90\xA1a\x1CIa\x1CB_a\x11\x9EV[`\x05a\x12\x9AV[`\x06a\x12\x9AV[_a\x1B\xEBV[a\x1C_\x90a\x12MV[\x90V[c\xFF\xFF\xFF\xFF\x16\x90V[`\xE0\x1B\x90V[a\x1C\x85a\x1C\x80a\x1C\x8A\x92a\x1CbV[a\x1CkV[a\x02\x04V[\x90V[`@\x90a\x1C\xB6a\x1C\xBD\x94\x96\x95\x93\x96a\x1C\xAC``\x84\x01\x98_\x85\x01\x90a\x0C\x0BV[` \x83\x01\x90a\x0C\x0BV[\x01\x90a\x02\xFBV[V[`\x04\x92a\x1C\xF9a\x1D\r\x95\x93a\x1D\x08\x93\x94a\x1C\xE0c#\xB8r\xDD\x92\x94\x91\x92a\x1CqV[\x93a\x1C\xE9a\x01\xF2V[\x97\x88\x95` \x87\x01\x90\x81R\x01a\x1C\x8DV[` \x82\x01\x81\x03\x82R\x03\x83a\tUV[a!\x82V[V[_\x7FMock bridge execution failed\0\0\0\0\x91\x01RV[a\x1DC`\x1C` \x92a\t\xCBV[a\x1DL\x81a\x1D\x0FV[\x01\x90V[a\x1De\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x1D6V[\x90V[P\x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a\x1D\x95\x91\x02\x91a\x1D\x8F_\x19\x84a\x1DvV[\x92a\x1DvV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x91\x90a\x1D\xB5a\x1D\xB0a\x1D\xBD\x93a\x12{V[a\x12\x97V[\x90\x83Ta\x1DzV[\x90UV[a\x1D\xD3\x91a\x1D\xCDa\x19\xBDV[\x91a\x1D\x9FV[V[[\x81\x81\x10a\x1D\xE1WPPV[\x80a\x1D\xEE_`\x01\x93a\x1D\xC1V[\x01a\x1D\xD6V[\x91\x90`\x1F\x81\x11a\x1E\x04W[PPPV[a\x1E\x10a\x1E5\x93a\x0C\xE2V[\x90` a\x1E\x1C\x84a\x1DlV[\x83\x01\x93\x10a\x1E=W[a\x1E.\x90a\x1DlV[\x01\x90a\x1D\xD5V[_\x80\x80a\x1D\xFFV[\x91Pa\x1E.\x81\x92\x90Pa\x1E%V[\x90a\x1E[\x90_\x19\x90`\x08\x02a\x02\xBCV[\x19\x16\x90V[\x81a\x1Ej\x91a\x1EKV[\x90`\x02\x02\x17\x90V[\x91a\x1E}\x90\x82a\x1DhV[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x1F<Wa\x1E\xA1\x82a\x1E\x9B\x85Ta\x08bV[\x85a\x1D\xF4V[_\x90`\x1F\x83\x11`\x01\x14a\x1E\xD4W\x91\x80\x91a\x1E\xC3\x93_\x92a\x1E\xC8W[PPa\x1E`V[\x90U[V[\x90\x91P\x015_\x80a\x1E\xBCV[`\x1F\x19\x83\x16\x91a\x1E\xE3\x85a\x0C\xE2V[\x92_[\x81\x81\x10a\x1F$WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\x1F\nW[PPP\x02\x01\x90Ua\x1E\xC6V[a\x1F\x1A\x91\x015`\x1F\x84\x16\x90a\x1EKV[\x90U_\x80\x80a\x1E\xFEV[\x91\x93` `\x01\x81\x92\x87\x87\x015\x81U\x01\x95\x01\x92\x01a\x1E\xE6V[a\tAV[\x90a\x1FL\x92\x91a\x1ErV[V[\x92\x91\x90\x92a\x1F\\`\x08a\x18bV[a\x1F\x82Wa\x1F\x80\x93a\x1Fra\x1Fy\x92`\na\x17pV[`\ta\x12\x9AV[`\x0Ba\x1FAV[V[a\x1F\x8Aa\x01\xF2V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x1F\xA0`\x04\x82\x01a\x1DPV[\x03\x90\xFD[a\x1F\xB6\x90a\x1F\xB0a cV[\x90a\"YV[V[a\x1F\xC0a\x10`V[Pa\x1F\xD5a\x1F\xCF\x82\x84\x90a\x18oV[\x15a\x02QV[_\x14a ]Wa\x1F\xFC`\x01a\x1F\xF7_a\x1F\xEF\x81\x86\x90a\x14\xB0V[\x01\x85\x90a\x188V[a\x17\nV[\x90a \x05a cV[\x90a Ba <a 6\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a\x14\xA4V[\x92a\x12\xDBV[\x92a\x12\xDBV[\x92a Ka\x01\xF2V[\x80a U\x81a\x05\x19V[\x03\x90\xA4`\x01\x90V[PP_\x90V[a ka\x19mV[P3\x90V[a xa\x10`V[Pa \x84\x81\x83\x90a\x18oV[_\x14a!\x0BWa \xAA_a \xA5_a \x9D\x81\x86\x90a\x14\xB0V[\x01\x85\x90a\x188V[a\x17\nV[\x90a \xB3a cV[\x90a \xF0a \xEAa \xE4\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x95a\x14\xA4V[\x92a\x12\xDBV[\x92a\x12\xDBV[\x92a \xF9a\x01\xF2V[\x80a!\x03\x81a\x05\x19V[\x03\x90\xA4`\x01\x90V[PP_\x90V[\x91` a!2\x92\x94\x93a!+`@\x82\x01\x96_\x83\x01\x90a\x0C\x0BV[\x01\x90a\x02\xFBV[V[\x90a!{a!\x80\x93a!l`\x04\x94\x93a!Sc\xA9\x05\x9C\xBB\x91\x93\x91a\x1CqV[\x92a!\\a\x01\xF2V[\x96\x87\x94` \x86\x01\x90\x81R\x01a!\x11V[` \x82\x01\x81\x03\x82R\x03\x83a\tUV[a!\x82V[V[\x90_` \x91a!\x8Fa\x19\xBDV[Pa!\x98a\x19\xBDV[P\x82\x81Q\x91\x01\x82\x85Z\xF1\x15a\"+W=_Q\x90a!\xBDa!\xB7_a\x11\x9EV[\x91a\x02\xF8V[\x14_\x14a\"\x11WPa!\xCE\x81a\x1CVV[;a!\xE1a!\xDB_a\x11\x9EV[\x91a\x02\xF8V[\x14[a!\xEAWPV[a!\xF6a\"\r\x91a\x1CVV[_\x91\x82\x91cRt\xAF\xE7`\xE0\x1B\x83R`\x04\x83\x01a\x0C\x18V[\x03\x90\xFD[a\"$a\"\x1E`\x01a\x1B!V[\x91a\x02\xF8V[\x14\x15a!\xE3V[`@Q=_\x82>=\x90\xFD[\x91` a\"W\x92\x94\x93a\"P`@\x82\x01\x96_\x83\x01\x90a\x0C\x0BV[\x01\x90a\x03\x84V[V[\x90a\"na\"h\x83\x83\x90a\x18oV[\x15a\x02QV[a\"vWPPV[a\"\x90_\x92\x83\x92c\xE2Q}?`\xE0\x1B\x84R`\x04\x84\x01a\"6V[\x03\x90\xFD",
    );
    /**Custom error with signature `AccessControlBadConfirmation()` and selector `0x6697b232`.
```solidity
error AccessControlBadConfirmation();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlBadConfirmation {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlBadConfirmation>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlBadConfirmation) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlBadConfirmation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlBadConfirmation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlBadConfirmation()";
            const SELECTOR: [u8; 4] = [102u8, 151u8, 178u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `AccessControlUnauthorizedAccount(address,bytes32)` and selector `0xe2517d3f`.
```solidity
error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub neededRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlUnauthorizedAccount) -> Self {
                (value.account, value.neededRole)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    neededRole: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlUnauthorizedAccount(address,bytes32)";
            const SELECTOR: [u8; 4] = [226u8, 81u8, 125u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.neededRole),
                )
            }
        }
    };
    /**Custom error with signature `BridgeCallFailed(string)` and selector `0xd245b2d3`.
```solidity
error BridgeCallFailed(string reason);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BridgeCallFailed {
        #[allow(missing_docs)]
        pub reason: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BridgeCallFailed> for UnderlyingRustTuple<'_> {
            fn from(value: BridgeCallFailed) -> Self {
                (value.reason,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BridgeCallFailed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { reason: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BridgeCallFailed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BridgeCallFailed(string)";
            const SELECTOR: [u8; 4] = [210u8, 69u8, 178u8, 211u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.reason,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `BridgeNotActive()` and selector `0x7bea20b2`.
```solidity
error BridgeNotActive();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BridgeNotActive {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BridgeNotActive> for UnderlyingRustTuple<'_> {
            fn from(value: BridgeNotActive) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BridgeNotActive {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BridgeNotActive {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BridgeNotActive()";
            const SELECTOR: [u8; 4] = [123u8, 234u8, 32u8, 178u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ExcessiveAmount()` and selector `0x70d168bc`.
```solidity
error ExcessiveAmount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExcessiveAmount {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExcessiveAmount> for UnderlyingRustTuple<'_> {
            fn from(value: ExcessiveAmount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ExcessiveAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ExcessiveAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ExcessiveAmount()";
            const SELECTOR: [u8; 4] = [112u8, 209u8, 104u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ReentrancyGuardReentrantCall()` and selector `0x3ee5aeb5`.
```solidity
error ReentrancyGuardReentrantCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ReentrancyGuardReentrantCall {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ReentrancyGuardReentrantCall>
        for UnderlyingRustTuple<'_> {
            fn from(value: ReentrancyGuardReentrantCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ReentrancyGuardReentrantCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ReentrancyGuardReentrantCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ReentrancyGuardReentrantCall()";
            const SELECTOR: [u8; 4] = [62u8, 229u8, 174u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `SafeERC20FailedOperation(address)` and selector `0x5274afe7`.
```solidity
error SafeERC20FailedOperation(address token);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SafeERC20FailedOperation {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SafeERC20FailedOperation>
        for UnderlyingRustTuple<'_> {
            fn from(value: SafeERC20FailedOperation) -> Self {
                (value.token,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SafeERC20FailedOperation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { token: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SafeERC20FailedOperation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SafeERC20FailedOperation(address)";
            const SELECTOR: [u8; 4] = [82u8, 116u8, 175u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `UnauthorizedCaller()` and selector `0x5c427cd9`.
```solidity
error UnauthorizedCaller();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UnauthorizedCaller {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnauthorizedCaller> for UnderlyingRustTuple<'_> {
            fn from(value: UnauthorizedCaller) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for UnauthorizedCaller {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UnauthorizedCaller {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UnauthorizedCaller()";
            const SELECTOR: [u8; 4] = [92u8, 66u8, 124u8, 217u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ZeroAddress()` and selector `0xd92e233d`.
```solidity
error ZeroAddress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAddress {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAddress> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAddress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAddress()";
            const SELECTOR: [u8; 4] = [217u8, 46u8, 35u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ZeroAmount()` and selector `0x1f2a2005`.
```solidity
error ZeroAmount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAmount {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAmount> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAmount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAmount()";
            const SELECTOR: [u8; 4] = [31u8, 42u8, 32u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Event with signature `BridgeExecuted(address,uint256,address)` and selector `0x3dba401dc1abbf017086864b33ba815f53ab3cdbb9366ba6bcd8ec342ddd98e8`.
```solidity
event BridgeExecuted(address indexed token, uint256 amount, address indexed target);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeExecuted {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub target: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeExecuted {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeExecuted(address,uint256,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                61u8,
                186u8,
                64u8,
                29u8,
                193u8,
                171u8,
                191u8,
                1u8,
                112u8,
                134u8,
                134u8,
                75u8,
                51u8,
                186u8,
                129u8,
                95u8,
                83u8,
                171u8,
                60u8,
                219u8,
                185u8,
                54u8,
                107u8,
                166u8,
                188u8,
                216u8,
                236u8,
                52u8,
                45u8,
                221u8,
                152u8,
                232u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    token: topics.1,
                    amount: data.0,
                    target: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.token.clone(), self.target.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.token,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.target,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeExecuted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeExecuted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeExecuted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeStatusUpdated(bool)` and selector `0xb3418989d06835b5c215eebb4d54ed6be7bbb66eb4807164740a2e082fa782d5`.
```solidity
event BridgeStatusUpdated(bool active);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeStatusUpdated {
        #[allow(missing_docs)]
        pub active: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeStatusUpdated {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "BridgeStatusUpdated(bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                179u8,
                65u8,
                137u8,
                137u8,
                208u8,
                104u8,
                53u8,
                181u8,
                194u8,
                21u8,
                238u8,
                187u8,
                77u8,
                84u8,
                237u8,
                107u8,
                231u8,
                187u8,
                182u8,
                110u8,
                180u8,
                128u8,
                113u8,
                100u8,
                116u8,
                10u8,
                46u8,
                8u8,
                47u8,
                167u8,
                130u8,
                213u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { active: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.active,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeStatusUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeStatusUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeStatusUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeTargetUpdated(address,address)` and selector `0xb07f8b1b85042d74022c867c836edeb0bcd70e135b0042390d2b1fd108298069`.
```solidity
event BridgeTargetUpdated(address indexed oldTarget, address indexed newTarget);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeTargetUpdated {
        #[allow(missing_docs)]
        pub oldTarget: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newTarget: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeTargetUpdated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeTargetUpdated(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                176u8,
                127u8,
                139u8,
                27u8,
                133u8,
                4u8,
                45u8,
                116u8,
                2u8,
                44u8,
                134u8,
                124u8,
                131u8,
                110u8,
                222u8,
                176u8,
                188u8,
                215u8,
                14u8,
                19u8,
                91u8,
                0u8,
                66u8,
                57u8,
                13u8,
                43u8,
                31u8,
                209u8,
                8u8,
                41u8,
                128u8,
                105u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldTarget: topics.1,
                    newTarget: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.oldTarget.clone(),
                    self.newTarget.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.oldTarget,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newTarget,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeTargetUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeTargetUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeTargetUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `DailyLimitReset(uint256,uint256)` and selector `0xda4e39dd56d72c2ee3d132e0146bc39e905e78e3bc64c40190421c7b2bcef2ab`.
```solidity
event DailyLimitReset(uint256 day, uint256 previousUsed);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DailyLimitReset {
        #[allow(missing_docs)]
        pub day: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub previousUsed: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DailyLimitReset {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "DailyLimitReset(uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                218u8,
                78u8,
                57u8,
                221u8,
                86u8,
                215u8,
                44u8,
                46u8,
                227u8,
                209u8,
                50u8,
                224u8,
                20u8,
                107u8,
                195u8,
                158u8,
                144u8,
                94u8,
                120u8,
                227u8,
                188u8,
                100u8,
                196u8,
                1u8,
                144u8,
                66u8,
                28u8,
                123u8,
                43u8,
                206u8,
                242u8,
                171u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    day: data.0,
                    previousUsed: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.day),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.previousUsed),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DailyLimitReset {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DailyLimitReset> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &DailyLimitReset) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `DailyLimitUpdated(uint256,uint256)` and selector `0x207c4cbdf55ec315a13f0d5e047732ec5d947da056e706593aa509909941cedf`.
```solidity
event DailyLimitUpdated(uint256 oldLimit, uint256 newLimit);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DailyLimitUpdated {
        #[allow(missing_docs)]
        pub oldLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub newLimit: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DailyLimitUpdated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "DailyLimitUpdated(uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                32u8,
                124u8,
                76u8,
                189u8,
                245u8,
                94u8,
                195u8,
                21u8,
                161u8,
                63u8,
                13u8,
                94u8,
                4u8,
                119u8,
                50u8,
                236u8,
                93u8,
                148u8,
                125u8,
                160u8,
                86u8,
                231u8,
                6u8,
                89u8,
                58u8,
                165u8,
                9u8,
                144u8,
                153u8,
                65u8,
                206u8,
                223u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldLimit: data.0,
                    newLimit: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.oldLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newLimit),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DailyLimitUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DailyLimitUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &DailyLimitUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleAdminChanged(bytes32,bytes32,bytes32)` and selector `0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff`.
```solidity
event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleAdminChanged {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub previousAdminRole: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newAdminRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleAdminChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "RoleAdminChanged(bytes32,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    previousAdminRole: topics.2,
                    newAdminRole: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.previousAdminRole.clone(),
                    self.newAdminRole.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.previousAdminRole);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newAdminRole);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleAdminChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleAdminChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleAdminChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleGranted(bytes32,address,address)` and selector `0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d`.
```solidity
event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleGranted {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleGranted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleGranted(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleGranted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleGranted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleGranted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleRevoked(bytes32,address,address)` and selector `0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b`.
```solidity
event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleRevoked {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleRevoked(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address admin, address caller, address bridgeTarget, uint256 maxSingleTransfer, uint256 dailyLimit);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub admin: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub bridgeTarget: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub maxSingleTransfer: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub dailyLimit: alloy::sol_types::private::primitives::aliases::U256,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (
                        value.admin,
                        value.caller,
                        value.bridgeTarget,
                        value.maxSingleTransfer,
                        value.dailyLimit,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        admin: tuple.0,
                        caller: tuple.1,
                        bridgeTarget: tuple.2,
                        maxSingleTransfer: tuple.3,
                        dailyLimit: tuple.4,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.admin,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridgeTarget,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxSingleTransfer),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.dailyLimit),
                )
            }
        }
    };
    /**Function with signature `BRIDGE_ADMIN_ROLE()` and selector `0x118c38c7`.
```solidity
function BRIDGE_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_ADMIN_ROLECall {}
    ///Container type for the return parameters of the [`BRIDGE_ADMIN_ROLE()`](BRIDGE_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for BRIDGE_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = BRIDGE_ADMIN_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BRIDGE_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [17u8, 140u8, 56u8, 199u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `BRIDGE_CALLER_ROLE()` and selector `0x3462fac3`.
```solidity
function BRIDGE_CALLER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_CALLER_ROLECall {}
    ///Container type for the return parameters of the [`BRIDGE_CALLER_ROLE()`](BRIDGE_CALLER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_CALLER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_CALLER_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_CALLER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_CALLER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_CALLER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_CALLER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_CALLER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for BRIDGE_CALLER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = BRIDGE_CALLER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BRIDGE_CALLER_ROLE()";
            const SELECTOR: [u8; 4] = [52u8, 98u8, 250u8, 195u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `DEFAULT_ADMIN_ROLE()` and selector `0xa217fddf`.
```solidity
function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLECall {}
    ///Container type for the return parameters of the [`DEFAULT_ADMIN_ROLE()`](DEFAULT_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEFAULT_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DEFAULT_ADMIN_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEFAULT_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [162u8, 23u8, 253u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeActive()` and selector `0xead93c8f`.
```solidity
function bridgeActive() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeActiveCall {}
    ///Container type for the return parameters of the [`bridgeActive()`](bridgeActiveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeActiveReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeActiveCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeActiveCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeActiveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeActiveReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeActiveReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeActiveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeActiveCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeActiveReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeActive()";
            const SELECTOR: [u8; 4] = [234u8, 217u8, 60u8, 143u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeName()` and selector `0x65d7a3c9`.
```solidity
function bridgeName() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeNameCall {}
    ///Container type for the return parameters of the [`bridgeName()`](bridgeNameCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeNameReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeNameCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeNameCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeNameCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeNameReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeNameReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeNameReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeNameCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeNameReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeName()";
            const SELECTOR: [u8; 4] = [101u8, 215u8, 163u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeTarget()` and selector `0xc9f5b63e`.
```solidity
function bridgeTarget() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeTargetCall {}
    ///Container type for the return parameters of the [`bridgeTarget()`](bridgeTargetCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeTargetReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeTargetCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeTargetCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeTargetCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeTargetReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeTargetReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeTargetReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeTargetCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeTargetReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeTarget()";
            const SELECTOR: [u8; 4] = [201u8, 245u8, 182u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `dailyLimit()` and selector `0x67eeba0c`.
```solidity
function dailyLimit() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct dailyLimitCall {}
    ///Container type for the return parameters of the [`dailyLimit()`](dailyLimitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct dailyLimitReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<dailyLimitCall> for UnderlyingRustTuple<'_> {
                fn from(value: dailyLimitCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for dailyLimitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<dailyLimitReturn> for UnderlyingRustTuple<'_> {
                fn from(value: dailyLimitReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for dailyLimitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for dailyLimitCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = dailyLimitReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "dailyLimit()";
            const SELECTOR: [u8; 4] = [103u8, 238u8, 186u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `dailyUsed()` and selector `0x1033b4cc`.
```solidity
function dailyUsed() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct dailyUsedCall {}
    ///Container type for the return parameters of the [`dailyUsed()`](dailyUsedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct dailyUsedReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<dailyUsedCall> for UnderlyingRustTuple<'_> {
                fn from(value: dailyUsedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for dailyUsedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<dailyUsedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: dailyUsedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for dailyUsedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for dailyUsedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = dailyUsedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "dailyUsed()";
            const SELECTOR: [u8; 4] = [16u8, 51u8, 180u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `executeBridge(address,uint256,bytes)` and selector `0x18b68b8c`.
```solidity
function executeBridge(address token, uint256 amount, bytes memory dynamicData) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct executeBridgeCall {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub dynamicData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`executeBridge(address,uint256,bytes)`](executeBridgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct executeBridgeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<executeBridgeCall> for UnderlyingRustTuple<'_> {
                fn from(value: executeBridgeCall) -> Self {
                    (value.token, value.amount, value.dynamicData)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for executeBridgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        token: tuple.0,
                        amount: tuple.1,
                        dynamicData: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<executeBridgeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: executeBridgeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for executeBridgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for executeBridgeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = executeBridgeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "executeBridge(address,uint256,bytes)";
            const SELECTOR: [u8; 4] = [24u8, 182u8, 139u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.dynamicData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBridgeInfo()` and selector `0xede7cebd`.
```solidity
function getBridgeInfo() external view returns (string memory name, address target, bool active);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeInfoCall {}
    ///Container type for the return parameters of the [`getBridgeInfo()`](getBridgeInfoCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeInfoReturn {
        #[allow(missing_docs)]
        pub name: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub target: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub active: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeInfoCall> for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeInfoCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBridgeInfoCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::Address,
                bool,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeInfoReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeInfoReturn) -> Self {
                    (value.name, value.target, value.active)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBridgeInfoReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        name: tuple.0,
                        target: tuple.1,
                        active: tuple.2,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBridgeInfoCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBridgeInfoReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBridgeInfo()";
            const SELECTOR: [u8; 4] = [237u8, 231u8, 206u8, 189u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getDailyUsage()` and selector `0xfb8c4b51`.
```solidity
function getDailyUsage() external view returns (uint256 used, uint256 limit, uint256 remaining);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getDailyUsageCall {}
    ///Container type for the return parameters of the [`getDailyUsage()`](getDailyUsageCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getDailyUsageReturn {
        #[allow(missing_docs)]
        pub used: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub limit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub remaining: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getDailyUsageCall> for UnderlyingRustTuple<'_> {
                fn from(value: getDailyUsageCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getDailyUsageCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getDailyUsageReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getDailyUsageReturn) -> Self {
                    (value.used, value.limit, value.remaining)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getDailyUsageReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        used: tuple.0,
                        limit: tuple.1,
                        remaining: tuple.2,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getDailyUsageCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getDailyUsageReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getDailyUsage()";
            const SELECTOR: [u8; 4] = [251u8, 140u8, 75u8, 81u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRoleAdmin(bytes32)` and selector `0x248a9ca3`.
```solidity
function getRoleAdmin(bytes32 role) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getRoleAdmin(bytes32)`](getRoleAdminCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleAdminCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRoleAdminReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleAdmin(bytes32)";
            const SELECTOR: [u8; 4] = [36u8, 138u8, 156u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `grantRole(bytes32,address)` and selector `0x2f2ff15d`.
```solidity
function grantRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`grantRole(bytes32,address)`](grantRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for grantRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = grantRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "grantRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [47u8, 47u8, 241u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `hasRole(bytes32,address)` and selector `0x91d14854`.
```solidity
function hasRole(bytes32 role, address account) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`hasRole(bytes32,address)`](hasRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = hasRoleReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [145u8, 209u8, 72u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `lastExecutedAmount()` and selector `0xf681a862`.
```solidity
function lastExecutedAmount() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lastExecutedAmountCall {}
    ///Container type for the return parameters of the [`lastExecutedAmount()`](lastExecutedAmountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lastExecutedAmountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lastExecutedAmountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: lastExecutedAmountCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for lastExecutedAmountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lastExecutedAmountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: lastExecutedAmountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for lastExecutedAmountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for lastExecutedAmountCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = lastExecutedAmountReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "lastExecutedAmount()";
            const SELECTOR: [u8; 4] = [246u8, 129u8, 168u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `lastExecutedData()` and selector `0xcc3dc061`.
```solidity
function lastExecutedData() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lastExecutedDataCall {}
    ///Container type for the return parameters of the [`lastExecutedData()`](lastExecutedDataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lastExecutedDataReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lastExecutedDataCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: lastExecutedDataCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for lastExecutedDataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lastExecutedDataReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: lastExecutedDataReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for lastExecutedDataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for lastExecutedDataCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = lastExecutedDataReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "lastExecutedData()";
            const SELECTOR: [u8; 4] = [204u8, 61u8, 192u8, 97u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `lastExecutedToken()` and selector `0xb16e7849`.
```solidity
function lastExecutedToken() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lastExecutedTokenCall {}
    ///Container type for the return parameters of the [`lastExecutedToken()`](lastExecutedTokenCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lastExecutedTokenReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lastExecutedTokenCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: lastExecutedTokenCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for lastExecutedTokenCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lastExecutedTokenReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: lastExecutedTokenReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for lastExecutedTokenReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for lastExecutedTokenCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = lastExecutedTokenReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "lastExecutedToken()";
            const SELECTOR: [u8; 4] = [177u8, 110u8, 120u8, 73u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `lastResetDay()` and selector `0x1259a5c8`.
```solidity
function lastResetDay() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lastResetDayCall {}
    ///Container type for the return parameters of the [`lastResetDay()`](lastResetDayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lastResetDayReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lastResetDayCall> for UnderlyingRustTuple<'_> {
                fn from(value: lastResetDayCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for lastResetDayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lastResetDayReturn> for UnderlyingRustTuple<'_> {
                fn from(value: lastResetDayReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for lastResetDayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for lastResetDayCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = lastResetDayReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "lastResetDay()";
            const SELECTOR: [u8; 4] = [18u8, 89u8, 165u8, 200u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `maxSingleTransfer()` and selector `0x36b089d8`.
```solidity
function maxSingleTransfer() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct maxSingleTransferCall {}
    ///Container type for the return parameters of the [`maxSingleTransfer()`](maxSingleTransferCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct maxSingleTransferReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<maxSingleTransferCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: maxSingleTransferCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for maxSingleTransferCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<maxSingleTransferReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: maxSingleTransferReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for maxSingleTransferReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for maxSingleTransferCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = maxSingleTransferReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "maxSingleTransfer()";
            const SELECTOR: [u8; 4] = [54u8, 176u8, 137u8, 216u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `recoverTokens(address,uint256,address)` and selector `0x61b0a56e`.
```solidity
function recoverTokens(address token, uint256 amount, address to) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct recoverTokensCall {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`recoverTokens(address,uint256,address)`](recoverTokensCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct recoverTokensReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<recoverTokensCall> for UnderlyingRustTuple<'_> {
                fn from(value: recoverTokensCall) -> Self {
                    (value.token, value.amount, value.to)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for recoverTokensCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        token: tuple.0,
                        amount: tuple.1,
                        to: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<recoverTokensReturn> for UnderlyingRustTuple<'_> {
                fn from(value: recoverTokensReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for recoverTokensReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for recoverTokensCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = recoverTokensReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "recoverTokens(address,uint256,address)";
            const SELECTOR: [u8; 4] = [97u8, 176u8, 165u8, 110u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `renounceRole(bytes32,address)` and selector `0x36568abe`.
```solidity
function renounceRole(bytes32 role, address callerConfirmation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub callerConfirmation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`renounceRole(bytes32,address)`](renounceRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleCall) -> Self {
                    (value.role, value.callerConfirmation)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        callerConfirmation: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [54u8, 86u8, 138u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callerConfirmation,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `revokeRole(bytes32,address)` and selector `0xd547741f`.
```solidity
function revokeRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeRole(bytes32,address)`](revokeRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [213u8, 71u8, 116u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBridgeActive(bool)` and selector `0x5ab1d61c`.
```solidity
function setBridgeActive(bool active) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeActiveCall {
        #[allow(missing_docs)]
        pub active: bool,
    }
    ///Container type for the return parameters of the [`setBridgeActive(bool)`](setBridgeActiveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeActiveReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeActiveCall> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeActiveCall) -> Self {
                    (value.active,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgeActiveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { active: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeActiveReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeActiveReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setBridgeActiveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBridgeActiveCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bool,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBridgeActiveReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBridgeActive(bool)";
            const SELECTOR: [u8; 4] = [90u8, 177u8, 214u8, 28u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.active,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBridgeTarget(address)` and selector `0x6bcc8c14`.
```solidity
function setBridgeTarget(address target) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeTargetCall {
        #[allow(missing_docs)]
        pub target: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setBridgeTarget(address)`](setBridgeTargetCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeTargetReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeTargetCall> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeTargetCall) -> Self {
                    (value.target,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgeTargetCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { target: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeTargetReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeTargetReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setBridgeTargetReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBridgeTargetCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBridgeTargetReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBridgeTarget(address)";
            const SELECTOR: [u8; 4] = [107u8, 204u8, 140u8, 20u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setDailyLimit(uint256)` and selector `0xb20d30a9`.
```solidity
function setDailyLimit(uint256 limit) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setDailyLimitCall {
        #[allow(missing_docs)]
        pub limit: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setDailyLimit(uint256)`](setDailyLimitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setDailyLimitReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setDailyLimitCall> for UnderlyingRustTuple<'_> {
                fn from(value: setDailyLimitCall) -> Self {
                    (value.limit,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setDailyLimitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { limit: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setDailyLimitReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setDailyLimitReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setDailyLimitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setDailyLimitCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setDailyLimitReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setDailyLimit(uint256)";
            const SELECTOR: [u8; 4] = [178u8, 13u8, 48u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.limit),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setMaxSingleTransfer(uint256)` and selector `0x63221490`.
```solidity
function setMaxSingleTransfer(uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setMaxSingleTransferCall {
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setMaxSingleTransfer(uint256)`](setMaxSingleTransferCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setMaxSingleTransferReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setMaxSingleTransferCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setMaxSingleTransferCall) -> Self {
                    (value.amount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setMaxSingleTransferCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { amount: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setMaxSingleTransferReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setMaxSingleTransferReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setMaxSingleTransferReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setMaxSingleTransferCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setMaxSingleTransferReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setMaxSingleTransfer(uint256)";
            const SELECTOR: [u8; 4] = [99u8, 34u8, 20u8, 144u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setShouldRevert(bool)` and selector `0x6813d787`.
```solidity
function setShouldRevert(bool _shouldRevert) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setShouldRevertCall {
        #[allow(missing_docs)]
        pub _shouldRevert: bool,
    }
    ///Container type for the return parameters of the [`setShouldRevert(bool)`](setShouldRevertCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setShouldRevertReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setShouldRevertCall> for UnderlyingRustTuple<'_> {
                fn from(value: setShouldRevertCall) -> Self {
                    (value._shouldRevert,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setShouldRevertCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _shouldRevert: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setShouldRevertReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setShouldRevertReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setShouldRevertReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setShouldRevertCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bool,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setShouldRevertReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setShouldRevert(bool)";
            const SELECTOR: [u8; 4] = [104u8, 19u8, 215u8, 135u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self._shouldRevert,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `shouldRevert()` and selector `0xd3072d82`.
```solidity
function shouldRevert() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct shouldRevertCall {}
    ///Container type for the return parameters of the [`shouldRevert()`](shouldRevertCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct shouldRevertReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<shouldRevertCall> for UnderlyingRustTuple<'_> {
                fn from(value: shouldRevertCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for shouldRevertCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<shouldRevertReturn> for UnderlyingRustTuple<'_> {
                fn from(value: shouldRevertReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for shouldRevertReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for shouldRevertCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = shouldRevertReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "shouldRevert()";
            const SELECTOR: [u8; 4] = [211u8, 7u8, 45u8, 130u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
```solidity
function supportsInterface(bytes4 interfaceId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceCall {
        #[allow(missing_docs)]
        pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
    }
    ///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceCall) -> Self {
                    (value.interfaceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { interfaceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportsInterfaceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = supportsInterfaceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportsInterface(bytes4)";
            const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.interfaceId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`MockBridgeProxy`](self) function calls.
    pub enum MockBridgeProxyCalls {
        #[allow(missing_docs)]
        BRIDGE_ADMIN_ROLE(BRIDGE_ADMIN_ROLECall),
        #[allow(missing_docs)]
        BRIDGE_CALLER_ROLE(BRIDGE_CALLER_ROLECall),
        #[allow(missing_docs)]
        DEFAULT_ADMIN_ROLE(DEFAULT_ADMIN_ROLECall),
        #[allow(missing_docs)]
        bridgeActive(bridgeActiveCall),
        #[allow(missing_docs)]
        bridgeName(bridgeNameCall),
        #[allow(missing_docs)]
        bridgeTarget(bridgeTargetCall),
        #[allow(missing_docs)]
        dailyLimit(dailyLimitCall),
        #[allow(missing_docs)]
        dailyUsed(dailyUsedCall),
        #[allow(missing_docs)]
        executeBridge(executeBridgeCall),
        #[allow(missing_docs)]
        getBridgeInfo(getBridgeInfoCall),
        #[allow(missing_docs)]
        getDailyUsage(getDailyUsageCall),
        #[allow(missing_docs)]
        getRoleAdmin(getRoleAdminCall),
        #[allow(missing_docs)]
        grantRole(grantRoleCall),
        #[allow(missing_docs)]
        hasRole(hasRoleCall),
        #[allow(missing_docs)]
        lastExecutedAmount(lastExecutedAmountCall),
        #[allow(missing_docs)]
        lastExecutedData(lastExecutedDataCall),
        #[allow(missing_docs)]
        lastExecutedToken(lastExecutedTokenCall),
        #[allow(missing_docs)]
        lastResetDay(lastResetDayCall),
        #[allow(missing_docs)]
        maxSingleTransfer(maxSingleTransferCall),
        #[allow(missing_docs)]
        recoverTokens(recoverTokensCall),
        #[allow(missing_docs)]
        renounceRole(renounceRoleCall),
        #[allow(missing_docs)]
        revokeRole(revokeRoleCall),
        #[allow(missing_docs)]
        setBridgeActive(setBridgeActiveCall),
        #[allow(missing_docs)]
        setBridgeTarget(setBridgeTargetCall),
        #[allow(missing_docs)]
        setDailyLimit(setDailyLimitCall),
        #[allow(missing_docs)]
        setMaxSingleTransfer(setMaxSingleTransferCall),
        #[allow(missing_docs)]
        setShouldRevert(setShouldRevertCall),
        #[allow(missing_docs)]
        shouldRevert(shouldRevertCall),
        #[allow(missing_docs)]
        supportsInterface(supportsInterfaceCall),
    }
    #[automatically_derived]
    impl MockBridgeProxyCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 255u8, 201u8, 167u8],
            [16u8, 51u8, 180u8, 204u8],
            [17u8, 140u8, 56u8, 199u8],
            [18u8, 89u8, 165u8, 200u8],
            [24u8, 182u8, 139u8, 140u8],
            [36u8, 138u8, 156u8, 163u8],
            [47u8, 47u8, 241u8, 93u8],
            [52u8, 98u8, 250u8, 195u8],
            [54u8, 86u8, 138u8, 190u8],
            [54u8, 176u8, 137u8, 216u8],
            [90u8, 177u8, 214u8, 28u8],
            [97u8, 176u8, 165u8, 110u8],
            [99u8, 34u8, 20u8, 144u8],
            [101u8, 215u8, 163u8, 201u8],
            [103u8, 238u8, 186u8, 12u8],
            [104u8, 19u8, 215u8, 135u8],
            [107u8, 204u8, 140u8, 20u8],
            [145u8, 209u8, 72u8, 84u8],
            [162u8, 23u8, 253u8, 223u8],
            [177u8, 110u8, 120u8, 73u8],
            [178u8, 13u8, 48u8, 169u8],
            [201u8, 245u8, 182u8, 62u8],
            [204u8, 61u8, 192u8, 97u8],
            [211u8, 7u8, 45u8, 130u8],
            [213u8, 71u8, 116u8, 31u8],
            [234u8, 217u8, 60u8, 143u8],
            [237u8, 231u8, 206u8, 189u8],
            [246u8, 129u8, 168u8, 98u8],
            [251u8, 140u8, 75u8, 81u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for MockBridgeProxyCalls {
        const NAME: &'static str = "MockBridgeProxyCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 29usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::BRIDGE_ADMIN_ROLE(_) => {
                    <BRIDGE_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::BRIDGE_CALLER_ROLE(_) => {
                    <BRIDGE_CALLER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DEFAULT_ADMIN_ROLE(_) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeActive(_) => {
                    <bridgeActiveCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeName(_) => {
                    <bridgeNameCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeTarget(_) => {
                    <bridgeTargetCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::dailyLimit(_) => {
                    <dailyLimitCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::dailyUsed(_) => {
                    <dailyUsedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::executeBridge(_) => {
                    <executeBridgeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBridgeInfo(_) => {
                    <getBridgeInfoCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getDailyUsage(_) => {
                    <getDailyUsageCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleAdmin(_) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::grantRole(_) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasRole(_) => <hasRoleCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::lastExecutedAmount(_) => {
                    <lastExecutedAmountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::lastExecutedData(_) => {
                    <lastExecutedDataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::lastExecutedToken(_) => {
                    <lastExecutedTokenCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::lastResetDay(_) => {
                    <lastResetDayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::maxSingleTransfer(_) => {
                    <maxSingleTransferCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::recoverTokens(_) => {
                    <recoverTokensCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceRole(_) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeRole(_) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBridgeActive(_) => {
                    <setBridgeActiveCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBridgeTarget(_) => {
                    <setBridgeTargetCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setDailyLimit(_) => {
                    <setDailyLimitCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setMaxSingleTransfer(_) => {
                    <setMaxSingleTransferCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setShouldRevert(_) => {
                    <setShouldRevertCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::shouldRevert(_) => {
                    <shouldRevertCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::supportsInterface(_) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<MockBridgeProxyCalls>] = &[
                {
                    fn supportsInterface(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn dailyUsed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <dailyUsedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::dailyUsed)
                    }
                    dailyUsed
                },
                {
                    fn BRIDGE_ADMIN_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <BRIDGE_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::BRIDGE_ADMIN_ROLE)
                    }
                    BRIDGE_ADMIN_ROLE
                },
                {
                    fn lastResetDay(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <lastResetDayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::lastResetDay)
                    }
                    lastResetDay
                },
                {
                    fn executeBridge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <executeBridgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::executeBridge)
                    }
                    executeBridge
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn grantRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn BRIDGE_CALLER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <BRIDGE_CALLER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::BRIDGE_CALLER_ROLE)
                    }
                    BRIDGE_CALLER_ROLE
                },
                {
                    fn renounceRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn maxSingleTransfer(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <maxSingleTransferCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::maxSingleTransfer)
                    }
                    maxSingleTransfer
                },
                {
                    fn setBridgeActive(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <setBridgeActiveCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::setBridgeActive)
                    }
                    setBridgeActive
                },
                {
                    fn recoverTokens(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <recoverTokensCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::recoverTokens)
                    }
                    recoverTokens
                },
                {
                    fn setMaxSingleTransfer(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <setMaxSingleTransferCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::setMaxSingleTransfer)
                    }
                    setMaxSingleTransfer
                },
                {
                    fn bridgeName(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <bridgeNameCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::bridgeName)
                    }
                    bridgeName
                },
                {
                    fn dailyLimit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <dailyLimitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::dailyLimit)
                    }
                    dailyLimit
                },
                {
                    fn setShouldRevert(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <setShouldRevertCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::setShouldRevert)
                    }
                    setShouldRevert
                },
                {
                    fn setBridgeTarget(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <setBridgeTargetCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::setBridgeTarget)
                    }
                    setBridgeTarget
                },
                {
                    fn hasRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn lastExecutedToken(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <lastExecutedTokenCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::lastExecutedToken)
                    }
                    lastExecutedToken
                },
                {
                    fn setDailyLimit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <setDailyLimitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::setDailyLimit)
                    }
                    setDailyLimit
                },
                {
                    fn bridgeTarget(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <bridgeTargetCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::bridgeTarget)
                    }
                    bridgeTarget
                },
                {
                    fn lastExecutedData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <lastExecutedDataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::lastExecutedData)
                    }
                    lastExecutedData
                },
                {
                    fn shouldRevert(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <shouldRevertCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::shouldRevert)
                    }
                    shouldRevert
                },
                {
                    fn revokeRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn bridgeActive(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <bridgeActiveCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::bridgeActive)
                    }
                    bridgeActive
                },
                {
                    fn getBridgeInfo(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <getBridgeInfoCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::getBridgeInfo)
                    }
                    getBridgeInfo
                },
                {
                    fn lastExecutedAmount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <lastExecutedAmountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::lastExecutedAmount)
                    }
                    lastExecutedAmount
                },
                {
                    fn getDailyUsage(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyCalls> {
                        <getDailyUsageCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyCalls::getDailyUsage)
                    }
                    getDailyUsage
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::BRIDGE_ADMIN_ROLE(inner) => {
                    <BRIDGE_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BRIDGE_CALLER_ROLE(inner) => {
                    <BRIDGE_CALLER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bridgeActive(inner) => {
                    <bridgeActiveCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bridgeName(inner) => {
                    <bridgeNameCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::bridgeTarget(inner) => {
                    <bridgeTargetCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::dailyLimit(inner) => {
                    <dailyLimitCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::dailyUsed(inner) => {
                    <dailyUsedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::executeBridge(inner) => {
                    <executeBridgeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBridgeInfo(inner) => {
                    <getBridgeInfoCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getDailyUsage(inner) => {
                    <getDailyUsageCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::lastExecutedAmount(inner) => {
                    <lastExecutedAmountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::lastExecutedData(inner) => {
                    <lastExecutedDataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::lastExecutedToken(inner) => {
                    <lastExecutedTokenCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::lastResetDay(inner) => {
                    <lastResetDayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::maxSingleTransfer(inner) => {
                    <maxSingleTransferCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::recoverTokens(inner) => {
                    <recoverTokensCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setBridgeActive(inner) => {
                    <setBridgeActiveCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setBridgeTarget(inner) => {
                    <setBridgeTargetCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setDailyLimit(inner) => {
                    <setDailyLimitCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setMaxSingleTransfer(inner) => {
                    <setMaxSingleTransferCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setShouldRevert(inner) => {
                    <setShouldRevertCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::shouldRevert(inner) => {
                    <shouldRevertCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::BRIDGE_ADMIN_ROLE(inner) => {
                    <BRIDGE_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BRIDGE_CALLER_ROLE(inner) => {
                    <BRIDGE_CALLER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeActive(inner) => {
                    <bridgeActiveCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeName(inner) => {
                    <bridgeNameCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeTarget(inner) => {
                    <bridgeTargetCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::dailyLimit(inner) => {
                    <dailyLimitCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::dailyUsed(inner) => {
                    <dailyUsedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::executeBridge(inner) => {
                    <executeBridgeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBridgeInfo(inner) => {
                    <getBridgeInfoCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getDailyUsage(inner) => {
                    <getDailyUsageCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::lastExecutedAmount(inner) => {
                    <lastExecutedAmountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::lastExecutedData(inner) => {
                    <lastExecutedDataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::lastExecutedToken(inner) => {
                    <lastExecutedTokenCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::lastResetDay(inner) => {
                    <lastResetDayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::maxSingleTransfer(inner) => {
                    <maxSingleTransferCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::recoverTokens(inner) => {
                    <recoverTokensCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBridgeActive(inner) => {
                    <setBridgeActiveCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBridgeTarget(inner) => {
                    <setBridgeTargetCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setDailyLimit(inner) => {
                    <setDailyLimitCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setMaxSingleTransfer(inner) => {
                    <setMaxSingleTransferCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setShouldRevert(inner) => {
                    <setShouldRevertCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::shouldRevert(inner) => {
                    <shouldRevertCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`MockBridgeProxy`](self) custom errors.
    pub enum MockBridgeProxyErrors {
        #[allow(missing_docs)]
        AccessControlBadConfirmation(AccessControlBadConfirmation),
        #[allow(missing_docs)]
        AccessControlUnauthorizedAccount(AccessControlUnauthorizedAccount),
        #[allow(missing_docs)]
        BridgeCallFailed(BridgeCallFailed),
        #[allow(missing_docs)]
        BridgeNotActive(BridgeNotActive),
        #[allow(missing_docs)]
        ExcessiveAmount(ExcessiveAmount),
        #[allow(missing_docs)]
        ReentrancyGuardReentrantCall(ReentrancyGuardReentrantCall),
        #[allow(missing_docs)]
        SafeERC20FailedOperation(SafeERC20FailedOperation),
        #[allow(missing_docs)]
        UnauthorizedCaller(UnauthorizedCaller),
        #[allow(missing_docs)]
        ZeroAddress(ZeroAddress),
        #[allow(missing_docs)]
        ZeroAmount(ZeroAmount),
    }
    #[automatically_derived]
    impl MockBridgeProxyErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [31u8, 42u8, 32u8, 5u8],
            [62u8, 229u8, 174u8, 181u8],
            [82u8, 116u8, 175u8, 231u8],
            [92u8, 66u8, 124u8, 217u8],
            [102u8, 151u8, 178u8, 50u8],
            [112u8, 209u8, 104u8, 188u8],
            [123u8, 234u8, 32u8, 178u8],
            [210u8, 69u8, 178u8, 211u8],
            [217u8, 46u8, 35u8, 61u8],
            [226u8, 81u8, 125u8, 63u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for MockBridgeProxyErrors {
        const NAME: &'static str = "MockBridgeProxyErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 10usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AccessControlBadConfirmation(_) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AccessControlUnauthorizedAccount(_) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BridgeCallFailed(_) => {
                    <BridgeCallFailed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BridgeNotActive(_) => {
                    <BridgeNotActive as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ExcessiveAmount(_) => {
                    <ExcessiveAmount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ReentrancyGuardReentrantCall(_) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SafeERC20FailedOperation(_) => {
                    <SafeERC20FailedOperation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UnauthorizedCaller(_) => {
                    <UnauthorizedCaller as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAddress(_) => {
                    <ZeroAddress as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAmount(_) => {
                    <ZeroAmount as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<MockBridgeProxyErrors>] = &[
                {
                    fn ZeroAmount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyErrors> {
                        <ZeroAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyErrors::ZeroAmount)
                    }
                    ZeroAmount
                },
                {
                    fn ReentrancyGuardReentrantCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyErrors> {
                        <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyErrors::ReentrancyGuardReentrantCall)
                    }
                    ReentrancyGuardReentrantCall
                },
                {
                    fn SafeERC20FailedOperation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyErrors> {
                        <SafeERC20FailedOperation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyErrors::SafeERC20FailedOperation)
                    }
                    SafeERC20FailedOperation
                },
                {
                    fn UnauthorizedCaller(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyErrors> {
                        <UnauthorizedCaller as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyErrors::UnauthorizedCaller)
                    }
                    UnauthorizedCaller
                },
                {
                    fn AccessControlBadConfirmation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyErrors> {
                        <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyErrors::AccessControlBadConfirmation)
                    }
                    AccessControlBadConfirmation
                },
                {
                    fn ExcessiveAmount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyErrors> {
                        <ExcessiveAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyErrors::ExcessiveAmount)
                    }
                    ExcessiveAmount
                },
                {
                    fn BridgeNotActive(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyErrors> {
                        <BridgeNotActive as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyErrors::BridgeNotActive)
                    }
                    BridgeNotActive
                },
                {
                    fn BridgeCallFailed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyErrors> {
                        <BridgeCallFailed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyErrors::BridgeCallFailed)
                    }
                    BridgeCallFailed
                },
                {
                    fn ZeroAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyErrors> {
                        <ZeroAddress as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyErrors::ZeroAddress)
                    }
                    ZeroAddress
                },
                {
                    fn AccessControlUnauthorizedAccount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeProxyErrors> {
                        <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeProxyErrors::AccessControlUnauthorizedAccount)
                    }
                    AccessControlUnauthorizedAccount
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BridgeCallFailed(inner) => {
                    <BridgeCallFailed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BridgeNotActive(inner) => {
                    <BridgeNotActive as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ExcessiveAmount(inner) => {
                    <ExcessiveAmount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ReentrancyGuardReentrantCall(inner) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SafeERC20FailedOperation(inner) => {
                    <SafeERC20FailedOperation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UnauthorizedCaller(inner) => {
                    <UnauthorizedCaller as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ZeroAmount(inner) => {
                    <ZeroAmount as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BridgeCallFailed(inner) => {
                    <BridgeCallFailed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BridgeNotActive(inner) => {
                    <BridgeNotActive as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ExcessiveAmount(inner) => {
                    <ExcessiveAmount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ReentrancyGuardReentrantCall(inner) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SafeERC20FailedOperation(inner) => {
                    <SafeERC20FailedOperation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UnauthorizedCaller(inner) => {
                    <UnauthorizedCaller as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAmount(inner) => {
                    <ZeroAmount as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
            }
        }
    }
    ///Container for all the [`MockBridgeProxy`](self) events.
    pub enum MockBridgeProxyEvents {
        #[allow(missing_docs)]
        BridgeExecuted(BridgeExecuted),
        #[allow(missing_docs)]
        BridgeStatusUpdated(BridgeStatusUpdated),
        #[allow(missing_docs)]
        BridgeTargetUpdated(BridgeTargetUpdated),
        #[allow(missing_docs)]
        DailyLimitReset(DailyLimitReset),
        #[allow(missing_docs)]
        DailyLimitUpdated(DailyLimitUpdated),
        #[allow(missing_docs)]
        RoleAdminChanged(RoleAdminChanged),
        #[allow(missing_docs)]
        RoleGranted(RoleGranted),
        #[allow(missing_docs)]
        RoleRevoked(RoleRevoked),
    }
    #[automatically_derived]
    impl MockBridgeProxyEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                32u8,
                124u8,
                76u8,
                189u8,
                245u8,
                94u8,
                195u8,
                21u8,
                161u8,
                63u8,
                13u8,
                94u8,
                4u8,
                119u8,
                50u8,
                236u8,
                93u8,
                148u8,
                125u8,
                160u8,
                86u8,
                231u8,
                6u8,
                89u8,
                58u8,
                165u8,
                9u8,
                144u8,
                153u8,
                65u8,
                206u8,
                223u8,
            ],
            [
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ],
            [
                61u8,
                186u8,
                64u8,
                29u8,
                193u8,
                171u8,
                191u8,
                1u8,
                112u8,
                134u8,
                134u8,
                75u8,
                51u8,
                186u8,
                129u8,
                95u8,
                83u8,
                171u8,
                60u8,
                219u8,
                185u8,
                54u8,
                107u8,
                166u8,
                188u8,
                216u8,
                236u8,
                52u8,
                45u8,
                221u8,
                152u8,
                232u8,
            ],
            [
                176u8,
                127u8,
                139u8,
                27u8,
                133u8,
                4u8,
                45u8,
                116u8,
                2u8,
                44u8,
                134u8,
                124u8,
                131u8,
                110u8,
                222u8,
                176u8,
                188u8,
                215u8,
                14u8,
                19u8,
                91u8,
                0u8,
                66u8,
                57u8,
                13u8,
                43u8,
                31u8,
                209u8,
                8u8,
                41u8,
                128u8,
                105u8,
            ],
            [
                179u8,
                65u8,
                137u8,
                137u8,
                208u8,
                104u8,
                53u8,
                181u8,
                194u8,
                21u8,
                238u8,
                187u8,
                77u8,
                84u8,
                237u8,
                107u8,
                231u8,
                187u8,
                182u8,
                110u8,
                180u8,
                128u8,
                113u8,
                100u8,
                116u8,
                10u8,
                46u8,
                8u8,
                47u8,
                167u8,
                130u8,
                213u8,
            ],
            [
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ],
            [
                218u8,
                78u8,
                57u8,
                221u8,
                86u8,
                215u8,
                44u8,
                46u8,
                227u8,
                209u8,
                50u8,
                224u8,
                20u8,
                107u8,
                195u8,
                158u8,
                144u8,
                94u8,
                120u8,
                227u8,
                188u8,
                100u8,
                196u8,
                1u8,
                144u8,
                66u8,
                28u8,
                123u8,
                43u8,
                206u8,
                242u8,
                171u8,
            ],
            [
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for MockBridgeProxyEvents {
        const NAME: &'static str = "MockBridgeProxyEvents";
        const COUNT: usize = 8usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<BridgeExecuted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <BridgeExecuted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeExecuted)
                }
                Some(
                    <BridgeStatusUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BridgeStatusUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeStatusUpdated)
                }
                Some(
                    <BridgeTargetUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BridgeTargetUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeTargetUpdated)
                }
                Some(<DailyLimitReset as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <DailyLimitReset as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::DailyLimitReset)
                }
                Some(
                    <DailyLimitUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <DailyLimitUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::DailyLimitUpdated)
                }
                Some(<RoleAdminChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleAdminChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleAdminChanged)
                }
                Some(<RoleGranted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleGranted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleGranted)
                }
                Some(<RoleRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleRevoked)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for MockBridgeProxyEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::BridgeExecuted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeStatusUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeTargetUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DailyLimitReset(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DailyLimitUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::BridgeExecuted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeStatusUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeTargetUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DailyLimitReset(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DailyLimitUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`MockBridgeProxy`](self) contract instance.

See the [wrapper's documentation](`MockBridgeProxyInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> MockBridgeProxyInstance<T, P, N> {
        MockBridgeProxyInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        admin: alloy::sol_types::private::Address,
        caller: alloy::sol_types::private::Address,
        bridgeTarget: alloy::sol_types::private::Address,
        maxSingleTransfer: alloy::sol_types::private::primitives::aliases::U256,
        dailyLimit: alloy::sol_types::private::primitives::aliases::U256,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<MockBridgeProxyInstance<T, P, N>>,
    > {
        MockBridgeProxyInstance::<
            T,
            P,
            N,
        >::deploy(provider, admin, caller, bridgeTarget, maxSingleTransfer, dailyLimit)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        admin: alloy::sol_types::private::Address,
        caller: alloy::sol_types::private::Address,
        bridgeTarget: alloy::sol_types::private::Address,
        maxSingleTransfer: alloy::sol_types::private::primitives::aliases::U256,
        dailyLimit: alloy::sol_types::private::primitives::aliases::U256,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        MockBridgeProxyInstance::<
            T,
            P,
            N,
        >::deploy_builder(
            provider,
            admin,
            caller,
            bridgeTarget,
            maxSingleTransfer,
            dailyLimit,
        )
    }
    /**A [`MockBridgeProxy`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`MockBridgeProxy`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct MockBridgeProxyInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for MockBridgeProxyInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("MockBridgeProxyInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MockBridgeProxyInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`MockBridgeProxy`](self) contract instance.

See the [wrapper's documentation](`MockBridgeProxyInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            admin: alloy::sol_types::private::Address,
            caller: alloy::sol_types::private::Address,
            bridgeTarget: alloy::sol_types::private::Address,
            maxSingleTransfer: alloy::sol_types::private::primitives::aliases::U256,
            dailyLimit: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::Result<MockBridgeProxyInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(
                provider,
                admin,
                caller,
                bridgeTarget,
                maxSingleTransfer,
                dailyLimit,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            admin: alloy::sol_types::private::Address,
            caller: alloy::sol_types::private::Address,
            bridgeTarget: alloy::sol_types::private::Address,
            maxSingleTransfer: alloy::sol_types::private::primitives::aliases::U256,
            dailyLimit: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            admin,
                            caller,
                            bridgeTarget,
                            maxSingleTransfer,
                            dailyLimit,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> MockBridgeProxyInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> MockBridgeProxyInstance<T, P, N> {
            MockBridgeProxyInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MockBridgeProxyInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`BRIDGE_ADMIN_ROLE`] function.
        pub fn BRIDGE_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, BRIDGE_ADMIN_ROLECall, N> {
            self.call_builder(&BRIDGE_ADMIN_ROLECall {})
        }
        ///Creates a new call builder for the [`BRIDGE_CALLER_ROLE`] function.
        pub fn BRIDGE_CALLER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, BRIDGE_CALLER_ROLECall, N> {
            self.call_builder(&BRIDGE_CALLER_ROLECall {})
        }
        ///Creates a new call builder for the [`DEFAULT_ADMIN_ROLE`] function.
        pub fn DEFAULT_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, DEFAULT_ADMIN_ROLECall, N> {
            self.call_builder(&DEFAULT_ADMIN_ROLECall {})
        }
        ///Creates a new call builder for the [`bridgeActive`] function.
        pub fn bridgeActive(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeActiveCall, N> {
            self.call_builder(&bridgeActiveCall {})
        }
        ///Creates a new call builder for the [`bridgeName`] function.
        pub fn bridgeName(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeNameCall, N> {
            self.call_builder(&bridgeNameCall {})
        }
        ///Creates a new call builder for the [`bridgeTarget`] function.
        pub fn bridgeTarget(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeTargetCall, N> {
            self.call_builder(&bridgeTargetCall {})
        }
        ///Creates a new call builder for the [`dailyLimit`] function.
        pub fn dailyLimit(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, dailyLimitCall, N> {
            self.call_builder(&dailyLimitCall {})
        }
        ///Creates a new call builder for the [`dailyUsed`] function.
        pub fn dailyUsed(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, dailyUsedCall, N> {
            self.call_builder(&dailyUsedCall {})
        }
        ///Creates a new call builder for the [`executeBridge`] function.
        pub fn executeBridge(
            &self,
            token: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
            dynamicData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, executeBridgeCall, N> {
            self.call_builder(
                &executeBridgeCall {
                    token,
                    amount,
                    dynamicData,
                },
            )
        }
        ///Creates a new call builder for the [`getBridgeInfo`] function.
        pub fn getBridgeInfo(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBridgeInfoCall, N> {
            self.call_builder(&getBridgeInfoCall {})
        }
        ///Creates a new call builder for the [`getDailyUsage`] function.
        pub fn getDailyUsage(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getDailyUsageCall, N> {
            self.call_builder(&getDailyUsageCall {})
        }
        ///Creates a new call builder for the [`getRoleAdmin`] function.
        pub fn getRoleAdmin(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRoleAdminCall, N> {
            self.call_builder(&getRoleAdminCall { role })
        }
        ///Creates a new call builder for the [`grantRole`] function.
        pub fn grantRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, grantRoleCall, N> {
            self.call_builder(&grantRoleCall { role, account })
        }
        ///Creates a new call builder for the [`hasRole`] function.
        pub fn hasRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, hasRoleCall, N> {
            self.call_builder(&hasRoleCall { role, account })
        }
        ///Creates a new call builder for the [`lastExecutedAmount`] function.
        pub fn lastExecutedAmount(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, lastExecutedAmountCall, N> {
            self.call_builder(&lastExecutedAmountCall {})
        }
        ///Creates a new call builder for the [`lastExecutedData`] function.
        pub fn lastExecutedData(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, lastExecutedDataCall, N> {
            self.call_builder(&lastExecutedDataCall {})
        }
        ///Creates a new call builder for the [`lastExecutedToken`] function.
        pub fn lastExecutedToken(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, lastExecutedTokenCall, N> {
            self.call_builder(&lastExecutedTokenCall {})
        }
        ///Creates a new call builder for the [`lastResetDay`] function.
        pub fn lastResetDay(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, lastResetDayCall, N> {
            self.call_builder(&lastResetDayCall {})
        }
        ///Creates a new call builder for the [`maxSingleTransfer`] function.
        pub fn maxSingleTransfer(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, maxSingleTransferCall, N> {
            self.call_builder(&maxSingleTransferCall {})
        }
        ///Creates a new call builder for the [`recoverTokens`] function.
        pub fn recoverTokens(
            &self,
            token: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
            to: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, recoverTokensCall, N> {
            self.call_builder(
                &recoverTokensCall {
                    token,
                    amount,
                    to,
                },
            )
        }
        ///Creates a new call builder for the [`renounceRole`] function.
        pub fn renounceRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            callerConfirmation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceRoleCall, N> {
            self.call_builder(
                &renounceRoleCall {
                    role,
                    callerConfirmation,
                },
            )
        }
        ///Creates a new call builder for the [`revokeRole`] function.
        pub fn revokeRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, revokeRoleCall, N> {
            self.call_builder(&revokeRoleCall { role, account })
        }
        ///Creates a new call builder for the [`setBridgeActive`] function.
        pub fn setBridgeActive(
            &self,
            active: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBridgeActiveCall, N> {
            self.call_builder(&setBridgeActiveCall { active })
        }
        ///Creates a new call builder for the [`setBridgeTarget`] function.
        pub fn setBridgeTarget(
            &self,
            target: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBridgeTargetCall, N> {
            self.call_builder(&setBridgeTargetCall { target })
        }
        ///Creates a new call builder for the [`setDailyLimit`] function.
        pub fn setDailyLimit(
            &self,
            limit: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, setDailyLimitCall, N> {
            self.call_builder(&setDailyLimitCall { limit })
        }
        ///Creates a new call builder for the [`setMaxSingleTransfer`] function.
        pub fn setMaxSingleTransfer(
            &self,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, setMaxSingleTransferCall, N> {
            self.call_builder(&setMaxSingleTransferCall { amount })
        }
        ///Creates a new call builder for the [`setShouldRevert`] function.
        pub fn setShouldRevert(
            &self,
            _shouldRevert: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, setShouldRevertCall, N> {
            self.call_builder(
                &setShouldRevertCall {
                    _shouldRevert,
                },
            )
        }
        ///Creates a new call builder for the [`shouldRevert`] function.
        pub fn shouldRevert(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, shouldRevertCall, N> {
            self.call_builder(&shouldRevertCall {})
        }
        ///Creates a new call builder for the [`supportsInterface`] function.
        pub fn supportsInterface(
            &self,
            interfaceId: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<T, &P, supportsInterfaceCall, N> {
            self.call_builder(
                &supportsInterfaceCall {
                    interfaceId,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MockBridgeProxyInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`BridgeExecuted`] event.
        pub fn BridgeExecuted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeExecuted, N> {
            self.event_filter::<BridgeExecuted>()
        }
        ///Creates a new event filter for the [`BridgeStatusUpdated`] event.
        pub fn BridgeStatusUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeStatusUpdated, N> {
            self.event_filter::<BridgeStatusUpdated>()
        }
        ///Creates a new event filter for the [`BridgeTargetUpdated`] event.
        pub fn BridgeTargetUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeTargetUpdated, N> {
            self.event_filter::<BridgeTargetUpdated>()
        }
        ///Creates a new event filter for the [`DailyLimitReset`] event.
        pub fn DailyLimitReset_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, DailyLimitReset, N> {
            self.event_filter::<DailyLimitReset>()
        }
        ///Creates a new event filter for the [`DailyLimitUpdated`] event.
        pub fn DailyLimitUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, DailyLimitUpdated, N> {
            self.event_filter::<DailyLimitUpdated>()
        }
        ///Creates a new event filter for the [`RoleAdminChanged`] event.
        pub fn RoleAdminChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleAdminChanged, N> {
            self.event_filter::<RoleAdminChanged>()
        }
        ///Creates a new event filter for the [`RoleGranted`] event.
        pub fn RoleGranted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleGranted, N> {
            self.event_filter::<RoleGranted>()
        }
        ///Creates a new event filter for the [`RoleRevoked`] event.
        pub fn RoleRevoked_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleRevoked, N> {
            self.event_filter::<RoleRevoked>()
        }
    }
}
