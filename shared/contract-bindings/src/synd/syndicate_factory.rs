/**

Generated by the following Solidity interface...
```solidity
interface SyndicateFactory {
    type NamespaceState is uint8;

    error AccessControlBadConfirmation();
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
    error CannotRemoveDefaultImplementation();
    error ChainIdAlreadyExists();
    error Create2EmptyBytecode();
    error EnforcedPause();
    error ExpectedPause();
    error FailedDeployment();
    error FailedToUpgradeToLatestImplementation();
    error ImplementationAlreadyAllowed();
    error ImplementationNotAllowed();
    error InsufficientBalance(uint256 balance, uint256 needed);
    error OnlyChainCanNotifyUpgrade();
    error StringsInvalidChar();
    error ZeroAddress();

    event ChainBannedFromGasTracking(uint256 indexed chainId, address indexed notAllowedImplementation);
    event ChainIdManuallyMarked(uint256 indexed chainId);
    event ImplementationAdded(address indexed implementation);
    event NamespaceConfigUpdated(uint256 oldNamespacePrefix, uint256 newNamespacePrefix);
    event Paused(address account);
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
    event SyndicateSequencingChainCreated(uint256 indexed appchainId, address indexed sequencingChainAddress, address indexed permissionModuleAddress);
    event Unpaused(address account);

    constructor(address admin);

    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
    function MANAGER_ROLE() external view returns (bytes32);
    function addAllowedImplementation(address implementation, bool makeDefault) external;
    function allowedImplementations(uint256) external view returns (address);
    function appchainContracts(uint256) external view returns (address);
    function banChainFromGasTracking(uint256 chainId, address notAllowedImplementation) external;
    function chainIDs(uint256) external view returns (uint256);
    function computeSequencingChainAddress(uint256 chainId) external view returns (address);
    function computeStubImplementationAddress() external view returns (address);
    function createSyndicateSequencingChain(uint256 appchainId, address admin, address permissionModule) external returns (address sequencingChain, uint256 actualChainId);
    function gasTrackingBanlist(uint256) external view returns (bool);
    function getAllowedImplementations() external view returns (address[] memory);
    function getAppchainsAndContractsForGasTracking() external view returns (uint256[] memory _chainIDs, address[] memory _contracts);
    function getContractsForGasTracking(uint256[] memory _chainIDs) external view returns (address[] memory _contracts);
    function getImplBytecode(address impl) external pure returns (bytes memory);
    function getNextChainId() external view returns (uint256);
    function getProxyBytecode() external view returns (bytes memory);
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function getTotalAppchainsForGasTracking() external view returns (uint256);
    function grantRole(bytes32 role, address account) external;
    function hasRole(bytes32 role, address account) external view returns (bool);
    function isChainBannedFromGasTracking(uint256 chainId) external view returns (bool);
    function isChainIdUsed(uint256 chainId) external view returns (bool);
    function isImplementationAllowed(address) external view returns (bool);
    function namespacePrefix() external view returns (uint256);
    function nextAutoChainId() external view returns (uint256);
    function notifyChainUpgrade(uint256 chainId, address newImplementation) external;
    function numberOfChainsBannedFromGasTracking() external view returns (uint256);
    function pause() external;
    function paused() external view returns (bool);
    function removeAllowedImplementation(address implementation) external;
    function renounceRole(bytes32 role, address callerConfirmation) external;
    function revokeRole(bytes32 role, address account) external;
    function setDefaultImplementation(address implementation) external;
    function stubImplementation() external view returns (address);
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
    function syndicateChainImpl() external view returns (address);
    function unpause() external;
    function updateNamespaceConfig(uint256 newPrefix) external;
    function usedNamespaces(uint256) external view returns (NamespaceState);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "admin",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "DEFAULT_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "MANAGER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "addAllowedImplementation",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "makeDefault",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "allowedImplementations",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "appchainContracts",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "banChainFromGasTracking",
    "inputs": [
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "notAllowedImplementation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "chainIDs",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "computeSequencingChainAddress",
    "inputs": [
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "computeStubImplementationAddress",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "createSyndicateSequencingChain",
    "inputs": [
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "admin",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "permissionModule",
        "type": "address",
        "internalType": "contract IRequirementModule"
      }
    ],
    "outputs": [
      {
        "name": "sequencingChain",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "actualChainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "gasTrackingBanlist",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getAllowedImplementations",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getAppchainsAndContractsForGasTracking",
    "inputs": [],
    "outputs": [
      {
        "name": "_chainIDs",
        "type": "uint256[]",
        "internalType": "uint256[]"
      },
      {
        "name": "_contracts",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getContractsForGasTracking",
    "inputs": [
      {
        "name": "_chainIDs",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "outputs": [
      {
        "name": "_contracts",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getImplBytecode",
    "inputs": [
      {
        "name": "impl",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "getNextChainId",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getProxyBytecode",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleAdmin",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getTotalAppchainsForGasTracking",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "grantRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "hasRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isChainBannedFromGasTracking",
    "inputs": [
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isChainIdUsed",
    "inputs": [
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isImplementationAllowed",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "namespacePrefix",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "nextAutoChainId",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "notifyChainUpgrade",
    "inputs": [
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "newImplementation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "numberOfChainsBannedFromGasTracking",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "paused",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "removeAllowedImplementation",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "callerConfirmation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setDefaultImplementation",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "stubImplementation",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "syndicateChainImpl",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "unpause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateNamespaceConfig",
    "inputs": [
      {
        "name": "newPrefix",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "usedNamespaces",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "enum NamespaceState"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "event",
    "name": "ChainBannedFromGasTracking",
    "inputs": [
      {
        "name": "chainId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "notAllowedImplementation",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ChainIdManuallyMarked",
    "inputs": [
      {
        "name": "chainId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ImplementationAdded",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "NamespaceConfigUpdated",
    "inputs": [
      {
        "name": "oldNamespacePrefix",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "newNamespacePrefix",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Paused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleAdminChanged",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "previousAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleGranted",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleRevoked",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SyndicateSequencingChainCreated",
    "inputs": [
      {
        "name": "appchainId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "sequencingChainAddress",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "permissionModuleAddress",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Unpaused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AccessControlBadConfirmation",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AccessControlUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "neededRole",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "CannotRemoveDefaultImplementation",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ChainIdAlreadyExists",
    "inputs": []
  },
  {
    "type": "error",
    "name": "Create2EmptyBytecode",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EnforcedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ExpectedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FailedDeployment",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FailedToUpgradeToLatestImplementation",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ImplementationAlreadyAllowed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ImplementationNotAllowed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientBalance",
    "inputs": [
      {
        "name": "balance",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "needed",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "OnlyChainCanNotifyUpgrade",
    "inputs": []
  },
  {
    "type": "error",
    "name": "StringsInvalidChar",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroAddress",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod SyndicateFactory {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a0806040523461034d57602081615dda803803809161001f8285610351565b83398101031261034d57516001600160a01b03811680820361034d5760ff19600154166001551561033e578061005761005d92610374565b506103ea565b506101fe5f5260046020525f516020615d7a5f395f51905f525460ff16600381101561032a57600261009091141561047d565b6101fe5f5260046020525f516020615d7a5f395f51905f52805460ff191660011790556033805b6102e3577fd9e1239177bfbd2aebf5d0f20fc075e6df5a502c59d121acd57342c783e3136460406002546101fe60025581519081526101fe6020820152a1600160035561073560405161010d6020830182610351565b818152602081019161301183396101436020604051809482820194518091865e81015f838201520301601f198101845283610351565b8151156102d45790517053594e4449434154455f535455425f563160781b915ff53d15198115166102ba576001600160a01b038116156102c5576080526040516126148082016001600160401b038111838210176102a6578291613746833903905ff080156102ba57600780546001600160a01b0319166001600160a01b03929092169182179055600854680100000000000000008110156102a6576001810180600855811015610292577ff3f7a9fe364faab93b216da50a3214154f22a0a2b415b23a84c8169e8b636ee30180546001600160a01b0319169091179055600780546001600160a01b039081165f90815260096020526040808220805460ff191660011790559254925192909116907f331cedc71f28c46d467691770675b586e8aa77a0d4fe09f257d01ef00bc154589080a2612b4790816104ca82396080518181816112ba0152611b170152f35b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52604160045260245ffd5b6040513d5f823e3d90fd5b63b06ebf3d60e01b5f5260045ffd5b631328927760e21b5f5260045ffd5b805f52600460205260ff60405f20541690600382101561032a5761030c6001600a93141561047d565b805f52600460205260405f20600260ff1982541617905504806100b7565b634e487b7160e01b5f52602160045260245ffd5b63d92e233d60e01b5f5260045ffd5b5f80fd5b601f909101601f19168101906001600160401b038211908210176102a657604052565b6001600160a01b0381165f9081525f516020615dba5f395f51905f52602052604090205460ff166103e5576001600160a01b03165f8181525f516020615dba5f395f51905f5260205260408120805460ff191660011790553391905f516020615d5a5f395f51905f528180a4600190565b505f90565b6001600160a01b0381165f9081525f516020615d9a5f395f51905f52602052604090205460ff166103e5576001600160a01b03165f8181525f516020615d9a5f395f51905f5260205260408120805460ff191660011790553391907f241ecf16d79d0f8dbfb92cbc07fe17840425976cf0667f022fe9877caa831b08905f516020615d5a5f395f51905f529080a4600190565b1561048457565b60405162461bcd60e51b815260206004820152601c60248201527f6e616d65737061636520636f6c6c6973696f6e206465746563746564000000006044820152606490fdfe6080806040526004361015610012575f80fd5b5f905f3560e01c908162b68a73146118465750806301ffc9a7146117a557806307a9bee7146116db57806309d23e24146116a35780630d4b4bda146116595780631d1ab15a14611539578063248a9ca31461150f578063297f4c64146114f25780632f2ff15d146114b55780633144e8531461146757806332ed6805146113c957806336568abe1461135d5780633f4ba83a146112de57806356dba7791461128e5780635bd6588b146111455780635c975abb146111235780636389f8da146110c757806367a5fb2c14610cce5780636ae7e70314610cac5780636ff6f6c014610c6c5780637232c13314610c2a5780637c16ffc414610bb15780638456cb5914610b575780638b35ba2514610aeb5780638c39aaa4146108b25780638de6e28c1461088f57806391d1485414610838578063999d71d41461081a5780639e15d6ff14610631578063a217fddf146107fe578063aae7238c146106e2578063b416663e146106c6578063b963ebf314610660578063c112ee8c14610631578063ca4cd02514610578578063d547741f14610531578063ec87621c146104f6578063ee5ee73c14610423578063eeeb44ad1461020b5763ff76aed6146101d5575f80fd5b34610208578060031936011261020857602073ffffffffffffffffffffffffffffffffffffffff60075416604051908152f35b80fd5b50346102085760206003193601126102085773ffffffffffffffffffffffffffffffffffffffff61023a611883565b610242611bd3565b16808252600960205260ff604083205416156103fb5773ffffffffffffffffffffffffffffffffffffffff6007541681146103d357815b600854808210156103cc578273ffffffffffffffffffffffffffffffffffffffff6102a3846118eb565b90549060031b1c16146102b95750600101610279565b5f19810190811161039f57906102f773ffffffffffffffffffffffffffffffffffffffff6102e9610323946118eb565b90549060031b1c16916118eb565b90919073ffffffffffffffffffffffffffffffffffffffff8084549260031b9316831b921b1916179055565b6008548015610372575f1901610338816118eb565b73ffffffffffffffffffffffffffffffffffffffff82549160031b1b191690556008555b815260096020526040812060ff19815416905580f35b6024837f4e487b710000000000000000000000000000000000000000000000000000000081526031600452fd5b6024847f4e487b710000000000000000000000000000000000000000000000000000000081526011600452fd5b505061035c565b6004827fd5cc4a0f000000000000000000000000000000000000000000000000000000008152fd5b6004827ffb101809000000000000000000000000000000000000000000000000000000008152fd5b5034610208576020600319360112610208576104f2906104de610444611883565b6102729260206040519261045a8287018561194c565b858452818401956121a087396040516104af816104a1858201948573ffffffffffffffffffffffffffffffffffffffff606092168152604060208201525f60408201520190565b03601f19810183528261194c565b6040519687955180918588015e85019083820190858252519283915e010190815203601f19810183528261194c565b604051918291602083526020830190611987565b0390f35b503461020857806003193601126102085760206040517f241ecf16d79d0f8dbfb92cbc07fe17840425976cf0667f022fe9877caa831b088152f35b503461020857604060031936011261020857610574600435610551611860565b9061056f61056a825f525f602052600160405f20015490565b611c3b565b611d55565b5080f35b503461020857806003193601126102085773ffffffffffffffffffffffffffffffffffffffff6055600b602093610735604051906105b88782018361194c565b8082528682019061241282396105ec87604051809382820195518091875e810186838201520301601f19810183528261194c565b51902090506040519060408201527f53594e4449434154455f535455425f5631000000000000000000000000000000858201523081520160ff81532016604051908152f35b50346102085760206003193601126102085760ff60406020926004358152600a84522054166040519015158152f35b5034610208576020600319360112610208576004358152600460205260ff60408220541660405190600381101561069957602092508152f35b6024837f4e487b710000000000000000000000000000000000000000000000000000000081526021600452fd5b50346102085780600319360112610208576104f26104de611ae2565b50346102085760206003193601126102085760043567ffffffffffffffff81116107fa57366023820112156107fa578060040135906107208261196f565b9161072e604051938461194c565b8083526024602084019160051b830101913683116107f657602401905b8282106107e65750505061075f81516119e6565b825b82518110156107d0578061077760019285611a17565b518552600a60205260ff60408620541615610793575b01610761565b61079d8185611a17565b518552600560205273ffffffffffffffffffffffffffffffffffffffff6040862054166107ca8285611a17565b5261078d565b604051602080825281906104f290820185611903565b813581526020918201910161074b565b8480fd5b5080fd5b5034610208578060031936011261020857602090604051908152f35b50346102085780600319360112610208576020600354604051908152f35b50346102085760406003193601126102085773ffffffffffffffffffffffffffffffffffffffff6040610869611860565b926004358152806020522091165f52602052602060ff60405f2054166040519015158152f35b503461020857806003193601126102085760206108aa611a55565b604051908152f35b5034610208576020600319360112610208576004357f241ecf16d79d0f8dbfb92cbc07fe17840425976cf0667f022fe9877caa831b088252816020526040822073ffffffffffffffffffffffffffffffffffffffff33165f5260205260ff60405f20541615610a9b578015610a1757808252600460205260ff6040832054166003811015610699576002610947911415611e33565b808252600460205260408220600160ff19825416179055600a8104805b6109a3575060407fd9e1239177bfbd2aebf5d0f20fc075e6df5a502c59d121acd57342c783e3136491600254908060025582519182526020820152a180f35b808352600460205260ff60408420541660038110156109ea57906109cc6001600a931415611e33565b808452600460205260408420600260ff198254161790550480610964565b6024847f4e487b710000000000000000000000000000000000000000000000000000000081526021600452fd5b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f6e616d65737061636520707265666978206f66203020697320666f726269646460448201527f656e0000000000000000000000000000000000000000000000000000000000006064820152fd5b6044827fe2517d3f000000000000000000000000000000000000000000000000000000008152336004527f241ecf16d79d0f8dbfb92cbc07fe17840425976cf0667f022fe9877caa831b08602452fd5b50346102085760406003193601126102085760043573ffffffffffffffffffffffffffffffffffffffff610b1d611860565b610b25611bd3565b610b2e83611b95565b16907febb4c50deb285192d1c2aa8832b1feeb078ba0fd92bb439c0dee28ebe9bb36e98380a380f35b5034610208578060031936011261020857610b70611bd3565b610b78611dff565b600160ff19815416176001557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586020604051338152a180f35b50346102085760206003193601126102085773ffffffffffffffffffffffffffffffffffffffff610be0611883565b610be8611bd3565b16808252600960205260ff604083205416156103fb577fffffffffffffffffffffffff0000000000000000000000000000000000000000600754161760075580f35b50346102085760206003193601126102085773ffffffffffffffffffffffffffffffffffffffff60406020926004358152600584522054161515604051908152f35b50346102085760206003193601126102085773ffffffffffffffffffffffffffffffffffffffff6040602092600435815260058452205416604051908152f35b503461020857806003193601126102085760206108aa600654600b54906119ac565b5034610fa8576060600319360112610fa85760043590610cec611860565b916044359273ffffffffffffffffffffffffffffffffffffffff8416809403610fa85773ffffffffffffffffffffffffffffffffffffffff90610d2d611dff565b1692831580156110bf575b6110975781159182156110915750610d4e611a55565b915b825f52600560205273ffffffffffffffffffffffffffffffffffffffff60405f20541661106957611056575b610d84611ae2565b80511561102e57805183916020015ff5903d1519821516610f9d5773ffffffffffffffffffffffffffffffffffffffff821691821561100657835f52600560205260405f20837fffffffffffffffffffffffff000000000000000000000000000000000000000082541617905560065468010000000000000000811015610fd9575f91610e188260018594016006556118a6565b81549060031b905f1989831b921b19161790556040517f1794bb3c00000000000000000000000000000000000000000000000000000000602082015230602482015284604482015286606482015260648152610e7560848261194c565b826104a1610eda73ffffffffffffffffffffffffffffffffffffffff600754169360405192839160208301967f4f1ef2860000000000000000000000000000000000000000000000000000000088526024840152604060448401526064830190611987565b51925af13d15610fd4573d610eee81611a39565b90610efc604051928361194c565b81525f60203d92013e5b15610fac57813b15610fa857604051947ff2fde38b00000000000000000000000000000000000000000000000000000000865260048601525f8560248183865af1948515610f9d57604095610f88575b5081837f49b21f1e4190db8b0a933c951ed013de222c847c15461754682daa2eab1fdbd287519680a482526020820152f35b610f959194505f9061194c565b5f925f610f56565b6040513d5f823e3d90fd5b5f80fd5b7fab6eb5bc000000000000000000000000000000000000000000000000000000005f5260045ffd5b610f06565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7fb06ebf3d000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f4ca249dc000000000000000000000000000000000000000000000000000000005f5260045ffd5b611061600354611a2b565b600355610d7c565b7f24591d89000000000000000000000000000000000000000000000000000000005f5260045ffd5b91610d50565b7fd92e233d000000000000000000000000000000000000000000000000000000005f5260045ffd5b508015610d38565b34610fa8576020600319360112610fa857602073ffffffffffffffffffffffffffffffffffffffff6055600b6110fb611ae2565b848151910120604051906040820152600435858201523081520160ff81532016604051908152f35b34610fa8575f600319360112610fa857602060ff600154166040519015158152f35b34610fa8575f600319360112610fa857600654611164600b54826119ac565b9061116e8261196f565b9061117c604051928361194c565b82825261119d61118b8461196f565b93601f196020850195013686376119e6565b905f5f5b8281106111f55750505060405191604083019060408452518091526060830193905f5b8181106111df5784806104f288878382036020850152611903565b82518652602095860195909201916001016111c4565b6111fe816118a6565b90549060031b1c5f52600a60205260ff60405f20541615611222575b6001016111a1565b90611286600191611232846118a6565b90549060031b1c6112438289611a17565b5261124d846118a6565b90549060031b1c5f52600560205273ffffffffffffffffffffffffffffffffffffffff60405f2054166112808288611a17565b52611a2b565b91905061121a565b34610fa8575f600319360112610fa857602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b34610fa8575f600319360112610fa8576112f6611bd3565b60015460ff8116156113355760ff19166001557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa6020604051338152a1005b7f8dfc202b000000000000000000000000000000000000000000000000000000005f5260045ffd5b34610fa8576040600319360112610fa857611376611860565b3373ffffffffffffffffffffffffffffffffffffffff8216036113a15761139f90600435611d55565b005b7f6697b232000000000000000000000000000000000000000000000000000000005f5260045ffd5b34610fa8575f600319360112610fa85760405180602060085491828152019060085f527ff3f7a9fe364faab93b216da50a3214154f22a0a2b415b23a84c8169e8b636ee3905f5b81811061143b576104f2856114278187038261194c565b604051918291602083526020830190611903565b825473ffffffffffffffffffffffffffffffffffffffff16845260209093019260019283019201611410565b34610fa8576020600319360112610fa857600435600854811015610fa85773ffffffffffffffffffffffffffffffffffffffff6114a56020926118eb565b90549060031b1c16604051908152f35b34610fa8576040600319360112610fa85761139f6004356114d4611860565b906114ed61056a825f525f602052600160405f20015490565b611ca1565b34610fa8575f600319360112610fa8576020600254604051908152f35b34610fa8576020600319360112610fa85760206108aa6004355f525f602052600160405f20015490565b34610fa8576040600319360112610fa857611552611883565b6024358015158103610fa857611566611bd3565b73ffffffffffffffffffffffffffffffffffffffff821691821561109757825f52600960205260ff60405f205416611631576008549068010000000000000000821015610fd9576102f78260016115c094016008556118eb565b815f52600960205260405f20600160ff19825416179055611602575b7f331cedc71f28c46d467691770675b586e8aa77a0d4fe09f257d01ef00bc154585f80a2005b807fffffffffffffffffffffffff000000000000000000000000000000000000000060075416176007556115dc565b7f1833a24b000000000000000000000000000000000000000000000000000000005f5260045ffd5b34610fa8576020600319360112610fa85773ffffffffffffffffffffffffffffffffffffffff611687611883565b165f526009602052602060ff60405f2054166040519015158152f35b34610fa8576020600319360112610fa857600435600654811015610fa8576116cc6020916118a6565b90549060031b1c604051908152f35b34610fa8576040600319360112610fa8576004356116f7611860565b815f52600560205273ffffffffffffffffffffffffffffffffffffffff60405f205416330361177d5773ffffffffffffffffffffffffffffffffffffffff1690815f52600960205260ff60405f2054161561174e57005b61175781611b95565b7febb4c50deb285192d1c2aa8832b1feeb078ba0fd92bb439c0dee28ebe9bb36e95f80a3005b7f2fd9adae000000000000000000000000000000000000000000000000000000005f5260045ffd5b34610fa8576020600319360112610fa8576004357fffffffff000000000000000000000000000000000000000000000000000000008116809103610fa857807f7965db0b000000000000000000000000000000000000000000000000000000006020921490811561181c575b506040519015158152f35b7f01ffc9a70000000000000000000000000000000000000000000000000000000091501482611811565b34610fa8575f600319360112610fa857602090600b548152f35b6024359073ffffffffffffffffffffffffffffffffffffffff82168203610fa857565b6004359073ffffffffffffffffffffffffffffffffffffffff82168203610fa857565b6006548110156118be5760065f5260205f2001905f90565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b6008548110156118be5760085f5260205f2001905f90565b90602080835192838152019201905f5b8181106119205750505090565b825173ffffffffffffffffffffffffffffffffffffffff16845260209384019390920191600101611913565b90601f601f19910116810190811067ffffffffffffffff821117610fd957604052565b67ffffffffffffffff8111610fd95760051b60200190565b90601f19601f602080948051918291828752018686015e5f8582860101520116010190565b919082039182116119b957565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b906119f08261196f565b6119fd604051918261194c565b828152601f19611a0d829461196f565b0190602036910137565b80518210156118be5760209160051b010190565b5f1981146119b95760010190565b67ffffffffffffffff8111610fd957601f01601f191660200190565b611ab16020611aa9611a68600254611e98565b8280611a75600354611e98565b6040519584879551918291018487015e8401908282015f8152815193849201905e01015f815203601f19810183528261194c565b80519061201d565b9015611aba5790565b7f94e2737e000000000000000000000000000000000000000000000000000000005f5260045ffd5b610272611b92604051611af8602084018261194c565b82815260208101926121a08439602060405181810190611b63816104a17f00000000000000000000000000000000000000000000000000000000000000008573ffffffffffffffffffffffffffffffffffffffff606092168152604060208201525f60408201520190565b6040519586945180918587015e840190838201905f8252519283915e01015f815203601f19810183528261194c565b90565b805f52600a60205260ff60405f20541615611bad5750565b5f52600a60205260405f20600160ff19825416179055611bce600b54611a2b565b600b55565b335f9081527fad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5602052604090205460ff1615611c0b57565b7fe2517d3f000000000000000000000000000000000000000000000000000000005f52336004525f60245260445ffd5b805f525f60205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260ff60405f20541615611c725750565b7fe2517d3f000000000000000000000000000000000000000000000000000000005f523360045260245260445ffd5b805f525f60205260405f2073ffffffffffffffffffffffffffffffffffffffff83165f5260205260ff60405f205416155f14611d4f57805f525f60205260405f2073ffffffffffffffffffffffffffffffffffffffff83165f5260205260405f20600160ff1982541617905573ffffffffffffffffffffffffffffffffffffffff339216907f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d5f80a4600190565b50505f90565b805f525f60205260405f2073ffffffffffffffffffffffffffffffffffffffff83165f5260205260ff60405f2054165f14611d4f57805f525f60205260405f2073ffffffffffffffffffffffffffffffffffffffff83165f5260205260405f2060ff19815416905573ffffffffffffffffffffffffffffffffffffffff339216907ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b5f80a4600190565b60ff60015416611e0b57565b7fd93c0665000000000000000000000000000000000000000000000000000000005f5260045ffd5b15611e3a57565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f6e616d65737061636520636f6c6c6973696f6e206465746563746564000000006044820152fd5b805f917a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000821015611ff5575b806d04ee2d6d415b85acef8100000000600a921015611fda575b662386f26fc10000811015611fc6575b6305f5e100811015611fb5575b612710811015611fa6575b6064811015611f98575b1015611f8d575b600a5f1960216001850194601f19611f42611f2c88611a39565b97611f3a604051998a61194c565b808952611a39565b013660208801378501015b01917f30313233343536373839616263646566000000000000000000000000000000008282061a8353048015611f88575f19600a9192611f4d565b505090565b600190910190611f12565b606460029104930192611f0b565b61271060049104930192611f01565b6305f5e10060089104930192611ef6565b662386f26fc1000060109104930192611ee9565b6d04ee2d6d415b85acef810000000060209104930192611ed9565b50604091507a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008104611ebf565b90815181118015612043575b61203b575f6120379261204a565b9091565b50505f905f90565b505f612029565b5f9392905b81831061205f5750505060019190565b9092919360ff6120967fff0000000000000000000000000000000000000000000000000000000000000060208886010151166120d3565b16600981116120c857600a820291808304600a14901517156119b95781018091116119b957600190940191929061204f565b505f94508493505050565b60f81c602f811180612195575b1561210d577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd00160ff1690565b606081118061218b575b15612144577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa90160ff1690565b6040811180612181575b1561217b577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc90160ff1690565b5060ff90565b506047811061214e565b5060678110612117565b50603a81106120e056fe60806040526102728038038061001481610168565b92833981016040828203126101645781516001600160a01b03811692909190838303610164576020810151906001600160401b03821161016457019281601f8501121561016457835161006e610069826101a1565b610168565b9481865260208601936020838301011161016457815f926020809301865e86010152823b15610152577f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80546001600160a01b031916821790557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a282511561013a575f8091610122945190845af43d15610132573d91610113610069846101a1565b9283523d5f602085013e6101bc565b505b6040516057908161021b8239f35b6060916101bc565b50505034156101245763b398979f60e01b5f5260045ffd5b634c9c8ce360e01b5f5260045260245ffd5b5f80fd5b6040519190601f01601f191682016001600160401b0381118382101761018d57604052565b634e487b7160e01b5f52604160045260245ffd5b6001600160401b03811161018d57601f01601f191660200190565b906101e057508051156101d157805190602001fd5b63d6bda27560e01b5f5260045ffd5b81511580610211575b6101f1575090565b639996b31560e01b5f9081526001600160a01b0391909116600452602490fd5b50803b156101e956fe60806040525f8073ffffffffffffffffffffffffffffffffffffffff7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416368280378136915af43d5f803e156053573d5ff35b3d5ffd60a0806040523460295730608052610707908161002e82396080518181816101f001526103290152f35b5f80fdfe608060405260043610156100d0575b36156100725760646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f537475623a206e6f206c6f67696320696d706c656d656e7465640000000000006044820152fd5b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f537475623a20455448206e6f74206163636570746564000000000000000000006044820152fd5b5f3560e01c80634f1ef2861461026857806352d1902d146101ab5763ad3cb1cc0361000e57346101a7575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a757604080519061013281836105c6565b6005825260208201917f352e302e3000000000000000000000000000000000000000000000000000000083527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8351948593602085525180918160208701528686015e5f85828601015201168101030190f35b5f80fd5b346101a7575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a75773ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001630036102405760206040517f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8152f35b7fe07c8dba000000000000000000000000000000000000000000000000000000005f5260045ffd5b60407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a75760043573ffffffffffffffffffffffffffffffffffffffff8116908181036101a7576024359067ffffffffffffffff82116101a757366023830112156101a7578160040135916102e183610634565b926102ef60405194856105c6565b808452602084019136602483830101116101a757815f9260246020930185378501015273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016803014908115610584575b50610240576040517f52d1902d000000000000000000000000000000000000000000000000000000008152602081600481885afa5f9181610550575b506103c157847f4c9c8ce3000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b807f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8692036105255750823b156104fa57807fffffffffffffffffffffffff00000000000000000000000000000000000000007f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416177f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a28251156104c8575f80916104be945190845af43d156104c0573d916104a283610634565b926104b060405194856105c6565b83523d5f602085013e61066e565b005b60609161066e565b505050346104d257005b7fb398979f000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f4c9c8ce3000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b7faa1d49a4000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b9091506020813d60201161057c575b8161056c602093836105c6565b810103126101a757519086610390565b3d915061055f565b905073ffffffffffffffffffffffffffffffffffffffff7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416141585610354565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761060757604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b67ffffffffffffffff811161060757601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b906106ab575080511561068357805190602001fd5b7fd6bda275000000000000000000000000000000000000000000000000000000005f5260045ffd5b815115806106fe575b6106bc575090565b73ffffffffffffffffffffffffffffffffffffffff907f9996b315000000000000000000000000000000000000000000000000000000005f521660045260245ffd5b50803b156106b45660a0806040523460295730608052610707908161002e82396080518181816101f001526103290152f35b5f80fdfe608060405260043610156100d0575b36156100725760646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f537475623a206e6f206c6f67696320696d706c656d656e7465640000000000006044820152fd5b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f537475623a20455448206e6f74206163636570746564000000000000000000006044820152fd5b5f3560e01c80634f1ef2861461026857806352d1902d146101ab5763ad3cb1cc0361000e57346101a7575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a757604080519061013281836105c6565b6005825260208201917f352e302e3000000000000000000000000000000000000000000000000000000083527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8351948593602085525180918160208701528686015e5f85828601015201168101030190f35b5f80fd5b346101a7575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a75773ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001630036102405760206040517f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8152f35b7fe07c8dba000000000000000000000000000000000000000000000000000000005f5260045ffd5b60407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a75760043573ffffffffffffffffffffffffffffffffffffffff8116908181036101a7576024359067ffffffffffffffff82116101a757366023830112156101a7578160040135916102e183610634565b926102ef60405194856105c6565b808452602084019136602483830101116101a757815f9260246020930185378501015273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016803014908115610584575b50610240576040517f52d1902d000000000000000000000000000000000000000000000000000000008152602081600481885afa5f9181610550575b506103c157847f4c9c8ce3000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b807f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8692036105255750823b156104fa57807fffffffffffffffffffffffff00000000000000000000000000000000000000007f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416177f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a28251156104c8575f80916104be945190845af43d156104c0573d916104a283610634565b926104b060405194856105c6565b83523d5f602085013e61066e565b005b60609161066e565b505050346104d257005b7fb398979f000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f4c9c8ce3000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b7faa1d49a4000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b9091506020813d60201161057c575b8161056c602093836105c6565b810103126101a757519086610390565b3d915061055f565b905073ffffffffffffffffffffffffffffffffffffffff7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416141585610354565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761060757604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b67ffffffffffffffff811161060757601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b906106ab575080511561068357805190602001fd5b7fd6bda275000000000000000000000000000000000000000000000000000000005f5260045ffd5b815115806106fe575b6106bc575090565b73ffffffffffffffffffffffffffffffffffffffff907f9996b315000000000000000000000000000000000000000000000000000000005f521660045260245ffd5b50803b156106b45660a080604052346100c257306080525f5160206125f45f395f51905f525460ff8160401c166100b3576002600160401b03196001600160401b03821601610060575b60405161252d90816100c78239608051818181610cb70152610d7c0152f35b6001600160401b0319166001600160401b039081175f5160206125f45f395f51905f525581527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d290602090a15f80610041565b63f92ee8a960e01b5f5260045ffd5b5f80fdfe6080806040526004361015610012575f80fd5b5f905f3560e01c9081630175e23b14611790575080630c672363146117475780631794bb3c146113ee5780632407f0b6146113b4578063349db36b1461134357806339698ac01461124d57806346e2cc09146112115780634f1ef28614610d2f57806352d1902d14610c8f57806353c1411114610c545780635467cb4814610ba15780635b3cd6e214610b4e5780635df19e2a14610b095780635e7a7bdf14610ad55780636b30fcef14610a77578063715018a6146109b9578063781cd99d1461099a5780637a3979dc1461093f5780637a8d41c2146108ad57806384c577a91461083657806384fab62b146107f45780638da5cb5b146107a1578063a70b9f0c14610783578063ad3cb1cc1461071e578063b3c65015146106d7578063b9566f76146106b1578063b97dd9e21461068e578063b9f7f26014610653578063c45a01551461061f578063cdafb978146105bd578063ce665dd81461058e578063d1c27e0114610526578063d4f0eb4d1461045f578063d5176d2314610393578063d878134214610376578063de1f453e14610355578063e03961661461030b578063f2fde38b1461023e5763f958cba2146101cb575f80fd5b3461023b57602060031936011261023b57600435801515809103610239576101f16122e4565b7fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff74ff00000000000000000000000000000000000000006002549260a01b1691161760025580f35b505b80fd5b503461023b57602060031936011261023b5761028f61025b611859565b6102636122e4565b73ffffffffffffffffffffffffffffffffffffffff6001541615610292575b61028a6122e4565b612350565b80f35b73ffffffffffffffffffffffffffffffffffffffff7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300541673ffffffffffffffffffffffffffffffffffffffff8216907f16ae3179615a2815583b6566eae6f783b25419452c00599aeeb01088f13eca1a8580a3610282565b503461023b57602060031936011261023b576004355f527f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b14801602052602060405f2054604051908152f35b503461023b578060031936011261023b5761036e6122e4565b61028f6121e1565b503461023b578060031936011261023b5760209054604051908152f35b503461023b57602060031936011261023b5760043580156104375762278d00810290810462278d000361040a5763688d46f001908163688d46f0116103dd57602082604051908152f35b807f4e487b7100000000000000000000000000000000000000000000000000000000602492526011600452fd5b6024827f4e487b710000000000000000000000000000000000000000000000000000000081526011600452fd5b6004827fd69368d4000000000000000000000000000000000000000000000000000000008152fd5b503461023b57602060031936011261023b5773ffffffffffffffffffffffffffffffffffffffff61048e611859565b6104966122e4565b16807fffffffffffffffffffffffff00000000000000000000000000000000000000007f5c6d1774bdd69d8d16847c3c97b51ea7343257b8f5ace5da9e25ab3bafd7d5005416177f5c6d1774bdd69d8d16847c3c97b51ea7343257b8f5ace5da9e25ab3bafd7d500557f253580f806741c11b3d4aa60d9cacc5bef0cebb35748767fe23f11916e2f04b98280a280f35b503461023b57602060031936011261023b57602073ffffffffffffffffffffffffffffffffffffffff7310000000000000000000000000000000000000018161056d611859565b16011673ffffffffffffffffffffffffffffffffffffffff60405191168152f35b503461023b578060031936011261023b5760206040517310000000000000000000000000000000000000018152f35b503461023b57602060031936011261023b5760043567ffffffffffffffff8111610239573660238201121561023957806004013567ffffffffffffffff811161061b573660248260051b8401011161061b57602461028f9201612033565b8280fd5b503461023b578060031936011261023b57602073ffffffffffffffffffffffffffffffffffffffff60025416604051908152f35b503461023b578060031936011261023b5760206040517f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b148008152f35b503461023b578060031936011261023b5760206106a9611ff5565b604051908152f35b503461023b578060031936011261023b57602060ff60025460a01c166040519015158152f35b503461023b578060031936011261023b57602067ffffffffffffffff7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a005416604051908152f35b503461023b578060031936011261023b575061077f6040516107416040826118e4565b600581527f352e302e300000000000000000000000000000000000000000000000000000006020820152604051918291602083526020830190611996565b0390f35b503461023b578060031936011261023b57602060405162278d008152f35b503461023b578060031936011261023b57602073ffffffffffffffffffffffffffffffffffffffff7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c1993005416604051908152f35b503461023b578060031936011261023b57602060ff7f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b1480054166040519015158152f35b503461023b5760c060031936011261023b5761085061189f565b6064359073ffffffffffffffffffffffffffffffffffffffff8216820361061b5760a4359167ffffffffffffffff83116108a95761089561028f9336906004016118b6565b929091608435916044359060243590611ed6565b8380fd5b503461023b578060031936011261023b575060015473ffffffffffffffffffffffffffffffffffffffff16806109375750602073ffffffffffffffffffffffffffffffffffffffff7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c19930054165b73ffffffffffffffffffffffffffffffffffffffff60405191168152f35b602090610919565b503461023b57606060031936011261023b57610959611859565b9061096261187c565b906044359067ffffffffffffffff821161023b576020610990858561098a3660048801611950565b91611de6565b6040519015158152f35b503461023b578060031936011261023b57602060405163688d46f08152f35b503461023b578060031936011261023b576109d26122e4565b8073ffffffffffffffffffffffffffffffffffffffff7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300547fffffffffffffffffffffffff000000000000000000000000000000000000000081167f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c19930055167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b503461023b57602060031936011261023b57602073ffffffffffffffffffffffffffffffffffffffff7fffffffffffffffffffffffffefffffffffffffffffffffffffffffffffffffff81610aca611859565b160116604051908152f35b503461023b578060031936011261023b57602073ffffffffffffffffffffffffffffffffffffffff60015416604051908152f35b503461023b57602060031936011261023b57604060209173ffffffffffffffffffffffffffffffffffffffff610b3d611859565b168152600383522054604051908152f35b503461023b578060031936011261023b57602073ffffffffffffffffffffffffffffffffffffffff7f5c6d1774bdd69d8d16847c3c97b51ea7343257b8f5ace5da9e25ab3bafd7d5005416604051908152f35b503461023b578060031936011261023b57610bba6122e4565b7f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b148005460ff811615610c2c577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00167f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b148005580f35b6004827fcd60c3ca000000000000000000000000000000000000000000000000000000008152fd5b503461023b57602060031936011261023b5760043567ffffffffffffffff811161023957610c8961028f9136906004016118b6565b90611cba565b503461023b578060031936011261023b5773ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003610d075760206040517f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8152f35b807fe07c8dba0000000000000000000000000000000000000000000000000000000060049252fd5b5060406003193601126110df57610d44611859565b9060243567ffffffffffffffff81116110df57610d65903690600401611950565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168030149081156111cf575b506111a757610db46122e4565b6002549073ffffffffffffffffffffffffffffffffffffffff8216604051927f0d4b4bda00000000000000000000000000000000000000000000000000000000845273ffffffffffffffffffffffffffffffffffffffff861693846004820152602081602481865afa9081156110d4575f91611178575b50156110e3575b505f54813b156110df575f916044839260405194859384927f07a9bee700000000000000000000000000000000000000000000000000000000845260048401528860248401525af180156110d4576110bf575b50604051937f52d1902d000000000000000000000000000000000000000000000000000000008552602085600481865afa80958596611087575b50610ef057602484847f4c9c8ce3000000000000000000000000000000000000000000000000000000008252600452fd5b9091847f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc810361105c5750813b1561103157807fffffffffffffffffffffffff00000000000000000000000000000000000000007f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416177f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b8480a28151839015610ffe5780836020610ff295519101845af43d15610ff6573d91610fd683611934565b92610fe460405194856118e4565b83523d85602085013e612494565b5080f35b606091612494565b505050346110095780f35b807fb398979f0000000000000000000000000000000000000000000000000000000060049252fd5b7f4c9c8ce3000000000000000000000000000000000000000000000000000000008452600452602483fd5b7faa1d49a4000000000000000000000000000000000000000000000000000000008552600452602484fd5b9095506020813d6020116110b7575b816110a3602093836118e4565b810103126110b35751945f610ebf565b8480fd5b3d9150611096565b6110cc9193505f906118e4565b5f915f610e85565b6040513d5f823e3d90fd5b5f80fd5b60a01c60ff16156110f4575f610e32565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f5570677261646520776f756c6420726573756c7420696e20676173207472616360448201527f6b696e672062616e0000000000000000000000000000000000000000000000006064820152fd5b61119a915060203d6020116111a0575b61119281836118e4565b810190611dce565b5f610e2b565b503d611188565b7fe07c8dba000000000000000000000000000000000000000000000000000000005f5260045ffd5b905073ffffffffffffffffffffffffffffffffffffffff7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc541614155f610da7565b346110df5760206003193601126110df5760043567ffffffffffffffff81116110df5761124561124b9136906004016118b6565b90611ba9565b005b346110df5760206003193601126110df577fffffffffffffffffffffffff0000000000000000000000000000000000000000611287611859565b61128f6122e4565b60015473ffffffffffffffffffffffffffffffffffffffff808216921692839116176001558115155f146112e3577f16ae3179615a2815583b6566eae6f783b25419452c00599aeeb01088f13eca1a5f80a3005b7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c1993005473ffffffffffffffffffffffffffffffffffffffff1691507f16ae3179615a2815583b6566eae6f783b25419452c00599aeeb01088f13eca1a5f80a3005b346110df5760a06003193601126110df5761135c61189f565b6044359073ffffffffffffffffffffffffffffffffffffffff821682036110df576084359067ffffffffffffffff82116110df576020926113a46106a99336906004016118b6565b92909160643591602435906119c8565b346110df575f6003193601126110df5760206040517f5c6d1774bdd69d8d16847c3c97b51ea7343257b8f5ace5da9e25ab3bafd7d5008152f35b346110df5760606003193601126110df57611407611859565b61140f61187c565b90604435907ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00549260ff8460401c16159367ffffffffffffffff81168015908161173f575b6001149081611735575b15908161172c575b50611704578460017fffffffffffffffffffffffffffffffffffffffffffffffff00000000000000008316177ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00556116af575b508215611651576114f173ffffffffffffffffffffffffffffffffffffffff926114e161243d565b6114e961243d565b61028a61243d565b167fffffffffffffffffffffffff00000000000000000000000000000000000000007f5c6d1774bdd69d8d16847c3c97b51ea7343257b8f5ace5da9e25ab3bafd7d5005416177f5c6d1774bdd69d8d16847c3c97b51ea7343257b8f5ace5da9e25ab3bafd7d5005561156161243d565b6115696121e1565b5f556002547fffffffffffffffffffffff0000000000000000000000000000000000000000007fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff33169116176002556115be57005b7fffffffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffff7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0054167ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00557fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2602060405160018152a1005b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f41707020636861696e2049442063616e6e6f74206265203000000000000000006044820152fd5b7fffffffffffffffffffffffffffffffffffffffffffffff0000000000000000001668010000000000000001177ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0055846114b9565b7ff92ee8a9000000000000000000000000000000000000000000000000000000005f5260045ffd5b90501586611466565b303b15915061145e565b869150611454565b346110df5760206003193601126110df576004355f527f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b14801602052602060405f2054604051908152f35b346110df5760206003193601126110df576004358015611831577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81019081116118045762278d0081029080820462278d0014901517156118045763688d46f001908163688d46f011611804576020918152f35b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b7fd69368d4000000000000000000000000000000000000000000000000000000005f5260045ffd5b6004359073ffffffffffffffffffffffffffffffffffffffff821682036110df57565b6024359073ffffffffffffffffffffffffffffffffffffffff821682036110df57565b6004359067ffffffffffffffff821682036110df57565b9181601f840112156110df5782359167ffffffffffffffff83116110df57602083818601950101116110df57565b90601f601f19910116810190811067ffffffffffffffff82111761190757604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b67ffffffffffffffff811161190757601f01601f191660200190565b81601f820112156110df5780359061196782611934565b9261197560405194856118e4565b828452602083830101116110df57815f926020809301838601378301015290565b90601f19601f602080948051918291828752018686015e5f8582860101520116010190565b9190820391821161180457565b95949392919060ff7f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b14800541615611a1c5792611a0d92611a1a9592611a15955a99611a29565b935a906119bb565b612281565b565b611a269596611a29565b90565b9190335f52600360205260405f20958654967fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff88146118045760018801905560405195337310000000000000000000000000000000000000010173ffffffffffffffffffffffffffffffffffffffff1690611b339673ffffffffffffffffffffffffffffffffffffffff899660209667ffffffffffffffff60b59a8e7fffffffffffffffffffffffffffffffffffffffff0000000000000000000000008a998d8d600160f81b91015260601b1660218d015260358c01521660558a015260758901521660958701528686015260d58501378201018281015f8152500301601f1981018352826118e4565b611b3e813233611de6565b15611b81577f83363b78bdfbb23e2a61db7accc3c01fda29c5c5ec81888003cb962912618a7f6040516020815280611b7b33946020830190611996565b0390a290565b7fdc741458000000000000000000000000000000000000000000000000000000005f5260045ffd5b9060ff7f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b14800541615611bed57611a1a91611be6611a15925a92611bf2565b5a906119bb565b611a1a915b8115611c92576021611c4591836040519485927f040000000000000000000000000000000000000000000000000000000000000060208501528484013781015f838201520301601f1981018352826118e4565b611c50813233611de6565b15611b81577f83363b78bdfbb23e2a61db7accc3c01fda29c5c5ec81888003cb962912618a7f6040516020815280611c8d33946020830190611996565b0390a2565b7fdc37f51d000000000000000000000000000000000000000000000000000000005f5260045ffd5b9060ff7f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b14800541615611cf757611a1a91611be6611a15925a92611cfc565b611a1a915b8115611c9257611d446040517f0300000000000000000000000000000000000000000000000000000000000000602082015260018152611d3d6021826118e4565b3233611de6565b15611b81576021611d9691836040519485927f030000000000000000000000000000000000000000000000000000000000000060208501528484013781015f838201520301601f1981018352826118e4565b7f83363b78bdfbb23e2a61db7accc3c01fda29c5c5ec81888003cb962912618a7f6040516020815280611c8d33946020830190611996565b908160209103126110df575180151581036110df5790565b919073ffffffffffffffffffffffffffffffffffffffff7f5c6d1774bdd69d8d16847c3c97b51ea7343257b8f5ace5da9e25ab3bafd7d50054168015928315611e32575b505050905090565b6020935073ffffffffffffffffffffffffffffffffffffffff94611e9b8692604051978896879586957f7a3979dc000000000000000000000000000000000000000000000000000000008752166004860152166024840152606060448401526064830190611996565b03915afa9081156110d4575f91611eb7575b50805f8080611e2a565b611ed0915060203d6020116111a05761119281836118e4565b5f611ead565b95949392919060ff7f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b14800541615611f1d5792611a159592611a1a979592611be6955a97611f22565b611a1a965b6040519690959394929391929091337310000000000000000000000000000000000000010173ffffffffffffffffffffffffffffffffffffffff169173ffffffffffffffffffffffffffffffffffffffff60b5978a9760209767ffffffffffffffff611c459c7fffffffffffffffffffffffffffffffffffffffff0000000000000000000000008a998d8d5f60f81b91015260601b1660218d01521660358b015260558a015260758901521660958701528686015260d58501378201018281015f8152500301601f1981018352826118e4565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff9772b91042014281116118045762278d009004600181018091116118045790565b9060ff7f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b1480054161561207057611a1a91611be6611a15925a92612106565b611a1a91612106565b91908110156120d95760051b810135907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1813603018212156110df57019081359167ffffffffffffffff83116110df5760200182360381136110df579190565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b908015611c92575f5b81811061211b57505050565b612126818385612079565b905015611c92578060216121896121406001948688612079565b9290836040519485927f040000000000000000000000000000000000000000000000000000000000000060208501528484013781015f838201520301601f1981018352826118e4565b612194813233611de6565b6121a0575b500161210f565b7f83363b78bdfbb23e2a61db7accc3c01fda29c5c5ec81888003cb962912618a7f60405160208152806121d833946020830190611996565b0390a25f612199565b7f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b1480054600160ff8216151514612259577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00166001177f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b1480055565b7f7679400d000000000000000000000000000000000000000000000000000000005f5260045ffd5b612289611ff5565b3a913a156122db575b828102928184041490151715611804575f527f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b1480160205260405f2080549182018092116118045755565b60019250612292565b73ffffffffffffffffffffffffffffffffffffffff7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c1993005416330361232457565b7f118cdaa7000000000000000000000000000000000000000000000000000000005f523360045260245ffd5b73ffffffffffffffffffffffffffffffffffffffff1680156124115773ffffffffffffffffffffffffffffffffffffffff7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c19930054827fffffffffffffffffffffffff00000000000000000000000000000000000000008216177f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c19930055167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3565b7f1e4fbdf7000000000000000000000000000000000000000000000000000000005f525f60045260245ffd5b60ff7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a005460401c161561246c57565b7fd7e6bcf8000000000000000000000000000000000000000000000000000000005f5260045ffd5b906124d157508051156124a957805190602001fd5b7fd6bda275000000000000000000000000000000000000000000000000000000005f5260045ffd5b81511580612524575b6124e2575090565b73ffffffffffffffffffffffffffffffffffffffff907f9996b315000000000000000000000000000000000000000000000000000000005f521660045260245ffd5b50803b156124da56f0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a002f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0dfefea1bb0b623b9ef93f3660a2c6239c474cd8dd141aaf60eb9b6bc0b389512ce84508f2c7fa9c351146748b3025cb78b45df37d868e48c6a75102fecdeee645ad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0\x80`@R4a\x03MW` \x81a]\xDA\x808\x03\x80\x91a\0\x1F\x82\x85a\x03QV[\x839\x81\x01\x03\x12a\x03MWQ`\x01`\x01`\xA0\x1B\x03\x81\x16\x80\x82\x03a\x03MW`\xFF\x19`\x01T\x16`\x01U\x15a\x03>W\x80a\0Wa\0]\x92a\x03tV[Pa\x03\xEAV[Pa\x01\xFE_R`\x04` R_Q` a]z_9_Q\x90_RT`\xFF\x16`\x03\x81\x10\x15a\x03*W`\x02a\0\x90\x91\x14\x15a\x04}V[a\x01\xFE_R`\x04` R_Q` a]z_9_Q\x90_R\x80T`\xFF\x19\x16`\x01\x17\x90U`3\x80[a\x02\xE3W\x7F\xD9\xE1#\x91w\xBF\xBD*\xEB\xF5\xD0\xF2\x0F\xC0u\xE6\xDFZP,Y\xD1!\xAC\xD5sB\xC7\x83\xE3\x13d`@`\x02Ta\x01\xFE`\x02U\x81Q\x90\x81Ra\x01\xFE` \x82\x01R\xA1`\x01`\x03Ua\x075`@Qa\x01\r` \x83\x01\x82a\x03QV[\x81\x81R` \x81\x01\x91a0\x11\x839a\x01C` `@Q\x80\x94\x82\x82\x01\x94Q\x80\x91\x86^\x81\x01_\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x84R\x83a\x03QV[\x81Q\x15a\x02\xD4W\x90QpSYNDICATE_STUB_V1`x\x1B\x91_\xF5=\x15\x19\x81\x15\x16a\x02\xBAW`\x01`\x01`\xA0\x1B\x03\x81\x16\x15a\x02\xC5W`\x80R`@Qa&\x14\x80\x82\x01`\x01`\x01`@\x1B\x03\x81\x11\x83\x82\x10\x17a\x02\xA6W\x82\x91a7F\x839\x03\x90_\xF0\x80\x15a\x02\xBAW`\x07\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x82\x17\x90U`\x08Th\x01\0\0\0\0\0\0\0\0\x81\x10\x15a\x02\xA6W`\x01\x81\x01\x80`\x08U\x81\x10\x15a\x02\x92W\x7F\xF3\xF7\xA9\xFE6O\xAA\xB9;!m\xA5\n2\x14\x15O\"\xA0\xA2\xB4\x15\xB2:\x84\xC8\x16\x9E\x8Bcn\xE3\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x90\x91\x17\x90U`\x07\x80T`\x01`\x01`\xA0\x1B\x03\x90\x81\x16_\x90\x81R`\t` R`@\x80\x82 \x80T`\xFF\x19\x16`\x01\x17\x90U\x92T\x92Q\x92\x90\x91\x16\x90\x7F3\x1C\xED\xC7\x1F(\xC4mFv\x91w\x06u\xB5\x86\xE8\xAAw\xA0\xD4\xFE\t\xF2W\xD0\x1E\xF0\x0B\xC1TX\x90\x80\xA2a+G\x90\x81a\x04\xCA\x829`\x80Q\x81\x81\x81a\x12\xBA\x01Ra\x1B\x17\x01R\xF3[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Q=_\x82>=\x90\xFD[c\xB0n\xBF=`\xE0\x1B_R`\x04_\xFD[c\x13(\x92w`\xE2\x1B_R`\x04_\xFD[\x80_R`\x04` R`\xFF`@_ T\x16\x90`\x03\x82\x10\x15a\x03*Wa\x03\x0C`\x01`\n\x93\x14\x15a\x04}V[\x80_R`\x04` R`@_ `\x02`\xFF\x19\x82T\x16\x17\x90U\x04\x80a\0\xB7V[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[c\xD9.#=`\xE0\x1B_R`\x04_\xFD[_\x80\xFD[`\x1F\x90\x91\x01`\x1F\x19\x16\x81\x01\x90`\x01`\x01`@\x1B\x03\x82\x11\x90\x82\x10\x17a\x02\xA6W`@RV[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R_Q` a]\xBA_9_Q\x90_R` R`@\x90 T`\xFF\x16a\x03\xE5W`\x01`\x01`\xA0\x1B\x03\x16_\x81\x81R_Q` a]\xBA_9_Q\x90_R` R`@\x81 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x91\x90_Q` a]Z_9_Q\x90_R\x81\x80\xA4`\x01\x90V[P_\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R_Q` a]\x9A_9_Q\x90_R` R`@\x90 T`\xFF\x16a\x03\xE5W`\x01`\x01`\xA0\x1B\x03\x16_\x81\x81R_Q` a]\x9A_9_Q\x90_R` R`@\x81 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x91\x90\x7F$\x1E\xCF\x16\xD7\x9D\x0F\x8D\xBF\xB9,\xBC\x07\xFE\x17\x84\x04%\x97l\xF0f\x7F\x02/\xE9\x87|\xAA\x83\x1B\x08\x90_Q` a]Z_9_Q\x90_R\x90\x80\xA4`\x01\x90V[\x15a\x04\x84WV[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7Fnamespace collision detected\0\0\0\0`D\x82\x01R`d\x90\xFD\xFE`\x80\x80`@R`\x046\x10\x15a\0\x12W_\x80\xFD[_\x90_5`\xE0\x1C\x90\x81b\xB6\x8As\x14a\x18FWP\x80c\x01\xFF\xC9\xA7\x14a\x17\xA5W\x80c\x07\xA9\xBE\xE7\x14a\x16\xDBW\x80c\t\xD2>$\x14a\x16\xA3W\x80c\rKK\xDA\x14a\x16YW\x80c\x1D\x1A\xB1Z\x14a\x159W\x80c$\x8A\x9C\xA3\x14a\x15\x0FW\x80c)\x7FLd\x14a\x14\xF2W\x80c//\xF1]\x14a\x14\xB5W\x80c1D\xE8S\x14a\x14gW\x80c2\xEDh\x05\x14a\x13\xC9W\x80c6V\x8A\xBE\x14a\x13]W\x80c?K\xA8:\x14a\x12\xDEW\x80cV\xDB\xA7y\x14a\x12\x8EW\x80c[\xD6X\x8B\x14a\x11EW\x80c\\\x97Z\xBB\x14a\x11#W\x80cc\x89\xF8\xDA\x14a\x10\xC7W\x80cg\xA5\xFB,\x14a\x0C\xCEW\x80cj\xE7\xE7\x03\x14a\x0C\xACW\x80co\xF6\xF6\xC0\x14a\x0ClW\x80cr2\xC13\x14a\x0C*W\x80c|\x16\xFF\xC4\x14a\x0B\xB1W\x80c\x84V\xCBY\x14a\x0BWW\x80c\x8B5\xBA%\x14a\n\xEBW\x80c\x8C9\xAA\xA4\x14a\x08\xB2W\x80c\x8D\xE6\xE2\x8C\x14a\x08\x8FW\x80c\x91\xD1HT\x14a\x088W\x80c\x99\x9Dq\xD4\x14a\x08\x1AW\x80c\x9E\x15\xD6\xFF\x14a\x061W\x80c\xA2\x17\xFD\xDF\x14a\x07\xFEW\x80c\xAA\xE7#\x8C\x14a\x06\xE2W\x80c\xB4\x16f>\x14a\x06\xC6W\x80c\xB9c\xEB\xF3\x14a\x06`W\x80c\xC1\x12\xEE\x8C\x14a\x061W\x80c\xCAL\xD0%\x14a\x05xW\x80c\xD5Gt\x1F\x14a\x051W\x80c\xEC\x87b\x1C\x14a\x04\xF6W\x80c\xEE^\xE7<\x14a\x04#W\x80c\xEE\xEBD\xAD\x14a\x02\x0BWc\xFFv\xAE\xD6\x14a\x01\xD5W_\x80\xFD[4a\x02\x08W\x80`\x03\x196\x01\x12a\x02\x08W` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x07T\x16`@Q\x90\x81R\xF3[\x80\xFD[P4a\x02\x08W` `\x03\x196\x01\x12a\x02\x08Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x02:a\x18\x83V[a\x02Ba\x1B\xD3V[\x16\x80\x82R`\t` R`\xFF`@\x83 T\x16\x15a\x03\xFBWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x07T\x16\x81\x14a\x03\xD3W\x81[`\x08T\x80\x82\x10\x15a\x03\xCCW\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x02\xA3\x84a\x18\xEBV[\x90T\x90`\x03\x1B\x1C\x16\x14a\x02\xB9WP`\x01\x01a\x02yV[_\x19\x81\x01\x90\x81\x11a\x03\x9FW\x90a\x02\xF7s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x02\xE9a\x03#\x94a\x18\xEBV[\x90T\x90`\x03\x1B\x1C\x16\x91a\x18\xEBV[\x90\x91\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x84T\x92`\x03\x1B\x93\x16\x83\x1B\x92\x1B\x19\x16\x17\x90UV[`\x08T\x80\x15a\x03rW_\x19\x01a\x038\x81a\x18\xEBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82T\x91`\x03\x1B\x1B\x19\x16\x90U`\x08U[\x81R`\t` R`@\x81 `\xFF\x19\x81T\x16\x90U\x80\xF3[`$\x83\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`1`\x04R\xFD[`$\x84\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x11`\x04R\xFD[PPa\x03\\V[`\x04\x82\x7F\xD5\xCCJ\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[`\x04\x82\x7F\xFB\x10\x18\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[P4a\x02\x08W` `\x03\x196\x01\x12a\x02\x08Wa\x04\xF2\x90a\x04\xDEa\x04Da\x18\x83V[a\x02r\x92` `@Q\x92a\x04Z\x82\x87\x01\x85a\x19LV[\x85\x84R\x81\x84\x01\x95a!\xA0\x879`@Qa\x04\xAF\x81a\x04\xA1\x85\x82\x01\x94\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF``\x92\x16\x81R`@` \x82\x01R_`@\x82\x01R\x01\x90V[\x03`\x1F\x19\x81\x01\x83R\x82a\x19LV[`@Q\x96\x87\x95Q\x80\x91\x85\x88\x01^\x85\x01\x90\x83\x82\x01\x90\x85\x82RQ\x92\x83\x91^\x01\x01\x90\x81R\x03`\x1F\x19\x81\x01\x83R\x82a\x19LV[`@Q\x91\x82\x91` \x83R` \x83\x01\x90a\x19\x87V[\x03\x90\xF3[P4a\x02\x08W\x80`\x03\x196\x01\x12a\x02\x08W` `@Q\x7F$\x1E\xCF\x16\xD7\x9D\x0F\x8D\xBF\xB9,\xBC\x07\xFE\x17\x84\x04%\x97l\xF0f\x7F\x02/\xE9\x87|\xAA\x83\x1B\x08\x81R\xF3[P4a\x02\x08W`@`\x03\x196\x01\x12a\x02\x08Wa\x05t`\x045a\x05Qa\x18`V[\x90a\x05oa\x05j\x82_R_` R`\x01`@_ \x01T\x90V[a\x1C;V[a\x1DUV[P\x80\xF3[P4a\x02\x08W\x80`\x03\x196\x01\x12a\x02\x08Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`U`\x0B` \x93a\x075`@Q\x90a\x05\xB8\x87\x82\x01\x83a\x19LV[\x80\x82R\x86\x82\x01\x90a$\x12\x829a\x05\xEC\x87`@Q\x80\x93\x82\x82\x01\x95Q\x80\x91\x87^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a\x19LV[Q\x90 \x90P`@Q\x90`@\x82\x01R\x7FSYNDICATE_STUB_V1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85\x82\x01R0\x81R\x01`\xFF\x81S \x16`@Q\x90\x81R\xF3[P4a\x02\x08W` `\x03\x196\x01\x12a\x02\x08W`\xFF`@` \x92`\x045\x81R`\n\x84R T\x16`@Q\x90\x15\x15\x81R\xF3[P4a\x02\x08W` `\x03\x196\x01\x12a\x02\x08W`\x045\x81R`\x04` R`\xFF`@\x82 T\x16`@Q\x90`\x03\x81\x10\x15a\x06\x99W` \x92P\x81R\xF3[`$\x83\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`!`\x04R\xFD[P4a\x02\x08W\x80`\x03\x196\x01\x12a\x02\x08Wa\x04\xF2a\x04\xDEa\x1A\xE2V[P4a\x02\x08W` `\x03\x196\x01\x12a\x02\x08W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x07\xFAW6`#\x82\x01\x12\x15a\x07\xFAW\x80`\x04\x015\x90a\x07 \x82a\x19oV[\x91a\x07.`@Q\x93\x84a\x19LV[\x80\x83R`$` \x84\x01\x91`\x05\x1B\x83\x01\x01\x916\x83\x11a\x07\xF6W`$\x01\x90[\x82\x82\x10a\x07\xE6WPPPa\x07_\x81Qa\x19\xE6V[\x82[\x82Q\x81\x10\x15a\x07\xD0W\x80a\x07w`\x01\x92\x85a\x1A\x17V[Q\x85R`\n` R`\xFF`@\x86 T\x16\x15a\x07\x93W[\x01a\x07aV[a\x07\x9D\x81\x85a\x1A\x17V[Q\x85R`\x05` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x86 T\x16a\x07\xCA\x82\x85a\x1A\x17V[Ra\x07\x8DV[`@Q` \x80\x82R\x81\x90a\x04\xF2\x90\x82\x01\x85a\x19\x03V[\x815\x81R` \x91\x82\x01\x91\x01a\x07KV[\x84\x80\xFD[P\x80\xFD[P4a\x02\x08W\x80`\x03\x196\x01\x12a\x02\x08W` \x90`@Q\x90\x81R\xF3[P4a\x02\x08W\x80`\x03\x196\x01\x12a\x02\x08W` `\x03T`@Q\x90\x81R\xF3[P4a\x02\x08W`@`\x03\x196\x01\x12a\x02\x08Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@a\x08ia\x18`V[\x92`\x045\x81R\x80` R \x91\x16_R` R` `\xFF`@_ T\x16`@Q\x90\x15\x15\x81R\xF3[P4a\x02\x08W\x80`\x03\x196\x01\x12a\x02\x08W` a\x08\xAAa\x1AUV[`@Q\x90\x81R\xF3[P4a\x02\x08W` `\x03\x196\x01\x12a\x02\x08W`\x045\x7F$\x1E\xCF\x16\xD7\x9D\x0F\x8D\xBF\xB9,\xBC\x07\xFE\x17\x84\x04%\x97l\xF0f\x7F\x02/\xE9\x87|\xAA\x83\x1B\x08\x82R\x81` R`@\x82 s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`\xFF`@_ T\x16\x15a\n\x9BW\x80\x15a\n\x17W\x80\x82R`\x04` R`\xFF`@\x83 T\x16`\x03\x81\x10\x15a\x06\x99W`\x02a\tG\x91\x14\x15a\x1E3V[\x80\x82R`\x04` R`@\x82 `\x01`\xFF\x19\x82T\x16\x17\x90U`\n\x81\x04\x80[a\t\xA3WP`@\x7F\xD9\xE1#\x91w\xBF\xBD*\xEB\xF5\xD0\xF2\x0F\xC0u\xE6\xDFZP,Y\xD1!\xAC\xD5sB\xC7\x83\xE3\x13d\x91`\x02T\x90\x80`\x02U\x82Q\x91\x82R` \x82\x01R\xA1\x80\xF3[\x80\x83R`\x04` R`\xFF`@\x84 T\x16`\x03\x81\x10\x15a\t\xEAW\x90a\t\xCC`\x01`\n\x93\x14\x15a\x1E3V[\x80\x84R`\x04` R`@\x84 `\x02`\xFF\x19\x82T\x16\x17\x90U\x04\x80a\tdV[`$\x84\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`!`\x04R\xFD[`\x84`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7Fnamespace prefix of 0 is forbidd`D\x82\x01R\x7Fen\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R\xFD[`D\x82\x7F\xE2Q}?\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R3`\x04R\x7F$\x1E\xCF\x16\xD7\x9D\x0F\x8D\xBF\xB9,\xBC\x07\xFE\x17\x84\x04%\x97l\xF0f\x7F\x02/\xE9\x87|\xAA\x83\x1B\x08`$R\xFD[P4a\x02\x08W`@`\x03\x196\x01\x12a\x02\x08W`\x045s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x0B\x1Da\x18`V[a\x0B%a\x1B\xD3V[a\x0B.\x83a\x1B\x95V[\x16\x90\x7F\xEB\xB4\xC5\r\xEB(Q\x92\xD1\xC2\xAA\x882\xB1\xFE\xEB\x07\x8B\xA0\xFD\x92\xBBC\x9C\r\xEE(\xEB\xE9\xBB6\xE9\x83\x80\xA3\x80\xF3[P4a\x02\x08W\x80`\x03\x196\x01\x12a\x02\x08Wa\x0Bpa\x1B\xD3V[a\x0Bxa\x1D\xFFV[`\x01`\xFF\x19\x81T\x16\x17`\x01U\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2X` `@Q3\x81R\xA1\x80\xF3[P4a\x02\x08W` `\x03\x196\x01\x12a\x02\x08Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x0B\xE0a\x18\x83V[a\x0B\xE8a\x1B\xD3V[\x16\x80\x82R`\t` R`\xFF`@\x83 T\x16\x15a\x03\xFBW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x07T\x16\x17`\x07U\x80\xF3[P4a\x02\x08W` `\x03\x196\x01\x12a\x02\x08Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@` \x92`\x045\x81R`\x05\x84R T\x16\x15\x15`@Q\x90\x81R\xF3[P4a\x02\x08W` `\x03\x196\x01\x12a\x02\x08Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@` \x92`\x045\x81R`\x05\x84R T\x16`@Q\x90\x81R\xF3[P4a\x02\x08W\x80`\x03\x196\x01\x12a\x02\x08W` a\x08\xAA`\x06T`\x0BT\x90a\x19\xACV[P4a\x0F\xA8W```\x03\x196\x01\x12a\x0F\xA8W`\x045\x90a\x0C\xECa\x18`V[\x91`D5\x92s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16\x80\x94\x03a\x0F\xA8Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90a\r-a\x1D\xFFV[\x16\x92\x83\x15\x80\x15a\x10\xBFW[a\x10\x97W\x81\x15\x91\x82\x15a\x10\x91WPa\rNa\x1AUV[\x91[\x82_R`\x05` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ T\x16a\x10iWa\x10VW[a\r\x84a\x1A\xE2V[\x80Q\x15a\x10.W\x80Q\x83\x91` \x01_\xF5\x90=\x15\x19\x82\x15\x16a\x0F\x9DWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x91\x82\x15a\x10\x06W\x83_R`\x05` R`@_ \x83\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82T\x16\x17\x90U`\x06Th\x01\0\0\0\0\0\0\0\0\x81\x10\x15a\x0F\xD9W_\x91a\x0E\x18\x82`\x01\x85\x94\x01`\x06Ua\x18\xA6V[\x81T\x90`\x03\x1B\x90_\x19\x89\x83\x1B\x92\x1B\x19\x16\x17\x90U`@Q\x7F\x17\x94\xBB<\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01R0`$\x82\x01R\x84`D\x82\x01R\x86`d\x82\x01R`d\x81Ra\x0Eu`\x84\x82a\x19LV[\x82a\x04\xA1a\x0E\xDAs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x07T\x16\x93`@Q\x92\x83\x91` \x83\x01\x96\x7FO\x1E\xF2\x86\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x88R`$\x84\x01R`@`D\x84\x01R`d\x83\x01\x90a\x19\x87V[Q\x92Z\xF1=\x15a\x0F\xD4W=a\x0E\xEE\x81a\x1A9V[\x90a\x0E\xFC`@Q\x92\x83a\x19LV[\x81R_` =\x92\x01>[\x15a\x0F\xACW\x81;\x15a\x0F\xA8W`@Q\x94\x7F\xF2\xFD\xE3\x8B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x86R`\x04\x86\x01R_\x85`$\x81\x83\x86Z\xF1\x94\x85\x15a\x0F\x9DW`@\x95a\x0F\x88W[P\x81\x83\x7FI\xB2\x1F\x1EA\x90\xDB\x8B\n\x93<\x95\x1E\xD0\x13\xDE\",\x84|\x15F\x17Th-\xAA.\xAB\x1F\xDB\xD2\x87Q\x96\x80\xA4\x82R` \x82\x01R\xF3[a\x0F\x95\x91\x94P_\x90a\x19LV[_\x92_a\x0FVV[`@Q=_\x82>=\x90\xFD[_\x80\xFD[\x7F\xABn\xB5\xBC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[a\x0F\x06V[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[\x7F\xB0n\xBF=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7FL\xA2I\xDC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[a\x10a`\x03Ta\x1A+V[`\x03Ua\r|V[\x7F$Y\x1D\x89\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x91a\rPV[\x7F\xD9.#=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[P\x80\x15a\r8V[4a\x0F\xA8W` `\x03\x196\x01\x12a\x0F\xA8W` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`U`\x0Ba\x10\xFBa\x1A\xE2V[\x84\x81Q\x91\x01 `@Q\x90`@\x82\x01R`\x045\x85\x82\x01R0\x81R\x01`\xFF\x81S \x16`@Q\x90\x81R\xF3[4a\x0F\xA8W_`\x03\x196\x01\x12a\x0F\xA8W` `\xFF`\x01T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x0F\xA8W_`\x03\x196\x01\x12a\x0F\xA8W`\x06Ta\x11d`\x0BT\x82a\x19\xACV[\x90a\x11n\x82a\x19oV[\x90a\x11|`@Q\x92\x83a\x19LV[\x82\x82Ra\x11\x9Da\x11\x8B\x84a\x19oV[\x93`\x1F\x19` \x85\x01\x95\x016\x867a\x19\xE6V[\x90__[\x82\x81\x10a\x11\xF5WPPP`@Q\x91`@\x83\x01\x90`@\x84RQ\x80\x91R``\x83\x01\x93\x90_[\x81\x81\x10a\x11\xDFW\x84\x80a\x04\xF2\x88\x87\x83\x82\x03` \x85\x01Ra\x19\x03V[\x82Q\x86R` \x95\x86\x01\x95\x90\x92\x01\x91`\x01\x01a\x11\xC4V[a\x11\xFE\x81a\x18\xA6V[\x90T\x90`\x03\x1B\x1C_R`\n` R`\xFF`@_ T\x16\x15a\x12\"W[`\x01\x01a\x11\xA1V[\x90a\x12\x86`\x01\x91a\x122\x84a\x18\xA6V[\x90T\x90`\x03\x1B\x1Ca\x12C\x82\x89a\x1A\x17V[Ra\x12M\x84a\x18\xA6V[\x90T\x90`\x03\x1B\x1C_R`\x05` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ T\x16a\x12\x80\x82\x88a\x1A\x17V[Ra\x1A+V[\x91\x90Pa\x12\x1AV[4a\x0F\xA8W_`\x03\x196\x01\x12a\x0F\xA8W` `@Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x81R\xF3[4a\x0F\xA8W_`\x03\x196\x01\x12a\x0F\xA8Wa\x12\xF6a\x1B\xD3V[`\x01T`\xFF\x81\x16\x15a\x135W`\xFF\x19\x16`\x01U\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA` `@Q3\x81R\xA1\0[\x7F\x8D\xFC +\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x0F\xA8W`@`\x03\x196\x01\x12a\x0F\xA8Wa\x13va\x18`V[3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x03a\x13\xA1Wa\x13\x9F\x90`\x045a\x1DUV[\0[\x7Ff\x97\xB22\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x0F\xA8W_`\x03\x196\x01\x12a\x0F\xA8W`@Q\x80` `\x08T\x91\x82\x81R\x01\x90`\x08_R\x7F\xF3\xF7\xA9\xFE6O\xAA\xB9;!m\xA5\n2\x14\x15O\"\xA0\xA2\xB4\x15\xB2:\x84\xC8\x16\x9E\x8Bcn\xE3\x90_[\x81\x81\x10a\x14;Wa\x04\xF2\x85a\x14'\x81\x87\x03\x82a\x19LV[`@Q\x91\x82\x91` \x83R` \x83\x01\x90a\x19\x03V[\x82Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84R` \x90\x93\x01\x92`\x01\x92\x83\x01\x92\x01a\x14\x10V[4a\x0F\xA8W` `\x03\x196\x01\x12a\x0F\xA8W`\x045`\x08T\x81\x10\x15a\x0F\xA8Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x14\xA5` \x92a\x18\xEBV[\x90T\x90`\x03\x1B\x1C\x16`@Q\x90\x81R\xF3[4a\x0F\xA8W`@`\x03\x196\x01\x12a\x0F\xA8Wa\x13\x9F`\x045a\x14\xD4a\x18`V[\x90a\x14\xEDa\x05j\x82_R_` R`\x01`@_ \x01T\x90V[a\x1C\xA1V[4a\x0F\xA8W_`\x03\x196\x01\x12a\x0F\xA8W` `\x02T`@Q\x90\x81R\xF3[4a\x0F\xA8W` `\x03\x196\x01\x12a\x0F\xA8W` a\x08\xAA`\x045_R_` R`\x01`@_ \x01T\x90V[4a\x0F\xA8W`@`\x03\x196\x01\x12a\x0F\xA8Wa\x15Ra\x18\x83V[`$5\x80\x15\x15\x81\x03a\x0F\xA8Wa\x15fa\x1B\xD3V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x91\x82\x15a\x10\x97W\x82_R`\t` R`\xFF`@_ T\x16a\x161W`\x08T\x90h\x01\0\0\0\0\0\0\0\0\x82\x10\x15a\x0F\xD9Wa\x02\xF7\x82`\x01a\x15\xC0\x94\x01`\x08Ua\x18\xEBV[\x81_R`\t` R`@_ `\x01`\xFF\x19\x82T\x16\x17\x90Ua\x16\x02W[\x7F3\x1C\xED\xC7\x1F(\xC4mFv\x91w\x06u\xB5\x86\xE8\xAAw\xA0\xD4\xFE\t\xF2W\xD0\x1E\xF0\x0B\xC1TX_\x80\xA2\0[\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x07T\x16\x17`\x07Ua\x15\xDCV[\x7F\x183\xA2K\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x0F\xA8W` `\x03\x196\x01\x12a\x0F\xA8Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x16\x87a\x18\x83V[\x16_R`\t` R` `\xFF`@_ T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x0F\xA8W` `\x03\x196\x01\x12a\x0F\xA8W`\x045`\x06T\x81\x10\x15a\x0F\xA8Wa\x16\xCC` \x91a\x18\xA6V[\x90T\x90`\x03\x1B\x1C`@Q\x90\x81R\xF3[4a\x0F\xA8W`@`\x03\x196\x01\x12a\x0F\xA8W`\x045a\x16\xF7a\x18`V[\x81_R`\x05` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ T\x163\x03a\x17}Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81_R`\t` R`\xFF`@_ T\x16\x15a\x17NW\0[a\x17W\x81a\x1B\x95V[\x7F\xEB\xB4\xC5\r\xEB(Q\x92\xD1\xC2\xAA\x882\xB1\xFE\xEB\x07\x8B\xA0\xFD\x92\xBBC\x9C\r\xEE(\xEB\xE9\xBB6\xE9_\x80\xA3\0[\x7F/\xD9\xAD\xAE\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x0F\xA8W` `\x03\x196\x01\x12a\x0F\xA8W`\x045\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16\x80\x91\x03a\x0F\xA8W\x80\x7Fye\xDB\x0B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x92\x14\x90\x81\x15a\x18\x1CW[P`@Q\x90\x15\x15\x81R\xF3[\x7F\x01\xFF\xC9\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91P\x14\x82a\x18\x11V[4a\x0F\xA8W_`\x03\x196\x01\x12a\x0F\xA8W` \x90`\x0BT\x81R\xF3[`$5\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x0F\xA8WV[`\x045\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x0F\xA8WV[`\x06T\x81\x10\x15a\x18\xBEW`\x06_R` _ \x01\x90_\x90V[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[`\x08T\x81\x10\x15a\x18\xBEW`\x08_R` _ \x01\x90_\x90V[\x90` \x80\x83Q\x92\x83\x81R\x01\x92\x01\x90_[\x81\x81\x10a\x19 WPPP\x90V[\x82Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a\x19\x13V[\x90`\x1F`\x1F\x19\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x0F\xD9W`@RV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x0F\xD9W`\x05\x1B` \x01\x90V[\x90`\x1F\x19`\x1F` \x80\x94\x80Q\x91\x82\x91\x82\x87R\x01\x86\x86\x01^_\x85\x82\x86\x01\x01R\x01\x16\x01\x01\x90V[\x91\x90\x82\x03\x91\x82\x11a\x19\xB9WV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[\x90a\x19\xF0\x82a\x19oV[a\x19\xFD`@Q\x91\x82a\x19LV[\x82\x81R`\x1F\x19a\x1A\r\x82\x94a\x19oV[\x01\x90` 6\x91\x017V[\x80Q\x82\x10\x15a\x18\xBEW` \x91`\x05\x1B\x01\x01\x90V[_\x19\x81\x14a\x19\xB9W`\x01\x01\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x0F\xD9W`\x1F\x01`\x1F\x19\x16` \x01\x90V[a\x1A\xB1` a\x1A\xA9a\x1Ah`\x02Ta\x1E\x98V[\x82\x80a\x1Au`\x03Ta\x1E\x98V[`@Q\x95\x84\x87\x95Q\x91\x82\x91\x01\x84\x87\x01^\x84\x01\x90\x82\x82\x01_\x81R\x81Q\x93\x84\x92\x01\x90^\x01\x01_\x81R\x03`\x1F\x19\x81\x01\x83R\x82a\x19LV[\x80Q\x90a \x1DV[\x90\x15a\x1A\xBAW\x90V[\x7F\x94\xE2s~\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[a\x02ra\x1B\x92`@Qa\x1A\xF8` \x84\x01\x82a\x19LV[\x82\x81R` \x81\x01\x92a!\xA0\x849` `@Q\x81\x81\x01\x90a\x1Bc\x81a\x04\xA1\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF``\x92\x16\x81R`@` \x82\x01R_`@\x82\x01R\x01\x90V[`@Q\x95\x86\x94Q\x80\x91\x85\x87\x01^\x84\x01\x90\x83\x82\x01\x90_\x82RQ\x92\x83\x91^\x01\x01_\x81R\x03`\x1F\x19\x81\x01\x83R\x82a\x19LV[\x90V[\x80_R`\n` R`\xFF`@_ T\x16\x15a\x1B\xADWPV[_R`\n` R`@_ `\x01`\xFF\x19\x82T\x16\x17\x90Ua\x1B\xCE`\x0BTa\x1A+V[`\x0BUV[3_\x90\x81R\x7F\xAD2(\xB6v\xF7\xD3\xCDB\x84\xA5D?\x17\xF1\x96+6\xE4\x91\xB3\n@\xB2@XI\xE5\x97\xBA_\xB5` R`@\x90 T`\xFF\x16\x15a\x1C\x0BWV[\x7F\xE2Q}?\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R3`\x04R_`$R`D_\xFD[\x80_R_` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`\xFF`@_ T\x16\x15a\x1CrWPV[\x7F\xE2Q}?\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R3`\x04R`$R`D_\xFD[\x80_R_` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16_R` R`\xFF`@_ T\x16\x15_\x14a\x1DOW\x80_R_` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16_R` R`@_ `\x01`\xFF\x19\x82T\x16\x17\x90Us\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x92\x16\x90\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r_\x80\xA4`\x01\x90V[PP_\x90V[\x80_R_` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16_R` R`\xFF`@_ T\x16_\x14a\x1DOW\x80_R_` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16_R` R`@_ `\xFF\x19\x81T\x16\x90Us\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x92\x16\x90\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B_\x80\xA4`\x01\x90V[`\xFF`\x01T\x16a\x1E\x0BWV[\x7F\xD9<\x06e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x15a\x1E:WV[`d`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7Fnamespace collision detected\0\0\0\0`D\x82\x01R\xFD[\x80_\x91z\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x82\x10\x15a\x1F\xF5W[\x80m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0`\n\x92\x10\x15a\x1F\xDAW[f#\x86\xF2o\xC1\0\0\x81\x10\x15a\x1F\xC6W[c\x05\xF5\xE1\0\x81\x10\x15a\x1F\xB5W[a'\x10\x81\x10\x15a\x1F\xA6W[`d\x81\x10\x15a\x1F\x98W[\x10\x15a\x1F\x8DW[`\n_\x19`!`\x01\x85\x01\x94`\x1F\x19a\x1FBa\x1F,\x88a\x1A9V[\x97a\x1F:`@Q\x99\x8Aa\x19LV[\x80\x89Ra\x1A9V[\x016` \x88\x017\x85\x01\x01[\x01\x91\x7F0123456789abcdef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x82\x06\x1A\x83S\x04\x80\x15a\x1F\x88W_\x19`\n\x91\x92a\x1FMV[PP\x90V[`\x01\x90\x91\x01\x90a\x1F\x12V[`d`\x02\x91\x04\x93\x01\x92a\x1F\x0BV[a'\x10`\x04\x91\x04\x93\x01\x92a\x1F\x01V[c\x05\xF5\xE1\0`\x08\x91\x04\x93\x01\x92a\x1E\xF6V[f#\x86\xF2o\xC1\0\0`\x10\x91\x04\x93\x01\x92a\x1E\xE9V[m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0` \x91\x04\x93\x01\x92a\x1E\xD9V[P`@\x91Pz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x81\x04a\x1E\xBFV[\x90\x81Q\x81\x11\x80\x15a CW[a ;W_a 7\x92a JV[\x90\x91V[PP_\x90_\x90V[P_a )V[_\x93\x92\x90[\x81\x83\x10a _WPPP`\x01\x91\x90V[\x90\x92\x91\x93`\xFFa \x96\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x88\x86\x01\x01Q\x16a \xD3V[\x16`\t\x81\x11a \xC8W`\n\x82\x02\x91\x80\x83\x04`\n\x14\x90\x15\x17\x15a\x19\xB9W\x81\x01\x80\x91\x11a\x19\xB9W`\x01\x90\x94\x01\x91\x92\x90a OV[P_\x94P\x84\x93PPPV[`\xF8\x1C`/\x81\x11\x80a!\x95W[\x15a!\rW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xD0\x01`\xFF\x16\x90V[``\x81\x11\x80a!\x8BW[\x15a!DW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xA9\x01`\xFF\x16\x90V[`@\x81\x11\x80a!\x81W[\x15a!{W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC9\x01`\xFF\x16\x90V[P`\xFF\x90V[P`G\x81\x10a!NV[P`g\x81\x10a!\x17V[P`:\x81\x10a \xE0V\xFE`\x80`@Ra\x02r\x808\x03\x80a\0\x14\x81a\x01hV[\x92\x839\x81\x01`@\x82\x82\x03\x12a\x01dW\x81Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x92\x90\x91\x90\x83\x83\x03a\x01dW` \x81\x01Q\x90`\x01`\x01`@\x1B\x03\x82\x11a\x01dW\x01\x92\x81`\x1F\x85\x01\x12\x15a\x01dW\x83Qa\0na\0i\x82a\x01\xA1V[a\x01hV[\x94\x81\x86R` \x86\x01\x93` \x83\x83\x01\x01\x11a\x01dW\x81_\x92` \x80\x93\x01\x86^\x86\x01\x01R\x82;\x15a\x01RW\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x82\x17\x90U\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;_\x80\xA2\x82Q\x15a\x01:W_\x80\x91a\x01\"\x94Q\x90\x84Z\xF4=\x15a\x012W=\x91a\x01\x13a\0i\x84a\x01\xA1V[\x92\x83R=_` \x85\x01>a\x01\xBCV[P[`@Q`W\x90\x81a\x02\x1B\x829\xF3[``\x91a\x01\xBCV[PPP4\x15a\x01$Wc\xB3\x98\x97\x9F`\xE0\x1B_R`\x04_\xFD[cL\x9C\x8C\xE3`\xE0\x1B_R`\x04R`$_\xFD[_\x80\xFD[`@Q\x91\x90`\x1F\x01`\x1F\x19\x16\x82\x01`\x01`\x01`@\x1B\x03\x81\x11\x83\x82\x10\x17a\x01\x8DW`@RV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`\x01`\x01`@\x1B\x03\x81\x11a\x01\x8DW`\x1F\x01`\x1F\x19\x16` \x01\x90V[\x90a\x01\xE0WP\x80Q\x15a\x01\xD1W\x80Q\x90` \x01\xFD[c\xD6\xBD\xA2u`\xE0\x1B_R`\x04_\xFD[\x81Q\x15\x80a\x02\x11W[a\x01\xF1WP\x90V[c\x99\x96\xB3\x15`\xE0\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16`\x04R`$\x90\xFD[P\x80;\x15a\x01\xE9V\xFE`\x80`@R_\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCT\x166\x82\x807\x816\x91Z\xF4=_\x80>\x15`SW=_\xF3[=_\xFD`\xA0\x80`@R4`)W0`\x80Ra\x07\x07\x90\x81a\0.\x829`\x80Q\x81\x81\x81a\x01\xF0\x01Ra\x03)\x01R\xF3[_\x80\xFD\xFE`\x80`@R`\x046\x10\x15a\0\xD0W[6\x15a\0rW`d`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FStub: no logic implemented\0\0\0\0\0\0`D\x82\x01R\xFD[`d`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FStub: ETH not accepted\0\0\0\0\0\0\0\0\0\0`D\x82\x01R\xFD[_5`\xE0\x1C\x80cO\x1E\xF2\x86\x14a\x02hW\x80cR\xD1\x90-\x14a\x01\xABWc\xAD<\xB1\xCC\x03a\0\x0EW4a\x01\xA7W_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x01\xA7W`@\x80Q\x90a\x012\x81\x83a\x05\xC6V[`\x05\x82R` \x82\x01\x91\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83R\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F\x83Q\x94\x85\x93` \x85RQ\x80\x91\x81` \x87\x01R\x86\x86\x01^_\x85\x82\x86\x01\x01R\x01\x16\x81\x01\x03\x01\x90\xF3[_\x80\xFD[4a\x01\xA7W_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x01\xA7Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x160\x03a\x02@W` `@Q\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x81R\xF3[\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x01\xA7W`\x045s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x90\x81\x81\x03a\x01\xA7W`$5\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x01\xA7W6`#\x83\x01\x12\x15a\x01\xA7W\x81`\x04\x015\x91a\x02\xE1\x83a\x064V[\x92a\x02\xEF`@Q\x94\x85a\x05\xC6V[\x80\x84R` \x84\x01\x916`$\x83\x83\x01\x01\x11a\x01\xA7W\x81_\x92`$` \x93\x01\x857\x85\x01\x01Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x800\x14\x90\x81\x15a\x05\x84W[Pa\x02@W`@Q\x7FR\xD1\x90-\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x81`\x04\x81\x88Z\xFA_\x91\x81a\x05PW[Pa\x03\xC1W\x84\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x80\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x86\x92\x03a\x05%WP\x82;\x15a\x04\xFAW\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCT\x16\x17\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCU\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;_\x80\xA2\x82Q\x15a\x04\xC8W_\x80\x91a\x04\xBE\x94Q\x90\x84Z\xF4=\x15a\x04\xC0W=\x91a\x04\xA2\x83a\x064V[\x92a\x04\xB0`@Q\x94\x85a\x05\xC6V[\x83R=_` \x85\x01>a\x06nV[\0[``\x91a\x06nV[PPP4a\x04\xD2W\0[\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x90\x91P` \x81=` \x11a\x05|W[\x81a\x05l` \x93\x83a\x05\xC6V[\x81\x01\x03\x12a\x01\xA7WQ\x90\x86a\x03\x90V[=\x91Pa\x05_V[\x90Ps\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCT\x16\x14\x15\x85a\x03TV[\x90`\x1F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x06\x07W`@RV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x06\x07W`\x1F\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x16` \x01\x90V[\x90a\x06\xABWP\x80Q\x15a\x06\x83W\x80Q\x90` \x01\xFD[\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x81Q\x15\x80a\x06\xFEW[a\x06\xBCWP\x90V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R\x16`\x04R`$_\xFD[P\x80;\x15a\x06\xB4V`\xA0\x80`@R4`)W0`\x80Ra\x07\x07\x90\x81a\0.\x829`\x80Q\x81\x81\x81a\x01\xF0\x01Ra\x03)\x01R\xF3[_\x80\xFD\xFE`\x80`@R`\x046\x10\x15a\0\xD0W[6\x15a\0rW`d`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FStub: no logic implemented\0\0\0\0\0\0`D\x82\x01R\xFD[`d`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FStub: ETH not accepted\0\0\0\0\0\0\0\0\0\0`D\x82\x01R\xFD[_5`\xE0\x1C\x80cO\x1E\xF2\x86\x14a\x02hW\x80cR\xD1\x90-\x14a\x01\xABWc\xAD<\xB1\xCC\x03a\0\x0EW4a\x01\xA7W_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x01\xA7W`@\x80Q\x90a\x012\x81\x83a\x05\xC6V[`\x05\x82R` \x82\x01\x91\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83R\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F\x83Q\x94\x85\x93` \x85RQ\x80\x91\x81` \x87\x01R\x86\x86\x01^_\x85\x82\x86\x01\x01R\x01\x16\x81\x01\x03\x01\x90\xF3[_\x80\xFD[4a\x01\xA7W_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x01\xA7Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x160\x03a\x02@W` `@Q\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x81R\xF3[\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x01\xA7W`\x045s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x90\x81\x81\x03a\x01\xA7W`$5\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x01\xA7W6`#\x83\x01\x12\x15a\x01\xA7W\x81`\x04\x015\x91a\x02\xE1\x83a\x064V[\x92a\x02\xEF`@Q\x94\x85a\x05\xC6V[\x80\x84R` \x84\x01\x916`$\x83\x83\x01\x01\x11a\x01\xA7W\x81_\x92`$` \x93\x01\x857\x85\x01\x01Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x800\x14\x90\x81\x15a\x05\x84W[Pa\x02@W`@Q\x7FR\xD1\x90-\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x81`\x04\x81\x88Z\xFA_\x91\x81a\x05PW[Pa\x03\xC1W\x84\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x80\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x86\x92\x03a\x05%WP\x82;\x15a\x04\xFAW\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCT\x16\x17\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCU\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;_\x80\xA2\x82Q\x15a\x04\xC8W_\x80\x91a\x04\xBE\x94Q\x90\x84Z\xF4=\x15a\x04\xC0W=\x91a\x04\xA2\x83a\x064V[\x92a\x04\xB0`@Q\x94\x85a\x05\xC6V[\x83R=_` \x85\x01>a\x06nV[\0[``\x91a\x06nV[PPP4a\x04\xD2W\0[\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x90\x91P` \x81=` \x11a\x05|W[\x81a\x05l` \x93\x83a\x05\xC6V[\x81\x01\x03\x12a\x01\xA7WQ\x90\x86a\x03\x90V[=\x91Pa\x05_V[\x90Ps\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCT\x16\x14\x15\x85a\x03TV[\x90`\x1F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x06\x07W`@RV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x06\x07W`\x1F\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x16` \x01\x90V[\x90a\x06\xABWP\x80Q\x15a\x06\x83W\x80Q\x90` \x01\xFD[\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x81Q\x15\x80a\x06\xFEW[a\x06\xBCWP\x90V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R\x16`\x04R`$_\xFD[P\x80;\x15a\x06\xB4V`\xA0\x80`@R4a\0\xC2W0`\x80R_Q` a%\xF4_9_Q\x90_RT`\xFF\x81`@\x1C\x16a\0\xB3W`\x02`\x01`@\x1B\x03\x19`\x01`\x01`@\x1B\x03\x82\x16\x01a\0`W[`@Qa%-\x90\x81a\0\xC7\x829`\x80Q\x81\x81\x81a\x0C\xB7\x01Ra\r|\x01R\xF3[`\x01`\x01`@\x1B\x03\x19\x16`\x01`\x01`@\x1B\x03\x90\x81\x17_Q` a%\xF4_9_Q\x90_RU\x81R\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x90` \x90\xA1_\x80a\0AV[c\xF9.\xE8\xA9`\xE0\x1B_R`\x04_\xFD[_\x80\xFD\xFE`\x80\x80`@R`\x046\x10\x15a\0\x12W_\x80\xFD[_\x90_5`\xE0\x1C\x90\x81c\x01u\xE2;\x14a\x17\x90WP\x80c\x0Cg#c\x14a\x17GW\x80c\x17\x94\xBB<\x14a\x13\xEEW\x80c$\x07\xF0\xB6\x14a\x13\xB4W\x80c4\x9D\xB3k\x14a\x13CW\x80c9i\x8A\xC0\x14a\x12MW\x80cF\xE2\xCC\t\x14a\x12\x11W\x80cO\x1E\xF2\x86\x14a\r/W\x80cR\xD1\x90-\x14a\x0C\x8FW\x80cS\xC1A\x11\x14a\x0CTW\x80cTg\xCBH\x14a\x0B\xA1W\x80c[<\xD6\xE2\x14a\x0BNW\x80c]\xF1\x9E*\x14a\x0B\tW\x80c^z{\xDF\x14a\n\xD5W\x80ck0\xFC\xEF\x14a\nwW\x80cqP\x18\xA6\x14a\t\xB9W\x80cx\x1C\xD9\x9D\x14a\t\x9AW\x80cz9y\xDC\x14a\t?W\x80cz\x8DA\xC2\x14a\x08\xADW\x80c\x84\xC5w\xA9\x14a\x086W\x80c\x84\xFA\xB6+\x14a\x07\xF4W\x80c\x8D\xA5\xCB[\x14a\x07\xA1W\x80c\xA7\x0B\x9F\x0C\x14a\x07\x83W\x80c\xAD<\xB1\xCC\x14a\x07\x1EW\x80c\xB3\xC6P\x15\x14a\x06\xD7W\x80c\xB9Vov\x14a\x06\xB1W\x80c\xB9}\xD9\xE2\x14a\x06\x8EW\x80c\xB9\xF7\xF2`\x14a\x06SW\x80c\xC4Z\x01U\x14a\x06\x1FW\x80c\xCD\xAF\xB9x\x14a\x05\xBDW\x80c\xCEf]\xD8\x14a\x05\x8EW\x80c\xD1\xC2~\x01\x14a\x05&W\x80c\xD4\xF0\xEBM\x14a\x04_W\x80c\xD5\x17m#\x14a\x03\x93W\x80c\xD8x\x13B\x14a\x03vW\x80c\xDE\x1FE>\x14a\x03UW\x80c\xE09af\x14a\x03\x0BW\x80c\xF2\xFD\xE3\x8B\x14a\x02>Wc\xF9X\xCB\xA2\x14a\x01\xCBW_\x80\xFD[4a\x02;W` `\x03\x196\x01\x12a\x02;W`\x045\x80\x15\x15\x80\x91\x03a\x029Wa\x01\xF1a\"\xE4V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFt\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x02T\x92`\xA0\x1B\x16\x91\x16\x17`\x02U\x80\xF3[P[\x80\xFD[P4a\x02;W` `\x03\x196\x01\x12a\x02;Wa\x02\x8Fa\x02[a\x18YV[a\x02ca\"\xE4V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01T\x16\x15a\x02\x92W[a\x02\x8Aa\"\xE4V[a#PV[\x80\xF3[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0T\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90\x7F\x16\xAE1yaZ(\x15X;ef\xEA\xE6\xF7\x83\xB2T\x19E,\0Y\x9A\xEE\xB0\x10\x88\xF1>\xCA\x1A\x85\x80\xA3a\x02\x82V[P4a\x02;W` `\x03\x196\x01\x12a\x02;W`\x045_R\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\x01` R` `@_ T`@Q\x90\x81R\xF3[P4a\x02;W\x80`\x03\x196\x01\x12a\x02;Wa\x03na\"\xE4V[a\x02\x8Fa!\xE1V[P4a\x02;W\x80`\x03\x196\x01\x12a\x02;W` \x90T`@Q\x90\x81R\xF3[P4a\x02;W` `\x03\x196\x01\x12a\x02;W`\x045\x80\x15a\x047Wb'\x8D\0\x81\x02\x90\x81\x04b'\x8D\0\x03a\x04\nWch\x8DF\xF0\x01\x90\x81ch\x8DF\xF0\x11a\x03\xDDW` \x82`@Q\x90\x81R\xF3[\x80\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`$\x92R`\x11`\x04R\xFD[`$\x82\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x11`\x04R\xFD[`\x04\x82\x7F\xD6\x93h\xD4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[P4a\x02;W` `\x03\x196\x01\x12a\x02;Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x04\x8Ea\x18YV[a\x04\x96a\"\xE4V[\x16\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F\\m\x17t\xBD\xD6\x9D\x8D\x16\x84|<\x97\xB5\x1E\xA742W\xB8\xF5\xAC\xE5\xDA\x9E%\xAB;\xAF\xD7\xD5\0T\x16\x17\x7F\\m\x17t\xBD\xD6\x9D\x8D\x16\x84|<\x97\xB5\x1E\xA742W\xB8\xF5\xAC\xE5\xDA\x9E%\xAB;\xAF\xD7\xD5\0U\x7F%5\x80\xF8\x06t\x1C\x11\xB3\xD4\xAA`\xD9\xCA\xCC[\xEF\x0C\xEB\xB3WHv\x7F\xE2?\x11\x91n/\x04\xB9\x82\x80\xA2\x80\xF3[P4a\x02;W` `\x03\x196\x01\x12a\x02;W` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFs\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\x81a\x05ma\x18YV[\x16\x01\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@Q\x91\x16\x81R\xF3[P4a\x02;W\x80`\x03\x196\x01\x12a\x02;W` `@Qs\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\x81R\xF3[P4a\x02;W` `\x03\x196\x01\x12a\x02;W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x029W6`#\x82\x01\x12\x15a\x029W\x80`\x04\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x06\x1BW6`$\x82`\x05\x1B\x84\x01\x01\x11a\x06\x1BW`$a\x02\x8F\x92\x01a 3V[\x82\x80\xFD[P4a\x02;W\x80`\x03\x196\x01\x12a\x02;W` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x02T\x16`@Q\x90\x81R\xF3[P4a\x02;W\x80`\x03\x196\x01\x12a\x02;W` `@Q\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\0\x81R\xF3[P4a\x02;W\x80`\x03\x196\x01\x12a\x02;W` a\x06\xA9a\x1F\xF5V[`@Q\x90\x81R\xF3[P4a\x02;W\x80`\x03\x196\x01\x12a\x02;W` `\xFF`\x02T`\xA0\x1C\x16`@Q\x90\x15\x15\x81R\xF3[P4a\x02;W\x80`\x03\x196\x01\x12a\x02;W` g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T\x16`@Q\x90\x81R\xF3[P4a\x02;W\x80`\x03\x196\x01\x12a\x02;WPa\x07\x7F`@Qa\x07A`@\x82a\x18\xE4V[`\x05\x81R\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01R`@Q\x91\x82\x91` \x83R` \x83\x01\x90a\x19\x96V[\x03\x90\xF3[P4a\x02;W\x80`\x03\x196\x01\x12a\x02;W` `@Qb'\x8D\0\x81R\xF3[P4a\x02;W\x80`\x03\x196\x01\x12a\x02;W` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0T\x16`@Q\x90\x81R\xF3[P4a\x02;W\x80`\x03\x196\x01\x12a\x02;W` `\xFF\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\0T\x16`@Q\x90\x15\x15\x81R\xF3[P4a\x02;W`\xC0`\x03\x196\x01\x12a\x02;Wa\x08Pa\x18\x9FV[`d5\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x06\x1BW`\xA45\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x08\xA9Wa\x08\x95a\x02\x8F\x936\x90`\x04\x01a\x18\xB6V[\x92\x90\x91`\x845\x91`D5\x90`$5\x90a\x1E\xD6V[\x83\x80\xFD[P4a\x02;W\x80`\x03\x196\x01\x12a\x02;WP`\x01Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80a\t7WP` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0T\x16[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@Q\x91\x16\x81R\xF3[` \x90a\t\x19V[P4a\x02;W```\x03\x196\x01\x12a\x02;Wa\tYa\x18YV[\x90a\tba\x18|V[\x90`D5\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x02;W` a\t\x90\x85\x85a\t\x8A6`\x04\x88\x01a\x19PV[\x91a\x1D\xE6V[`@Q\x90\x15\x15\x81R\xF3[P4a\x02;W\x80`\x03\x196\x01\x12a\x02;W` `@Qch\x8DF\xF0\x81R\xF3[P4a\x02;W\x80`\x03\x196\x01\x12a\x02;Wa\t\xD2a\"\xE4V[\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0U\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x82\x80\xA3\x80\xF3[P4a\x02;W` `\x03\x196\x01\x12a\x02;W` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xEF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81a\n\xCAa\x18YV[\x16\x01\x16`@Q\x90\x81R\xF3[P4a\x02;W\x80`\x03\x196\x01\x12a\x02;W` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01T\x16`@Q\x90\x81R\xF3[P4a\x02;W` `\x03\x196\x01\x12a\x02;W`@` \x91s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x0B=a\x18YV[\x16\x81R`\x03\x83R T`@Q\x90\x81R\xF3[P4a\x02;W\x80`\x03\x196\x01\x12a\x02;W` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\\m\x17t\xBD\xD6\x9D\x8D\x16\x84|<\x97\xB5\x1E\xA742W\xB8\xF5\xAC\xE5\xDA\x9E%\xAB;\xAF\xD7\xD5\0T\x16`@Q\x90\x81R\xF3[P4a\x02;W\x80`\x03\x196\x01\x12a\x02;Wa\x0B\xBAa\"\xE4V[\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\0T`\xFF\x81\x16\x15a\x0C,W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x16\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\0U\x80\xF3[`\x04\x82\x7F\xCD`\xC3\xCA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[P4a\x02;W` `\x03\x196\x01\x12a\x02;W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x029Wa\x0C\x89a\x02\x8F\x916\x90`\x04\x01a\x18\xB6V[\x90a\x1C\xBAV[P4a\x02;W\x80`\x03\x196\x01\x12a\x02;Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x160\x03a\r\x07W` `@Q\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x81R\xF3[\x80\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x04\x92R\xFD[P`@`\x03\x196\x01\x12a\x10\xDFWa\rDa\x18YV[\x90`$5g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x10\xDFWa\re\x906\x90`\x04\x01a\x19PV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x800\x14\x90\x81\x15a\x11\xCFW[Pa\x11\xA7Wa\r\xB4a\"\xE4V[`\x02T\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16`@Q\x92\x7F\rKK\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x86\x16\x93\x84`\x04\x82\x01R` \x81`$\x81\x86Z\xFA\x90\x81\x15a\x10\xD4W_\x91a\x11xW[P\x15a\x10\xE3W[P_T\x81;\x15a\x10\xDFW_\x91`D\x83\x92`@Q\x94\x85\x93\x84\x92\x7F\x07\xA9\xBE\xE7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84R`\x04\x84\x01R\x88`$\x84\x01RZ\xF1\x80\x15a\x10\xD4Wa\x10\xBFW[P`@Q\x93\x7FR\xD1\x90-\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85R` \x85`\x04\x81\x86Z\xFA\x80\x95\x85\x96a\x10\x87W[Pa\x0E\xF0W`$\x84\x84\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82R`\x04R\xFD[\x90\x91\x84\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x81\x03a\x10\\WP\x81;\x15a\x101W\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCT\x16\x17\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCU\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;\x84\x80\xA2\x81Q\x83\x90\x15a\x0F\xFEW\x80\x83` a\x0F\xF2\x95Q\x91\x01\x84Z\xF4=\x15a\x0F\xF6W=\x91a\x0F\xD6\x83a\x194V[\x92a\x0F\xE4`@Q\x94\x85a\x18\xE4V[\x83R=\x85` \x85\x01>a$\x94V[P\x80\xF3[``\x91a$\x94V[PPP4a\x10\tW\x80\xF3[\x80\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x04\x92R\xFD[\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84R`\x04R`$\x83\xFD[\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85R`\x04R`$\x84\xFD[\x90\x95P` \x81=` \x11a\x10\xB7W[\x81a\x10\xA3` \x93\x83a\x18\xE4V[\x81\x01\x03\x12a\x10\xB3WQ\x94_a\x0E\xBFV[\x84\x80\xFD[=\x91Pa\x10\x96V[a\x10\xCC\x91\x93P_\x90a\x18\xE4V[_\x91_a\x0E\x85V[`@Q=_\x82>=\x90\xFD[_\x80\xFD[`\xA0\x1C`\xFF\x16\x15a\x10\xF4W_a\x0E2V[`\x84`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`(`$\x82\x01R\x7FUpgrade would result in gas trac`D\x82\x01R\x7Fking ban\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R\xFD[a\x11\x9A\x91P` =` \x11a\x11\xA0W[a\x11\x92\x81\x83a\x18\xE4V[\x81\x01\x90a\x1D\xCEV[_a\x0E+V[P=a\x11\x88V[\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90Ps\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCT\x16\x14\x15_a\r\xA7V[4a\x10\xDFW` `\x03\x196\x01\x12a\x10\xDFW`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x10\xDFWa\x12Ea\x12K\x916\x90`\x04\x01a\x18\xB6V[\x90a\x1B\xA9V[\0[4a\x10\xDFW` `\x03\x196\x01\x12a\x10\xDFW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x12\x87a\x18YV[a\x12\x8Fa\"\xE4V[`\x01Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x16\x92\x16\x92\x83\x91\x16\x17`\x01U\x81\x15\x15_\x14a\x12\xE3W\x7F\x16\xAE1yaZ(\x15X;ef\xEA\xE6\xF7\x83\xB2T\x19E,\0Y\x9A\xEE\xB0\x10\x88\xF1>\xCA\x1A_\x80\xA3\0[\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91P\x7F\x16\xAE1yaZ(\x15X;ef\xEA\xE6\xF7\x83\xB2T\x19E,\0Y\x9A\xEE\xB0\x10\x88\xF1>\xCA\x1A_\x80\xA3\0[4a\x10\xDFW`\xA0`\x03\x196\x01\x12a\x10\xDFWa\x13\\a\x18\x9FV[`D5\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x10\xDFW`\x845\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x10\xDFW` \x92a\x13\xA4a\x06\xA9\x936\x90`\x04\x01a\x18\xB6V[\x92\x90\x91`d5\x91`$5\x90a\x19\xC8V[4a\x10\xDFW_`\x03\x196\x01\x12a\x10\xDFW` `@Q\x7F\\m\x17t\xBD\xD6\x9D\x8D\x16\x84|<\x97\xB5\x1E\xA742W\xB8\xF5\xAC\xE5\xDA\x9E%\xAB;\xAF\xD7\xD5\0\x81R\xF3[4a\x10\xDFW```\x03\x196\x01\x12a\x10\xDFWa\x14\x07a\x18YV[a\x14\x0Fa\x18|V[\x90`D5\x90\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T\x92`\xFF\x84`@\x1C\x16\x15\x93g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x80\x15\x90\x81a\x17?W[`\x01\x14\x90\x81a\x175W[\x15\x90\x81a\x17,W[Pa\x17\x04W\x84`\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\x83\x16\x17\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0Ua\x16\xAFW[P\x82\x15a\x16QWa\x14\xF1s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92a\x14\xE1a$=V[a\x14\xE9a$=V[a\x02\x8Aa$=V[\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F\\m\x17t\xBD\xD6\x9D\x8D\x16\x84|<\x97\xB5\x1E\xA742W\xB8\xF5\xAC\xE5\xDA\x9E%\xAB;\xAF\xD7\xD5\0T\x16\x17\x7F\\m\x17t\xBD\xD6\x9D\x8D\x16\x84|<\x97\xB5\x1E\xA742W\xB8\xF5\xAC\xE5\xDA\x9E%\xAB;\xAF\xD7\xD5\0Ua\x15aa$=V[a\x15ia!\xE1V[_U`\x02T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16\x91\x16\x17`\x02Ua\x15\xBEW\0[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T\x16\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0U\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2` `@Q`\x01\x81R\xA1\0[`d`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x18`$\x82\x01R\x7FApp chain ID cannot be 0\0\0\0\0\0\0\0\0`D\x82\x01R\xFD[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\x16h\x01\0\0\0\0\0\0\0\x01\x17\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0U\x84a\x14\xB9V[\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90P\x15\x86a\x14fV[0;\x15\x91Pa\x14^V[\x86\x91Pa\x14TV[4a\x10\xDFW` `\x03\x196\x01\x12a\x10\xDFW`\x045_R\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\x01` R` `@_ T`@Q\x90\x81R\xF3[4a\x10\xDFW` `\x03\x196\x01\x12a\x10\xDFW`\x045\x80\x15a\x181W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x01\x90\x81\x11a\x18\x04Wb'\x8D\0\x81\x02\x90\x80\x82\x04b'\x8D\0\x14\x90\x15\x17\x15a\x18\x04Wch\x8DF\xF0\x01\x90\x81ch\x8DF\xF0\x11a\x18\x04W` \x91\x81R\xF3[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[\x7F\xD6\x93h\xD4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[`\x045\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x10\xDFWV[`$5\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x10\xDFWV[`\x045\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x10\xDFWV[\x91\x81`\x1F\x84\x01\x12\x15a\x10\xDFW\x825\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x10\xDFW` \x83\x81\x86\x01\x95\x01\x01\x11a\x10\xDFWV[\x90`\x1F`\x1F\x19\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x19\x07W`@RV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x19\x07W`\x1F\x01`\x1F\x19\x16` \x01\x90V[\x81`\x1F\x82\x01\x12\x15a\x10\xDFW\x805\x90a\x19g\x82a\x194V[\x92a\x19u`@Q\x94\x85a\x18\xE4V[\x82\x84R` \x83\x83\x01\x01\x11a\x10\xDFW\x81_\x92` \x80\x93\x01\x83\x86\x017\x83\x01\x01R\x90V[\x90`\x1F\x19`\x1F` \x80\x94\x80Q\x91\x82\x91\x82\x87R\x01\x86\x86\x01^_\x85\x82\x86\x01\x01R\x01\x16\x01\x01\x90V[\x91\x90\x82\x03\x91\x82\x11a\x18\x04WV[\x95\x94\x93\x92\x91\x90`\xFF\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\0T\x16\x15a\x1A\x1CW\x92a\x1A\r\x92a\x1A\x1A\x95\x92a\x1A\x15\x95Z\x99a\x1A)V[\x93Z\x90a\x19\xBBV[a\"\x81V[V[a\x1A&\x95\x96a\x1A)V[\x90V[\x91\x903_R`\x03` R`@_ \x95\x86T\x96\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x88\x14a\x18\x04W`\x01\x88\x01\x90U`@Q\x953s\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\x01s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90a\x1B3\x96s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x89\x96` \x96g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xB5\x9A\x8E\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\x8A\x99\x8D\x8D`\x01`\xF8\x1B\x91\x01R``\x1B\x16`!\x8D\x01R`5\x8C\x01R\x16`U\x8A\x01R`u\x89\x01R\x16`\x95\x87\x01R\x86\x86\x01R`\xD5\x85\x017\x82\x01\x01\x82\x81\x01_\x81RP\x03\x01`\x1F\x19\x81\x01\x83R\x82a\x18\xE4V[a\x1B>\x8123a\x1D\xE6V[\x15a\x1B\x81W\x7F\x836;x\xBD\xFB\xB2>*a\xDBz\xCC\xC3\xC0\x1F\xDA)\xC5\xC5\xEC\x81\x88\x80\x03\xCB\x96)\x12a\x8A\x7F`@Q` \x81R\x80a\x1B{3\x94` \x83\x01\x90a\x19\x96V[\x03\x90\xA2\x90V[\x7F\xDCt\x14X\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90`\xFF\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\0T\x16\x15a\x1B\xEDWa\x1A\x1A\x91a\x1B\xE6a\x1A\x15\x92Z\x92a\x1B\xF2V[Z\x90a\x19\xBBV[a\x1A\x1A\x91[\x81\x15a\x1C\x92W`!a\x1CE\x91\x83`@Q\x94\x85\x92\x7F\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x85\x01R\x84\x84\x017\x81\x01_\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a\x18\xE4V[a\x1CP\x8123a\x1D\xE6V[\x15a\x1B\x81W\x7F\x836;x\xBD\xFB\xB2>*a\xDBz\xCC\xC3\xC0\x1F\xDA)\xC5\xC5\xEC\x81\x88\x80\x03\xCB\x96)\x12a\x8A\x7F`@Q` \x81R\x80a\x1C\x8D3\x94` \x83\x01\x90a\x19\x96V[\x03\x90\xA2V[\x7F\xDC7\xF5\x1D\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90`\xFF\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\0T\x16\x15a\x1C\xF7Wa\x1A\x1A\x91a\x1B\xE6a\x1A\x15\x92Z\x92a\x1C\xFCV[a\x1A\x1A\x91[\x81\x15a\x1C\x92Wa\x1DD`@Q\x7F\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01R`\x01\x81Ra\x1D=`!\x82a\x18\xE4V[23a\x1D\xE6V[\x15a\x1B\x81W`!a\x1D\x96\x91\x83`@Q\x94\x85\x92\x7F\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x85\x01R\x84\x84\x017\x81\x01_\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a\x18\xE4V[\x7F\x836;x\xBD\xFB\xB2>*a\xDBz\xCC\xC3\xC0\x1F\xDA)\xC5\xC5\xEC\x81\x88\x80\x03\xCB\x96)\x12a\x8A\x7F`@Q` \x81R\x80a\x1C\x8D3\x94` \x83\x01\x90a\x19\x96V[\x90\x81` \x91\x03\x12a\x10\xDFWQ\x80\x15\x15\x81\x03a\x10\xDFW\x90V[\x91\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\\m\x17t\xBD\xD6\x9D\x8D\x16\x84|<\x97\xB5\x1E\xA742W\xB8\xF5\xAC\xE5\xDA\x9E%\xAB;\xAF\xD7\xD5\0T\x16\x80\x15\x92\x83\x15a\x1E2W[PPP\x90P\x90V[` \x93Ps\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x94a\x1E\x9B\x86\x92`@Q\x97\x88\x96\x87\x95\x86\x95\x7Fz9y\xDC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x87R\x16`\x04\x86\x01R\x16`$\x84\x01R```D\x84\x01R`d\x83\x01\x90a\x19\x96V[\x03\x91Z\xFA\x90\x81\x15a\x10\xD4W_\x91a\x1E\xB7W[P\x80_\x80\x80a\x1E*V[a\x1E\xD0\x91P` =` \x11a\x11\xA0Wa\x11\x92\x81\x83a\x18\xE4V[_a\x1E\xADV[\x95\x94\x93\x92\x91\x90`\xFF\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\0T\x16\x15a\x1F\x1DW\x92a\x1A\x15\x95\x92a\x1A\x1A\x97\x95\x92a\x1B\xE6\x95Z\x97a\x1F\"V[a\x1A\x1A\x96[`@Q\x96\x90\x95\x93\x94\x92\x93\x91\x92\x90\x913s\x10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\x01s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xB5\x97\x8A\x97` \x97g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x1CE\x9C\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\x8A\x99\x8D\x8D_`\xF8\x1B\x91\x01R``\x1B\x16`!\x8D\x01R\x16`5\x8B\x01R`U\x8A\x01R`u\x89\x01R\x16`\x95\x87\x01R\x86\x86\x01R`\xD5\x85\x017\x82\x01\x01\x82\x81\x01_\x81RP\x03\x01`\x1F\x19\x81\x01\x83R\x82a\x18\xE4V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x97r\xB9\x10B\x01B\x81\x11a\x18\x04Wb'\x8D\0\x90\x04`\x01\x81\x01\x80\x91\x11a\x18\x04W\x90V[\x90`\xFF\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\0T\x16\x15a pWa\x1A\x1A\x91a\x1B\xE6a\x1A\x15\x92Z\x92a!\x06V[a\x1A\x1A\x91a!\x06V[\x91\x90\x81\x10\x15a \xD9W`\x05\x1B\x81\x015\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE1\x816\x03\x01\x82\x12\x15a\x10\xDFW\x01\x90\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x10\xDFW` \x01\x826\x03\x81\x13a\x10\xDFW\x91\x90V[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[\x90\x80\x15a\x1C\x92W_[\x81\x81\x10a!\x1BWPPPV[a!&\x81\x83\x85a yV[\x90P\x15a\x1C\x92W\x80`!a!\x89a!@`\x01\x94\x86\x88a yV[\x92\x90\x83`@Q\x94\x85\x92\x7F\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x85\x01R\x84\x84\x017\x81\x01_\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a\x18\xE4V[a!\x94\x8123a\x1D\xE6V[a!\xA0W[P\x01a!\x0FV[\x7F\x836;x\xBD\xFB\xB2>*a\xDBz\xCC\xC3\xC0\x1F\xDA)\xC5\xC5\xEC\x81\x88\x80\x03\xCB\x96)\x12a\x8A\x7F`@Q` \x81R\x80a!\xD83\x94` \x83\x01\x90a\x19\x96V[\x03\x90\xA2_a!\x99V[\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\0T`\x01`\xFF\x82\x16\x15\x15\x14a\"YW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x16`\x01\x17\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\0UV[\x7Fvy@\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[a\"\x89a\x1F\xF5V[:\x91:\x15a\"\xDBW[\x82\x81\x02\x92\x81\x84\x04\x14\x90\x15\x17\x15a\x18\x04W_R\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\x01` R`@_ \x80T\x91\x82\x01\x80\x92\x11a\x18\x04WUV[`\x01\x92Pa\"\x92V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0T\x163\x03a#$WV[\x7F\x11\x8C\xDA\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R3`\x04R`$_\xFD[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80\x15a$\x11Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0T\x82\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x17\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0U\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0_\x80\xA3V[\x7F\x1EO\xBD\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R_`\x04R`$_\xFD[`\xFF\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T`@\x1C\x16\x15a$lWV[\x7F\xD7\xE6\xBC\xF8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90a$\xD1WP\x80Q\x15a$\xA9W\x80Q\x90` \x01\xFD[\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x81Q\x15\x80a%$W[a$\xE2WP\x90V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R\x16`\x04R`$_\xFD[P\x80;\x15a$\xDAV\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\xFE\xFE\xA1\xBB\x0Bb;\x9E\xF9?6`\xA2\xC6#\x9CGL\xD8\xDD\x14\x1A\xAF`\xEB\x9Bk\xC0\xB3\x89Q,\xE8E\x08\xF2\xC7\xFA\x9C5\x11Ft\x8B0%\xCBx\xB4]\xF3}\x86\x8EH\xC6\xA7Q\x02\xFE\xCD\xEE\xE6E\xAD2(\xB6v\xF7\xD3\xCDB\x84\xA5D?\x17\xF1\x96+6\xE4\x91\xB3\n@\xB2@XI\xE5\x97\xBA_\xB5",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x6080806040526004361015610012575f80fd5b5f905f3560e01c908162b68a73146118465750806301ffc9a7146117a557806307a9bee7146116db57806309d23e24146116a35780630d4b4bda146116595780631d1ab15a14611539578063248a9ca31461150f578063297f4c64146114f25780632f2ff15d146114b55780633144e8531461146757806332ed6805146113c957806336568abe1461135d5780633f4ba83a146112de57806356dba7791461128e5780635bd6588b146111455780635c975abb146111235780636389f8da146110c757806367a5fb2c14610cce5780636ae7e70314610cac5780636ff6f6c014610c6c5780637232c13314610c2a5780637c16ffc414610bb15780638456cb5914610b575780638b35ba2514610aeb5780638c39aaa4146108b25780638de6e28c1461088f57806391d1485414610838578063999d71d41461081a5780639e15d6ff14610631578063a217fddf146107fe578063aae7238c146106e2578063b416663e146106c6578063b963ebf314610660578063c112ee8c14610631578063ca4cd02514610578578063d547741f14610531578063ec87621c146104f6578063ee5ee73c14610423578063eeeb44ad1461020b5763ff76aed6146101d5575f80fd5b34610208578060031936011261020857602073ffffffffffffffffffffffffffffffffffffffff60075416604051908152f35b80fd5b50346102085760206003193601126102085773ffffffffffffffffffffffffffffffffffffffff61023a611883565b610242611bd3565b16808252600960205260ff604083205416156103fb5773ffffffffffffffffffffffffffffffffffffffff6007541681146103d357815b600854808210156103cc578273ffffffffffffffffffffffffffffffffffffffff6102a3846118eb565b90549060031b1c16146102b95750600101610279565b5f19810190811161039f57906102f773ffffffffffffffffffffffffffffffffffffffff6102e9610323946118eb565b90549060031b1c16916118eb565b90919073ffffffffffffffffffffffffffffffffffffffff8084549260031b9316831b921b1916179055565b6008548015610372575f1901610338816118eb565b73ffffffffffffffffffffffffffffffffffffffff82549160031b1b191690556008555b815260096020526040812060ff19815416905580f35b6024837f4e487b710000000000000000000000000000000000000000000000000000000081526031600452fd5b6024847f4e487b710000000000000000000000000000000000000000000000000000000081526011600452fd5b505061035c565b6004827fd5cc4a0f000000000000000000000000000000000000000000000000000000008152fd5b6004827ffb101809000000000000000000000000000000000000000000000000000000008152fd5b5034610208576020600319360112610208576104f2906104de610444611883565b6102729260206040519261045a8287018561194c565b858452818401956121a087396040516104af816104a1858201948573ffffffffffffffffffffffffffffffffffffffff606092168152604060208201525f60408201520190565b03601f19810183528261194c565b6040519687955180918588015e85019083820190858252519283915e010190815203601f19810183528261194c565b604051918291602083526020830190611987565b0390f35b503461020857806003193601126102085760206040517f241ecf16d79d0f8dbfb92cbc07fe17840425976cf0667f022fe9877caa831b088152f35b503461020857604060031936011261020857610574600435610551611860565b9061056f61056a825f525f602052600160405f20015490565b611c3b565b611d55565b5080f35b503461020857806003193601126102085773ffffffffffffffffffffffffffffffffffffffff6055600b602093610735604051906105b88782018361194c565b8082528682019061241282396105ec87604051809382820195518091875e810186838201520301601f19810183528261194c565b51902090506040519060408201527f53594e4449434154455f535455425f5631000000000000000000000000000000858201523081520160ff81532016604051908152f35b50346102085760206003193601126102085760ff60406020926004358152600a84522054166040519015158152f35b5034610208576020600319360112610208576004358152600460205260ff60408220541660405190600381101561069957602092508152f35b6024837f4e487b710000000000000000000000000000000000000000000000000000000081526021600452fd5b50346102085780600319360112610208576104f26104de611ae2565b50346102085760206003193601126102085760043567ffffffffffffffff81116107fa57366023820112156107fa578060040135906107208261196f565b9161072e604051938461194c565b8083526024602084019160051b830101913683116107f657602401905b8282106107e65750505061075f81516119e6565b825b82518110156107d0578061077760019285611a17565b518552600a60205260ff60408620541615610793575b01610761565b61079d8185611a17565b518552600560205273ffffffffffffffffffffffffffffffffffffffff6040862054166107ca8285611a17565b5261078d565b604051602080825281906104f290820185611903565b813581526020918201910161074b565b8480fd5b5080fd5b5034610208578060031936011261020857602090604051908152f35b50346102085780600319360112610208576020600354604051908152f35b50346102085760406003193601126102085773ffffffffffffffffffffffffffffffffffffffff6040610869611860565b926004358152806020522091165f52602052602060ff60405f2054166040519015158152f35b503461020857806003193601126102085760206108aa611a55565b604051908152f35b5034610208576020600319360112610208576004357f241ecf16d79d0f8dbfb92cbc07fe17840425976cf0667f022fe9877caa831b088252816020526040822073ffffffffffffffffffffffffffffffffffffffff33165f5260205260ff60405f20541615610a9b578015610a1757808252600460205260ff6040832054166003811015610699576002610947911415611e33565b808252600460205260408220600160ff19825416179055600a8104805b6109a3575060407fd9e1239177bfbd2aebf5d0f20fc075e6df5a502c59d121acd57342c783e3136491600254908060025582519182526020820152a180f35b808352600460205260ff60408420541660038110156109ea57906109cc6001600a931415611e33565b808452600460205260408420600260ff198254161790550480610964565b6024847f4e487b710000000000000000000000000000000000000000000000000000000081526021600452fd5b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f6e616d65737061636520707265666978206f66203020697320666f726269646460448201527f656e0000000000000000000000000000000000000000000000000000000000006064820152fd5b6044827fe2517d3f000000000000000000000000000000000000000000000000000000008152336004527f241ecf16d79d0f8dbfb92cbc07fe17840425976cf0667f022fe9877caa831b08602452fd5b50346102085760406003193601126102085760043573ffffffffffffffffffffffffffffffffffffffff610b1d611860565b610b25611bd3565b610b2e83611b95565b16907febb4c50deb285192d1c2aa8832b1feeb078ba0fd92bb439c0dee28ebe9bb36e98380a380f35b5034610208578060031936011261020857610b70611bd3565b610b78611dff565b600160ff19815416176001557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586020604051338152a180f35b50346102085760206003193601126102085773ffffffffffffffffffffffffffffffffffffffff610be0611883565b610be8611bd3565b16808252600960205260ff604083205416156103fb577fffffffffffffffffffffffff0000000000000000000000000000000000000000600754161760075580f35b50346102085760206003193601126102085773ffffffffffffffffffffffffffffffffffffffff60406020926004358152600584522054161515604051908152f35b50346102085760206003193601126102085773ffffffffffffffffffffffffffffffffffffffff6040602092600435815260058452205416604051908152f35b503461020857806003193601126102085760206108aa600654600b54906119ac565b5034610fa8576060600319360112610fa85760043590610cec611860565b916044359273ffffffffffffffffffffffffffffffffffffffff8416809403610fa85773ffffffffffffffffffffffffffffffffffffffff90610d2d611dff565b1692831580156110bf575b6110975781159182156110915750610d4e611a55565b915b825f52600560205273ffffffffffffffffffffffffffffffffffffffff60405f20541661106957611056575b610d84611ae2565b80511561102e57805183916020015ff5903d1519821516610f9d5773ffffffffffffffffffffffffffffffffffffffff821691821561100657835f52600560205260405f20837fffffffffffffffffffffffff000000000000000000000000000000000000000082541617905560065468010000000000000000811015610fd9575f91610e188260018594016006556118a6565b81549060031b905f1989831b921b19161790556040517f1794bb3c00000000000000000000000000000000000000000000000000000000602082015230602482015284604482015286606482015260648152610e7560848261194c565b826104a1610eda73ffffffffffffffffffffffffffffffffffffffff600754169360405192839160208301967f4f1ef2860000000000000000000000000000000000000000000000000000000088526024840152604060448401526064830190611987565b51925af13d15610fd4573d610eee81611a39565b90610efc604051928361194c565b81525f60203d92013e5b15610fac57813b15610fa857604051947ff2fde38b00000000000000000000000000000000000000000000000000000000865260048601525f8560248183865af1948515610f9d57604095610f88575b5081837f49b21f1e4190db8b0a933c951ed013de222c847c15461754682daa2eab1fdbd287519680a482526020820152f35b610f959194505f9061194c565b5f925f610f56565b6040513d5f823e3d90fd5b5f80fd5b7fab6eb5bc000000000000000000000000000000000000000000000000000000005f5260045ffd5b610f06565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7fb06ebf3d000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f4ca249dc000000000000000000000000000000000000000000000000000000005f5260045ffd5b611061600354611a2b565b600355610d7c565b7f24591d89000000000000000000000000000000000000000000000000000000005f5260045ffd5b91610d50565b7fd92e233d000000000000000000000000000000000000000000000000000000005f5260045ffd5b508015610d38565b34610fa8576020600319360112610fa857602073ffffffffffffffffffffffffffffffffffffffff6055600b6110fb611ae2565b848151910120604051906040820152600435858201523081520160ff81532016604051908152f35b34610fa8575f600319360112610fa857602060ff600154166040519015158152f35b34610fa8575f600319360112610fa857600654611164600b54826119ac565b9061116e8261196f565b9061117c604051928361194c565b82825261119d61118b8461196f565b93601f196020850195013686376119e6565b905f5f5b8281106111f55750505060405191604083019060408452518091526060830193905f5b8181106111df5784806104f288878382036020850152611903565b82518652602095860195909201916001016111c4565b6111fe816118a6565b90549060031b1c5f52600a60205260ff60405f20541615611222575b6001016111a1565b90611286600191611232846118a6565b90549060031b1c6112438289611a17565b5261124d846118a6565b90549060031b1c5f52600560205273ffffffffffffffffffffffffffffffffffffffff60405f2054166112808288611a17565b52611a2b565b91905061121a565b34610fa8575f600319360112610fa857602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b34610fa8575f600319360112610fa8576112f6611bd3565b60015460ff8116156113355760ff19166001557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa6020604051338152a1005b7f8dfc202b000000000000000000000000000000000000000000000000000000005f5260045ffd5b34610fa8576040600319360112610fa857611376611860565b3373ffffffffffffffffffffffffffffffffffffffff8216036113a15761139f90600435611d55565b005b7f6697b232000000000000000000000000000000000000000000000000000000005f5260045ffd5b34610fa8575f600319360112610fa85760405180602060085491828152019060085f527ff3f7a9fe364faab93b216da50a3214154f22a0a2b415b23a84c8169e8b636ee3905f5b81811061143b576104f2856114278187038261194c565b604051918291602083526020830190611903565b825473ffffffffffffffffffffffffffffffffffffffff16845260209093019260019283019201611410565b34610fa8576020600319360112610fa857600435600854811015610fa85773ffffffffffffffffffffffffffffffffffffffff6114a56020926118eb565b90549060031b1c16604051908152f35b34610fa8576040600319360112610fa85761139f6004356114d4611860565b906114ed61056a825f525f602052600160405f20015490565b611ca1565b34610fa8575f600319360112610fa8576020600254604051908152f35b34610fa8576020600319360112610fa85760206108aa6004355f525f602052600160405f20015490565b34610fa8576040600319360112610fa857611552611883565b6024358015158103610fa857611566611bd3565b73ffffffffffffffffffffffffffffffffffffffff821691821561109757825f52600960205260ff60405f205416611631576008549068010000000000000000821015610fd9576102f78260016115c094016008556118eb565b815f52600960205260405f20600160ff19825416179055611602575b7f331cedc71f28c46d467691770675b586e8aa77a0d4fe09f257d01ef00bc154585f80a2005b807fffffffffffffffffffffffff000000000000000000000000000000000000000060075416176007556115dc565b7f1833a24b000000000000000000000000000000000000000000000000000000005f5260045ffd5b34610fa8576020600319360112610fa85773ffffffffffffffffffffffffffffffffffffffff611687611883565b165f526009602052602060ff60405f2054166040519015158152f35b34610fa8576020600319360112610fa857600435600654811015610fa8576116cc6020916118a6565b90549060031b1c604051908152f35b34610fa8576040600319360112610fa8576004356116f7611860565b815f52600560205273ffffffffffffffffffffffffffffffffffffffff60405f205416330361177d5773ffffffffffffffffffffffffffffffffffffffff1690815f52600960205260ff60405f2054161561174e57005b61175781611b95565b7febb4c50deb285192d1c2aa8832b1feeb078ba0fd92bb439c0dee28ebe9bb36e95f80a3005b7f2fd9adae000000000000000000000000000000000000000000000000000000005f5260045ffd5b34610fa8576020600319360112610fa8576004357fffffffff000000000000000000000000000000000000000000000000000000008116809103610fa857807f7965db0b000000000000000000000000000000000000000000000000000000006020921490811561181c575b506040519015158152f35b7f01ffc9a70000000000000000000000000000000000000000000000000000000091501482611811565b34610fa8575f600319360112610fa857602090600b548152f35b6024359073ffffffffffffffffffffffffffffffffffffffff82168203610fa857565b6004359073ffffffffffffffffffffffffffffffffffffffff82168203610fa857565b6006548110156118be5760065f5260205f2001905f90565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b6008548110156118be5760085f5260205f2001905f90565b90602080835192838152019201905f5b8181106119205750505090565b825173ffffffffffffffffffffffffffffffffffffffff16845260209384019390920191600101611913565b90601f601f19910116810190811067ffffffffffffffff821117610fd957604052565b67ffffffffffffffff8111610fd95760051b60200190565b90601f19601f602080948051918291828752018686015e5f8582860101520116010190565b919082039182116119b957565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b906119f08261196f565b6119fd604051918261194c565b828152601f19611a0d829461196f565b0190602036910137565b80518210156118be5760209160051b010190565b5f1981146119b95760010190565b67ffffffffffffffff8111610fd957601f01601f191660200190565b611ab16020611aa9611a68600254611e98565b8280611a75600354611e98565b6040519584879551918291018487015e8401908282015f8152815193849201905e01015f815203601f19810183528261194c565b80519061201d565b9015611aba5790565b7f94e2737e000000000000000000000000000000000000000000000000000000005f5260045ffd5b610272611b92604051611af8602084018261194c565b82815260208101926121a08439602060405181810190611b63816104a17f00000000000000000000000000000000000000000000000000000000000000008573ffffffffffffffffffffffffffffffffffffffff606092168152604060208201525f60408201520190565b6040519586945180918587015e840190838201905f8252519283915e01015f815203601f19810183528261194c565b90565b805f52600a60205260ff60405f20541615611bad5750565b5f52600a60205260405f20600160ff19825416179055611bce600b54611a2b565b600b55565b335f9081527fad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5602052604090205460ff1615611c0b57565b7fe2517d3f000000000000000000000000000000000000000000000000000000005f52336004525f60245260445ffd5b805f525f60205260405f2073ffffffffffffffffffffffffffffffffffffffff33165f5260205260ff60405f20541615611c725750565b7fe2517d3f000000000000000000000000000000000000000000000000000000005f523360045260245260445ffd5b805f525f60205260405f2073ffffffffffffffffffffffffffffffffffffffff83165f5260205260ff60405f205416155f14611d4f57805f525f60205260405f2073ffffffffffffffffffffffffffffffffffffffff83165f5260205260405f20600160ff1982541617905573ffffffffffffffffffffffffffffffffffffffff339216907f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d5f80a4600190565b50505f90565b805f525f60205260405f2073ffffffffffffffffffffffffffffffffffffffff83165f5260205260ff60405f2054165f14611d4f57805f525f60205260405f2073ffffffffffffffffffffffffffffffffffffffff83165f5260205260405f2060ff19815416905573ffffffffffffffffffffffffffffffffffffffff339216907ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b5f80a4600190565b60ff60015416611e0b57565b7fd93c0665000000000000000000000000000000000000000000000000000000005f5260045ffd5b15611e3a57565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f6e616d65737061636520636f6c6c6973696f6e206465746563746564000000006044820152fd5b805f917a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000821015611ff5575b806d04ee2d6d415b85acef8100000000600a921015611fda575b662386f26fc10000811015611fc6575b6305f5e100811015611fb5575b612710811015611fa6575b6064811015611f98575b1015611f8d575b600a5f1960216001850194601f19611f42611f2c88611a39565b97611f3a604051998a61194c565b808952611a39565b013660208801378501015b01917f30313233343536373839616263646566000000000000000000000000000000008282061a8353048015611f88575f19600a9192611f4d565b505090565b600190910190611f12565b606460029104930192611f0b565b61271060049104930192611f01565b6305f5e10060089104930192611ef6565b662386f26fc1000060109104930192611ee9565b6d04ee2d6d415b85acef810000000060209104930192611ed9565b50604091507a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008104611ebf565b90815181118015612043575b61203b575f6120379261204a565b9091565b50505f905f90565b505f612029565b5f9392905b81831061205f5750505060019190565b9092919360ff6120967fff0000000000000000000000000000000000000000000000000000000000000060208886010151166120d3565b16600981116120c857600a820291808304600a14901517156119b95781018091116119b957600190940191929061204f565b505f94508493505050565b60f81c602f811180612195575b1561210d577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd00160ff1690565b606081118061218b575b15612144577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa90160ff1690565b6040811180612181575b1561217b577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc90160ff1690565b5060ff90565b506047811061214e565b5060678110612117565b50603a81106120e056fe60806040526102728038038061001481610168565b92833981016040828203126101645781516001600160a01b03811692909190838303610164576020810151906001600160401b03821161016457019281601f8501121561016457835161006e610069826101a1565b610168565b9481865260208601936020838301011161016457815f926020809301865e86010152823b15610152577f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80546001600160a01b031916821790557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a282511561013a575f8091610122945190845af43d15610132573d91610113610069846101a1565b9283523d5f602085013e6101bc565b505b6040516057908161021b8239f35b6060916101bc565b50505034156101245763b398979f60e01b5f5260045ffd5b634c9c8ce360e01b5f5260045260245ffd5b5f80fd5b6040519190601f01601f191682016001600160401b0381118382101761018d57604052565b634e487b7160e01b5f52604160045260245ffd5b6001600160401b03811161018d57601f01601f191660200190565b906101e057508051156101d157805190602001fd5b63d6bda27560e01b5f5260045ffd5b81511580610211575b6101f1575090565b639996b31560e01b5f9081526001600160a01b0391909116600452602490fd5b50803b156101e956fe60806040525f8073ffffffffffffffffffffffffffffffffffffffff7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416368280378136915af43d5f803e156053573d5ff35b3d5ffd60a0806040523460295730608052610707908161002e82396080518181816101f001526103290152f35b5f80fdfe608060405260043610156100d0575b36156100725760646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f537475623a206e6f206c6f67696320696d706c656d656e7465640000000000006044820152fd5b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f537475623a20455448206e6f74206163636570746564000000000000000000006044820152fd5b5f3560e01c80634f1ef2861461026857806352d1902d146101ab5763ad3cb1cc0361000e57346101a7575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a757604080519061013281836105c6565b6005825260208201917f352e302e3000000000000000000000000000000000000000000000000000000083527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8351948593602085525180918160208701528686015e5f85828601015201168101030190f35b5f80fd5b346101a7575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a75773ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001630036102405760206040517f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8152f35b7fe07c8dba000000000000000000000000000000000000000000000000000000005f5260045ffd5b60407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a75760043573ffffffffffffffffffffffffffffffffffffffff8116908181036101a7576024359067ffffffffffffffff82116101a757366023830112156101a7578160040135916102e183610634565b926102ef60405194856105c6565b808452602084019136602483830101116101a757815f9260246020930185378501015273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016803014908115610584575b50610240576040517f52d1902d000000000000000000000000000000000000000000000000000000008152602081600481885afa5f9181610550575b506103c157847f4c9c8ce3000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b807f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8692036105255750823b156104fa57807fffffffffffffffffffffffff00000000000000000000000000000000000000007f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416177f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a28251156104c8575f80916104be945190845af43d156104c0573d916104a283610634565b926104b060405194856105c6565b83523d5f602085013e61066e565b005b60609161066e565b505050346104d257005b7fb398979f000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f4c9c8ce3000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b7faa1d49a4000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b9091506020813d60201161057c575b8161056c602093836105c6565b810103126101a757519086610390565b3d915061055f565b905073ffffffffffffffffffffffffffffffffffffffff7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416141585610354565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761060757604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b67ffffffffffffffff811161060757601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b906106ab575080511561068357805190602001fd5b7fd6bda275000000000000000000000000000000000000000000000000000000005f5260045ffd5b815115806106fe575b6106bc575090565b73ffffffffffffffffffffffffffffffffffffffff907f9996b315000000000000000000000000000000000000000000000000000000005f521660045260245ffd5b50803b156106b456
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80\x80`@R`\x046\x10\x15a\0\x12W_\x80\xFD[_\x90_5`\xE0\x1C\x90\x81b\xB6\x8As\x14a\x18FWP\x80c\x01\xFF\xC9\xA7\x14a\x17\xA5W\x80c\x07\xA9\xBE\xE7\x14a\x16\xDBW\x80c\t\xD2>$\x14a\x16\xA3W\x80c\rKK\xDA\x14a\x16YW\x80c\x1D\x1A\xB1Z\x14a\x159W\x80c$\x8A\x9C\xA3\x14a\x15\x0FW\x80c)\x7FLd\x14a\x14\xF2W\x80c//\xF1]\x14a\x14\xB5W\x80c1D\xE8S\x14a\x14gW\x80c2\xEDh\x05\x14a\x13\xC9W\x80c6V\x8A\xBE\x14a\x13]W\x80c?K\xA8:\x14a\x12\xDEW\x80cV\xDB\xA7y\x14a\x12\x8EW\x80c[\xD6X\x8B\x14a\x11EW\x80c\\\x97Z\xBB\x14a\x11#W\x80cc\x89\xF8\xDA\x14a\x10\xC7W\x80cg\xA5\xFB,\x14a\x0C\xCEW\x80cj\xE7\xE7\x03\x14a\x0C\xACW\x80co\xF6\xF6\xC0\x14a\x0ClW\x80cr2\xC13\x14a\x0C*W\x80c|\x16\xFF\xC4\x14a\x0B\xB1W\x80c\x84V\xCBY\x14a\x0BWW\x80c\x8B5\xBA%\x14a\n\xEBW\x80c\x8C9\xAA\xA4\x14a\x08\xB2W\x80c\x8D\xE6\xE2\x8C\x14a\x08\x8FW\x80c\x91\xD1HT\x14a\x088W\x80c\x99\x9Dq\xD4\x14a\x08\x1AW\x80c\x9E\x15\xD6\xFF\x14a\x061W\x80c\xA2\x17\xFD\xDF\x14a\x07\xFEW\x80c\xAA\xE7#\x8C\x14a\x06\xE2W\x80c\xB4\x16f>\x14a\x06\xC6W\x80c\xB9c\xEB\xF3\x14a\x06`W\x80c\xC1\x12\xEE\x8C\x14a\x061W\x80c\xCAL\xD0%\x14a\x05xW\x80c\xD5Gt\x1F\x14a\x051W\x80c\xEC\x87b\x1C\x14a\x04\xF6W\x80c\xEE^\xE7<\x14a\x04#W\x80c\xEE\xEBD\xAD\x14a\x02\x0BWc\xFFv\xAE\xD6\x14a\x01\xD5W_\x80\xFD[4a\x02\x08W\x80`\x03\x196\x01\x12a\x02\x08W` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x07T\x16`@Q\x90\x81R\xF3[\x80\xFD[P4a\x02\x08W` `\x03\x196\x01\x12a\x02\x08Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x02:a\x18\x83V[a\x02Ba\x1B\xD3V[\x16\x80\x82R`\t` R`\xFF`@\x83 T\x16\x15a\x03\xFBWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x07T\x16\x81\x14a\x03\xD3W\x81[`\x08T\x80\x82\x10\x15a\x03\xCCW\x82s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x02\xA3\x84a\x18\xEBV[\x90T\x90`\x03\x1B\x1C\x16\x14a\x02\xB9WP`\x01\x01a\x02yV[_\x19\x81\x01\x90\x81\x11a\x03\x9FW\x90a\x02\xF7s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x02\xE9a\x03#\x94a\x18\xEBV[\x90T\x90`\x03\x1B\x1C\x16\x91a\x18\xEBV[\x90\x91\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x84T\x92`\x03\x1B\x93\x16\x83\x1B\x92\x1B\x19\x16\x17\x90UV[`\x08T\x80\x15a\x03rW_\x19\x01a\x038\x81a\x18\xEBV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82T\x91`\x03\x1B\x1B\x19\x16\x90U`\x08U[\x81R`\t` R`@\x81 `\xFF\x19\x81T\x16\x90U\x80\xF3[`$\x83\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`1`\x04R\xFD[`$\x84\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x11`\x04R\xFD[PPa\x03\\V[`\x04\x82\x7F\xD5\xCCJ\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[`\x04\x82\x7F\xFB\x10\x18\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[P4a\x02\x08W` `\x03\x196\x01\x12a\x02\x08Wa\x04\xF2\x90a\x04\xDEa\x04Da\x18\x83V[a\x02r\x92` `@Q\x92a\x04Z\x82\x87\x01\x85a\x19LV[\x85\x84R\x81\x84\x01\x95a!\xA0\x879`@Qa\x04\xAF\x81a\x04\xA1\x85\x82\x01\x94\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF``\x92\x16\x81R`@` \x82\x01R_`@\x82\x01R\x01\x90V[\x03`\x1F\x19\x81\x01\x83R\x82a\x19LV[`@Q\x96\x87\x95Q\x80\x91\x85\x88\x01^\x85\x01\x90\x83\x82\x01\x90\x85\x82RQ\x92\x83\x91^\x01\x01\x90\x81R\x03`\x1F\x19\x81\x01\x83R\x82a\x19LV[`@Q\x91\x82\x91` \x83R` \x83\x01\x90a\x19\x87V[\x03\x90\xF3[P4a\x02\x08W\x80`\x03\x196\x01\x12a\x02\x08W` `@Q\x7F$\x1E\xCF\x16\xD7\x9D\x0F\x8D\xBF\xB9,\xBC\x07\xFE\x17\x84\x04%\x97l\xF0f\x7F\x02/\xE9\x87|\xAA\x83\x1B\x08\x81R\xF3[P4a\x02\x08W`@`\x03\x196\x01\x12a\x02\x08Wa\x05t`\x045a\x05Qa\x18`V[\x90a\x05oa\x05j\x82_R_` R`\x01`@_ \x01T\x90V[a\x1C;V[a\x1DUV[P\x80\xF3[P4a\x02\x08W\x80`\x03\x196\x01\x12a\x02\x08Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`U`\x0B` \x93a\x075`@Q\x90a\x05\xB8\x87\x82\x01\x83a\x19LV[\x80\x82R\x86\x82\x01\x90a$\x12\x829a\x05\xEC\x87`@Q\x80\x93\x82\x82\x01\x95Q\x80\x91\x87^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a\x19LV[Q\x90 \x90P`@Q\x90`@\x82\x01R\x7FSYNDICATE_STUB_V1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85\x82\x01R0\x81R\x01`\xFF\x81S \x16`@Q\x90\x81R\xF3[P4a\x02\x08W` `\x03\x196\x01\x12a\x02\x08W`\xFF`@` \x92`\x045\x81R`\n\x84R T\x16`@Q\x90\x15\x15\x81R\xF3[P4a\x02\x08W` `\x03\x196\x01\x12a\x02\x08W`\x045\x81R`\x04` R`\xFF`@\x82 T\x16`@Q\x90`\x03\x81\x10\x15a\x06\x99W` \x92P\x81R\xF3[`$\x83\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`!`\x04R\xFD[P4a\x02\x08W\x80`\x03\x196\x01\x12a\x02\x08Wa\x04\xF2a\x04\xDEa\x1A\xE2V[P4a\x02\x08W` `\x03\x196\x01\x12a\x02\x08W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x07\xFAW6`#\x82\x01\x12\x15a\x07\xFAW\x80`\x04\x015\x90a\x07 \x82a\x19oV[\x91a\x07.`@Q\x93\x84a\x19LV[\x80\x83R`$` \x84\x01\x91`\x05\x1B\x83\x01\x01\x916\x83\x11a\x07\xF6W`$\x01\x90[\x82\x82\x10a\x07\xE6WPPPa\x07_\x81Qa\x19\xE6V[\x82[\x82Q\x81\x10\x15a\x07\xD0W\x80a\x07w`\x01\x92\x85a\x1A\x17V[Q\x85R`\n` R`\xFF`@\x86 T\x16\x15a\x07\x93W[\x01a\x07aV[a\x07\x9D\x81\x85a\x1A\x17V[Q\x85R`\x05` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x86 T\x16a\x07\xCA\x82\x85a\x1A\x17V[Ra\x07\x8DV[`@Q` \x80\x82R\x81\x90a\x04\xF2\x90\x82\x01\x85a\x19\x03V[\x815\x81R` \x91\x82\x01\x91\x01a\x07KV[\x84\x80\xFD[P\x80\xFD[P4a\x02\x08W\x80`\x03\x196\x01\x12a\x02\x08W` \x90`@Q\x90\x81R\xF3[P4a\x02\x08W\x80`\x03\x196\x01\x12a\x02\x08W` `\x03T`@Q\x90\x81R\xF3[P4a\x02\x08W`@`\x03\x196\x01\x12a\x02\x08Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@a\x08ia\x18`V[\x92`\x045\x81R\x80` R \x91\x16_R` R` `\xFF`@_ T\x16`@Q\x90\x15\x15\x81R\xF3[P4a\x02\x08W\x80`\x03\x196\x01\x12a\x02\x08W` a\x08\xAAa\x1AUV[`@Q\x90\x81R\xF3[P4a\x02\x08W` `\x03\x196\x01\x12a\x02\x08W`\x045\x7F$\x1E\xCF\x16\xD7\x9D\x0F\x8D\xBF\xB9,\xBC\x07\xFE\x17\x84\x04%\x97l\xF0f\x7F\x02/\xE9\x87|\xAA\x83\x1B\x08\x82R\x81` R`@\x82 s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`\xFF`@_ T\x16\x15a\n\x9BW\x80\x15a\n\x17W\x80\x82R`\x04` R`\xFF`@\x83 T\x16`\x03\x81\x10\x15a\x06\x99W`\x02a\tG\x91\x14\x15a\x1E3V[\x80\x82R`\x04` R`@\x82 `\x01`\xFF\x19\x82T\x16\x17\x90U`\n\x81\x04\x80[a\t\xA3WP`@\x7F\xD9\xE1#\x91w\xBF\xBD*\xEB\xF5\xD0\xF2\x0F\xC0u\xE6\xDFZP,Y\xD1!\xAC\xD5sB\xC7\x83\xE3\x13d\x91`\x02T\x90\x80`\x02U\x82Q\x91\x82R` \x82\x01R\xA1\x80\xF3[\x80\x83R`\x04` R`\xFF`@\x84 T\x16`\x03\x81\x10\x15a\t\xEAW\x90a\t\xCC`\x01`\n\x93\x14\x15a\x1E3V[\x80\x84R`\x04` R`@\x84 `\x02`\xFF\x19\x82T\x16\x17\x90U\x04\x80a\tdV[`$\x84\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`!`\x04R\xFD[`\x84`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7Fnamespace prefix of 0 is forbidd`D\x82\x01R\x7Fen\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R\xFD[`D\x82\x7F\xE2Q}?\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R3`\x04R\x7F$\x1E\xCF\x16\xD7\x9D\x0F\x8D\xBF\xB9,\xBC\x07\xFE\x17\x84\x04%\x97l\xF0f\x7F\x02/\xE9\x87|\xAA\x83\x1B\x08`$R\xFD[P4a\x02\x08W`@`\x03\x196\x01\x12a\x02\x08W`\x045s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x0B\x1Da\x18`V[a\x0B%a\x1B\xD3V[a\x0B.\x83a\x1B\x95V[\x16\x90\x7F\xEB\xB4\xC5\r\xEB(Q\x92\xD1\xC2\xAA\x882\xB1\xFE\xEB\x07\x8B\xA0\xFD\x92\xBBC\x9C\r\xEE(\xEB\xE9\xBB6\xE9\x83\x80\xA3\x80\xF3[P4a\x02\x08W\x80`\x03\x196\x01\x12a\x02\x08Wa\x0Bpa\x1B\xD3V[a\x0Bxa\x1D\xFFV[`\x01`\xFF\x19\x81T\x16\x17`\x01U\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2X` `@Q3\x81R\xA1\x80\xF3[P4a\x02\x08W` `\x03\x196\x01\x12a\x02\x08Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x0B\xE0a\x18\x83V[a\x0B\xE8a\x1B\xD3V[\x16\x80\x82R`\t` R`\xFF`@\x83 T\x16\x15a\x03\xFBW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x07T\x16\x17`\x07U\x80\xF3[P4a\x02\x08W` `\x03\x196\x01\x12a\x02\x08Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@` \x92`\x045\x81R`\x05\x84R T\x16\x15\x15`@Q\x90\x81R\xF3[P4a\x02\x08W` `\x03\x196\x01\x12a\x02\x08Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@` \x92`\x045\x81R`\x05\x84R T\x16`@Q\x90\x81R\xF3[P4a\x02\x08W\x80`\x03\x196\x01\x12a\x02\x08W` a\x08\xAA`\x06T`\x0BT\x90a\x19\xACV[P4a\x0F\xA8W```\x03\x196\x01\x12a\x0F\xA8W`\x045\x90a\x0C\xECa\x18`V[\x91`D5\x92s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16\x80\x94\x03a\x0F\xA8Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90a\r-a\x1D\xFFV[\x16\x92\x83\x15\x80\x15a\x10\xBFW[a\x10\x97W\x81\x15\x91\x82\x15a\x10\x91WPa\rNa\x1AUV[\x91[\x82_R`\x05` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ T\x16a\x10iWa\x10VW[a\r\x84a\x1A\xE2V[\x80Q\x15a\x10.W\x80Q\x83\x91` \x01_\xF5\x90=\x15\x19\x82\x15\x16a\x0F\x9DWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x91\x82\x15a\x10\x06W\x83_R`\x05` R`@_ \x83\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82T\x16\x17\x90U`\x06Th\x01\0\0\0\0\0\0\0\0\x81\x10\x15a\x0F\xD9W_\x91a\x0E\x18\x82`\x01\x85\x94\x01`\x06Ua\x18\xA6V[\x81T\x90`\x03\x1B\x90_\x19\x89\x83\x1B\x92\x1B\x19\x16\x17\x90U`@Q\x7F\x17\x94\xBB<\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01R0`$\x82\x01R\x84`D\x82\x01R\x86`d\x82\x01R`d\x81Ra\x0Eu`\x84\x82a\x19LV[\x82a\x04\xA1a\x0E\xDAs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x07T\x16\x93`@Q\x92\x83\x91` \x83\x01\x96\x7FO\x1E\xF2\x86\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x88R`$\x84\x01R`@`D\x84\x01R`d\x83\x01\x90a\x19\x87V[Q\x92Z\xF1=\x15a\x0F\xD4W=a\x0E\xEE\x81a\x1A9V[\x90a\x0E\xFC`@Q\x92\x83a\x19LV[\x81R_` =\x92\x01>[\x15a\x0F\xACW\x81;\x15a\x0F\xA8W`@Q\x94\x7F\xF2\xFD\xE3\x8B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x86R`\x04\x86\x01R_\x85`$\x81\x83\x86Z\xF1\x94\x85\x15a\x0F\x9DW`@\x95a\x0F\x88W[P\x81\x83\x7FI\xB2\x1F\x1EA\x90\xDB\x8B\n\x93<\x95\x1E\xD0\x13\xDE\",\x84|\x15F\x17Th-\xAA.\xAB\x1F\xDB\xD2\x87Q\x96\x80\xA4\x82R` \x82\x01R\xF3[a\x0F\x95\x91\x94P_\x90a\x19LV[_\x92_a\x0FVV[`@Q=_\x82>=\x90\xFD[_\x80\xFD[\x7F\xABn\xB5\xBC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[a\x0F\x06V[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[\x7F\xB0n\xBF=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7FL\xA2I\xDC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[a\x10a`\x03Ta\x1A+V[`\x03Ua\r|V[\x7F$Y\x1D\x89\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x91a\rPV[\x7F\xD9.#=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[P\x80\x15a\r8V[4a\x0F\xA8W` `\x03\x196\x01\x12a\x0F\xA8W` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`U`\x0Ba\x10\xFBa\x1A\xE2V[\x84\x81Q\x91\x01 `@Q\x90`@\x82\x01R`\x045\x85\x82\x01R0\x81R\x01`\xFF\x81S \x16`@Q\x90\x81R\xF3[4a\x0F\xA8W_`\x03\x196\x01\x12a\x0F\xA8W` `\xFF`\x01T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x0F\xA8W_`\x03\x196\x01\x12a\x0F\xA8W`\x06Ta\x11d`\x0BT\x82a\x19\xACV[\x90a\x11n\x82a\x19oV[\x90a\x11|`@Q\x92\x83a\x19LV[\x82\x82Ra\x11\x9Da\x11\x8B\x84a\x19oV[\x93`\x1F\x19` \x85\x01\x95\x016\x867a\x19\xE6V[\x90__[\x82\x81\x10a\x11\xF5WPPP`@Q\x91`@\x83\x01\x90`@\x84RQ\x80\x91R``\x83\x01\x93\x90_[\x81\x81\x10a\x11\xDFW\x84\x80a\x04\xF2\x88\x87\x83\x82\x03` \x85\x01Ra\x19\x03V[\x82Q\x86R` \x95\x86\x01\x95\x90\x92\x01\x91`\x01\x01a\x11\xC4V[a\x11\xFE\x81a\x18\xA6V[\x90T\x90`\x03\x1B\x1C_R`\n` R`\xFF`@_ T\x16\x15a\x12\"W[`\x01\x01a\x11\xA1V[\x90a\x12\x86`\x01\x91a\x122\x84a\x18\xA6V[\x90T\x90`\x03\x1B\x1Ca\x12C\x82\x89a\x1A\x17V[Ra\x12M\x84a\x18\xA6V[\x90T\x90`\x03\x1B\x1C_R`\x05` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ T\x16a\x12\x80\x82\x88a\x1A\x17V[Ra\x1A+V[\x91\x90Pa\x12\x1AV[4a\x0F\xA8W_`\x03\x196\x01\x12a\x0F\xA8W` `@Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x81R\xF3[4a\x0F\xA8W_`\x03\x196\x01\x12a\x0F\xA8Wa\x12\xF6a\x1B\xD3V[`\x01T`\xFF\x81\x16\x15a\x135W`\xFF\x19\x16`\x01U\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA` `@Q3\x81R\xA1\0[\x7F\x8D\xFC +\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x0F\xA8W`@`\x03\x196\x01\x12a\x0F\xA8Wa\x13va\x18`V[3s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x03a\x13\xA1Wa\x13\x9F\x90`\x045a\x1DUV[\0[\x7Ff\x97\xB22\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x0F\xA8W_`\x03\x196\x01\x12a\x0F\xA8W`@Q\x80` `\x08T\x91\x82\x81R\x01\x90`\x08_R\x7F\xF3\xF7\xA9\xFE6O\xAA\xB9;!m\xA5\n2\x14\x15O\"\xA0\xA2\xB4\x15\xB2:\x84\xC8\x16\x9E\x8Bcn\xE3\x90_[\x81\x81\x10a\x14;Wa\x04\xF2\x85a\x14'\x81\x87\x03\x82a\x19LV[`@Q\x91\x82\x91` \x83R` \x83\x01\x90a\x19\x03V[\x82Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84R` \x90\x93\x01\x92`\x01\x92\x83\x01\x92\x01a\x14\x10V[4a\x0F\xA8W` `\x03\x196\x01\x12a\x0F\xA8W`\x045`\x08T\x81\x10\x15a\x0F\xA8Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x14\xA5` \x92a\x18\xEBV[\x90T\x90`\x03\x1B\x1C\x16`@Q\x90\x81R\xF3[4a\x0F\xA8W`@`\x03\x196\x01\x12a\x0F\xA8Wa\x13\x9F`\x045a\x14\xD4a\x18`V[\x90a\x14\xEDa\x05j\x82_R_` R`\x01`@_ \x01T\x90V[a\x1C\xA1V[4a\x0F\xA8W_`\x03\x196\x01\x12a\x0F\xA8W` `\x02T`@Q\x90\x81R\xF3[4a\x0F\xA8W` `\x03\x196\x01\x12a\x0F\xA8W` a\x08\xAA`\x045_R_` R`\x01`@_ \x01T\x90V[4a\x0F\xA8W`@`\x03\x196\x01\x12a\x0F\xA8Wa\x15Ra\x18\x83V[`$5\x80\x15\x15\x81\x03a\x0F\xA8Wa\x15fa\x1B\xD3V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x91\x82\x15a\x10\x97W\x82_R`\t` R`\xFF`@_ T\x16a\x161W`\x08T\x90h\x01\0\0\0\0\0\0\0\0\x82\x10\x15a\x0F\xD9Wa\x02\xF7\x82`\x01a\x15\xC0\x94\x01`\x08Ua\x18\xEBV[\x81_R`\t` R`@_ `\x01`\xFF\x19\x82T\x16\x17\x90Ua\x16\x02W[\x7F3\x1C\xED\xC7\x1F(\xC4mFv\x91w\x06u\xB5\x86\xE8\xAAw\xA0\xD4\xFE\t\xF2W\xD0\x1E\xF0\x0B\xC1TX_\x80\xA2\0[\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x07T\x16\x17`\x07Ua\x15\xDCV[\x7F\x183\xA2K\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x0F\xA8W` `\x03\x196\x01\x12a\x0F\xA8Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x16\x87a\x18\x83V[\x16_R`\t` R` `\xFF`@_ T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x0F\xA8W` `\x03\x196\x01\x12a\x0F\xA8W`\x045`\x06T\x81\x10\x15a\x0F\xA8Wa\x16\xCC` \x91a\x18\xA6V[\x90T\x90`\x03\x1B\x1C`@Q\x90\x81R\xF3[4a\x0F\xA8W`@`\x03\x196\x01\x12a\x0F\xA8W`\x045a\x16\xF7a\x18`V[\x81_R`\x05` Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@_ T\x163\x03a\x17}Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x81_R`\t` R`\xFF`@_ T\x16\x15a\x17NW\0[a\x17W\x81a\x1B\x95V[\x7F\xEB\xB4\xC5\r\xEB(Q\x92\xD1\xC2\xAA\x882\xB1\xFE\xEB\x07\x8B\xA0\xFD\x92\xBBC\x9C\r\xEE(\xEB\xE9\xBB6\xE9_\x80\xA3\0[\x7F/\xD9\xAD\xAE\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x0F\xA8W` `\x03\x196\x01\x12a\x0F\xA8W`\x045\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16\x80\x91\x03a\x0F\xA8W\x80\x7Fye\xDB\x0B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x92\x14\x90\x81\x15a\x18\x1CW[P`@Q\x90\x15\x15\x81R\xF3[\x7F\x01\xFF\xC9\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91P\x14\x82a\x18\x11V[4a\x0F\xA8W_`\x03\x196\x01\x12a\x0F\xA8W` \x90`\x0BT\x81R\xF3[`$5\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x0F\xA8WV[`\x045\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x0F\xA8WV[`\x06T\x81\x10\x15a\x18\xBEW`\x06_R` _ \x01\x90_\x90V[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[`\x08T\x81\x10\x15a\x18\xBEW`\x08_R` _ \x01\x90_\x90V[\x90` \x80\x83Q\x92\x83\x81R\x01\x92\x01\x90_[\x81\x81\x10a\x19 WPPP\x90V[\x82Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a\x19\x13V[\x90`\x1F`\x1F\x19\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x0F\xD9W`@RV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x0F\xD9W`\x05\x1B` \x01\x90V[\x90`\x1F\x19`\x1F` \x80\x94\x80Q\x91\x82\x91\x82\x87R\x01\x86\x86\x01^_\x85\x82\x86\x01\x01R\x01\x16\x01\x01\x90V[\x91\x90\x82\x03\x91\x82\x11a\x19\xB9WV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[\x90a\x19\xF0\x82a\x19oV[a\x19\xFD`@Q\x91\x82a\x19LV[\x82\x81R`\x1F\x19a\x1A\r\x82\x94a\x19oV[\x01\x90` 6\x91\x017V[\x80Q\x82\x10\x15a\x18\xBEW` \x91`\x05\x1B\x01\x01\x90V[_\x19\x81\x14a\x19\xB9W`\x01\x01\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x0F\xD9W`\x1F\x01`\x1F\x19\x16` \x01\x90V[a\x1A\xB1` a\x1A\xA9a\x1Ah`\x02Ta\x1E\x98V[\x82\x80a\x1Au`\x03Ta\x1E\x98V[`@Q\x95\x84\x87\x95Q\x91\x82\x91\x01\x84\x87\x01^\x84\x01\x90\x82\x82\x01_\x81R\x81Q\x93\x84\x92\x01\x90^\x01\x01_\x81R\x03`\x1F\x19\x81\x01\x83R\x82a\x19LV[\x80Q\x90a \x1DV[\x90\x15a\x1A\xBAW\x90V[\x7F\x94\xE2s~\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[a\x02ra\x1B\x92`@Qa\x1A\xF8` \x84\x01\x82a\x19LV[\x82\x81R` \x81\x01\x92a!\xA0\x849` `@Q\x81\x81\x01\x90a\x1Bc\x81a\x04\xA1\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF``\x92\x16\x81R`@` \x82\x01R_`@\x82\x01R\x01\x90V[`@Q\x95\x86\x94Q\x80\x91\x85\x87\x01^\x84\x01\x90\x83\x82\x01\x90_\x82RQ\x92\x83\x91^\x01\x01_\x81R\x03`\x1F\x19\x81\x01\x83R\x82a\x19LV[\x90V[\x80_R`\n` R`\xFF`@_ T\x16\x15a\x1B\xADWPV[_R`\n` R`@_ `\x01`\xFF\x19\x82T\x16\x17\x90Ua\x1B\xCE`\x0BTa\x1A+V[`\x0BUV[3_\x90\x81R\x7F\xAD2(\xB6v\xF7\xD3\xCDB\x84\xA5D?\x17\xF1\x96+6\xE4\x91\xB3\n@\xB2@XI\xE5\x97\xBA_\xB5` R`@\x90 T`\xFF\x16\x15a\x1C\x0BWV[\x7F\xE2Q}?\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R3`\x04R_`$R`D_\xFD[\x80_R_` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x16_R` R`\xFF`@_ T\x16\x15a\x1CrWPV[\x7F\xE2Q}?\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R3`\x04R`$R`D_\xFD[\x80_R_` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16_R` R`\xFF`@_ T\x16\x15_\x14a\x1DOW\x80_R_` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16_R` R`@_ `\x01`\xFF\x19\x82T\x16\x17\x90Us\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x92\x16\x90\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r_\x80\xA4`\x01\x90V[PP_\x90V[\x80_R_` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16_R` R`\xFF`@_ T\x16_\x14a\x1DOW\x80_R_` R`@_ s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16_R` R`@_ `\xFF\x19\x81T\x16\x90Us\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF3\x92\x16\x90\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B_\x80\xA4`\x01\x90V[`\xFF`\x01T\x16a\x1E\x0BWV[\x7F\xD9<\x06e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x15a\x1E:WV[`d`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7Fnamespace collision detected\0\0\0\0`D\x82\x01R\xFD[\x80_\x91z\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x82\x10\x15a\x1F\xF5W[\x80m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0`\n\x92\x10\x15a\x1F\xDAW[f#\x86\xF2o\xC1\0\0\x81\x10\x15a\x1F\xC6W[c\x05\xF5\xE1\0\x81\x10\x15a\x1F\xB5W[a'\x10\x81\x10\x15a\x1F\xA6W[`d\x81\x10\x15a\x1F\x98W[\x10\x15a\x1F\x8DW[`\n_\x19`!`\x01\x85\x01\x94`\x1F\x19a\x1FBa\x1F,\x88a\x1A9V[\x97a\x1F:`@Q\x99\x8Aa\x19LV[\x80\x89Ra\x1A9V[\x016` \x88\x017\x85\x01\x01[\x01\x91\x7F0123456789abcdef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x82\x06\x1A\x83S\x04\x80\x15a\x1F\x88W_\x19`\n\x91\x92a\x1FMV[PP\x90V[`\x01\x90\x91\x01\x90a\x1F\x12V[`d`\x02\x91\x04\x93\x01\x92a\x1F\x0BV[a'\x10`\x04\x91\x04\x93\x01\x92a\x1F\x01V[c\x05\xF5\xE1\0`\x08\x91\x04\x93\x01\x92a\x1E\xF6V[f#\x86\xF2o\xC1\0\0`\x10\x91\x04\x93\x01\x92a\x1E\xE9V[m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0` \x91\x04\x93\x01\x92a\x1E\xD9V[P`@\x91Pz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x81\x04a\x1E\xBFV[\x90\x81Q\x81\x11\x80\x15a CW[a ;W_a 7\x92a JV[\x90\x91V[PP_\x90_\x90V[P_a )V[_\x93\x92\x90[\x81\x83\x10a _WPPP`\x01\x91\x90V[\x90\x92\x91\x93`\xFFa \x96\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x88\x86\x01\x01Q\x16a \xD3V[\x16`\t\x81\x11a \xC8W`\n\x82\x02\x91\x80\x83\x04`\n\x14\x90\x15\x17\x15a\x19\xB9W\x81\x01\x80\x91\x11a\x19\xB9W`\x01\x90\x94\x01\x91\x92\x90a OV[P_\x94P\x84\x93PPPV[`\xF8\x1C`/\x81\x11\x80a!\x95W[\x15a!\rW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xD0\x01`\xFF\x16\x90V[``\x81\x11\x80a!\x8BW[\x15a!DW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xA9\x01`\xFF\x16\x90V[`@\x81\x11\x80a!\x81W[\x15a!{W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC9\x01`\xFF\x16\x90V[P`\xFF\x90V[P`G\x81\x10a!NV[P`g\x81\x10a!\x17V[P`:\x81\x10a \xE0V\xFE`\x80`@Ra\x02r\x808\x03\x80a\0\x14\x81a\x01hV[\x92\x839\x81\x01`@\x82\x82\x03\x12a\x01dW\x81Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x92\x90\x91\x90\x83\x83\x03a\x01dW` \x81\x01Q\x90`\x01`\x01`@\x1B\x03\x82\x11a\x01dW\x01\x92\x81`\x1F\x85\x01\x12\x15a\x01dW\x83Qa\0na\0i\x82a\x01\xA1V[a\x01hV[\x94\x81\x86R` \x86\x01\x93` \x83\x83\x01\x01\x11a\x01dW\x81_\x92` \x80\x93\x01\x86^\x86\x01\x01R\x82;\x15a\x01RW\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x82\x17\x90U\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;_\x80\xA2\x82Q\x15a\x01:W_\x80\x91a\x01\"\x94Q\x90\x84Z\xF4=\x15a\x012W=\x91a\x01\x13a\0i\x84a\x01\xA1V[\x92\x83R=_` \x85\x01>a\x01\xBCV[P[`@Q`W\x90\x81a\x02\x1B\x829\xF3[``\x91a\x01\xBCV[PPP4\x15a\x01$Wc\xB3\x98\x97\x9F`\xE0\x1B_R`\x04_\xFD[cL\x9C\x8C\xE3`\xE0\x1B_R`\x04R`$_\xFD[_\x80\xFD[`@Q\x91\x90`\x1F\x01`\x1F\x19\x16\x82\x01`\x01`\x01`@\x1B\x03\x81\x11\x83\x82\x10\x17a\x01\x8DW`@RV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`\x01`\x01`@\x1B\x03\x81\x11a\x01\x8DW`\x1F\x01`\x1F\x19\x16` \x01\x90V[\x90a\x01\xE0WP\x80Q\x15a\x01\xD1W\x80Q\x90` \x01\xFD[c\xD6\xBD\xA2u`\xE0\x1B_R`\x04_\xFD[\x81Q\x15\x80a\x02\x11W[a\x01\xF1WP\x90V[c\x99\x96\xB3\x15`\xE0\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16`\x04R`$\x90\xFD[P\x80;\x15a\x01\xE9V\xFE`\x80`@R_\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCT\x166\x82\x807\x816\x91Z\xF4=_\x80>\x15`SW=_\xF3[=_\xFD`\xA0\x80`@R4`)W0`\x80Ra\x07\x07\x90\x81a\0.\x829`\x80Q\x81\x81\x81a\x01\xF0\x01Ra\x03)\x01R\xF3[_\x80\xFD\xFE`\x80`@R`\x046\x10\x15a\0\xD0W[6\x15a\0rW`d`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FStub: no logic implemented\0\0\0\0\0\0`D\x82\x01R\xFD[`d`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FStub: ETH not accepted\0\0\0\0\0\0\0\0\0\0`D\x82\x01R\xFD[_5`\xE0\x1C\x80cO\x1E\xF2\x86\x14a\x02hW\x80cR\xD1\x90-\x14a\x01\xABWc\xAD<\xB1\xCC\x03a\0\x0EW4a\x01\xA7W_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x01\xA7W`@\x80Q\x90a\x012\x81\x83a\x05\xC6V[`\x05\x82R` \x82\x01\x91\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83R\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F\x83Q\x94\x85\x93` \x85RQ\x80\x91\x81` \x87\x01R\x86\x86\x01^_\x85\x82\x86\x01\x01R\x01\x16\x81\x01\x03\x01\x90\xF3[_\x80\xFD[4a\x01\xA7W_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x01\xA7Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x160\x03a\x02@W` `@Q\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x81R\xF3[\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x01\xA7W`\x045s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x90\x81\x81\x03a\x01\xA7W`$5\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x01\xA7W6`#\x83\x01\x12\x15a\x01\xA7W\x81`\x04\x015\x91a\x02\xE1\x83a\x064V[\x92a\x02\xEF`@Q\x94\x85a\x05\xC6V[\x80\x84R` \x84\x01\x916`$\x83\x83\x01\x01\x11a\x01\xA7W\x81_\x92`$` \x93\x01\x857\x85\x01\x01Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x800\x14\x90\x81\x15a\x05\x84W[Pa\x02@W`@Q\x7FR\xD1\x90-\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x81`\x04\x81\x88Z\xFA_\x91\x81a\x05PW[Pa\x03\xC1W\x84\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x80\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x86\x92\x03a\x05%WP\x82;\x15a\x04\xFAW\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCT\x16\x17\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCU\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;_\x80\xA2\x82Q\x15a\x04\xC8W_\x80\x91a\x04\xBE\x94Q\x90\x84Z\xF4=\x15a\x04\xC0W=\x91a\x04\xA2\x83a\x064V[\x92a\x04\xB0`@Q\x94\x85a\x05\xC6V[\x83R=_` \x85\x01>a\x06nV[\0[``\x91a\x06nV[PPP4a\x04\xD2W\0[\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x90\x91P` \x81=` \x11a\x05|W[\x81a\x05l` \x93\x83a\x05\xC6V[\x81\x01\x03\x12a\x01\xA7WQ\x90\x86a\x03\x90V[=\x91Pa\x05_V[\x90Ps\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCT\x16\x14\x15\x85a\x03TV[\x90`\x1F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x06\x07W`@RV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x06\x07W`\x1F\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x16` \x01\x90V[\x90a\x06\xABWP\x80Q\x15a\x06\x83W\x80Q\x90` \x01\xFD[\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x81Q\x15\x80a\x06\xFEW[a\x06\xBCWP\x90V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R\x16`\x04R`$_\xFD[P\x80;\x15a\x06\xB4V",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NamespaceState(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<NamespaceState> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl NamespaceState {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<u8> for NamespaceState {
            fn from(value: u8) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<NamespaceState> for u8 {
            fn from(value: NamespaceState) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for NamespaceState {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for NamespaceState {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AccessControlBadConfirmation()` and selector `0x6697b232`.
```solidity
error AccessControlBadConfirmation();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlBadConfirmation;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlBadConfirmation>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlBadConfirmation) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlBadConfirmation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlBadConfirmation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlBadConfirmation()";
            const SELECTOR: [u8; 4] = [102u8, 151u8, 178u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AccessControlUnauthorizedAccount(address,bytes32)` and selector `0xe2517d3f`.
```solidity
error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub neededRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlUnauthorizedAccount) -> Self {
                (value.account, value.neededRole)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    neededRole: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlUnauthorizedAccount(address,bytes32)";
            const SELECTOR: [u8; 4] = [226u8, 81u8, 125u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.neededRole),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `CannotRemoveDefaultImplementation()` and selector `0xd5cc4a0f`.
```solidity
error CannotRemoveDefaultImplementation();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CannotRemoveDefaultImplementation;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CannotRemoveDefaultImplementation>
        for UnderlyingRustTuple<'_> {
            fn from(value: CannotRemoveDefaultImplementation) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for CannotRemoveDefaultImplementation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CannotRemoveDefaultImplementation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CannotRemoveDefaultImplementation()";
            const SELECTOR: [u8; 4] = [213u8, 204u8, 74u8, 15u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ChainIdAlreadyExists()` and selector `0x24591d89`.
```solidity
error ChainIdAlreadyExists();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ChainIdAlreadyExists;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ChainIdAlreadyExists> for UnderlyingRustTuple<'_> {
            fn from(value: ChainIdAlreadyExists) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ChainIdAlreadyExists {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ChainIdAlreadyExists {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ChainIdAlreadyExists()";
            const SELECTOR: [u8; 4] = [36u8, 89u8, 29u8, 137u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `Create2EmptyBytecode()` and selector `0x4ca249dc`.
```solidity
error Create2EmptyBytecode();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Create2EmptyBytecode;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Create2EmptyBytecode> for UnderlyingRustTuple<'_> {
            fn from(value: Create2EmptyBytecode) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Create2EmptyBytecode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for Create2EmptyBytecode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "Create2EmptyBytecode()";
            const SELECTOR: [u8; 4] = [76u8, 162u8, 73u8, 220u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `EnforcedPause()` and selector `0xd93c0665`.
```solidity
error EnforcedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EnforcedPause;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EnforcedPause> for UnderlyingRustTuple<'_> {
            fn from(value: EnforcedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EnforcedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EnforcedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EnforcedPause()";
            const SELECTOR: [u8; 4] = [217u8, 60u8, 6u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ExpectedPause()` and selector `0x8dfc202b`.
```solidity
error ExpectedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExpectedPause;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExpectedPause> for UnderlyingRustTuple<'_> {
            fn from(value: ExpectedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ExpectedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ExpectedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ExpectedPause()";
            const SELECTOR: [u8; 4] = [141u8, 252u8, 32u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `FailedDeployment()` and selector `0xb06ebf3d`.
```solidity
error FailedDeployment();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FailedDeployment;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FailedDeployment> for UnderlyingRustTuple<'_> {
            fn from(value: FailedDeployment) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FailedDeployment {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FailedDeployment {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FailedDeployment()";
            const SELECTOR: [u8; 4] = [176u8, 110u8, 191u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `FailedToUpgradeToLatestImplementation()` and selector `0xab6eb5bc`.
```solidity
error FailedToUpgradeToLatestImplementation();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FailedToUpgradeToLatestImplementation;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FailedToUpgradeToLatestImplementation>
        for UnderlyingRustTuple<'_> {
            fn from(value: FailedToUpgradeToLatestImplementation) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for FailedToUpgradeToLatestImplementation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FailedToUpgradeToLatestImplementation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FailedToUpgradeToLatestImplementation()";
            const SELECTOR: [u8; 4] = [171u8, 110u8, 181u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ImplementationAlreadyAllowed()` and selector `0x1833a24b`.
```solidity
error ImplementationAlreadyAllowed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ImplementationAlreadyAllowed;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ImplementationAlreadyAllowed>
        for UnderlyingRustTuple<'_> {
            fn from(value: ImplementationAlreadyAllowed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ImplementationAlreadyAllowed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ImplementationAlreadyAllowed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ImplementationAlreadyAllowed()";
            const SELECTOR: [u8; 4] = [24u8, 51u8, 162u8, 75u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ImplementationNotAllowed()` and selector `0xfb101809`.
```solidity
error ImplementationNotAllowed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ImplementationNotAllowed;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ImplementationNotAllowed>
        for UnderlyingRustTuple<'_> {
            fn from(value: ImplementationNotAllowed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ImplementationNotAllowed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ImplementationNotAllowed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ImplementationNotAllowed()";
            const SELECTOR: [u8; 4] = [251u8, 16u8, 24u8, 9u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InsufficientBalance(uint256,uint256)` and selector `0xcf479181`.
```solidity
error InsufficientBalance(uint256 balance, uint256 needed);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientBalance {
        #[allow(missing_docs)]
        pub balance: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub needed: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientBalance> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientBalance) -> Self {
                (value.balance, value.needed)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientBalance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    balance: tuple.0,
                    needed: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientBalance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientBalance(uint256,uint256)";
            const SELECTOR: [u8; 4] = [207u8, 71u8, 145u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.balance),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.needed),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `OnlyChainCanNotifyUpgrade()` and selector `0x2fd9adae`.
```solidity
error OnlyChainCanNotifyUpgrade();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OnlyChainCanNotifyUpgrade;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OnlyChainCanNotifyUpgrade>
        for UnderlyingRustTuple<'_> {
            fn from(value: OnlyChainCanNotifyUpgrade) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for OnlyChainCanNotifyUpgrade {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OnlyChainCanNotifyUpgrade {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OnlyChainCanNotifyUpgrade()";
            const SELECTOR: [u8; 4] = [47u8, 217u8, 173u8, 174u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `StringsInvalidChar()` and selector `0x94e2737e`.
```solidity
error StringsInvalidChar();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct StringsInvalidChar;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<StringsInvalidChar> for UnderlyingRustTuple<'_> {
            fn from(value: StringsInvalidChar) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for StringsInvalidChar {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for StringsInvalidChar {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "StringsInvalidChar()";
            const SELECTOR: [u8; 4] = [148u8, 226u8, 115u8, 126u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ZeroAddress()` and selector `0xd92e233d`.
```solidity
error ZeroAddress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAddress;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAddress> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAddress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAddress()";
            const SELECTOR: [u8; 4] = [217u8, 46u8, 35u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ChainBannedFromGasTracking(uint256,address)` and selector `0xebb4c50deb285192d1c2aa8832b1feeb078ba0fd92bb439c0dee28ebe9bb36e9`.
```solidity
event ChainBannedFromGasTracking(uint256 indexed chainId, address indexed notAllowedImplementation);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ChainBannedFromGasTracking {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub notAllowedImplementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ChainBannedFromGasTracking {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "ChainBannedFromGasTracking(uint256,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                235u8, 180u8, 197u8, 13u8, 235u8, 40u8, 81u8, 146u8, 209u8, 194u8, 170u8,
                136u8, 50u8, 177u8, 254u8, 235u8, 7u8, 139u8, 160u8, 253u8, 146u8, 187u8,
                67u8, 156u8, 13u8, 238u8, 40u8, 235u8, 233u8, 187u8, 54u8, 233u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    chainId: topics.1,
                    notAllowedImplementation: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.chainId.clone(),
                    self.notAllowedImplementation.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.chainId);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.notAllowedImplementation,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ChainBannedFromGasTracking {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ChainBannedFromGasTracking> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &ChainBannedFromGasTracking,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ChainIdManuallyMarked(uint256)` and selector `0x21c25cd0a54e1609e3e68b335693eefb694d5ef17cc32b106f913f8a1f1b8058`.
```solidity
event ChainIdManuallyMarked(uint256 indexed chainId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ChainIdManuallyMarked {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ChainIdManuallyMarked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "ChainIdManuallyMarked(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                33u8, 194u8, 92u8, 208u8, 165u8, 78u8, 22u8, 9u8, 227u8, 230u8, 139u8,
                51u8, 86u8, 147u8, 238u8, 251u8, 105u8, 77u8, 94u8, 241u8, 124u8, 195u8,
                43u8, 16u8, 111u8, 145u8, 63u8, 138u8, 31u8, 27u8, 128u8, 88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { chainId: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.chainId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.chainId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ChainIdManuallyMarked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ChainIdManuallyMarked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ChainIdManuallyMarked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ImplementationAdded(address)` and selector `0x331cedc71f28c46d467691770675b586e8aa77a0d4fe09f257d01ef00bc15458`.
```solidity
event ImplementationAdded(address indexed implementation);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ImplementationAdded {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ImplementationAdded {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "ImplementationAdded(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                51u8, 28u8, 237u8, 199u8, 31u8, 40u8, 196u8, 109u8, 70u8, 118u8, 145u8,
                119u8, 6u8, 117u8, 181u8, 134u8, 232u8, 170u8, 119u8, 160u8, 212u8,
                254u8, 9u8, 242u8, 87u8, 208u8, 30u8, 240u8, 11u8, 193u8, 84u8, 88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { implementation: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.implementation.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.implementation,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ImplementationAdded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ImplementationAdded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ImplementationAdded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `NamespaceConfigUpdated(uint256,uint256)` and selector `0xd9e1239177bfbd2aebf5d0f20fc075e6df5a502c59d121acd57342c783e31364`.
```solidity
event NamespaceConfigUpdated(uint256 oldNamespacePrefix, uint256 newNamespacePrefix);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct NamespaceConfigUpdated {
        #[allow(missing_docs)]
        pub oldNamespacePrefix: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub newNamespacePrefix: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for NamespaceConfigUpdated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "NamespaceConfigUpdated(uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                217u8, 225u8, 35u8, 145u8, 119u8, 191u8, 189u8, 42u8, 235u8, 245u8,
                208u8, 242u8, 15u8, 192u8, 117u8, 230u8, 223u8, 90u8, 80u8, 44u8, 89u8,
                209u8, 33u8, 172u8, 213u8, 115u8, 66u8, 199u8, 131u8, 227u8, 19u8, 100u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldNamespacePrefix: data.0,
                    newNamespacePrefix: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.oldNamespacePrefix),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newNamespacePrefix),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for NamespaceConfigUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&NamespaceConfigUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &NamespaceConfigUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Paused(address)` and selector `0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258`.
```solidity
event Paused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Paused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Paused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Paused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                98u8, 231u8, 140u8, 234u8, 1u8, 190u8, 227u8, 32u8, 205u8, 78u8, 66u8,
                2u8, 112u8, 181u8, 234u8, 116u8, 0u8, 13u8, 17u8, 176u8, 201u8, 247u8,
                71u8, 84u8, 235u8, 219u8, 252u8, 84u8, 75u8, 5u8, 162u8, 88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Paused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Paused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Paused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoleAdminChanged(bytes32,bytes32,bytes32)` and selector `0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff`.
```solidity
event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleAdminChanged {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub previousAdminRole: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newAdminRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleAdminChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "RoleAdminChanged(bytes32,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                189u8, 121u8, 184u8, 111u8, 254u8, 10u8, 184u8, 232u8, 119u8, 97u8, 81u8,
                81u8, 66u8, 23u8, 205u8, 124u8, 172u8, 213u8, 44u8, 144u8, 159u8, 102u8,
                71u8, 92u8, 58u8, 244u8, 78u8, 18u8, 159u8, 11u8, 0u8, 255u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    previousAdminRole: topics.2,
                    newAdminRole: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.previousAdminRole.clone(),
                    self.newAdminRole.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.previousAdminRole);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newAdminRole);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleAdminChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleAdminChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleAdminChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoleGranted(bytes32,address,address)` and selector `0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d`.
```solidity
event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleGranted {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleGranted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleGranted(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                47u8, 135u8, 136u8, 17u8, 126u8, 126u8, 255u8, 29u8, 130u8, 233u8, 38u8,
                236u8, 121u8, 73u8, 1u8, 209u8, 124u8, 120u8, 2u8, 74u8, 80u8, 39u8, 9u8,
                64u8, 48u8, 69u8, 64u8, 167u8, 51u8, 101u8, 111u8, 13u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleGranted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleGranted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleGranted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoleRevoked(bytes32,address,address)` and selector `0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b`.
```solidity
event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleRevoked {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleRevoked(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                246u8, 57u8, 31u8, 92u8, 50u8, 217u8, 198u8, 157u8, 42u8, 71u8, 234u8,
                103u8, 11u8, 68u8, 41u8, 116u8, 181u8, 57u8, 53u8, 209u8, 237u8, 199u8,
                253u8, 100u8, 235u8, 33u8, 224u8, 71u8, 168u8, 57u8, 23u8, 27u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `SyndicateSequencingChainCreated(uint256,address,address)` and selector `0x49b21f1e4190db8b0a933c951ed013de222c847c15461754682daa2eab1fdbd2`.
```solidity
event SyndicateSequencingChainCreated(uint256 indexed appchainId, address indexed sequencingChainAddress, address indexed permissionModuleAddress);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SyndicateSequencingChainCreated {
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub sequencingChainAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub permissionModuleAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SyndicateSequencingChainCreated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "SyndicateSequencingChainCreated(uint256,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                73u8, 178u8, 31u8, 30u8, 65u8, 144u8, 219u8, 139u8, 10u8, 147u8, 60u8,
                149u8, 30u8, 208u8, 19u8, 222u8, 34u8, 44u8, 132u8, 124u8, 21u8, 70u8,
                23u8, 84u8, 104u8, 45u8, 170u8, 46u8, 171u8, 31u8, 219u8, 210u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    appchainId: topics.1,
                    sequencingChainAddress: topics.2,
                    permissionModuleAddress: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.appchainId.clone(),
                    self.sequencingChainAddress.clone(),
                    self.permissionModuleAddress.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.appchainId);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sequencingChainAddress,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.permissionModuleAddress,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SyndicateSequencingChainCreated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SyndicateSequencingChainCreated>
        for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &SyndicateSequencingChainCreated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Unpaused(address)` and selector `0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa`.
```solidity
event Unpaused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Unpaused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Unpaused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Unpaused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                93u8, 185u8, 238u8, 10u8, 73u8, 91u8, 242u8, 230u8, 255u8, 156u8, 145u8,
                167u8, 131u8, 76u8, 27u8, 164u8, 253u8, 210u8, 68u8, 165u8, 232u8, 170u8,
                78u8, 83u8, 123u8, 211u8, 138u8, 234u8, 228u8, 176u8, 115u8, 170u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Unpaused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Unpaused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Unpaused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address admin);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub admin: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value.admin,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { admin: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.admin,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `DEFAULT_ADMIN_ROLE()` and selector `0xa217fddf`.
```solidity
function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLECall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`DEFAULT_ADMIN_ROLE()`](DEFAULT_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEFAULT_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEFAULT_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [162u8, 23u8, 253u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: DEFAULT_ADMIN_ROLEReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: DEFAULT_ADMIN_ROLEReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `MANAGER_ROLE()` and selector `0xec87621c`.
```solidity
function MANAGER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MANAGER_ROLECall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`MANAGER_ROLE()`](MANAGER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MANAGER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MANAGER_ROLECall> for UnderlyingRustTuple<'_> {
                fn from(value: MANAGER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for MANAGER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MANAGER_ROLEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: MANAGER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for MANAGER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for MANAGER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MANAGER_ROLE()";
            const SELECTOR: [u8; 4] = [236u8, 135u8, 98u8, 28u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: MANAGER_ROLEReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: MANAGER_ROLEReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `addAllowedImplementation(address,bool)` and selector `0x1d1ab15a`.
```solidity
function addAllowedImplementation(address implementation, bool makeDefault) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addAllowedImplementationCall {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub makeDefault: bool,
    }
    ///Container type for the return parameters of the [`addAllowedImplementation(address,bool)`](addAllowedImplementationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addAllowedImplementationReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, bool);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addAllowedImplementationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: addAllowedImplementationCall) -> Self {
                    (value.implementation, value.makeDefault)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for addAllowedImplementationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        implementation: tuple.0,
                        makeDefault: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addAllowedImplementationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: addAllowedImplementationReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for addAllowedImplementationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl addAllowedImplementationReturn {
            fn _tokenize(
                &self,
            ) -> <addAllowedImplementationCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addAllowedImplementationCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addAllowedImplementationReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addAllowedImplementation(address,bool)";
            const SELECTOR: [u8; 4] = [29u8, 26u8, 177u8, 90u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.implementation,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.makeDefault,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                addAllowedImplementationReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `allowedImplementations(uint256)` and selector `0x3144e853`.
```solidity
function allowedImplementations(uint256) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allowedImplementationsCall(
        pub alloy::sol_types::private::primitives::aliases::U256,
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`allowedImplementations(uint256)`](allowedImplementationsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allowedImplementationsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowedImplementationsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: allowedImplementationsCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for allowedImplementationsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowedImplementationsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: allowedImplementationsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for allowedImplementationsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for allowedImplementationsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "allowedImplementations(uint256)";
            const SELECTOR: [u8; 4] = [49u8, 68u8, 232u8, 83u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.0),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: allowedImplementationsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: allowedImplementationsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `appchainContracts(uint256)` and selector `0x6ff6f6c0`.
```solidity
function appchainContracts(uint256) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct appchainContractsCall(
        pub alloy::sol_types::private::primitives::aliases::U256,
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`appchainContracts(uint256)`](appchainContractsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct appchainContractsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<appchainContractsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: appchainContractsCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for appchainContractsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<appchainContractsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: appchainContractsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for appchainContractsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for appchainContractsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "appchainContracts(uint256)";
            const SELECTOR: [u8; 4] = [111u8, 246u8, 246u8, 192u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.0),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: appchainContractsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: appchainContractsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `banChainFromGasTracking(uint256,address)` and selector `0x8b35ba25`.
```solidity
function banChainFromGasTracking(uint256 chainId, address notAllowedImplementation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct banChainFromGasTrackingCall {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub notAllowedImplementation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`banChainFromGasTracking(uint256,address)`](banChainFromGasTrackingCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct banChainFromGasTrackingReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<banChainFromGasTrackingCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: banChainFromGasTrackingCall) -> Self {
                    (value.chainId, value.notAllowedImplementation)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for banChainFromGasTrackingCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        chainId: tuple.0,
                        notAllowedImplementation: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<banChainFromGasTrackingReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: banChainFromGasTrackingReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for banChainFromGasTrackingReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl banChainFromGasTrackingReturn {
            fn _tokenize(
                &self,
            ) -> <banChainFromGasTrackingCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for banChainFromGasTrackingCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = banChainFromGasTrackingReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "banChainFromGasTracking(uint256,address)";
            const SELECTOR: [u8; 4] = [139u8, 53u8, 186u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.notAllowedImplementation,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                banChainFromGasTrackingReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `chainIDs(uint256)` and selector `0x09d23e24`.
```solidity
function chainIDs(uint256) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct chainIDsCall(pub alloy::sol_types::private::primitives::aliases::U256);
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`chainIDs(uint256)`](chainIDsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct chainIDsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<chainIDsCall> for UnderlyingRustTuple<'_> {
                fn from(value: chainIDsCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for chainIDsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<chainIDsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: chainIDsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for chainIDsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for chainIDsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "chainIDs(uint256)";
            const SELECTOR: [u8; 4] = [9u8, 210u8, 62u8, 36u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.0),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: chainIDsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: chainIDsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `computeSequencingChainAddress(uint256)` and selector `0x6389f8da`.
```solidity
function computeSequencingChainAddress(uint256 chainId) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct computeSequencingChainAddressCall {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`computeSequencingChainAddress(uint256)`](computeSequencingChainAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct computeSequencingChainAddressReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<computeSequencingChainAddressCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: computeSequencingChainAddressCall) -> Self {
                    (value.chainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for computeSequencingChainAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { chainId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<computeSequencingChainAddressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: computeSequencingChainAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for computeSequencingChainAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for computeSequencingChainAddressCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "computeSequencingChainAddress(uint256)";
            const SELECTOR: [u8; 4] = [99u8, 137u8, 248u8, 218u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: computeSequencingChainAddressReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: computeSequencingChainAddressReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `computeStubImplementationAddress()` and selector `0xca4cd025`.
```solidity
function computeStubImplementationAddress() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct computeStubImplementationAddressCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`computeStubImplementationAddress()`](computeStubImplementationAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct computeStubImplementationAddressReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<computeStubImplementationAddressCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: computeStubImplementationAddressCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for computeStubImplementationAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<computeStubImplementationAddressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: computeStubImplementationAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for computeStubImplementationAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for computeStubImplementationAddressCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "computeStubImplementationAddress()";
            const SELECTOR: [u8; 4] = [202u8, 76u8, 208u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: computeStubImplementationAddressReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: computeStubImplementationAddressReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `createSyndicateSequencingChain(uint256,address,address)` and selector `0x67a5fb2c`.
```solidity
function createSyndicateSequencingChain(uint256 appchainId, address admin, address permissionModule) external returns (address sequencingChain, uint256 actualChainId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createSyndicateSequencingChainCall {
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub admin: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub permissionModule: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`createSyndicateSequencingChain(uint256,address,address)`](createSyndicateSequencingChainCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createSyndicateSequencingChainReturn {
        #[allow(missing_docs)]
        pub sequencingChain: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub actualChainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createSyndicateSequencingChainCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: createSyndicateSequencingChainCall) -> Self {
                    (value.appchainId, value.admin, value.permissionModule)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createSyndicateSequencingChainCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        appchainId: tuple.0,
                        admin: tuple.1,
                        permissionModule: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createSyndicateSequencingChainReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: createSyndicateSequencingChainReturn) -> Self {
                    (value.sequencingChain, value.actualChainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createSyndicateSequencingChainReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        sequencingChain: tuple.0,
                        actualChainId: tuple.1,
                    }
                }
            }
        }
        impl createSyndicateSequencingChainReturn {
            fn _tokenize(
                &self,
            ) -> <createSyndicateSequencingChainCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sequencingChain,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.actualChainId),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for createSyndicateSequencingChainCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = createSyndicateSequencingChainReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "createSyndicateSequencingChain(uint256,address,address)";
            const SELECTOR: [u8; 4] = [103u8, 165u8, 251u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.admin,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.permissionModule,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                createSyndicateSequencingChainReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `gasTrackingBanlist(uint256)` and selector `0xc112ee8c`.
```solidity
function gasTrackingBanlist(uint256) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gasTrackingBanlistCall(
        pub alloy::sol_types::private::primitives::aliases::U256,
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`gasTrackingBanlist(uint256)`](gasTrackingBanlistCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gasTrackingBanlistReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gasTrackingBanlistCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: gasTrackingBanlistCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for gasTrackingBanlistCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gasTrackingBanlistReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: gasTrackingBanlistReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for gasTrackingBanlistReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for gasTrackingBanlistCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "gasTrackingBanlist(uint256)";
            const SELECTOR: [u8; 4] = [193u8, 18u8, 238u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.0),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: gasTrackingBanlistReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: gasTrackingBanlistReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getAllowedImplementations()` and selector `0x32ed6805`.
```solidity
function getAllowedImplementations() external view returns (address[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAllowedImplementationsCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getAllowedImplementations()`](getAllowedImplementationsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAllowedImplementationsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAllowedImplementationsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAllowedImplementationsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAllowedImplementationsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAllowedImplementationsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAllowedImplementationsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAllowedImplementationsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAllowedImplementationsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAllowedImplementations()";
            const SELECTOR: [u8; 4] = [50u8, 237u8, 104u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getAllowedImplementationsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getAllowedImplementationsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getAppchainsAndContractsForGasTracking()` and selector `0x5bd6588b`.
```solidity
function getAppchainsAndContractsForGasTracking() external view returns (uint256[] memory _chainIDs, address[] memory _contracts);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAppchainsAndContractsForGasTrackingCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getAppchainsAndContractsForGasTracking()`](getAppchainsAndContractsForGasTrackingCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAppchainsAndContractsForGasTrackingReturn {
        #[allow(missing_docs)]
        pub _chainIDs: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
        #[allow(missing_docs)]
        pub _contracts: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAppchainsAndContractsForGasTrackingCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAppchainsAndContractsForGasTrackingCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAppchainsAndContractsForGasTrackingCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAppchainsAndContractsForGasTrackingReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAppchainsAndContractsForGasTrackingReturn) -> Self {
                    (value._chainIDs, value._contracts)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAppchainsAndContractsForGasTrackingReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _chainIDs: tuple.0,
                        _contracts: tuple.1,
                    }
                }
            }
        }
        impl getAppchainsAndContractsForGasTrackingReturn {
            fn _tokenize(
                &self,
            ) -> <getAppchainsAndContractsForGasTrackingCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self._chainIDs),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self._contracts),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAppchainsAndContractsForGasTrackingCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getAppchainsAndContractsForGasTrackingReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAppchainsAndContractsForGasTracking()";
            const SELECTOR: [u8; 4] = [91u8, 214u8, 88u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                getAppchainsAndContractsForGasTrackingReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getContractsForGasTracking(uint256[])` and selector `0xaae7238c`.
```solidity
function getContractsForGasTracking(uint256[] memory _chainIDs) external view returns (address[] memory _contracts);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getContractsForGasTrackingCall {
        #[allow(missing_docs)]
        pub _chainIDs: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getContractsForGasTracking(uint256[])`](getContractsForGasTrackingCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getContractsForGasTrackingReturn {
        #[allow(missing_docs)]
        pub _contracts: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getContractsForGasTrackingCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getContractsForGasTrackingCall) -> Self {
                    (value._chainIDs,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getContractsForGasTrackingCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _chainIDs: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getContractsForGasTrackingReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getContractsForGasTrackingReturn) -> Self {
                    (value._contracts,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getContractsForGasTrackingReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _contracts: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getContractsForGasTrackingCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getContractsForGasTracking(uint256[])";
            const SELECTOR: [u8; 4] = [170u8, 231u8, 35u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self._chainIDs),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getContractsForGasTrackingReturn = r.into();
                        r._contracts
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getContractsForGasTrackingReturn = r.into();
                        r._contracts
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getImplBytecode(address)` and selector `0xee5ee73c`.
```solidity
function getImplBytecode(address r#impl) external pure returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getImplBytecodeCall {
        #[allow(missing_docs)]
        pub r#impl: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getImplBytecode(address)`](getImplBytecodeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getImplBytecodeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getImplBytecodeCall> for UnderlyingRustTuple<'_> {
                fn from(value: getImplBytecodeCall) -> Self {
                    (value.r#impl,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getImplBytecodeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { r#impl: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getImplBytecodeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getImplBytecodeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getImplBytecodeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getImplBytecodeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Bytes;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getImplBytecode(address)";
            const SELECTOR: [u8; 4] = [238u8, 94u8, 231u8, 60u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.r#impl,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getImplBytecodeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getImplBytecodeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getNextChainId()` and selector `0x8de6e28c`.
```solidity
function getNextChainId() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getNextChainIdCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getNextChainId()`](getNextChainIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getNextChainIdReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getNextChainIdCall> for UnderlyingRustTuple<'_> {
                fn from(value: getNextChainIdCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getNextChainIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getNextChainIdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getNextChainIdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getNextChainIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getNextChainIdCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getNextChainId()";
            const SELECTOR: [u8; 4] = [141u8, 230u8, 226u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getNextChainIdReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getNextChainIdReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getProxyBytecode()` and selector `0xb416663e`.
```solidity
function getProxyBytecode() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getProxyBytecodeCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getProxyBytecode()`](getProxyBytecodeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getProxyBytecodeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getProxyBytecodeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getProxyBytecodeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getProxyBytecodeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getProxyBytecodeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getProxyBytecodeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getProxyBytecodeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getProxyBytecodeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Bytes;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getProxyBytecode()";
            const SELECTOR: [u8; 4] = [180u8, 22u8, 102u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getProxyBytecodeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getProxyBytecodeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getRoleAdmin(bytes32)` and selector `0x248a9ca3`.
```solidity
function getRoleAdmin(bytes32 role) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getRoleAdmin(bytes32)`](getRoleAdminCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleAdminCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleAdmin(bytes32)";
            const SELECTOR: [u8; 4] = [36u8, 138u8, 156u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getRoleAdminReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getRoleAdminReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getTotalAppchainsForGasTracking()` and selector `0x6ae7e703`.
```solidity
function getTotalAppchainsForGasTracking() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getTotalAppchainsForGasTrackingCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getTotalAppchainsForGasTracking()`](getTotalAppchainsForGasTrackingCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getTotalAppchainsForGasTrackingReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTotalAppchainsForGasTrackingCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getTotalAppchainsForGasTrackingCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getTotalAppchainsForGasTrackingCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTotalAppchainsForGasTrackingReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getTotalAppchainsForGasTrackingReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getTotalAppchainsForGasTrackingReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getTotalAppchainsForGasTrackingCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getTotalAppchainsForGasTracking()";
            const SELECTOR: [u8; 4] = [106u8, 231u8, 231u8, 3u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getTotalAppchainsForGasTrackingReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getTotalAppchainsForGasTrackingReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `grantRole(bytes32,address)` and selector `0x2f2ff15d`.
```solidity
function grantRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`grantRole(bytes32,address)`](grantRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl grantRoleReturn {
            fn _tokenize(
                &self,
            ) -> <grantRoleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for grantRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = grantRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "grantRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [47u8, 47u8, 241u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                grantRoleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `hasRole(bytes32,address)` and selector `0x91d14854`.
```solidity
function hasRole(bytes32 role, address account) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`hasRole(bytes32,address)`](hasRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [145u8, 209u8, 72u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: hasRoleReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: hasRoleReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isChainBannedFromGasTracking(uint256)` and selector `0x9e15d6ff`.
```solidity
function isChainBannedFromGasTracking(uint256 chainId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isChainBannedFromGasTrackingCall {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isChainBannedFromGasTracking(uint256)`](isChainBannedFromGasTrackingCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isChainBannedFromGasTrackingReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isChainBannedFromGasTrackingCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isChainBannedFromGasTrackingCall) -> Self {
                    (value.chainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isChainBannedFromGasTrackingCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { chainId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isChainBannedFromGasTrackingReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isChainBannedFromGasTrackingReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isChainBannedFromGasTrackingReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isChainBannedFromGasTrackingCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isChainBannedFromGasTracking(uint256)";
            const SELECTOR: [u8; 4] = [158u8, 21u8, 214u8, 255u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isChainBannedFromGasTrackingReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isChainBannedFromGasTrackingReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isChainIdUsed(uint256)` and selector `0x7232c133`.
```solidity
function isChainIdUsed(uint256 chainId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isChainIdUsedCall {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isChainIdUsed(uint256)`](isChainIdUsedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isChainIdUsedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isChainIdUsedCall> for UnderlyingRustTuple<'_> {
                fn from(value: isChainIdUsedCall) -> Self {
                    (value.chainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isChainIdUsedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { chainId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isChainIdUsedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isChainIdUsedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isChainIdUsedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isChainIdUsedCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isChainIdUsed(uint256)";
            const SELECTOR: [u8; 4] = [114u8, 50u8, 193u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isChainIdUsedReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isChainIdUsedReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isImplementationAllowed(address)` and selector `0x0d4b4bda`.
```solidity
function isImplementationAllowed(address) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isImplementationAllowedCall(pub alloy::sol_types::private::Address);
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isImplementationAllowed(address)`](isImplementationAllowedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isImplementationAllowedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isImplementationAllowedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isImplementationAllowedCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isImplementationAllowedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isImplementationAllowedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isImplementationAllowedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isImplementationAllowedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isImplementationAllowedCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isImplementationAllowed(address)";
            const SELECTOR: [u8; 4] = [13u8, 75u8, 75u8, 218u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.0,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isImplementationAllowedReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isImplementationAllowedReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `namespacePrefix()` and selector `0x297f4c64`.
```solidity
function namespacePrefix() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct namespacePrefixCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`namespacePrefix()`](namespacePrefixCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct namespacePrefixReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<namespacePrefixCall> for UnderlyingRustTuple<'_> {
                fn from(value: namespacePrefixCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for namespacePrefixCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<namespacePrefixReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: namespacePrefixReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for namespacePrefixReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for namespacePrefixCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "namespacePrefix()";
            const SELECTOR: [u8; 4] = [41u8, 127u8, 76u8, 100u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: namespacePrefixReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: namespacePrefixReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `nextAutoChainId()` and selector `0x999d71d4`.
```solidity
function nextAutoChainId() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nextAutoChainIdCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`nextAutoChainId()`](nextAutoChainIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nextAutoChainIdReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nextAutoChainIdCall> for UnderlyingRustTuple<'_> {
                fn from(value: nextAutoChainIdCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nextAutoChainIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nextAutoChainIdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: nextAutoChainIdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for nextAutoChainIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for nextAutoChainIdCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "nextAutoChainId()";
            const SELECTOR: [u8; 4] = [153u8, 157u8, 113u8, 212u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: nextAutoChainIdReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: nextAutoChainIdReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `notifyChainUpgrade(uint256,address)` and selector `0x07a9bee7`.
```solidity
function notifyChainUpgrade(uint256 chainId, address newImplementation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct notifyChainUpgradeCall {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub newImplementation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`notifyChainUpgrade(uint256,address)`](notifyChainUpgradeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct notifyChainUpgradeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<notifyChainUpgradeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: notifyChainUpgradeCall) -> Self {
                    (value.chainId, value.newImplementation)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for notifyChainUpgradeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        chainId: tuple.0,
                        newImplementation: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<notifyChainUpgradeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: notifyChainUpgradeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for notifyChainUpgradeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl notifyChainUpgradeReturn {
            fn _tokenize(
                &self,
            ) -> <notifyChainUpgradeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for notifyChainUpgradeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = notifyChainUpgradeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "notifyChainUpgrade(uint256,address)";
            const SELECTOR: [u8; 4] = [7u8, 169u8, 190u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newImplementation,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                notifyChainUpgradeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `numberOfChainsBannedFromGasTracking()` and selector `0x00b68a73`.
```solidity
function numberOfChainsBannedFromGasTracking() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct numberOfChainsBannedFromGasTrackingCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`numberOfChainsBannedFromGasTracking()`](numberOfChainsBannedFromGasTrackingCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct numberOfChainsBannedFromGasTrackingReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<numberOfChainsBannedFromGasTrackingCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: numberOfChainsBannedFromGasTrackingCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for numberOfChainsBannedFromGasTrackingCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<numberOfChainsBannedFromGasTrackingReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: numberOfChainsBannedFromGasTrackingReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for numberOfChainsBannedFromGasTrackingReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for numberOfChainsBannedFromGasTrackingCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "numberOfChainsBannedFromGasTracking()";
            const SELECTOR: [u8; 4] = [0u8, 182u8, 138u8, 115u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: numberOfChainsBannedFromGasTrackingReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: numberOfChainsBannedFromGasTrackingReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `pause()` and selector `0x8456cb59`.
```solidity
function pause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseCall;
    ///Container type for the return parameters of the [`pause()`](pauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl pauseReturn {
            fn _tokenize(
                &self,
            ) -> <pauseCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pause()";
            const SELECTOR: [u8; 4] = [132u8, 86u8, 203u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                pauseReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `paused()` and selector `0x5c975abb`.
```solidity
function paused() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`paused()`](pausedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedCall> for UnderlyingRustTuple<'_> {
                fn from(value: pausedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pausedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pausedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "paused()";
            const SELECTOR: [u8; 4] = [92u8, 151u8, 90u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: pausedReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: pausedReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `removeAllowedImplementation(address)` and selector `0xeeeb44ad`.
```solidity
function removeAllowedImplementation(address implementation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeAllowedImplementationCall {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`removeAllowedImplementation(address)`](removeAllowedImplementationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeAllowedImplementationReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeAllowedImplementationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeAllowedImplementationCall) -> Self {
                    (value.implementation,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeAllowedImplementationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { implementation: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeAllowedImplementationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeAllowedImplementationReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeAllowedImplementationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl removeAllowedImplementationReturn {
            fn _tokenize(
                &self,
            ) -> <removeAllowedImplementationCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeAllowedImplementationCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeAllowedImplementationReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeAllowedImplementation(address)";
            const SELECTOR: [u8; 4] = [238u8, 235u8, 68u8, 173u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.implementation,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                removeAllowedImplementationReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `renounceRole(bytes32,address)` and selector `0x36568abe`.
```solidity
function renounceRole(bytes32 role, address callerConfirmation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub callerConfirmation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`renounceRole(bytes32,address)`](renounceRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleCall) -> Self {
                    (value.role, value.callerConfirmation)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        callerConfirmation: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl renounceRoleReturn {
            fn _tokenize(
                &self,
            ) -> <renounceRoleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [54u8, 86u8, 138u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callerConfirmation,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                renounceRoleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `revokeRole(bytes32,address)` and selector `0xd547741f`.
```solidity
function revokeRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeRole(bytes32,address)`](revokeRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl revokeRoleReturn {
            fn _tokenize(
                &self,
            ) -> <revokeRoleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [213u8, 71u8, 116u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                revokeRoleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setDefaultImplementation(address)` and selector `0x7c16ffc4`.
```solidity
function setDefaultImplementation(address implementation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setDefaultImplementationCall {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setDefaultImplementation(address)`](setDefaultImplementationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setDefaultImplementationReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setDefaultImplementationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setDefaultImplementationCall) -> Self {
                    (value.implementation,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setDefaultImplementationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { implementation: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setDefaultImplementationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setDefaultImplementationReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setDefaultImplementationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setDefaultImplementationReturn {
            fn _tokenize(
                &self,
            ) -> <setDefaultImplementationCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setDefaultImplementationCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setDefaultImplementationReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setDefaultImplementation(address)";
            const SELECTOR: [u8; 4] = [124u8, 22u8, 255u8, 196u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.implementation,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setDefaultImplementationReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `stubImplementation()` and selector `0x56dba779`.
```solidity
function stubImplementation() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stubImplementationCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`stubImplementation()`](stubImplementationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stubImplementationReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stubImplementationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: stubImplementationCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for stubImplementationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stubImplementationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: stubImplementationReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for stubImplementationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for stubImplementationCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "stubImplementation()";
            const SELECTOR: [u8; 4] = [86u8, 219u8, 167u8, 121u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: stubImplementationReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: stubImplementationReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
```solidity
function supportsInterface(bytes4 interfaceId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceCall {
        #[allow(missing_docs)]
        pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceCall) -> Self {
                    (value.interfaceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { interfaceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportsInterfaceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportsInterface(bytes4)";
            const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.interfaceId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: supportsInterfaceReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: supportsInterfaceReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `syndicateChainImpl()` and selector `0xff76aed6`.
```solidity
function syndicateChainImpl() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct syndicateChainImplCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`syndicateChainImpl()`](syndicateChainImplCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct syndicateChainImplReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<syndicateChainImplCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: syndicateChainImplCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for syndicateChainImplCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<syndicateChainImplReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: syndicateChainImplReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for syndicateChainImplReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for syndicateChainImplCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "syndicateChainImpl()";
            const SELECTOR: [u8; 4] = [255u8, 118u8, 174u8, 214u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: syndicateChainImplReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: syndicateChainImplReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `unpause()` and selector `0x3f4ba83a`.
```solidity
function unpause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseCall;
    ///Container type for the return parameters of the [`unpause()`](unpauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl unpauseReturn {
            fn _tokenize(
                &self,
            ) -> <unpauseCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unpauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = unpauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unpause()";
            const SELECTOR: [u8; 4] = [63u8, 75u8, 168u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                unpauseReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `updateNamespaceConfig(uint256)` and selector `0x8c39aaa4`.
```solidity
function updateNamespaceConfig(uint256 newPrefix) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateNamespaceConfigCall {
        #[allow(missing_docs)]
        pub newPrefix: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`updateNamespaceConfig(uint256)`](updateNamespaceConfigCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateNamespaceConfigReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateNamespaceConfigCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateNamespaceConfigCall) -> Self {
                    (value.newPrefix,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateNamespaceConfigCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newPrefix: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateNamespaceConfigReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateNamespaceConfigReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateNamespaceConfigReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl updateNamespaceConfigReturn {
            fn _tokenize(
                &self,
            ) -> <updateNamespaceConfigCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateNamespaceConfigCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateNamespaceConfigReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateNamespaceConfig(uint256)";
            const SELECTOR: [u8; 4] = [140u8, 57u8, 170u8, 164u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newPrefix),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                updateNamespaceConfigReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `usedNamespaces(uint256)` and selector `0xb963ebf3`.
```solidity
function usedNamespaces(uint256) external view returns (NamespaceState);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct usedNamespacesCall(
        pub alloy::sol_types::private::primitives::aliases::U256,
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`usedNamespaces(uint256)`](usedNamespacesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct usedNamespacesReturn {
        #[allow(missing_docs)]
        pub _0: <NamespaceState as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<usedNamespacesCall> for UnderlyingRustTuple<'_> {
                fn from(value: usedNamespacesCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for usedNamespacesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (NamespaceState,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <NamespaceState as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<usedNamespacesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: usedNamespacesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for usedNamespacesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for usedNamespacesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = <NamespaceState as alloy::sol_types::SolType>::RustType;
            type ReturnTuple<'a> = (NamespaceState,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "usedNamespaces(uint256)";
            const SELECTOR: [u8; 4] = [185u8, 99u8, 235u8, 243u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.0),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (<NamespaceState as alloy_sol_types::SolType>::tokenize(ret),)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: usedNamespacesReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: usedNamespacesReturn = r.into();
                        r._0
                    })
            }
        }
    };
    ///Container for all the [`SyndicateFactory`](self) function calls.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum SyndicateFactoryCalls {
        #[allow(missing_docs)]
        DEFAULT_ADMIN_ROLE(DEFAULT_ADMIN_ROLECall),
        #[allow(missing_docs)]
        MANAGER_ROLE(MANAGER_ROLECall),
        #[allow(missing_docs)]
        addAllowedImplementation(addAllowedImplementationCall),
        #[allow(missing_docs)]
        allowedImplementations(allowedImplementationsCall),
        #[allow(missing_docs)]
        appchainContracts(appchainContractsCall),
        #[allow(missing_docs)]
        banChainFromGasTracking(banChainFromGasTrackingCall),
        #[allow(missing_docs)]
        chainIDs(chainIDsCall),
        #[allow(missing_docs)]
        computeSequencingChainAddress(computeSequencingChainAddressCall),
        #[allow(missing_docs)]
        computeStubImplementationAddress(computeStubImplementationAddressCall),
        #[allow(missing_docs)]
        createSyndicateSequencingChain(createSyndicateSequencingChainCall),
        #[allow(missing_docs)]
        gasTrackingBanlist(gasTrackingBanlistCall),
        #[allow(missing_docs)]
        getAllowedImplementations(getAllowedImplementationsCall),
        #[allow(missing_docs)]
        getAppchainsAndContractsForGasTracking(
            getAppchainsAndContractsForGasTrackingCall,
        ),
        #[allow(missing_docs)]
        getContractsForGasTracking(getContractsForGasTrackingCall),
        #[allow(missing_docs)]
        getImplBytecode(getImplBytecodeCall),
        #[allow(missing_docs)]
        getNextChainId(getNextChainIdCall),
        #[allow(missing_docs)]
        getProxyBytecode(getProxyBytecodeCall),
        #[allow(missing_docs)]
        getRoleAdmin(getRoleAdminCall),
        #[allow(missing_docs)]
        getTotalAppchainsForGasTracking(getTotalAppchainsForGasTrackingCall),
        #[allow(missing_docs)]
        grantRole(grantRoleCall),
        #[allow(missing_docs)]
        hasRole(hasRoleCall),
        #[allow(missing_docs)]
        isChainBannedFromGasTracking(isChainBannedFromGasTrackingCall),
        #[allow(missing_docs)]
        isChainIdUsed(isChainIdUsedCall),
        #[allow(missing_docs)]
        isImplementationAllowed(isImplementationAllowedCall),
        #[allow(missing_docs)]
        namespacePrefix(namespacePrefixCall),
        #[allow(missing_docs)]
        nextAutoChainId(nextAutoChainIdCall),
        #[allow(missing_docs)]
        notifyChainUpgrade(notifyChainUpgradeCall),
        #[allow(missing_docs)]
        numberOfChainsBannedFromGasTracking(numberOfChainsBannedFromGasTrackingCall),
        #[allow(missing_docs)]
        pause(pauseCall),
        #[allow(missing_docs)]
        paused(pausedCall),
        #[allow(missing_docs)]
        removeAllowedImplementation(removeAllowedImplementationCall),
        #[allow(missing_docs)]
        renounceRole(renounceRoleCall),
        #[allow(missing_docs)]
        revokeRole(revokeRoleCall),
        #[allow(missing_docs)]
        setDefaultImplementation(setDefaultImplementationCall),
        #[allow(missing_docs)]
        stubImplementation(stubImplementationCall),
        #[allow(missing_docs)]
        supportsInterface(supportsInterfaceCall),
        #[allow(missing_docs)]
        syndicateChainImpl(syndicateChainImplCall),
        #[allow(missing_docs)]
        unpause(unpauseCall),
        #[allow(missing_docs)]
        updateNamespaceConfig(updateNamespaceConfigCall),
        #[allow(missing_docs)]
        usedNamespaces(usedNamespacesCall),
    }
    #[automatically_derived]
    impl SyndicateFactoryCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [0u8, 182u8, 138u8, 115u8],
            [1u8, 255u8, 201u8, 167u8],
            [7u8, 169u8, 190u8, 231u8],
            [9u8, 210u8, 62u8, 36u8],
            [13u8, 75u8, 75u8, 218u8],
            [29u8, 26u8, 177u8, 90u8],
            [36u8, 138u8, 156u8, 163u8],
            [41u8, 127u8, 76u8, 100u8],
            [47u8, 47u8, 241u8, 93u8],
            [49u8, 68u8, 232u8, 83u8],
            [50u8, 237u8, 104u8, 5u8],
            [54u8, 86u8, 138u8, 190u8],
            [63u8, 75u8, 168u8, 58u8],
            [86u8, 219u8, 167u8, 121u8],
            [91u8, 214u8, 88u8, 139u8],
            [92u8, 151u8, 90u8, 187u8],
            [99u8, 137u8, 248u8, 218u8],
            [103u8, 165u8, 251u8, 44u8],
            [106u8, 231u8, 231u8, 3u8],
            [111u8, 246u8, 246u8, 192u8],
            [114u8, 50u8, 193u8, 51u8],
            [124u8, 22u8, 255u8, 196u8],
            [132u8, 86u8, 203u8, 89u8],
            [139u8, 53u8, 186u8, 37u8],
            [140u8, 57u8, 170u8, 164u8],
            [141u8, 230u8, 226u8, 140u8],
            [145u8, 209u8, 72u8, 84u8],
            [153u8, 157u8, 113u8, 212u8],
            [158u8, 21u8, 214u8, 255u8],
            [162u8, 23u8, 253u8, 223u8],
            [170u8, 231u8, 35u8, 140u8],
            [180u8, 22u8, 102u8, 62u8],
            [185u8, 99u8, 235u8, 243u8],
            [193u8, 18u8, 238u8, 140u8],
            [202u8, 76u8, 208u8, 37u8],
            [213u8, 71u8, 116u8, 31u8],
            [236u8, 135u8, 98u8, 28u8],
            [238u8, 94u8, 231u8, 60u8],
            [238u8, 235u8, 68u8, 173u8],
            [255u8, 118u8, 174u8, 214u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndicateFactoryCalls {
        const NAME: &'static str = "SyndicateFactoryCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 40usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::DEFAULT_ADMIN_ROLE(_) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::MANAGER_ROLE(_) => {
                    <MANAGER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::addAllowedImplementation(_) => {
                    <addAllowedImplementationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::allowedImplementations(_) => {
                    <allowedImplementationsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::appchainContracts(_) => {
                    <appchainContractsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::banChainFromGasTracking(_) => {
                    <banChainFromGasTrackingCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::chainIDs(_) => <chainIDsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::computeSequencingChainAddress(_) => {
                    <computeSequencingChainAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::computeStubImplementationAddress(_) => {
                    <computeStubImplementationAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::createSyndicateSequencingChain(_) => {
                    <createSyndicateSequencingChainCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::gasTrackingBanlist(_) => {
                    <gasTrackingBanlistCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAllowedImplementations(_) => {
                    <getAllowedImplementationsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAppchainsAndContractsForGasTracking(_) => {
                    <getAppchainsAndContractsForGasTrackingCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getContractsForGasTracking(_) => {
                    <getContractsForGasTrackingCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getImplBytecode(_) => {
                    <getImplBytecodeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getNextChainId(_) => {
                    <getNextChainIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getProxyBytecode(_) => {
                    <getProxyBytecodeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleAdmin(_) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getTotalAppchainsForGasTracking(_) => {
                    <getTotalAppchainsForGasTrackingCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::grantRole(_) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasRole(_) => <hasRoleCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::isChainBannedFromGasTracking(_) => {
                    <isChainBannedFromGasTrackingCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isChainIdUsed(_) => {
                    <isChainIdUsedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isImplementationAllowed(_) => {
                    <isImplementationAllowedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::namespacePrefix(_) => {
                    <namespacePrefixCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::nextAutoChainId(_) => {
                    <nextAutoChainIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::notifyChainUpgrade(_) => {
                    <notifyChainUpgradeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::numberOfChainsBannedFromGasTracking(_) => {
                    <numberOfChainsBannedFromGasTrackingCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::pause(_) => <pauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::paused(_) => <pausedCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::removeAllowedImplementation(_) => {
                    <removeAllowedImplementationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceRole(_) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeRole(_) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setDefaultImplementation(_) => {
                    <setDefaultImplementationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::stubImplementation(_) => {
                    <stubImplementationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::supportsInterface(_) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::syndicateChainImpl(_) => {
                    <syndicateChainImplCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::unpause(_) => <unpauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::updateNamespaceConfig(_) => {
                    <updateNamespaceConfigCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::usedNamespaces(_) => {
                    <usedNamespacesCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<SyndicateFactoryCalls>] = &[
                {
                    fn numberOfChainsBannedFromGasTracking(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <numberOfChainsBannedFromGasTrackingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                SyndicateFactoryCalls::numberOfChainsBannedFromGasTracking,
                            )
                    }
                    numberOfChainsBannedFromGasTracking
                },
                {
                    fn supportsInterface(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn notifyChainUpgrade(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <notifyChainUpgradeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::notifyChainUpgrade)
                    }
                    notifyChainUpgrade
                },
                {
                    fn chainIDs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <chainIDsCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SyndicateFactoryCalls::chainIDs)
                    }
                    chainIDs
                },
                {
                    fn isImplementationAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <isImplementationAllowedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::isImplementationAllowed)
                    }
                    isImplementationAllowed
                },
                {
                    fn addAllowedImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <addAllowedImplementationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::addAllowedImplementation)
                    }
                    addAllowedImplementation
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn namespacePrefix(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <namespacePrefixCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::namespacePrefix)
                    }
                    namespacePrefix
                },
                {
                    fn grantRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SyndicateFactoryCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn allowedImplementations(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <allowedImplementationsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::allowedImplementations)
                    }
                    allowedImplementations
                },
                {
                    fn getAllowedImplementations(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getAllowedImplementationsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getAllowedImplementations)
                    }
                    getAllowedImplementations
                },
                {
                    fn renounceRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn unpause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <unpauseCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SyndicateFactoryCalls::unpause)
                    }
                    unpause
                },
                {
                    fn stubImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <stubImplementationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::stubImplementation)
                    }
                    stubImplementation
                },
                {
                    fn getAppchainsAndContractsForGasTracking(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getAppchainsAndContractsForGasTrackingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                SyndicateFactoryCalls::getAppchainsAndContractsForGasTracking,
                            )
                    }
                    getAppchainsAndContractsForGasTracking
                },
                {
                    fn paused(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <pausedCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SyndicateFactoryCalls::paused)
                    }
                    paused
                },
                {
                    fn computeSequencingChainAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <computeSequencingChainAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::computeSequencingChainAddress)
                    }
                    computeSequencingChainAddress
                },
                {
                    fn createSyndicateSequencingChain(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <createSyndicateSequencingChainCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::createSyndicateSequencingChain)
                    }
                    createSyndicateSequencingChain
                },
                {
                    fn getTotalAppchainsForGasTracking(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getTotalAppchainsForGasTrackingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getTotalAppchainsForGasTracking)
                    }
                    getTotalAppchainsForGasTracking
                },
                {
                    fn appchainContracts(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <appchainContractsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::appchainContracts)
                    }
                    appchainContracts
                },
                {
                    fn isChainIdUsed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <isChainIdUsedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::isChainIdUsed)
                    }
                    isChainIdUsed
                },
                {
                    fn setDefaultImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <setDefaultImplementationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::setDefaultImplementation)
                    }
                    setDefaultImplementation
                },
                {
                    fn pause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <pauseCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SyndicateFactoryCalls::pause)
                    }
                    pause
                },
                {
                    fn banChainFromGasTracking(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <banChainFromGasTrackingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::banChainFromGasTracking)
                    }
                    banChainFromGasTracking
                },
                {
                    fn updateNamespaceConfig(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <updateNamespaceConfigCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::updateNamespaceConfig)
                    }
                    updateNamespaceConfig
                },
                {
                    fn getNextChainId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getNextChainIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getNextChainId)
                    }
                    getNextChainId
                },
                {
                    fn hasRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SyndicateFactoryCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn nextAutoChainId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <nextAutoChainIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::nextAutoChainId)
                    }
                    nextAutoChainId
                },
                {
                    fn isChainBannedFromGasTracking(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <isChainBannedFromGasTrackingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::isChainBannedFromGasTracking)
                    }
                    isChainBannedFromGasTracking
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn getContractsForGasTracking(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getContractsForGasTrackingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getContractsForGasTracking)
                    }
                    getContractsForGasTracking
                },
                {
                    fn getProxyBytecode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getProxyBytecodeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getProxyBytecode)
                    }
                    getProxyBytecode
                },
                {
                    fn usedNamespaces(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <usedNamespacesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::usedNamespaces)
                    }
                    usedNamespaces
                },
                {
                    fn gasTrackingBanlist(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <gasTrackingBanlistCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::gasTrackingBanlist)
                    }
                    gasTrackingBanlist
                },
                {
                    fn computeStubImplementationAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <computeStubImplementationAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::computeStubImplementationAddress)
                    }
                    computeStubImplementationAddress
                },
                {
                    fn revokeRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn MANAGER_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::MANAGER_ROLE)
                    }
                    MANAGER_ROLE
                },
                {
                    fn getImplBytecode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getImplBytecodeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getImplBytecode)
                    }
                    getImplBytecode
                },
                {
                    fn removeAllowedImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <removeAllowedImplementationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::removeAllowedImplementation)
                    }
                    removeAllowedImplementation
                },
                {
                    fn syndicateChainImpl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <syndicateChainImplCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::syndicateChainImpl)
                    }
                    syndicateChainImpl
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<SyndicateFactoryCalls>] = &[
                {
                    fn numberOfChainsBannedFromGasTracking(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <numberOfChainsBannedFromGasTrackingCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                SyndicateFactoryCalls::numberOfChainsBannedFromGasTracking,
                            )
                    }
                    numberOfChainsBannedFromGasTracking
                },
                {
                    fn supportsInterface(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn notifyChainUpgrade(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <notifyChainUpgradeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::notifyChainUpgrade)
                    }
                    notifyChainUpgrade
                },
                {
                    fn chainIDs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <chainIDsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::chainIDs)
                    }
                    chainIDs
                },
                {
                    fn isImplementationAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <isImplementationAllowedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::isImplementationAllowed)
                    }
                    isImplementationAllowed
                },
                {
                    fn addAllowedImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <addAllowedImplementationCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::addAllowedImplementation)
                    }
                    addAllowedImplementation
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn namespacePrefix(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <namespacePrefixCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::namespacePrefix)
                    }
                    namespacePrefix
                },
                {
                    fn grantRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn allowedImplementations(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <allowedImplementationsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::allowedImplementations)
                    }
                    allowedImplementations
                },
                {
                    fn getAllowedImplementations(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getAllowedImplementationsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getAllowedImplementations)
                    }
                    getAllowedImplementations
                },
                {
                    fn renounceRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn unpause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <unpauseCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::unpause)
                    }
                    unpause
                },
                {
                    fn stubImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <stubImplementationCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::stubImplementation)
                    }
                    stubImplementation
                },
                {
                    fn getAppchainsAndContractsForGasTracking(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getAppchainsAndContractsForGasTrackingCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                SyndicateFactoryCalls::getAppchainsAndContractsForGasTracking,
                            )
                    }
                    getAppchainsAndContractsForGasTracking
                },
                {
                    fn paused(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <pausedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::paused)
                    }
                    paused
                },
                {
                    fn computeSequencingChainAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <computeSequencingChainAddressCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::computeSequencingChainAddress)
                    }
                    computeSequencingChainAddress
                },
                {
                    fn createSyndicateSequencingChain(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <createSyndicateSequencingChainCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::createSyndicateSequencingChain)
                    }
                    createSyndicateSequencingChain
                },
                {
                    fn getTotalAppchainsForGasTracking(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getTotalAppchainsForGasTrackingCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getTotalAppchainsForGasTracking)
                    }
                    getTotalAppchainsForGasTracking
                },
                {
                    fn appchainContracts(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <appchainContractsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::appchainContracts)
                    }
                    appchainContracts
                },
                {
                    fn isChainIdUsed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <isChainIdUsedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::isChainIdUsed)
                    }
                    isChainIdUsed
                },
                {
                    fn setDefaultImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <setDefaultImplementationCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::setDefaultImplementation)
                    }
                    setDefaultImplementation
                },
                {
                    fn pause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <pauseCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::pause)
                    }
                    pause
                },
                {
                    fn banChainFromGasTracking(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <banChainFromGasTrackingCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::banChainFromGasTracking)
                    }
                    banChainFromGasTracking
                },
                {
                    fn updateNamespaceConfig(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <updateNamespaceConfigCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::updateNamespaceConfig)
                    }
                    updateNamespaceConfig
                },
                {
                    fn getNextChainId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getNextChainIdCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getNextChainId)
                    }
                    getNextChainId
                },
                {
                    fn hasRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn nextAutoChainId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <nextAutoChainIdCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::nextAutoChainId)
                    }
                    nextAutoChainId
                },
                {
                    fn isChainBannedFromGasTracking(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <isChainBannedFromGasTrackingCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::isChainBannedFromGasTracking)
                    }
                    isChainBannedFromGasTracking
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn getContractsForGasTracking(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getContractsForGasTrackingCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getContractsForGasTracking)
                    }
                    getContractsForGasTracking
                },
                {
                    fn getProxyBytecode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getProxyBytecodeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getProxyBytecode)
                    }
                    getProxyBytecode
                },
                {
                    fn usedNamespaces(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <usedNamespacesCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::usedNamespaces)
                    }
                    usedNamespaces
                },
                {
                    fn gasTrackingBanlist(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <gasTrackingBanlistCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::gasTrackingBanlist)
                    }
                    gasTrackingBanlist
                },
                {
                    fn computeStubImplementationAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <computeStubImplementationAddressCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::computeStubImplementationAddress)
                    }
                    computeStubImplementationAddress
                },
                {
                    fn revokeRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn MANAGER_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::MANAGER_ROLE)
                    }
                    MANAGER_ROLE
                },
                {
                    fn getImplBytecode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getImplBytecodeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getImplBytecode)
                    }
                    getImplBytecode
                },
                {
                    fn removeAllowedImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <removeAllowedImplementationCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::removeAllowedImplementation)
                    }
                    removeAllowedImplementation
                },
                {
                    fn syndicateChainImpl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <syndicateChainImplCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::syndicateChainImpl)
                    }
                    syndicateChainImpl
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MANAGER_ROLE(inner) => {
                    <MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::addAllowedImplementation(inner) => {
                    <addAllowedImplementationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::allowedImplementations(inner) => {
                    <allowedImplementationsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::appchainContracts(inner) => {
                    <appchainContractsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::banChainFromGasTracking(inner) => {
                    <banChainFromGasTrackingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::chainIDs(inner) => {
                    <chainIDsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::computeSequencingChainAddress(inner) => {
                    <computeSequencingChainAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::computeStubImplementationAddress(inner) => {
                    <computeStubImplementationAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::createSyndicateSequencingChain(inner) => {
                    <createSyndicateSequencingChainCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::gasTrackingBanlist(inner) => {
                    <gasTrackingBanlistCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAllowedImplementations(inner) => {
                    <getAllowedImplementationsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAppchainsAndContractsForGasTracking(inner) => {
                    <getAppchainsAndContractsForGasTrackingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getContractsForGasTracking(inner) => {
                    <getContractsForGasTrackingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getImplBytecode(inner) => {
                    <getImplBytecodeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getNextChainId(inner) => {
                    <getNextChainIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getProxyBytecode(inner) => {
                    <getProxyBytecodeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getTotalAppchainsForGasTracking(inner) => {
                    <getTotalAppchainsForGasTrackingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isChainBannedFromGasTracking(inner) => {
                    <isChainBannedFromGasTrackingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isChainIdUsed(inner) => {
                    <isChainIdUsedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isImplementationAllowed(inner) => {
                    <isImplementationAllowedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::namespacePrefix(inner) => {
                    <namespacePrefixCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::nextAutoChainId(inner) => {
                    <nextAutoChainIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::notifyChainUpgrade(inner) => {
                    <notifyChainUpgradeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::numberOfChainsBannedFromGasTracking(inner) => {
                    <numberOfChainsBannedFromGasTrackingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::removeAllowedImplementation(inner) => {
                    <removeAllowedImplementationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setDefaultImplementation(inner) => {
                    <setDefaultImplementationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::stubImplementation(inner) => {
                    <stubImplementationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::syndicateChainImpl(inner) => {
                    <syndicateChainImplCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::updateNamespaceConfig(inner) => {
                    <updateNamespaceConfigCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::usedNamespaces(inner) => {
                    <usedNamespacesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MANAGER_ROLE(inner) => {
                    <MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::addAllowedImplementation(inner) => {
                    <addAllowedImplementationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::allowedImplementations(inner) => {
                    <allowedImplementationsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::appchainContracts(inner) => {
                    <appchainContractsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::banChainFromGasTracking(inner) => {
                    <banChainFromGasTrackingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::chainIDs(inner) => {
                    <chainIDsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::computeSequencingChainAddress(inner) => {
                    <computeSequencingChainAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::computeStubImplementationAddress(inner) => {
                    <computeStubImplementationAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::createSyndicateSequencingChain(inner) => {
                    <createSyndicateSequencingChainCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::gasTrackingBanlist(inner) => {
                    <gasTrackingBanlistCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAllowedImplementations(inner) => {
                    <getAllowedImplementationsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAppchainsAndContractsForGasTracking(inner) => {
                    <getAppchainsAndContractsForGasTrackingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getContractsForGasTracking(inner) => {
                    <getContractsForGasTrackingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getImplBytecode(inner) => {
                    <getImplBytecodeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getNextChainId(inner) => {
                    <getNextChainIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getProxyBytecode(inner) => {
                    <getProxyBytecodeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getTotalAppchainsForGasTracking(inner) => {
                    <getTotalAppchainsForGasTrackingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::isChainBannedFromGasTracking(inner) => {
                    <isChainBannedFromGasTrackingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isChainIdUsed(inner) => {
                    <isChainIdUsedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isImplementationAllowed(inner) => {
                    <isImplementationAllowedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::namespacePrefix(inner) => {
                    <namespacePrefixCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::nextAutoChainId(inner) => {
                    <nextAutoChainIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::notifyChainUpgrade(inner) => {
                    <notifyChainUpgradeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::numberOfChainsBannedFromGasTracking(inner) => {
                    <numberOfChainsBannedFromGasTrackingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::removeAllowedImplementation(inner) => {
                    <removeAllowedImplementationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setDefaultImplementation(inner) => {
                    <setDefaultImplementationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::stubImplementation(inner) => {
                    <stubImplementationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::syndicateChainImpl(inner) => {
                    <syndicateChainImplCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::updateNamespaceConfig(inner) => {
                    <updateNamespaceConfigCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::usedNamespaces(inner) => {
                    <usedNamespacesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`SyndicateFactory`](self) custom errors.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum SyndicateFactoryErrors {
        #[allow(missing_docs)]
        AccessControlBadConfirmation(AccessControlBadConfirmation),
        #[allow(missing_docs)]
        AccessControlUnauthorizedAccount(AccessControlUnauthorizedAccount),
        #[allow(missing_docs)]
        CannotRemoveDefaultImplementation(CannotRemoveDefaultImplementation),
        #[allow(missing_docs)]
        ChainIdAlreadyExists(ChainIdAlreadyExists),
        #[allow(missing_docs)]
        Create2EmptyBytecode(Create2EmptyBytecode),
        #[allow(missing_docs)]
        EnforcedPause(EnforcedPause),
        #[allow(missing_docs)]
        ExpectedPause(ExpectedPause),
        #[allow(missing_docs)]
        FailedDeployment(FailedDeployment),
        #[allow(missing_docs)]
        FailedToUpgradeToLatestImplementation(FailedToUpgradeToLatestImplementation),
        #[allow(missing_docs)]
        ImplementationAlreadyAllowed(ImplementationAlreadyAllowed),
        #[allow(missing_docs)]
        ImplementationNotAllowed(ImplementationNotAllowed),
        #[allow(missing_docs)]
        InsufficientBalance(InsufficientBalance),
        #[allow(missing_docs)]
        OnlyChainCanNotifyUpgrade(OnlyChainCanNotifyUpgrade),
        #[allow(missing_docs)]
        StringsInvalidChar(StringsInvalidChar),
        #[allow(missing_docs)]
        ZeroAddress(ZeroAddress),
    }
    #[automatically_derived]
    impl SyndicateFactoryErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [24u8, 51u8, 162u8, 75u8],
            [36u8, 89u8, 29u8, 137u8],
            [47u8, 217u8, 173u8, 174u8],
            [76u8, 162u8, 73u8, 220u8],
            [102u8, 151u8, 178u8, 50u8],
            [141u8, 252u8, 32u8, 43u8],
            [148u8, 226u8, 115u8, 126u8],
            [171u8, 110u8, 181u8, 188u8],
            [176u8, 110u8, 191u8, 61u8],
            [207u8, 71u8, 145u8, 129u8],
            [213u8, 204u8, 74u8, 15u8],
            [217u8, 46u8, 35u8, 61u8],
            [217u8, 60u8, 6u8, 101u8],
            [226u8, 81u8, 125u8, 63u8],
            [251u8, 16u8, 24u8, 9u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndicateFactoryErrors {
        const NAME: &'static str = "SyndicateFactoryErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 15usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AccessControlBadConfirmation(_) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AccessControlUnauthorizedAccount(_) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CannotRemoveDefaultImplementation(_) => {
                    <CannotRemoveDefaultImplementation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ChainIdAlreadyExists(_) => {
                    <ChainIdAlreadyExists as alloy_sol_types::SolError>::SELECTOR
                }
                Self::Create2EmptyBytecode(_) => {
                    <Create2EmptyBytecode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EnforcedPause(_) => {
                    <EnforcedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ExpectedPause(_) => {
                    <ExpectedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FailedDeployment(_) => {
                    <FailedDeployment as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FailedToUpgradeToLatestImplementation(_) => {
                    <FailedToUpgradeToLatestImplementation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ImplementationAlreadyAllowed(_) => {
                    <ImplementationAlreadyAllowed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ImplementationNotAllowed(_) => {
                    <ImplementationNotAllowed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientBalance(_) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OnlyChainCanNotifyUpgrade(_) => {
                    <OnlyChainCanNotifyUpgrade as alloy_sol_types::SolError>::SELECTOR
                }
                Self::StringsInvalidChar(_) => {
                    <StringsInvalidChar as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAddress(_) => {
                    <ZeroAddress as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<SyndicateFactoryErrors>] = &[
                {
                    fn ImplementationAlreadyAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <ImplementationAlreadyAllowed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::ImplementationAlreadyAllowed)
                    }
                    ImplementationAlreadyAllowed
                },
                {
                    fn ChainIdAlreadyExists(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <ChainIdAlreadyExists as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::ChainIdAlreadyExists)
                    }
                    ChainIdAlreadyExists
                },
                {
                    fn OnlyChainCanNotifyUpgrade(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <OnlyChainCanNotifyUpgrade as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::OnlyChainCanNotifyUpgrade)
                    }
                    OnlyChainCanNotifyUpgrade
                },
                {
                    fn Create2EmptyBytecode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <Create2EmptyBytecode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::Create2EmptyBytecode)
                    }
                    Create2EmptyBytecode
                },
                {
                    fn AccessControlBadConfirmation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::AccessControlBadConfirmation)
                    }
                    AccessControlBadConfirmation
                },
                {
                    fn ExpectedPause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <ExpectedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::ExpectedPause)
                    }
                    ExpectedPause
                },
                {
                    fn StringsInvalidChar(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <StringsInvalidChar as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::StringsInvalidChar)
                    }
                    StringsInvalidChar
                },
                {
                    fn FailedToUpgradeToLatestImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <FailedToUpgradeToLatestImplementation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                SyndicateFactoryErrors::FailedToUpgradeToLatestImplementation,
                            )
                    }
                    FailedToUpgradeToLatestImplementation
                },
                {
                    fn FailedDeployment(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <FailedDeployment as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::FailedDeployment)
                    }
                    FailedDeployment
                },
                {
                    fn InsufficientBalance(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <InsufficientBalance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::InsufficientBalance)
                    }
                    InsufficientBalance
                },
                {
                    fn CannotRemoveDefaultImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <CannotRemoveDefaultImplementation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                SyndicateFactoryErrors::CannotRemoveDefaultImplementation,
                            )
                    }
                    CannotRemoveDefaultImplementation
                },
                {
                    fn ZeroAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <ZeroAddress as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(SyndicateFactoryErrors::ZeroAddress)
                    }
                    ZeroAddress
                },
                {
                    fn EnforcedPause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <EnforcedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::EnforcedPause)
                    }
                    EnforcedPause
                },
                {
                    fn AccessControlUnauthorizedAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                SyndicateFactoryErrors::AccessControlUnauthorizedAccount,
                            )
                    }
                    AccessControlUnauthorizedAccount
                },
                {
                    fn ImplementationNotAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <ImplementationNotAllowed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::ImplementationNotAllowed)
                    }
                    ImplementationNotAllowed
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<SyndicateFactoryErrors>] = &[
                {
                    fn ImplementationAlreadyAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <ImplementationAlreadyAllowed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::ImplementationAlreadyAllowed)
                    }
                    ImplementationAlreadyAllowed
                },
                {
                    fn ChainIdAlreadyExists(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <ChainIdAlreadyExists as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::ChainIdAlreadyExists)
                    }
                    ChainIdAlreadyExists
                },
                {
                    fn OnlyChainCanNotifyUpgrade(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <OnlyChainCanNotifyUpgrade as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::OnlyChainCanNotifyUpgrade)
                    }
                    OnlyChainCanNotifyUpgrade
                },
                {
                    fn Create2EmptyBytecode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <Create2EmptyBytecode as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::Create2EmptyBytecode)
                    }
                    Create2EmptyBytecode
                },
                {
                    fn AccessControlBadConfirmation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::AccessControlBadConfirmation)
                    }
                    AccessControlBadConfirmation
                },
                {
                    fn ExpectedPause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <ExpectedPause as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::ExpectedPause)
                    }
                    ExpectedPause
                },
                {
                    fn StringsInvalidChar(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <StringsInvalidChar as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::StringsInvalidChar)
                    }
                    StringsInvalidChar
                },
                {
                    fn FailedToUpgradeToLatestImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <FailedToUpgradeToLatestImplementation as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                SyndicateFactoryErrors::FailedToUpgradeToLatestImplementation,
                            )
                    }
                    FailedToUpgradeToLatestImplementation
                },
                {
                    fn FailedDeployment(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <FailedDeployment as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::FailedDeployment)
                    }
                    FailedDeployment
                },
                {
                    fn InsufficientBalance(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <InsufficientBalance as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::InsufficientBalance)
                    }
                    InsufficientBalance
                },
                {
                    fn CannotRemoveDefaultImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <CannotRemoveDefaultImplementation as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                SyndicateFactoryErrors::CannotRemoveDefaultImplementation,
                            )
                    }
                    CannotRemoveDefaultImplementation
                },
                {
                    fn ZeroAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <ZeroAddress as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::ZeroAddress)
                    }
                    ZeroAddress
                },
                {
                    fn EnforcedPause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <EnforcedPause as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::EnforcedPause)
                    }
                    EnforcedPause
                },
                {
                    fn AccessControlUnauthorizedAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                SyndicateFactoryErrors::AccessControlUnauthorizedAccount,
                            )
                    }
                    AccessControlUnauthorizedAccount
                },
                {
                    fn ImplementationNotAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <ImplementationNotAllowed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::ImplementationNotAllowed)
                    }
                    ImplementationNotAllowed
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CannotRemoveDefaultImplementation(inner) => {
                    <CannotRemoveDefaultImplementation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ChainIdAlreadyExists(inner) => {
                    <ChainIdAlreadyExists as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::Create2EmptyBytecode(inner) => {
                    <Create2EmptyBytecode as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::FailedDeployment(inner) => {
                    <FailedDeployment as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::FailedToUpgradeToLatestImplementation(inner) => {
                    <FailedToUpgradeToLatestImplementation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ImplementationAlreadyAllowed(inner) => {
                    <ImplementationAlreadyAllowed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ImplementationNotAllowed(inner) => {
                    <ImplementationNotAllowed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientBalance(inner) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OnlyChainCanNotifyUpgrade(inner) => {
                    <OnlyChainCanNotifyUpgrade as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::StringsInvalidChar(inner) => {
                    <StringsInvalidChar as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CannotRemoveDefaultImplementation(inner) => {
                    <CannotRemoveDefaultImplementation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ChainIdAlreadyExists(inner) => {
                    <ChainIdAlreadyExists as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::Create2EmptyBytecode(inner) => {
                    <Create2EmptyBytecode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FailedDeployment(inner) => {
                    <FailedDeployment as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FailedToUpgradeToLatestImplementation(inner) => {
                    <FailedToUpgradeToLatestImplementation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ImplementationAlreadyAllowed(inner) => {
                    <ImplementationAlreadyAllowed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ImplementationNotAllowed(inner) => {
                    <ImplementationNotAllowed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientBalance(inner) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OnlyChainCanNotifyUpgrade(inner) => {
                    <OnlyChainCanNotifyUpgrade as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::StringsInvalidChar(inner) => {
                    <StringsInvalidChar as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`SyndicateFactory`](self) events.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum SyndicateFactoryEvents {
        #[allow(missing_docs)]
        ChainBannedFromGasTracking(ChainBannedFromGasTracking),
        #[allow(missing_docs)]
        ChainIdManuallyMarked(ChainIdManuallyMarked),
        #[allow(missing_docs)]
        ImplementationAdded(ImplementationAdded),
        #[allow(missing_docs)]
        NamespaceConfigUpdated(NamespaceConfigUpdated),
        #[allow(missing_docs)]
        Paused(Paused),
        #[allow(missing_docs)]
        RoleAdminChanged(RoleAdminChanged),
        #[allow(missing_docs)]
        RoleGranted(RoleGranted),
        #[allow(missing_docs)]
        RoleRevoked(RoleRevoked),
        #[allow(missing_docs)]
        SyndicateSequencingChainCreated(SyndicateSequencingChainCreated),
        #[allow(missing_docs)]
        Unpaused(Unpaused),
    }
    #[automatically_derived]
    impl SyndicateFactoryEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                33u8, 194u8, 92u8, 208u8, 165u8, 78u8, 22u8, 9u8, 227u8, 230u8, 139u8,
                51u8, 86u8, 147u8, 238u8, 251u8, 105u8, 77u8, 94u8, 241u8, 124u8, 195u8,
                43u8, 16u8, 111u8, 145u8, 63u8, 138u8, 31u8, 27u8, 128u8, 88u8,
            ],
            [
                47u8, 135u8, 136u8, 17u8, 126u8, 126u8, 255u8, 29u8, 130u8, 233u8, 38u8,
                236u8, 121u8, 73u8, 1u8, 209u8, 124u8, 120u8, 2u8, 74u8, 80u8, 39u8, 9u8,
                64u8, 48u8, 69u8, 64u8, 167u8, 51u8, 101u8, 111u8, 13u8,
            ],
            [
                51u8, 28u8, 237u8, 199u8, 31u8, 40u8, 196u8, 109u8, 70u8, 118u8, 145u8,
                119u8, 6u8, 117u8, 181u8, 134u8, 232u8, 170u8, 119u8, 160u8, 212u8,
                254u8, 9u8, 242u8, 87u8, 208u8, 30u8, 240u8, 11u8, 193u8, 84u8, 88u8,
            ],
            [
                73u8, 178u8, 31u8, 30u8, 65u8, 144u8, 219u8, 139u8, 10u8, 147u8, 60u8,
                149u8, 30u8, 208u8, 19u8, 222u8, 34u8, 44u8, 132u8, 124u8, 21u8, 70u8,
                23u8, 84u8, 104u8, 45u8, 170u8, 46u8, 171u8, 31u8, 219u8, 210u8,
            ],
            [
                93u8, 185u8, 238u8, 10u8, 73u8, 91u8, 242u8, 230u8, 255u8, 156u8, 145u8,
                167u8, 131u8, 76u8, 27u8, 164u8, 253u8, 210u8, 68u8, 165u8, 232u8, 170u8,
                78u8, 83u8, 123u8, 211u8, 138u8, 234u8, 228u8, 176u8, 115u8, 170u8,
            ],
            [
                98u8, 231u8, 140u8, 234u8, 1u8, 190u8, 227u8, 32u8, 205u8, 78u8, 66u8,
                2u8, 112u8, 181u8, 234u8, 116u8, 0u8, 13u8, 17u8, 176u8, 201u8, 247u8,
                71u8, 84u8, 235u8, 219u8, 252u8, 84u8, 75u8, 5u8, 162u8, 88u8,
            ],
            [
                189u8, 121u8, 184u8, 111u8, 254u8, 10u8, 184u8, 232u8, 119u8, 97u8, 81u8,
                81u8, 66u8, 23u8, 205u8, 124u8, 172u8, 213u8, 44u8, 144u8, 159u8, 102u8,
                71u8, 92u8, 58u8, 244u8, 78u8, 18u8, 159u8, 11u8, 0u8, 255u8,
            ],
            [
                217u8, 225u8, 35u8, 145u8, 119u8, 191u8, 189u8, 42u8, 235u8, 245u8,
                208u8, 242u8, 15u8, 192u8, 117u8, 230u8, 223u8, 90u8, 80u8, 44u8, 89u8,
                209u8, 33u8, 172u8, 213u8, 115u8, 66u8, 199u8, 131u8, 227u8, 19u8, 100u8,
            ],
            [
                235u8, 180u8, 197u8, 13u8, 235u8, 40u8, 81u8, 146u8, 209u8, 194u8, 170u8,
                136u8, 50u8, 177u8, 254u8, 235u8, 7u8, 139u8, 160u8, 253u8, 146u8, 187u8,
                67u8, 156u8, 13u8, 238u8, 40u8, 235u8, 233u8, 187u8, 54u8, 233u8,
            ],
            [
                246u8, 57u8, 31u8, 92u8, 50u8, 217u8, 198u8, 157u8, 42u8, 71u8, 234u8,
                103u8, 11u8, 68u8, 41u8, 116u8, 181u8, 57u8, 53u8, 209u8, 237u8, 199u8,
                253u8, 100u8, 235u8, 33u8, 224u8, 71u8, 168u8, 57u8, 23u8, 27u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for SyndicateFactoryEvents {
        const NAME: &'static str = "SyndicateFactoryEvents";
        const COUNT: usize = 10usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <ChainBannedFromGasTracking as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ChainBannedFromGasTracking as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ChainBannedFromGasTracking)
                }
                Some(
                    <ChainIdManuallyMarked as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ChainIdManuallyMarked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ChainIdManuallyMarked)
                }
                Some(
                    <ImplementationAdded as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ImplementationAdded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ImplementationAdded)
                }
                Some(
                    <NamespaceConfigUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <NamespaceConfigUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::NamespaceConfigUpdated)
                }
                Some(<Paused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Paused as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Paused)
                }
                Some(<RoleAdminChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleAdminChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoleAdminChanged)
                }
                Some(<RoleGranted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleGranted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoleGranted)
                }
                Some(<RoleRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoleRevoked)
                }
                Some(
                    <SyndicateSequencingChainCreated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <SyndicateSequencingChainCreated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::SyndicateSequencingChainCreated)
                }
                Some(<Unpaused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Unpaused as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Unpaused)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for SyndicateFactoryEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ChainBannedFromGasTracking(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ChainIdManuallyMarked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ImplementationAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::NamespaceConfigUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SyndicateSequencingChainCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ChainBannedFromGasTracking(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ChainIdManuallyMarked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ImplementationAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::NamespaceConfigUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SyndicateSequencingChainCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`SyndicateFactory`](self) contract instance.

See the [wrapper's documentation](`SyndicateFactoryInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> SyndicateFactoryInstance<P, N> {
        SyndicateFactoryInstance::<P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        admin: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<SyndicateFactoryInstance<P, N>>,
    > {
        SyndicateFactoryInstance::<P, N>::deploy(provider, admin)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        admin: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<P, N> {
        SyndicateFactoryInstance::<P, N>::deploy_builder(provider, admin)
    }
    /**A [`SyndicateFactory`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`SyndicateFactory`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct SyndicateFactoryInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for SyndicateFactoryInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("SyndicateFactoryInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > SyndicateFactoryInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`SyndicateFactory`](self) contract instance.

See the [wrapper's documentation](`SyndicateFactoryInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            admin: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<SyndicateFactoryInstance<P, N>> {
            let call_builder = Self::deploy_builder(provider, admin);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            admin: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall { admin },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> SyndicateFactoryInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> SyndicateFactoryInstance<P, N> {
            SyndicateFactoryInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > SyndicateFactoryInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`DEFAULT_ADMIN_ROLE`] function.
        pub fn DEFAULT_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, DEFAULT_ADMIN_ROLECall, N> {
            self.call_builder(&DEFAULT_ADMIN_ROLECall)
        }
        ///Creates a new call builder for the [`MANAGER_ROLE`] function.
        pub fn MANAGER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, MANAGER_ROLECall, N> {
            self.call_builder(&MANAGER_ROLECall)
        }
        ///Creates a new call builder for the [`addAllowedImplementation`] function.
        pub fn addAllowedImplementation(
            &self,
            implementation: alloy::sol_types::private::Address,
            makeDefault: bool,
        ) -> alloy_contract::SolCallBuilder<&P, addAllowedImplementationCall, N> {
            self.call_builder(
                &addAllowedImplementationCall {
                    implementation,
                    makeDefault,
                },
            )
        }
        ///Creates a new call builder for the [`allowedImplementations`] function.
        pub fn allowedImplementations(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, allowedImplementationsCall, N> {
            self.call_builder(&allowedImplementationsCall(_0))
        }
        ///Creates a new call builder for the [`appchainContracts`] function.
        pub fn appchainContracts(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, appchainContractsCall, N> {
            self.call_builder(&appchainContractsCall(_0))
        }
        ///Creates a new call builder for the [`banChainFromGasTracking`] function.
        pub fn banChainFromGasTracking(
            &self,
            chainId: alloy::sol_types::private::primitives::aliases::U256,
            notAllowedImplementation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, banChainFromGasTrackingCall, N> {
            self.call_builder(
                &banChainFromGasTrackingCall {
                    chainId,
                    notAllowedImplementation,
                },
            )
        }
        ///Creates a new call builder for the [`chainIDs`] function.
        pub fn chainIDs(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, chainIDsCall, N> {
            self.call_builder(&chainIDsCall(_0))
        }
        ///Creates a new call builder for the [`computeSequencingChainAddress`] function.
        pub fn computeSequencingChainAddress(
            &self,
            chainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, computeSequencingChainAddressCall, N> {
            self.call_builder(
                &computeSequencingChainAddressCall {
                    chainId,
                },
            )
        }
        ///Creates a new call builder for the [`computeStubImplementationAddress`] function.
        pub fn computeStubImplementationAddress(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            &P,
            computeStubImplementationAddressCall,
            N,
        > {
            self.call_builder(&computeStubImplementationAddressCall)
        }
        ///Creates a new call builder for the [`createSyndicateSequencingChain`] function.
        pub fn createSyndicateSequencingChain(
            &self,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
            admin: alloy::sol_types::private::Address,
            permissionModule: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, createSyndicateSequencingChainCall, N> {
            self.call_builder(
                &createSyndicateSequencingChainCall {
                    appchainId,
                    admin,
                    permissionModule,
                },
            )
        }
        ///Creates a new call builder for the [`gasTrackingBanlist`] function.
        pub fn gasTrackingBanlist(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, gasTrackingBanlistCall, N> {
            self.call_builder(&gasTrackingBanlistCall(_0))
        }
        ///Creates a new call builder for the [`getAllowedImplementations`] function.
        pub fn getAllowedImplementations(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getAllowedImplementationsCall, N> {
            self.call_builder(&getAllowedImplementationsCall)
        }
        ///Creates a new call builder for the [`getAppchainsAndContractsForGasTracking`] function.
        pub fn getAppchainsAndContractsForGasTracking(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            &P,
            getAppchainsAndContractsForGasTrackingCall,
            N,
        > {
            self.call_builder(&getAppchainsAndContractsForGasTrackingCall)
        }
        ///Creates a new call builder for the [`getContractsForGasTracking`] function.
        pub fn getContractsForGasTracking(
            &self,
            _chainIDs: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
        ) -> alloy_contract::SolCallBuilder<&P, getContractsForGasTrackingCall, N> {
            self.call_builder(
                &getContractsForGasTrackingCall {
                    _chainIDs,
                },
            )
        }
        ///Creates a new call builder for the [`getImplBytecode`] function.
        pub fn getImplBytecode(
            &self,
            r#impl: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getImplBytecodeCall, N> {
            self.call_builder(&getImplBytecodeCall { r#impl })
        }
        ///Creates a new call builder for the [`getNextChainId`] function.
        pub fn getNextChainId(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getNextChainIdCall, N> {
            self.call_builder(&getNextChainIdCall)
        }
        ///Creates a new call builder for the [`getProxyBytecode`] function.
        pub fn getProxyBytecode(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getProxyBytecodeCall, N> {
            self.call_builder(&getProxyBytecodeCall)
        }
        ///Creates a new call builder for the [`getRoleAdmin`] function.
        pub fn getRoleAdmin(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, getRoleAdminCall, N> {
            self.call_builder(&getRoleAdminCall { role })
        }
        ///Creates a new call builder for the [`getTotalAppchainsForGasTracking`] function.
        pub fn getTotalAppchainsForGasTracking(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getTotalAppchainsForGasTrackingCall, N> {
            self.call_builder(&getTotalAppchainsForGasTrackingCall)
        }
        ///Creates a new call builder for the [`grantRole`] function.
        pub fn grantRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, grantRoleCall, N> {
            self.call_builder(&grantRoleCall { role, account })
        }
        ///Creates a new call builder for the [`hasRole`] function.
        pub fn hasRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, hasRoleCall, N> {
            self.call_builder(&hasRoleCall { role, account })
        }
        ///Creates a new call builder for the [`isChainBannedFromGasTracking`] function.
        pub fn isChainBannedFromGasTracking(
            &self,
            chainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, isChainBannedFromGasTrackingCall, N> {
            self.call_builder(
                &isChainBannedFromGasTrackingCall {
                    chainId,
                },
            )
        }
        ///Creates a new call builder for the [`isChainIdUsed`] function.
        pub fn isChainIdUsed(
            &self,
            chainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, isChainIdUsedCall, N> {
            self.call_builder(&isChainIdUsedCall { chainId })
        }
        ///Creates a new call builder for the [`isImplementationAllowed`] function.
        pub fn isImplementationAllowed(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, isImplementationAllowedCall, N> {
            self.call_builder(&isImplementationAllowedCall(_0))
        }
        ///Creates a new call builder for the [`namespacePrefix`] function.
        pub fn namespacePrefix(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, namespacePrefixCall, N> {
            self.call_builder(&namespacePrefixCall)
        }
        ///Creates a new call builder for the [`nextAutoChainId`] function.
        pub fn nextAutoChainId(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, nextAutoChainIdCall, N> {
            self.call_builder(&nextAutoChainIdCall)
        }
        ///Creates a new call builder for the [`notifyChainUpgrade`] function.
        pub fn notifyChainUpgrade(
            &self,
            chainId: alloy::sol_types::private::primitives::aliases::U256,
            newImplementation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, notifyChainUpgradeCall, N> {
            self.call_builder(
                &notifyChainUpgradeCall {
                    chainId,
                    newImplementation,
                },
            )
        }
        ///Creates a new call builder for the [`numberOfChainsBannedFromGasTracking`] function.
        pub fn numberOfChainsBannedFromGasTracking(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            &P,
            numberOfChainsBannedFromGasTrackingCall,
            N,
        > {
            self.call_builder(&numberOfChainsBannedFromGasTrackingCall)
        }
        ///Creates a new call builder for the [`pause`] function.
        pub fn pause(&self) -> alloy_contract::SolCallBuilder<&P, pauseCall, N> {
            self.call_builder(&pauseCall)
        }
        ///Creates a new call builder for the [`paused`] function.
        pub fn paused(&self) -> alloy_contract::SolCallBuilder<&P, pausedCall, N> {
            self.call_builder(&pausedCall)
        }
        ///Creates a new call builder for the [`removeAllowedImplementation`] function.
        pub fn removeAllowedImplementation(
            &self,
            implementation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, removeAllowedImplementationCall, N> {
            self.call_builder(
                &removeAllowedImplementationCall {
                    implementation,
                },
            )
        }
        ///Creates a new call builder for the [`renounceRole`] function.
        pub fn renounceRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            callerConfirmation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, renounceRoleCall, N> {
            self.call_builder(
                &renounceRoleCall {
                    role,
                    callerConfirmation,
                },
            )
        }
        ///Creates a new call builder for the [`revokeRole`] function.
        pub fn revokeRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, revokeRoleCall, N> {
            self.call_builder(&revokeRoleCall { role, account })
        }
        ///Creates a new call builder for the [`setDefaultImplementation`] function.
        pub fn setDefaultImplementation(
            &self,
            implementation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, setDefaultImplementationCall, N> {
            self.call_builder(
                &setDefaultImplementationCall {
                    implementation,
                },
            )
        }
        ///Creates a new call builder for the [`stubImplementation`] function.
        pub fn stubImplementation(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, stubImplementationCall, N> {
            self.call_builder(&stubImplementationCall)
        }
        ///Creates a new call builder for the [`supportsInterface`] function.
        pub fn supportsInterface(
            &self,
            interfaceId: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<&P, supportsInterfaceCall, N> {
            self.call_builder(
                &supportsInterfaceCall {
                    interfaceId,
                },
            )
        }
        ///Creates a new call builder for the [`syndicateChainImpl`] function.
        pub fn syndicateChainImpl(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, syndicateChainImplCall, N> {
            self.call_builder(&syndicateChainImplCall)
        }
        ///Creates a new call builder for the [`unpause`] function.
        pub fn unpause(&self) -> alloy_contract::SolCallBuilder<&P, unpauseCall, N> {
            self.call_builder(&unpauseCall)
        }
        ///Creates a new call builder for the [`updateNamespaceConfig`] function.
        pub fn updateNamespaceConfig(
            &self,
            newPrefix: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, updateNamespaceConfigCall, N> {
            self.call_builder(
                &updateNamespaceConfigCall {
                    newPrefix,
                },
            )
        }
        ///Creates a new call builder for the [`usedNamespaces`] function.
        pub fn usedNamespaces(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, usedNamespacesCall, N> {
            self.call_builder(&usedNamespacesCall(_0))
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > SyndicateFactoryInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`ChainBannedFromGasTracking`] event.
        pub fn ChainBannedFromGasTracking_filter(
            &self,
        ) -> alloy_contract::Event<&P, ChainBannedFromGasTracking, N> {
            self.event_filter::<ChainBannedFromGasTracking>()
        }
        ///Creates a new event filter for the [`ChainIdManuallyMarked`] event.
        pub fn ChainIdManuallyMarked_filter(
            &self,
        ) -> alloy_contract::Event<&P, ChainIdManuallyMarked, N> {
            self.event_filter::<ChainIdManuallyMarked>()
        }
        ///Creates a new event filter for the [`ImplementationAdded`] event.
        pub fn ImplementationAdded_filter(
            &self,
        ) -> alloy_contract::Event<&P, ImplementationAdded, N> {
            self.event_filter::<ImplementationAdded>()
        }
        ///Creates a new event filter for the [`NamespaceConfigUpdated`] event.
        pub fn NamespaceConfigUpdated_filter(
            &self,
        ) -> alloy_contract::Event<&P, NamespaceConfigUpdated, N> {
            self.event_filter::<NamespaceConfigUpdated>()
        }
        ///Creates a new event filter for the [`Paused`] event.
        pub fn Paused_filter(&self) -> alloy_contract::Event<&P, Paused, N> {
            self.event_filter::<Paused>()
        }
        ///Creates a new event filter for the [`RoleAdminChanged`] event.
        pub fn RoleAdminChanged_filter(
            &self,
        ) -> alloy_contract::Event<&P, RoleAdminChanged, N> {
            self.event_filter::<RoleAdminChanged>()
        }
        ///Creates a new event filter for the [`RoleGranted`] event.
        pub fn RoleGranted_filter(&self) -> alloy_contract::Event<&P, RoleGranted, N> {
            self.event_filter::<RoleGranted>()
        }
        ///Creates a new event filter for the [`RoleRevoked`] event.
        pub fn RoleRevoked_filter(&self) -> alloy_contract::Event<&P, RoleRevoked, N> {
            self.event_filter::<RoleRevoked>()
        }
        ///Creates a new event filter for the [`SyndicateSequencingChainCreated`] event.
        pub fn SyndicateSequencingChainCreated_filter(
            &self,
        ) -> alloy_contract::Event<&P, SyndicateSequencingChainCreated, N> {
            self.event_filter::<SyndicateSequencingChainCreated>()
        }
        ///Creates a new event filter for the [`Unpaused`] event.
        pub fn Unpaused_filter(&self) -> alloy_contract::Event<&P, Unpaused, N> {
            self.event_filter::<Unpaused>()
        }
    }
}
