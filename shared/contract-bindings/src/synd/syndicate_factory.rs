/**

Generated by the following Solidity interface...
```solidity
interface SyndicateFactory {
    type NamespaceState is uint8;

    error AccessControlBadConfirmation();
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
    error AddressEmptyCode(address target);
    error CannotRemoveDefaultImplementation();
    error ChainIdAlreadyExists();
    error Create2EmptyBytecode();
    error ERC1967InvalidImplementation(address implementation);
    error ERC1967NonPayable();
    error EnforcedPause();
    error ExpectedPause();
    error FailedCall();
    error FailedDeployment();
    error FailedToUpgradeToLatestImplementation();
    error ImplementationAlreadyAllowed();
    error ImplementationNotAllowed();
    error InsufficientBalance(uint256 balance, uint256 needed);
    error InvalidInitialization();
    error NotInitializing();
    error OnlyChainCanNotifyUpgrade();
    error StringsInvalidChar();
    error UUPSUnauthorizedCallContext();
    error UUPSUnsupportedProxiableUUID(bytes32 slot);
    error ZeroAddress();

    event ChainBannedFromGasTracking(uint256 indexed chainId, address indexed notAllowedImplementation);
    event ChainIdManuallyMarked(uint256 indexed chainId);
    event DeterministicChainIdGenerated(address indexed sender, uint256 indexed nonce, uint256 indexed chainId);
    event ImplementationAdded(address indexed implementation);
    event Initialized(uint64 version);
    event NamespaceConfigUpdated(uint256 oldNamespacePrefix, uint256 newNamespacePrefix);
    event Paused(address account);
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
    event SyndicateSequencingChainCreated(uint256 indexed appchainId, address indexed sequencingChainAddress, address indexed permissionModuleAddress);
    event Unpaused(address account);
    event Upgraded(address indexed implementation);

    constructor();

    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
    function MANAGER_ROLE() external view returns (bytes32);
    function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
    function addAllowedImplementation(address implementation, bool makeDefault) external;
    function allowedImplementations(uint256) external view returns (address);
    function appchainContracts(uint256) external view returns (address);
    function banChainFromGasTracking(uint256 chainId, address notAllowedImplementation) external;
    function chainIDs(uint256) external view returns (uint256);
    function computeSequencingChainAddress(uint256 chainId) external view returns (address);
    function computeStubImplementationAddress() external view returns (address);
    function createSyndicateSequencingChain(uint256 appchainId, address admin, address permissionModule) external returns (address sequencingChain, uint256 actualChainId);
    function createSyndicateSequencingChainDeterministic(uint256 nonce, address admin, address permissionModule) external returns (address sequencingChain, uint256 actualChainId);
    function createSyndicateSequencingChainWithCustomId(uint256 customChainId, address admin, address permissionModule) external returns (address sequencingChain, uint256 actualChainId);
    function gasTrackingBanlist(uint256) external view returns (bool);
    function generateDeterministicChainId(address sender, uint256 nonce) external pure returns (uint256 chainId);
    function getAllowedImplementations() external view returns (address[] memory);
    function getAppchainsAndContractsForGasTracking() external view returns (uint256[] memory _chainIDs, address[] memory _contracts);
    function getContractsForGasTracking(uint256[] memory _chainIDs) external view returns (address[] memory _contracts);
    function getImplBytecode(address impl) external pure returns (bytes memory);
    function getNextChainId() external view returns (uint256);
    function getNextNonceForSender(address sender) external view returns (uint256);
    function getProxyBytecode() external view returns (bytes memory);
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function getTotalAppchainsForGasTracking() external view returns (uint256);
    function grantRole(bytes32 role, address account) external;
    function hasRole(bytes32 role, address account) external view returns (bool);
    function initialize(address admin) external;
    function isChainBannedFromGasTracking(uint256 chainId) external view returns (bool);
    function isChainIdUsed(uint256 chainId) external view returns (bool);
    function isImplementationAllowed(address) external view returns (bool);
    function namespacePrefix() external view returns (uint256);
    function nextAutoChainId() external view returns (uint256);
    function notifyChainUpgrade(uint256 chainId, address newImplementation) external;
    function numberOfChainsBannedFromGasTracking() external view returns (uint256);
    function pause() external;
    function paused() external view returns (bool);
    function proxiableUUID() external view returns (bytes32);
    function removeAllowedImplementation(address implementation) external;
    function renounceRole(bytes32 role, address callerConfirmation) external;
    function revokeRole(bytes32 role, address account) external;
    function senderNonces(address sender) external view returns (uint256 nonce);
    function setDefaultImplementation(address implementation) external;
    function stubImplementation() external view returns (address);
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
    function syndicateChainImpl() external view returns (address);
    function unpause() external;
    function updateNamespaceConfig(uint256 newPrefix) external;
    function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
    function usedNamespaces(uint256) external view returns (NamespaceState);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "DEFAULT_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "MANAGER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "UPGRADE_INTERFACE_VERSION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "addAllowedImplementation",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "makeDefault",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "allowedImplementations",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "appchainContracts",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "banChainFromGasTracking",
    "inputs": [
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "notAllowedImplementation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "chainIDs",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "computeSequencingChainAddress",
    "inputs": [
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "computeStubImplementationAddress",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "createSyndicateSequencingChain",
    "inputs": [
      {
        "name": "appchainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "admin",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "permissionModule",
        "type": "address",
        "internalType": "contract IRequirementModule"
      }
    ],
    "outputs": [
      {
        "name": "sequencingChain",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "actualChainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "createSyndicateSequencingChainDeterministic",
    "inputs": [
      {
        "name": "nonce",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "admin",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "permissionModule",
        "type": "address",
        "internalType": "contract IRequirementModule"
      }
    ],
    "outputs": [
      {
        "name": "sequencingChain",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "actualChainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "createSyndicateSequencingChainWithCustomId",
    "inputs": [
      {
        "name": "customChainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "admin",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "permissionModule",
        "type": "address",
        "internalType": "contract IRequirementModule"
      }
    ],
    "outputs": [
      {
        "name": "sequencingChain",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "actualChainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "gasTrackingBanlist",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "generateDeterministicChainId",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "nonce",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "getAllowedImplementations",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getAppchainsAndContractsForGasTracking",
    "inputs": [],
    "outputs": [
      {
        "name": "_chainIDs",
        "type": "uint256[]",
        "internalType": "uint256[]"
      },
      {
        "name": "_contracts",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getContractsForGasTracking",
    "inputs": [
      {
        "name": "_chainIDs",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "outputs": [
      {
        "name": "_contracts",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getImplBytecode",
    "inputs": [
      {
        "name": "impl",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "getNextChainId",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getNextNonceForSender",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getProxyBytecode",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleAdmin",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getTotalAppchainsForGasTracking",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "grantRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "hasRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "initialize",
    "inputs": [
      {
        "name": "admin",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "isChainBannedFromGasTracking",
    "inputs": [
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isChainIdUsed",
    "inputs": [
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isImplementationAllowed",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "namespacePrefix",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "nextAutoChainId",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "notifyChainUpgrade",
    "inputs": [
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "newImplementation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "numberOfChainsBannedFromGasTracking",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "paused",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "proxiableUUID",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "removeAllowedImplementation",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "callerConfirmation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "senderNonces",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "nonce",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setDefaultImplementation",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "stubImplementation",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "syndicateChainImpl",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "unpause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateNamespaceConfig",
    "inputs": [
      {
        "name": "newPrefix",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "upgradeToAndCall",
    "inputs": [
      {
        "name": "newImplementation",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "usedNamespaces",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "enum NamespaceState"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "event",
    "name": "ChainBannedFromGasTracking",
    "inputs": [
      {
        "name": "chainId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "notAllowedImplementation",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ChainIdManuallyMarked",
    "inputs": [
      {
        "name": "chainId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DeterministicChainIdGenerated",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "nonce",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "chainId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ImplementationAdded",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialized",
    "inputs": [
      {
        "name": "version",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "NamespaceConfigUpdated",
    "inputs": [
      {
        "name": "oldNamespacePrefix",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "newNamespacePrefix",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Paused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleAdminChanged",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "previousAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleGranted",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleRevoked",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SyndicateSequencingChainCreated",
    "inputs": [
      {
        "name": "appchainId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "sequencingChainAddress",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "permissionModuleAddress",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Unpaused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Upgraded",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AccessControlBadConfirmation",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AccessControlUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "neededRole",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "AddressEmptyCode",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "CannotRemoveDefaultImplementation",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ChainIdAlreadyExists",
    "inputs": []
  },
  {
    "type": "error",
    "name": "Create2EmptyBytecode",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ERC1967InvalidImplementation",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1967NonPayable",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EnforcedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ExpectedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FailedCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FailedDeployment",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FailedToUpgradeToLatestImplementation",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ImplementationAlreadyAllowed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ImplementationNotAllowed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientBalance",
    "inputs": [
      {
        "name": "balance",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "needed",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidInitialization",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotInitializing",
    "inputs": []
  },
  {
    "type": "error",
    "name": "OnlyChainCanNotifyUpgrade",
    "inputs": []
  },
  {
    "type": "error",
    "name": "StringsInvalidChar",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UUPSUnauthorizedCallContext",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UUPSUnsupportedProxiableUUID",
    "inputs": [
      {
        "name": "slot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "ZeroAddress",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod SyndicateFactory {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a080604052346100c257306080525f516020615f505f395f51905f525460ff8160401c166100b3576002600160401b03196001600160401b03821601610060575b604051615e8990816100c78239608051818181611c0b0152611cff0152f35b6001600160401b0319166001600160401b039081175f516020615f505f395f51905f525581527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d290602090a15f80610041565b63f92ee8a960e01b5f5260045ffd5b5f80fdfe6080806040526004361015610012575f80fd5b5f905f3560e01c908162b68a731461251c5750806301ffc9a71461247b57806307a9bee7146123cb57806309d23e24146123935780630d4b4bda146123565780631d1ab15a14612262578063248a9ca314612218578063295710ff146121e0578063297f4c64146121c45780632f2ff15d146121675780633144e8531461212657806332ed68051461209557806336568abe146120385780633f4ba83a14611f7b5780634f1ef28614611c8357806352d1902d14611bf157806356dba77914611bcb5780635bd6588b14611a8f5780635c975abb14611a4e5780636389f8da146119ff57806367a5fb2c146117245780636ab51442146116ec5780636ae7e703146116ca5780636ff6f6c0146116975780637232c133146116625780637c16ffc4146115f65780638456cb591461155d5780638b35ba25146114fe5780638c39aaa4146112e15780638de6e28c146112c657806391d148541461125c578063999d71d41461123e5780639e15d6ff14610f5e578063a08f1a7f1461120e578063a217fddf146111f2578063aae7238c146110e7578063ad3cb1cc14611086578063afeb55f814610fe2578063b416663e14610fc6578063b963ebf314610f8d578063c112ee8c14610f5e578063c4d66de8146109e1578063ca4cd02514610935578063d4f4768f14610593578063d547741f1461052c578063ec87621c146104f1578063ee5ee73c1461042b578063eeeb44ad146102615763ff76aed614610238575f80fd5b3461025e578060031936011261025e5760206001600160a01b0360065416604051908152f35b80fd5b503461025e57602060031936011261025e576001600160a01b0361028361254c565b61028b6129f3565b16808252600860205260ff60408320541615610403576001600160a01b036006541681146103db57815b600754808210156103d457826001600160a01b036102d2846125a7565b90549060031b1c16146102e857506001016102b5565b5f1981019081116103a757906103196001600160a01b0361030b610338946125a7565b90549060031b1c16916125a7565b9091906001600160a01b038084549260031b9316831b921b1916179055565b600754801561037a575f190161034d816125a7565b6001600160a01b0382549160031b1b191690556007555b815260086020526040812060ff19815416905580f35b6024837f4e487b710000000000000000000000000000000000000000000000000000000081526031600452fd5b6024847f4e487b710000000000000000000000000000000000000000000000000000000081526011600452fd5b5050610364565b6004827fd5cc4a0f000000000000000000000000000000000000000000000000000000008152fd5b6004827ffb101809000000000000000000000000000000000000000000000000000000008152fd5b503461025e57602060031936011261025e576104ed906104d961044c61254c565b6102729260206040519261046282870185612610565b858452818401956132fe87396040516104aa8161049c85820194856001600160a01b03606092168152604060208201525f60408201520190565b03601f198101835282612610565b6040519687955180918588015e85019083820190858252519283915e010190815203601f198101835282612610565b6040519182916020835260208301906126ce565b0390f35b503461025e578060031936011261025e5760206040517f241ecf16d79d0f8dbfb92cbc07fe17840425976cf0667f022fe9877caa831b088152f35b503461025e57604060031936011261025e5761058f60043561054c612536565b9061058a610585825f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800602052600160405f20015490565b612a5b565b612d1c565b5080f35b503461025e576001600160a01b036105aa3661267c565b9192906105b5612ddf565b1680158015610924575b6108fc5782159283156108f657338552600b6020526040852054905b6105e582336128c6565b9485875260036020526001600160a01b036040882054166108ce5785929190156108445750338652600b60205260408620610620815461279e565b90555b337f550194668a072a7c7daf12b7751a52478a8a12de0b9f557162d280fb8c74f4738780a46001600160a01b0361066161065b612927565b85612e32565b928486526003602052604086208285167fffffffffffffffffffffffff00000000000000000000000000000000000000008254161790556106a1856127ac565b169084806040517f1794bb3c0000000000000000000000000000000000000000000000000000000060208201526106fd8161049c898830602485016001600160a01b036040929594938160608401971683521660208201520152565b61049c6107476001600160a01b03600654169260405192839160208301957f4f1ef286000000000000000000000000000000000000000000000000000000008752602484016127e8565b519082875af161075561280b565b501561081c576001600160a01b03831690813b1561081857604051907ff2fde38b0000000000000000000000000000000000000000000000000000000082526004820152858160248183865af1801561080d576107f4575b604051806104ed87878787837f49b21f1e4190db8b0a933c951ed013de222c847c15461754682daa2eab1fdbd28e80a46001600160a01b0316835260208301526040820190565b6107ff868092612610565b610809575f6107ad565b8480fd5b6040513d88823e3d90fd5b8580fd5b6004857fab6eb5bc000000000000000000000000000000000000000000000000000000008152fd5b909150338652600b602052604086205481106108a6576001810180911161087957338652600b60205260408620558390610623565b6024867f4e487b710000000000000000000000000000000000000000000000000000000081526011600452fd5b6004867f24591d89000000000000000000000000000000000000000000000000000000008152fd5b6004877f24591d89000000000000000000000000000000000000000000000000000000008152fd5b806105db565b6004847fd92e233d000000000000000000000000000000000000000000000000000000008152fd5b506001600160a01b038216156105bf565b503461025e578060031936011261025e576001600160a01b036055600b6020936107356040519061096887820183612610565b80825286820190613570823961099c87604051809382820195518091875e810186838201520301601f198101835282612610565b51902090506040519060408201527f53594e4449434154455f535455425f5631000000000000000000000000000000858201523081520160ff81532016604051908152f35b503461025e57602060031936011261025e576109fb61254c565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00549060ff8260401c16159167ffffffffffffffff811680159081610f56575b6001149081610f4c575b159081610f43575b50610f1b578260017fffffffffffffffffffffffffffffffffffffffffffffffff00000000000000008316177ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0055610ec6575b506001600160a01b03811615610e9e57610adb90610abc613098565b610ac4613098565b610acc613098565b610ad581612ad4565b50612b83565b506101fe8252600260205260ff6040832054166003811015610e71576002610b04911415612eae565b6101fe8252600260205260408220600160ff198254161790556033805b610dfd57507fd9e1239177bfbd2aebf5d0f20fc075e6df5a502c59d121acd57342c783e31364604083546101fe855581519081526101fe6020820152a160018055604051610735610b756020820183612610565b80825260208201906135708239610bab6020604051809382820195518091875e810187838201520301601f198101835282612610565b805115610dd557517f53594e4449434154455f535455425f56310000000000000000000000000000009184f53d1519811516610d75576001600160a01b03168015610dad577fffffffffffffffffffffffff000000000000000000000000000000000000000060055416176005556040516121e48082019082821067ffffffffffffffff831117610d8057908291613ca58339039083f08015610d75576001600160a01b03610c849116807fffffffffffffffffffffffff000000000000000000000000000000000000000060065416176006556126f3565b6001600160a01b03600654168252600860205260408220600160ff198254161790556001600160a01b036006541690604051917f331cedc71f28c46d467691770675b586e8aa77a0d4fe09f257d01ef00bc154588480a2610ce3575080f35b60207fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2917fffffffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffff7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0054167ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a005560018152a180f35b6040513d84823e3d90fd5b6024857f4e487b710000000000000000000000000000000000000000000000000000000081526041600452fd5b6004837fb06ebf3d000000000000000000000000000000000000000000000000000000008152fd5b6004847f4ca249dc000000000000000000000000000000000000000000000000000000008152fd5b808352600260205260ff6040842054166003811015610e445790610e266001600a931415612eae565b808452600260205260408420600260ff198254161790550480610b21565b6024847f4e487b710000000000000000000000000000000000000000000000000000000081526021600452fd5b6024837f4e487b710000000000000000000000000000000000000000000000000000000081526021600452fd5b6004837fd92e233d000000000000000000000000000000000000000000000000000000008152fd5b7fffffffffffffffffffffffffffffffffffffffffffffff0000000000000000001668010000000000000001177ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00555f610aa0565b6004847ff92ee8a9000000000000000000000000000000000000000000000000000000008152fd5b9050155f610a4d565b303b159150610a45565b849150610a3b565b503461025e57602060031936011261025e5760ff60406020926004358152600984522054166040519015158152f35b503461025e57602060031936011261025e576004358152600260205260ff604082205416604051906003811015610e7157602092508152f35b503461025e578060031936011261025e576104ed6104d9612927565b503461025e576001600160a01b03610ff93661267c565b9192906110046129f3565b61100c612ddf565b1680158015611075575b6108fc5782156108fc5782845260036020526001600160a01b0360408520541661104d576001600160a01b0361066161065b612927565b6004847f24591d89000000000000000000000000000000000000000000000000000000008152fd5b506001600160a01b03821615611016565b503461025e578060031936011261025e57506104ed6040516110a9604082612610565b600581527f352e302e3000000000000000000000000000000000000000000000000000000060208201526040519182916020835260208301906126ce565b503461025e57602060031936011261025e5760043567ffffffffffffffff81116111ee57366023820112156111ee57806004013590611125826126b6565b916111336040519384612610565b8083526024602084019160051b8301019136831161080957602401905b8282106111de575050506111648151612759565b825b82518110156111c8578061117c6001928561278a565b518552600960205260ff60408620541615611198575b01611166565b6111a2818561278a565b51855260036020526001600160a01b036040862054166111c2828561278a565b52611192565b604051602080825281906104ed908201856125d4565b8135815260209182019101611150565b5080fd5b503461025e578060031936011261025e57602090604051908152f35b503461025e57604060031936011261025e57602061123661122d61254c565b602435906128c6565b604051908152f35b503461025e578060031936011261025e576020600154604051908152f35b503461025e57604060031936011261025e576001600160a01b036040611280612536565b9260043581527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b6268006020522091165f52602052602060ff60405f2054166040519015158152f35b503461025e578060031936011261025e57602061123661283a565b503461025e57602060031936011261025e576004357f241ecf16d79d0f8dbfb92cbc07fe17840425976cf0667f022fe9877caa831b0882527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800602052604082206001600160a01b0333165f5260205260ff60405f205416156114ae57801561142a57808252600260205260ff6040832054166003811015610e71576002611389911415612eae565b808252600260205260408220600160ff19825416179055600a8104805b6113e3575060407fd9e1239177bfbd2aebf5d0f20fc075e6df5a502c59d121acd57342c783e313649183549080855582519182526020820152a180f35b808352600260205260ff6040842054166003811015610e44579061140c6001600a931415612eae565b808452600260205260408420600260ff1982541617905504806113a6565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f6e616d65737061636520707265666978206f66203020697320666f726269646460448201527f656e0000000000000000000000000000000000000000000000000000000000006064820152fd5b6044827fe2517d3f000000000000000000000000000000000000000000000000000000008152336004527f241ecf16d79d0f8dbfb92cbc07fe17840425976cf0667f022fe9877caa831b08602452fd5b503461025e57604060031936011261025e576004356001600160a01b03611523612536565b61152b6129f3565b611534836129b5565b16907febb4c50deb285192d1c2aa8832b1feeb078ba0fd92bb439c0dee28ebe9bb36e98380a380f35b503461025e578060031936011261025e576115766129f3565b61157e612ddf565b600160ff197fcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f033005416177fcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586020604051338152a180f35b503461025e57602060031936011261025e576001600160a01b0361161861254c565b6116206129f3565b16808252600860205260ff60408320541615610403577fffffffffffffffffffffffff0000000000000000000000000000000000000000600654161760065580f35b503461025e57602060031936011261025e576001600160a01b0360406020926004358152600384522054161515604051908152f35b503461025e57602060031936011261025e576001600160a01b036040602092600435815260038452205416604051908152f35b503461025e578060031936011261025e576020611236600454600a549061271f565b503461025e57602060031936011261025e5760406020916001600160a01b0361171361254c565b168152600b83522054604051908152f35b5034611959576001600160a01b039061173c3661267c565b92919390611748612ddf565b1692831580156119ee575b6119c65780159081156119c0575061176961283a565b905b815f5260036020526001600160a01b0360405f20541661199857611985575b6001600160a01b036117a361179d612927565b83612e32565b93825f52600360205260405f208286167fffffffffffffffffffffffff00000000000000000000000000000000000000008254161790556117e3836127ac565b16925f806040517f1794bb3c00000000000000000000000000000000000000000000000000000000602082015261183f8161049c878a30602485016001600160a01b036040929594938160608401971683521660208201520152565b61049c6118896001600160a01b03600654169260405192839160208301957f4f1ef286000000000000000000000000000000000000000000000000000000008752602484016127e8565b519082855af161189761280b565b501561195d576001600160a01b03811693843b1561195957604051957ff2fde38b00000000000000000000000000000000000000000000000000000000875260048701525f8660248183895af195861561194e577f49b21f1e4190db8b0a933c951ed013de222c847c15461754682daa2eab1fdbd296611938575b506104ed93948360405197878998a46001600160a01b0316835260208301526040820190565b6104ed94505f61194791612610565b5f93611912565b6040513d5f823e3d90fd5b5f80fd5b7fab6eb5bc000000000000000000000000000000000000000000000000000000005f5260045ffd5b61199060015461279e565b60015561178a565b7f24591d89000000000000000000000000000000000000000000000000000000005f5260045ffd5b9061176b565b7fd92e233d000000000000000000000000000000000000000000000000000000005f5260045ffd5b506001600160a01b03831615611753565b346119595760206003193601126119595760206001600160a01b036055600b611a26612927565b848151910120604051906040820152600435858201523081520160ff81532016604051908152f35b34611959575f60031936011261195957602060ff7fcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f0330054166040519015158152f35b34611959575f60031936011261195957600454611aae600a548261271f565b90611ab8826126b6565b90611ac66040519283612610565b828252611ae7611ad5846126b6565b93601f19602085019501368637612759565b905f5f5b828110611b3f5750505060405191604083019060408452518091526060830193905f5b818110611b295784806104ed888783820360208501526125d4565b8251865260209586019590920191600101611b0e565b611b4881612562565b90549060031b1c5f52600960205260ff60405f20541615611b6c575b600101611aeb565b90611bc3600191611b7c84612562565b90549060031b1c611b8d828961278a565b52611b9784612562565b90549060031b1c5f5260036020526001600160a01b0360405f205416611bbd828861278a565b5261279e565b919050611b64565b34611959575f6003193601126119595760206001600160a01b0360055416604051908152f35b34611959575f600319360112611959576001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163003611c5b5760206040517f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8152f35b7fe07c8dba000000000000000000000000000000000000000000000000000000005f5260045ffd5b604060031936011261195957611c9761254c565b6024359067ffffffffffffffff8211611959573660238301121561195957816004013590611cc482612660565b91611cd26040519384612610565b8083526020830193366024838301011161195957815f926024602093018737840101526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016803014908115611f46575b50611c5b57611d376129f3565b6001600160a01b038116926040517f52d1902d000000000000000000000000000000000000000000000000000000008152602081600481885afa5f9181611f12575b50611daa57847f4c9c8ce3000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b807f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc869203611ee75750823b15611ebc57807fffffffffffffffffffffffff00000000000000000000000000000000000000007f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416177f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a2825115611e8a575f8091611e88945190845af4611e8261280b565b9161311c565b005b50505034611e9457005b7fb398979f000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f4c9c8ce3000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b7faa1d49a4000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b9091506020813d602011611f3e575b81611f2e60209383612610565b8101031261195957519086611d79565b3d9150611f21565b90506001600160a01b037f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416141584611d2a565b34611959575f60031936011261195957611f936129f3565b7fcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f033005460ff8116156120105760ff19167fcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa6020604051338152a1005b7f8dfc202b000000000000000000000000000000000000000000000000000000005f5260045ffd5b3461195957604060031936011261195957612051612536565b336001600160a01b0382160361206d57611e8890600435612d1c565b7f6697b232000000000000000000000000000000000000000000000000000000005f5260045ffd5b34611959575f6003193601126119595760405180602060075491828152019060075f527fa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c688905f5b818110612107576104ed856120f381870382612610565b6040519182916020835260208301906125d4565b82546001600160a01b03168452602090930192600192830192016120dc565b3461195957602060031936011261195957600435600754811015611959576001600160a01b036121576020926125a7565b90549060031b1c16604051908152f35b3461195957604060031936011261195957611e88600435612186612536565b906121bf610585825f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800602052600160405f20015490565b612c4f565b34611959575f6003193601126119595760205f54604051908152f35b34611959576020600319360112611959576001600160a01b0361220161254c565b165f52600b602052602060405f2054604051908152f35b346119595760206003193601126119595760206112366004355f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800602052600160405f20015490565b346119595760406003193601126119595761227b61254c565b60243580151581036119595761228f6129f3565b6001600160a01b0382169182156119c657825f52600860205260ff60405f20541661232e576122bd906126f3565b815f52600860205260405f20600160ff198254161790556122ff575b7f331cedc71f28c46d467691770675b586e8aa77a0d4fe09f257d01ef00bc154585f80a2005b807fffffffffffffffffffffffff000000000000000000000000000000000000000060065416176006556122d9565b7f1833a24b000000000000000000000000000000000000000000000000000000005f5260045ffd5b34611959576020600319360112611959576001600160a01b0361237761254c565b165f526008602052602060ff60405f2054166040519015158152f35b3461195957602060031936011261195957600435600454811015611959576123bc602091612562565b90549060031b1c604051908152f35b34611959576040600319360112611959576004356123e7612536565b815f5260036020526001600160a01b0360405f2054163303612453576001600160a01b031690815f52600860205260ff60405f2054161561242457005b61242d816129b5565b7febb4c50deb285192d1c2aa8832b1feeb078ba0fd92bb439c0dee28ebe9bb36e95f80a3005b7f2fd9adae000000000000000000000000000000000000000000000000000000005f5260045ffd5b34611959576020600319360112611959576004357fffffffff00000000000000000000000000000000000000000000000000000000811680910361195957807f7965db0b00000000000000000000000000000000000000000000000000000000602092149081156124f2575b506040519015158152f35b7f01ffc9a700000000000000000000000000000000000000000000000000000000915014826124e7565b34611959575f60031936011261195957602090600a548152f35b602435906001600160a01b038216820361195957565b600435906001600160a01b038216820361195957565b60045481101561257a5760045f5260205f2001905f90565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b60075481101561257a5760075f5260205f2001905f90565b805482101561257a575f5260205f2001905f90565b90602080835192838152019201905f5b8181106125f15750505090565b82516001600160a01b03168452602093840193909201916001016125e4565b90601f601f19910116810190811067ffffffffffffffff82111761263357604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b67ffffffffffffffff811161263357601f01601f191660200190565b600319606091011261195957600435906024356001600160a01b038116810361195957906044356001600160a01b03811681036119595790565b67ffffffffffffffff81116126335760051b60200190565b90601f19601f602080948051918291828752018686015e5f8582860101520116010190565b60075490680100000000000000008210156126335761031982600161271d940160075560076125bf565b565b9190820391821161272c57565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b90612763826126b6565b6127706040519182612610565b828152601f1961278082946126b6565b0190602036910137565b805182101561257a5760209160051b010190565b5f19811461272c5760010190565b60045468010000000000000000811015612633578060016127d2920160045560046125bf565b5f19829392549160031b92831b921b1916179055565b6040906001600160a01b03612808949316815281602082015201906126ce565b90565b3d15612835573d9061281c82612660565b9161282a6040519384612610565b82523d5f602084013e565b606090565b612895602061288d61284c5f54612f13565b8280612859600154612f13565b6040519584879551918291018487015e8401908282015f8152815193849201905e01015f815203601f198101835282612610565b8051906130ef565b901561289e5790565b7f94e2737e000000000000000000000000000000000000000000000000000000005f5260045ffd5b670de0b6b3a764000091604051907fffffffffffffffffffffffffffffffffffffffff000000000000000000000000602083019360601b168352603482015260348152612914605482612610565b5190200690811561292157565b60019150565b61027261280860405161293d6020840182612610565b82815260208101926132fe843960206001600160a01b03600554166040516129868161049c85820194856001600160a01b03606092168152604060208201525f60408201520190565b6040519586945180918587015e840190838201905f8252519283915e01015f815203601f198101835282612610565b805f52600960205260ff60405f205416156129cd5750565b5f52600960205260405f20600160ff198254161790556129ee600a5461279e565b600a55565b335f9081527fb7db2dd08fcb62d0c9e08c51941cae53c267786a0b75803fb7960902fc8ef97d602052604090205460ff1615612a2b57565b7fe2517d3f000000000000000000000000000000000000000000000000000000005f52336004525f60245260445ffd5b805f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b62680060205260405f206001600160a01b0333165f5260205260ff60405f20541615612aa55750565b7fe2517d3f000000000000000000000000000000000000000000000000000000005f523360045260245260445ffd5b6001600160a01b0381165f9081527fb7db2dd08fcb62d0c9e08c51941cae53c267786a0b75803fb7960902fc8ef97d602052604090205460ff16612b7e576001600160a01b03165f8181527fb7db2dd08fcb62d0c9e08c51941cae53c267786a0b75803fb7960902fc8ef97d60205260408120805460ff191660011790553391907f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d8180a4600190565b505f90565b6001600160a01b0381165f9081527f06484cc59dc38e4f67c31122333a17ca81b3ca18cdf02bfc298072fa52b0316a602052604090205460ff16612b7e576001600160a01b03165f8181527f06484cc59dc38e4f67c31122333a17ca81b3ca18cdf02bfc298072fa52b0316a60205260408120805460ff191660011790553391907f241ecf16d79d0f8dbfb92cbc07fe17840425976cf0667f022fe9877caa831b08907f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d9080a4600190565b805f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b62680060205260405f206001600160a01b0383165f5260205260ff60405f205416155f14612d1657805f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b62680060205260405f206001600160a01b0383165f5260205260405f20600160ff198254161790556001600160a01b03339216907f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d5f80a4600190565b50505f90565b805f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b62680060205260405f206001600160a01b0383165f5260205260ff60405f2054165f14612d1657805f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b62680060205260405f206001600160a01b0383165f5260205260405f2060ff1981541690556001600160a01b03339216907ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b5f80a4600190565b60ff7fcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f033005416612e0a57565b7fd93c0665000000000000000000000000000000000000000000000000000000005f5260045ffd5b90805115612e86576020815191015ff5903d151982151661194e576001600160a01b03821615612e5e57565b7fb06ebf3d000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f4ca249dc000000000000000000000000000000000000000000000000000000005f5260045ffd5b15612eb557565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f6e616d65737061636520636f6c6c6973696f6e206465746563746564000000006044820152fd5b805f917a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000821015613070575b806d04ee2d6d415b85acef8100000000600a921015613055575b662386f26fc10000811015613041575b6305f5e100811015613030575b612710811015613021575b6064811015613013575b1015613008575b600a5f1960216001850194601f19612fbd612fa788612660565b97612fb5604051998a612610565b808952612660565b013660208801378501015b01917f30313233343536373839616263646566000000000000000000000000000000008282061a8353048015613003575f19600a9192612fc8565b505090565b600190910190612f8d565b606460029104930192612f86565b61271060049104930192612f7c565b6305f5e10060089104930192612f71565b662386f26fc1000060109104930192612f64565b6d04ee2d6d415b85acef810000000060209104930192612f54565b50604091507a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008104612f3a565b60ff7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a005460401c16156130c757565b7fd7e6bcf8000000000000000000000000000000000000000000000000000000005f5260045ffd5b90815181118015613115575b61310d575f613109926131a8565b9091565b50505f905f90565b505f6130fb565b90613159575080511561313157805190602001fd5b7fd6bda275000000000000000000000000000000000000000000000000000000005f5260045ffd5b8151158061319f575b61316a575090565b6001600160a01b03907f9996b315000000000000000000000000000000000000000000000000000000005f521660045260245ffd5b50803b15613162565b5f9392905b8183106131bd5750505060019190565b9092919360ff6131f47fff000000000000000000000000000000000000000000000000000000000000006020888601015116613231565b166009811161322657600a820291808304600a149015171561272c57810180911161272c5760019094019192906131ad565b505f94508493505050565b60f81c602f8111806132f3575b1561326b577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd00160ff1690565b60608111806132e9575b156132a2577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa90160ff1690565b60408111806132df575b156132d9577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc90160ff1690565b5060ff90565b50604781106132ac565b5060678110613275565b50603a811061323e56fe60806040526102728038038061001481610168565b92833981016040828203126101645781516001600160a01b03811692909190838303610164576020810151906001600160401b03821161016457019281601f8501121561016457835161006e610069826101a1565b610168565b9481865260208601936020838301011161016457815f926020809301865e86010152823b15610152577f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80546001600160a01b031916821790557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a282511561013a575f8091610122945190845af43d15610132573d91610113610069846101a1565b9283523d5f602085013e6101bc565b505b6040516057908161021b8239f35b6060916101bc565b50505034156101245763b398979f60e01b5f5260045ffd5b634c9c8ce360e01b5f5260045260245ffd5b5f80fd5b6040519190601f01601f191682016001600160401b0381118382101761018d57604052565b634e487b7160e01b5f52604160045260245ffd5b6001600160401b03811161018d57601f01601f191660200190565b906101e057508051156101d157805190602001fd5b63d6bda27560e01b5f5260045ffd5b81511580610211575b6101f1575090565b639996b31560e01b5f9081526001600160a01b0391909116600452602490fd5b50803b156101e956fe60806040525f8073ffffffffffffffffffffffffffffffffffffffff7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416368280378136915af43d5f803e156053573d5ff35b3d5ffd60a0806040523460295730608052610707908161002e82396080518181816101f001526103290152f35b5f80fdfe608060405260043610156100d0575b36156100725760646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f537475623a206e6f206c6f67696320696d706c656d656e7465640000000000006044820152fd5b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f537475623a20455448206e6f74206163636570746564000000000000000000006044820152fd5b5f3560e01c80634f1ef2861461026857806352d1902d146101ab5763ad3cb1cc0361000e57346101a7575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a757604080519061013281836105c6565b6005825260208201917f352e302e3000000000000000000000000000000000000000000000000000000083527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8351948593602085525180918160208701528686015e5f85828601015201168101030190f35b5f80fd5b346101a7575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a75773ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001630036102405760206040517f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8152f35b7fe07c8dba000000000000000000000000000000000000000000000000000000005f5260045ffd5b60407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a75760043573ffffffffffffffffffffffffffffffffffffffff8116908181036101a7576024359067ffffffffffffffff82116101a757366023830112156101a7578160040135916102e183610634565b926102ef60405194856105c6565b808452602084019136602483830101116101a757815f9260246020930185378501015273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016803014908115610584575b50610240576040517f52d1902d000000000000000000000000000000000000000000000000000000008152602081600481885afa5f9181610550575b506103c157847f4c9c8ce3000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b807f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8692036105255750823b156104fa57807fffffffffffffffffffffffff00000000000000000000000000000000000000007f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416177f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a28251156104c8575f80916104be945190845af43d156104c0573d916104a283610634565b926104b060405194856105c6565b83523d5f602085013e61066e565b005b60609161066e565b505050346104d257005b7fb398979f000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f4c9c8ce3000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b7faa1d49a4000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b9091506020813d60201161057c575b8161056c602093836105c6565b810103126101a757519086610390565b3d915061055f565b905073ffffffffffffffffffffffffffffffffffffffff7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416141585610354565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761060757604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b67ffffffffffffffff811161060757601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b906106ab575080511561068357805190602001fd5b7fd6bda275000000000000000000000000000000000000000000000000000000005f5260045ffd5b815115806106fe575b6106bc575090565b73ffffffffffffffffffffffffffffffffffffffff907f9996b315000000000000000000000000000000000000000000000000000000005f521660045260245ffd5b50803b156106b45660a080604052346100c257306080525f5160206121c45f395f51905f525460ff8160401c166100b3576002600160401b03196001600160401b03821601610060575b6040516120fd90816100c78239608051818181610bf70152610cbc0152f35b6001600160401b0319166001600160401b039081175f5160206121c45f395f51905f525581527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d290602090a15f80610041565b63f92ee8a960e01b5f5260045ffd5b5f80fdfe6080806040526004361015610012575f80fd5b5f905f3560e01c9081630175e23b146116d6575080630c6723631461168d5780631794bb3c146112f65780632407f0b6146112bc57806339698ac0146111a957806346e2cc09146111905780634f1ef28614610c6f57806352d1902d14610bcf5780635467cb4814610b1c5780635b3cd6e214610ac95780635e7a7bdf14610a76578063715018a6146109b8578063781cd99d146109995780637a3979dc1461093e5780637a8d41c21461088d57806384fab62b1461084b578063850749251461081c5780638da5cb5b146107c957806395c5bf751461078e578063a70b9f0c14610770578063ad3cb1cc1461070b578063b3c65015146106c4578063b9566f761461067f578063b97dd9e21461065c578063b9f7f26014610621578063c45a0155146105ce578063cdafb9781461056c578063d4f0eb4d146104a5578063d5176d2314610402578063d8781342146103c5578063de1f453e146103a4578063e03961661461035a578063e8eb1dc31461033c578063f2fde38b146102505763f958cba21461019f575f80fd5b3461024d57602060031936011261024d5760043580151580910361024b576101c5611e51565b7fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff74ff00000000000000000000000000000000000000007fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a402549260a01b169116177fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a4025580f35b505b80fd5b503461024d57602060031936011261024d576102c061026d61179f565b610275611e51565b73ffffffffffffffffffffffffffffffffffffffff7fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a4015416156102c3575b6102bb611e51565b611f20565b80f35b73ffffffffffffffffffffffffffffffffffffffff7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300541673ffffffffffffffffffffffffffffffffffffffff8216907f16ae3179615a2815583b6566eae6f783b25419452c00599aeeb01088f13eca1a8580a36102b3565b503461024d578060031936011261024d57602060405162030d408152f35b503461024d57602060031936011261024d576004355f527f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b14801602052602060405f2054604051908152f35b503461024d578060031936011261024d576103bd611e51565b6102c0611db1565b503461024d578060031936011261024d5760207fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a40054604051908152f35b503461024d57602060031936011261024d5760043562278d0081029080820462278d0014901517156104785763688d46f001908163688d46f01161044b57602082604051908152f35b807f4e487b7100000000000000000000000000000000000000000000000000000000602492526011600452fd5b6024827f4e487b710000000000000000000000000000000000000000000000000000000081526011600452fd5b503461024d57602060031936011261024d5773ffffffffffffffffffffffffffffffffffffffff6104d461179f565b6104dc611e51565b16807fffffffffffffffffffffffff00000000000000000000000000000000000000007f5c6d1774bdd69d8d16847c3c97b51ea7343257b8f5ace5da9e25ab3bafd7d5005416177f5c6d1774bdd69d8d16847c3c97b51ea7343257b8f5ace5da9e25ab3bafd7d500557f253580f806741c11b3d4aa60d9cacc5bef0cebb35748767fe23f11916e2f04b98280a280f35b503461024d57602060031936011261024d5760043567ffffffffffffffff811161024b573660238201121561024b57806004013567ffffffffffffffff81116105ca573660248260051b840101116105ca5760246102c09201611c52565b8280fd5b503461024d578060031936011261024d57602073ffffffffffffffffffffffffffffffffffffffff7fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a4025416604051908152f35b503461024d578060031936011261024d5760206040517f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b148008152f35b503461024d578060031936011261024d576020610677611c14565b604051908152f35b503461024d578060031936011261024d57602060ff7fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a4025460a01c166040519015158152f35b503461024d578060031936011261024d57602067ffffffffffffffff7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a005416604051908152f35b503461024d578060031936011261024d575061076c60405161072e604082611836565b600581527f352e302e300000000000000000000000000000000000000000000000000000006020820152604051918291602083526020830190611924565b0390f35b503461024d578060031936011261024d57602060405162278d008152f35b503461024d578060031936011261024d5760206040517fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a4008152f35b503461024d578060031936011261024d57602073ffffffffffffffffffffffffffffffffffffffff7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c1993005416604051908152f35b503461024d5761076c610837610831366117e5565b90611ba6565b604051918291602083526020830190611924565b503461024d578060031936011261024d57602060ff7f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b1480054166040519015158152f35b503461024d578060031936011261024d57507fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a4015473ffffffffffffffffffffffffffffffffffffffff16806109365750602073ffffffffffffffffffffffffffffffffffffffff7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c19930054165b73ffffffffffffffffffffffffffffffffffffffff60405191168152f35b602090610918565b503461024d57606060031936011261024d5761095861179f565b906109616117c2565b906044359067ffffffffffffffff821161024d57602061098f858561098936600488016118de565b91611a75565b6040519015158152f35b503461024d578060031936011261024d57602060405163688d46f08152f35b503461024d578060031936011261024d576109d1611e51565b8073ffffffffffffffffffffffffffffffffffffffff7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300547fffffffffffffffffffffffff000000000000000000000000000000000000000081167f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c19930055167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b503461024d578060031936011261024d57602073ffffffffffffffffffffffffffffffffffffffff7fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a4015416604051908152f35b503461024d578060031936011261024d57602073ffffffffffffffffffffffffffffffffffffffff7f5c6d1774bdd69d8d16847c3c97b51ea7343257b8f5ace5da9e25ab3bafd7d5005416604051908152f35b503461024d578060031936011261024d57610b35611e51565b7f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b148005460ff811615610ba7577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00167f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b148005580f35b6004827fcd60c3ca000000000000000000000000000000000000000000000000000000008152fd5b503461024d578060031936011261024d5773ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003610c475760206040517f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8152f35b807fe07c8dba0000000000000000000000000000000000000000000000000000000060049252fd5b50604060031936011261105e57610c8461179f565b9060243567ffffffffffffffff811161105e57610ca59036906004016118de565b73ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001680301490811561114e575b5061112657610cf4611e51565b7fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a402549073ffffffffffffffffffffffffffffffffffffffff8216604051927f0d4b4bda00000000000000000000000000000000000000000000000000000000845273ffffffffffffffffffffffffffffffffffffffff861693846004820152602081602481865afa908115611053575f916110f7575b5015611062575b507fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a40054813b1561105e575f916044839260405194859384927f07a9bee700000000000000000000000000000000000000000000000000000000845260048401528860248401525af180156110535761103e575b50604051937f52d1902d000000000000000000000000000000000000000000000000000000008552602085600481865afa80958596611006575b50610e6f57602484847f4c9c8ce3000000000000000000000000000000000000000000000000000000008252600452fd5b9091847f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8103610fdb5750813b15610fb057807fffffffffffffffffffffffff00000000000000000000000000000000000000007f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416177f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b8480a28151839015610f7d5780836020610f7195519101845af43d15610f75573d91610f55836118a4565b92610f636040519485611836565b83523d85602085013e612064565b5080f35b606091612064565b50505034610f885780f35b807fb398979f0000000000000000000000000000000000000000000000000000000060049252fd5b7f4c9c8ce3000000000000000000000000000000000000000000000000000000008452600452602483fd5b7faa1d49a4000000000000000000000000000000000000000000000000000000008552600452602484fd5b9095506020813d602011611036575b8161102260209383611836565b810103126110325751945f610e3e565b8480fd5b3d9150611015565b61104b9193505f90611836565b5f915f610e04565b6040513d5f823e3d90fd5b5f80fd5b60a01c60ff1615611073575f610d91565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f5570677261646520776f756c6420726573756c7420696e20676173207472616360448201527f6b696e672062616e0000000000000000000000000000000000000000000000006064820152fd5b611119915060203d60201161111f575b6111118183611836565b810190611a5d565b5f610d8a565b503d611107565b7fe07c8dba000000000000000000000000000000000000000000000000000000005f5260045ffd5b905073ffffffffffffffffffffffffffffffffffffffff7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc541614155f610ce7565b3461105e576111a76111a1366117e5565b90611967565b005b3461105e57602060031936011261105e576111c261179f565b6111ca611e51565b7fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a401805473ffffffffffffffffffffffffffffffffffffffff9283167fffffffffffffffffffffffff000000000000000000000000000000000000000082168117909255909116811561125c577f16ae3179615a2815583b6566eae6f783b25419452c00599aeeb01088f13eca1a5f80a3005b7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c1993005473ffffffffffffffffffffffffffffffffffffffff1691507f16ae3179615a2815583b6566eae6f783b25419452c00599aeeb01088f13eca1a5f80a3005b3461105e575f60031936011261105e5760206040517f5c6d1774bdd69d8d16847c3c97b51ea7343257b8f5ace5da9e25ab3bafd7d5008152f35b3461105e57606060031936011261105e5761130f61179f565b6113176117c2565b90604435907ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00549260ff8460401c16159367ffffffffffffffff811680159081611685575b600114908161167b575b159081611672575b5061164a578460017fffffffffffffffffffffffffffffffffffffffffffffffff00000000000000008316177ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00556115f5575b508215611597576113f973ffffffffffffffffffffffffffffffffffffffff926113e961200d565b6113f161200d565b6102bb61200d565b167fffffffffffffffffffffffff00000000000000000000000000000000000000007f5c6d1774bdd69d8d16847c3c97b51ea7343257b8f5ace5da9e25ab3bafd7d5005416177f5c6d1774bdd69d8d16847c3c97b51ea7343257b8f5ace5da9e25ab3bafd7d5005561146961200d565b611471611db1565b7fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a400557fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a40280547fffffffffffffffffffffff00000000000000000000000000000000000000000016337fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff1617905561150457005b7fffffffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffff7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0054167ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00557fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2602060405160018152a1005b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f41707020636861696e2049442063616e6e6f74206265203000000000000000006044820152fd5b7fffffffffffffffffffffffffffffffffffffffffffffff0000000000000000001668010000000000000001177ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0055846113c1565b7ff92ee8a9000000000000000000000000000000000000000000000000000000005f5260045ffd5b9050158661136e565b303b159150611366565b86915061135c565b3461105e57602060031936011261105e576004355f527f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b14801602052602060405f2054604051908152f35b3461105e57602060031936011261105e576004358015611777577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff810190811161174a5762278d0081029080820462278d00149015171561174a5763688d46f001908163688d46f01161174a576020918152f35b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b7fd69368d4000000000000000000000000000000000000000000000000000000005f5260045ffd5b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361105e57565b6024359073ffffffffffffffffffffffffffffffffffffffff8216820361105e57565b90602060031983011261105e5760043567ffffffffffffffff811161105e578260238201121561105e5780600401359267ffffffffffffffff841161105e576024848301011161105e576024019190565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761187757604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b67ffffffffffffffff811161187757601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b81601f8201121561105e578035906118f5826118a4565b926119036040519485611836565b8284526020838301011161105e57815f926020809301838601378301015290565b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f602080948051918291828752018686015e5f8582860101520116010190565b9060ff7f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b148005416156119ab57906119a16119a9925a926119b0565b5a9003611ebd565b565b6119a9915b908015611a35576119c091611ba6565b6119cb813233611a75565b15611a0d577f83363b78bdfbb23e2a61db7accc3c01fda29c5c5ec81888003cb962912618a7f6040516020815280611a0833946020830190611924565b0390a2565b7fdc741458000000000000000000000000000000000000000000000000000000005f5260045ffd5b7fdc37f51d000000000000000000000000000000000000000000000000000000005f5260045ffd5b9081602091031261105e5751801515810361105e5790565b9190815162030d408111611b74575073ffffffffffffffffffffffffffffffffffffffff7f5c6d1774bdd69d8d16847c3c97b51ea7343257b8f5ace5da9e25ab3bafd7d500541660018114928315611ad0575b505050905090565b6020935073ffffffffffffffffffffffffffffffffffffffff94611b398692604051978896879586957f7a3979dc000000000000000000000000000000000000000000000000000000008752166004860152166024840152606060448401526064830190611924565b03915afa908115611053575f91611b55575b50805f8080611ac8565b611b6e915060203d60201161111f576111118183611836565b5f611b4b565b7f4634691b000000000000000000000000000000000000000000000000000000005f5260045262030d4060245260445ffd5b6021611c1191836040519485927f040000000000000000000000000000000000000000000000000000000000000060208501528484013781015f8382015203017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08101835282611836565b90565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff9772b910420142811161174a5762278d0090046001810180911161174a5790565b9060ff7f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b14800541615611c8c57906119a16119a9925a92611d22565b6119a991611d22565b9190811015611cf55760051b810135907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18136030182121561105e57019081359167ffffffffffffffff831161105e57602001823603811361105e579190565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b8115611a35575f5b828110611d3657505050565b611d41818484611c95565b905015611a355780611d596108316001938686611c95565b611d64813233611a75565b611d70575b5001611d2a565b7f83363b78bdfbb23e2a61db7accc3c01fda29c5c5ec81888003cb962912618a7f6040516020815280611da833946020830190611924565b0390a25f611d69565b7f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b1480054600160ff8216151514611e29577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00166001177f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b1480055565b7f7679400d000000000000000000000000000000000000000000000000000000005f5260045ffd5b73ffffffffffffffffffffffffffffffffffffffff7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c19930054163303611e9157565b7f118cdaa7000000000000000000000000000000000000000000000000000000005f523360045260245ffd5b611ec5611c14565b3a913a15611f17575b82810292818404149015171561174a575f527f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b1480160205260405f20805491820180921161174a5755565b60019250611ece565b73ffffffffffffffffffffffffffffffffffffffff168015611fe15773ffffffffffffffffffffffffffffffffffffffff7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c19930054827fffffffffffffffffffffffff00000000000000000000000000000000000000008216177f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c19930055167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3565b7f1e4fbdf7000000000000000000000000000000000000000000000000000000005f525f60045260245ffd5b60ff7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a005460401c161561203c57565b7fd7e6bcf8000000000000000000000000000000000000000000000000000000005f5260045ffd5b906120a1575080511561207957805190602001fd5b7fd6bda275000000000000000000000000000000000000000000000000000000005f5260045ffd5b815115806120f4575b6120b2575090565b73ffffffffffffffffffffffffffffffffffffffff907f9996b315000000000000000000000000000000000000000000000000000000005f521660045260245ffd5b50803b156120aa56f0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00f0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0\x80`@R4a\0\xC2W0`\x80R_Q` a_P_9_Q\x90_RT`\xFF\x81`@\x1C\x16a\0\xB3W`\x02`\x01`@\x1B\x03\x19`\x01`\x01`@\x1B\x03\x82\x16\x01a\0`W[`@Qa^\x89\x90\x81a\0\xC7\x829`\x80Q\x81\x81\x81a\x1C\x0B\x01Ra\x1C\xFF\x01R\xF3[`\x01`\x01`@\x1B\x03\x19\x16`\x01`\x01`@\x1B\x03\x90\x81\x17_Q` a_P_9_Q\x90_RU\x81R\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x90` \x90\xA1_\x80a\0AV[c\xF9.\xE8\xA9`\xE0\x1B_R`\x04_\xFD[_\x80\xFD\xFE`\x80\x80`@R`\x046\x10\x15a\0\x12W_\x80\xFD[_\x90_5`\xE0\x1C\x90\x81b\xB6\x8As\x14a%\x1CWP\x80c\x01\xFF\xC9\xA7\x14a${W\x80c\x07\xA9\xBE\xE7\x14a#\xCBW\x80c\t\xD2>$\x14a#\x93W\x80c\rKK\xDA\x14a#VW\x80c\x1D\x1A\xB1Z\x14a\"bW\x80c$\x8A\x9C\xA3\x14a\"\x18W\x80c)W\x10\xFF\x14a!\xE0W\x80c)\x7FLd\x14a!\xC4W\x80c//\xF1]\x14a!gW\x80c1D\xE8S\x14a!&W\x80c2\xEDh\x05\x14a \x95W\x80c6V\x8A\xBE\x14a 8W\x80c?K\xA8:\x14a\x1F{W\x80cO\x1E\xF2\x86\x14a\x1C\x83W\x80cR\xD1\x90-\x14a\x1B\xF1W\x80cV\xDB\xA7y\x14a\x1B\xCBW\x80c[\xD6X\x8B\x14a\x1A\x8FW\x80c\\\x97Z\xBB\x14a\x1ANW\x80cc\x89\xF8\xDA\x14a\x19\xFFW\x80cg\xA5\xFB,\x14a\x17$W\x80cj\xB5\x14B\x14a\x16\xECW\x80cj\xE7\xE7\x03\x14a\x16\xCAW\x80co\xF6\xF6\xC0\x14a\x16\x97W\x80cr2\xC13\x14a\x16bW\x80c|\x16\xFF\xC4\x14a\x15\xF6W\x80c\x84V\xCBY\x14a\x15]W\x80c\x8B5\xBA%\x14a\x14\xFEW\x80c\x8C9\xAA\xA4\x14a\x12\xE1W\x80c\x8D\xE6\xE2\x8C\x14a\x12\xC6W\x80c\x91\xD1HT\x14a\x12\\W\x80c\x99\x9Dq\xD4\x14a\x12>W\x80c\x9E\x15\xD6\xFF\x14a\x0F^W\x80c\xA0\x8F\x1A\x7F\x14a\x12\x0EW\x80c\xA2\x17\xFD\xDF\x14a\x11\xF2W\x80c\xAA\xE7#\x8C\x14a\x10\xE7W\x80c\xAD<\xB1\xCC\x14a\x10\x86W\x80c\xAF\xEBU\xF8\x14a\x0F\xE2W\x80c\xB4\x16f>\x14a\x0F\xC6W\x80c\xB9c\xEB\xF3\x14a\x0F\x8DW\x80c\xC1\x12\xEE\x8C\x14a\x0F^W\x80c\xC4\xD6m\xE8\x14a\t\xE1W\x80c\xCAL\xD0%\x14a\t5W\x80c\xD4\xF4v\x8F\x14a\x05\x93W\x80c\xD5Gt\x1F\x14a\x05,W\x80c\xEC\x87b\x1C\x14a\x04\xF1W\x80c\xEE^\xE7<\x14a\x04+W\x80c\xEE\xEBD\xAD\x14a\x02aWc\xFFv\xAE\xD6\x14a\x028W_\x80\xFD[4a\x02^W\x80`\x03\x196\x01\x12a\x02^W` `\x01`\x01`\xA0\x1B\x03`\x06T\x16`@Q\x90\x81R\xF3[\x80\xFD[P4a\x02^W` `\x03\x196\x01\x12a\x02^W`\x01`\x01`\xA0\x1B\x03a\x02\x83a%LV[a\x02\x8Ba)\xF3V[\x16\x80\x82R`\x08` R`\xFF`@\x83 T\x16\x15a\x04\x03W`\x01`\x01`\xA0\x1B\x03`\x06T\x16\x81\x14a\x03\xDBW\x81[`\x07T\x80\x82\x10\x15a\x03\xD4W\x82`\x01`\x01`\xA0\x1B\x03a\x02\xD2\x84a%\xA7V[\x90T\x90`\x03\x1B\x1C\x16\x14a\x02\xE8WP`\x01\x01a\x02\xB5V[_\x19\x81\x01\x90\x81\x11a\x03\xA7W\x90a\x03\x19`\x01`\x01`\xA0\x1B\x03a\x03\x0Ba\x038\x94a%\xA7V[\x90T\x90`\x03\x1B\x1C\x16\x91a%\xA7V[\x90\x91\x90`\x01`\x01`\xA0\x1B\x03\x80\x84T\x92`\x03\x1B\x93\x16\x83\x1B\x92\x1B\x19\x16\x17\x90UV[`\x07T\x80\x15a\x03zW_\x19\x01a\x03M\x81a%\xA7V[`\x01`\x01`\xA0\x1B\x03\x82T\x91`\x03\x1B\x1B\x19\x16\x90U`\x07U[\x81R`\x08` R`@\x81 `\xFF\x19\x81T\x16\x90U\x80\xF3[`$\x83\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`1`\x04R\xFD[`$\x84\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x11`\x04R\xFD[PPa\x03dV[`\x04\x82\x7F\xD5\xCCJ\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[`\x04\x82\x7F\xFB\x10\x18\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[P4a\x02^W` `\x03\x196\x01\x12a\x02^Wa\x04\xED\x90a\x04\xD9a\x04La%LV[a\x02r\x92` `@Q\x92a\x04b\x82\x87\x01\x85a&\x10V[\x85\x84R\x81\x84\x01\x95a2\xFE\x879`@Qa\x04\xAA\x81a\x04\x9C\x85\x82\x01\x94\x85`\x01`\x01`\xA0\x1B\x03``\x92\x16\x81R`@` \x82\x01R_`@\x82\x01R\x01\x90V[\x03`\x1F\x19\x81\x01\x83R\x82a&\x10V[`@Q\x96\x87\x95Q\x80\x91\x85\x88\x01^\x85\x01\x90\x83\x82\x01\x90\x85\x82RQ\x92\x83\x91^\x01\x01\x90\x81R\x03`\x1F\x19\x81\x01\x83R\x82a&\x10V[`@Q\x91\x82\x91` \x83R` \x83\x01\x90a&\xCEV[\x03\x90\xF3[P4a\x02^W\x80`\x03\x196\x01\x12a\x02^W` `@Q\x7F$\x1E\xCF\x16\xD7\x9D\x0F\x8D\xBF\xB9,\xBC\x07\xFE\x17\x84\x04%\x97l\xF0f\x7F\x02/\xE9\x87|\xAA\x83\x1B\x08\x81R\xF3[P4a\x02^W`@`\x03\x196\x01\x12a\x02^Wa\x05\x8F`\x045a\x05La%6V[\x90a\x05\x8Aa\x05\x85\x82_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`\x01`@_ \x01T\x90V[a*[V[a-\x1CV[P\x80\xF3[P4a\x02^W`\x01`\x01`\xA0\x1B\x03a\x05\xAA6a&|V[\x91\x92\x90a\x05\xB5a-\xDFV[\x16\x80\x15\x80\x15a\t$W[a\x08\xFCW\x82\x15\x92\x83\x15a\x08\xF6W3\x85R`\x0B` R`@\x85 T\x90[a\x05\xE5\x823a(\xC6V[\x94\x85\x87R`\x03` R`\x01`\x01`\xA0\x1B\x03`@\x88 T\x16a\x08\xCEW\x85\x92\x91\x90\x15a\x08DWP3\x86R`\x0B` R`@\x86 a\x06 \x81Ta'\x9EV[\x90U[3\x7FU\x01\x94f\x8A\x07*|}\xAF\x12\xB7u\x1ARG\x8A\x8A\x12\xDE\x0B\x9FUqb\xD2\x80\xFB\x8Ct\xF4s\x87\x80\xA4`\x01`\x01`\xA0\x1B\x03a\x06aa\x06[a)'V[\x85a.2V[\x92\x84\x86R`\x03` R`@\x86 \x82\x85\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82T\x16\x17\x90Ua\x06\xA1\x85a'\xACV[\x16\x90\x84\x80`@Q\x7F\x17\x94\xBB<\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01Ra\x06\xFD\x81a\x04\x9C\x89\x880`$\x85\x01`\x01`\x01`\xA0\x1B\x03`@\x92\x95\x94\x93\x81``\x84\x01\x97\x16\x83R\x16` \x82\x01R\x01RV[a\x04\x9Ca\x07G`\x01`\x01`\xA0\x1B\x03`\x06T\x16\x92`@Q\x92\x83\x91` \x83\x01\x95\x7FO\x1E\xF2\x86\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x87R`$\x84\x01a'\xE8V[Q\x90\x82\x87Z\xF1a\x07Ua(\x0BV[P\x15a\x08\x1CW`\x01`\x01`\xA0\x1B\x03\x83\x16\x90\x81;\x15a\x08\x18W`@Q\x90\x7F\xF2\xFD\xE3\x8B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82R`\x04\x82\x01R\x85\x81`$\x81\x83\x86Z\xF1\x80\x15a\x08\rWa\x07\xF4W[`@Q\x80a\x04\xED\x87\x87\x87\x87\x83\x7FI\xB2\x1F\x1EA\x90\xDB\x8B\n\x93<\x95\x1E\xD0\x13\xDE\",\x84|\x15F\x17Th-\xAA.\xAB\x1F\xDB\xD2\x8E\x80\xA4`\x01`\x01`\xA0\x1B\x03\x16\x83R` \x83\x01R`@\x82\x01\x90V[a\x07\xFF\x86\x80\x92a&\x10V[a\x08\tW_a\x07\xADV[\x84\x80\xFD[`@Q=\x88\x82>=\x90\xFD[\x85\x80\xFD[`\x04\x85\x7F\xABn\xB5\xBC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[\x90\x91P3\x86R`\x0B` R`@\x86 T\x81\x10a\x08\xA6W`\x01\x81\x01\x80\x91\x11a\x08yW3\x86R`\x0B` R`@\x86 U\x83\x90a\x06#V[`$\x86\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x11`\x04R\xFD[`\x04\x86\x7F$Y\x1D\x89\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[`\x04\x87\x7F$Y\x1D\x89\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[\x80a\x05\xDBV[`\x04\x84\x7F\xD9.#=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[P`\x01`\x01`\xA0\x1B\x03\x82\x16\x15a\x05\xBFV[P4a\x02^W\x80`\x03\x196\x01\x12a\x02^W`\x01`\x01`\xA0\x1B\x03`U`\x0B` \x93a\x075`@Q\x90a\th\x87\x82\x01\x83a&\x10V[\x80\x82R\x86\x82\x01\x90a5p\x829a\t\x9C\x87`@Q\x80\x93\x82\x82\x01\x95Q\x80\x91\x87^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a&\x10V[Q\x90 \x90P`@Q\x90`@\x82\x01R\x7FSYNDICATE_STUB_V1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85\x82\x01R0\x81R\x01`\xFF\x81S \x16`@Q\x90\x81R\xF3[P4a\x02^W` `\x03\x196\x01\x12a\x02^Wa\t\xFBa%LV[\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T\x90`\xFF\x82`@\x1C\x16\x15\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x80\x15\x90\x81a\x0FVW[`\x01\x14\x90\x81a\x0FLW[\x15\x90\x81a\x0FCW[Pa\x0F\x1BW\x82`\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\x83\x16\x17\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0Ua\x0E\xC6W[P`\x01`\x01`\xA0\x1B\x03\x81\x16\x15a\x0E\x9EWa\n\xDB\x90a\n\xBCa0\x98V[a\n\xC4a0\x98V[a\n\xCCa0\x98V[a\n\xD5\x81a*\xD4V[Pa+\x83V[Pa\x01\xFE\x82R`\x02` R`\xFF`@\x83 T\x16`\x03\x81\x10\x15a\x0EqW`\x02a\x0B\x04\x91\x14\x15a.\xAEV[a\x01\xFE\x82R`\x02` R`@\x82 `\x01`\xFF\x19\x82T\x16\x17\x90U`3\x80[a\r\xFDWP\x7F\xD9\xE1#\x91w\xBF\xBD*\xEB\xF5\xD0\xF2\x0F\xC0u\xE6\xDFZP,Y\xD1!\xAC\xD5sB\xC7\x83\xE3\x13d`@\x83Ta\x01\xFE\x85U\x81Q\x90\x81Ra\x01\xFE` \x82\x01R\xA1`\x01\x80U`@Qa\x075a\x0Bu` \x82\x01\x83a&\x10V[\x80\x82R` \x82\x01\x90a5p\x829a\x0B\xAB` `@Q\x80\x93\x82\x82\x01\x95Q\x80\x91\x87^\x81\x01\x87\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a&\x10V[\x80Q\x15a\r\xD5WQ\x7FSYNDICATE_STUB_V1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x84\xF5=\x15\x19\x81\x15\x16a\ruW`\x01`\x01`\xA0\x1B\x03\x16\x80\x15a\r\xADW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x05T\x16\x17`\x05U`@Qa!\xE4\x80\x82\x01\x90\x82\x82\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11\x17a\r\x80W\x90\x82\x91a<\xA5\x839\x03\x90\x83\xF0\x80\x15a\ruW`\x01`\x01`\xA0\x1B\x03a\x0C\x84\x91\x16\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x06T\x16\x17`\x06Ua&\xF3V[`\x01`\x01`\xA0\x1B\x03`\x06T\x16\x82R`\x08` R`@\x82 `\x01`\xFF\x19\x82T\x16\x17\x90U`\x01`\x01`\xA0\x1B\x03`\x06T\x16\x90`@Q\x91\x7F3\x1C\xED\xC7\x1F(\xC4mFv\x91w\x06u\xB5\x86\xE8\xAAw\xA0\xD4\xFE\t\xF2W\xD0\x1E\xF0\x0B\xC1TX\x84\x80\xA2a\x0C\xE3WP\x80\xF3[` \x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T\x16\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0U`\x01\x81R\xA1\x80\xF3[`@Q=\x84\x82>=\x90\xFD[`$\x85\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`A`\x04R\xFD[`\x04\x83\x7F\xB0n\xBF=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[`\x04\x84\x7FL\xA2I\xDC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[\x80\x83R`\x02` R`\xFF`@\x84 T\x16`\x03\x81\x10\x15a\x0EDW\x90a\x0E&`\x01`\n\x93\x14\x15a.\xAEV[\x80\x84R`\x02` R`@\x84 `\x02`\xFF\x19\x82T\x16\x17\x90U\x04\x80a\x0B!V[`$\x84\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`!`\x04R\xFD[`$\x83\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`!`\x04R\xFD[`\x04\x83\x7F\xD9.#=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\x16h\x01\0\0\0\0\0\0\0\x01\x17\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0U_a\n\xA0V[`\x04\x84\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[\x90P\x15_a\nMV[0;\x15\x91Pa\nEV[\x84\x91Pa\n;V[P4a\x02^W` `\x03\x196\x01\x12a\x02^W`\xFF`@` \x92`\x045\x81R`\t\x84R T\x16`@Q\x90\x15\x15\x81R\xF3[P4a\x02^W` `\x03\x196\x01\x12a\x02^W`\x045\x81R`\x02` R`\xFF`@\x82 T\x16`@Q\x90`\x03\x81\x10\x15a\x0EqW` \x92P\x81R\xF3[P4a\x02^W\x80`\x03\x196\x01\x12a\x02^Wa\x04\xEDa\x04\xD9a)'V[P4a\x02^W`\x01`\x01`\xA0\x1B\x03a\x0F\xF96a&|V[\x91\x92\x90a\x10\x04a)\xF3V[a\x10\x0Ca-\xDFV[\x16\x80\x15\x80\x15a\x10uW[a\x08\xFCW\x82\x15a\x08\xFCW\x82\x84R`\x03` R`\x01`\x01`\xA0\x1B\x03`@\x85 T\x16a\x10MW`\x01`\x01`\xA0\x1B\x03a\x06aa\x06[a)'V[`\x04\x84\x7F$Y\x1D\x89\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[P`\x01`\x01`\xA0\x1B\x03\x82\x16\x15a\x10\x16V[P4a\x02^W\x80`\x03\x196\x01\x12a\x02^WPa\x04\xED`@Qa\x10\xA9`@\x82a&\x10V[`\x05\x81R\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01R`@Q\x91\x82\x91` \x83R` \x83\x01\x90a&\xCEV[P4a\x02^W` `\x03\x196\x01\x12a\x02^W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x11\xEEW6`#\x82\x01\x12\x15a\x11\xEEW\x80`\x04\x015\x90a\x11%\x82a&\xB6V[\x91a\x113`@Q\x93\x84a&\x10V[\x80\x83R`$` \x84\x01\x91`\x05\x1B\x83\x01\x01\x916\x83\x11a\x08\tW`$\x01\x90[\x82\x82\x10a\x11\xDEWPPPa\x11d\x81Qa'YV[\x82[\x82Q\x81\x10\x15a\x11\xC8W\x80a\x11|`\x01\x92\x85a'\x8AV[Q\x85R`\t` R`\xFF`@\x86 T\x16\x15a\x11\x98W[\x01a\x11fV[a\x11\xA2\x81\x85a'\x8AV[Q\x85R`\x03` R`\x01`\x01`\xA0\x1B\x03`@\x86 T\x16a\x11\xC2\x82\x85a'\x8AV[Ra\x11\x92V[`@Q` \x80\x82R\x81\x90a\x04\xED\x90\x82\x01\x85a%\xD4V[\x815\x81R` \x91\x82\x01\x91\x01a\x11PV[P\x80\xFD[P4a\x02^W\x80`\x03\x196\x01\x12a\x02^W` \x90`@Q\x90\x81R\xF3[P4a\x02^W`@`\x03\x196\x01\x12a\x02^W` a\x126a\x12-a%LV[`$5\x90a(\xC6V[`@Q\x90\x81R\xF3[P4a\x02^W\x80`\x03\x196\x01\x12a\x02^W` `\x01T`@Q\x90\x81R\xF3[P4a\x02^W`@`\x03\x196\x01\x12a\x02^W`\x01`\x01`\xA0\x1B\x03`@a\x12\x80a%6V[\x92`\x045\x81R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R \x91\x16_R` R` `\xFF`@_ T\x16`@Q\x90\x15\x15\x81R\xF3[P4a\x02^W\x80`\x03\x196\x01\x12a\x02^W` a\x126a(:V[P4a\x02^W` `\x03\x196\x01\x12a\x02^W`\x045\x7F$\x1E\xCF\x16\xD7\x9D\x0F\x8D\xBF\xB9,\xBC\x07\xFE\x17\x84\x04%\x97l\xF0f\x7F\x02/\xE9\x87|\xAA\x83\x1B\x08\x82R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`@\x82 `\x01`\x01`\xA0\x1B\x033\x16_R` R`\xFF`@_ T\x16\x15a\x14\xAEW\x80\x15a\x14*W\x80\x82R`\x02` R`\xFF`@\x83 T\x16`\x03\x81\x10\x15a\x0EqW`\x02a\x13\x89\x91\x14\x15a.\xAEV[\x80\x82R`\x02` R`@\x82 `\x01`\xFF\x19\x82T\x16\x17\x90U`\n\x81\x04\x80[a\x13\xE3WP`@\x7F\xD9\xE1#\x91w\xBF\xBD*\xEB\xF5\xD0\xF2\x0F\xC0u\xE6\xDFZP,Y\xD1!\xAC\xD5sB\xC7\x83\xE3\x13d\x91\x83T\x90\x80\x85U\x82Q\x91\x82R` \x82\x01R\xA1\x80\xF3[\x80\x83R`\x02` R`\xFF`@\x84 T\x16`\x03\x81\x10\x15a\x0EDW\x90a\x14\x0C`\x01`\n\x93\x14\x15a.\xAEV[\x80\x84R`\x02` R`@\x84 `\x02`\xFF\x19\x82T\x16\x17\x90U\x04\x80a\x13\xA6V[`\x84`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7Fnamespace prefix of 0 is forbidd`D\x82\x01R\x7Fen\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R\xFD[`D\x82\x7F\xE2Q}?\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R3`\x04R\x7F$\x1E\xCF\x16\xD7\x9D\x0F\x8D\xBF\xB9,\xBC\x07\xFE\x17\x84\x04%\x97l\xF0f\x7F\x02/\xE9\x87|\xAA\x83\x1B\x08`$R\xFD[P4a\x02^W`@`\x03\x196\x01\x12a\x02^W`\x045`\x01`\x01`\xA0\x1B\x03a\x15#a%6V[a\x15+a)\xF3V[a\x154\x83a)\xB5V[\x16\x90\x7F\xEB\xB4\xC5\r\xEB(Q\x92\xD1\xC2\xAA\x882\xB1\xFE\xEB\x07\x8B\xA0\xFD\x92\xBBC\x9C\r\xEE(\xEB\xE9\xBB6\xE9\x83\x80\xA3\x80\xF3[P4a\x02^W\x80`\x03\x196\x01\x12a\x02^Wa\x15va)\xF3V[a\x15~a-\xDFV[`\x01`\xFF\x19\x7F\xCD^\xD1\\n\x18~w\xE9\xAE\xE8\x81\x84\xC2\x1FO!\x82\xABX'\xCB;~\x07\xFB\xED\xCDc\xF03\0T\x16\x17\x7F\xCD^\xD1\\n\x18~w\xE9\xAE\xE8\x81\x84\xC2\x1FO!\x82\xABX'\xCB;~\x07\xFB\xED\xCDc\xF03\0U\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2X` `@Q3\x81R\xA1\x80\xF3[P4a\x02^W` `\x03\x196\x01\x12a\x02^W`\x01`\x01`\xA0\x1B\x03a\x16\x18a%LV[a\x16 a)\xF3V[\x16\x80\x82R`\x08` R`\xFF`@\x83 T\x16\x15a\x04\x03W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x06T\x16\x17`\x06U\x80\xF3[P4a\x02^W` `\x03\x196\x01\x12a\x02^W`\x01`\x01`\xA0\x1B\x03`@` \x92`\x045\x81R`\x03\x84R T\x16\x15\x15`@Q\x90\x81R\xF3[P4a\x02^W` `\x03\x196\x01\x12a\x02^W`\x01`\x01`\xA0\x1B\x03`@` \x92`\x045\x81R`\x03\x84R T\x16`@Q\x90\x81R\xF3[P4a\x02^W\x80`\x03\x196\x01\x12a\x02^W` a\x126`\x04T`\nT\x90a'\x1FV[P4a\x02^W` `\x03\x196\x01\x12a\x02^W`@` \x91`\x01`\x01`\xA0\x1B\x03a\x17\x13a%LV[\x16\x81R`\x0B\x83R T`@Q\x90\x81R\xF3[P4a\x19YW`\x01`\x01`\xA0\x1B\x03\x90a\x17<6a&|V[\x92\x91\x93\x90a\x17Ha-\xDFV[\x16\x92\x83\x15\x80\x15a\x19\xEEW[a\x19\xC6W\x80\x15\x90\x81\x15a\x19\xC0WPa\x17ia(:V[\x90[\x81_R`\x03` R`\x01`\x01`\xA0\x1B\x03`@_ T\x16a\x19\x98Wa\x19\x85W[`\x01`\x01`\xA0\x1B\x03a\x17\xA3a\x17\x9Da)'V[\x83a.2V[\x93\x82_R`\x03` R`@_ \x82\x86\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82T\x16\x17\x90Ua\x17\xE3\x83a'\xACV[\x16\x92_\x80`@Q\x7F\x17\x94\xBB<\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01Ra\x18?\x81a\x04\x9C\x87\x8A0`$\x85\x01`\x01`\x01`\xA0\x1B\x03`@\x92\x95\x94\x93\x81``\x84\x01\x97\x16\x83R\x16` \x82\x01R\x01RV[a\x04\x9Ca\x18\x89`\x01`\x01`\xA0\x1B\x03`\x06T\x16\x92`@Q\x92\x83\x91` \x83\x01\x95\x7FO\x1E\xF2\x86\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x87R`$\x84\x01a'\xE8V[Q\x90\x82\x85Z\xF1a\x18\x97a(\x0BV[P\x15a\x19]W`\x01`\x01`\xA0\x1B\x03\x81\x16\x93\x84;\x15a\x19YW`@Q\x95\x7F\xF2\xFD\xE3\x8B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x87R`\x04\x87\x01R_\x86`$\x81\x83\x89Z\xF1\x95\x86\x15a\x19NW\x7FI\xB2\x1F\x1EA\x90\xDB\x8B\n\x93<\x95\x1E\xD0\x13\xDE\",\x84|\x15F\x17Th-\xAA.\xAB\x1F\xDB\xD2\x96a\x198W[Pa\x04\xED\x93\x94\x83`@Q\x97\x87\x89\x98\xA4`\x01`\x01`\xA0\x1B\x03\x16\x83R` \x83\x01R`@\x82\x01\x90V[a\x04\xED\x94P_a\x19G\x91a&\x10V[_\x93a\x19\x12V[`@Q=_\x82>=\x90\xFD[_\x80\xFD[\x7F\xABn\xB5\xBC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[a\x19\x90`\x01Ta'\x9EV[`\x01Ua\x17\x8AV[\x7F$Y\x1D\x89\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90a\x17kV[\x7F\xD9.#=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[P`\x01`\x01`\xA0\x1B\x03\x83\x16\x15a\x17SV[4a\x19YW` `\x03\x196\x01\x12a\x19YW` `\x01`\x01`\xA0\x1B\x03`U`\x0Ba\x1A&a)'V[\x84\x81Q\x91\x01 `@Q\x90`@\x82\x01R`\x045\x85\x82\x01R0\x81R\x01`\xFF\x81S \x16`@Q\x90\x81R\xF3[4a\x19YW_`\x03\x196\x01\x12a\x19YW` `\xFF\x7F\xCD^\xD1\\n\x18~w\xE9\xAE\xE8\x81\x84\xC2\x1FO!\x82\xABX'\xCB;~\x07\xFB\xED\xCDc\xF03\0T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x19YW_`\x03\x196\x01\x12a\x19YW`\x04Ta\x1A\xAE`\nT\x82a'\x1FV[\x90a\x1A\xB8\x82a&\xB6V[\x90a\x1A\xC6`@Q\x92\x83a&\x10V[\x82\x82Ra\x1A\xE7a\x1A\xD5\x84a&\xB6V[\x93`\x1F\x19` \x85\x01\x95\x016\x867a'YV[\x90__[\x82\x81\x10a\x1B?WPPP`@Q\x91`@\x83\x01\x90`@\x84RQ\x80\x91R``\x83\x01\x93\x90_[\x81\x81\x10a\x1B)W\x84\x80a\x04\xED\x88\x87\x83\x82\x03` \x85\x01Ra%\xD4V[\x82Q\x86R` \x95\x86\x01\x95\x90\x92\x01\x91`\x01\x01a\x1B\x0EV[a\x1BH\x81a%bV[\x90T\x90`\x03\x1B\x1C_R`\t` R`\xFF`@_ T\x16\x15a\x1BlW[`\x01\x01a\x1A\xEBV[\x90a\x1B\xC3`\x01\x91a\x1B|\x84a%bV[\x90T\x90`\x03\x1B\x1Ca\x1B\x8D\x82\x89a'\x8AV[Ra\x1B\x97\x84a%bV[\x90T\x90`\x03\x1B\x1C_R`\x03` R`\x01`\x01`\xA0\x1B\x03`@_ T\x16a\x1B\xBD\x82\x88a'\x8AV[Ra'\x9EV[\x91\x90Pa\x1BdV[4a\x19YW_`\x03\x196\x01\x12a\x19YW` `\x01`\x01`\xA0\x1B\x03`\x05T\x16`@Q\x90\x81R\xF3[4a\x19YW_`\x03\x196\x01\x12a\x19YW`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x160\x03a\x1C[W` `@Q\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x81R\xF3[\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[`@`\x03\x196\x01\x12a\x19YWa\x1C\x97a%LV[`$5\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x19YW6`#\x83\x01\x12\x15a\x19YW\x81`\x04\x015\x90a\x1C\xC4\x82a&`V[\x91a\x1C\xD2`@Q\x93\x84a&\x10V[\x80\x83R` \x83\x01\x936`$\x83\x83\x01\x01\x11a\x19YW\x81_\x92`$` \x93\x01\x877\x84\x01\x01R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x800\x14\x90\x81\x15a\x1FFW[Pa\x1C[Wa\x1D7a)\xF3V[`\x01`\x01`\xA0\x1B\x03\x81\x16\x92`@Q\x7FR\xD1\x90-\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x81`\x04\x81\x88Z\xFA_\x91\x81a\x1F\x12W[Pa\x1D\xAAW\x84\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x80\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x86\x92\x03a\x1E\xE7WP\x82;\x15a\x1E\xBCW\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCT\x16\x17\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCU\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;_\x80\xA2\x82Q\x15a\x1E\x8AW_\x80\x91a\x1E\x88\x94Q\x90\x84Z\xF4a\x1E\x82a(\x0BV[\x91a1\x1CV[\0[PPP4a\x1E\x94W\0[\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x90\x91P` \x81=` \x11a\x1F>W[\x81a\x1F.` \x93\x83a&\x10V[\x81\x01\x03\x12a\x19YWQ\x90\x86a\x1DyV[=\x91Pa\x1F!V[\x90P`\x01`\x01`\xA0\x1B\x03\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCT\x16\x14\x15\x84a\x1D*V[4a\x19YW_`\x03\x196\x01\x12a\x19YWa\x1F\x93a)\xF3V[\x7F\xCD^\xD1\\n\x18~w\xE9\xAE\xE8\x81\x84\xC2\x1FO!\x82\xABX'\xCB;~\x07\xFB\xED\xCDc\xF03\0T`\xFF\x81\x16\x15a \x10W`\xFF\x19\x16\x7F\xCD^\xD1\\n\x18~w\xE9\xAE\xE8\x81\x84\xC2\x1FO!\x82\xABX'\xCB;~\x07\xFB\xED\xCDc\xF03\0U\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA` `@Q3\x81R\xA1\0[\x7F\x8D\xFC +\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x19YW`@`\x03\x196\x01\x12a\x19YWa Qa%6V[3`\x01`\x01`\xA0\x1B\x03\x82\x16\x03a mWa\x1E\x88\x90`\x045a-\x1CV[\x7Ff\x97\xB22\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x19YW_`\x03\x196\x01\x12a\x19YW`@Q\x80` `\x07T\x91\x82\x81R\x01\x90`\x07_R\x7F\xA6l\xC9(\xB5\xED\xB8*\xF9\xBDI\x92)T\x15Z\xB7\xB0\x94&\x94\xBE\xA4\xCEDf\x1D\x9A\x876\xC6\x88\x90_[\x81\x81\x10a!\x07Wa\x04\xED\x85a \xF3\x81\x87\x03\x82a&\x10V[`@Q\x91\x82\x91` \x83R` \x83\x01\x90a%\xD4V[\x82T`\x01`\x01`\xA0\x1B\x03\x16\x84R` \x90\x93\x01\x92`\x01\x92\x83\x01\x92\x01a \xDCV[4a\x19YW` `\x03\x196\x01\x12a\x19YW`\x045`\x07T\x81\x10\x15a\x19YW`\x01`\x01`\xA0\x1B\x03a!W` \x92a%\xA7V[\x90T\x90`\x03\x1B\x1C\x16`@Q\x90\x81R\xF3[4a\x19YW`@`\x03\x196\x01\x12a\x19YWa\x1E\x88`\x045a!\x86a%6V[\x90a!\xBFa\x05\x85\x82_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`\x01`@_ \x01T\x90V[a,OV[4a\x19YW_`\x03\x196\x01\x12a\x19YW` _T`@Q\x90\x81R\xF3[4a\x19YW` `\x03\x196\x01\x12a\x19YW`\x01`\x01`\xA0\x1B\x03a\"\x01a%LV[\x16_R`\x0B` R` `@_ T`@Q\x90\x81R\xF3[4a\x19YW` `\x03\x196\x01\x12a\x19YW` a\x126`\x045_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`\x01`@_ \x01T\x90V[4a\x19YW`@`\x03\x196\x01\x12a\x19YWa\"{a%LV[`$5\x80\x15\x15\x81\x03a\x19YWa\"\x8Fa)\xF3V[`\x01`\x01`\xA0\x1B\x03\x82\x16\x91\x82\x15a\x19\xC6W\x82_R`\x08` R`\xFF`@_ T\x16a#.Wa\"\xBD\x90a&\xF3V[\x81_R`\x08` R`@_ `\x01`\xFF\x19\x82T\x16\x17\x90Ua\"\xFFW[\x7F3\x1C\xED\xC7\x1F(\xC4mFv\x91w\x06u\xB5\x86\xE8\xAAw\xA0\xD4\xFE\t\xF2W\xD0\x1E\xF0\x0B\xC1TX_\x80\xA2\0[\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x06T\x16\x17`\x06Ua\"\xD9V[\x7F\x183\xA2K\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x19YW` `\x03\x196\x01\x12a\x19YW`\x01`\x01`\xA0\x1B\x03a#wa%LV[\x16_R`\x08` R` `\xFF`@_ T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x19YW` `\x03\x196\x01\x12a\x19YW`\x045`\x04T\x81\x10\x15a\x19YWa#\xBC` \x91a%bV[\x90T\x90`\x03\x1B\x1C`@Q\x90\x81R\xF3[4a\x19YW`@`\x03\x196\x01\x12a\x19YW`\x045a#\xE7a%6V[\x81_R`\x03` R`\x01`\x01`\xA0\x1B\x03`@_ T\x163\x03a$SW`\x01`\x01`\xA0\x1B\x03\x16\x90\x81_R`\x08` R`\xFF`@_ T\x16\x15a$$W\0[a$-\x81a)\xB5V[\x7F\xEB\xB4\xC5\r\xEB(Q\x92\xD1\xC2\xAA\x882\xB1\xFE\xEB\x07\x8B\xA0\xFD\x92\xBBC\x9C\r\xEE(\xEB\xE9\xBB6\xE9_\x80\xA3\0[\x7F/\xD9\xAD\xAE\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x19YW` `\x03\x196\x01\x12a\x19YW`\x045\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16\x80\x91\x03a\x19YW\x80\x7Fye\xDB\x0B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x92\x14\x90\x81\x15a$\xF2W[P`@Q\x90\x15\x15\x81R\xF3[\x7F\x01\xFF\xC9\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91P\x14\x82a$\xE7V[4a\x19YW_`\x03\x196\x01\x12a\x19YW` \x90`\nT\x81R\xF3[`$5\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a\x19YWV[`\x045\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a\x19YWV[`\x04T\x81\x10\x15a%zW`\x04_R` _ \x01\x90_\x90V[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[`\x07T\x81\x10\x15a%zW`\x07_R` _ \x01\x90_\x90V[\x80T\x82\x10\x15a%zW_R` _ \x01\x90_\x90V[\x90` \x80\x83Q\x92\x83\x81R\x01\x92\x01\x90_[\x81\x81\x10a%\xF1WPPP\x90V[\x82Q`\x01`\x01`\xA0\x1B\x03\x16\x84R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a%\xE4V[\x90`\x1F`\x1F\x19\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a&3W`@RV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a&3W`\x1F\x01`\x1F\x19\x16` \x01\x90V[`\x03\x19``\x91\x01\x12a\x19YW`\x045\x90`$5`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x19YW\x90`D5`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x19YW\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a&3W`\x05\x1B` \x01\x90V[\x90`\x1F\x19`\x1F` \x80\x94\x80Q\x91\x82\x91\x82\x87R\x01\x86\x86\x01^_\x85\x82\x86\x01\x01R\x01\x16\x01\x01\x90V[`\x07T\x90h\x01\0\0\0\0\0\0\0\0\x82\x10\x15a&3Wa\x03\x19\x82`\x01a'\x1D\x94\x01`\x07U`\x07a%\xBFV[V[\x91\x90\x82\x03\x91\x82\x11a',WV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[\x90a'c\x82a&\xB6V[a'p`@Q\x91\x82a&\x10V[\x82\x81R`\x1F\x19a'\x80\x82\x94a&\xB6V[\x01\x90` 6\x91\x017V[\x80Q\x82\x10\x15a%zW` \x91`\x05\x1B\x01\x01\x90V[_\x19\x81\x14a',W`\x01\x01\x90V[`\x04Th\x01\0\0\0\0\0\0\0\0\x81\x10\x15a&3W\x80`\x01a'\xD2\x92\x01`\x04U`\x04a%\xBFV[_\x19\x82\x93\x92T\x91`\x03\x1B\x92\x83\x1B\x92\x1B\x19\x16\x17\x90UV[`@\x90`\x01`\x01`\xA0\x1B\x03a(\x08\x94\x93\x16\x81R\x81` \x82\x01R\x01\x90a&\xCEV[\x90V[=\x15a(5W=\x90a(\x1C\x82a&`V[\x91a(*`@Q\x93\x84a&\x10V[\x82R=_` \x84\x01>V[``\x90V[a(\x95` a(\x8Da(L_Ta/\x13V[\x82\x80a(Y`\x01Ta/\x13V[`@Q\x95\x84\x87\x95Q\x91\x82\x91\x01\x84\x87\x01^\x84\x01\x90\x82\x82\x01_\x81R\x81Q\x93\x84\x92\x01\x90^\x01\x01_\x81R\x03`\x1F\x19\x81\x01\x83R\x82a&\x10V[\x80Q\x90a0\xEFV[\x90\x15a(\x9EW\x90V[\x7F\x94\xE2s~\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[g\r\xE0\xB6\xB3\xA7d\0\0\x91`@Q\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0` \x83\x01\x93``\x1B\x16\x83R`4\x82\x01R`4\x81Ra)\x14`T\x82a&\x10V[Q\x90 \x06\x90\x81\x15a)!WV[`\x01\x91PV[a\x02ra(\x08`@Qa)=` \x84\x01\x82a&\x10V[\x82\x81R` \x81\x01\x92a2\xFE\x849` `\x01`\x01`\xA0\x1B\x03`\x05T\x16`@Qa)\x86\x81a\x04\x9C\x85\x82\x01\x94\x85`\x01`\x01`\xA0\x1B\x03``\x92\x16\x81R`@` \x82\x01R_`@\x82\x01R\x01\x90V[`@Q\x95\x86\x94Q\x80\x91\x85\x87\x01^\x84\x01\x90\x83\x82\x01\x90_\x82RQ\x92\x83\x91^\x01\x01_\x81R\x03`\x1F\x19\x81\x01\x83R\x82a&\x10V[\x80_R`\t` R`\xFF`@_ T\x16\x15a)\xCDWPV[_R`\t` R`@_ `\x01`\xFF\x19\x82T\x16\x17\x90Ua)\xEE`\nTa'\x9EV[`\nUV[3_\x90\x81R\x7F\xB7\xDB-\xD0\x8F\xCBb\xD0\xC9\xE0\x8CQ\x94\x1C\xAES\xC2gxj\x0Bu\x80?\xB7\x96\t\x02\xFC\x8E\xF9}` R`@\x90 T`\xFF\x16\x15a*+WV[\x7F\xE2Q}?\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R3`\x04R_`$R`D_\xFD[\x80_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`@_ `\x01`\x01`\xA0\x1B\x033\x16_R` R`\xFF`@_ T\x16\x15a*\xA5WPV[\x7F\xE2Q}?\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R3`\x04R`$R`D_\xFD[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R\x7F\xB7\xDB-\xD0\x8F\xCBb\xD0\xC9\xE0\x8CQ\x94\x1C\xAES\xC2gxj\x0Bu\x80?\xB7\x96\t\x02\xFC\x8E\xF9}` R`@\x90 T`\xFF\x16a+~W`\x01`\x01`\xA0\x1B\x03\x16_\x81\x81R\x7F\xB7\xDB-\xD0\x8F\xCBb\xD0\xC9\xE0\x8CQ\x94\x1C\xAES\xC2gxj\x0Bu\x80?\xB7\x96\t\x02\xFC\x8E\xF9}` R`@\x81 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x91\x90\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x81\x80\xA4`\x01\x90V[P_\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R\x7F\x06HL\xC5\x9D\xC3\x8EOg\xC3\x11\"3:\x17\xCA\x81\xB3\xCA\x18\xCD\xF0+\xFC)\x80r\xFAR\xB01j` R`@\x90 T`\xFF\x16a+~W`\x01`\x01`\xA0\x1B\x03\x16_\x81\x81R\x7F\x06HL\xC5\x9D\xC3\x8EOg\xC3\x11\"3:\x17\xCA\x81\xB3\xCA\x18\xCD\xF0+\xFC)\x80r\xFAR\xB01j` R`@\x81 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x91\x90\x7F$\x1E\xCF\x16\xD7\x9D\x0F\x8D\xBF\xB9,\xBC\x07\xFE\x17\x84\x04%\x97l\xF0f\x7F\x02/\xE9\x87|\xAA\x83\x1B\x08\x90\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x90\x80\xA4`\x01\x90V[\x80_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`@_ `\x01`\x01`\xA0\x1B\x03\x83\x16_R` R`\xFF`@_ T\x16\x15_\x14a-\x16W\x80_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`@_ `\x01`\x01`\xA0\x1B\x03\x83\x16_R` R`@_ `\x01`\xFF\x19\x82T\x16\x17\x90U`\x01`\x01`\xA0\x1B\x033\x92\x16\x90\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r_\x80\xA4`\x01\x90V[PP_\x90V[\x80_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`@_ `\x01`\x01`\xA0\x1B\x03\x83\x16_R` R`\xFF`@_ T\x16_\x14a-\x16W\x80_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`@_ `\x01`\x01`\xA0\x1B\x03\x83\x16_R` R`@_ `\xFF\x19\x81T\x16\x90U`\x01`\x01`\xA0\x1B\x033\x92\x16\x90\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B_\x80\xA4`\x01\x90V[`\xFF\x7F\xCD^\xD1\\n\x18~w\xE9\xAE\xE8\x81\x84\xC2\x1FO!\x82\xABX'\xCB;~\x07\xFB\xED\xCDc\xF03\0T\x16a.\nWV[\x7F\xD9<\x06e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90\x80Q\x15a.\x86W` \x81Q\x91\x01_\xF5\x90=\x15\x19\x82\x15\x16a\x19NW`\x01`\x01`\xA0\x1B\x03\x82\x16\x15a.^WV[\x7F\xB0n\xBF=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7FL\xA2I\xDC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x15a.\xB5WV[`d`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7Fnamespace collision detected\0\0\0\0`D\x82\x01R\xFD[\x80_\x91z\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x82\x10\x15a0pW[\x80m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0`\n\x92\x10\x15a0UW[f#\x86\xF2o\xC1\0\0\x81\x10\x15a0AW[c\x05\xF5\xE1\0\x81\x10\x15a00W[a'\x10\x81\x10\x15a0!W[`d\x81\x10\x15a0\x13W[\x10\x15a0\x08W[`\n_\x19`!`\x01\x85\x01\x94`\x1F\x19a/\xBDa/\xA7\x88a&`V[\x97a/\xB5`@Q\x99\x8Aa&\x10V[\x80\x89Ra&`V[\x016` \x88\x017\x85\x01\x01[\x01\x91\x7F0123456789abcdef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x82\x06\x1A\x83S\x04\x80\x15a0\x03W_\x19`\n\x91\x92a/\xC8V[PP\x90V[`\x01\x90\x91\x01\x90a/\x8DV[`d`\x02\x91\x04\x93\x01\x92a/\x86V[a'\x10`\x04\x91\x04\x93\x01\x92a/|V[c\x05\xF5\xE1\0`\x08\x91\x04\x93\x01\x92a/qV[f#\x86\xF2o\xC1\0\0`\x10\x91\x04\x93\x01\x92a/dV[m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0` \x91\x04\x93\x01\x92a/TV[P`@\x91Pz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x81\x04a/:V[`\xFF\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T`@\x1C\x16\x15a0\xC7WV[\x7F\xD7\xE6\xBC\xF8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90\x81Q\x81\x11\x80\x15a1\x15W[a1\rW_a1\t\x92a1\xA8V[\x90\x91V[PP_\x90_\x90V[P_a0\xFBV[\x90a1YWP\x80Q\x15a11W\x80Q\x90` \x01\xFD[\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x81Q\x15\x80a1\x9FW[a1jWP\x90V[`\x01`\x01`\xA0\x1B\x03\x90\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R\x16`\x04R`$_\xFD[P\x80;\x15a1bV[_\x93\x92\x90[\x81\x83\x10a1\xBDWPPP`\x01\x91\x90V[\x90\x92\x91\x93`\xFFa1\xF4\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x88\x86\x01\x01Q\x16a21V[\x16`\t\x81\x11a2&W`\n\x82\x02\x91\x80\x83\x04`\n\x14\x90\x15\x17\x15a',W\x81\x01\x80\x91\x11a',W`\x01\x90\x94\x01\x91\x92\x90a1\xADV[P_\x94P\x84\x93PPPV[`\xF8\x1C`/\x81\x11\x80a2\xF3W[\x15a2kW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xD0\x01`\xFF\x16\x90V[``\x81\x11\x80a2\xE9W[\x15a2\xA2W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xA9\x01`\xFF\x16\x90V[`@\x81\x11\x80a2\xDFW[\x15a2\xD9W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC9\x01`\xFF\x16\x90V[P`\xFF\x90V[P`G\x81\x10a2\xACV[P`g\x81\x10a2uV[P`:\x81\x10a2>V\xFE`\x80`@Ra\x02r\x808\x03\x80a\0\x14\x81a\x01hV[\x92\x839\x81\x01`@\x82\x82\x03\x12a\x01dW\x81Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x92\x90\x91\x90\x83\x83\x03a\x01dW` \x81\x01Q\x90`\x01`\x01`@\x1B\x03\x82\x11a\x01dW\x01\x92\x81`\x1F\x85\x01\x12\x15a\x01dW\x83Qa\0na\0i\x82a\x01\xA1V[a\x01hV[\x94\x81\x86R` \x86\x01\x93` \x83\x83\x01\x01\x11a\x01dW\x81_\x92` \x80\x93\x01\x86^\x86\x01\x01R\x82;\x15a\x01RW\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x82\x17\x90U\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;_\x80\xA2\x82Q\x15a\x01:W_\x80\x91a\x01\"\x94Q\x90\x84Z\xF4=\x15a\x012W=\x91a\x01\x13a\0i\x84a\x01\xA1V[\x92\x83R=_` \x85\x01>a\x01\xBCV[P[`@Q`W\x90\x81a\x02\x1B\x829\xF3[``\x91a\x01\xBCV[PPP4\x15a\x01$Wc\xB3\x98\x97\x9F`\xE0\x1B_R`\x04_\xFD[cL\x9C\x8C\xE3`\xE0\x1B_R`\x04R`$_\xFD[_\x80\xFD[`@Q\x91\x90`\x1F\x01`\x1F\x19\x16\x82\x01`\x01`\x01`@\x1B\x03\x81\x11\x83\x82\x10\x17a\x01\x8DW`@RV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`\x01`\x01`@\x1B\x03\x81\x11a\x01\x8DW`\x1F\x01`\x1F\x19\x16` \x01\x90V[\x90a\x01\xE0WP\x80Q\x15a\x01\xD1W\x80Q\x90` \x01\xFD[c\xD6\xBD\xA2u`\xE0\x1B_R`\x04_\xFD[\x81Q\x15\x80a\x02\x11W[a\x01\xF1WP\x90V[c\x99\x96\xB3\x15`\xE0\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16`\x04R`$\x90\xFD[P\x80;\x15a\x01\xE9V\xFE`\x80`@R_\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCT\x166\x82\x807\x816\x91Z\xF4=_\x80>\x15`SW=_\xF3[=_\xFD`\xA0\x80`@R4`)W0`\x80Ra\x07\x07\x90\x81a\0.\x829`\x80Q\x81\x81\x81a\x01\xF0\x01Ra\x03)\x01R\xF3[_\x80\xFD\xFE`\x80`@R`\x046\x10\x15a\0\xD0W[6\x15a\0rW`d`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FStub: no logic implemented\0\0\0\0\0\0`D\x82\x01R\xFD[`d`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FStub: ETH not accepted\0\0\0\0\0\0\0\0\0\0`D\x82\x01R\xFD[_5`\xE0\x1C\x80cO\x1E\xF2\x86\x14a\x02hW\x80cR\xD1\x90-\x14a\x01\xABWc\xAD<\xB1\xCC\x03a\0\x0EW4a\x01\xA7W_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x01\xA7W`@\x80Q\x90a\x012\x81\x83a\x05\xC6V[`\x05\x82R` \x82\x01\x91\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83R\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F\x83Q\x94\x85\x93` \x85RQ\x80\x91\x81` \x87\x01R\x86\x86\x01^_\x85\x82\x86\x01\x01R\x01\x16\x81\x01\x03\x01\x90\xF3[_\x80\xFD[4a\x01\xA7W_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x01\xA7Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x160\x03a\x02@W` `@Q\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x81R\xF3[\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x01\xA7W`\x045s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x90\x81\x81\x03a\x01\xA7W`$5\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x01\xA7W6`#\x83\x01\x12\x15a\x01\xA7W\x81`\x04\x015\x91a\x02\xE1\x83a\x064V[\x92a\x02\xEF`@Q\x94\x85a\x05\xC6V[\x80\x84R` \x84\x01\x916`$\x83\x83\x01\x01\x11a\x01\xA7W\x81_\x92`$` \x93\x01\x857\x85\x01\x01Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x800\x14\x90\x81\x15a\x05\x84W[Pa\x02@W`@Q\x7FR\xD1\x90-\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x81`\x04\x81\x88Z\xFA_\x91\x81a\x05PW[Pa\x03\xC1W\x84\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x80\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x86\x92\x03a\x05%WP\x82;\x15a\x04\xFAW\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCT\x16\x17\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCU\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;_\x80\xA2\x82Q\x15a\x04\xC8W_\x80\x91a\x04\xBE\x94Q\x90\x84Z\xF4=\x15a\x04\xC0W=\x91a\x04\xA2\x83a\x064V[\x92a\x04\xB0`@Q\x94\x85a\x05\xC6V[\x83R=_` \x85\x01>a\x06nV[\0[``\x91a\x06nV[PPP4a\x04\xD2W\0[\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x90\x91P` \x81=` \x11a\x05|W[\x81a\x05l` \x93\x83a\x05\xC6V[\x81\x01\x03\x12a\x01\xA7WQ\x90\x86a\x03\x90V[=\x91Pa\x05_V[\x90Ps\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCT\x16\x14\x15\x85a\x03TV[\x90`\x1F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x06\x07W`@RV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x06\x07W`\x1F\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x16` \x01\x90V[\x90a\x06\xABWP\x80Q\x15a\x06\x83W\x80Q\x90` \x01\xFD[\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x81Q\x15\x80a\x06\xFEW[a\x06\xBCWP\x90V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R\x16`\x04R`$_\xFD[P\x80;\x15a\x06\xB4V`\xA0\x80`@R4a\0\xC2W0`\x80R_Q` a!\xC4_9_Q\x90_RT`\xFF\x81`@\x1C\x16a\0\xB3W`\x02`\x01`@\x1B\x03\x19`\x01`\x01`@\x1B\x03\x82\x16\x01a\0`W[`@Qa \xFD\x90\x81a\0\xC7\x829`\x80Q\x81\x81\x81a\x0B\xF7\x01Ra\x0C\xBC\x01R\xF3[`\x01`\x01`@\x1B\x03\x19\x16`\x01`\x01`@\x1B\x03\x90\x81\x17_Q` a!\xC4_9_Q\x90_RU\x81R\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x90` \x90\xA1_\x80a\0AV[c\xF9.\xE8\xA9`\xE0\x1B_R`\x04_\xFD[_\x80\xFD\xFE`\x80\x80`@R`\x046\x10\x15a\0\x12W_\x80\xFD[_\x90_5`\xE0\x1C\x90\x81c\x01u\xE2;\x14a\x16\xD6WP\x80c\x0Cg#c\x14a\x16\x8DW\x80c\x17\x94\xBB<\x14a\x12\xF6W\x80c$\x07\xF0\xB6\x14a\x12\xBCW\x80c9i\x8A\xC0\x14a\x11\xA9W\x80cF\xE2\xCC\t\x14a\x11\x90W\x80cO\x1E\xF2\x86\x14a\x0CoW\x80cR\xD1\x90-\x14a\x0B\xCFW\x80cTg\xCBH\x14a\x0B\x1CW\x80c[<\xD6\xE2\x14a\n\xC9W\x80c^z{\xDF\x14a\nvW\x80cqP\x18\xA6\x14a\t\xB8W\x80cx\x1C\xD9\x9D\x14a\t\x99W\x80cz9y\xDC\x14a\t>W\x80cz\x8DA\xC2\x14a\x08\x8DW\x80c\x84\xFA\xB6+\x14a\x08KW\x80c\x85\x07I%\x14a\x08\x1CW\x80c\x8D\xA5\xCB[\x14a\x07\xC9W\x80c\x95\xC5\xBFu\x14a\x07\x8EW\x80c\xA7\x0B\x9F\x0C\x14a\x07pW\x80c\xAD<\xB1\xCC\x14a\x07\x0BW\x80c\xB3\xC6P\x15\x14a\x06\xC4W\x80c\xB9Vov\x14a\x06\x7FW\x80c\xB9}\xD9\xE2\x14a\x06\\W\x80c\xB9\xF7\xF2`\x14a\x06!W\x80c\xC4Z\x01U\x14a\x05\xCEW\x80c\xCD\xAF\xB9x\x14a\x05lW\x80c\xD4\xF0\xEBM\x14a\x04\xA5W\x80c\xD5\x17m#\x14a\x04\x02W\x80c\xD8x\x13B\x14a\x03\xC5W\x80c\xDE\x1FE>\x14a\x03\xA4W\x80c\xE09af\x14a\x03ZW\x80c\xE8\xEB\x1D\xC3\x14a\x03<W\x80c\xF2\xFD\xE3\x8B\x14a\x02PWc\xF9X\xCB\xA2\x14a\x01\x9FW_\x80\xFD[4a\x02MW` `\x03\x196\x01\x12a\x02MW`\x045\x80\x15\x15\x80\x91\x03a\x02KWa\x01\xC5a\x1EQV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFt\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\x02T\x92`\xA0\x1B\x16\x91\x16\x17\x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\x02U\x80\xF3[P[\x80\xFD[P4a\x02MW` `\x03\x196\x01\x12a\x02MWa\x02\xC0a\x02ma\x17\x9FV[a\x02ua\x1EQV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\x01T\x16\x15a\x02\xC3W[a\x02\xBBa\x1EQV[a\x1F V[\x80\xF3[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0T\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90\x7F\x16\xAE1yaZ(\x15X;ef\xEA\xE6\xF7\x83\xB2T\x19E,\0Y\x9A\xEE\xB0\x10\x88\xF1>\xCA\x1A\x85\x80\xA3a\x02\xB3V[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` `@Qb\x03\r@\x81R\xF3[P4a\x02MW` `\x03\x196\x01\x12a\x02MW`\x045_R\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\x01` R` `@_ T`@Q\x90\x81R\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MWa\x03\xBDa\x1EQV[a\x02\xC0a\x1D\xB1V[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` \x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\0T`@Q\x90\x81R\xF3[P4a\x02MW` `\x03\x196\x01\x12a\x02MW`\x045b'\x8D\0\x81\x02\x90\x80\x82\x04b'\x8D\0\x14\x90\x15\x17\x15a\x04xWch\x8DF\xF0\x01\x90\x81ch\x8DF\xF0\x11a\x04KW` \x82`@Q\x90\x81R\xF3[\x80\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`$\x92R`\x11`\x04R\xFD[`$\x82\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x11`\x04R\xFD[P4a\x02MW` `\x03\x196\x01\x12a\x02MWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x04\xD4a\x17\x9FV[a\x04\xDCa\x1EQV[\x16\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F\\m\x17t\xBD\xD6\x9D\x8D\x16\x84|<\x97\xB5\x1E\xA742W\xB8\xF5\xAC\xE5\xDA\x9E%\xAB;\xAF\xD7\xD5\0T\x16\x17\x7F\\m\x17t\xBD\xD6\x9D\x8D\x16\x84|<\x97\xB5\x1E\xA742W\xB8\xF5\xAC\xE5\xDA\x9E%\xAB;\xAF\xD7\xD5\0U\x7F%5\x80\xF8\x06t\x1C\x11\xB3\xD4\xAA`\xD9\xCA\xCC[\xEF\x0C\xEB\xB3WHv\x7F\xE2?\x11\x91n/\x04\xB9\x82\x80\xA2\x80\xF3[P4a\x02MW` `\x03\x196\x01\x12a\x02MW`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02KW6`#\x82\x01\x12\x15a\x02KW\x80`\x04\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x05\xCAW6`$\x82`\x05\x1B\x84\x01\x01\x11a\x05\xCAW`$a\x02\xC0\x92\x01a\x1CRV[\x82\x80\xFD[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\x02T\x16`@Q\x90\x81R\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` `@Q\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\0\x81R\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` a\x06wa\x1C\x14V[`@Q\x90\x81R\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` `\xFF\x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\x02T`\xA0\x1C\x16`@Q\x90\x15\x15\x81R\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T\x16`@Q\x90\x81R\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MWPa\x07l`@Qa\x07.`@\x82a\x186V[`\x05\x81R\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01R`@Q\x91\x82\x91` \x83R` \x83\x01\x90a\x19$V[\x03\x90\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` `@Qb'\x8D\0\x81R\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` `@Q\x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\0\x81R\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0T\x16`@Q\x90\x81R\xF3[P4a\x02MWa\x07la\x087a\x0816a\x17\xE5V[\x90a\x1B\xA6V[`@Q\x91\x82\x91` \x83R` \x83\x01\x90a\x19$V[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` `\xFF\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\0T\x16`@Q\x90\x15\x15\x81R\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MWP\x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\x01Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80a\t6WP` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0T\x16[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@Q\x91\x16\x81R\xF3[` \x90a\t\x18V[P4a\x02MW```\x03\x196\x01\x12a\x02MWa\tXa\x17\x9FV[\x90a\taa\x17\xC2V[\x90`D5\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x02MW` a\t\x8F\x85\x85a\t\x896`\x04\x88\x01a\x18\xDEV[\x91a\x1AuV[`@Q\x90\x15\x15\x81R\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` `@Qch\x8DF\xF0\x81R\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MWa\t\xD1a\x1EQV[\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0U\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x82\x80\xA3\x80\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\x01T\x16`@Q\x90\x81R\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\\m\x17t\xBD\xD6\x9D\x8D\x16\x84|<\x97\xB5\x1E\xA742W\xB8\xF5\xAC\xE5\xDA\x9E%\xAB;\xAF\xD7\xD5\0T\x16`@Q\x90\x81R\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MWa\x0B5a\x1EQV[\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\0T`\xFF\x81\x16\x15a\x0B\xA7W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x16\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\0U\x80\xF3[`\x04\x82\x7F\xCD`\xC3\xCA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x160\x03a\x0CGW` `@Q\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x81R\xF3[\x80\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x04\x92R\xFD[P`@`\x03\x196\x01\x12a\x10^Wa\x0C\x84a\x17\x9FV[\x90`$5g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x10^Wa\x0C\xA5\x906\x90`\x04\x01a\x18\xDEV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x800\x14\x90\x81\x15a\x11NW[Pa\x11&Wa\x0C\xF4a\x1EQV[\x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\x02T\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16`@Q\x92\x7F\rKK\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x86\x16\x93\x84`\x04\x82\x01R` \x81`$\x81\x86Z\xFA\x90\x81\x15a\x10SW_\x91a\x10\xF7W[P\x15a\x10bW[P\x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\0T\x81;\x15a\x10^W_\x91`D\x83\x92`@Q\x94\x85\x93\x84\x92\x7F\x07\xA9\xBE\xE7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84R`\x04\x84\x01R\x88`$\x84\x01RZ\xF1\x80\x15a\x10SWa\x10>W[P`@Q\x93\x7FR\xD1\x90-\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85R` \x85`\x04\x81\x86Z\xFA\x80\x95\x85\x96a\x10\x06W[Pa\x0EoW`$\x84\x84\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82R`\x04R\xFD[\x90\x91\x84\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x81\x03a\x0F\xDBWP\x81;\x15a\x0F\xB0W\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCT\x16\x17\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCU\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;\x84\x80\xA2\x81Q\x83\x90\x15a\x0F}W\x80\x83` a\x0Fq\x95Q\x91\x01\x84Z\xF4=\x15a\x0FuW=\x91a\x0FU\x83a\x18\xA4V[\x92a\x0Fc`@Q\x94\x85a\x186V[\x83R=\x85` \x85\x01>a dV[P\x80\xF3[``\x91a dV[PPP4a\x0F\x88W\x80\xF3[\x80\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x04\x92R\xFD[\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84R`\x04R`$\x83\xFD[\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85R`\x04R`$\x84\xFD[\x90\x95P` \x81=` \x11a\x106W[\x81a\x10\"` \x93\x83a\x186V[\x81\x01\x03\x12a\x102WQ\x94_a\x0E>V[\x84\x80\xFD[=\x91Pa\x10\x15V[a\x10K\x91\x93P_\x90a\x186V[_\x91_a\x0E\x04V[`@Q=_\x82>=\x90\xFD[_\x80\xFD[`\xA0\x1C`\xFF\x16\x15a\x10sW_a\r\x91V[`\x84`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`(`$\x82\x01R\x7FUpgrade would result in gas trac`D\x82\x01R\x7Fking ban\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R\xFD[a\x11\x19\x91P` =` \x11a\x11\x1FW[a\x11\x11\x81\x83a\x186V[\x81\x01\x90a\x1A]V[_a\r\x8AV[P=a\x11\x07V[\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90Ps\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCT\x16\x14\x15_a\x0C\xE7V[4a\x10^Wa\x11\xA7a\x11\xA16a\x17\xE5V[\x90a\x19gV[\0[4a\x10^W` `\x03\x196\x01\x12a\x10^Wa\x11\xC2a\x17\x9FV[a\x11\xCAa\x1EQV[\x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\x01\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92\x83\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x81\x17\x90\x92U\x90\x91\x16\x81\x15a\x12\\W\x7F\x16\xAE1yaZ(\x15X;ef\xEA\xE6\xF7\x83\xB2T\x19E,\0Y\x9A\xEE\xB0\x10\x88\xF1>\xCA\x1A_\x80\xA3\0[\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91P\x7F\x16\xAE1yaZ(\x15X;ef\xEA\xE6\xF7\x83\xB2T\x19E,\0Y\x9A\xEE\xB0\x10\x88\xF1>\xCA\x1A_\x80\xA3\0[4a\x10^W_`\x03\x196\x01\x12a\x10^W` `@Q\x7F\\m\x17t\xBD\xD6\x9D\x8D\x16\x84|<\x97\xB5\x1E\xA742W\xB8\xF5\xAC\xE5\xDA\x9E%\xAB;\xAF\xD7\xD5\0\x81R\xF3[4a\x10^W```\x03\x196\x01\x12a\x10^Wa\x13\x0Fa\x17\x9FV[a\x13\x17a\x17\xC2V[\x90`D5\x90\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T\x92`\xFF\x84`@\x1C\x16\x15\x93g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x80\x15\x90\x81a\x16\x85W[`\x01\x14\x90\x81a\x16{W[\x15\x90\x81a\x16rW[Pa\x16JW\x84`\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\x83\x16\x17\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0Ua\x15\xF5W[P\x82\x15a\x15\x97Wa\x13\xF9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92a\x13\xE9a \rV[a\x13\xF1a \rV[a\x02\xBBa \rV[\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F\\m\x17t\xBD\xD6\x9D\x8D\x16\x84|<\x97\xB5\x1E\xA742W\xB8\xF5\xAC\xE5\xDA\x9E%\xAB;\xAF\xD7\xD5\0T\x16\x17\x7F\\m\x17t\xBD\xD6\x9D\x8D\x16\x84|<\x97\xB5\x1E\xA742W\xB8\xF5\xAC\xE5\xDA\x9E%\xAB;\xAF\xD7\xD5\0Ua\x14ia \rV[a\x14qa\x1D\xB1V[\x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\0U\x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\x02\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x163\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x17\x90Ua\x15\x04W\0[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T\x16\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0U\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2` `@Q`\x01\x81R\xA1\0[`d`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x18`$\x82\x01R\x7FApp chain ID cannot be 0\0\0\0\0\0\0\0\0`D\x82\x01R\xFD[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\x16h\x01\0\0\0\0\0\0\0\x01\x17\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0U\x84a\x13\xC1V[\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90P\x15\x86a\x13nV[0;\x15\x91Pa\x13fV[\x86\x91Pa\x13\\V[4a\x10^W` `\x03\x196\x01\x12a\x10^W`\x045_R\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\x01` R` `@_ T`@Q\x90\x81R\xF3[4a\x10^W` `\x03\x196\x01\x12a\x10^W`\x045\x80\x15a\x17wW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x01\x90\x81\x11a\x17JWb'\x8D\0\x81\x02\x90\x80\x82\x04b'\x8D\0\x14\x90\x15\x17\x15a\x17JWch\x8DF\xF0\x01\x90\x81ch\x8DF\xF0\x11a\x17JW` \x91\x81R\xF3[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[\x7F\xD6\x93h\xD4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[`\x045\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x10^WV[`$5\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x10^WV[\x90` `\x03\x19\x83\x01\x12a\x10^W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x10^W\x82`#\x82\x01\x12\x15a\x10^W\x80`\x04\x015\x92g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x11a\x10^W`$\x84\x83\x01\x01\x11a\x10^W`$\x01\x91\x90V[\x90`\x1F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x18wW`@RV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x18wW`\x1F\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x16` \x01\x90V[\x81`\x1F\x82\x01\x12\x15a\x10^W\x805\x90a\x18\xF5\x82a\x18\xA4V[\x92a\x19\x03`@Q\x94\x85a\x186V[\x82\x84R` \x83\x83\x01\x01\x11a\x10^W\x81_\x92` \x80\x93\x01\x83\x86\x017\x83\x01\x01R\x90V[\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F` \x80\x94\x80Q\x91\x82\x91\x82\x87R\x01\x86\x86\x01^_\x85\x82\x86\x01\x01R\x01\x16\x01\x01\x90V[\x90`\xFF\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\0T\x16\x15a\x19\xABW\x90a\x19\xA1a\x19\xA9\x92Z\x92a\x19\xB0V[Z\x90\x03a\x1E\xBDV[V[a\x19\xA9\x91[\x90\x80\x15a\x1A5Wa\x19\xC0\x91a\x1B\xA6V[a\x19\xCB\x8123a\x1AuV[\x15a\x1A\rW\x7F\x836;x\xBD\xFB\xB2>*a\xDBz\xCC\xC3\xC0\x1F\xDA)\xC5\xC5\xEC\x81\x88\x80\x03\xCB\x96)\x12a\x8A\x7F`@Q` \x81R\x80a\x1A\x083\x94` \x83\x01\x90a\x19$V[\x03\x90\xA2V[\x7F\xDCt\x14X\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\xDC7\xF5\x1D\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90\x81` \x91\x03\x12a\x10^WQ\x80\x15\x15\x81\x03a\x10^W\x90V[\x91\x90\x81Qb\x03\r@\x81\x11a\x1BtWPs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\\m\x17t\xBD\xD6\x9D\x8D\x16\x84|<\x97\xB5\x1E\xA742W\xB8\xF5\xAC\xE5\xDA\x9E%\xAB;\xAF\xD7\xD5\0T\x16`\x01\x81\x14\x92\x83\x15a\x1A\xD0W[PPP\x90P\x90V[` \x93Ps\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x94a\x1B9\x86\x92`@Q\x97\x88\x96\x87\x95\x86\x95\x7Fz9y\xDC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x87R\x16`\x04\x86\x01R\x16`$\x84\x01R```D\x84\x01R`d\x83\x01\x90a\x19$V[\x03\x91Z\xFA\x90\x81\x15a\x10SW_\x91a\x1BUW[P\x80_\x80\x80a\x1A\xC8V[a\x1Bn\x91P` =` \x11a\x11\x1FWa\x11\x11\x81\x83a\x186V[_a\x1BKV[\x7FF4i\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04Rb\x03\r@`$R`D_\xFD[`!a\x1C\x11\x91\x83`@Q\x94\x85\x92\x7F\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x85\x01R\x84\x84\x017\x81\x01_\x83\x82\x01R\x03\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x81\x01\x83R\x82a\x186V[\x90V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x97r\xB9\x10B\x01B\x81\x11a\x17JWb'\x8D\0\x90\x04`\x01\x81\x01\x80\x91\x11a\x17JW\x90V[\x90`\xFF\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\0T\x16\x15a\x1C\x8CW\x90a\x19\xA1a\x19\xA9\x92Z\x92a\x1D\"V[a\x19\xA9\x91a\x1D\"V[\x91\x90\x81\x10\x15a\x1C\xF5W`\x05\x1B\x81\x015\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE1\x816\x03\x01\x82\x12\x15a\x10^W\x01\x90\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x10^W` \x01\x826\x03\x81\x13a\x10^W\x91\x90V[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[\x81\x15a\x1A5W_[\x82\x81\x10a\x1D6WPPPV[a\x1DA\x81\x84\x84a\x1C\x95V[\x90P\x15a\x1A5W\x80a\x1DYa\x081`\x01\x93\x86\x86a\x1C\x95V[a\x1Dd\x8123a\x1AuV[a\x1DpW[P\x01a\x1D*V[\x7F\x836;x\xBD\xFB\xB2>*a\xDBz\xCC\xC3\xC0\x1F\xDA)\xC5\xC5\xEC\x81\x88\x80\x03\xCB\x96)\x12a\x8A\x7F`@Q` \x81R\x80a\x1D\xA83\x94` \x83\x01\x90a\x19$V[\x03\x90\xA2_a\x1DiV[\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\0T`\x01`\xFF\x82\x16\x15\x15\x14a\x1E)W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x16`\x01\x17\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\0UV[\x7Fvy@\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0T\x163\x03a\x1E\x91WV[\x7F\x11\x8C\xDA\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R3`\x04R`$_\xFD[a\x1E\xC5a\x1C\x14V[:\x91:\x15a\x1F\x17W[\x82\x81\x02\x92\x81\x84\x04\x14\x90\x15\x17\x15a\x17JW_R\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\x01` R`@_ \x80T\x91\x82\x01\x80\x92\x11a\x17JWUV[`\x01\x92Pa\x1E\xCEV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80\x15a\x1F\xE1Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0T\x82\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x17\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0U\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0_\x80\xA3V[\x7F\x1EO\xBD\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R_`\x04R`$_\xFD[`\xFF\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T`@\x1C\x16\x15a <WV[\x7F\xD7\xE6\xBC\xF8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90a \xA1WP\x80Q\x15a yW\x80Q\x90` \x01\xFD[\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x81Q\x15\x80a \xF4W[a \xB2WP\x90V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R\x16`\x04R`$_\xFD[P\x80;\x15a \xAAV\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x6080806040526004361015610012575f80fd5b5f905f3560e01c908162b68a731461251c5750806301ffc9a71461247b57806307a9bee7146123cb57806309d23e24146123935780630d4b4bda146123565780631d1ab15a14612262578063248a9ca314612218578063295710ff146121e0578063297f4c64146121c45780632f2ff15d146121675780633144e8531461212657806332ed68051461209557806336568abe146120385780633f4ba83a14611f7b5780634f1ef28614611c8357806352d1902d14611bf157806356dba77914611bcb5780635bd6588b14611a8f5780635c975abb14611a4e5780636389f8da146119ff57806367a5fb2c146117245780636ab51442146116ec5780636ae7e703146116ca5780636ff6f6c0146116975780637232c133146116625780637c16ffc4146115f65780638456cb591461155d5780638b35ba25146114fe5780638c39aaa4146112e15780638de6e28c146112c657806391d148541461125c578063999d71d41461123e5780639e15d6ff14610f5e578063a08f1a7f1461120e578063a217fddf146111f2578063aae7238c146110e7578063ad3cb1cc14611086578063afeb55f814610fe2578063b416663e14610fc6578063b963ebf314610f8d578063c112ee8c14610f5e578063c4d66de8146109e1578063ca4cd02514610935578063d4f4768f14610593578063d547741f1461052c578063ec87621c146104f1578063ee5ee73c1461042b578063eeeb44ad146102615763ff76aed614610238575f80fd5b3461025e578060031936011261025e5760206001600160a01b0360065416604051908152f35b80fd5b503461025e57602060031936011261025e576001600160a01b0361028361254c565b61028b6129f3565b16808252600860205260ff60408320541615610403576001600160a01b036006541681146103db57815b600754808210156103d457826001600160a01b036102d2846125a7565b90549060031b1c16146102e857506001016102b5565b5f1981019081116103a757906103196001600160a01b0361030b610338946125a7565b90549060031b1c16916125a7565b9091906001600160a01b038084549260031b9316831b921b1916179055565b600754801561037a575f190161034d816125a7565b6001600160a01b0382549160031b1b191690556007555b815260086020526040812060ff19815416905580f35b6024837f4e487b710000000000000000000000000000000000000000000000000000000081526031600452fd5b6024847f4e487b710000000000000000000000000000000000000000000000000000000081526011600452fd5b5050610364565b6004827fd5cc4a0f000000000000000000000000000000000000000000000000000000008152fd5b6004827ffb101809000000000000000000000000000000000000000000000000000000008152fd5b503461025e57602060031936011261025e576104ed906104d961044c61254c565b6102729260206040519261046282870185612610565b858452818401956132fe87396040516104aa8161049c85820194856001600160a01b03606092168152604060208201525f60408201520190565b03601f198101835282612610565b6040519687955180918588015e85019083820190858252519283915e010190815203601f198101835282612610565b6040519182916020835260208301906126ce565b0390f35b503461025e578060031936011261025e5760206040517f241ecf16d79d0f8dbfb92cbc07fe17840425976cf0667f022fe9877caa831b088152f35b503461025e57604060031936011261025e5761058f60043561054c612536565b9061058a610585825f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800602052600160405f20015490565b612a5b565b612d1c565b5080f35b503461025e576001600160a01b036105aa3661267c565b9192906105b5612ddf565b1680158015610924575b6108fc5782159283156108f657338552600b6020526040852054905b6105e582336128c6565b9485875260036020526001600160a01b036040882054166108ce5785929190156108445750338652600b60205260408620610620815461279e565b90555b337f550194668a072a7c7daf12b7751a52478a8a12de0b9f557162d280fb8c74f4738780a46001600160a01b0361066161065b612927565b85612e32565b928486526003602052604086208285167fffffffffffffffffffffffff00000000000000000000000000000000000000008254161790556106a1856127ac565b169084806040517f1794bb3c0000000000000000000000000000000000000000000000000000000060208201526106fd8161049c898830602485016001600160a01b036040929594938160608401971683521660208201520152565b61049c6107476001600160a01b03600654169260405192839160208301957f4f1ef286000000000000000000000000000000000000000000000000000000008752602484016127e8565b519082875af161075561280b565b501561081c576001600160a01b03831690813b1561081857604051907ff2fde38b0000000000000000000000000000000000000000000000000000000082526004820152858160248183865af1801561080d576107f4575b604051806104ed87878787837f49b21f1e4190db8b0a933c951ed013de222c847c15461754682daa2eab1fdbd28e80a46001600160a01b0316835260208301526040820190565b6107ff868092612610565b610809575f6107ad565b8480fd5b6040513d88823e3d90fd5b8580fd5b6004857fab6eb5bc000000000000000000000000000000000000000000000000000000008152fd5b909150338652600b602052604086205481106108a6576001810180911161087957338652600b60205260408620558390610623565b6024867f4e487b710000000000000000000000000000000000000000000000000000000081526011600452fd5b6004867f24591d89000000000000000000000000000000000000000000000000000000008152fd5b6004877f24591d89000000000000000000000000000000000000000000000000000000008152fd5b806105db565b6004847fd92e233d000000000000000000000000000000000000000000000000000000008152fd5b506001600160a01b038216156105bf565b503461025e578060031936011261025e576001600160a01b036055600b6020936107356040519061096887820183612610565b80825286820190613570823961099c87604051809382820195518091875e810186838201520301601f198101835282612610565b51902090506040519060408201527f53594e4449434154455f535455425f5631000000000000000000000000000000858201523081520160ff81532016604051908152f35b503461025e57602060031936011261025e576109fb61254c565b7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00549060ff8260401c16159167ffffffffffffffff811680159081610f56575b6001149081610f4c575b159081610f43575b50610f1b578260017fffffffffffffffffffffffffffffffffffffffffffffffff00000000000000008316177ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0055610ec6575b506001600160a01b03811615610e9e57610adb90610abc613098565b610ac4613098565b610acc613098565b610ad581612ad4565b50612b83565b506101fe8252600260205260ff6040832054166003811015610e71576002610b04911415612eae565b6101fe8252600260205260408220600160ff198254161790556033805b610dfd57507fd9e1239177bfbd2aebf5d0f20fc075e6df5a502c59d121acd57342c783e31364604083546101fe855581519081526101fe6020820152a160018055604051610735610b756020820183612610565b80825260208201906135708239610bab6020604051809382820195518091875e810187838201520301601f198101835282612610565b805115610dd557517f53594e4449434154455f535455425f56310000000000000000000000000000009184f53d1519811516610d75576001600160a01b03168015610dad577fffffffffffffffffffffffff000000000000000000000000000000000000000060055416176005556040516121e48082019082821067ffffffffffffffff831117610d8057908291613ca58339039083f08015610d75576001600160a01b03610c849116807fffffffffffffffffffffffff000000000000000000000000000000000000000060065416176006556126f3565b6001600160a01b03600654168252600860205260408220600160ff198254161790556001600160a01b036006541690604051917f331cedc71f28c46d467691770675b586e8aa77a0d4fe09f257d01ef00bc154588480a2610ce3575080f35b60207fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2917fffffffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffff7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0054167ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a005560018152a180f35b6040513d84823e3d90fd5b6024857f4e487b710000000000000000000000000000000000000000000000000000000081526041600452fd5b6004837fb06ebf3d000000000000000000000000000000000000000000000000000000008152fd5b6004847f4ca249dc000000000000000000000000000000000000000000000000000000008152fd5b808352600260205260ff6040842054166003811015610e445790610e266001600a931415612eae565b808452600260205260408420600260ff198254161790550480610b21565b6024847f4e487b710000000000000000000000000000000000000000000000000000000081526021600452fd5b6024837f4e487b710000000000000000000000000000000000000000000000000000000081526021600452fd5b6004837fd92e233d000000000000000000000000000000000000000000000000000000008152fd5b7fffffffffffffffffffffffffffffffffffffffffffffff0000000000000000001668010000000000000001177ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00555f610aa0565b6004847ff92ee8a9000000000000000000000000000000000000000000000000000000008152fd5b9050155f610a4d565b303b159150610a45565b849150610a3b565b503461025e57602060031936011261025e5760ff60406020926004358152600984522054166040519015158152f35b503461025e57602060031936011261025e576004358152600260205260ff604082205416604051906003811015610e7157602092508152f35b503461025e578060031936011261025e576104ed6104d9612927565b503461025e576001600160a01b03610ff93661267c565b9192906110046129f3565b61100c612ddf565b1680158015611075575b6108fc5782156108fc5782845260036020526001600160a01b0360408520541661104d576001600160a01b0361066161065b612927565b6004847f24591d89000000000000000000000000000000000000000000000000000000008152fd5b506001600160a01b03821615611016565b503461025e578060031936011261025e57506104ed6040516110a9604082612610565b600581527f352e302e3000000000000000000000000000000000000000000000000000000060208201526040519182916020835260208301906126ce565b503461025e57602060031936011261025e5760043567ffffffffffffffff81116111ee57366023820112156111ee57806004013590611125826126b6565b916111336040519384612610565b8083526024602084019160051b8301019136831161080957602401905b8282106111de575050506111648151612759565b825b82518110156111c8578061117c6001928561278a565b518552600960205260ff60408620541615611198575b01611166565b6111a2818561278a565b51855260036020526001600160a01b036040862054166111c2828561278a565b52611192565b604051602080825281906104ed908201856125d4565b8135815260209182019101611150565b5080fd5b503461025e578060031936011261025e57602090604051908152f35b503461025e57604060031936011261025e57602061123661122d61254c565b602435906128c6565b604051908152f35b503461025e578060031936011261025e576020600154604051908152f35b503461025e57604060031936011261025e576001600160a01b036040611280612536565b9260043581527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b6268006020522091165f52602052602060ff60405f2054166040519015158152f35b503461025e578060031936011261025e57602061123661283a565b503461025e57602060031936011261025e576004357f241ecf16d79d0f8dbfb92cbc07fe17840425976cf0667f022fe9877caa831b0882527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800602052604082206001600160a01b0333165f5260205260ff60405f205416156114ae57801561142a57808252600260205260ff6040832054166003811015610e71576002611389911415612eae565b808252600260205260408220600160ff19825416179055600a8104805b6113e3575060407fd9e1239177bfbd2aebf5d0f20fc075e6df5a502c59d121acd57342c783e313649183549080855582519182526020820152a180f35b808352600260205260ff6040842054166003811015610e44579061140c6001600a931415612eae565b808452600260205260408420600260ff1982541617905504806113a6565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f6e616d65737061636520707265666978206f66203020697320666f726269646460448201527f656e0000000000000000000000000000000000000000000000000000000000006064820152fd5b6044827fe2517d3f000000000000000000000000000000000000000000000000000000008152336004527f241ecf16d79d0f8dbfb92cbc07fe17840425976cf0667f022fe9877caa831b08602452fd5b503461025e57604060031936011261025e576004356001600160a01b03611523612536565b61152b6129f3565b611534836129b5565b16907febb4c50deb285192d1c2aa8832b1feeb078ba0fd92bb439c0dee28ebe9bb36e98380a380f35b503461025e578060031936011261025e576115766129f3565b61157e612ddf565b600160ff197fcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f033005416177fcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586020604051338152a180f35b503461025e57602060031936011261025e576001600160a01b0361161861254c565b6116206129f3565b16808252600860205260ff60408320541615610403577fffffffffffffffffffffffff0000000000000000000000000000000000000000600654161760065580f35b503461025e57602060031936011261025e576001600160a01b0360406020926004358152600384522054161515604051908152f35b503461025e57602060031936011261025e576001600160a01b036040602092600435815260038452205416604051908152f35b503461025e578060031936011261025e576020611236600454600a549061271f565b503461025e57602060031936011261025e5760406020916001600160a01b0361171361254c565b168152600b83522054604051908152f35b5034611959576001600160a01b039061173c3661267c565b92919390611748612ddf565b1692831580156119ee575b6119c65780159081156119c0575061176961283a565b905b815f5260036020526001600160a01b0360405f20541661199857611985575b6001600160a01b036117a361179d612927565b83612e32565b93825f52600360205260405f208286167fffffffffffffffffffffffff00000000000000000000000000000000000000008254161790556117e3836127ac565b16925f806040517f1794bb3c00000000000000000000000000000000000000000000000000000000602082015261183f8161049c878a30602485016001600160a01b036040929594938160608401971683521660208201520152565b61049c6118896001600160a01b03600654169260405192839160208301957f4f1ef286000000000000000000000000000000000000000000000000000000008752602484016127e8565b519082855af161189761280b565b501561195d576001600160a01b03811693843b1561195957604051957ff2fde38b00000000000000000000000000000000000000000000000000000000875260048701525f8660248183895af195861561194e577f49b21f1e4190db8b0a933c951ed013de222c847c15461754682daa2eab1fdbd296611938575b506104ed93948360405197878998a46001600160a01b0316835260208301526040820190565b6104ed94505f61194791612610565b5f93611912565b6040513d5f823e3d90fd5b5f80fd5b7fab6eb5bc000000000000000000000000000000000000000000000000000000005f5260045ffd5b61199060015461279e565b60015561178a565b7f24591d89000000000000000000000000000000000000000000000000000000005f5260045ffd5b9061176b565b7fd92e233d000000000000000000000000000000000000000000000000000000005f5260045ffd5b506001600160a01b03831615611753565b346119595760206003193601126119595760206001600160a01b036055600b611a26612927565b848151910120604051906040820152600435858201523081520160ff81532016604051908152f35b34611959575f60031936011261195957602060ff7fcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f0330054166040519015158152f35b34611959575f60031936011261195957600454611aae600a548261271f565b90611ab8826126b6565b90611ac66040519283612610565b828252611ae7611ad5846126b6565b93601f19602085019501368637612759565b905f5f5b828110611b3f5750505060405191604083019060408452518091526060830193905f5b818110611b295784806104ed888783820360208501526125d4565b8251865260209586019590920191600101611b0e565b611b4881612562565b90549060031b1c5f52600960205260ff60405f20541615611b6c575b600101611aeb565b90611bc3600191611b7c84612562565b90549060031b1c611b8d828961278a565b52611b9784612562565b90549060031b1c5f5260036020526001600160a01b0360405f205416611bbd828861278a565b5261279e565b919050611b64565b34611959575f6003193601126119595760206001600160a01b0360055416604051908152f35b34611959575f600319360112611959576001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163003611c5b5760206040517f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8152f35b7fe07c8dba000000000000000000000000000000000000000000000000000000005f5260045ffd5b604060031936011261195957611c9761254c565b6024359067ffffffffffffffff8211611959573660238301121561195957816004013590611cc482612660565b91611cd26040519384612610565b8083526020830193366024838301011161195957815f926024602093018737840101526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016803014908115611f46575b50611c5b57611d376129f3565b6001600160a01b038116926040517f52d1902d000000000000000000000000000000000000000000000000000000008152602081600481885afa5f9181611f12575b50611daa57847f4c9c8ce3000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b807f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc869203611ee75750823b15611ebc57807fffffffffffffffffffffffff00000000000000000000000000000000000000007f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416177f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a2825115611e8a575f8091611e88945190845af4611e8261280b565b9161311c565b005b50505034611e9457005b7fb398979f000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f4c9c8ce3000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b7faa1d49a4000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b9091506020813d602011611f3e575b81611f2e60209383612610565b8101031261195957519086611d79565b3d9150611f21565b90506001600160a01b037f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416141584611d2a565b34611959575f60031936011261195957611f936129f3565b7fcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f033005460ff8116156120105760ff19167fcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa6020604051338152a1005b7f8dfc202b000000000000000000000000000000000000000000000000000000005f5260045ffd5b3461195957604060031936011261195957612051612536565b336001600160a01b0382160361206d57611e8890600435612d1c565b7f6697b232000000000000000000000000000000000000000000000000000000005f5260045ffd5b34611959575f6003193601126119595760405180602060075491828152019060075f527fa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c688905f5b818110612107576104ed856120f381870382612610565b6040519182916020835260208301906125d4565b82546001600160a01b03168452602090930192600192830192016120dc565b3461195957602060031936011261195957600435600754811015611959576001600160a01b036121576020926125a7565b90549060031b1c16604051908152f35b3461195957604060031936011261195957611e88600435612186612536565b906121bf610585825f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800602052600160405f20015490565b612c4f565b34611959575f6003193601126119595760205f54604051908152f35b34611959576020600319360112611959576001600160a01b0361220161254c565b165f52600b602052602060405f2054604051908152f35b346119595760206003193601126119595760206112366004355f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800602052600160405f20015490565b346119595760406003193601126119595761227b61254c565b60243580151581036119595761228f6129f3565b6001600160a01b0382169182156119c657825f52600860205260ff60405f20541661232e576122bd906126f3565b815f52600860205260405f20600160ff198254161790556122ff575b7f331cedc71f28c46d467691770675b586e8aa77a0d4fe09f257d01ef00bc154585f80a2005b807fffffffffffffffffffffffff000000000000000000000000000000000000000060065416176006556122d9565b7f1833a24b000000000000000000000000000000000000000000000000000000005f5260045ffd5b34611959576020600319360112611959576001600160a01b0361237761254c565b165f526008602052602060ff60405f2054166040519015158152f35b3461195957602060031936011261195957600435600454811015611959576123bc602091612562565b90549060031b1c604051908152f35b34611959576040600319360112611959576004356123e7612536565b815f5260036020526001600160a01b0360405f2054163303612453576001600160a01b031690815f52600860205260ff60405f2054161561242457005b61242d816129b5565b7febb4c50deb285192d1c2aa8832b1feeb078ba0fd92bb439c0dee28ebe9bb36e95f80a3005b7f2fd9adae000000000000000000000000000000000000000000000000000000005f5260045ffd5b34611959576020600319360112611959576004357fffffffff00000000000000000000000000000000000000000000000000000000811680910361195957807f7965db0b00000000000000000000000000000000000000000000000000000000602092149081156124f2575b506040519015158152f35b7f01ffc9a700000000000000000000000000000000000000000000000000000000915014826124e7565b34611959575f60031936011261195957602090600a548152f35b602435906001600160a01b038216820361195957565b600435906001600160a01b038216820361195957565b60045481101561257a5760045f5260205f2001905f90565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b60075481101561257a5760075f5260205f2001905f90565b805482101561257a575f5260205f2001905f90565b90602080835192838152019201905f5b8181106125f15750505090565b82516001600160a01b03168452602093840193909201916001016125e4565b90601f601f19910116810190811067ffffffffffffffff82111761263357604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b67ffffffffffffffff811161263357601f01601f191660200190565b600319606091011261195957600435906024356001600160a01b038116810361195957906044356001600160a01b03811681036119595790565b67ffffffffffffffff81116126335760051b60200190565b90601f19601f602080948051918291828752018686015e5f8582860101520116010190565b60075490680100000000000000008210156126335761031982600161271d940160075560076125bf565b565b9190820391821161272c57565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b90612763826126b6565b6127706040519182612610565b828152601f1961278082946126b6565b0190602036910137565b805182101561257a5760209160051b010190565b5f19811461272c5760010190565b60045468010000000000000000811015612633578060016127d2920160045560046125bf565b5f19829392549160031b92831b921b1916179055565b6040906001600160a01b03612808949316815281602082015201906126ce565b90565b3d15612835573d9061281c82612660565b9161282a6040519384612610565b82523d5f602084013e565b606090565b612895602061288d61284c5f54612f13565b8280612859600154612f13565b6040519584879551918291018487015e8401908282015f8152815193849201905e01015f815203601f198101835282612610565b8051906130ef565b901561289e5790565b7f94e2737e000000000000000000000000000000000000000000000000000000005f5260045ffd5b670de0b6b3a764000091604051907fffffffffffffffffffffffffffffffffffffffff000000000000000000000000602083019360601b168352603482015260348152612914605482612610565b5190200690811561292157565b60019150565b61027261280860405161293d6020840182612610565b82815260208101926132fe843960206001600160a01b03600554166040516129868161049c85820194856001600160a01b03606092168152604060208201525f60408201520190565b6040519586945180918587015e840190838201905f8252519283915e01015f815203601f198101835282612610565b805f52600960205260ff60405f205416156129cd5750565b5f52600960205260405f20600160ff198254161790556129ee600a5461279e565b600a55565b335f9081527fb7db2dd08fcb62d0c9e08c51941cae53c267786a0b75803fb7960902fc8ef97d602052604090205460ff1615612a2b57565b7fe2517d3f000000000000000000000000000000000000000000000000000000005f52336004525f60245260445ffd5b805f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b62680060205260405f206001600160a01b0333165f5260205260ff60405f20541615612aa55750565b7fe2517d3f000000000000000000000000000000000000000000000000000000005f523360045260245260445ffd5b6001600160a01b0381165f9081527fb7db2dd08fcb62d0c9e08c51941cae53c267786a0b75803fb7960902fc8ef97d602052604090205460ff16612b7e576001600160a01b03165f8181527fb7db2dd08fcb62d0c9e08c51941cae53c267786a0b75803fb7960902fc8ef97d60205260408120805460ff191660011790553391907f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d8180a4600190565b505f90565b6001600160a01b0381165f9081527f06484cc59dc38e4f67c31122333a17ca81b3ca18cdf02bfc298072fa52b0316a602052604090205460ff16612b7e576001600160a01b03165f8181527f06484cc59dc38e4f67c31122333a17ca81b3ca18cdf02bfc298072fa52b0316a60205260408120805460ff191660011790553391907f241ecf16d79d0f8dbfb92cbc07fe17840425976cf0667f022fe9877caa831b08907f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d9080a4600190565b805f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b62680060205260405f206001600160a01b0383165f5260205260ff60405f205416155f14612d1657805f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b62680060205260405f206001600160a01b0383165f5260205260405f20600160ff198254161790556001600160a01b03339216907f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d5f80a4600190565b50505f90565b805f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b62680060205260405f206001600160a01b0383165f5260205260ff60405f2054165f14612d1657805f527f02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b62680060205260405f206001600160a01b0383165f5260205260405f2060ff1981541690556001600160a01b03339216907ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b5f80a4600190565b60ff7fcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f033005416612e0a57565b7fd93c0665000000000000000000000000000000000000000000000000000000005f5260045ffd5b90805115612e86576020815191015ff5903d151982151661194e576001600160a01b03821615612e5e57565b7fb06ebf3d000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f4ca249dc000000000000000000000000000000000000000000000000000000005f5260045ffd5b15612eb557565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f6e616d65737061636520636f6c6c6973696f6e206465746563746564000000006044820152fd5b805f917a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000821015613070575b806d04ee2d6d415b85acef8100000000600a921015613055575b662386f26fc10000811015613041575b6305f5e100811015613030575b612710811015613021575b6064811015613013575b1015613008575b600a5f1960216001850194601f19612fbd612fa788612660565b97612fb5604051998a612610565b808952612660565b013660208801378501015b01917f30313233343536373839616263646566000000000000000000000000000000008282061a8353048015613003575f19600a9192612fc8565b505090565b600190910190612f8d565b606460029104930192612f86565b61271060049104930192612f7c565b6305f5e10060089104930192612f71565b662386f26fc1000060109104930192612f64565b6d04ee2d6d415b85acef810000000060209104930192612f54565b50604091507a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008104612f3a565b60ff7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a005460401c16156130c757565b7fd7e6bcf8000000000000000000000000000000000000000000000000000000005f5260045ffd5b90815181118015613115575b61310d575f613109926131a8565b9091565b50505f905f90565b505f6130fb565b90613159575080511561313157805190602001fd5b7fd6bda275000000000000000000000000000000000000000000000000000000005f5260045ffd5b8151158061319f575b61316a575090565b6001600160a01b03907f9996b315000000000000000000000000000000000000000000000000000000005f521660045260245ffd5b50803b15613162565b5f9392905b8183106131bd5750505060019190565b9092919360ff6131f47fff000000000000000000000000000000000000000000000000000000000000006020888601015116613231565b166009811161322657600a820291808304600a149015171561272c57810180911161272c5760019094019192906131ad565b505f94508493505050565b60f81c602f8111806132f3575b1561326b577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd00160ff1690565b60608111806132e9575b156132a2577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa90160ff1690565b60408111806132df575b156132d9577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc90160ff1690565b5060ff90565b50604781106132ac565b5060678110613275565b50603a811061323e56fe60806040526102728038038061001481610168565b92833981016040828203126101645781516001600160a01b03811692909190838303610164576020810151906001600160401b03821161016457019281601f8501121561016457835161006e610069826101a1565b610168565b9481865260208601936020838301011161016457815f926020809301865e86010152823b15610152577f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80546001600160a01b031916821790557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a282511561013a575f8091610122945190845af43d15610132573d91610113610069846101a1565b9283523d5f602085013e6101bc565b505b6040516057908161021b8239f35b6060916101bc565b50505034156101245763b398979f60e01b5f5260045ffd5b634c9c8ce360e01b5f5260045260245ffd5b5f80fd5b6040519190601f01601f191682016001600160401b0381118382101761018d57604052565b634e487b7160e01b5f52604160045260245ffd5b6001600160401b03811161018d57601f01601f191660200190565b906101e057508051156101d157805190602001fd5b63d6bda27560e01b5f5260045ffd5b81511580610211575b6101f1575090565b639996b31560e01b5f9081526001600160a01b0391909116600452602490fd5b50803b156101e956fe60806040525f8073ffffffffffffffffffffffffffffffffffffffff7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416368280378136915af43d5f803e156053573d5ff35b3d5ffd60a0806040523460295730608052610707908161002e82396080518181816101f001526103290152f35b5f80fdfe608060405260043610156100d0575b36156100725760646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f537475623a206e6f206c6f67696320696d706c656d656e7465640000000000006044820152fd5b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f537475623a20455448206e6f74206163636570746564000000000000000000006044820152fd5b5f3560e01c80634f1ef2861461026857806352d1902d146101ab5763ad3cb1cc0361000e57346101a7575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a757604080519061013281836105c6565b6005825260208201917f352e302e3000000000000000000000000000000000000000000000000000000083527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8351948593602085525180918160208701528686015e5f85828601015201168101030190f35b5f80fd5b346101a7575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a75773ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001630036102405760206040517f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8152f35b7fe07c8dba000000000000000000000000000000000000000000000000000000005f5260045ffd5b60407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101a75760043573ffffffffffffffffffffffffffffffffffffffff8116908181036101a7576024359067ffffffffffffffff82116101a757366023830112156101a7578160040135916102e183610634565b926102ef60405194856105c6565b808452602084019136602483830101116101a757815f9260246020930185378501015273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016803014908115610584575b50610240576040517f52d1902d000000000000000000000000000000000000000000000000000000008152602081600481885afa5f9181610550575b506103c157847f4c9c8ce3000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b807f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8692036105255750823b156104fa57807fffffffffffffffffffffffff00000000000000000000000000000000000000007f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416177f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a28251156104c8575f80916104be945190845af43d156104c0573d916104a283610634565b926104b060405194856105c6565b83523d5f602085013e61066e565b005b60609161066e565b505050346104d257005b7fb398979f000000000000000000000000000000000000000000000000000000005f5260045ffd5b7f4c9c8ce3000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b7faa1d49a4000000000000000000000000000000000000000000000000000000005f5260045260245ffd5b9091506020813d60201161057c575b8161056c602093836105c6565b810103126101a757519086610390565b3d915061055f565b905073ffffffffffffffffffffffffffffffffffffffff7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416141585610354565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761060757604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b67ffffffffffffffff811161060757601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b906106ab575080511561068357805190602001fd5b7fd6bda275000000000000000000000000000000000000000000000000000000005f5260045ffd5b815115806106fe575b6106bc575090565b73ffffffffffffffffffffffffffffffffffffffff907f9996b315000000000000000000000000000000000000000000000000000000005f521660045260245ffd5b50803b156106b45660a080604052346100c257306080525f5160206121c45f395f51905f525460ff8160401c166100b3576002600160401b03196001600160401b03821601610060575b6040516120fd90816100c78239608051818181610bf70152610cbc0152f35b6001600160401b0319166001600160401b039081175f5160206121c45f395f51905f525581527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d290602090a15f80610041565b63f92ee8a960e01b5f5260045ffd5b5f80fdfe6080806040526004361015610012575f80fd5b5f905f3560e01c9081630175e23b146116d6575080630c6723631461168d5780631794bb3c146112f65780632407f0b6146112bc57806339698ac0146111a957806346e2cc09146111905780634f1ef28614610c6f57806352d1902d14610bcf5780635467cb4814610b1c5780635b3cd6e214610ac95780635e7a7bdf14610a76578063715018a6146109b8578063781cd99d146109995780637a3979dc1461093e5780637a8d41c21461088d57806384fab62b1461084b578063850749251461081c5780638da5cb5b146107c957806395c5bf751461078e578063a70b9f0c14610770578063ad3cb1cc1461070b578063b3c65015146106c4578063b9566f761461067f578063b97dd9e21461065c578063b9f7f26014610621578063c45a0155146105ce578063cdafb9781461056c578063d4f0eb4d146104a5578063d5176d2314610402578063d8781342146103c5578063de1f453e146103a4578063e03961661461035a578063e8eb1dc31461033c578063f2fde38b146102505763f958cba21461019f575f80fd5b3461024d57602060031936011261024d5760043580151580910361024b576101c5611e51565b7fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff74ff00000000000000000000000000000000000000007fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a402549260a01b169116177fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a4025580f35b505b80fd5b503461024d57602060031936011261024d576102c061026d61179f565b610275611e51565b73ffffffffffffffffffffffffffffffffffffffff7fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a4015416156102c3575b6102bb611e51565b611f20565b80f35b73ffffffffffffffffffffffffffffffffffffffff7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300541673ffffffffffffffffffffffffffffffffffffffff8216907f16ae3179615a2815583b6566eae6f783b25419452c00599aeeb01088f13eca1a8580a36102b3565b503461024d578060031936011261024d57602060405162030d408152f35b503461024d57602060031936011261024d576004355f527f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b14801602052602060405f2054604051908152f35b503461024d578060031936011261024d576103bd611e51565b6102c0611db1565b503461024d578060031936011261024d5760207fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a40054604051908152f35b503461024d57602060031936011261024d5760043562278d0081029080820462278d0014901517156104785763688d46f001908163688d46f01161044b57602082604051908152f35b807f4e487b7100000000000000000000000000000000000000000000000000000000602492526011600452fd5b6024827f4e487b710000000000000000000000000000000000000000000000000000000081526011600452fd5b503461024d57602060031936011261024d5773ffffffffffffffffffffffffffffffffffffffff6104d461179f565b6104dc611e51565b16807fffffffffffffffffffffffff00000000000000000000000000000000000000007f5c6d1774bdd69d8d16847c3c97b51ea7343257b8f5ace5da9e25ab3bafd7d5005416177f5c6d1774bdd69d8d16847c3c97b51ea7343257b8f5ace5da9e25ab3bafd7d500557f253580f806741c11b3d4aa60d9cacc5bef0cebb35748767fe23f11916e2f04b98280a280f35b503461024d57602060031936011261024d5760043567ffffffffffffffff811161024b573660238201121561024b57806004013567ffffffffffffffff81116105ca573660248260051b840101116105ca5760246102c09201611c52565b8280fd5b503461024d578060031936011261024d57602073ffffffffffffffffffffffffffffffffffffffff7fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a4025416604051908152f35b503461024d578060031936011261024d5760206040517f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b148008152f35b503461024d578060031936011261024d576020610677611c14565b604051908152f35b503461024d578060031936011261024d57602060ff7fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a4025460a01c166040519015158152f35b503461024d578060031936011261024d57602067ffffffffffffffff7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a005416604051908152f35b503461024d578060031936011261024d575061076c60405161072e604082611836565b600581527f352e302e300000000000000000000000000000000000000000000000000000006020820152604051918291602083526020830190611924565b0390f35b503461024d578060031936011261024d57602060405162278d008152f35b503461024d578060031936011261024d5760206040517fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a4008152f35b503461024d578060031936011261024d57602073ffffffffffffffffffffffffffffffffffffffff7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c1993005416604051908152f35b503461024d5761076c610837610831366117e5565b90611ba6565b604051918291602083526020830190611924565b503461024d578060031936011261024d57602060ff7f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b1480054166040519015158152f35b503461024d578060031936011261024d57507fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a4015473ffffffffffffffffffffffffffffffffffffffff16806109365750602073ffffffffffffffffffffffffffffffffffffffff7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c19930054165b73ffffffffffffffffffffffffffffffffffffffff60405191168152f35b602090610918565b503461024d57606060031936011261024d5761095861179f565b906109616117c2565b906044359067ffffffffffffffff821161024d57602061098f858561098936600488016118de565b91611a75565b6040519015158152f35b503461024d578060031936011261024d57602060405163688d46f08152f35b503461024d578060031936011261024d576109d1611e51565b8073ffffffffffffffffffffffffffffffffffffffff7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300547fffffffffffffffffffffffff000000000000000000000000000000000000000081167f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c19930055167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b503461024d578060031936011261024d57602073ffffffffffffffffffffffffffffffffffffffff7fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a4015416604051908152f35b503461024d578060031936011261024d57602073ffffffffffffffffffffffffffffffffffffffff7f5c6d1774bdd69d8d16847c3c97b51ea7343257b8f5ace5da9e25ab3bafd7d5005416604051908152f35b503461024d578060031936011261024d57610b35611e51565b7f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b148005460ff811615610ba7577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00167f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b148005580f35b6004827fcd60c3ca000000000000000000000000000000000000000000000000000000008152fd5b503461024d578060031936011261024d5773ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163003610c475760206040517f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8152f35b807fe07c8dba0000000000000000000000000000000000000000000000000000000060049252fd5b50604060031936011261105e57610c8461179f565b9060243567ffffffffffffffff811161105e57610ca59036906004016118de565b73ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001680301490811561114e575b5061112657610cf4611e51565b7fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a402549073ffffffffffffffffffffffffffffffffffffffff8216604051927f0d4b4bda00000000000000000000000000000000000000000000000000000000845273ffffffffffffffffffffffffffffffffffffffff861693846004820152602081602481865afa908115611053575f916110f7575b5015611062575b507fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a40054813b1561105e575f916044839260405194859384927f07a9bee700000000000000000000000000000000000000000000000000000000845260048401528860248401525af180156110535761103e575b50604051937f52d1902d000000000000000000000000000000000000000000000000000000008552602085600481865afa80958596611006575b50610e6f57602484847f4c9c8ce3000000000000000000000000000000000000000000000000000000008252600452fd5b9091847f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8103610fdb5750813b15610fb057807fffffffffffffffffffffffff00000000000000000000000000000000000000007f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416177f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b8480a28151839015610f7d5780836020610f7195519101845af43d15610f75573d91610f55836118a4565b92610f636040519485611836565b83523d85602085013e612064565b5080f35b606091612064565b50505034610f885780f35b807fb398979f0000000000000000000000000000000000000000000000000000000060049252fd5b7f4c9c8ce3000000000000000000000000000000000000000000000000000000008452600452602483fd5b7faa1d49a4000000000000000000000000000000000000000000000000000000008552600452602484fd5b9095506020813d602011611036575b8161102260209383611836565b810103126110325751945f610e3e565b8480fd5b3d9150611015565b61104b9193505f90611836565b5f915f610e04565b6040513d5f823e3d90fd5b5f80fd5b60a01c60ff1615611073575f610d91565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f5570677261646520776f756c6420726573756c7420696e20676173207472616360448201527f6b696e672062616e0000000000000000000000000000000000000000000000006064820152fd5b611119915060203d60201161111f575b6111118183611836565b810190611a5d565b5f610d8a565b503d611107565b7fe07c8dba000000000000000000000000000000000000000000000000000000005f5260045ffd5b905073ffffffffffffffffffffffffffffffffffffffff7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc541614155f610ce7565b3461105e576111a76111a1366117e5565b90611967565b005b3461105e57602060031936011261105e576111c261179f565b6111ca611e51565b7fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a401805473ffffffffffffffffffffffffffffffffffffffff9283167fffffffffffffffffffffffff000000000000000000000000000000000000000082168117909255909116811561125c577f16ae3179615a2815583b6566eae6f783b25419452c00599aeeb01088f13eca1a5f80a3005b7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c1993005473ffffffffffffffffffffffffffffffffffffffff1691507f16ae3179615a2815583b6566eae6f783b25419452c00599aeeb01088f13eca1a5f80a3005b3461105e575f60031936011261105e5760206040517f5c6d1774bdd69d8d16847c3c97b51ea7343257b8f5ace5da9e25ab3bafd7d5008152f35b3461105e57606060031936011261105e5761130f61179f565b6113176117c2565b90604435907ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00549260ff8460401c16159367ffffffffffffffff811680159081611685575b600114908161167b575b159081611672575b5061164a578460017fffffffffffffffffffffffffffffffffffffffffffffffff00000000000000008316177ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00556115f5575b508215611597576113f973ffffffffffffffffffffffffffffffffffffffff926113e961200d565b6113f161200d565b6102bb61200d565b167fffffffffffffffffffffffff00000000000000000000000000000000000000007f5c6d1774bdd69d8d16847c3c97b51ea7343257b8f5ace5da9e25ab3bafd7d5005416177f5c6d1774bdd69d8d16847c3c97b51ea7343257b8f5ace5da9e25ab3bafd7d5005561146961200d565b611471611db1565b7fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a400557fc541a3613bd22a8da1c897658e95c42e6bb9158c83d62ac963646ba27200a40280547fffffffffffffffffffffff00000000000000000000000000000000000000000016337fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff1617905561150457005b7fffffffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffff7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0054167ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00557fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2602060405160018152a1005b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f41707020636861696e2049442063616e6e6f74206265203000000000000000006044820152fd5b7fffffffffffffffffffffffffffffffffffffffffffffff0000000000000000001668010000000000000001177ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0055846113c1565b7ff92ee8a9000000000000000000000000000000000000000000000000000000005f5260045ffd5b9050158661136e565b303b159150611366565b86915061135c565b3461105e57602060031936011261105e576004355f527f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b14801602052602060405f2054604051908152f35b3461105e57602060031936011261105e576004358015611777577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff810190811161174a5762278d0081029080820462278d00149015171561174a5763688d46f001908163688d46f01161174a576020918152f35b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b7fd69368d4000000000000000000000000000000000000000000000000000000005f5260045ffd5b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361105e57565b6024359073ffffffffffffffffffffffffffffffffffffffff8216820361105e57565b90602060031983011261105e5760043567ffffffffffffffff811161105e578260238201121561105e5780600401359267ffffffffffffffff841161105e576024848301011161105e576024019190565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761187757604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b67ffffffffffffffff811161187757601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b81601f8201121561105e578035906118f5826118a4565b926119036040519485611836565b8284526020838301011161105e57815f926020809301838601378301015290565b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f602080948051918291828752018686015e5f8582860101520116010190565b9060ff7f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b148005416156119ab57906119a16119a9925a926119b0565b5a9003611ebd565b565b6119a9915b908015611a35576119c091611ba6565b6119cb813233611a75565b15611a0d577f83363b78bdfbb23e2a61db7accc3c01fda29c5c5ec81888003cb962912618a7f6040516020815280611a0833946020830190611924565b0390a2565b7fdc741458000000000000000000000000000000000000000000000000000000005f5260045ffd5b7fdc37f51d000000000000000000000000000000000000000000000000000000005f5260045ffd5b9081602091031261105e5751801515810361105e5790565b9190815162030d408111611b74575073ffffffffffffffffffffffffffffffffffffffff7f5c6d1774bdd69d8d16847c3c97b51ea7343257b8f5ace5da9e25ab3bafd7d500541660018114928315611ad0575b505050905090565b6020935073ffffffffffffffffffffffffffffffffffffffff94611b398692604051978896879586957f7a3979dc000000000000000000000000000000000000000000000000000000008752166004860152166024840152606060448401526064830190611924565b03915afa908115611053575f91611b55575b50805f8080611ac8565b611b6e915060203d60201161111f576111118183611836565b5f611b4b565b7f4634691b000000000000000000000000000000000000000000000000000000005f5260045262030d4060245260445ffd5b6021611c1191836040519485927f040000000000000000000000000000000000000000000000000000000000000060208501528484013781015f8382015203017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08101835282611836565b90565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff9772b910420142811161174a5762278d0090046001810180911161174a5790565b9060ff7f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b14800541615611c8c57906119a16119a9925a92611d22565b6119a991611d22565b9190811015611cf55760051b810135907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18136030182121561105e57019081359167ffffffffffffffff831161105e57602001823603811361105e579190565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b8115611a35575f5b828110611d3657505050565b611d41818484611c95565b905015611a355780611d596108316001938686611c95565b611d64813233611a75565b611d70575b5001611d2a565b7f83363b78bdfbb23e2a61db7accc3c01fda29c5c5ec81888003cb962912618a7f6040516020815280611da833946020830190611924565b0390a25f611d69565b7f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b1480054600160ff8216151514611e29577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00166001177f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b1480055565b7f7679400d000000000000000000000000000000000000000000000000000000005f5260045ffd5b73ffffffffffffffffffffffffffffffffffffffff7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c19930054163303611e9157565b7f118cdaa7000000000000000000000000000000000000000000000000000000005f523360045260245ffd5b611ec5611c14565b3a913a15611f17575b82810292818404149015171561174a575f527f119494e47c2426a6072fc6072ec5c5d5ae865a3372fd102c643c18e978b1480160205260405f20805491820180921161174a5755565b60019250611ece565b73ffffffffffffffffffffffffffffffffffffffff168015611fe15773ffffffffffffffffffffffffffffffffffffffff7f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c19930054827fffffffffffffffffffffffff00000000000000000000000000000000000000008216177f9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c19930055167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e05f80a3565b7f1e4fbdf7000000000000000000000000000000000000000000000000000000005f525f60045260245ffd5b60ff7ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a005460401c161561203c57565b7fd7e6bcf8000000000000000000000000000000000000000000000000000000005f5260045ffd5b906120a1575080511561207957805190602001fd5b7fd6bda275000000000000000000000000000000000000000000000000000000005f5260045ffd5b815115806120f4575b6120b2575090565b73ffffffffffffffffffffffffffffffffffffffff907f9996b315000000000000000000000000000000000000000000000000000000005f521660045260245ffd5b50803b156120aa56f0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80\x80`@R`\x046\x10\x15a\0\x12W_\x80\xFD[_\x90_5`\xE0\x1C\x90\x81b\xB6\x8As\x14a%\x1CWP\x80c\x01\xFF\xC9\xA7\x14a${W\x80c\x07\xA9\xBE\xE7\x14a#\xCBW\x80c\t\xD2>$\x14a#\x93W\x80c\rKK\xDA\x14a#VW\x80c\x1D\x1A\xB1Z\x14a\"bW\x80c$\x8A\x9C\xA3\x14a\"\x18W\x80c)W\x10\xFF\x14a!\xE0W\x80c)\x7FLd\x14a!\xC4W\x80c//\xF1]\x14a!gW\x80c1D\xE8S\x14a!&W\x80c2\xEDh\x05\x14a \x95W\x80c6V\x8A\xBE\x14a 8W\x80c?K\xA8:\x14a\x1F{W\x80cO\x1E\xF2\x86\x14a\x1C\x83W\x80cR\xD1\x90-\x14a\x1B\xF1W\x80cV\xDB\xA7y\x14a\x1B\xCBW\x80c[\xD6X\x8B\x14a\x1A\x8FW\x80c\\\x97Z\xBB\x14a\x1ANW\x80cc\x89\xF8\xDA\x14a\x19\xFFW\x80cg\xA5\xFB,\x14a\x17$W\x80cj\xB5\x14B\x14a\x16\xECW\x80cj\xE7\xE7\x03\x14a\x16\xCAW\x80co\xF6\xF6\xC0\x14a\x16\x97W\x80cr2\xC13\x14a\x16bW\x80c|\x16\xFF\xC4\x14a\x15\xF6W\x80c\x84V\xCBY\x14a\x15]W\x80c\x8B5\xBA%\x14a\x14\xFEW\x80c\x8C9\xAA\xA4\x14a\x12\xE1W\x80c\x8D\xE6\xE2\x8C\x14a\x12\xC6W\x80c\x91\xD1HT\x14a\x12\\W\x80c\x99\x9Dq\xD4\x14a\x12>W\x80c\x9E\x15\xD6\xFF\x14a\x0F^W\x80c\xA0\x8F\x1A\x7F\x14a\x12\x0EW\x80c\xA2\x17\xFD\xDF\x14a\x11\xF2W\x80c\xAA\xE7#\x8C\x14a\x10\xE7W\x80c\xAD<\xB1\xCC\x14a\x10\x86W\x80c\xAF\xEBU\xF8\x14a\x0F\xE2W\x80c\xB4\x16f>\x14a\x0F\xC6W\x80c\xB9c\xEB\xF3\x14a\x0F\x8DW\x80c\xC1\x12\xEE\x8C\x14a\x0F^W\x80c\xC4\xD6m\xE8\x14a\t\xE1W\x80c\xCAL\xD0%\x14a\t5W\x80c\xD4\xF4v\x8F\x14a\x05\x93W\x80c\xD5Gt\x1F\x14a\x05,W\x80c\xEC\x87b\x1C\x14a\x04\xF1W\x80c\xEE^\xE7<\x14a\x04+W\x80c\xEE\xEBD\xAD\x14a\x02aWc\xFFv\xAE\xD6\x14a\x028W_\x80\xFD[4a\x02^W\x80`\x03\x196\x01\x12a\x02^W` `\x01`\x01`\xA0\x1B\x03`\x06T\x16`@Q\x90\x81R\xF3[\x80\xFD[P4a\x02^W` `\x03\x196\x01\x12a\x02^W`\x01`\x01`\xA0\x1B\x03a\x02\x83a%LV[a\x02\x8Ba)\xF3V[\x16\x80\x82R`\x08` R`\xFF`@\x83 T\x16\x15a\x04\x03W`\x01`\x01`\xA0\x1B\x03`\x06T\x16\x81\x14a\x03\xDBW\x81[`\x07T\x80\x82\x10\x15a\x03\xD4W\x82`\x01`\x01`\xA0\x1B\x03a\x02\xD2\x84a%\xA7V[\x90T\x90`\x03\x1B\x1C\x16\x14a\x02\xE8WP`\x01\x01a\x02\xB5V[_\x19\x81\x01\x90\x81\x11a\x03\xA7W\x90a\x03\x19`\x01`\x01`\xA0\x1B\x03a\x03\x0Ba\x038\x94a%\xA7V[\x90T\x90`\x03\x1B\x1C\x16\x91a%\xA7V[\x90\x91\x90`\x01`\x01`\xA0\x1B\x03\x80\x84T\x92`\x03\x1B\x93\x16\x83\x1B\x92\x1B\x19\x16\x17\x90UV[`\x07T\x80\x15a\x03zW_\x19\x01a\x03M\x81a%\xA7V[`\x01`\x01`\xA0\x1B\x03\x82T\x91`\x03\x1B\x1B\x19\x16\x90U`\x07U[\x81R`\x08` R`@\x81 `\xFF\x19\x81T\x16\x90U\x80\xF3[`$\x83\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`1`\x04R\xFD[`$\x84\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x11`\x04R\xFD[PPa\x03dV[`\x04\x82\x7F\xD5\xCCJ\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[`\x04\x82\x7F\xFB\x10\x18\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[P4a\x02^W` `\x03\x196\x01\x12a\x02^Wa\x04\xED\x90a\x04\xD9a\x04La%LV[a\x02r\x92` `@Q\x92a\x04b\x82\x87\x01\x85a&\x10V[\x85\x84R\x81\x84\x01\x95a2\xFE\x879`@Qa\x04\xAA\x81a\x04\x9C\x85\x82\x01\x94\x85`\x01`\x01`\xA0\x1B\x03``\x92\x16\x81R`@` \x82\x01R_`@\x82\x01R\x01\x90V[\x03`\x1F\x19\x81\x01\x83R\x82a&\x10V[`@Q\x96\x87\x95Q\x80\x91\x85\x88\x01^\x85\x01\x90\x83\x82\x01\x90\x85\x82RQ\x92\x83\x91^\x01\x01\x90\x81R\x03`\x1F\x19\x81\x01\x83R\x82a&\x10V[`@Q\x91\x82\x91` \x83R` \x83\x01\x90a&\xCEV[\x03\x90\xF3[P4a\x02^W\x80`\x03\x196\x01\x12a\x02^W` `@Q\x7F$\x1E\xCF\x16\xD7\x9D\x0F\x8D\xBF\xB9,\xBC\x07\xFE\x17\x84\x04%\x97l\xF0f\x7F\x02/\xE9\x87|\xAA\x83\x1B\x08\x81R\xF3[P4a\x02^W`@`\x03\x196\x01\x12a\x02^Wa\x05\x8F`\x045a\x05La%6V[\x90a\x05\x8Aa\x05\x85\x82_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`\x01`@_ \x01T\x90V[a*[V[a-\x1CV[P\x80\xF3[P4a\x02^W`\x01`\x01`\xA0\x1B\x03a\x05\xAA6a&|V[\x91\x92\x90a\x05\xB5a-\xDFV[\x16\x80\x15\x80\x15a\t$W[a\x08\xFCW\x82\x15\x92\x83\x15a\x08\xF6W3\x85R`\x0B` R`@\x85 T\x90[a\x05\xE5\x823a(\xC6V[\x94\x85\x87R`\x03` R`\x01`\x01`\xA0\x1B\x03`@\x88 T\x16a\x08\xCEW\x85\x92\x91\x90\x15a\x08DWP3\x86R`\x0B` R`@\x86 a\x06 \x81Ta'\x9EV[\x90U[3\x7FU\x01\x94f\x8A\x07*|}\xAF\x12\xB7u\x1ARG\x8A\x8A\x12\xDE\x0B\x9FUqb\xD2\x80\xFB\x8Ct\xF4s\x87\x80\xA4`\x01`\x01`\xA0\x1B\x03a\x06aa\x06[a)'V[\x85a.2V[\x92\x84\x86R`\x03` R`@\x86 \x82\x85\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82T\x16\x17\x90Ua\x06\xA1\x85a'\xACV[\x16\x90\x84\x80`@Q\x7F\x17\x94\xBB<\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01Ra\x06\xFD\x81a\x04\x9C\x89\x880`$\x85\x01`\x01`\x01`\xA0\x1B\x03`@\x92\x95\x94\x93\x81``\x84\x01\x97\x16\x83R\x16` \x82\x01R\x01RV[a\x04\x9Ca\x07G`\x01`\x01`\xA0\x1B\x03`\x06T\x16\x92`@Q\x92\x83\x91` \x83\x01\x95\x7FO\x1E\xF2\x86\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x87R`$\x84\x01a'\xE8V[Q\x90\x82\x87Z\xF1a\x07Ua(\x0BV[P\x15a\x08\x1CW`\x01`\x01`\xA0\x1B\x03\x83\x16\x90\x81;\x15a\x08\x18W`@Q\x90\x7F\xF2\xFD\xE3\x8B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82R`\x04\x82\x01R\x85\x81`$\x81\x83\x86Z\xF1\x80\x15a\x08\rWa\x07\xF4W[`@Q\x80a\x04\xED\x87\x87\x87\x87\x83\x7FI\xB2\x1F\x1EA\x90\xDB\x8B\n\x93<\x95\x1E\xD0\x13\xDE\",\x84|\x15F\x17Th-\xAA.\xAB\x1F\xDB\xD2\x8E\x80\xA4`\x01`\x01`\xA0\x1B\x03\x16\x83R` \x83\x01R`@\x82\x01\x90V[a\x07\xFF\x86\x80\x92a&\x10V[a\x08\tW_a\x07\xADV[\x84\x80\xFD[`@Q=\x88\x82>=\x90\xFD[\x85\x80\xFD[`\x04\x85\x7F\xABn\xB5\xBC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[\x90\x91P3\x86R`\x0B` R`@\x86 T\x81\x10a\x08\xA6W`\x01\x81\x01\x80\x91\x11a\x08yW3\x86R`\x0B` R`@\x86 U\x83\x90a\x06#V[`$\x86\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x11`\x04R\xFD[`\x04\x86\x7F$Y\x1D\x89\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[`\x04\x87\x7F$Y\x1D\x89\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[\x80a\x05\xDBV[`\x04\x84\x7F\xD9.#=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[P`\x01`\x01`\xA0\x1B\x03\x82\x16\x15a\x05\xBFV[P4a\x02^W\x80`\x03\x196\x01\x12a\x02^W`\x01`\x01`\xA0\x1B\x03`U`\x0B` \x93a\x075`@Q\x90a\th\x87\x82\x01\x83a&\x10V[\x80\x82R\x86\x82\x01\x90a5p\x829a\t\x9C\x87`@Q\x80\x93\x82\x82\x01\x95Q\x80\x91\x87^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a&\x10V[Q\x90 \x90P`@Q\x90`@\x82\x01R\x7FSYNDICATE_STUB_V1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85\x82\x01R0\x81R\x01`\xFF\x81S \x16`@Q\x90\x81R\xF3[P4a\x02^W` `\x03\x196\x01\x12a\x02^Wa\t\xFBa%LV[\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T\x90`\xFF\x82`@\x1C\x16\x15\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x80\x15\x90\x81a\x0FVW[`\x01\x14\x90\x81a\x0FLW[\x15\x90\x81a\x0FCW[Pa\x0F\x1BW\x82`\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\x83\x16\x17\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0Ua\x0E\xC6W[P`\x01`\x01`\xA0\x1B\x03\x81\x16\x15a\x0E\x9EWa\n\xDB\x90a\n\xBCa0\x98V[a\n\xC4a0\x98V[a\n\xCCa0\x98V[a\n\xD5\x81a*\xD4V[Pa+\x83V[Pa\x01\xFE\x82R`\x02` R`\xFF`@\x83 T\x16`\x03\x81\x10\x15a\x0EqW`\x02a\x0B\x04\x91\x14\x15a.\xAEV[a\x01\xFE\x82R`\x02` R`@\x82 `\x01`\xFF\x19\x82T\x16\x17\x90U`3\x80[a\r\xFDWP\x7F\xD9\xE1#\x91w\xBF\xBD*\xEB\xF5\xD0\xF2\x0F\xC0u\xE6\xDFZP,Y\xD1!\xAC\xD5sB\xC7\x83\xE3\x13d`@\x83Ta\x01\xFE\x85U\x81Q\x90\x81Ra\x01\xFE` \x82\x01R\xA1`\x01\x80U`@Qa\x075a\x0Bu` \x82\x01\x83a&\x10V[\x80\x82R` \x82\x01\x90a5p\x829a\x0B\xAB` `@Q\x80\x93\x82\x82\x01\x95Q\x80\x91\x87^\x81\x01\x87\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a&\x10V[\x80Q\x15a\r\xD5WQ\x7FSYNDICATE_STUB_V1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x84\xF5=\x15\x19\x81\x15\x16a\ruW`\x01`\x01`\xA0\x1B\x03\x16\x80\x15a\r\xADW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x05T\x16\x17`\x05U`@Qa!\xE4\x80\x82\x01\x90\x82\x82\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11\x17a\r\x80W\x90\x82\x91a<\xA5\x839\x03\x90\x83\xF0\x80\x15a\ruW`\x01`\x01`\xA0\x1B\x03a\x0C\x84\x91\x16\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x06T\x16\x17`\x06Ua&\xF3V[`\x01`\x01`\xA0\x1B\x03`\x06T\x16\x82R`\x08` R`@\x82 `\x01`\xFF\x19\x82T\x16\x17\x90U`\x01`\x01`\xA0\x1B\x03`\x06T\x16\x90`@Q\x91\x7F3\x1C\xED\xC7\x1F(\xC4mFv\x91w\x06u\xB5\x86\xE8\xAAw\xA0\xD4\xFE\t\xF2W\xD0\x1E\xF0\x0B\xC1TX\x84\x80\xA2a\x0C\xE3WP\x80\xF3[` \x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x91\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T\x16\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0U`\x01\x81R\xA1\x80\xF3[`@Q=\x84\x82>=\x90\xFD[`$\x85\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`A`\x04R\xFD[`\x04\x83\x7F\xB0n\xBF=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[`\x04\x84\x7FL\xA2I\xDC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[\x80\x83R`\x02` R`\xFF`@\x84 T\x16`\x03\x81\x10\x15a\x0EDW\x90a\x0E&`\x01`\n\x93\x14\x15a.\xAEV[\x80\x84R`\x02` R`@\x84 `\x02`\xFF\x19\x82T\x16\x17\x90U\x04\x80a\x0B!V[`$\x84\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`!`\x04R\xFD[`$\x83\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`!`\x04R\xFD[`\x04\x83\x7F\xD9.#=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\x16h\x01\0\0\0\0\0\0\0\x01\x17\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0U_a\n\xA0V[`\x04\x84\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[\x90P\x15_a\nMV[0;\x15\x91Pa\nEV[\x84\x91Pa\n;V[P4a\x02^W` `\x03\x196\x01\x12a\x02^W`\xFF`@` \x92`\x045\x81R`\t\x84R T\x16`@Q\x90\x15\x15\x81R\xF3[P4a\x02^W` `\x03\x196\x01\x12a\x02^W`\x045\x81R`\x02` R`\xFF`@\x82 T\x16`@Q\x90`\x03\x81\x10\x15a\x0EqW` \x92P\x81R\xF3[P4a\x02^W\x80`\x03\x196\x01\x12a\x02^Wa\x04\xEDa\x04\xD9a)'V[P4a\x02^W`\x01`\x01`\xA0\x1B\x03a\x0F\xF96a&|V[\x91\x92\x90a\x10\x04a)\xF3V[a\x10\x0Ca-\xDFV[\x16\x80\x15\x80\x15a\x10uW[a\x08\xFCW\x82\x15a\x08\xFCW\x82\x84R`\x03` R`\x01`\x01`\xA0\x1B\x03`@\x85 T\x16a\x10MW`\x01`\x01`\xA0\x1B\x03a\x06aa\x06[a)'V[`\x04\x84\x7F$Y\x1D\x89\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[P`\x01`\x01`\xA0\x1B\x03\x82\x16\x15a\x10\x16V[P4a\x02^W\x80`\x03\x196\x01\x12a\x02^WPa\x04\xED`@Qa\x10\xA9`@\x82a&\x10V[`\x05\x81R\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01R`@Q\x91\x82\x91` \x83R` \x83\x01\x90a&\xCEV[P4a\x02^W` `\x03\x196\x01\x12a\x02^W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x11\xEEW6`#\x82\x01\x12\x15a\x11\xEEW\x80`\x04\x015\x90a\x11%\x82a&\xB6V[\x91a\x113`@Q\x93\x84a&\x10V[\x80\x83R`$` \x84\x01\x91`\x05\x1B\x83\x01\x01\x916\x83\x11a\x08\tW`$\x01\x90[\x82\x82\x10a\x11\xDEWPPPa\x11d\x81Qa'YV[\x82[\x82Q\x81\x10\x15a\x11\xC8W\x80a\x11|`\x01\x92\x85a'\x8AV[Q\x85R`\t` R`\xFF`@\x86 T\x16\x15a\x11\x98W[\x01a\x11fV[a\x11\xA2\x81\x85a'\x8AV[Q\x85R`\x03` R`\x01`\x01`\xA0\x1B\x03`@\x86 T\x16a\x11\xC2\x82\x85a'\x8AV[Ra\x11\x92V[`@Q` \x80\x82R\x81\x90a\x04\xED\x90\x82\x01\x85a%\xD4V[\x815\x81R` \x91\x82\x01\x91\x01a\x11PV[P\x80\xFD[P4a\x02^W\x80`\x03\x196\x01\x12a\x02^W` \x90`@Q\x90\x81R\xF3[P4a\x02^W`@`\x03\x196\x01\x12a\x02^W` a\x126a\x12-a%LV[`$5\x90a(\xC6V[`@Q\x90\x81R\xF3[P4a\x02^W\x80`\x03\x196\x01\x12a\x02^W` `\x01T`@Q\x90\x81R\xF3[P4a\x02^W`@`\x03\x196\x01\x12a\x02^W`\x01`\x01`\xA0\x1B\x03`@a\x12\x80a%6V[\x92`\x045\x81R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R \x91\x16_R` R` `\xFF`@_ T\x16`@Q\x90\x15\x15\x81R\xF3[P4a\x02^W\x80`\x03\x196\x01\x12a\x02^W` a\x126a(:V[P4a\x02^W` `\x03\x196\x01\x12a\x02^W`\x045\x7F$\x1E\xCF\x16\xD7\x9D\x0F\x8D\xBF\xB9,\xBC\x07\xFE\x17\x84\x04%\x97l\xF0f\x7F\x02/\xE9\x87|\xAA\x83\x1B\x08\x82R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`@\x82 `\x01`\x01`\xA0\x1B\x033\x16_R` R`\xFF`@_ T\x16\x15a\x14\xAEW\x80\x15a\x14*W\x80\x82R`\x02` R`\xFF`@\x83 T\x16`\x03\x81\x10\x15a\x0EqW`\x02a\x13\x89\x91\x14\x15a.\xAEV[\x80\x82R`\x02` R`@\x82 `\x01`\xFF\x19\x82T\x16\x17\x90U`\n\x81\x04\x80[a\x13\xE3WP`@\x7F\xD9\xE1#\x91w\xBF\xBD*\xEB\xF5\xD0\xF2\x0F\xC0u\xE6\xDFZP,Y\xD1!\xAC\xD5sB\xC7\x83\xE3\x13d\x91\x83T\x90\x80\x85U\x82Q\x91\x82R` \x82\x01R\xA1\x80\xF3[\x80\x83R`\x02` R`\xFF`@\x84 T\x16`\x03\x81\x10\x15a\x0EDW\x90a\x14\x0C`\x01`\n\x93\x14\x15a.\xAEV[\x80\x84R`\x02` R`@\x84 `\x02`\xFF\x19\x82T\x16\x17\x90U\x04\x80a\x13\xA6V[`\x84`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7Fnamespace prefix of 0 is forbidd`D\x82\x01R\x7Fen\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R\xFD[`D\x82\x7F\xE2Q}?\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R3`\x04R\x7F$\x1E\xCF\x16\xD7\x9D\x0F\x8D\xBF\xB9,\xBC\x07\xFE\x17\x84\x04%\x97l\xF0f\x7F\x02/\xE9\x87|\xAA\x83\x1B\x08`$R\xFD[P4a\x02^W`@`\x03\x196\x01\x12a\x02^W`\x045`\x01`\x01`\xA0\x1B\x03a\x15#a%6V[a\x15+a)\xF3V[a\x154\x83a)\xB5V[\x16\x90\x7F\xEB\xB4\xC5\r\xEB(Q\x92\xD1\xC2\xAA\x882\xB1\xFE\xEB\x07\x8B\xA0\xFD\x92\xBBC\x9C\r\xEE(\xEB\xE9\xBB6\xE9\x83\x80\xA3\x80\xF3[P4a\x02^W\x80`\x03\x196\x01\x12a\x02^Wa\x15va)\xF3V[a\x15~a-\xDFV[`\x01`\xFF\x19\x7F\xCD^\xD1\\n\x18~w\xE9\xAE\xE8\x81\x84\xC2\x1FO!\x82\xABX'\xCB;~\x07\xFB\xED\xCDc\xF03\0T\x16\x17\x7F\xCD^\xD1\\n\x18~w\xE9\xAE\xE8\x81\x84\xC2\x1FO!\x82\xABX'\xCB;~\x07\xFB\xED\xCDc\xF03\0U\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2X` `@Q3\x81R\xA1\x80\xF3[P4a\x02^W` `\x03\x196\x01\x12a\x02^W`\x01`\x01`\xA0\x1B\x03a\x16\x18a%LV[a\x16 a)\xF3V[\x16\x80\x82R`\x08` R`\xFF`@\x83 T\x16\x15a\x04\x03W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x06T\x16\x17`\x06U\x80\xF3[P4a\x02^W` `\x03\x196\x01\x12a\x02^W`\x01`\x01`\xA0\x1B\x03`@` \x92`\x045\x81R`\x03\x84R T\x16\x15\x15`@Q\x90\x81R\xF3[P4a\x02^W` `\x03\x196\x01\x12a\x02^W`\x01`\x01`\xA0\x1B\x03`@` \x92`\x045\x81R`\x03\x84R T\x16`@Q\x90\x81R\xF3[P4a\x02^W\x80`\x03\x196\x01\x12a\x02^W` a\x126`\x04T`\nT\x90a'\x1FV[P4a\x02^W` `\x03\x196\x01\x12a\x02^W`@` \x91`\x01`\x01`\xA0\x1B\x03a\x17\x13a%LV[\x16\x81R`\x0B\x83R T`@Q\x90\x81R\xF3[P4a\x19YW`\x01`\x01`\xA0\x1B\x03\x90a\x17<6a&|V[\x92\x91\x93\x90a\x17Ha-\xDFV[\x16\x92\x83\x15\x80\x15a\x19\xEEW[a\x19\xC6W\x80\x15\x90\x81\x15a\x19\xC0WPa\x17ia(:V[\x90[\x81_R`\x03` R`\x01`\x01`\xA0\x1B\x03`@_ T\x16a\x19\x98Wa\x19\x85W[`\x01`\x01`\xA0\x1B\x03a\x17\xA3a\x17\x9Da)'V[\x83a.2V[\x93\x82_R`\x03` R`@_ \x82\x86\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82T\x16\x17\x90Ua\x17\xE3\x83a'\xACV[\x16\x92_\x80`@Q\x7F\x17\x94\xBB<\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01Ra\x18?\x81a\x04\x9C\x87\x8A0`$\x85\x01`\x01`\x01`\xA0\x1B\x03`@\x92\x95\x94\x93\x81``\x84\x01\x97\x16\x83R\x16` \x82\x01R\x01RV[a\x04\x9Ca\x18\x89`\x01`\x01`\xA0\x1B\x03`\x06T\x16\x92`@Q\x92\x83\x91` \x83\x01\x95\x7FO\x1E\xF2\x86\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x87R`$\x84\x01a'\xE8V[Q\x90\x82\x85Z\xF1a\x18\x97a(\x0BV[P\x15a\x19]W`\x01`\x01`\xA0\x1B\x03\x81\x16\x93\x84;\x15a\x19YW`@Q\x95\x7F\xF2\xFD\xE3\x8B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x87R`\x04\x87\x01R_\x86`$\x81\x83\x89Z\xF1\x95\x86\x15a\x19NW\x7FI\xB2\x1F\x1EA\x90\xDB\x8B\n\x93<\x95\x1E\xD0\x13\xDE\",\x84|\x15F\x17Th-\xAA.\xAB\x1F\xDB\xD2\x96a\x198W[Pa\x04\xED\x93\x94\x83`@Q\x97\x87\x89\x98\xA4`\x01`\x01`\xA0\x1B\x03\x16\x83R` \x83\x01R`@\x82\x01\x90V[a\x04\xED\x94P_a\x19G\x91a&\x10V[_\x93a\x19\x12V[`@Q=_\x82>=\x90\xFD[_\x80\xFD[\x7F\xABn\xB5\xBC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[a\x19\x90`\x01Ta'\x9EV[`\x01Ua\x17\x8AV[\x7F$Y\x1D\x89\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90a\x17kV[\x7F\xD9.#=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[P`\x01`\x01`\xA0\x1B\x03\x83\x16\x15a\x17SV[4a\x19YW` `\x03\x196\x01\x12a\x19YW` `\x01`\x01`\xA0\x1B\x03`U`\x0Ba\x1A&a)'V[\x84\x81Q\x91\x01 `@Q\x90`@\x82\x01R`\x045\x85\x82\x01R0\x81R\x01`\xFF\x81S \x16`@Q\x90\x81R\xF3[4a\x19YW_`\x03\x196\x01\x12a\x19YW` `\xFF\x7F\xCD^\xD1\\n\x18~w\xE9\xAE\xE8\x81\x84\xC2\x1FO!\x82\xABX'\xCB;~\x07\xFB\xED\xCDc\xF03\0T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x19YW_`\x03\x196\x01\x12a\x19YW`\x04Ta\x1A\xAE`\nT\x82a'\x1FV[\x90a\x1A\xB8\x82a&\xB6V[\x90a\x1A\xC6`@Q\x92\x83a&\x10V[\x82\x82Ra\x1A\xE7a\x1A\xD5\x84a&\xB6V[\x93`\x1F\x19` \x85\x01\x95\x016\x867a'YV[\x90__[\x82\x81\x10a\x1B?WPPP`@Q\x91`@\x83\x01\x90`@\x84RQ\x80\x91R``\x83\x01\x93\x90_[\x81\x81\x10a\x1B)W\x84\x80a\x04\xED\x88\x87\x83\x82\x03` \x85\x01Ra%\xD4V[\x82Q\x86R` \x95\x86\x01\x95\x90\x92\x01\x91`\x01\x01a\x1B\x0EV[a\x1BH\x81a%bV[\x90T\x90`\x03\x1B\x1C_R`\t` R`\xFF`@_ T\x16\x15a\x1BlW[`\x01\x01a\x1A\xEBV[\x90a\x1B\xC3`\x01\x91a\x1B|\x84a%bV[\x90T\x90`\x03\x1B\x1Ca\x1B\x8D\x82\x89a'\x8AV[Ra\x1B\x97\x84a%bV[\x90T\x90`\x03\x1B\x1C_R`\x03` R`\x01`\x01`\xA0\x1B\x03`@_ T\x16a\x1B\xBD\x82\x88a'\x8AV[Ra'\x9EV[\x91\x90Pa\x1BdV[4a\x19YW_`\x03\x196\x01\x12a\x19YW` `\x01`\x01`\xA0\x1B\x03`\x05T\x16`@Q\x90\x81R\xF3[4a\x19YW_`\x03\x196\x01\x12a\x19YW`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x160\x03a\x1C[W` `@Q\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x81R\xF3[\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[`@`\x03\x196\x01\x12a\x19YWa\x1C\x97a%LV[`$5\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x19YW6`#\x83\x01\x12\x15a\x19YW\x81`\x04\x015\x90a\x1C\xC4\x82a&`V[\x91a\x1C\xD2`@Q\x93\x84a&\x10V[\x80\x83R` \x83\x01\x936`$\x83\x83\x01\x01\x11a\x19YW\x81_\x92`$` \x93\x01\x877\x84\x01\x01R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x800\x14\x90\x81\x15a\x1FFW[Pa\x1C[Wa\x1D7a)\xF3V[`\x01`\x01`\xA0\x1B\x03\x81\x16\x92`@Q\x7FR\xD1\x90-\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x81`\x04\x81\x88Z\xFA_\x91\x81a\x1F\x12W[Pa\x1D\xAAW\x84\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x80\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x86\x92\x03a\x1E\xE7WP\x82;\x15a\x1E\xBCW\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCT\x16\x17\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCU\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;_\x80\xA2\x82Q\x15a\x1E\x8AW_\x80\x91a\x1E\x88\x94Q\x90\x84Z\xF4a\x1E\x82a(\x0BV[\x91a1\x1CV[\0[PPP4a\x1E\x94W\0[\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x90\x91P` \x81=` \x11a\x1F>W[\x81a\x1F.` \x93\x83a&\x10V[\x81\x01\x03\x12a\x19YWQ\x90\x86a\x1DyV[=\x91Pa\x1F!V[\x90P`\x01`\x01`\xA0\x1B\x03\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCT\x16\x14\x15\x84a\x1D*V[4a\x19YW_`\x03\x196\x01\x12a\x19YWa\x1F\x93a)\xF3V[\x7F\xCD^\xD1\\n\x18~w\xE9\xAE\xE8\x81\x84\xC2\x1FO!\x82\xABX'\xCB;~\x07\xFB\xED\xCDc\xF03\0T`\xFF\x81\x16\x15a \x10W`\xFF\x19\x16\x7F\xCD^\xD1\\n\x18~w\xE9\xAE\xE8\x81\x84\xC2\x1FO!\x82\xABX'\xCB;~\x07\xFB\xED\xCDc\xF03\0U\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA` `@Q3\x81R\xA1\0[\x7F\x8D\xFC +\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x19YW`@`\x03\x196\x01\x12a\x19YWa Qa%6V[3`\x01`\x01`\xA0\x1B\x03\x82\x16\x03a mWa\x1E\x88\x90`\x045a-\x1CV[\x7Ff\x97\xB22\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x19YW_`\x03\x196\x01\x12a\x19YW`@Q\x80` `\x07T\x91\x82\x81R\x01\x90`\x07_R\x7F\xA6l\xC9(\xB5\xED\xB8*\xF9\xBDI\x92)T\x15Z\xB7\xB0\x94&\x94\xBE\xA4\xCEDf\x1D\x9A\x876\xC6\x88\x90_[\x81\x81\x10a!\x07Wa\x04\xED\x85a \xF3\x81\x87\x03\x82a&\x10V[`@Q\x91\x82\x91` \x83R` \x83\x01\x90a%\xD4V[\x82T`\x01`\x01`\xA0\x1B\x03\x16\x84R` \x90\x93\x01\x92`\x01\x92\x83\x01\x92\x01a \xDCV[4a\x19YW` `\x03\x196\x01\x12a\x19YW`\x045`\x07T\x81\x10\x15a\x19YW`\x01`\x01`\xA0\x1B\x03a!W` \x92a%\xA7V[\x90T\x90`\x03\x1B\x1C\x16`@Q\x90\x81R\xF3[4a\x19YW`@`\x03\x196\x01\x12a\x19YWa\x1E\x88`\x045a!\x86a%6V[\x90a!\xBFa\x05\x85\x82_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`\x01`@_ \x01T\x90V[a,OV[4a\x19YW_`\x03\x196\x01\x12a\x19YW` _T`@Q\x90\x81R\xF3[4a\x19YW` `\x03\x196\x01\x12a\x19YW`\x01`\x01`\xA0\x1B\x03a\"\x01a%LV[\x16_R`\x0B` R` `@_ T`@Q\x90\x81R\xF3[4a\x19YW` `\x03\x196\x01\x12a\x19YW` a\x126`\x045_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`\x01`@_ \x01T\x90V[4a\x19YW`@`\x03\x196\x01\x12a\x19YWa\"{a%LV[`$5\x80\x15\x15\x81\x03a\x19YWa\"\x8Fa)\xF3V[`\x01`\x01`\xA0\x1B\x03\x82\x16\x91\x82\x15a\x19\xC6W\x82_R`\x08` R`\xFF`@_ T\x16a#.Wa\"\xBD\x90a&\xF3V[\x81_R`\x08` R`@_ `\x01`\xFF\x19\x82T\x16\x17\x90Ua\"\xFFW[\x7F3\x1C\xED\xC7\x1F(\xC4mFv\x91w\x06u\xB5\x86\xE8\xAAw\xA0\xD4\xFE\t\xF2W\xD0\x1E\xF0\x0B\xC1TX_\x80\xA2\0[\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x06T\x16\x17`\x06Ua\"\xD9V[\x7F\x183\xA2K\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x19YW` `\x03\x196\x01\x12a\x19YW`\x01`\x01`\xA0\x1B\x03a#wa%LV[\x16_R`\x08` R` `\xFF`@_ T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x19YW` `\x03\x196\x01\x12a\x19YW`\x045`\x04T\x81\x10\x15a\x19YWa#\xBC` \x91a%bV[\x90T\x90`\x03\x1B\x1C`@Q\x90\x81R\xF3[4a\x19YW`@`\x03\x196\x01\x12a\x19YW`\x045a#\xE7a%6V[\x81_R`\x03` R`\x01`\x01`\xA0\x1B\x03`@_ T\x163\x03a$SW`\x01`\x01`\xA0\x1B\x03\x16\x90\x81_R`\x08` R`\xFF`@_ T\x16\x15a$$W\0[a$-\x81a)\xB5V[\x7F\xEB\xB4\xC5\r\xEB(Q\x92\xD1\xC2\xAA\x882\xB1\xFE\xEB\x07\x8B\xA0\xFD\x92\xBBC\x9C\r\xEE(\xEB\xE9\xBB6\xE9_\x80\xA3\0[\x7F/\xD9\xAD\xAE\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[4a\x19YW` `\x03\x196\x01\x12a\x19YW`\x045\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16\x80\x91\x03a\x19YW\x80\x7Fye\xDB\x0B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x92\x14\x90\x81\x15a$\xF2W[P`@Q\x90\x15\x15\x81R\xF3[\x7F\x01\xFF\xC9\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91P\x14\x82a$\xE7V[4a\x19YW_`\x03\x196\x01\x12a\x19YW` \x90`\nT\x81R\xF3[`$5\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a\x19YWV[`\x045\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a\x19YWV[`\x04T\x81\x10\x15a%zW`\x04_R` _ \x01\x90_\x90V[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[`\x07T\x81\x10\x15a%zW`\x07_R` _ \x01\x90_\x90V[\x80T\x82\x10\x15a%zW_R` _ \x01\x90_\x90V[\x90` \x80\x83Q\x92\x83\x81R\x01\x92\x01\x90_[\x81\x81\x10a%\xF1WPPP\x90V[\x82Q`\x01`\x01`\xA0\x1B\x03\x16\x84R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a%\xE4V[\x90`\x1F`\x1F\x19\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a&3W`@RV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a&3W`\x1F\x01`\x1F\x19\x16` \x01\x90V[`\x03\x19``\x91\x01\x12a\x19YW`\x045\x90`$5`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x19YW\x90`D5`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x19YW\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a&3W`\x05\x1B` \x01\x90V[\x90`\x1F\x19`\x1F` \x80\x94\x80Q\x91\x82\x91\x82\x87R\x01\x86\x86\x01^_\x85\x82\x86\x01\x01R\x01\x16\x01\x01\x90V[`\x07T\x90h\x01\0\0\0\0\0\0\0\0\x82\x10\x15a&3Wa\x03\x19\x82`\x01a'\x1D\x94\x01`\x07U`\x07a%\xBFV[V[\x91\x90\x82\x03\x91\x82\x11a',WV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[\x90a'c\x82a&\xB6V[a'p`@Q\x91\x82a&\x10V[\x82\x81R`\x1F\x19a'\x80\x82\x94a&\xB6V[\x01\x90` 6\x91\x017V[\x80Q\x82\x10\x15a%zW` \x91`\x05\x1B\x01\x01\x90V[_\x19\x81\x14a',W`\x01\x01\x90V[`\x04Th\x01\0\0\0\0\0\0\0\0\x81\x10\x15a&3W\x80`\x01a'\xD2\x92\x01`\x04U`\x04a%\xBFV[_\x19\x82\x93\x92T\x91`\x03\x1B\x92\x83\x1B\x92\x1B\x19\x16\x17\x90UV[`@\x90`\x01`\x01`\xA0\x1B\x03a(\x08\x94\x93\x16\x81R\x81` \x82\x01R\x01\x90a&\xCEV[\x90V[=\x15a(5W=\x90a(\x1C\x82a&`V[\x91a(*`@Q\x93\x84a&\x10V[\x82R=_` \x84\x01>V[``\x90V[a(\x95` a(\x8Da(L_Ta/\x13V[\x82\x80a(Y`\x01Ta/\x13V[`@Q\x95\x84\x87\x95Q\x91\x82\x91\x01\x84\x87\x01^\x84\x01\x90\x82\x82\x01_\x81R\x81Q\x93\x84\x92\x01\x90^\x01\x01_\x81R\x03`\x1F\x19\x81\x01\x83R\x82a&\x10V[\x80Q\x90a0\xEFV[\x90\x15a(\x9EW\x90V[\x7F\x94\xE2s~\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[g\r\xE0\xB6\xB3\xA7d\0\0\x91`@Q\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0` \x83\x01\x93``\x1B\x16\x83R`4\x82\x01R`4\x81Ra)\x14`T\x82a&\x10V[Q\x90 \x06\x90\x81\x15a)!WV[`\x01\x91PV[a\x02ra(\x08`@Qa)=` \x84\x01\x82a&\x10V[\x82\x81R` \x81\x01\x92a2\xFE\x849` `\x01`\x01`\xA0\x1B\x03`\x05T\x16`@Qa)\x86\x81a\x04\x9C\x85\x82\x01\x94\x85`\x01`\x01`\xA0\x1B\x03``\x92\x16\x81R`@` \x82\x01R_`@\x82\x01R\x01\x90V[`@Q\x95\x86\x94Q\x80\x91\x85\x87\x01^\x84\x01\x90\x83\x82\x01\x90_\x82RQ\x92\x83\x91^\x01\x01_\x81R\x03`\x1F\x19\x81\x01\x83R\x82a&\x10V[\x80_R`\t` R`\xFF`@_ T\x16\x15a)\xCDWPV[_R`\t` R`@_ `\x01`\xFF\x19\x82T\x16\x17\x90Ua)\xEE`\nTa'\x9EV[`\nUV[3_\x90\x81R\x7F\xB7\xDB-\xD0\x8F\xCBb\xD0\xC9\xE0\x8CQ\x94\x1C\xAES\xC2gxj\x0Bu\x80?\xB7\x96\t\x02\xFC\x8E\xF9}` R`@\x90 T`\xFF\x16\x15a*+WV[\x7F\xE2Q}?\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R3`\x04R_`$R`D_\xFD[\x80_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`@_ `\x01`\x01`\xA0\x1B\x033\x16_R` R`\xFF`@_ T\x16\x15a*\xA5WPV[\x7F\xE2Q}?\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R3`\x04R`$R`D_\xFD[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R\x7F\xB7\xDB-\xD0\x8F\xCBb\xD0\xC9\xE0\x8CQ\x94\x1C\xAES\xC2gxj\x0Bu\x80?\xB7\x96\t\x02\xFC\x8E\xF9}` R`@\x90 T`\xFF\x16a+~W`\x01`\x01`\xA0\x1B\x03\x16_\x81\x81R\x7F\xB7\xDB-\xD0\x8F\xCBb\xD0\xC9\xE0\x8CQ\x94\x1C\xAES\xC2gxj\x0Bu\x80?\xB7\x96\t\x02\xFC\x8E\xF9}` R`@\x81 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x91\x90\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x81\x80\xA4`\x01\x90V[P_\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R\x7F\x06HL\xC5\x9D\xC3\x8EOg\xC3\x11\"3:\x17\xCA\x81\xB3\xCA\x18\xCD\xF0+\xFC)\x80r\xFAR\xB01j` R`@\x90 T`\xFF\x16a+~W`\x01`\x01`\xA0\x1B\x03\x16_\x81\x81R\x7F\x06HL\xC5\x9D\xC3\x8EOg\xC3\x11\"3:\x17\xCA\x81\xB3\xCA\x18\xCD\xF0+\xFC)\x80r\xFAR\xB01j` R`@\x81 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x91\x90\x7F$\x1E\xCF\x16\xD7\x9D\x0F\x8D\xBF\xB9,\xBC\x07\xFE\x17\x84\x04%\x97l\xF0f\x7F\x02/\xE9\x87|\xAA\x83\x1B\x08\x90\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x90\x80\xA4`\x01\x90V[\x80_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`@_ `\x01`\x01`\xA0\x1B\x03\x83\x16_R` R`\xFF`@_ T\x16\x15_\x14a-\x16W\x80_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`@_ `\x01`\x01`\xA0\x1B\x03\x83\x16_R` R`@_ `\x01`\xFF\x19\x82T\x16\x17\x90U`\x01`\x01`\xA0\x1B\x033\x92\x16\x90\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r_\x80\xA4`\x01\x90V[PP_\x90V[\x80_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`@_ `\x01`\x01`\xA0\x1B\x03\x83\x16_R` R`\xFF`@_ T\x16_\x14a-\x16W\x80_R\x7F\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0` R`@_ `\x01`\x01`\xA0\x1B\x03\x83\x16_R` R`@_ `\xFF\x19\x81T\x16\x90U`\x01`\x01`\xA0\x1B\x033\x92\x16\x90\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B_\x80\xA4`\x01\x90V[`\xFF\x7F\xCD^\xD1\\n\x18~w\xE9\xAE\xE8\x81\x84\xC2\x1FO!\x82\xABX'\xCB;~\x07\xFB\xED\xCDc\xF03\0T\x16a.\nWV[\x7F\xD9<\x06e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90\x80Q\x15a.\x86W` \x81Q\x91\x01_\xF5\x90=\x15\x19\x82\x15\x16a\x19NW`\x01`\x01`\xA0\x1B\x03\x82\x16\x15a.^WV[\x7F\xB0n\xBF=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7FL\xA2I\xDC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x15a.\xB5WV[`d`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7Fnamespace collision detected\0\0\0\0`D\x82\x01R\xFD[\x80_\x91z\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x82\x10\x15a0pW[\x80m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0`\n\x92\x10\x15a0UW[f#\x86\xF2o\xC1\0\0\x81\x10\x15a0AW[c\x05\xF5\xE1\0\x81\x10\x15a00W[a'\x10\x81\x10\x15a0!W[`d\x81\x10\x15a0\x13W[\x10\x15a0\x08W[`\n_\x19`!`\x01\x85\x01\x94`\x1F\x19a/\xBDa/\xA7\x88a&`V[\x97a/\xB5`@Q\x99\x8Aa&\x10V[\x80\x89Ra&`V[\x016` \x88\x017\x85\x01\x01[\x01\x91\x7F0123456789abcdef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x82\x06\x1A\x83S\x04\x80\x15a0\x03W_\x19`\n\x91\x92a/\xC8V[PP\x90V[`\x01\x90\x91\x01\x90a/\x8DV[`d`\x02\x91\x04\x93\x01\x92a/\x86V[a'\x10`\x04\x91\x04\x93\x01\x92a/|V[c\x05\xF5\xE1\0`\x08\x91\x04\x93\x01\x92a/qV[f#\x86\xF2o\xC1\0\0`\x10\x91\x04\x93\x01\x92a/dV[m\x04\xEE-mA[\x85\xAC\xEF\x81\0\0\0\0` \x91\x04\x93\x01\x92a/TV[P`@\x91Pz\x18O\x03\xE9?\xF9\xF4\xDA\xA7\x97\xEDn8\xEDd\xBFj\x1F\x01\0\0\0\0\0\0\0\0\x81\x04a/:V[`\xFF\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T`@\x1C\x16\x15a0\xC7WV[\x7F\xD7\xE6\xBC\xF8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90\x81Q\x81\x11\x80\x15a1\x15W[a1\rW_a1\t\x92a1\xA8V[\x90\x91V[PP_\x90_\x90V[P_a0\xFBV[\x90a1YWP\x80Q\x15a11W\x80Q\x90` \x01\xFD[\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x81Q\x15\x80a1\x9FW[a1jWP\x90V[`\x01`\x01`\xA0\x1B\x03\x90\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R\x16`\x04R`$_\xFD[P\x80;\x15a1bV[_\x93\x92\x90[\x81\x83\x10a1\xBDWPPP`\x01\x91\x90V[\x90\x92\x91\x93`\xFFa1\xF4\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x88\x86\x01\x01Q\x16a21V[\x16`\t\x81\x11a2&W`\n\x82\x02\x91\x80\x83\x04`\n\x14\x90\x15\x17\x15a',W\x81\x01\x80\x91\x11a',W`\x01\x90\x94\x01\x91\x92\x90a1\xADV[P_\x94P\x84\x93PPPV[`\xF8\x1C`/\x81\x11\x80a2\xF3W[\x15a2kW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xD0\x01`\xFF\x16\x90V[``\x81\x11\x80a2\xE9W[\x15a2\xA2W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xA9\x01`\xFF\x16\x90V[`@\x81\x11\x80a2\xDFW[\x15a2\xD9W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC9\x01`\xFF\x16\x90V[P`\xFF\x90V[P`G\x81\x10a2\xACV[P`g\x81\x10a2uV[P`:\x81\x10a2>V\xFE`\x80`@Ra\x02r\x808\x03\x80a\0\x14\x81a\x01hV[\x92\x839\x81\x01`@\x82\x82\x03\x12a\x01dW\x81Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x92\x90\x91\x90\x83\x83\x03a\x01dW` \x81\x01Q\x90`\x01`\x01`@\x1B\x03\x82\x11a\x01dW\x01\x92\x81`\x1F\x85\x01\x12\x15a\x01dW\x83Qa\0na\0i\x82a\x01\xA1V[a\x01hV[\x94\x81\x86R` \x86\x01\x93` \x83\x83\x01\x01\x11a\x01dW\x81_\x92` \x80\x93\x01\x86^\x86\x01\x01R\x82;\x15a\x01RW\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x82\x17\x90U\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;_\x80\xA2\x82Q\x15a\x01:W_\x80\x91a\x01\"\x94Q\x90\x84Z\xF4=\x15a\x012W=\x91a\x01\x13a\0i\x84a\x01\xA1V[\x92\x83R=_` \x85\x01>a\x01\xBCV[P[`@Q`W\x90\x81a\x02\x1B\x829\xF3[``\x91a\x01\xBCV[PPP4\x15a\x01$Wc\xB3\x98\x97\x9F`\xE0\x1B_R`\x04_\xFD[cL\x9C\x8C\xE3`\xE0\x1B_R`\x04R`$_\xFD[_\x80\xFD[`@Q\x91\x90`\x1F\x01`\x1F\x19\x16\x82\x01`\x01`\x01`@\x1B\x03\x81\x11\x83\x82\x10\x17a\x01\x8DW`@RV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`\x01`\x01`@\x1B\x03\x81\x11a\x01\x8DW`\x1F\x01`\x1F\x19\x16` \x01\x90V[\x90a\x01\xE0WP\x80Q\x15a\x01\xD1W\x80Q\x90` \x01\xFD[c\xD6\xBD\xA2u`\xE0\x1B_R`\x04_\xFD[\x81Q\x15\x80a\x02\x11W[a\x01\xF1WP\x90V[c\x99\x96\xB3\x15`\xE0\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16`\x04R`$\x90\xFD[P\x80;\x15a\x01\xE9V\xFE`\x80`@R_\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCT\x166\x82\x807\x816\x91Z\xF4=_\x80>\x15`SW=_\xF3[=_\xFD`\xA0\x80`@R4`)W0`\x80Ra\x07\x07\x90\x81a\0.\x829`\x80Q\x81\x81\x81a\x01\xF0\x01Ra\x03)\x01R\xF3[_\x80\xFD\xFE`\x80`@R`\x046\x10\x15a\0\xD0W[6\x15a\0rW`d`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FStub: no logic implemented\0\0\0\0\0\0`D\x82\x01R\xFD[`d`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FStub: ETH not accepted\0\0\0\0\0\0\0\0\0\0`D\x82\x01R\xFD[_5`\xE0\x1C\x80cO\x1E\xF2\x86\x14a\x02hW\x80cR\xD1\x90-\x14a\x01\xABWc\xAD<\xB1\xCC\x03a\0\x0EW4a\x01\xA7W_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x01\xA7W`@\x80Q\x90a\x012\x81\x83a\x05\xC6V[`\x05\x82R` \x82\x01\x91\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83R\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F\x83Q\x94\x85\x93` \x85RQ\x80\x91\x81` \x87\x01R\x86\x86\x01^_\x85\x82\x86\x01\x01R\x01\x16\x81\x01\x03\x01\x90\xF3[_\x80\xFD[4a\x01\xA7W_\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x01\xA7Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x160\x03a\x02@W` `@Q\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x81R\xF3[\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFC6\x01\x12a\x01\xA7W`\x045s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x90\x81\x81\x03a\x01\xA7W`$5\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x01\xA7W6`#\x83\x01\x12\x15a\x01\xA7W\x81`\x04\x015\x91a\x02\xE1\x83a\x064V[\x92a\x02\xEF`@Q\x94\x85a\x05\xC6V[\x80\x84R` \x84\x01\x916`$\x83\x83\x01\x01\x11a\x01\xA7W\x81_\x92`$` \x93\x01\x857\x85\x01\x01Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x800\x14\x90\x81\x15a\x05\x84W[Pa\x02@W`@Q\x7FR\xD1\x90-\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x81`\x04\x81\x88Z\xFA_\x91\x81a\x05PW[Pa\x03\xC1W\x84\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x80\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x86\x92\x03a\x05%WP\x82;\x15a\x04\xFAW\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCT\x16\x17\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCU\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;_\x80\xA2\x82Q\x15a\x04\xC8W_\x80\x91a\x04\xBE\x94Q\x90\x84Z\xF4=\x15a\x04\xC0W=\x91a\x04\xA2\x83a\x064V[\x92a\x04\xB0`@Q\x94\x85a\x05\xC6V[\x83R=_` \x85\x01>a\x06nV[\0[``\x91a\x06nV[PPP4a\x04\xD2W\0[\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04R`$_\xFD[\x90\x91P` \x81=` \x11a\x05|W[\x81a\x05l` \x93\x83a\x05\xC6V[\x81\x01\x03\x12a\x01\xA7WQ\x90\x86a\x03\x90V[=\x91Pa\x05_V[\x90Ps\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCT\x16\x14\x15\x85a\x03TV[\x90`\x1F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x06\x07W`@RV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x06\x07W`\x1F\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x16` \x01\x90V[\x90a\x06\xABWP\x80Q\x15a\x06\x83W\x80Q\x90` \x01\xFD[\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x81Q\x15\x80a\x06\xFEW[a\x06\xBCWP\x90V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R\x16`\x04R`$_\xFD[P\x80;\x15a\x06\xB4V`\xA0\x80`@R4a\0\xC2W0`\x80R_Q` a!\xC4_9_Q\x90_RT`\xFF\x81`@\x1C\x16a\0\xB3W`\x02`\x01`@\x1B\x03\x19`\x01`\x01`@\x1B\x03\x82\x16\x01a\0`W[`@Qa \xFD\x90\x81a\0\xC7\x829`\x80Q\x81\x81\x81a\x0B\xF7\x01Ra\x0C\xBC\x01R\xF3[`\x01`\x01`@\x1B\x03\x19\x16`\x01`\x01`@\x1B\x03\x90\x81\x17_Q` a!\xC4_9_Q\x90_RU\x81R\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x90` \x90\xA1_\x80a\0AV[c\xF9.\xE8\xA9`\xE0\x1B_R`\x04_\xFD[_\x80\xFD\xFE`\x80\x80`@R`\x046\x10\x15a\0\x12W_\x80\xFD[_\x90_5`\xE0\x1C\x90\x81c\x01u\xE2;\x14a\x16\xD6WP\x80c\x0Cg#c\x14a\x16\x8DW\x80c\x17\x94\xBB<\x14a\x12\xF6W\x80c$\x07\xF0\xB6\x14a\x12\xBCW\x80c9i\x8A\xC0\x14a\x11\xA9W\x80cF\xE2\xCC\t\x14a\x11\x90W\x80cO\x1E\xF2\x86\x14a\x0CoW\x80cR\xD1\x90-\x14a\x0B\xCFW\x80cTg\xCBH\x14a\x0B\x1CW\x80c[<\xD6\xE2\x14a\n\xC9W\x80c^z{\xDF\x14a\nvW\x80cqP\x18\xA6\x14a\t\xB8W\x80cx\x1C\xD9\x9D\x14a\t\x99W\x80cz9y\xDC\x14a\t>W\x80cz\x8DA\xC2\x14a\x08\x8DW\x80c\x84\xFA\xB6+\x14a\x08KW\x80c\x85\x07I%\x14a\x08\x1CW\x80c\x8D\xA5\xCB[\x14a\x07\xC9W\x80c\x95\xC5\xBFu\x14a\x07\x8EW\x80c\xA7\x0B\x9F\x0C\x14a\x07pW\x80c\xAD<\xB1\xCC\x14a\x07\x0BW\x80c\xB3\xC6P\x15\x14a\x06\xC4W\x80c\xB9Vov\x14a\x06\x7FW\x80c\xB9}\xD9\xE2\x14a\x06\\W\x80c\xB9\xF7\xF2`\x14a\x06!W\x80c\xC4Z\x01U\x14a\x05\xCEW\x80c\xCD\xAF\xB9x\x14a\x05lW\x80c\xD4\xF0\xEBM\x14a\x04\xA5W\x80c\xD5\x17m#\x14a\x04\x02W\x80c\xD8x\x13B\x14a\x03\xC5W\x80c\xDE\x1FE>\x14a\x03\xA4W\x80c\xE09af\x14a\x03ZW\x80c\xE8\xEB\x1D\xC3\x14a\x03<W\x80c\xF2\xFD\xE3\x8B\x14a\x02PWc\xF9X\xCB\xA2\x14a\x01\x9FW_\x80\xFD[4a\x02MW` `\x03\x196\x01\x12a\x02MW`\x045\x80\x15\x15\x80\x91\x03a\x02KWa\x01\xC5a\x1EQV[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFt\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\x02T\x92`\xA0\x1B\x16\x91\x16\x17\x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\x02U\x80\xF3[P[\x80\xFD[P4a\x02MW` `\x03\x196\x01\x12a\x02MWa\x02\xC0a\x02ma\x17\x9FV[a\x02ua\x1EQV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\x01T\x16\x15a\x02\xC3W[a\x02\xBBa\x1EQV[a\x1F V[\x80\xF3[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0T\x16s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x90\x7F\x16\xAE1yaZ(\x15X;ef\xEA\xE6\xF7\x83\xB2T\x19E,\0Y\x9A\xEE\xB0\x10\x88\xF1>\xCA\x1A\x85\x80\xA3a\x02\xB3V[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` `@Qb\x03\r@\x81R\xF3[P4a\x02MW` `\x03\x196\x01\x12a\x02MW`\x045_R\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\x01` R` `@_ T`@Q\x90\x81R\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MWa\x03\xBDa\x1EQV[a\x02\xC0a\x1D\xB1V[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` \x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\0T`@Q\x90\x81R\xF3[P4a\x02MW` `\x03\x196\x01\x12a\x02MW`\x045b'\x8D\0\x81\x02\x90\x80\x82\x04b'\x8D\0\x14\x90\x15\x17\x15a\x04xWch\x8DF\xF0\x01\x90\x81ch\x8DF\xF0\x11a\x04KW` \x82`@Q\x90\x81R\xF3[\x80\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`$\x92R`\x11`\x04R\xFD[`$\x82\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x11`\x04R\xFD[P4a\x02MW` `\x03\x196\x01\x12a\x02MWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFa\x04\xD4a\x17\x9FV[a\x04\xDCa\x1EQV[\x16\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F\\m\x17t\xBD\xD6\x9D\x8D\x16\x84|<\x97\xB5\x1E\xA742W\xB8\xF5\xAC\xE5\xDA\x9E%\xAB;\xAF\xD7\xD5\0T\x16\x17\x7F\\m\x17t\xBD\xD6\x9D\x8D\x16\x84|<\x97\xB5\x1E\xA742W\xB8\xF5\xAC\xE5\xDA\x9E%\xAB;\xAF\xD7\xD5\0U\x7F%5\x80\xF8\x06t\x1C\x11\xB3\xD4\xAA`\xD9\xCA\xCC[\xEF\x0C\xEB\xB3WHv\x7F\xE2?\x11\x91n/\x04\xB9\x82\x80\xA2\x80\xF3[P4a\x02MW` `\x03\x196\x01\x12a\x02MW`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02KW6`#\x82\x01\x12\x15a\x02KW\x80`\x04\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x05\xCAW6`$\x82`\x05\x1B\x84\x01\x01\x11a\x05\xCAW`$a\x02\xC0\x92\x01a\x1CRV[\x82\x80\xFD[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\x02T\x16`@Q\x90\x81R\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` `@Q\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\0\x81R\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` a\x06wa\x1C\x14V[`@Q\x90\x81R\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` `\xFF\x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\x02T`\xA0\x1C\x16`@Q\x90\x15\x15\x81R\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T\x16`@Q\x90\x81R\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MWPa\x07l`@Qa\x07.`@\x82a\x186V[`\x05\x81R\x7F5.0.0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01R`@Q\x91\x82\x91` \x83R` \x83\x01\x90a\x19$V[\x03\x90\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` `@Qb'\x8D\0\x81R\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` `@Q\x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\0\x81R\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0T\x16`@Q\x90\x81R\xF3[P4a\x02MWa\x07la\x087a\x0816a\x17\xE5V[\x90a\x1B\xA6V[`@Q\x91\x82\x91` \x83R` \x83\x01\x90a\x19$V[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` `\xFF\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\0T\x16`@Q\x90\x15\x15\x81R\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MWP\x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\x01Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80a\t6WP` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0T\x16[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@Q\x91\x16\x81R\xF3[` \x90a\t\x18V[P4a\x02MW```\x03\x196\x01\x12a\x02MWa\tXa\x17\x9FV[\x90a\taa\x17\xC2V[\x90`D5\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x02MW` a\t\x8F\x85\x85a\t\x896`\x04\x88\x01a\x18\xDEV[\x91a\x1AuV[`@Q\x90\x15\x15\x81R\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` `@Qch\x8DF\xF0\x81R\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MWa\t\xD1a\x1EQV[\x80s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0U\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x82\x80\xA3\x80\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\x01T\x16`@Q\x90\x81R\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MW` s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\\m\x17t\xBD\xD6\x9D\x8D\x16\x84|<\x97\xB5\x1E\xA742W\xB8\xF5\xAC\xE5\xDA\x9E%\xAB;\xAF\xD7\xD5\0T\x16`@Q\x90\x81R\xF3[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MWa\x0B5a\x1EQV[\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\0T`\xFF\x81\x16\x15a\x0B\xA7W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x16\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\0U\x80\xF3[`\x04\x82\x7F\xCD`\xC3\xCA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xFD[P4a\x02MW\x80`\x03\x196\x01\x12a\x02MWs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x160\x03a\x0CGW` `@Q\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x81R\xF3[\x80\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x04\x92R\xFD[P`@`\x03\x196\x01\x12a\x10^Wa\x0C\x84a\x17\x9FV[\x90`$5g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x10^Wa\x0C\xA5\x906\x90`\x04\x01a\x18\xDEV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x800\x14\x90\x81\x15a\x11NW[Pa\x11&Wa\x0C\xF4a\x1EQV[\x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\x02T\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16`@Q\x92\x7F\rKK\xDA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84Rs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x86\x16\x93\x84`\x04\x82\x01R` \x81`$\x81\x86Z\xFA\x90\x81\x15a\x10SW_\x91a\x10\xF7W[P\x15a\x10bW[P\x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\0T\x81;\x15a\x10^W_\x91`D\x83\x92`@Q\x94\x85\x93\x84\x92\x7F\x07\xA9\xBE\xE7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84R`\x04\x84\x01R\x88`$\x84\x01RZ\xF1\x80\x15a\x10SWa\x10>W[P`@Q\x93\x7FR\xD1\x90-\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85R` \x85`\x04\x81\x86Z\xFA\x80\x95\x85\x96a\x10\x06W[Pa\x0EoW`$\x84\x84\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82R`\x04R\xFD[\x90\x91\x84\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x81\x03a\x0F\xDBWP\x81;\x15a\x0F\xB0W\x80\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCT\x16\x17\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCU\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;\x84\x80\xA2\x81Q\x83\x90\x15a\x0F}W\x80\x83` a\x0Fq\x95Q\x91\x01\x84Z\xF4=\x15a\x0FuW=\x91a\x0FU\x83a\x18\xA4V[\x92a\x0Fc`@Q\x94\x85a\x186V[\x83R=\x85` \x85\x01>a dV[P\x80\xF3[``\x91a dV[PPP4a\x0F\x88W\x80\xF3[\x80\x7F\xB3\x98\x97\x9F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x04\x92R\xFD[\x7FL\x9C\x8C\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84R`\x04R`$\x83\xFD[\x7F\xAA\x1DI\xA4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85R`\x04R`$\x84\xFD[\x90\x95P` \x81=` \x11a\x106W[\x81a\x10\"` \x93\x83a\x186V[\x81\x01\x03\x12a\x102WQ\x94_a\x0E>V[\x84\x80\xFD[=\x91Pa\x10\x15V[a\x10K\x91\x93P_\x90a\x186V[_\x91_a\x0E\x04V[`@Q=_\x82>=\x90\xFD[_\x80\xFD[`\xA0\x1C`\xFF\x16\x15a\x10sW_a\r\x91V[`\x84`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`(`$\x82\x01R\x7FUpgrade would result in gas trac`D\x82\x01R\x7Fking ban\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R\xFD[a\x11\x19\x91P` =` \x11a\x11\x1FW[a\x11\x11\x81\x83a\x186V[\x81\x01\x90a\x1A]V[_a\r\x8AV[P=a\x11\x07V[\x7F\xE0|\x8D\xBA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90Ps\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBCT\x16\x14\x15_a\x0C\xE7V[4a\x10^Wa\x11\xA7a\x11\xA16a\x17\xE5V[\x90a\x19gV[\0[4a\x10^W` `\x03\x196\x01\x12a\x10^Wa\x11\xC2a\x17\x9FV[a\x11\xCAa\x1EQV[\x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\x01\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92\x83\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x81\x17\x90\x92U\x90\x91\x16\x81\x15a\x12\\W\x7F\x16\xAE1yaZ(\x15X;ef\xEA\xE6\xF7\x83\xB2T\x19E,\0Y\x9A\xEE\xB0\x10\x88\xF1>\xCA\x1A_\x80\xA3\0[\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x91P\x7F\x16\xAE1yaZ(\x15X;ef\xEA\xE6\xF7\x83\xB2T\x19E,\0Y\x9A\xEE\xB0\x10\x88\xF1>\xCA\x1A_\x80\xA3\0[4a\x10^W_`\x03\x196\x01\x12a\x10^W` `@Q\x7F\\m\x17t\xBD\xD6\x9D\x8D\x16\x84|<\x97\xB5\x1E\xA742W\xB8\xF5\xAC\xE5\xDA\x9E%\xAB;\xAF\xD7\xD5\0\x81R\xF3[4a\x10^W```\x03\x196\x01\x12a\x10^Wa\x13\x0Fa\x17\x9FV[a\x13\x17a\x17\xC2V[\x90`D5\x90\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T\x92`\xFF\x84`@\x1C\x16\x15\x93g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x80\x15\x90\x81a\x16\x85W[`\x01\x14\x90\x81a\x16{W[\x15\x90\x81a\x16rW[Pa\x16JW\x84`\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\x83\x16\x17\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0Ua\x15\xF5W[P\x82\x15a\x15\x97Wa\x13\xF9s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92a\x13\xE9a \rV[a\x13\xF1a \rV[a\x02\xBBa \rV[\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F\\m\x17t\xBD\xD6\x9D\x8D\x16\x84|<\x97\xB5\x1E\xA742W\xB8\xF5\xAC\xE5\xDA\x9E%\xAB;\xAF\xD7\xD5\0T\x16\x17\x7F\\m\x17t\xBD\xD6\x9D\x8D\x16\x84|<\x97\xB5\x1E\xA742W\xB8\xF5\xAC\xE5\xDA\x9E%\xAB;\xAF\xD7\xD5\0Ua\x14ia \rV[a\x14qa\x1D\xB1V[\x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\0U\x7F\xC5A\xA3a;\xD2*\x8D\xA1\xC8\x97e\x8E\x95\xC4.k\xB9\x15\x8C\x83\xD6*\xC9cdk\xA2r\0\xA4\x02\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x163\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x17\x90Ua\x15\x04W\0[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T\x16\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0U\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2` `@Q`\x01\x81R\xA1\0[`d`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x18`$\x82\x01R\x7FApp chain ID cannot be 0\0\0\0\0\0\0\0\0`D\x82\x01R\xFD[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\x16h\x01\0\0\0\0\0\0\0\x01\x17\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0U\x84a\x13\xC1V[\x7F\xF9.\xE8\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90P\x15\x86a\x13nV[0;\x15\x91Pa\x13fV[\x86\x91Pa\x13\\V[4a\x10^W` `\x03\x196\x01\x12a\x10^W`\x045_R\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\x01` R` `@_ T`@Q\x90\x81R\xF3[4a\x10^W` `\x03\x196\x01\x12a\x10^W`\x045\x80\x15a\x17wW\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x01\x90\x81\x11a\x17JWb'\x8D\0\x81\x02\x90\x80\x82\x04b'\x8D\0\x14\x90\x15\x17\x15a\x17JWch\x8DF\xF0\x01\x90\x81ch\x8DF\xF0\x11a\x17JW` \x91\x81R\xF3[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[\x7F\xD6\x93h\xD4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[`\x045\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x10^WV[`$5\x90s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x82\x03a\x10^WV[\x90` `\x03\x19\x83\x01\x12a\x10^W`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x10^W\x82`#\x82\x01\x12\x15a\x10^W\x80`\x04\x015\x92g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x11a\x10^W`$\x84\x83\x01\x01\x11a\x10^W`$\x01\x91\x90V[\x90`\x1F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x18wW`@RV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x18wW`\x1F\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x16` \x01\x90V[\x81`\x1F\x82\x01\x12\x15a\x10^W\x805\x90a\x18\xF5\x82a\x18\xA4V[\x92a\x19\x03`@Q\x94\x85a\x186V[\x82\x84R` \x83\x83\x01\x01\x11a\x10^W\x81_\x92` \x80\x93\x01\x83\x86\x017\x83\x01\x01R\x90V[\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F` \x80\x94\x80Q\x91\x82\x91\x82\x87R\x01\x86\x86\x01^_\x85\x82\x86\x01\x01R\x01\x16\x01\x01\x90V[\x90`\xFF\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\0T\x16\x15a\x19\xABW\x90a\x19\xA1a\x19\xA9\x92Z\x92a\x19\xB0V[Z\x90\x03a\x1E\xBDV[V[a\x19\xA9\x91[\x90\x80\x15a\x1A5Wa\x19\xC0\x91a\x1B\xA6V[a\x19\xCB\x8123a\x1AuV[\x15a\x1A\rW\x7F\x836;x\xBD\xFB\xB2>*a\xDBz\xCC\xC3\xC0\x1F\xDA)\xC5\xC5\xEC\x81\x88\x80\x03\xCB\x96)\x12a\x8A\x7F`@Q` \x81R\x80a\x1A\x083\x94` \x83\x01\x90a\x19$V[\x03\x90\xA2V[\x7F\xDCt\x14X\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x7F\xDC7\xF5\x1D\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90\x81` \x91\x03\x12a\x10^WQ\x80\x15\x15\x81\x03a\x10^W\x90V[\x91\x90\x81Qb\x03\r@\x81\x11a\x1BtWPs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\\m\x17t\xBD\xD6\x9D\x8D\x16\x84|<\x97\xB5\x1E\xA742W\xB8\xF5\xAC\xE5\xDA\x9E%\xAB;\xAF\xD7\xD5\0T\x16`\x01\x81\x14\x92\x83\x15a\x1A\xD0W[PPP\x90P\x90V[` \x93Ps\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x94a\x1B9\x86\x92`@Q\x97\x88\x96\x87\x95\x86\x95\x7Fz9y\xDC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x87R\x16`\x04\x86\x01R\x16`$\x84\x01R```D\x84\x01R`d\x83\x01\x90a\x19$V[\x03\x91Z\xFA\x90\x81\x15a\x10SW_\x91a\x1BUW[P\x80_\x80\x80a\x1A\xC8V[a\x1Bn\x91P` =` \x11a\x11\x1FWa\x11\x11\x81\x83a\x186V[_a\x1BKV[\x7FF4i\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04Rb\x03\r@`$R`D_\xFD[`!a\x1C\x11\x91\x83`@Q\x94\x85\x92\x7F\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x85\x01R\x84\x84\x017\x81\x01_\x83\x82\x01R\x03\x01\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x81\x01\x83R\x82a\x186V[\x90V[\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x97r\xB9\x10B\x01B\x81\x11a\x17JWb'\x8D\0\x90\x04`\x01\x81\x01\x80\x91\x11a\x17JW\x90V[\x90`\xFF\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\0T\x16\x15a\x1C\x8CW\x90a\x19\xA1a\x19\xA9\x92Z\x92a\x1D\"V[a\x19\xA9\x91a\x1D\"V[\x91\x90\x81\x10\x15a\x1C\xF5W`\x05\x1B\x81\x015\x90\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE1\x816\x03\x01\x82\x12\x15a\x10^W\x01\x90\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x10^W` \x01\x826\x03\x81\x13a\x10^W\x91\x90V[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[\x81\x15a\x1A5W_[\x82\x81\x10a\x1D6WPPPV[a\x1DA\x81\x84\x84a\x1C\x95V[\x90P\x15a\x1A5W\x80a\x1DYa\x081`\x01\x93\x86\x86a\x1C\x95V[a\x1Dd\x8123a\x1AuV[a\x1DpW[P\x01a\x1D*V[\x7F\x836;x\xBD\xFB\xB2>*a\xDBz\xCC\xC3\xC0\x1F\xDA)\xC5\xC5\xEC\x81\x88\x80\x03\xCB\x96)\x12a\x8A\x7F`@Q` \x81R\x80a\x1D\xA83\x94` \x83\x01\x90a\x19$V[\x03\x90\xA2_a\x1DiV[\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\0T`\x01`\xFF\x82\x16\x15\x15\x14a\x1E)W\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x16`\x01\x17\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\0UV[\x7Fvy@\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0T\x163\x03a\x1E\x91WV[\x7F\x11\x8C\xDA\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R3`\x04R`$_\xFD[a\x1E\xC5a\x1C\x14V[:\x91:\x15a\x1F\x17W[\x82\x81\x02\x92\x81\x84\x04\x14\x90\x15\x17\x15a\x17JW_R\x7F\x11\x94\x94\xE4|$&\xA6\x07/\xC6\x07.\xC5\xC5\xD5\xAE\x86Z3r\xFD\x10,d<\x18\xE9x\xB1H\x01` R`@_ \x80T\x91\x82\x01\x80\x92\x11a\x17JWUV[`\x01\x92Pa\x1E\xCEV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x80\x15a\x1F\xE1Ws\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0T\x82\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x16\x17\x7F\x90\x16\xD0\x9Dr\xD4\x0F\xDA\xE2\xFD\x8C\xEA\xC6\xB6#Lw\x06!O\xD3\x9C\x1C\xD1\xE6\t\xA0R\x8C\x19\x93\0U\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0_\x80\xA3V[\x7F\x1EO\xBD\xF7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R_`\x04R`$_\xFD[`\xFF\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T`@\x1C\x16\x15a <WV[\x7F\xD7\xE6\xBC\xF8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x90a \xA1WP\x80Q\x15a yW\x80Q\x90` \x01\xFD[\x7F\xD6\xBD\xA2u\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x04_\xFD[\x81Q\x15\x80a \xF4W[a \xB2WP\x90V[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x7F\x99\x96\xB3\x15\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R\x16`\x04R`$_\xFD[P\x80;\x15a \xAAV\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NamespaceState(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<NamespaceState> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl NamespaceState {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<u8> for NamespaceState {
            fn from(value: u8) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<NamespaceState> for u8 {
            fn from(value: NamespaceState) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for NamespaceState {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for NamespaceState {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AccessControlBadConfirmation()` and selector `0x6697b232`.
```solidity
error AccessControlBadConfirmation();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlBadConfirmation;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlBadConfirmation>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlBadConfirmation) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlBadConfirmation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlBadConfirmation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlBadConfirmation()";
            const SELECTOR: [u8; 4] = [102u8, 151u8, 178u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AccessControlUnauthorizedAccount(address,bytes32)` and selector `0xe2517d3f`.
```solidity
error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub neededRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlUnauthorizedAccount) -> Self {
                (value.account, value.neededRole)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    neededRole: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlUnauthorizedAccount(address,bytes32)";
            const SELECTOR: [u8; 4] = [226u8, 81u8, 125u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.neededRole),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AddressEmptyCode(address)` and selector `0x9996b315`.
```solidity
error AddressEmptyCode(address target);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AddressEmptyCode {
        #[allow(missing_docs)]
        pub target: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AddressEmptyCode> for UnderlyingRustTuple<'_> {
            fn from(value: AddressEmptyCode) -> Self {
                (value.target,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AddressEmptyCode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { target: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AddressEmptyCode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AddressEmptyCode(address)";
            const SELECTOR: [u8; 4] = [153u8, 150u8, 179u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `CannotRemoveDefaultImplementation()` and selector `0xd5cc4a0f`.
```solidity
error CannotRemoveDefaultImplementation();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CannotRemoveDefaultImplementation;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CannotRemoveDefaultImplementation>
        for UnderlyingRustTuple<'_> {
            fn from(value: CannotRemoveDefaultImplementation) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for CannotRemoveDefaultImplementation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CannotRemoveDefaultImplementation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CannotRemoveDefaultImplementation()";
            const SELECTOR: [u8; 4] = [213u8, 204u8, 74u8, 15u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ChainIdAlreadyExists()` and selector `0x24591d89`.
```solidity
error ChainIdAlreadyExists();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ChainIdAlreadyExists;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ChainIdAlreadyExists> for UnderlyingRustTuple<'_> {
            fn from(value: ChainIdAlreadyExists) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ChainIdAlreadyExists {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ChainIdAlreadyExists {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ChainIdAlreadyExists()";
            const SELECTOR: [u8; 4] = [36u8, 89u8, 29u8, 137u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `Create2EmptyBytecode()` and selector `0x4ca249dc`.
```solidity
error Create2EmptyBytecode();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Create2EmptyBytecode;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Create2EmptyBytecode> for UnderlyingRustTuple<'_> {
            fn from(value: Create2EmptyBytecode) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Create2EmptyBytecode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for Create2EmptyBytecode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "Create2EmptyBytecode()";
            const SELECTOR: [u8; 4] = [76u8, 162u8, 73u8, 220u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ERC1967InvalidImplementation(address)` and selector `0x4c9c8ce3`.
```solidity
error ERC1967InvalidImplementation(address implementation);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967InvalidImplementation {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967InvalidImplementation>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967InvalidImplementation) -> Self {
                (value.implementation,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC1967InvalidImplementation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { implementation: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967InvalidImplementation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967InvalidImplementation(address)";
            const SELECTOR: [u8; 4] = [76u8, 156u8, 140u8, 227u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.implementation,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ERC1967NonPayable()` and selector `0xb398979f`.
```solidity
error ERC1967NonPayable();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967NonPayable;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967NonPayable> for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967NonPayable) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC1967NonPayable {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967NonPayable {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967NonPayable()";
            const SELECTOR: [u8; 4] = [179u8, 152u8, 151u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `EnforcedPause()` and selector `0xd93c0665`.
```solidity
error EnforcedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EnforcedPause;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EnforcedPause> for UnderlyingRustTuple<'_> {
            fn from(value: EnforcedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EnforcedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EnforcedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EnforcedPause()";
            const SELECTOR: [u8; 4] = [217u8, 60u8, 6u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ExpectedPause()` and selector `0x8dfc202b`.
```solidity
error ExpectedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExpectedPause;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExpectedPause> for UnderlyingRustTuple<'_> {
            fn from(value: ExpectedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ExpectedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ExpectedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ExpectedPause()";
            const SELECTOR: [u8; 4] = [141u8, 252u8, 32u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `FailedCall()` and selector `0xd6bda275`.
```solidity
error FailedCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FailedCall;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FailedCall> for UnderlyingRustTuple<'_> {
            fn from(value: FailedCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FailedCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FailedCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FailedCall()";
            const SELECTOR: [u8; 4] = [214u8, 189u8, 162u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `FailedDeployment()` and selector `0xb06ebf3d`.
```solidity
error FailedDeployment();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FailedDeployment;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FailedDeployment> for UnderlyingRustTuple<'_> {
            fn from(value: FailedDeployment) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FailedDeployment {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FailedDeployment {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FailedDeployment()";
            const SELECTOR: [u8; 4] = [176u8, 110u8, 191u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `FailedToUpgradeToLatestImplementation()` and selector `0xab6eb5bc`.
```solidity
error FailedToUpgradeToLatestImplementation();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FailedToUpgradeToLatestImplementation;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FailedToUpgradeToLatestImplementation>
        for UnderlyingRustTuple<'_> {
            fn from(value: FailedToUpgradeToLatestImplementation) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for FailedToUpgradeToLatestImplementation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FailedToUpgradeToLatestImplementation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FailedToUpgradeToLatestImplementation()";
            const SELECTOR: [u8; 4] = [171u8, 110u8, 181u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ImplementationAlreadyAllowed()` and selector `0x1833a24b`.
```solidity
error ImplementationAlreadyAllowed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ImplementationAlreadyAllowed;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ImplementationAlreadyAllowed>
        for UnderlyingRustTuple<'_> {
            fn from(value: ImplementationAlreadyAllowed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ImplementationAlreadyAllowed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ImplementationAlreadyAllowed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ImplementationAlreadyAllowed()";
            const SELECTOR: [u8; 4] = [24u8, 51u8, 162u8, 75u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ImplementationNotAllowed()` and selector `0xfb101809`.
```solidity
error ImplementationNotAllowed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ImplementationNotAllowed;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ImplementationNotAllowed>
        for UnderlyingRustTuple<'_> {
            fn from(value: ImplementationNotAllowed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ImplementationNotAllowed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ImplementationNotAllowed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ImplementationNotAllowed()";
            const SELECTOR: [u8; 4] = [251u8, 16u8, 24u8, 9u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InsufficientBalance(uint256,uint256)` and selector `0xcf479181`.
```solidity
error InsufficientBalance(uint256 balance, uint256 needed);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientBalance {
        #[allow(missing_docs)]
        pub balance: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub needed: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientBalance> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientBalance) -> Self {
                (value.balance, value.needed)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientBalance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    balance: tuple.0,
                    needed: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientBalance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientBalance(uint256,uint256)";
            const SELECTOR: [u8; 4] = [207u8, 71u8, 145u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.balance),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.needed),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidInitialization()` and selector `0xf92ee8a9`.
```solidity
error InvalidInitialization();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidInitialization;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidInitialization> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidInitialization) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidInitialization {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidInitialization {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidInitialization()";
            const SELECTOR: [u8; 4] = [249u8, 46u8, 232u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotInitializing()` and selector `0xd7e6bcf8`.
```solidity
error NotInitializing();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotInitializing;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotInitializing> for UnderlyingRustTuple<'_> {
            fn from(value: NotInitializing) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotInitializing {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotInitializing {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotInitializing()";
            const SELECTOR: [u8; 4] = [215u8, 230u8, 188u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `OnlyChainCanNotifyUpgrade()` and selector `0x2fd9adae`.
```solidity
error OnlyChainCanNotifyUpgrade();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OnlyChainCanNotifyUpgrade;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OnlyChainCanNotifyUpgrade>
        for UnderlyingRustTuple<'_> {
            fn from(value: OnlyChainCanNotifyUpgrade) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for OnlyChainCanNotifyUpgrade {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OnlyChainCanNotifyUpgrade {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OnlyChainCanNotifyUpgrade()";
            const SELECTOR: [u8; 4] = [47u8, 217u8, 173u8, 174u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `StringsInvalidChar()` and selector `0x94e2737e`.
```solidity
error StringsInvalidChar();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct StringsInvalidChar;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<StringsInvalidChar> for UnderlyingRustTuple<'_> {
            fn from(value: StringsInvalidChar) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for StringsInvalidChar {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for StringsInvalidChar {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "StringsInvalidChar()";
            const SELECTOR: [u8; 4] = [148u8, 226u8, 115u8, 126u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UUPSUnauthorizedCallContext()` and selector `0xe07c8dba`.
```solidity
error UUPSUnauthorizedCallContext();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnauthorizedCallContext;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnauthorizedCallContext>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnauthorizedCallContext) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnauthorizedCallContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnauthorizedCallContext {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnauthorizedCallContext()";
            const SELECTOR: [u8; 4] = [224u8, 124u8, 141u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UUPSUnsupportedProxiableUUID(bytes32)` and selector `0xaa1d49a4`.
```solidity
error UUPSUnsupportedProxiableUUID(bytes32 slot);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnsupportedProxiableUUID {
        #[allow(missing_docs)]
        pub slot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnsupportedProxiableUUID>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnsupportedProxiableUUID) -> Self {
                (value.slot,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnsupportedProxiableUUID {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { slot: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnsupportedProxiableUUID {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnsupportedProxiableUUID(bytes32)";
            const SELECTOR: [u8; 4] = [170u8, 29u8, 73u8, 164u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ZeroAddress()` and selector `0xd92e233d`.
```solidity
error ZeroAddress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAddress;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAddress> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAddress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAddress()";
            const SELECTOR: [u8; 4] = [217u8, 46u8, 35u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ChainBannedFromGasTracking(uint256,address)` and selector `0xebb4c50deb285192d1c2aa8832b1feeb078ba0fd92bb439c0dee28ebe9bb36e9`.
```solidity
event ChainBannedFromGasTracking(uint256 indexed chainId, address indexed notAllowedImplementation);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ChainBannedFromGasTracking {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub notAllowedImplementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ChainBannedFromGasTracking {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "ChainBannedFromGasTracking(uint256,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                235u8, 180u8, 197u8, 13u8, 235u8, 40u8, 81u8, 146u8, 209u8, 194u8, 170u8,
                136u8, 50u8, 177u8, 254u8, 235u8, 7u8, 139u8, 160u8, 253u8, 146u8, 187u8,
                67u8, 156u8, 13u8, 238u8, 40u8, 235u8, 233u8, 187u8, 54u8, 233u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    chainId: topics.1,
                    notAllowedImplementation: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.chainId.clone(),
                    self.notAllowedImplementation.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.chainId);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.notAllowedImplementation,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ChainBannedFromGasTracking {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ChainBannedFromGasTracking> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &ChainBannedFromGasTracking,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ChainIdManuallyMarked(uint256)` and selector `0x21c25cd0a54e1609e3e68b335693eefb694d5ef17cc32b106f913f8a1f1b8058`.
```solidity
event ChainIdManuallyMarked(uint256 indexed chainId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ChainIdManuallyMarked {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ChainIdManuallyMarked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "ChainIdManuallyMarked(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                33u8, 194u8, 92u8, 208u8, 165u8, 78u8, 22u8, 9u8, 227u8, 230u8, 139u8,
                51u8, 86u8, 147u8, 238u8, 251u8, 105u8, 77u8, 94u8, 241u8, 124u8, 195u8,
                43u8, 16u8, 111u8, 145u8, 63u8, 138u8, 31u8, 27u8, 128u8, 88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { chainId: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.chainId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.chainId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ChainIdManuallyMarked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ChainIdManuallyMarked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ChainIdManuallyMarked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `DeterministicChainIdGenerated(address,uint256,uint256)` and selector `0x550194668a072a7c7daf12b7751a52478a8a12de0b9f557162d280fb8c74f473`.
```solidity
event DeterministicChainIdGenerated(address indexed sender, uint256 indexed nonce, uint256 indexed chainId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DeterministicChainIdGenerated {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DeterministicChainIdGenerated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "DeterministicChainIdGenerated(address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                85u8, 1u8, 148u8, 102u8, 138u8, 7u8, 42u8, 124u8, 125u8, 175u8, 18u8,
                183u8, 117u8, 26u8, 82u8, 71u8, 138u8, 138u8, 18u8, 222u8, 11u8, 159u8,
                85u8, 113u8, 98u8, 210u8, 128u8, 251u8, 140u8, 116u8, 244u8, 115u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    sender: topics.1,
                    nonce: topics.2,
                    chainId: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.sender.clone(),
                    self.nonce.clone(),
                    self.chainId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.nonce);
                out[3usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.chainId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DeterministicChainIdGenerated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DeterministicChainIdGenerated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &DeterministicChainIdGenerated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ImplementationAdded(address)` and selector `0x331cedc71f28c46d467691770675b586e8aa77a0d4fe09f257d01ef00bc15458`.
```solidity
event ImplementationAdded(address indexed implementation);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ImplementationAdded {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ImplementationAdded {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "ImplementationAdded(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                51u8, 28u8, 237u8, 199u8, 31u8, 40u8, 196u8, 109u8, 70u8, 118u8, 145u8,
                119u8, 6u8, 117u8, 181u8, 134u8, 232u8, 170u8, 119u8, 160u8, 212u8,
                254u8, 9u8, 242u8, 87u8, 208u8, 30u8, 240u8, 11u8, 193u8, 84u8, 88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { implementation: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.implementation.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.implementation,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ImplementationAdded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ImplementationAdded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ImplementationAdded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Initialized(uint64)` and selector `0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2`.
```solidity
event Initialized(uint64 version);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Initialized {
        #[allow(missing_docs)]
        pub version: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialized {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialized(uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                199u8, 245u8, 5u8, 178u8, 243u8, 113u8, 174u8, 33u8, 117u8, 238u8, 73u8,
                19u8, 244u8, 73u8, 158u8, 31u8, 38u8, 51u8, 167u8, 181u8, 147u8, 99u8,
                33u8, 238u8, 209u8, 205u8, 174u8, 182u8, 17u8, 81u8, 129u8, 210u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { version: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.version),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `NamespaceConfigUpdated(uint256,uint256)` and selector `0xd9e1239177bfbd2aebf5d0f20fc075e6df5a502c59d121acd57342c783e31364`.
```solidity
event NamespaceConfigUpdated(uint256 oldNamespacePrefix, uint256 newNamespacePrefix);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct NamespaceConfigUpdated {
        #[allow(missing_docs)]
        pub oldNamespacePrefix: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub newNamespacePrefix: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for NamespaceConfigUpdated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "NamespaceConfigUpdated(uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                217u8, 225u8, 35u8, 145u8, 119u8, 191u8, 189u8, 42u8, 235u8, 245u8,
                208u8, 242u8, 15u8, 192u8, 117u8, 230u8, 223u8, 90u8, 80u8, 44u8, 89u8,
                209u8, 33u8, 172u8, 213u8, 115u8, 66u8, 199u8, 131u8, 227u8, 19u8, 100u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldNamespacePrefix: data.0,
                    newNamespacePrefix: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.oldNamespacePrefix),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newNamespacePrefix),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for NamespaceConfigUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&NamespaceConfigUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &NamespaceConfigUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Paused(address)` and selector `0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258`.
```solidity
event Paused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Paused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Paused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Paused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                98u8, 231u8, 140u8, 234u8, 1u8, 190u8, 227u8, 32u8, 205u8, 78u8, 66u8,
                2u8, 112u8, 181u8, 234u8, 116u8, 0u8, 13u8, 17u8, 176u8, 201u8, 247u8,
                71u8, 84u8, 235u8, 219u8, 252u8, 84u8, 75u8, 5u8, 162u8, 88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Paused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Paused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Paused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoleAdminChanged(bytes32,bytes32,bytes32)` and selector `0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff`.
```solidity
event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleAdminChanged {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub previousAdminRole: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newAdminRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleAdminChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "RoleAdminChanged(bytes32,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                189u8, 121u8, 184u8, 111u8, 254u8, 10u8, 184u8, 232u8, 119u8, 97u8, 81u8,
                81u8, 66u8, 23u8, 205u8, 124u8, 172u8, 213u8, 44u8, 144u8, 159u8, 102u8,
                71u8, 92u8, 58u8, 244u8, 78u8, 18u8, 159u8, 11u8, 0u8, 255u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    previousAdminRole: topics.2,
                    newAdminRole: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.previousAdminRole.clone(),
                    self.newAdminRole.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.previousAdminRole);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newAdminRole);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleAdminChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleAdminChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleAdminChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoleGranted(bytes32,address,address)` and selector `0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d`.
```solidity
event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleGranted {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleGranted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleGranted(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                47u8, 135u8, 136u8, 17u8, 126u8, 126u8, 255u8, 29u8, 130u8, 233u8, 38u8,
                236u8, 121u8, 73u8, 1u8, 209u8, 124u8, 120u8, 2u8, 74u8, 80u8, 39u8, 9u8,
                64u8, 48u8, 69u8, 64u8, 167u8, 51u8, 101u8, 111u8, 13u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleGranted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleGranted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleGranted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoleRevoked(bytes32,address,address)` and selector `0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b`.
```solidity
event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleRevoked {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleRevoked(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                246u8, 57u8, 31u8, 92u8, 50u8, 217u8, 198u8, 157u8, 42u8, 71u8, 234u8,
                103u8, 11u8, 68u8, 41u8, 116u8, 181u8, 57u8, 53u8, 209u8, 237u8, 199u8,
                253u8, 100u8, 235u8, 33u8, 224u8, 71u8, 168u8, 57u8, 23u8, 27u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `SyndicateSequencingChainCreated(uint256,address,address)` and selector `0x49b21f1e4190db8b0a933c951ed013de222c847c15461754682daa2eab1fdbd2`.
```solidity
event SyndicateSequencingChainCreated(uint256 indexed appchainId, address indexed sequencingChainAddress, address indexed permissionModuleAddress);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SyndicateSequencingChainCreated {
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub sequencingChainAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub permissionModuleAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SyndicateSequencingChainCreated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "SyndicateSequencingChainCreated(uint256,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                73u8, 178u8, 31u8, 30u8, 65u8, 144u8, 219u8, 139u8, 10u8, 147u8, 60u8,
                149u8, 30u8, 208u8, 19u8, 222u8, 34u8, 44u8, 132u8, 124u8, 21u8, 70u8,
                23u8, 84u8, 104u8, 45u8, 170u8, 46u8, 171u8, 31u8, 219u8, 210u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    appchainId: topics.1,
                    sequencingChainAddress: topics.2,
                    permissionModuleAddress: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.appchainId.clone(),
                    self.sequencingChainAddress.clone(),
                    self.permissionModuleAddress.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.appchainId);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sequencingChainAddress,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.permissionModuleAddress,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SyndicateSequencingChainCreated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SyndicateSequencingChainCreated>
        for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &SyndicateSequencingChainCreated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Unpaused(address)` and selector `0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa`.
```solidity
event Unpaused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Unpaused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Unpaused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Unpaused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                93u8, 185u8, 238u8, 10u8, 73u8, 91u8, 242u8, 230u8, 255u8, 156u8, 145u8,
                167u8, 131u8, 76u8, 27u8, 164u8, 253u8, 210u8, 68u8, 165u8, 232u8, 170u8,
                78u8, 83u8, 123u8, 211u8, 138u8, 234u8, 228u8, 176u8, 115u8, 170u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Unpaused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Unpaused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Unpaused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Upgraded(address)` and selector `0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b`.
```solidity
event Upgraded(address indexed implementation);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Upgraded {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Upgraded {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Upgraded(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                188u8, 124u8, 215u8, 90u8, 32u8, 238u8, 39u8, 253u8, 154u8, 222u8, 186u8,
                179u8, 32u8, 65u8, 247u8, 85u8, 33u8, 77u8, 188u8, 107u8, 255u8, 169u8,
                12u8, 192u8, 34u8, 91u8, 57u8, 218u8, 46u8, 92u8, 45u8, 59u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { implementation: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.implementation.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.implementation,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Upgraded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Upgraded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Upgraded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {}
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `DEFAULT_ADMIN_ROLE()` and selector `0xa217fddf`.
```solidity
function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLECall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`DEFAULT_ADMIN_ROLE()`](DEFAULT_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEFAULT_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEFAULT_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [162u8, 23u8, 253u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: DEFAULT_ADMIN_ROLEReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: DEFAULT_ADMIN_ROLEReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `MANAGER_ROLE()` and selector `0xec87621c`.
```solidity
function MANAGER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MANAGER_ROLECall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`MANAGER_ROLE()`](MANAGER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MANAGER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MANAGER_ROLECall> for UnderlyingRustTuple<'_> {
                fn from(value: MANAGER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for MANAGER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MANAGER_ROLEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: MANAGER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for MANAGER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for MANAGER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MANAGER_ROLE()";
            const SELECTOR: [u8; 4] = [236u8, 135u8, 98u8, 28u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: MANAGER_ROLEReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: MANAGER_ROLEReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `UPGRADE_INTERFACE_VERSION()` and selector `0xad3cb1cc`.
```solidity
function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`UPGRADE_INTERFACE_VERSION()`](UPGRADE_INTERFACE_VERSIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for UPGRADE_INTERFACE_VERSIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UPGRADE_INTERFACE_VERSION()";
            const SELECTOR: [u8; 4] = [173u8, 60u8, 177u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: UPGRADE_INTERFACE_VERSIONReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: UPGRADE_INTERFACE_VERSIONReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `addAllowedImplementation(address,bool)` and selector `0x1d1ab15a`.
```solidity
function addAllowedImplementation(address implementation, bool makeDefault) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addAllowedImplementationCall {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub makeDefault: bool,
    }
    ///Container type for the return parameters of the [`addAllowedImplementation(address,bool)`](addAllowedImplementationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addAllowedImplementationReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, bool);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addAllowedImplementationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: addAllowedImplementationCall) -> Self {
                    (value.implementation, value.makeDefault)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for addAllowedImplementationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        implementation: tuple.0,
                        makeDefault: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addAllowedImplementationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: addAllowedImplementationReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for addAllowedImplementationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl addAllowedImplementationReturn {
            fn _tokenize(
                &self,
            ) -> <addAllowedImplementationCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addAllowedImplementationCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addAllowedImplementationReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addAllowedImplementation(address,bool)";
            const SELECTOR: [u8; 4] = [29u8, 26u8, 177u8, 90u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.implementation,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.makeDefault,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                addAllowedImplementationReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `allowedImplementations(uint256)` and selector `0x3144e853`.
```solidity
function allowedImplementations(uint256) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allowedImplementationsCall(
        pub alloy::sol_types::private::primitives::aliases::U256,
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`allowedImplementations(uint256)`](allowedImplementationsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allowedImplementationsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowedImplementationsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: allowedImplementationsCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for allowedImplementationsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowedImplementationsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: allowedImplementationsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for allowedImplementationsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for allowedImplementationsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "allowedImplementations(uint256)";
            const SELECTOR: [u8; 4] = [49u8, 68u8, 232u8, 83u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.0),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: allowedImplementationsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: allowedImplementationsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `appchainContracts(uint256)` and selector `0x6ff6f6c0`.
```solidity
function appchainContracts(uint256) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct appchainContractsCall(
        pub alloy::sol_types::private::primitives::aliases::U256,
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`appchainContracts(uint256)`](appchainContractsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct appchainContractsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<appchainContractsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: appchainContractsCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for appchainContractsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<appchainContractsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: appchainContractsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for appchainContractsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for appchainContractsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "appchainContracts(uint256)";
            const SELECTOR: [u8; 4] = [111u8, 246u8, 246u8, 192u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.0),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: appchainContractsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: appchainContractsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `banChainFromGasTracking(uint256,address)` and selector `0x8b35ba25`.
```solidity
function banChainFromGasTracking(uint256 chainId, address notAllowedImplementation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct banChainFromGasTrackingCall {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub notAllowedImplementation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`banChainFromGasTracking(uint256,address)`](banChainFromGasTrackingCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct banChainFromGasTrackingReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<banChainFromGasTrackingCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: banChainFromGasTrackingCall) -> Self {
                    (value.chainId, value.notAllowedImplementation)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for banChainFromGasTrackingCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        chainId: tuple.0,
                        notAllowedImplementation: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<banChainFromGasTrackingReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: banChainFromGasTrackingReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for banChainFromGasTrackingReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl banChainFromGasTrackingReturn {
            fn _tokenize(
                &self,
            ) -> <banChainFromGasTrackingCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for banChainFromGasTrackingCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = banChainFromGasTrackingReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "banChainFromGasTracking(uint256,address)";
            const SELECTOR: [u8; 4] = [139u8, 53u8, 186u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.notAllowedImplementation,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                banChainFromGasTrackingReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `chainIDs(uint256)` and selector `0x09d23e24`.
```solidity
function chainIDs(uint256) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct chainIDsCall(pub alloy::sol_types::private::primitives::aliases::U256);
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`chainIDs(uint256)`](chainIDsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct chainIDsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<chainIDsCall> for UnderlyingRustTuple<'_> {
                fn from(value: chainIDsCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for chainIDsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<chainIDsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: chainIDsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for chainIDsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for chainIDsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "chainIDs(uint256)";
            const SELECTOR: [u8; 4] = [9u8, 210u8, 62u8, 36u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.0),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: chainIDsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: chainIDsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `computeSequencingChainAddress(uint256)` and selector `0x6389f8da`.
```solidity
function computeSequencingChainAddress(uint256 chainId) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct computeSequencingChainAddressCall {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`computeSequencingChainAddress(uint256)`](computeSequencingChainAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct computeSequencingChainAddressReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<computeSequencingChainAddressCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: computeSequencingChainAddressCall) -> Self {
                    (value.chainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for computeSequencingChainAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { chainId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<computeSequencingChainAddressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: computeSequencingChainAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for computeSequencingChainAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for computeSequencingChainAddressCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "computeSequencingChainAddress(uint256)";
            const SELECTOR: [u8; 4] = [99u8, 137u8, 248u8, 218u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: computeSequencingChainAddressReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: computeSequencingChainAddressReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `computeStubImplementationAddress()` and selector `0xca4cd025`.
```solidity
function computeStubImplementationAddress() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct computeStubImplementationAddressCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`computeStubImplementationAddress()`](computeStubImplementationAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct computeStubImplementationAddressReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<computeStubImplementationAddressCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: computeStubImplementationAddressCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for computeStubImplementationAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<computeStubImplementationAddressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: computeStubImplementationAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for computeStubImplementationAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for computeStubImplementationAddressCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "computeStubImplementationAddress()";
            const SELECTOR: [u8; 4] = [202u8, 76u8, 208u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: computeStubImplementationAddressReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: computeStubImplementationAddressReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `createSyndicateSequencingChain(uint256,address,address)` and selector `0x67a5fb2c`.
```solidity
function createSyndicateSequencingChain(uint256 appchainId, address admin, address permissionModule) external returns (address sequencingChain, uint256 actualChainId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createSyndicateSequencingChainCall {
        #[allow(missing_docs)]
        pub appchainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub admin: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub permissionModule: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`createSyndicateSequencingChain(uint256,address,address)`](createSyndicateSequencingChainCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createSyndicateSequencingChainReturn {
        #[allow(missing_docs)]
        pub sequencingChain: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub actualChainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createSyndicateSequencingChainCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: createSyndicateSequencingChainCall) -> Self {
                    (value.appchainId, value.admin, value.permissionModule)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createSyndicateSequencingChainCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        appchainId: tuple.0,
                        admin: tuple.1,
                        permissionModule: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createSyndicateSequencingChainReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: createSyndicateSequencingChainReturn) -> Self {
                    (value.sequencingChain, value.actualChainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createSyndicateSequencingChainReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        sequencingChain: tuple.0,
                        actualChainId: tuple.1,
                    }
                }
            }
        }
        impl createSyndicateSequencingChainReturn {
            fn _tokenize(
                &self,
            ) -> <createSyndicateSequencingChainCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sequencingChain,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.actualChainId),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for createSyndicateSequencingChainCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = createSyndicateSequencingChainReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "createSyndicateSequencingChain(uint256,address,address)";
            const SELECTOR: [u8; 4] = [103u8, 165u8, 251u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.appchainId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.admin,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.permissionModule,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                createSyndicateSequencingChainReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `createSyndicateSequencingChainDeterministic(uint256,address,address)` and selector `0xd4f4768f`.
```solidity
function createSyndicateSequencingChainDeterministic(uint256 nonce, address admin, address permissionModule) external returns (address sequencingChain, uint256 actualChainId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createSyndicateSequencingChainDeterministicCall {
        #[allow(missing_docs)]
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub admin: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub permissionModule: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`createSyndicateSequencingChainDeterministic(uint256,address,address)`](createSyndicateSequencingChainDeterministicCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createSyndicateSequencingChainDeterministicReturn {
        #[allow(missing_docs)]
        pub sequencingChain: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub actualChainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createSyndicateSequencingChainDeterministicCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: createSyndicateSequencingChainDeterministicCall) -> Self {
                    (value.nonce, value.admin, value.permissionModule)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createSyndicateSequencingChainDeterministicCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        nonce: tuple.0,
                        admin: tuple.1,
                        permissionModule: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createSyndicateSequencingChainDeterministicReturn>
            for UnderlyingRustTuple<'_> {
                fn from(
                    value: createSyndicateSequencingChainDeterministicReturn,
                ) -> Self {
                    (value.sequencingChain, value.actualChainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createSyndicateSequencingChainDeterministicReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        sequencingChain: tuple.0,
                        actualChainId: tuple.1,
                    }
                }
            }
        }
        impl createSyndicateSequencingChainDeterministicReturn {
            fn _tokenize(
                &self,
            ) -> <createSyndicateSequencingChainDeterministicCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sequencingChain,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.actualChainId),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall
        for createSyndicateSequencingChainDeterministicCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = createSyndicateSequencingChainDeterministicReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "createSyndicateSequencingChainDeterministic(uint256,address,address)";
            const SELECTOR: [u8; 4] = [212u8, 244u8, 118u8, 143u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.admin,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.permissionModule,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                createSyndicateSequencingChainDeterministicReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `createSyndicateSequencingChainWithCustomId(uint256,address,address)` and selector `0xafeb55f8`.
```solidity
function createSyndicateSequencingChainWithCustomId(uint256 customChainId, address admin, address permissionModule) external returns (address sequencingChain, uint256 actualChainId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createSyndicateSequencingChainWithCustomIdCall {
        #[allow(missing_docs)]
        pub customChainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub admin: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub permissionModule: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`createSyndicateSequencingChainWithCustomId(uint256,address,address)`](createSyndicateSequencingChainWithCustomIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createSyndicateSequencingChainWithCustomIdReturn {
        #[allow(missing_docs)]
        pub sequencingChain: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub actualChainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createSyndicateSequencingChainWithCustomIdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: createSyndicateSequencingChainWithCustomIdCall) -> Self {
                    (value.customChainId, value.admin, value.permissionModule)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createSyndicateSequencingChainWithCustomIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        customChainId: tuple.0,
                        admin: tuple.1,
                        permissionModule: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createSyndicateSequencingChainWithCustomIdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(
                    value: createSyndicateSequencingChainWithCustomIdReturn,
                ) -> Self {
                    (value.sequencingChain, value.actualChainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createSyndicateSequencingChainWithCustomIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        sequencingChain: tuple.0,
                        actualChainId: tuple.1,
                    }
                }
            }
        }
        impl createSyndicateSequencingChainWithCustomIdReturn {
            fn _tokenize(
                &self,
            ) -> <createSyndicateSequencingChainWithCustomIdCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sequencingChain,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.actualChainId),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall
        for createSyndicateSequencingChainWithCustomIdCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = createSyndicateSequencingChainWithCustomIdReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "createSyndicateSequencingChainWithCustomId(uint256,address,address)";
            const SELECTOR: [u8; 4] = [175u8, 235u8, 85u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.customChainId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.admin,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.permissionModule,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                createSyndicateSequencingChainWithCustomIdReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `gasTrackingBanlist(uint256)` and selector `0xc112ee8c`.
```solidity
function gasTrackingBanlist(uint256) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gasTrackingBanlistCall(
        pub alloy::sol_types::private::primitives::aliases::U256,
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`gasTrackingBanlist(uint256)`](gasTrackingBanlistCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct gasTrackingBanlistReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gasTrackingBanlistCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: gasTrackingBanlistCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for gasTrackingBanlistCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<gasTrackingBanlistReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: gasTrackingBanlistReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for gasTrackingBanlistReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for gasTrackingBanlistCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "gasTrackingBanlist(uint256)";
            const SELECTOR: [u8; 4] = [193u8, 18u8, 238u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.0),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: gasTrackingBanlistReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: gasTrackingBanlistReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `generateDeterministicChainId(address,uint256)` and selector `0xa08f1a7f`.
```solidity
function generateDeterministicChainId(address sender, uint256 nonce) external pure returns (uint256 chainId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct generateDeterministicChainIdCall {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`generateDeterministicChainId(address,uint256)`](generateDeterministicChainIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct generateDeterministicChainIdReturn {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<generateDeterministicChainIdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: generateDeterministicChainIdCall) -> Self {
                    (value.sender, value.nonce)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for generateDeterministicChainIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        sender: tuple.0,
                        nonce: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<generateDeterministicChainIdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: generateDeterministicChainIdReturn) -> Self {
                    (value.chainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for generateDeterministicChainIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { chainId: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for generateDeterministicChainIdCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "generateDeterministicChainId(address,uint256)";
            const SELECTOR: [u8; 4] = [160u8, 143u8, 26u8, 127u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: generateDeterministicChainIdReturn = r.into();
                        r.chainId
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: generateDeterministicChainIdReturn = r.into();
                        r.chainId
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getAllowedImplementations()` and selector `0x32ed6805`.
```solidity
function getAllowedImplementations() external view returns (address[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAllowedImplementationsCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getAllowedImplementations()`](getAllowedImplementationsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAllowedImplementationsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAllowedImplementationsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAllowedImplementationsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAllowedImplementationsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAllowedImplementationsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAllowedImplementationsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAllowedImplementationsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAllowedImplementationsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAllowedImplementations()";
            const SELECTOR: [u8; 4] = [50u8, 237u8, 104u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getAllowedImplementationsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getAllowedImplementationsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getAppchainsAndContractsForGasTracking()` and selector `0x5bd6588b`.
```solidity
function getAppchainsAndContractsForGasTracking() external view returns (uint256[] memory _chainIDs, address[] memory _contracts);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAppchainsAndContractsForGasTrackingCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getAppchainsAndContractsForGasTracking()`](getAppchainsAndContractsForGasTrackingCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAppchainsAndContractsForGasTrackingReturn {
        #[allow(missing_docs)]
        pub _chainIDs: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
        #[allow(missing_docs)]
        pub _contracts: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAppchainsAndContractsForGasTrackingCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAppchainsAndContractsForGasTrackingCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAppchainsAndContractsForGasTrackingCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAppchainsAndContractsForGasTrackingReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAppchainsAndContractsForGasTrackingReturn) -> Self {
                    (value._chainIDs, value._contracts)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAppchainsAndContractsForGasTrackingReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _chainIDs: tuple.0,
                        _contracts: tuple.1,
                    }
                }
            }
        }
        impl getAppchainsAndContractsForGasTrackingReturn {
            fn _tokenize(
                &self,
            ) -> <getAppchainsAndContractsForGasTrackingCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self._chainIDs),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self._contracts),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAppchainsAndContractsForGasTrackingCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getAppchainsAndContractsForGasTrackingReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAppchainsAndContractsForGasTracking()";
            const SELECTOR: [u8; 4] = [91u8, 214u8, 88u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                getAppchainsAndContractsForGasTrackingReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getContractsForGasTracking(uint256[])` and selector `0xaae7238c`.
```solidity
function getContractsForGasTracking(uint256[] memory _chainIDs) external view returns (address[] memory _contracts);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getContractsForGasTrackingCall {
        #[allow(missing_docs)]
        pub _chainIDs: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getContractsForGasTracking(uint256[])`](getContractsForGasTrackingCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getContractsForGasTrackingReturn {
        #[allow(missing_docs)]
        pub _contracts: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getContractsForGasTrackingCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getContractsForGasTrackingCall) -> Self {
                    (value._chainIDs,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getContractsForGasTrackingCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _chainIDs: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getContractsForGasTrackingReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getContractsForGasTrackingReturn) -> Self {
                    (value._contracts,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getContractsForGasTrackingReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _contracts: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getContractsForGasTrackingCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getContractsForGasTracking(uint256[])";
            const SELECTOR: [u8; 4] = [170u8, 231u8, 35u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self._chainIDs),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getContractsForGasTrackingReturn = r.into();
                        r._contracts
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getContractsForGasTrackingReturn = r.into();
                        r._contracts
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getImplBytecode(address)` and selector `0xee5ee73c`.
```solidity
function getImplBytecode(address r#impl) external pure returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getImplBytecodeCall {
        #[allow(missing_docs)]
        pub r#impl: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getImplBytecode(address)`](getImplBytecodeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getImplBytecodeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getImplBytecodeCall> for UnderlyingRustTuple<'_> {
                fn from(value: getImplBytecodeCall) -> Self {
                    (value.r#impl,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getImplBytecodeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { r#impl: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getImplBytecodeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getImplBytecodeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getImplBytecodeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getImplBytecodeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Bytes;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getImplBytecode(address)";
            const SELECTOR: [u8; 4] = [238u8, 94u8, 231u8, 60u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.r#impl,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getImplBytecodeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getImplBytecodeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getNextChainId()` and selector `0x8de6e28c`.
```solidity
function getNextChainId() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getNextChainIdCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getNextChainId()`](getNextChainIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getNextChainIdReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getNextChainIdCall> for UnderlyingRustTuple<'_> {
                fn from(value: getNextChainIdCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getNextChainIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getNextChainIdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getNextChainIdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getNextChainIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getNextChainIdCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getNextChainId()";
            const SELECTOR: [u8; 4] = [141u8, 230u8, 226u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getNextChainIdReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getNextChainIdReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getNextNonceForSender(address)` and selector `0x6ab51442`.
```solidity
function getNextNonceForSender(address sender) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getNextNonceForSenderCall {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getNextNonceForSender(address)`](getNextNonceForSenderCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getNextNonceForSenderReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getNextNonceForSenderCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getNextNonceForSenderCall) -> Self {
                    (value.sender,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getNextNonceForSenderCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { sender: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getNextNonceForSenderReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getNextNonceForSenderReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getNextNonceForSenderReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getNextNonceForSenderCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getNextNonceForSender(address)";
            const SELECTOR: [u8; 4] = [106u8, 181u8, 20u8, 66u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getNextNonceForSenderReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getNextNonceForSenderReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getProxyBytecode()` and selector `0xb416663e`.
```solidity
function getProxyBytecode() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getProxyBytecodeCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getProxyBytecode()`](getProxyBytecodeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getProxyBytecodeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getProxyBytecodeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getProxyBytecodeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getProxyBytecodeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getProxyBytecodeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getProxyBytecodeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getProxyBytecodeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getProxyBytecodeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Bytes;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getProxyBytecode()";
            const SELECTOR: [u8; 4] = [180u8, 22u8, 102u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getProxyBytecodeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getProxyBytecodeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getRoleAdmin(bytes32)` and selector `0x248a9ca3`.
```solidity
function getRoleAdmin(bytes32 role) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getRoleAdmin(bytes32)`](getRoleAdminCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleAdminCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleAdmin(bytes32)";
            const SELECTOR: [u8; 4] = [36u8, 138u8, 156u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getRoleAdminReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getRoleAdminReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getTotalAppchainsForGasTracking()` and selector `0x6ae7e703`.
```solidity
function getTotalAppchainsForGasTracking() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getTotalAppchainsForGasTrackingCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getTotalAppchainsForGasTracking()`](getTotalAppchainsForGasTrackingCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getTotalAppchainsForGasTrackingReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTotalAppchainsForGasTrackingCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getTotalAppchainsForGasTrackingCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getTotalAppchainsForGasTrackingCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTotalAppchainsForGasTrackingReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getTotalAppchainsForGasTrackingReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getTotalAppchainsForGasTrackingReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getTotalAppchainsForGasTrackingCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getTotalAppchainsForGasTracking()";
            const SELECTOR: [u8; 4] = [106u8, 231u8, 231u8, 3u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getTotalAppchainsForGasTrackingReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getTotalAppchainsForGasTrackingReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `grantRole(bytes32,address)` and selector `0x2f2ff15d`.
```solidity
function grantRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`grantRole(bytes32,address)`](grantRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl grantRoleReturn {
            fn _tokenize(
                &self,
            ) -> <grantRoleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for grantRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = grantRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "grantRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [47u8, 47u8, 241u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                grantRoleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `hasRole(bytes32,address)` and selector `0x91d14854`.
```solidity
function hasRole(bytes32 role, address account) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`hasRole(bytes32,address)`](hasRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [145u8, 209u8, 72u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: hasRoleReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: hasRoleReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `initialize(address)` and selector `0xc4d66de8`.
```solidity
function initialize(address admin) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeCall {
        #[allow(missing_docs)]
        pub admin: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`initialize(address)`](initializeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeCall> for UnderlyingRustTuple<'_> {
                fn from(value: initializeCall) -> Self {
                    (value.admin,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { admin: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: initializeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl initializeReturn {
            fn _tokenize(
                &self,
            ) -> <initializeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initialize(address)";
            const SELECTOR: [u8; 4] = [196u8, 214u8, 109u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.admin,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                initializeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isChainBannedFromGasTracking(uint256)` and selector `0x9e15d6ff`.
```solidity
function isChainBannedFromGasTracking(uint256 chainId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isChainBannedFromGasTrackingCall {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isChainBannedFromGasTracking(uint256)`](isChainBannedFromGasTrackingCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isChainBannedFromGasTrackingReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isChainBannedFromGasTrackingCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isChainBannedFromGasTrackingCall) -> Self {
                    (value.chainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isChainBannedFromGasTrackingCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { chainId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isChainBannedFromGasTrackingReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isChainBannedFromGasTrackingReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isChainBannedFromGasTrackingReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isChainBannedFromGasTrackingCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isChainBannedFromGasTracking(uint256)";
            const SELECTOR: [u8; 4] = [158u8, 21u8, 214u8, 255u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isChainBannedFromGasTrackingReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isChainBannedFromGasTrackingReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isChainIdUsed(uint256)` and selector `0x7232c133`.
```solidity
function isChainIdUsed(uint256 chainId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isChainIdUsedCall {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isChainIdUsed(uint256)`](isChainIdUsedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isChainIdUsedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isChainIdUsedCall> for UnderlyingRustTuple<'_> {
                fn from(value: isChainIdUsedCall) -> Self {
                    (value.chainId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isChainIdUsedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { chainId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isChainIdUsedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isChainIdUsedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isChainIdUsedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isChainIdUsedCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isChainIdUsed(uint256)";
            const SELECTOR: [u8; 4] = [114u8, 50u8, 193u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isChainIdUsedReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isChainIdUsedReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isImplementationAllowed(address)` and selector `0x0d4b4bda`.
```solidity
function isImplementationAllowed(address) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isImplementationAllowedCall(pub alloy::sol_types::private::Address);
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isImplementationAllowed(address)`](isImplementationAllowedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isImplementationAllowedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isImplementationAllowedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isImplementationAllowedCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isImplementationAllowedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isImplementationAllowedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isImplementationAllowedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isImplementationAllowedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isImplementationAllowedCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isImplementationAllowed(address)";
            const SELECTOR: [u8; 4] = [13u8, 75u8, 75u8, 218u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.0,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isImplementationAllowedReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isImplementationAllowedReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `namespacePrefix()` and selector `0x297f4c64`.
```solidity
function namespacePrefix() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct namespacePrefixCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`namespacePrefix()`](namespacePrefixCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct namespacePrefixReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<namespacePrefixCall> for UnderlyingRustTuple<'_> {
                fn from(value: namespacePrefixCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for namespacePrefixCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<namespacePrefixReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: namespacePrefixReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for namespacePrefixReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for namespacePrefixCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "namespacePrefix()";
            const SELECTOR: [u8; 4] = [41u8, 127u8, 76u8, 100u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: namespacePrefixReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: namespacePrefixReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `nextAutoChainId()` and selector `0x999d71d4`.
```solidity
function nextAutoChainId() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nextAutoChainIdCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`nextAutoChainId()`](nextAutoChainIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nextAutoChainIdReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nextAutoChainIdCall> for UnderlyingRustTuple<'_> {
                fn from(value: nextAutoChainIdCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nextAutoChainIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nextAutoChainIdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: nextAutoChainIdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for nextAutoChainIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for nextAutoChainIdCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "nextAutoChainId()";
            const SELECTOR: [u8; 4] = [153u8, 157u8, 113u8, 212u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: nextAutoChainIdReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: nextAutoChainIdReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `notifyChainUpgrade(uint256,address)` and selector `0x07a9bee7`.
```solidity
function notifyChainUpgrade(uint256 chainId, address newImplementation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct notifyChainUpgradeCall {
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub newImplementation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`notifyChainUpgrade(uint256,address)`](notifyChainUpgradeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct notifyChainUpgradeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<notifyChainUpgradeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: notifyChainUpgradeCall) -> Self {
                    (value.chainId, value.newImplementation)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for notifyChainUpgradeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        chainId: tuple.0,
                        newImplementation: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<notifyChainUpgradeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: notifyChainUpgradeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for notifyChainUpgradeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl notifyChainUpgradeReturn {
            fn _tokenize(
                &self,
            ) -> <notifyChainUpgradeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for notifyChainUpgradeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = notifyChainUpgradeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "notifyChainUpgrade(uint256,address)";
            const SELECTOR: [u8; 4] = [7u8, 169u8, 190u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newImplementation,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                notifyChainUpgradeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `numberOfChainsBannedFromGasTracking()` and selector `0x00b68a73`.
```solidity
function numberOfChainsBannedFromGasTracking() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct numberOfChainsBannedFromGasTrackingCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`numberOfChainsBannedFromGasTracking()`](numberOfChainsBannedFromGasTrackingCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct numberOfChainsBannedFromGasTrackingReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<numberOfChainsBannedFromGasTrackingCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: numberOfChainsBannedFromGasTrackingCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for numberOfChainsBannedFromGasTrackingCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<numberOfChainsBannedFromGasTrackingReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: numberOfChainsBannedFromGasTrackingReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for numberOfChainsBannedFromGasTrackingReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for numberOfChainsBannedFromGasTrackingCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "numberOfChainsBannedFromGasTracking()";
            const SELECTOR: [u8; 4] = [0u8, 182u8, 138u8, 115u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: numberOfChainsBannedFromGasTrackingReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: numberOfChainsBannedFromGasTrackingReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `pause()` and selector `0x8456cb59`.
```solidity
function pause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseCall;
    ///Container type for the return parameters of the [`pause()`](pauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl pauseReturn {
            fn _tokenize(
                &self,
            ) -> <pauseCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pause()";
            const SELECTOR: [u8; 4] = [132u8, 86u8, 203u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                pauseReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `paused()` and selector `0x5c975abb`.
```solidity
function paused() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`paused()`](pausedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedCall> for UnderlyingRustTuple<'_> {
                fn from(value: pausedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pausedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pausedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "paused()";
            const SELECTOR: [u8; 4] = [92u8, 151u8, 90u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: pausedReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: pausedReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `proxiableUUID()` and selector `0x52d1902d`.
```solidity
function proxiableUUID() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`proxiableUUID()`](proxiableUUIDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDCall> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for proxiableUUIDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "proxiableUUID()";
            const SELECTOR: [u8; 4] = [82u8, 209u8, 144u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: proxiableUUIDReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: proxiableUUIDReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `removeAllowedImplementation(address)` and selector `0xeeeb44ad`.
```solidity
function removeAllowedImplementation(address implementation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeAllowedImplementationCall {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`removeAllowedImplementation(address)`](removeAllowedImplementationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeAllowedImplementationReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeAllowedImplementationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeAllowedImplementationCall) -> Self {
                    (value.implementation,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeAllowedImplementationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { implementation: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeAllowedImplementationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeAllowedImplementationReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeAllowedImplementationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl removeAllowedImplementationReturn {
            fn _tokenize(
                &self,
            ) -> <removeAllowedImplementationCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeAllowedImplementationCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeAllowedImplementationReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeAllowedImplementation(address)";
            const SELECTOR: [u8; 4] = [238u8, 235u8, 68u8, 173u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.implementation,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                removeAllowedImplementationReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `renounceRole(bytes32,address)` and selector `0x36568abe`.
```solidity
function renounceRole(bytes32 role, address callerConfirmation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub callerConfirmation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`renounceRole(bytes32,address)`](renounceRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleCall) -> Self {
                    (value.role, value.callerConfirmation)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        callerConfirmation: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl renounceRoleReturn {
            fn _tokenize(
                &self,
            ) -> <renounceRoleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [54u8, 86u8, 138u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callerConfirmation,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                renounceRoleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `revokeRole(bytes32,address)` and selector `0xd547741f`.
```solidity
function revokeRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeRole(bytes32,address)`](revokeRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl revokeRoleReturn {
            fn _tokenize(
                &self,
            ) -> <revokeRoleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [213u8, 71u8, 116u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                revokeRoleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `senderNonces(address)` and selector `0x295710ff`.
```solidity
function senderNonces(address sender) external view returns (uint256 nonce);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct senderNoncesCall {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`senderNonces(address)`](senderNoncesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct senderNoncesReturn {
        #[allow(missing_docs)]
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<senderNoncesCall> for UnderlyingRustTuple<'_> {
                fn from(value: senderNoncesCall) -> Self {
                    (value.sender,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for senderNoncesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { sender: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<senderNoncesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: senderNoncesReturn) -> Self {
                    (value.nonce,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for senderNoncesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { nonce: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for senderNoncesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "senderNonces(address)";
            const SELECTOR: [u8; 4] = [41u8, 87u8, 16u8, 255u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: senderNoncesReturn = r.into();
                        r.nonce
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: senderNoncesReturn = r.into();
                        r.nonce
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setDefaultImplementation(address)` and selector `0x7c16ffc4`.
```solidity
function setDefaultImplementation(address implementation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setDefaultImplementationCall {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setDefaultImplementation(address)`](setDefaultImplementationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setDefaultImplementationReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setDefaultImplementationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setDefaultImplementationCall) -> Self {
                    (value.implementation,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setDefaultImplementationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { implementation: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setDefaultImplementationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setDefaultImplementationReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setDefaultImplementationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setDefaultImplementationReturn {
            fn _tokenize(
                &self,
            ) -> <setDefaultImplementationCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setDefaultImplementationCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setDefaultImplementationReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setDefaultImplementation(address)";
            const SELECTOR: [u8; 4] = [124u8, 22u8, 255u8, 196u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.implementation,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setDefaultImplementationReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `stubImplementation()` and selector `0x56dba779`.
```solidity
function stubImplementation() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stubImplementationCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`stubImplementation()`](stubImplementationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stubImplementationReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stubImplementationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: stubImplementationCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for stubImplementationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stubImplementationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: stubImplementationReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for stubImplementationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for stubImplementationCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "stubImplementation()";
            const SELECTOR: [u8; 4] = [86u8, 219u8, 167u8, 121u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: stubImplementationReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: stubImplementationReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
```solidity
function supportsInterface(bytes4 interfaceId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceCall {
        #[allow(missing_docs)]
        pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceCall) -> Self {
                    (value.interfaceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { interfaceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportsInterfaceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportsInterface(bytes4)";
            const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.interfaceId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: supportsInterfaceReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: supportsInterfaceReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `syndicateChainImpl()` and selector `0xff76aed6`.
```solidity
function syndicateChainImpl() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct syndicateChainImplCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`syndicateChainImpl()`](syndicateChainImplCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct syndicateChainImplReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<syndicateChainImplCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: syndicateChainImplCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for syndicateChainImplCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<syndicateChainImplReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: syndicateChainImplReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for syndicateChainImplReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for syndicateChainImplCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "syndicateChainImpl()";
            const SELECTOR: [u8; 4] = [255u8, 118u8, 174u8, 214u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: syndicateChainImplReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: syndicateChainImplReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `unpause()` and selector `0x3f4ba83a`.
```solidity
function unpause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseCall;
    ///Container type for the return parameters of the [`unpause()`](unpauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl unpauseReturn {
            fn _tokenize(
                &self,
            ) -> <unpauseCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unpauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = unpauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unpause()";
            const SELECTOR: [u8; 4] = [63u8, 75u8, 168u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                unpauseReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `updateNamespaceConfig(uint256)` and selector `0x8c39aaa4`.
```solidity
function updateNamespaceConfig(uint256 newPrefix) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateNamespaceConfigCall {
        #[allow(missing_docs)]
        pub newPrefix: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`updateNamespaceConfig(uint256)`](updateNamespaceConfigCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateNamespaceConfigReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateNamespaceConfigCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateNamespaceConfigCall) -> Self {
                    (value.newPrefix,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateNamespaceConfigCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newPrefix: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateNamespaceConfigReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateNamespaceConfigReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateNamespaceConfigReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl updateNamespaceConfigReturn {
            fn _tokenize(
                &self,
            ) -> <updateNamespaceConfigCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateNamespaceConfigCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateNamespaceConfigReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateNamespaceConfig(uint256)";
            const SELECTOR: [u8; 4] = [140u8, 57u8, 170u8, 164u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newPrefix),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                updateNamespaceConfigReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `upgradeToAndCall(address,bytes)` and selector `0x4f1ef286`.
```solidity
function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallCall {
        #[allow(missing_docs)]
        pub newImplementation: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`upgradeToAndCall(address,bytes)`](upgradeToAndCallCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallCall) -> Self {
                    (value.newImplementation, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newImplementation: tuple.0,
                        data: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl upgradeToAndCallReturn {
            fn _tokenize(
                &self,
            ) -> <upgradeToAndCallCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for upgradeToAndCallCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = upgradeToAndCallReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "upgradeToAndCall(address,bytes)";
            const SELECTOR: [u8; 4] = [79u8, 30u8, 242u8, 134u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newImplementation,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                upgradeToAndCallReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `usedNamespaces(uint256)` and selector `0xb963ebf3`.
```solidity
function usedNamespaces(uint256) external view returns (NamespaceState);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct usedNamespacesCall(
        pub alloy::sol_types::private::primitives::aliases::U256,
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`usedNamespaces(uint256)`](usedNamespacesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct usedNamespacesReturn {
        #[allow(missing_docs)]
        pub _0: <NamespaceState as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<usedNamespacesCall> for UnderlyingRustTuple<'_> {
                fn from(value: usedNamespacesCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for usedNamespacesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (NamespaceState,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <NamespaceState as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<usedNamespacesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: usedNamespacesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for usedNamespacesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for usedNamespacesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = <NamespaceState as alloy::sol_types::SolType>::RustType;
            type ReturnTuple<'a> = (NamespaceState,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "usedNamespaces(uint256)";
            const SELECTOR: [u8; 4] = [185u8, 99u8, 235u8, 243u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.0),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (<NamespaceState as alloy_sol_types::SolType>::tokenize(ret),)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: usedNamespacesReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: usedNamespacesReturn = r.into();
                        r._0
                    })
            }
        }
    };
    ///Container for all the [`SyndicateFactory`](self) function calls.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum SyndicateFactoryCalls {
        #[allow(missing_docs)]
        DEFAULT_ADMIN_ROLE(DEFAULT_ADMIN_ROLECall),
        #[allow(missing_docs)]
        MANAGER_ROLE(MANAGER_ROLECall),
        #[allow(missing_docs)]
        UPGRADE_INTERFACE_VERSION(UPGRADE_INTERFACE_VERSIONCall),
        #[allow(missing_docs)]
        addAllowedImplementation(addAllowedImplementationCall),
        #[allow(missing_docs)]
        allowedImplementations(allowedImplementationsCall),
        #[allow(missing_docs)]
        appchainContracts(appchainContractsCall),
        #[allow(missing_docs)]
        banChainFromGasTracking(banChainFromGasTrackingCall),
        #[allow(missing_docs)]
        chainIDs(chainIDsCall),
        #[allow(missing_docs)]
        computeSequencingChainAddress(computeSequencingChainAddressCall),
        #[allow(missing_docs)]
        computeStubImplementationAddress(computeStubImplementationAddressCall),
        #[allow(missing_docs)]
        createSyndicateSequencingChain(createSyndicateSequencingChainCall),
        #[allow(missing_docs)]
        createSyndicateSequencingChainDeterministic(
            createSyndicateSequencingChainDeterministicCall,
        ),
        #[allow(missing_docs)]
        createSyndicateSequencingChainWithCustomId(
            createSyndicateSequencingChainWithCustomIdCall,
        ),
        #[allow(missing_docs)]
        gasTrackingBanlist(gasTrackingBanlistCall),
        #[allow(missing_docs)]
        generateDeterministicChainId(generateDeterministicChainIdCall),
        #[allow(missing_docs)]
        getAllowedImplementations(getAllowedImplementationsCall),
        #[allow(missing_docs)]
        getAppchainsAndContractsForGasTracking(
            getAppchainsAndContractsForGasTrackingCall,
        ),
        #[allow(missing_docs)]
        getContractsForGasTracking(getContractsForGasTrackingCall),
        #[allow(missing_docs)]
        getImplBytecode(getImplBytecodeCall),
        #[allow(missing_docs)]
        getNextChainId(getNextChainIdCall),
        #[allow(missing_docs)]
        getNextNonceForSender(getNextNonceForSenderCall),
        #[allow(missing_docs)]
        getProxyBytecode(getProxyBytecodeCall),
        #[allow(missing_docs)]
        getRoleAdmin(getRoleAdminCall),
        #[allow(missing_docs)]
        getTotalAppchainsForGasTracking(getTotalAppchainsForGasTrackingCall),
        #[allow(missing_docs)]
        grantRole(grantRoleCall),
        #[allow(missing_docs)]
        hasRole(hasRoleCall),
        #[allow(missing_docs)]
        initialize(initializeCall),
        #[allow(missing_docs)]
        isChainBannedFromGasTracking(isChainBannedFromGasTrackingCall),
        #[allow(missing_docs)]
        isChainIdUsed(isChainIdUsedCall),
        #[allow(missing_docs)]
        isImplementationAllowed(isImplementationAllowedCall),
        #[allow(missing_docs)]
        namespacePrefix(namespacePrefixCall),
        #[allow(missing_docs)]
        nextAutoChainId(nextAutoChainIdCall),
        #[allow(missing_docs)]
        notifyChainUpgrade(notifyChainUpgradeCall),
        #[allow(missing_docs)]
        numberOfChainsBannedFromGasTracking(numberOfChainsBannedFromGasTrackingCall),
        #[allow(missing_docs)]
        pause(pauseCall),
        #[allow(missing_docs)]
        paused(pausedCall),
        #[allow(missing_docs)]
        proxiableUUID(proxiableUUIDCall),
        #[allow(missing_docs)]
        removeAllowedImplementation(removeAllowedImplementationCall),
        #[allow(missing_docs)]
        renounceRole(renounceRoleCall),
        #[allow(missing_docs)]
        revokeRole(revokeRoleCall),
        #[allow(missing_docs)]
        senderNonces(senderNoncesCall),
        #[allow(missing_docs)]
        setDefaultImplementation(setDefaultImplementationCall),
        #[allow(missing_docs)]
        stubImplementation(stubImplementationCall),
        #[allow(missing_docs)]
        supportsInterface(supportsInterfaceCall),
        #[allow(missing_docs)]
        syndicateChainImpl(syndicateChainImplCall),
        #[allow(missing_docs)]
        unpause(unpauseCall),
        #[allow(missing_docs)]
        updateNamespaceConfig(updateNamespaceConfigCall),
        #[allow(missing_docs)]
        upgradeToAndCall(upgradeToAndCallCall),
        #[allow(missing_docs)]
        usedNamespaces(usedNamespacesCall),
    }
    #[automatically_derived]
    impl SyndicateFactoryCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [0u8, 182u8, 138u8, 115u8],
            [1u8, 255u8, 201u8, 167u8],
            [7u8, 169u8, 190u8, 231u8],
            [9u8, 210u8, 62u8, 36u8],
            [13u8, 75u8, 75u8, 218u8],
            [29u8, 26u8, 177u8, 90u8],
            [36u8, 138u8, 156u8, 163u8],
            [41u8, 87u8, 16u8, 255u8],
            [41u8, 127u8, 76u8, 100u8],
            [47u8, 47u8, 241u8, 93u8],
            [49u8, 68u8, 232u8, 83u8],
            [50u8, 237u8, 104u8, 5u8],
            [54u8, 86u8, 138u8, 190u8],
            [63u8, 75u8, 168u8, 58u8],
            [79u8, 30u8, 242u8, 134u8],
            [82u8, 209u8, 144u8, 45u8],
            [86u8, 219u8, 167u8, 121u8],
            [91u8, 214u8, 88u8, 139u8],
            [92u8, 151u8, 90u8, 187u8],
            [99u8, 137u8, 248u8, 218u8],
            [103u8, 165u8, 251u8, 44u8],
            [106u8, 181u8, 20u8, 66u8],
            [106u8, 231u8, 231u8, 3u8],
            [111u8, 246u8, 246u8, 192u8],
            [114u8, 50u8, 193u8, 51u8],
            [124u8, 22u8, 255u8, 196u8],
            [132u8, 86u8, 203u8, 89u8],
            [139u8, 53u8, 186u8, 37u8],
            [140u8, 57u8, 170u8, 164u8],
            [141u8, 230u8, 226u8, 140u8],
            [145u8, 209u8, 72u8, 84u8],
            [153u8, 157u8, 113u8, 212u8],
            [158u8, 21u8, 214u8, 255u8],
            [160u8, 143u8, 26u8, 127u8],
            [162u8, 23u8, 253u8, 223u8],
            [170u8, 231u8, 35u8, 140u8],
            [173u8, 60u8, 177u8, 204u8],
            [175u8, 235u8, 85u8, 248u8],
            [180u8, 22u8, 102u8, 62u8],
            [185u8, 99u8, 235u8, 243u8],
            [193u8, 18u8, 238u8, 140u8],
            [196u8, 214u8, 109u8, 232u8],
            [202u8, 76u8, 208u8, 37u8],
            [212u8, 244u8, 118u8, 143u8],
            [213u8, 71u8, 116u8, 31u8],
            [236u8, 135u8, 98u8, 28u8],
            [238u8, 94u8, 231u8, 60u8],
            [238u8, 235u8, 68u8, 173u8],
            [255u8, 118u8, 174u8, 214u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndicateFactoryCalls {
        const NAME: &'static str = "SyndicateFactoryCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 49usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::DEFAULT_ADMIN_ROLE(_) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::MANAGER_ROLE(_) => {
                    <MANAGER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::UPGRADE_INTERFACE_VERSION(_) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::addAllowedImplementation(_) => {
                    <addAllowedImplementationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::allowedImplementations(_) => {
                    <allowedImplementationsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::appchainContracts(_) => {
                    <appchainContractsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::banChainFromGasTracking(_) => {
                    <banChainFromGasTrackingCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::chainIDs(_) => <chainIDsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::computeSequencingChainAddress(_) => {
                    <computeSequencingChainAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::computeStubImplementationAddress(_) => {
                    <computeStubImplementationAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::createSyndicateSequencingChain(_) => {
                    <createSyndicateSequencingChainCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::createSyndicateSequencingChainDeterministic(_) => {
                    <createSyndicateSequencingChainDeterministicCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::createSyndicateSequencingChainWithCustomId(_) => {
                    <createSyndicateSequencingChainWithCustomIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::gasTrackingBanlist(_) => {
                    <gasTrackingBanlistCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::generateDeterministicChainId(_) => {
                    <generateDeterministicChainIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAllowedImplementations(_) => {
                    <getAllowedImplementationsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAppchainsAndContractsForGasTracking(_) => {
                    <getAppchainsAndContractsForGasTrackingCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getContractsForGasTracking(_) => {
                    <getContractsForGasTrackingCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getImplBytecode(_) => {
                    <getImplBytecodeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getNextChainId(_) => {
                    <getNextChainIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getNextNonceForSender(_) => {
                    <getNextNonceForSenderCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getProxyBytecode(_) => {
                    <getProxyBytecodeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleAdmin(_) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getTotalAppchainsForGasTracking(_) => {
                    <getTotalAppchainsForGasTrackingCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::grantRole(_) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasRole(_) => <hasRoleCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::initialize(_) => {
                    <initializeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isChainBannedFromGasTracking(_) => {
                    <isChainBannedFromGasTrackingCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isChainIdUsed(_) => {
                    <isChainIdUsedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isImplementationAllowed(_) => {
                    <isImplementationAllowedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::namespacePrefix(_) => {
                    <namespacePrefixCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::nextAutoChainId(_) => {
                    <nextAutoChainIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::notifyChainUpgrade(_) => {
                    <notifyChainUpgradeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::numberOfChainsBannedFromGasTracking(_) => {
                    <numberOfChainsBannedFromGasTrackingCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::pause(_) => <pauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::paused(_) => <pausedCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::proxiableUUID(_) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removeAllowedImplementation(_) => {
                    <removeAllowedImplementationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceRole(_) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeRole(_) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::senderNonces(_) => {
                    <senderNoncesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setDefaultImplementation(_) => {
                    <setDefaultImplementationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::stubImplementation(_) => {
                    <stubImplementationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::supportsInterface(_) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::syndicateChainImpl(_) => {
                    <syndicateChainImplCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::unpause(_) => <unpauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::updateNamespaceConfig(_) => {
                    <updateNamespaceConfigCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::upgradeToAndCall(_) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::usedNamespaces(_) => {
                    <usedNamespacesCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<SyndicateFactoryCalls>] = &[
                {
                    fn numberOfChainsBannedFromGasTracking(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <numberOfChainsBannedFromGasTrackingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                SyndicateFactoryCalls::numberOfChainsBannedFromGasTracking,
                            )
                    }
                    numberOfChainsBannedFromGasTracking
                },
                {
                    fn supportsInterface(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn notifyChainUpgrade(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <notifyChainUpgradeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::notifyChainUpgrade)
                    }
                    notifyChainUpgrade
                },
                {
                    fn chainIDs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <chainIDsCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SyndicateFactoryCalls::chainIDs)
                    }
                    chainIDs
                },
                {
                    fn isImplementationAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <isImplementationAllowedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::isImplementationAllowed)
                    }
                    isImplementationAllowed
                },
                {
                    fn addAllowedImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <addAllowedImplementationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::addAllowedImplementation)
                    }
                    addAllowedImplementation
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn senderNonces(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <senderNoncesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::senderNonces)
                    }
                    senderNonces
                },
                {
                    fn namespacePrefix(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <namespacePrefixCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::namespacePrefix)
                    }
                    namespacePrefix
                },
                {
                    fn grantRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SyndicateFactoryCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn allowedImplementations(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <allowedImplementationsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::allowedImplementations)
                    }
                    allowedImplementations
                },
                {
                    fn getAllowedImplementations(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getAllowedImplementationsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getAllowedImplementations)
                    }
                    getAllowedImplementations
                },
                {
                    fn renounceRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn unpause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <unpauseCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SyndicateFactoryCalls::unpause)
                    }
                    unpause
                },
                {
                    fn upgradeToAndCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::upgradeToAndCall)
                    }
                    upgradeToAndCall
                },
                {
                    fn proxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::proxiableUUID)
                    }
                    proxiableUUID
                },
                {
                    fn stubImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <stubImplementationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::stubImplementation)
                    }
                    stubImplementation
                },
                {
                    fn getAppchainsAndContractsForGasTracking(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getAppchainsAndContractsForGasTrackingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                SyndicateFactoryCalls::getAppchainsAndContractsForGasTracking,
                            )
                    }
                    getAppchainsAndContractsForGasTracking
                },
                {
                    fn paused(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <pausedCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SyndicateFactoryCalls::paused)
                    }
                    paused
                },
                {
                    fn computeSequencingChainAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <computeSequencingChainAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::computeSequencingChainAddress)
                    }
                    computeSequencingChainAddress
                },
                {
                    fn createSyndicateSequencingChain(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <createSyndicateSequencingChainCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::createSyndicateSequencingChain)
                    }
                    createSyndicateSequencingChain
                },
                {
                    fn getNextNonceForSender(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getNextNonceForSenderCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getNextNonceForSender)
                    }
                    getNextNonceForSender
                },
                {
                    fn getTotalAppchainsForGasTracking(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getTotalAppchainsForGasTrackingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getTotalAppchainsForGasTracking)
                    }
                    getTotalAppchainsForGasTracking
                },
                {
                    fn appchainContracts(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <appchainContractsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::appchainContracts)
                    }
                    appchainContracts
                },
                {
                    fn isChainIdUsed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <isChainIdUsedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::isChainIdUsed)
                    }
                    isChainIdUsed
                },
                {
                    fn setDefaultImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <setDefaultImplementationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::setDefaultImplementation)
                    }
                    setDefaultImplementation
                },
                {
                    fn pause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <pauseCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SyndicateFactoryCalls::pause)
                    }
                    pause
                },
                {
                    fn banChainFromGasTracking(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <banChainFromGasTrackingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::banChainFromGasTracking)
                    }
                    banChainFromGasTracking
                },
                {
                    fn updateNamespaceConfig(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <updateNamespaceConfigCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::updateNamespaceConfig)
                    }
                    updateNamespaceConfig
                },
                {
                    fn getNextChainId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getNextChainIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getNextChainId)
                    }
                    getNextChainId
                },
                {
                    fn hasRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(SyndicateFactoryCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn nextAutoChainId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <nextAutoChainIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::nextAutoChainId)
                    }
                    nextAutoChainId
                },
                {
                    fn isChainBannedFromGasTracking(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <isChainBannedFromGasTrackingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::isChainBannedFromGasTracking)
                    }
                    isChainBannedFromGasTracking
                },
                {
                    fn generateDeterministicChainId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <generateDeterministicChainIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::generateDeterministicChainId)
                    }
                    generateDeterministicChainId
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn getContractsForGasTracking(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getContractsForGasTrackingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getContractsForGasTracking)
                    }
                    getContractsForGasTracking
                },
                {
                    fn UPGRADE_INTERFACE_VERSION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::UPGRADE_INTERFACE_VERSION)
                    }
                    UPGRADE_INTERFACE_VERSION
                },
                {
                    fn createSyndicateSequencingChainWithCustomId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <createSyndicateSequencingChainWithCustomIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                SyndicateFactoryCalls::createSyndicateSequencingChainWithCustomId,
                            )
                    }
                    createSyndicateSequencingChainWithCustomId
                },
                {
                    fn getProxyBytecode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getProxyBytecodeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getProxyBytecode)
                    }
                    getProxyBytecode
                },
                {
                    fn usedNamespaces(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <usedNamespacesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::usedNamespaces)
                    }
                    usedNamespaces
                },
                {
                    fn gasTrackingBanlist(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <gasTrackingBanlistCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::gasTrackingBanlist)
                    }
                    gasTrackingBanlist
                },
                {
                    fn initialize(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::initialize)
                    }
                    initialize
                },
                {
                    fn computeStubImplementationAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <computeStubImplementationAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::computeStubImplementationAddress)
                    }
                    computeStubImplementationAddress
                },
                {
                    fn createSyndicateSequencingChainDeterministic(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <createSyndicateSequencingChainDeterministicCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                SyndicateFactoryCalls::createSyndicateSequencingChainDeterministic,
                            )
                    }
                    createSyndicateSequencingChainDeterministic
                },
                {
                    fn revokeRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn MANAGER_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::MANAGER_ROLE)
                    }
                    MANAGER_ROLE
                },
                {
                    fn getImplBytecode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getImplBytecodeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getImplBytecode)
                    }
                    getImplBytecode
                },
                {
                    fn removeAllowedImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <removeAllowedImplementationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::removeAllowedImplementation)
                    }
                    removeAllowedImplementation
                },
                {
                    fn syndicateChainImpl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <syndicateChainImplCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryCalls::syndicateChainImpl)
                    }
                    syndicateChainImpl
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<SyndicateFactoryCalls>] = &[
                {
                    fn numberOfChainsBannedFromGasTracking(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <numberOfChainsBannedFromGasTrackingCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                SyndicateFactoryCalls::numberOfChainsBannedFromGasTracking,
                            )
                    }
                    numberOfChainsBannedFromGasTracking
                },
                {
                    fn supportsInterface(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn notifyChainUpgrade(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <notifyChainUpgradeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::notifyChainUpgrade)
                    }
                    notifyChainUpgrade
                },
                {
                    fn chainIDs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <chainIDsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::chainIDs)
                    }
                    chainIDs
                },
                {
                    fn isImplementationAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <isImplementationAllowedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::isImplementationAllowed)
                    }
                    isImplementationAllowed
                },
                {
                    fn addAllowedImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <addAllowedImplementationCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::addAllowedImplementation)
                    }
                    addAllowedImplementation
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn senderNonces(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <senderNoncesCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::senderNonces)
                    }
                    senderNonces
                },
                {
                    fn namespacePrefix(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <namespacePrefixCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::namespacePrefix)
                    }
                    namespacePrefix
                },
                {
                    fn grantRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn allowedImplementations(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <allowedImplementationsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::allowedImplementations)
                    }
                    allowedImplementations
                },
                {
                    fn getAllowedImplementations(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getAllowedImplementationsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getAllowedImplementations)
                    }
                    getAllowedImplementations
                },
                {
                    fn renounceRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn unpause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <unpauseCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::unpause)
                    }
                    unpause
                },
                {
                    fn upgradeToAndCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::upgradeToAndCall)
                    }
                    upgradeToAndCall
                },
                {
                    fn proxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::proxiableUUID)
                    }
                    proxiableUUID
                },
                {
                    fn stubImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <stubImplementationCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::stubImplementation)
                    }
                    stubImplementation
                },
                {
                    fn getAppchainsAndContractsForGasTracking(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getAppchainsAndContractsForGasTrackingCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                SyndicateFactoryCalls::getAppchainsAndContractsForGasTracking,
                            )
                    }
                    getAppchainsAndContractsForGasTracking
                },
                {
                    fn paused(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <pausedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::paused)
                    }
                    paused
                },
                {
                    fn computeSequencingChainAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <computeSequencingChainAddressCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::computeSequencingChainAddress)
                    }
                    computeSequencingChainAddress
                },
                {
                    fn createSyndicateSequencingChain(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <createSyndicateSequencingChainCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::createSyndicateSequencingChain)
                    }
                    createSyndicateSequencingChain
                },
                {
                    fn getNextNonceForSender(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getNextNonceForSenderCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getNextNonceForSender)
                    }
                    getNextNonceForSender
                },
                {
                    fn getTotalAppchainsForGasTracking(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getTotalAppchainsForGasTrackingCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getTotalAppchainsForGasTracking)
                    }
                    getTotalAppchainsForGasTracking
                },
                {
                    fn appchainContracts(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <appchainContractsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::appchainContracts)
                    }
                    appchainContracts
                },
                {
                    fn isChainIdUsed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <isChainIdUsedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::isChainIdUsed)
                    }
                    isChainIdUsed
                },
                {
                    fn setDefaultImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <setDefaultImplementationCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::setDefaultImplementation)
                    }
                    setDefaultImplementation
                },
                {
                    fn pause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <pauseCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::pause)
                    }
                    pause
                },
                {
                    fn banChainFromGasTracking(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <banChainFromGasTrackingCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::banChainFromGasTracking)
                    }
                    banChainFromGasTracking
                },
                {
                    fn updateNamespaceConfig(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <updateNamespaceConfigCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::updateNamespaceConfig)
                    }
                    updateNamespaceConfig
                },
                {
                    fn getNextChainId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getNextChainIdCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getNextChainId)
                    }
                    getNextChainId
                },
                {
                    fn hasRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn nextAutoChainId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <nextAutoChainIdCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::nextAutoChainId)
                    }
                    nextAutoChainId
                },
                {
                    fn isChainBannedFromGasTracking(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <isChainBannedFromGasTrackingCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::isChainBannedFromGasTracking)
                    }
                    isChainBannedFromGasTracking
                },
                {
                    fn generateDeterministicChainId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <generateDeterministicChainIdCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::generateDeterministicChainId)
                    }
                    generateDeterministicChainId
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn getContractsForGasTracking(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getContractsForGasTrackingCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getContractsForGasTracking)
                    }
                    getContractsForGasTracking
                },
                {
                    fn UPGRADE_INTERFACE_VERSION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::UPGRADE_INTERFACE_VERSION)
                    }
                    UPGRADE_INTERFACE_VERSION
                },
                {
                    fn createSyndicateSequencingChainWithCustomId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <createSyndicateSequencingChainWithCustomIdCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                SyndicateFactoryCalls::createSyndicateSequencingChainWithCustomId,
                            )
                    }
                    createSyndicateSequencingChainWithCustomId
                },
                {
                    fn getProxyBytecode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getProxyBytecodeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getProxyBytecode)
                    }
                    getProxyBytecode
                },
                {
                    fn usedNamespaces(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <usedNamespacesCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::usedNamespaces)
                    }
                    usedNamespaces
                },
                {
                    fn gasTrackingBanlist(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <gasTrackingBanlistCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::gasTrackingBanlist)
                    }
                    gasTrackingBanlist
                },
                {
                    fn initialize(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::initialize)
                    }
                    initialize
                },
                {
                    fn computeStubImplementationAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <computeStubImplementationAddressCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::computeStubImplementationAddress)
                    }
                    computeStubImplementationAddress
                },
                {
                    fn createSyndicateSequencingChainDeterministic(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <createSyndicateSequencingChainDeterministicCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                SyndicateFactoryCalls::createSyndicateSequencingChainDeterministic,
                            )
                    }
                    createSyndicateSequencingChainDeterministic
                },
                {
                    fn revokeRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn MANAGER_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::MANAGER_ROLE)
                    }
                    MANAGER_ROLE
                },
                {
                    fn getImplBytecode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <getImplBytecodeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::getImplBytecode)
                    }
                    getImplBytecode
                },
                {
                    fn removeAllowedImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <removeAllowedImplementationCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::removeAllowedImplementation)
                    }
                    removeAllowedImplementation
                },
                {
                    fn syndicateChainImpl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryCalls> {
                        <syndicateChainImplCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryCalls::syndicateChainImpl)
                    }
                    syndicateChainImpl
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MANAGER_ROLE(inner) => {
                    <MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::addAllowedImplementation(inner) => {
                    <addAllowedImplementationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::allowedImplementations(inner) => {
                    <allowedImplementationsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::appchainContracts(inner) => {
                    <appchainContractsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::banChainFromGasTracking(inner) => {
                    <banChainFromGasTrackingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::chainIDs(inner) => {
                    <chainIDsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::computeSequencingChainAddress(inner) => {
                    <computeSequencingChainAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::computeStubImplementationAddress(inner) => {
                    <computeStubImplementationAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::createSyndicateSequencingChain(inner) => {
                    <createSyndicateSequencingChainCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::createSyndicateSequencingChainDeterministic(inner) => {
                    <createSyndicateSequencingChainDeterministicCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::createSyndicateSequencingChainWithCustomId(inner) => {
                    <createSyndicateSequencingChainWithCustomIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::gasTrackingBanlist(inner) => {
                    <gasTrackingBanlistCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::generateDeterministicChainId(inner) => {
                    <generateDeterministicChainIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAllowedImplementations(inner) => {
                    <getAllowedImplementationsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAppchainsAndContractsForGasTracking(inner) => {
                    <getAppchainsAndContractsForGasTrackingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getContractsForGasTracking(inner) => {
                    <getContractsForGasTrackingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getImplBytecode(inner) => {
                    <getImplBytecodeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getNextChainId(inner) => {
                    <getNextChainIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getNextNonceForSender(inner) => {
                    <getNextNonceForSenderCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getProxyBytecode(inner) => {
                    <getProxyBytecodeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getTotalAppchainsForGasTracking(inner) => {
                    <getTotalAppchainsForGasTrackingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isChainBannedFromGasTracking(inner) => {
                    <isChainBannedFromGasTrackingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isChainIdUsed(inner) => {
                    <isChainIdUsedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isImplementationAllowed(inner) => {
                    <isImplementationAllowedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::namespacePrefix(inner) => {
                    <namespacePrefixCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::nextAutoChainId(inner) => {
                    <nextAutoChainIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::notifyChainUpgrade(inner) => {
                    <notifyChainUpgradeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::numberOfChainsBannedFromGasTracking(inner) => {
                    <numberOfChainsBannedFromGasTrackingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::removeAllowedImplementation(inner) => {
                    <removeAllowedImplementationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::senderNonces(inner) => {
                    <senderNoncesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setDefaultImplementation(inner) => {
                    <setDefaultImplementationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::stubImplementation(inner) => {
                    <stubImplementationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::syndicateChainImpl(inner) => {
                    <syndicateChainImplCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::updateNamespaceConfig(inner) => {
                    <updateNamespaceConfigCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::usedNamespaces(inner) => {
                    <usedNamespacesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MANAGER_ROLE(inner) => {
                    <MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::addAllowedImplementation(inner) => {
                    <addAllowedImplementationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::allowedImplementations(inner) => {
                    <allowedImplementationsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::appchainContracts(inner) => {
                    <appchainContractsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::banChainFromGasTracking(inner) => {
                    <banChainFromGasTrackingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::chainIDs(inner) => {
                    <chainIDsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::computeSequencingChainAddress(inner) => {
                    <computeSequencingChainAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::computeStubImplementationAddress(inner) => {
                    <computeStubImplementationAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::createSyndicateSequencingChain(inner) => {
                    <createSyndicateSequencingChainCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::createSyndicateSequencingChainDeterministic(inner) => {
                    <createSyndicateSequencingChainDeterministicCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::createSyndicateSequencingChainWithCustomId(inner) => {
                    <createSyndicateSequencingChainWithCustomIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::gasTrackingBanlist(inner) => {
                    <gasTrackingBanlistCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::generateDeterministicChainId(inner) => {
                    <generateDeterministicChainIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAllowedImplementations(inner) => {
                    <getAllowedImplementationsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAppchainsAndContractsForGasTracking(inner) => {
                    <getAppchainsAndContractsForGasTrackingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getContractsForGasTracking(inner) => {
                    <getContractsForGasTrackingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getImplBytecode(inner) => {
                    <getImplBytecodeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getNextChainId(inner) => {
                    <getNextChainIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getNextNonceForSender(inner) => {
                    <getNextNonceForSenderCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getProxyBytecode(inner) => {
                    <getProxyBytecodeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getTotalAppchainsForGasTracking(inner) => {
                    <getTotalAppchainsForGasTrackingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isChainBannedFromGasTracking(inner) => {
                    <isChainBannedFromGasTrackingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isChainIdUsed(inner) => {
                    <isChainIdUsedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isImplementationAllowed(inner) => {
                    <isImplementationAllowedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::namespacePrefix(inner) => {
                    <namespacePrefixCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::nextAutoChainId(inner) => {
                    <nextAutoChainIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::notifyChainUpgrade(inner) => {
                    <notifyChainUpgradeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::numberOfChainsBannedFromGasTracking(inner) => {
                    <numberOfChainsBannedFromGasTrackingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removeAllowedImplementation(inner) => {
                    <removeAllowedImplementationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::senderNonces(inner) => {
                    <senderNoncesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setDefaultImplementation(inner) => {
                    <setDefaultImplementationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::stubImplementation(inner) => {
                    <stubImplementationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::syndicateChainImpl(inner) => {
                    <syndicateChainImplCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::updateNamespaceConfig(inner) => {
                    <updateNamespaceConfigCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::usedNamespaces(inner) => {
                    <usedNamespacesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`SyndicateFactory`](self) custom errors.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum SyndicateFactoryErrors {
        #[allow(missing_docs)]
        AccessControlBadConfirmation(AccessControlBadConfirmation),
        #[allow(missing_docs)]
        AccessControlUnauthorizedAccount(AccessControlUnauthorizedAccount),
        #[allow(missing_docs)]
        AddressEmptyCode(AddressEmptyCode),
        #[allow(missing_docs)]
        CannotRemoveDefaultImplementation(CannotRemoveDefaultImplementation),
        #[allow(missing_docs)]
        ChainIdAlreadyExists(ChainIdAlreadyExists),
        #[allow(missing_docs)]
        Create2EmptyBytecode(Create2EmptyBytecode),
        #[allow(missing_docs)]
        ERC1967InvalidImplementation(ERC1967InvalidImplementation),
        #[allow(missing_docs)]
        ERC1967NonPayable(ERC1967NonPayable),
        #[allow(missing_docs)]
        EnforcedPause(EnforcedPause),
        #[allow(missing_docs)]
        ExpectedPause(ExpectedPause),
        #[allow(missing_docs)]
        FailedCall(FailedCall),
        #[allow(missing_docs)]
        FailedDeployment(FailedDeployment),
        #[allow(missing_docs)]
        FailedToUpgradeToLatestImplementation(FailedToUpgradeToLatestImplementation),
        #[allow(missing_docs)]
        ImplementationAlreadyAllowed(ImplementationAlreadyAllowed),
        #[allow(missing_docs)]
        ImplementationNotAllowed(ImplementationNotAllowed),
        #[allow(missing_docs)]
        InsufficientBalance(InsufficientBalance),
        #[allow(missing_docs)]
        InvalidInitialization(InvalidInitialization),
        #[allow(missing_docs)]
        NotInitializing(NotInitializing),
        #[allow(missing_docs)]
        OnlyChainCanNotifyUpgrade(OnlyChainCanNotifyUpgrade),
        #[allow(missing_docs)]
        StringsInvalidChar(StringsInvalidChar),
        #[allow(missing_docs)]
        UUPSUnauthorizedCallContext(UUPSUnauthorizedCallContext),
        #[allow(missing_docs)]
        UUPSUnsupportedProxiableUUID(UUPSUnsupportedProxiableUUID),
        #[allow(missing_docs)]
        ZeroAddress(ZeroAddress),
    }
    #[automatically_derived]
    impl SyndicateFactoryErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [24u8, 51u8, 162u8, 75u8],
            [36u8, 89u8, 29u8, 137u8],
            [47u8, 217u8, 173u8, 174u8],
            [76u8, 156u8, 140u8, 227u8],
            [76u8, 162u8, 73u8, 220u8],
            [102u8, 151u8, 178u8, 50u8],
            [141u8, 252u8, 32u8, 43u8],
            [148u8, 226u8, 115u8, 126u8],
            [153u8, 150u8, 179u8, 21u8],
            [170u8, 29u8, 73u8, 164u8],
            [171u8, 110u8, 181u8, 188u8],
            [176u8, 110u8, 191u8, 61u8],
            [179u8, 152u8, 151u8, 159u8],
            [207u8, 71u8, 145u8, 129u8],
            [213u8, 204u8, 74u8, 15u8],
            [214u8, 189u8, 162u8, 117u8],
            [215u8, 230u8, 188u8, 248u8],
            [217u8, 46u8, 35u8, 61u8],
            [217u8, 60u8, 6u8, 101u8],
            [224u8, 124u8, 141u8, 186u8],
            [226u8, 81u8, 125u8, 63u8],
            [249u8, 46u8, 232u8, 169u8],
            [251u8, 16u8, 24u8, 9u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndicateFactoryErrors {
        const NAME: &'static str = "SyndicateFactoryErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 23usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AccessControlBadConfirmation(_) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AccessControlUnauthorizedAccount(_) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AddressEmptyCode(_) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CannotRemoveDefaultImplementation(_) => {
                    <CannotRemoveDefaultImplementation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ChainIdAlreadyExists(_) => {
                    <ChainIdAlreadyExists as alloy_sol_types::SolError>::SELECTOR
                }
                Self::Create2EmptyBytecode(_) => {
                    <Create2EmptyBytecode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967InvalidImplementation(_) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967NonPayable(_) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EnforcedPause(_) => {
                    <EnforcedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ExpectedPause(_) => {
                    <ExpectedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FailedCall(_) => {
                    <FailedCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FailedDeployment(_) => {
                    <FailedDeployment as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FailedToUpgradeToLatestImplementation(_) => {
                    <FailedToUpgradeToLatestImplementation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ImplementationAlreadyAllowed(_) => {
                    <ImplementationAlreadyAllowed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ImplementationNotAllowed(_) => {
                    <ImplementationNotAllowed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientBalance(_) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidInitialization(_) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotInitializing(_) => {
                    <NotInitializing as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OnlyChainCanNotifyUpgrade(_) => {
                    <OnlyChainCanNotifyUpgrade as alloy_sol_types::SolError>::SELECTOR
                }
                Self::StringsInvalidChar(_) => {
                    <StringsInvalidChar as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnauthorizedCallContext(_) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnsupportedProxiableUUID(_) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAddress(_) => {
                    <ZeroAddress as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<SyndicateFactoryErrors>] = &[
                {
                    fn ImplementationAlreadyAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <ImplementationAlreadyAllowed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::ImplementationAlreadyAllowed)
                    }
                    ImplementationAlreadyAllowed
                },
                {
                    fn ChainIdAlreadyExists(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <ChainIdAlreadyExists as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::ChainIdAlreadyExists)
                    }
                    ChainIdAlreadyExists
                },
                {
                    fn OnlyChainCanNotifyUpgrade(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <OnlyChainCanNotifyUpgrade as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::OnlyChainCanNotifyUpgrade)
                    }
                    OnlyChainCanNotifyUpgrade
                },
                {
                    fn ERC1967InvalidImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::ERC1967InvalidImplementation)
                    }
                    ERC1967InvalidImplementation
                },
                {
                    fn Create2EmptyBytecode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <Create2EmptyBytecode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::Create2EmptyBytecode)
                    }
                    Create2EmptyBytecode
                },
                {
                    fn AccessControlBadConfirmation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::AccessControlBadConfirmation)
                    }
                    AccessControlBadConfirmation
                },
                {
                    fn ExpectedPause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <ExpectedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::ExpectedPause)
                    }
                    ExpectedPause
                },
                {
                    fn StringsInvalidChar(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <StringsInvalidChar as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::StringsInvalidChar)
                    }
                    StringsInvalidChar
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn UUPSUnsupportedProxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::UUPSUnsupportedProxiableUUID)
                    }
                    UUPSUnsupportedProxiableUUID
                },
                {
                    fn FailedToUpgradeToLatestImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <FailedToUpgradeToLatestImplementation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                SyndicateFactoryErrors::FailedToUpgradeToLatestImplementation,
                            )
                    }
                    FailedToUpgradeToLatestImplementation
                },
                {
                    fn FailedDeployment(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <FailedDeployment as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::FailedDeployment)
                    }
                    FailedDeployment
                },
                {
                    fn ERC1967NonPayable(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <ERC1967NonPayable as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::ERC1967NonPayable)
                    }
                    ERC1967NonPayable
                },
                {
                    fn InsufficientBalance(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <InsufficientBalance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::InsufficientBalance)
                    }
                    InsufficientBalance
                },
                {
                    fn CannotRemoveDefaultImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <CannotRemoveDefaultImplementation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                SyndicateFactoryErrors::CannotRemoveDefaultImplementation,
                            )
                    }
                    CannotRemoveDefaultImplementation
                },
                {
                    fn FailedCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(SyndicateFactoryErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn NotInitializing(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <NotInitializing as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::NotInitializing)
                    }
                    NotInitializing
                },
                {
                    fn ZeroAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <ZeroAddress as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(SyndicateFactoryErrors::ZeroAddress)
                    }
                    ZeroAddress
                },
                {
                    fn EnforcedPause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <EnforcedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::EnforcedPause)
                    }
                    EnforcedPause
                },
                {
                    fn UUPSUnauthorizedCallContext(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::UUPSUnauthorizedCallContext)
                    }
                    UUPSUnauthorizedCallContext
                },
                {
                    fn AccessControlUnauthorizedAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                SyndicateFactoryErrors::AccessControlUnauthorizedAccount,
                            )
                    }
                    AccessControlUnauthorizedAccount
                },
                {
                    fn InvalidInitialization(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <InvalidInitialization as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::InvalidInitialization)
                    }
                    InvalidInitialization
                },
                {
                    fn ImplementationNotAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <ImplementationNotAllowed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(SyndicateFactoryErrors::ImplementationNotAllowed)
                    }
                    ImplementationNotAllowed
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<SyndicateFactoryErrors>] = &[
                {
                    fn ImplementationAlreadyAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <ImplementationAlreadyAllowed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::ImplementationAlreadyAllowed)
                    }
                    ImplementationAlreadyAllowed
                },
                {
                    fn ChainIdAlreadyExists(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <ChainIdAlreadyExists as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::ChainIdAlreadyExists)
                    }
                    ChainIdAlreadyExists
                },
                {
                    fn OnlyChainCanNotifyUpgrade(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <OnlyChainCanNotifyUpgrade as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::OnlyChainCanNotifyUpgrade)
                    }
                    OnlyChainCanNotifyUpgrade
                },
                {
                    fn ERC1967InvalidImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::ERC1967InvalidImplementation)
                    }
                    ERC1967InvalidImplementation
                },
                {
                    fn Create2EmptyBytecode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <Create2EmptyBytecode as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::Create2EmptyBytecode)
                    }
                    Create2EmptyBytecode
                },
                {
                    fn AccessControlBadConfirmation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::AccessControlBadConfirmation)
                    }
                    AccessControlBadConfirmation
                },
                {
                    fn ExpectedPause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <ExpectedPause as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::ExpectedPause)
                    }
                    ExpectedPause
                },
                {
                    fn StringsInvalidChar(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <StringsInvalidChar as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::StringsInvalidChar)
                    }
                    StringsInvalidChar
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn UUPSUnsupportedProxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::UUPSUnsupportedProxiableUUID)
                    }
                    UUPSUnsupportedProxiableUUID
                },
                {
                    fn FailedToUpgradeToLatestImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <FailedToUpgradeToLatestImplementation as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                SyndicateFactoryErrors::FailedToUpgradeToLatestImplementation,
                            )
                    }
                    FailedToUpgradeToLatestImplementation
                },
                {
                    fn FailedDeployment(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <FailedDeployment as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::FailedDeployment)
                    }
                    FailedDeployment
                },
                {
                    fn ERC1967NonPayable(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <ERC1967NonPayable as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::ERC1967NonPayable)
                    }
                    ERC1967NonPayable
                },
                {
                    fn InsufficientBalance(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <InsufficientBalance as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::InsufficientBalance)
                    }
                    InsufficientBalance
                },
                {
                    fn CannotRemoveDefaultImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <CannotRemoveDefaultImplementation as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                SyndicateFactoryErrors::CannotRemoveDefaultImplementation,
                            )
                    }
                    CannotRemoveDefaultImplementation
                },
                {
                    fn FailedCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn NotInitializing(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <NotInitializing as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::NotInitializing)
                    }
                    NotInitializing
                },
                {
                    fn ZeroAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <ZeroAddress as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::ZeroAddress)
                    }
                    ZeroAddress
                },
                {
                    fn EnforcedPause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <EnforcedPause as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::EnforcedPause)
                    }
                    EnforcedPause
                },
                {
                    fn UUPSUnauthorizedCallContext(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::UUPSUnauthorizedCallContext)
                    }
                    UUPSUnauthorizedCallContext
                },
                {
                    fn AccessControlUnauthorizedAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                SyndicateFactoryErrors::AccessControlUnauthorizedAccount,
                            )
                    }
                    AccessControlUnauthorizedAccount
                },
                {
                    fn InvalidInitialization(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <InvalidInitialization as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::InvalidInitialization)
                    }
                    InvalidInitialization
                },
                {
                    fn ImplementationNotAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<SyndicateFactoryErrors> {
                        <ImplementationNotAllowed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(SyndicateFactoryErrors::ImplementationNotAllowed)
                    }
                    ImplementationNotAllowed
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CannotRemoveDefaultImplementation(inner) => {
                    <CannotRemoveDefaultImplementation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ChainIdAlreadyExists(inner) => {
                    <ChainIdAlreadyExists as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::Create2EmptyBytecode(inner) => {
                    <Create2EmptyBytecode as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::FailedDeployment(inner) => {
                    <FailedDeployment as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::FailedToUpgradeToLatestImplementation(inner) => {
                    <FailedToUpgradeToLatestImplementation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ImplementationAlreadyAllowed(inner) => {
                    <ImplementationAlreadyAllowed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ImplementationNotAllowed(inner) => {
                    <ImplementationNotAllowed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientBalance(inner) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OnlyChainCanNotifyUpgrade(inner) => {
                    <OnlyChainCanNotifyUpgrade as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::StringsInvalidChar(inner) => {
                    <StringsInvalidChar as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CannotRemoveDefaultImplementation(inner) => {
                    <CannotRemoveDefaultImplementation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ChainIdAlreadyExists(inner) => {
                    <ChainIdAlreadyExists as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::Create2EmptyBytecode(inner) => {
                    <Create2EmptyBytecode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::FailedDeployment(inner) => {
                    <FailedDeployment as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FailedToUpgradeToLatestImplementation(inner) => {
                    <FailedToUpgradeToLatestImplementation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ImplementationAlreadyAllowed(inner) => {
                    <ImplementationAlreadyAllowed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ImplementationNotAllowed(inner) => {
                    <ImplementationNotAllowed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientBalance(inner) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OnlyChainCanNotifyUpgrade(inner) => {
                    <OnlyChainCanNotifyUpgrade as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::StringsInvalidChar(inner) => {
                    <StringsInvalidChar as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`SyndicateFactory`](self) events.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum SyndicateFactoryEvents {
        #[allow(missing_docs)]
        ChainBannedFromGasTracking(ChainBannedFromGasTracking),
        #[allow(missing_docs)]
        ChainIdManuallyMarked(ChainIdManuallyMarked),
        #[allow(missing_docs)]
        DeterministicChainIdGenerated(DeterministicChainIdGenerated),
        #[allow(missing_docs)]
        ImplementationAdded(ImplementationAdded),
        #[allow(missing_docs)]
        Initialized(Initialized),
        #[allow(missing_docs)]
        NamespaceConfigUpdated(NamespaceConfigUpdated),
        #[allow(missing_docs)]
        Paused(Paused),
        #[allow(missing_docs)]
        RoleAdminChanged(RoleAdminChanged),
        #[allow(missing_docs)]
        RoleGranted(RoleGranted),
        #[allow(missing_docs)]
        RoleRevoked(RoleRevoked),
        #[allow(missing_docs)]
        SyndicateSequencingChainCreated(SyndicateSequencingChainCreated),
        #[allow(missing_docs)]
        Unpaused(Unpaused),
        #[allow(missing_docs)]
        Upgraded(Upgraded),
    }
    #[automatically_derived]
    impl SyndicateFactoryEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                33u8, 194u8, 92u8, 208u8, 165u8, 78u8, 22u8, 9u8, 227u8, 230u8, 139u8,
                51u8, 86u8, 147u8, 238u8, 251u8, 105u8, 77u8, 94u8, 241u8, 124u8, 195u8,
                43u8, 16u8, 111u8, 145u8, 63u8, 138u8, 31u8, 27u8, 128u8, 88u8,
            ],
            [
                47u8, 135u8, 136u8, 17u8, 126u8, 126u8, 255u8, 29u8, 130u8, 233u8, 38u8,
                236u8, 121u8, 73u8, 1u8, 209u8, 124u8, 120u8, 2u8, 74u8, 80u8, 39u8, 9u8,
                64u8, 48u8, 69u8, 64u8, 167u8, 51u8, 101u8, 111u8, 13u8,
            ],
            [
                51u8, 28u8, 237u8, 199u8, 31u8, 40u8, 196u8, 109u8, 70u8, 118u8, 145u8,
                119u8, 6u8, 117u8, 181u8, 134u8, 232u8, 170u8, 119u8, 160u8, 212u8,
                254u8, 9u8, 242u8, 87u8, 208u8, 30u8, 240u8, 11u8, 193u8, 84u8, 88u8,
            ],
            [
                73u8, 178u8, 31u8, 30u8, 65u8, 144u8, 219u8, 139u8, 10u8, 147u8, 60u8,
                149u8, 30u8, 208u8, 19u8, 222u8, 34u8, 44u8, 132u8, 124u8, 21u8, 70u8,
                23u8, 84u8, 104u8, 45u8, 170u8, 46u8, 171u8, 31u8, 219u8, 210u8,
            ],
            [
                85u8, 1u8, 148u8, 102u8, 138u8, 7u8, 42u8, 124u8, 125u8, 175u8, 18u8,
                183u8, 117u8, 26u8, 82u8, 71u8, 138u8, 138u8, 18u8, 222u8, 11u8, 159u8,
                85u8, 113u8, 98u8, 210u8, 128u8, 251u8, 140u8, 116u8, 244u8, 115u8,
            ],
            [
                93u8, 185u8, 238u8, 10u8, 73u8, 91u8, 242u8, 230u8, 255u8, 156u8, 145u8,
                167u8, 131u8, 76u8, 27u8, 164u8, 253u8, 210u8, 68u8, 165u8, 232u8, 170u8,
                78u8, 83u8, 123u8, 211u8, 138u8, 234u8, 228u8, 176u8, 115u8, 170u8,
            ],
            [
                98u8, 231u8, 140u8, 234u8, 1u8, 190u8, 227u8, 32u8, 205u8, 78u8, 66u8,
                2u8, 112u8, 181u8, 234u8, 116u8, 0u8, 13u8, 17u8, 176u8, 201u8, 247u8,
                71u8, 84u8, 235u8, 219u8, 252u8, 84u8, 75u8, 5u8, 162u8, 88u8,
            ],
            [
                188u8, 124u8, 215u8, 90u8, 32u8, 238u8, 39u8, 253u8, 154u8, 222u8, 186u8,
                179u8, 32u8, 65u8, 247u8, 85u8, 33u8, 77u8, 188u8, 107u8, 255u8, 169u8,
                12u8, 192u8, 34u8, 91u8, 57u8, 218u8, 46u8, 92u8, 45u8, 59u8,
            ],
            [
                189u8, 121u8, 184u8, 111u8, 254u8, 10u8, 184u8, 232u8, 119u8, 97u8, 81u8,
                81u8, 66u8, 23u8, 205u8, 124u8, 172u8, 213u8, 44u8, 144u8, 159u8, 102u8,
                71u8, 92u8, 58u8, 244u8, 78u8, 18u8, 159u8, 11u8, 0u8, 255u8,
            ],
            [
                199u8, 245u8, 5u8, 178u8, 243u8, 113u8, 174u8, 33u8, 117u8, 238u8, 73u8,
                19u8, 244u8, 73u8, 158u8, 31u8, 38u8, 51u8, 167u8, 181u8, 147u8, 99u8,
                33u8, 238u8, 209u8, 205u8, 174u8, 182u8, 17u8, 81u8, 129u8, 210u8,
            ],
            [
                217u8, 225u8, 35u8, 145u8, 119u8, 191u8, 189u8, 42u8, 235u8, 245u8,
                208u8, 242u8, 15u8, 192u8, 117u8, 230u8, 223u8, 90u8, 80u8, 44u8, 89u8,
                209u8, 33u8, 172u8, 213u8, 115u8, 66u8, 199u8, 131u8, 227u8, 19u8, 100u8,
            ],
            [
                235u8, 180u8, 197u8, 13u8, 235u8, 40u8, 81u8, 146u8, 209u8, 194u8, 170u8,
                136u8, 50u8, 177u8, 254u8, 235u8, 7u8, 139u8, 160u8, 253u8, 146u8, 187u8,
                67u8, 156u8, 13u8, 238u8, 40u8, 235u8, 233u8, 187u8, 54u8, 233u8,
            ],
            [
                246u8, 57u8, 31u8, 92u8, 50u8, 217u8, 198u8, 157u8, 42u8, 71u8, 234u8,
                103u8, 11u8, 68u8, 41u8, 116u8, 181u8, 57u8, 53u8, 209u8, 237u8, 199u8,
                253u8, 100u8, 235u8, 33u8, 224u8, 71u8, 168u8, 57u8, 23u8, 27u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for SyndicateFactoryEvents {
        const NAME: &'static str = "SyndicateFactoryEvents";
        const COUNT: usize = 13usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <ChainBannedFromGasTracking as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ChainBannedFromGasTracking as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ChainBannedFromGasTracking)
                }
                Some(
                    <ChainIdManuallyMarked as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ChainIdManuallyMarked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ChainIdManuallyMarked)
                }
                Some(
                    <DeterministicChainIdGenerated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <DeterministicChainIdGenerated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::DeterministicChainIdGenerated)
                }
                Some(
                    <ImplementationAdded as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ImplementationAdded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ImplementationAdded)
                }
                Some(<Initialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::Initialized)
                }
                Some(
                    <NamespaceConfigUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <NamespaceConfigUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::NamespaceConfigUpdated)
                }
                Some(<Paused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Paused as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Paused)
                }
                Some(<RoleAdminChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleAdminChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoleAdminChanged)
                }
                Some(<RoleGranted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleGranted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoleGranted)
                }
                Some(<RoleRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoleRevoked)
                }
                Some(
                    <SyndicateSequencingChainCreated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <SyndicateSequencingChainCreated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::SyndicateSequencingChainCreated)
                }
                Some(<Unpaused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Unpaused as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Unpaused)
                }
                Some(<Upgraded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Upgraded as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Upgraded)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for SyndicateFactoryEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ChainBannedFromGasTracking(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ChainIdManuallyMarked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DeterministicChainIdGenerated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ImplementationAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::NamespaceConfigUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SyndicateSequencingChainCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ChainBannedFromGasTracking(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ChainIdManuallyMarked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DeterministicChainIdGenerated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ImplementationAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::NamespaceConfigUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SyndicateSequencingChainCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`SyndicateFactory`](self) contract instance.

See the [wrapper's documentation](`SyndicateFactoryInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> SyndicateFactoryInstance<P, N> {
        SyndicateFactoryInstance::<P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<SyndicateFactoryInstance<P, N>>,
    > {
        SyndicateFactoryInstance::<P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<P, N> {
        SyndicateFactoryInstance::<P, N>::deploy_builder(provider)
    }
    /**A [`SyndicateFactory`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`SyndicateFactory`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct SyndicateFactoryInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for SyndicateFactoryInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("SyndicateFactoryInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > SyndicateFactoryInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`SyndicateFactory`](self) contract instance.

See the [wrapper's documentation](`SyndicateFactoryInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<SyndicateFactoryInstance<P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> SyndicateFactoryInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> SyndicateFactoryInstance<P, N> {
            SyndicateFactoryInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > SyndicateFactoryInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`DEFAULT_ADMIN_ROLE`] function.
        pub fn DEFAULT_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, DEFAULT_ADMIN_ROLECall, N> {
            self.call_builder(&DEFAULT_ADMIN_ROLECall)
        }
        ///Creates a new call builder for the [`MANAGER_ROLE`] function.
        pub fn MANAGER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, MANAGER_ROLECall, N> {
            self.call_builder(&MANAGER_ROLECall)
        }
        ///Creates a new call builder for the [`UPGRADE_INTERFACE_VERSION`] function.
        pub fn UPGRADE_INTERFACE_VERSION(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, UPGRADE_INTERFACE_VERSIONCall, N> {
            self.call_builder(&UPGRADE_INTERFACE_VERSIONCall)
        }
        ///Creates a new call builder for the [`addAllowedImplementation`] function.
        pub fn addAllowedImplementation(
            &self,
            implementation: alloy::sol_types::private::Address,
            makeDefault: bool,
        ) -> alloy_contract::SolCallBuilder<&P, addAllowedImplementationCall, N> {
            self.call_builder(
                &addAllowedImplementationCall {
                    implementation,
                    makeDefault,
                },
            )
        }
        ///Creates a new call builder for the [`allowedImplementations`] function.
        pub fn allowedImplementations(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, allowedImplementationsCall, N> {
            self.call_builder(&allowedImplementationsCall(_0))
        }
        ///Creates a new call builder for the [`appchainContracts`] function.
        pub fn appchainContracts(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, appchainContractsCall, N> {
            self.call_builder(&appchainContractsCall(_0))
        }
        ///Creates a new call builder for the [`banChainFromGasTracking`] function.
        pub fn banChainFromGasTracking(
            &self,
            chainId: alloy::sol_types::private::primitives::aliases::U256,
            notAllowedImplementation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, banChainFromGasTrackingCall, N> {
            self.call_builder(
                &banChainFromGasTrackingCall {
                    chainId,
                    notAllowedImplementation,
                },
            )
        }
        ///Creates a new call builder for the [`chainIDs`] function.
        pub fn chainIDs(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, chainIDsCall, N> {
            self.call_builder(&chainIDsCall(_0))
        }
        ///Creates a new call builder for the [`computeSequencingChainAddress`] function.
        pub fn computeSequencingChainAddress(
            &self,
            chainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, computeSequencingChainAddressCall, N> {
            self.call_builder(
                &computeSequencingChainAddressCall {
                    chainId,
                },
            )
        }
        ///Creates a new call builder for the [`computeStubImplementationAddress`] function.
        pub fn computeStubImplementationAddress(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            &P,
            computeStubImplementationAddressCall,
            N,
        > {
            self.call_builder(&computeStubImplementationAddressCall)
        }
        ///Creates a new call builder for the [`createSyndicateSequencingChain`] function.
        pub fn createSyndicateSequencingChain(
            &self,
            appchainId: alloy::sol_types::private::primitives::aliases::U256,
            admin: alloy::sol_types::private::Address,
            permissionModule: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, createSyndicateSequencingChainCall, N> {
            self.call_builder(
                &createSyndicateSequencingChainCall {
                    appchainId,
                    admin,
                    permissionModule,
                },
            )
        }
        ///Creates a new call builder for the [`createSyndicateSequencingChainDeterministic`] function.
        pub fn createSyndicateSequencingChainDeterministic(
            &self,
            nonce: alloy::sol_types::private::primitives::aliases::U256,
            admin: alloy::sol_types::private::Address,
            permissionModule: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<
            &P,
            createSyndicateSequencingChainDeterministicCall,
            N,
        > {
            self.call_builder(
                &createSyndicateSequencingChainDeterministicCall {
                    nonce,
                    admin,
                    permissionModule,
                },
            )
        }
        ///Creates a new call builder for the [`createSyndicateSequencingChainWithCustomId`] function.
        pub fn createSyndicateSequencingChainWithCustomId(
            &self,
            customChainId: alloy::sol_types::private::primitives::aliases::U256,
            admin: alloy::sol_types::private::Address,
            permissionModule: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<
            &P,
            createSyndicateSequencingChainWithCustomIdCall,
            N,
        > {
            self.call_builder(
                &createSyndicateSequencingChainWithCustomIdCall {
                    customChainId,
                    admin,
                    permissionModule,
                },
            )
        }
        ///Creates a new call builder for the [`gasTrackingBanlist`] function.
        pub fn gasTrackingBanlist(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, gasTrackingBanlistCall, N> {
            self.call_builder(&gasTrackingBanlistCall(_0))
        }
        ///Creates a new call builder for the [`generateDeterministicChainId`] function.
        pub fn generateDeterministicChainId(
            &self,
            sender: alloy::sol_types::private::Address,
            nonce: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, generateDeterministicChainIdCall, N> {
            self.call_builder(
                &generateDeterministicChainIdCall {
                    sender,
                    nonce,
                },
            )
        }
        ///Creates a new call builder for the [`getAllowedImplementations`] function.
        pub fn getAllowedImplementations(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getAllowedImplementationsCall, N> {
            self.call_builder(&getAllowedImplementationsCall)
        }
        ///Creates a new call builder for the [`getAppchainsAndContractsForGasTracking`] function.
        pub fn getAppchainsAndContractsForGasTracking(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            &P,
            getAppchainsAndContractsForGasTrackingCall,
            N,
        > {
            self.call_builder(&getAppchainsAndContractsForGasTrackingCall)
        }
        ///Creates a new call builder for the [`getContractsForGasTracking`] function.
        pub fn getContractsForGasTracking(
            &self,
            _chainIDs: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
        ) -> alloy_contract::SolCallBuilder<&P, getContractsForGasTrackingCall, N> {
            self.call_builder(
                &getContractsForGasTrackingCall {
                    _chainIDs,
                },
            )
        }
        ///Creates a new call builder for the [`getImplBytecode`] function.
        pub fn getImplBytecode(
            &self,
            r#impl: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getImplBytecodeCall, N> {
            self.call_builder(&getImplBytecodeCall { r#impl })
        }
        ///Creates a new call builder for the [`getNextChainId`] function.
        pub fn getNextChainId(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getNextChainIdCall, N> {
            self.call_builder(&getNextChainIdCall)
        }
        ///Creates a new call builder for the [`getNextNonceForSender`] function.
        pub fn getNextNonceForSender(
            &self,
            sender: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getNextNonceForSenderCall, N> {
            self.call_builder(
                &getNextNonceForSenderCall {
                    sender,
                },
            )
        }
        ///Creates a new call builder for the [`getProxyBytecode`] function.
        pub fn getProxyBytecode(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getProxyBytecodeCall, N> {
            self.call_builder(&getProxyBytecodeCall)
        }
        ///Creates a new call builder for the [`getRoleAdmin`] function.
        pub fn getRoleAdmin(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, getRoleAdminCall, N> {
            self.call_builder(&getRoleAdminCall { role })
        }
        ///Creates a new call builder for the [`getTotalAppchainsForGasTracking`] function.
        pub fn getTotalAppchainsForGasTracking(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getTotalAppchainsForGasTrackingCall, N> {
            self.call_builder(&getTotalAppchainsForGasTrackingCall)
        }
        ///Creates a new call builder for the [`grantRole`] function.
        pub fn grantRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, grantRoleCall, N> {
            self.call_builder(&grantRoleCall { role, account })
        }
        ///Creates a new call builder for the [`hasRole`] function.
        pub fn hasRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, hasRoleCall, N> {
            self.call_builder(&hasRoleCall { role, account })
        }
        ///Creates a new call builder for the [`initialize`] function.
        pub fn initialize(
            &self,
            admin: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, initializeCall, N> {
            self.call_builder(&initializeCall { admin })
        }
        ///Creates a new call builder for the [`isChainBannedFromGasTracking`] function.
        pub fn isChainBannedFromGasTracking(
            &self,
            chainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, isChainBannedFromGasTrackingCall, N> {
            self.call_builder(
                &isChainBannedFromGasTrackingCall {
                    chainId,
                },
            )
        }
        ///Creates a new call builder for the [`isChainIdUsed`] function.
        pub fn isChainIdUsed(
            &self,
            chainId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, isChainIdUsedCall, N> {
            self.call_builder(&isChainIdUsedCall { chainId })
        }
        ///Creates a new call builder for the [`isImplementationAllowed`] function.
        pub fn isImplementationAllowed(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, isImplementationAllowedCall, N> {
            self.call_builder(&isImplementationAllowedCall(_0))
        }
        ///Creates a new call builder for the [`namespacePrefix`] function.
        pub fn namespacePrefix(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, namespacePrefixCall, N> {
            self.call_builder(&namespacePrefixCall)
        }
        ///Creates a new call builder for the [`nextAutoChainId`] function.
        pub fn nextAutoChainId(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, nextAutoChainIdCall, N> {
            self.call_builder(&nextAutoChainIdCall)
        }
        ///Creates a new call builder for the [`notifyChainUpgrade`] function.
        pub fn notifyChainUpgrade(
            &self,
            chainId: alloy::sol_types::private::primitives::aliases::U256,
            newImplementation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, notifyChainUpgradeCall, N> {
            self.call_builder(
                &notifyChainUpgradeCall {
                    chainId,
                    newImplementation,
                },
            )
        }
        ///Creates a new call builder for the [`numberOfChainsBannedFromGasTracking`] function.
        pub fn numberOfChainsBannedFromGasTracking(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            &P,
            numberOfChainsBannedFromGasTrackingCall,
            N,
        > {
            self.call_builder(&numberOfChainsBannedFromGasTrackingCall)
        }
        ///Creates a new call builder for the [`pause`] function.
        pub fn pause(&self) -> alloy_contract::SolCallBuilder<&P, pauseCall, N> {
            self.call_builder(&pauseCall)
        }
        ///Creates a new call builder for the [`paused`] function.
        pub fn paused(&self) -> alloy_contract::SolCallBuilder<&P, pausedCall, N> {
            self.call_builder(&pausedCall)
        }
        ///Creates a new call builder for the [`proxiableUUID`] function.
        pub fn proxiableUUID(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, proxiableUUIDCall, N> {
            self.call_builder(&proxiableUUIDCall)
        }
        ///Creates a new call builder for the [`removeAllowedImplementation`] function.
        pub fn removeAllowedImplementation(
            &self,
            implementation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, removeAllowedImplementationCall, N> {
            self.call_builder(
                &removeAllowedImplementationCall {
                    implementation,
                },
            )
        }
        ///Creates a new call builder for the [`renounceRole`] function.
        pub fn renounceRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            callerConfirmation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, renounceRoleCall, N> {
            self.call_builder(
                &renounceRoleCall {
                    role,
                    callerConfirmation,
                },
            )
        }
        ///Creates a new call builder for the [`revokeRole`] function.
        pub fn revokeRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, revokeRoleCall, N> {
            self.call_builder(&revokeRoleCall { role, account })
        }
        ///Creates a new call builder for the [`senderNonces`] function.
        pub fn senderNonces(
            &self,
            sender: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, senderNoncesCall, N> {
            self.call_builder(&senderNoncesCall { sender })
        }
        ///Creates a new call builder for the [`setDefaultImplementation`] function.
        pub fn setDefaultImplementation(
            &self,
            implementation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, setDefaultImplementationCall, N> {
            self.call_builder(
                &setDefaultImplementationCall {
                    implementation,
                },
            )
        }
        ///Creates a new call builder for the [`stubImplementation`] function.
        pub fn stubImplementation(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, stubImplementationCall, N> {
            self.call_builder(&stubImplementationCall)
        }
        ///Creates a new call builder for the [`supportsInterface`] function.
        pub fn supportsInterface(
            &self,
            interfaceId: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<&P, supportsInterfaceCall, N> {
            self.call_builder(
                &supportsInterfaceCall {
                    interfaceId,
                },
            )
        }
        ///Creates a new call builder for the [`syndicateChainImpl`] function.
        pub fn syndicateChainImpl(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, syndicateChainImplCall, N> {
            self.call_builder(&syndicateChainImplCall)
        }
        ///Creates a new call builder for the [`unpause`] function.
        pub fn unpause(&self) -> alloy_contract::SolCallBuilder<&P, unpauseCall, N> {
            self.call_builder(&unpauseCall)
        }
        ///Creates a new call builder for the [`updateNamespaceConfig`] function.
        pub fn updateNamespaceConfig(
            &self,
            newPrefix: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, updateNamespaceConfigCall, N> {
            self.call_builder(
                &updateNamespaceConfigCall {
                    newPrefix,
                },
            )
        }
        ///Creates a new call builder for the [`upgradeToAndCall`] function.
        pub fn upgradeToAndCall(
            &self,
            newImplementation: alloy::sol_types::private::Address,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, upgradeToAndCallCall, N> {
            self.call_builder(
                &upgradeToAndCallCall {
                    newImplementation,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`usedNamespaces`] function.
        pub fn usedNamespaces(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, usedNamespacesCall, N> {
            self.call_builder(&usedNamespacesCall(_0))
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > SyndicateFactoryInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`ChainBannedFromGasTracking`] event.
        pub fn ChainBannedFromGasTracking_filter(
            &self,
        ) -> alloy_contract::Event<&P, ChainBannedFromGasTracking, N> {
            self.event_filter::<ChainBannedFromGasTracking>()
        }
        ///Creates a new event filter for the [`ChainIdManuallyMarked`] event.
        pub fn ChainIdManuallyMarked_filter(
            &self,
        ) -> alloy_contract::Event<&P, ChainIdManuallyMarked, N> {
            self.event_filter::<ChainIdManuallyMarked>()
        }
        ///Creates a new event filter for the [`DeterministicChainIdGenerated`] event.
        pub fn DeterministicChainIdGenerated_filter(
            &self,
        ) -> alloy_contract::Event<&P, DeterministicChainIdGenerated, N> {
            self.event_filter::<DeterministicChainIdGenerated>()
        }
        ///Creates a new event filter for the [`ImplementationAdded`] event.
        pub fn ImplementationAdded_filter(
            &self,
        ) -> alloy_contract::Event<&P, ImplementationAdded, N> {
            self.event_filter::<ImplementationAdded>()
        }
        ///Creates a new event filter for the [`Initialized`] event.
        pub fn Initialized_filter(&self) -> alloy_contract::Event<&P, Initialized, N> {
            self.event_filter::<Initialized>()
        }
        ///Creates a new event filter for the [`NamespaceConfigUpdated`] event.
        pub fn NamespaceConfigUpdated_filter(
            &self,
        ) -> alloy_contract::Event<&P, NamespaceConfigUpdated, N> {
            self.event_filter::<NamespaceConfigUpdated>()
        }
        ///Creates a new event filter for the [`Paused`] event.
        pub fn Paused_filter(&self) -> alloy_contract::Event<&P, Paused, N> {
            self.event_filter::<Paused>()
        }
        ///Creates a new event filter for the [`RoleAdminChanged`] event.
        pub fn RoleAdminChanged_filter(
            &self,
        ) -> alloy_contract::Event<&P, RoleAdminChanged, N> {
            self.event_filter::<RoleAdminChanged>()
        }
        ///Creates a new event filter for the [`RoleGranted`] event.
        pub fn RoleGranted_filter(&self) -> alloy_contract::Event<&P, RoleGranted, N> {
            self.event_filter::<RoleGranted>()
        }
        ///Creates a new event filter for the [`RoleRevoked`] event.
        pub fn RoleRevoked_filter(&self) -> alloy_contract::Event<&P, RoleRevoked, N> {
            self.event_filter::<RoleRevoked>()
        }
        ///Creates a new event filter for the [`SyndicateSequencingChainCreated`] event.
        pub fn SyndicateSequencingChainCreated_filter(
            &self,
        ) -> alloy_contract::Event<&P, SyndicateSequencingChainCreated, N> {
            self.event_filter::<SyndicateSequencingChainCreated>()
        }
        ///Creates a new event filter for the [`Unpaused`] event.
        pub fn Unpaused_filter(&self) -> alloy_contract::Event<&P, Unpaused, N> {
            self.event_filter::<Unpaused>()
        }
        ///Creates a new event filter for the [`Upgraded`] event.
        pub fn Upgraded_filter(&self) -> alloy_contract::Event<&P, Upgraded, N> {
            self.event_filter::<Upgraded>()
        }
    }
}
