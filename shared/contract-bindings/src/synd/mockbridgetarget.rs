/**

Generated by the following Solidity interface...
```solidity
interface MockBridgeTarget {
    struct BridgeCall {
        address token;
        uint256 amount;
        bytes data;
        uint256 value;
    }

    fallback() external payable;

    receive() external payable;

    function bridgeCalls(uint256) external view returns (address token, uint256 amount, bytes memory data, uint256 value);
    function bridgeTokens(address token, uint256 amount, bytes memory data) external payable;
    function getBridgeCallCount() external view returns (uint256);
    function getLastBridgeCall() external view returns (BridgeCall memory);
    function setShouldRevert(bool _shouldRevert) external;
    function shouldRevert() external view returns (bool);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "fallback",
    "stateMutability": "payable"
  },
  {
    "type": "receive",
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "bridgeCalls",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeTokens",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "getBridgeCallCount",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getLastBridgeCall",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct MockBridgeTarget.BridgeCall",
        "components": [
          {
            "name": "token",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "data",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "value",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setShouldRevert",
    "inputs": [
      {
        "name": "_shouldRevert",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "shouldRevert",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod MockBridgeTarget {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x608060405234601c57600e6020565b6111aa61002b82396111aa90f35b6026565b60405190565b5f80fdfe60806040526004361015610028575b361561001e5761001c611124565b005b6100266110df565b005b6100325f35610091565b8063246ce2c61461008c5780633ae0d321146100875780636813d78714610082578063c759c78e1461007d578063d3072d82146100785763d71f00a10361000e57610732565b610423565b610395565b61027f565b6101fb565b6101a4565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f9103126100af57565b6100a1565b60018060a01b031690565b6100c8906100b4565b90565b6100d4906100bf565b9052565b90565b6100e4906100d8565b9052565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b61012961013260209361013793610120816100e8565b938480936100ec565b958691016100f5565b610100565b0190565b906101899060608061017e6080840161015a5f8801515f8701906100cb565b61016c602088015160208701906100db565b6040870151858203604087015261010a565b9401519101906100db565b90565b6101a19160208201915f81840391015261013b565b90565b346101d4576101b43660046100a5565b6101d06101bf61097c565b6101c7610097565b9182918261018c565b0390f35b61009d565b6101e2906100d8565b9052565b91906101f9905f602085019401906101d9565b565b3461022b5761020b3660046100a5565b6102276102166109df565b61021e610097565b918291826101e6565b0390f35b61009d565b5f80fd5b151590565b61024281610234565b0361024957565b5f80fd5b9050359061025a82610239565b565b9060208282031261027557610272915f0161024d565b90565b6100a1565b5f0190565b346102ad5761029761029236600461025c565b610a3e565b61029f610097565b806102a98161027a565b0390f35b61009d565b6102bb816100bf565b036102c257565b5f80fd5b905035906102d3826102b2565b565b6102de816100d8565b036102e557565b5f80fd5b905035906102f6826102d5565b565b5f80fd5b5f80fd5b5f80fd5b909182601f8301121561033e5781359167ffffffffffffffff831161033957602001926001830284011161033457565b610300565b6102fc565b6102f8565b916060838303126103905761035a825f85016102c6565b9261036883602083016102e9565b92604082013567ffffffffffffffff811161038b576103879201610304565b9091565b610230565b6100a1565b6103ac6103a3366004610343565b92919091610fd7565b6103b4610097565b806103be8161027a565b0390f35b1c90565b60ff1690565b6103dc9060086103e193026103c2565b6103c6565b90565b906103ef91546103cc565b90565b6103fe60015f906103e4565b90565b61040a90610234565b9052565b9190610421905f60208501940190610401565b565b34610453576104333660046100a5565b61044f61043e6103f2565b610446610097565b9182918261040e565b0390f35b61009d565b906020828203126104715761046e915f016102e9565b90565b6100a1565b634e487b7160e01b5f52603260045260245ffd5b5490565b5f5260205f2090565b6104a08161048a565b8210156104ba576104b260049161048e565b910201905f90565b610476565b5f1c90565b60018060a01b031690565b6104db6104e0916104bf565b6104c4565b90565b6104ed90546104cf565b90565b90565b6104ff610504916104bf565b6104f0565b90565b61051190546104f3565b90565b634e487b7160e01b5f52602260045260245ffd5b9060016002830492168015610548575b602083101461054357565b610514565b91607f1691610538565b5f5260205f2090565b905f929180549061057561056e83610528565b80946100ec565b916001811690815f146105cc5750600114610590575b505050565b61059d9192939450610552565b915f925b8184106105b457505001905f808061058b565b600181602092959395548486015201910192906105a1565b92949550505060ff19168252151560200201905f808061058b565b906105f19161055b565b90565b634e487b7160e01b5f52604160045260245ffd5b9061061290610100565b810190811067ffffffffffffffff82111761062c57604052565b6105f4565b9061065161064a92610641610097565b938480926105e7565b0383610608565b565b5f9061065e8261048a565b8110156106a45761066e91610497565b509061067b5f83016104e3565b9161068860018201610507565b916106a1600361069a60028501610631565b9301610507565b90565b5f80fd5b6106b1906100bf565b9052565b60209181520190565b6106dd6106e66020936106eb936106d4816100e8565b938480936106b5565b958691016100f5565b610100565b0190565b9493916060916107309461071b6107289361071160808b01945f8c01906106a8565b60208a01906101d9565b87820360408901526106be565b9401906101d9565b565b346107665761076261074d610748366004610458565b610653565b90610759949294610097565b948594856106ef565b0390f35b61009d565b9061077e610777610097565b9283610608565b565b61078a608061076b565b90565b5f90565b5f90565b606090565b6107a2610780565b906020808080856107b161078d565b8152016107bc610791565b8152016107c7610795565b8152016107d2610791565b81525050565b6107e061079a565b90565b90565b90565b6107fd6107f8610802926107e3565b6107e6565b6100d8565b90565b60209181520190565b5f7f4e6f206272696467652063616c6c730000000000000000000000000000000000910152565b610842600f602092610805565b61084b8161080e565b0190565b6108649060208101905f818303910152610835565b90565b1561086e57565b610876610097565b62461bcd60e51b81528061088c6004820161084f565b0390fd5b90565b6108a76108a26108ac92610890565b6107e6565b6100d8565b90565b634e487b7160e01b5f52601160045260245ffd5b6108d26108d8919392936100d8565b926100d8565b82039182116108e357565b6108af565b906108f2906100bf565b9052565b90610900906100d8565b9052565b52565b9061096e6109656003610918610780565b9461092f6109275f83016104e3565b5f88016108e8565b61094761093e60018301610507565b602088016108f6565b61095f61095660028301610631565b60408801610904565b01610507565b606084016108f6565b565b61097990610907565b90565b6109846107d8565b506109a96109915f61048a565b6109a361099d5f6107e9565b916100d8565b11610867565b6109d86109d25f6109cc6109bc5f61048a565b6109c66001610893565b906108c3565b90610497565b50610970565b90565b5f90565b6109e76109db565b506109f15f61048a565b90565b5f1b90565b90610a0560ff916109f4565b9181191691161790565b610a1890610234565b90565b90565b90610a33610a2e610a3a92610a0f565b610a1b565b82546109f9565b9055565b610a49906001610a1e565b565b610a57610a5c916104bf565b6103c6565b90565b610a699054610a4b565b90565b5f7f4d6f636b4272696467653a20666f726365642072657665727400000000000000910152565b610aa06019602092610805565b610aa981610a6c565b0190565b610ac29060208101905f818303910152610a93565b90565b15610acc57565b610ad4610097565b62461bcd60e51b815280610aea60048201610aad565b0390fd5b610b02610afd610b07926100b4565b6107e6565b6100b4565b90565b610b1390610aee565b90565b610b1f90610b0a565b90565b610b2b90610aee565b90565b610b3790610b22565b90565b610b4390610b22565b90565b60e01b90565b90505190610b5982610239565b565b90602082820312610b7457610b71915f01610b4c565b90565b6100a1565b604090610ba2610ba99496959396610b9860608401985f8501906106a8565b60208301906106a8565b01906101d9565b565b610bb3610097565b3d5f823e3d90fd5b90565b610bc8608061076b565b90565b5f80fd5b67ffffffffffffffff8111610bed57610be9602091610100565b0190565b6105f4565b90825f939282370152565b90929192610c12610c0d82610bcf565b61076b565b93818552602085019082840111610c2e57610c2c92610bf2565b565b610bcb565b610c3e913691610bfd565b90565b5f5260205f2090565b5490565b610c5781610c4a565b821015610c7157610c69600491610c41565b910201905f90565b610476565b634e487b7160e01b5f525f60045260245ffd5b610c9390516100bf565b90565b90610ca760018060a01b03916109f4565b9181191691161790565b610cba90610b22565b90565b90565b90610cd5610cd0610cdc92610cb1565b610cbd565b8254610c96565b9055565b610cea90516100d8565b90565b90610cf95f19916109f4565b9181191691161790565b610d17610d12610d1c926100d8565b6107e6565b6100d8565b90565b90565b90610d37610d32610d3e92610d03565b610d1f565b8254610ced565b9055565b5190565b601f602091010490565b1b90565b91906008610d6f910291610d695f1984610d50565b92610d50565b9181191691161790565b9190610d8f610d8a610d9793610d03565b610d1f565b908354610d54565b9055565b610dad91610da76109db565b91610d79565b565b5b818110610dbb575050565b80610dc85f600193610d9b565b01610db0565b9190601f8111610dde575b505050565b610dea610e0f93610552565b906020610df684610d46565b83019310610e17575b610e0890610d46565b0190610daf565b5f8080610dd9565b9150610e0881929050610dff565b90610e35905f19906008026103c2565b191690565b81610e4491610e25565b906002021790565b90610e56816100e8565b9067ffffffffffffffff8211610f1657610e7a82610e748554610528565b85610dce565b602090601f8311600114610eae57918091610e9d935f92610ea2575b5050610e3a565b90555b565b90915001515f80610e96565b601f19831691610ebd85610552565b925f5b818110610efe57509160029391856001969410610ee4575b50505002019055610ea0565b610ef4910151601f841690610e25565b90555f8080610ed8565b91936020600181928787015181550195019201610ec0565b6105f4565b90610f2591610e4c565b565b90610f8460606003610f8a94610f4a5f8201610f445f8801610c89565b90610cc0565b610f6360018201610f5d60208801610ce0565b90610d22565b610f7c60028201610f7660408801610d42565b90610f1b565b019201610ce0565b90610d22565b565b9190610f9d57610f9b91610f27565b565b610c76565b9081549168010000000000000000831015610fd25782610fca916001610fd095018155610c4e565b90610f8c565b565b6105f4565b909192610ff5610ff0610fea6001610a5f565b15610234565b610ac5565b61100661100183610b16565b610b2e565b9360206323b872dd9533906110375f61101e30610b3a565b996110428a61102b610097565b9c8d9788968795610b46565b855260048501610b79565b03925af19485156110da576110956110a79361109e926110ac986110ae575b5061106b5f610bbb565b959693611090349561108761107e610bbe565b9a5f8c016108e8565b60208a016108f6565b610c33565b60408601610904565b606084016108f6565b610fa2565b565b6110ce9060203d81116110d3575b6110c68183610608565b810190610b5b565b611061565b503d6110bc565b610bab565b6110fa6110f56110ef6001610a5f565b15610234565b610ac5565b565b61111061110b611115926107e3565b6107e6565b6100b4565b90565b611121906110fc565b90565b61113f61113a6111346001610a5f565b15610234565b610ac5565b6111a861114b5f610bbb565b6111545f611118565b906111a35f61119a6111915f369061118c611183349661117e611175610bbe565b9b5f8d016108e8565b6107e9565b60208a016108f6565b610c33565b60408601610904565b606084016108f6565b610fa2565b56
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4`\x1CW`\x0E` V[a\x11\xAAa\0+\x829a\x11\xAA\x90\xF3[`&V[`@Q\x90V[_\x80\xFD\xFE`\x80`@R`\x046\x10\x15a\0(W[6\x15a\0\x1EWa\0\x1Ca\x11$V[\0[a\0&a\x10\xDFV[\0[a\x002_5a\0\x91V[\x80c$l\xE2\xC6\x14a\0\x8CW\x80c:\xE0\xD3!\x14a\0\x87W\x80ch\x13\xD7\x87\x14a\0\x82W\x80c\xC7Y\xC7\x8E\x14a\0}W\x80c\xD3\x07-\x82\x14a\0xWc\xD7\x1F\0\xA1\x03a\0\x0EWa\x072V[a\x04#V[a\x03\x95V[a\x02\x7FV[a\x01\xFBV[a\x01\xA4V[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x91\x03\x12a\0\xAFWV[a\0\xA1V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\0\xC8\x90a\0\xB4V[\x90V[a\0\xD4\x90a\0\xBFV[\x90RV[\x90V[a\0\xE4\x90a\0\xD8V[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[`\x1F\x80\x19\x91\x01\x16\x90V[a\x01)a\x012` \x93a\x017\x93a\x01 \x81a\0\xE8V[\x93\x84\x80\x93a\0\xECV[\x95\x86\x91\x01a\0\xF5V[a\x01\0V[\x01\x90V[\x90a\x01\x89\x90``\x80a\x01~`\x80\x84\x01a\x01Z_\x88\x01Q_\x87\x01\x90a\0\xCBV[a\x01l` \x88\x01Q` \x87\x01\x90a\0\xDBV[`@\x87\x01Q\x85\x82\x03`@\x87\x01Ra\x01\nV[\x94\x01Q\x91\x01\x90a\0\xDBV[\x90V[a\x01\xA1\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x01;V[\x90V[4a\x01\xD4Wa\x01\xB46`\x04a\0\xA5V[a\x01\xD0a\x01\xBFa\t|V[a\x01\xC7a\0\x97V[\x91\x82\x91\x82a\x01\x8CV[\x03\x90\xF3[a\0\x9DV[a\x01\xE2\x90a\0\xD8V[\x90RV[\x91\x90a\x01\xF9\x90_` \x85\x01\x94\x01\x90a\x01\xD9V[V[4a\x02+Wa\x02\x0B6`\x04a\0\xA5V[a\x02'a\x02\x16a\t\xDFV[a\x02\x1Ea\0\x97V[\x91\x82\x91\x82a\x01\xE6V[\x03\x90\xF3[a\0\x9DV[_\x80\xFD[\x15\x15\x90V[a\x02B\x81a\x024V[\x03a\x02IWV[_\x80\xFD[\x90P5\x90a\x02Z\x82a\x029V[V[\x90` \x82\x82\x03\x12a\x02uWa\x02r\x91_\x01a\x02MV[\x90V[a\0\xA1V[_\x01\x90V[4a\x02\xADWa\x02\x97a\x02\x926`\x04a\x02\\V[a\n>V[a\x02\x9Fa\0\x97V[\x80a\x02\xA9\x81a\x02zV[\x03\x90\xF3[a\0\x9DV[a\x02\xBB\x81a\0\xBFV[\x03a\x02\xC2WV[_\x80\xFD[\x90P5\x90a\x02\xD3\x82a\x02\xB2V[V[a\x02\xDE\x81a\0\xD8V[\x03a\x02\xE5WV[_\x80\xFD[\x90P5\x90a\x02\xF6\x82a\x02\xD5V[V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x03>W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x039W` \x01\x92`\x01\x83\x02\x84\x01\x11a\x034WV[a\x03\0V[a\x02\xFCV[a\x02\xF8V[\x91``\x83\x83\x03\x12a\x03\x90Wa\x03Z\x82_\x85\x01a\x02\xC6V[\x92a\x03h\x83` \x83\x01a\x02\xE9V[\x92`@\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x03\x8BWa\x03\x87\x92\x01a\x03\x04V[\x90\x91V[a\x020V[a\0\xA1V[a\x03\xACa\x03\xA36`\x04a\x03CV[\x92\x91\x90\x91a\x0F\xD7V[a\x03\xB4a\0\x97V[\x80a\x03\xBE\x81a\x02zV[\x03\x90\xF3[\x1C\x90V[`\xFF\x16\x90V[a\x03\xDC\x90`\x08a\x03\xE1\x93\x02a\x03\xC2V[a\x03\xC6V[\x90V[\x90a\x03\xEF\x91Ta\x03\xCCV[\x90V[a\x03\xFE`\x01_\x90a\x03\xE4V[\x90V[a\x04\n\x90a\x024V[\x90RV[\x91\x90a\x04!\x90_` \x85\x01\x94\x01\x90a\x04\x01V[V[4a\x04SWa\x0436`\x04a\0\xA5V[a\x04Oa\x04>a\x03\xF2V[a\x04Fa\0\x97V[\x91\x82\x91\x82a\x04\x0EV[\x03\x90\xF3[a\0\x9DV[\x90` \x82\x82\x03\x12a\x04qWa\x04n\x91_\x01a\x02\xE9V[\x90V[a\0\xA1V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[T\x90V[_R` _ \x90V[a\x04\xA0\x81a\x04\x8AV[\x82\x10\x15a\x04\xBAWa\x04\xB2`\x04\x91a\x04\x8EV[\x91\x02\x01\x90_\x90V[a\x04vV[_\x1C\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x04\xDBa\x04\xE0\x91a\x04\xBFV[a\x04\xC4V[\x90V[a\x04\xED\x90Ta\x04\xCFV[\x90V[\x90V[a\x04\xFFa\x05\x04\x91a\x04\xBFV[a\x04\xF0V[\x90V[a\x05\x11\x90Ta\x04\xF3V[\x90V[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x05HW[` \x83\x10\x14a\x05CWV[a\x05\x14V[\x91`\x7F\x16\x91a\x058V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x05ua\x05n\x83a\x05(V[\x80\x94a\0\xECV[\x91`\x01\x81\x16\x90\x81_\x14a\x05\xCCWP`\x01\x14a\x05\x90W[PPPV[a\x05\x9D\x91\x92\x93\x94Pa\x05RV[\x91_\x92[\x81\x84\x10a\x05\xB4WPP\x01\x90_\x80\x80a\x05\x8BV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x05\xA1V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x05\x8BV[\x90a\x05\xF1\x91a\x05[V[\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x06\x12\x90a\x01\0V[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x06,W`@RV[a\x05\xF4V[\x90a\x06Qa\x06J\x92a\x06Aa\0\x97V[\x93\x84\x80\x92a\x05\xE7V[\x03\x83a\x06\x08V[V[_\x90a\x06^\x82a\x04\x8AV[\x81\x10\x15a\x06\xA4Wa\x06n\x91a\x04\x97V[P\x90a\x06{_\x83\x01a\x04\xE3V[\x91a\x06\x88`\x01\x82\x01a\x05\x07V[\x91a\x06\xA1`\x03a\x06\x9A`\x02\x85\x01a\x061V[\x93\x01a\x05\x07V[\x90V[_\x80\xFD[a\x06\xB1\x90a\0\xBFV[\x90RV[` \x91\x81R\x01\x90V[a\x06\xDDa\x06\xE6` \x93a\x06\xEB\x93a\x06\xD4\x81a\0\xE8V[\x93\x84\x80\x93a\x06\xB5V[\x95\x86\x91\x01a\0\xF5V[a\x01\0V[\x01\x90V[\x94\x93\x91``\x91a\x070\x94a\x07\x1Ba\x07(\x93a\x07\x11`\x80\x8B\x01\x94_\x8C\x01\x90a\x06\xA8V[` \x8A\x01\x90a\x01\xD9V[\x87\x82\x03`@\x89\x01Ra\x06\xBEV[\x94\x01\x90a\x01\xD9V[V[4a\x07fWa\x07ba\x07Ma\x07H6`\x04a\x04XV[a\x06SV[\x90a\x07Y\x94\x92\x94a\0\x97V[\x94\x85\x94\x85a\x06\xEFV[\x03\x90\xF3[a\0\x9DV[\x90a\x07~a\x07wa\0\x97V[\x92\x83a\x06\x08V[V[a\x07\x8A`\x80a\x07kV[\x90V[_\x90V[_\x90V[``\x90V[a\x07\xA2a\x07\x80V[\x90` \x80\x80\x80\x85a\x07\xB1a\x07\x8DV[\x81R\x01a\x07\xBCa\x07\x91V[\x81R\x01a\x07\xC7a\x07\x95V[\x81R\x01a\x07\xD2a\x07\x91V[\x81RPPV[a\x07\xE0a\x07\x9AV[\x90V[\x90V[\x90V[a\x07\xFDa\x07\xF8a\x08\x02\x92a\x07\xE3V[a\x07\xE6V[a\0\xD8V[\x90V[` \x91\x81R\x01\x90V[_\x7FNo bridge calls\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x08B`\x0F` \x92a\x08\x05V[a\x08K\x81a\x08\x0EV[\x01\x90V[a\x08d\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x085V[\x90V[\x15a\x08nWV[a\x08va\0\x97V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x08\x8C`\x04\x82\x01a\x08OV[\x03\x90\xFD[\x90V[a\x08\xA7a\x08\xA2a\x08\xAC\x92a\x08\x90V[a\x07\xE6V[a\0\xD8V[\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\x08\xD2a\x08\xD8\x91\x93\x92\x93a\0\xD8V[\x92a\0\xD8V[\x82\x03\x91\x82\x11a\x08\xE3WV[a\x08\xAFV[\x90a\x08\xF2\x90a\0\xBFV[\x90RV[\x90a\t\0\x90a\0\xD8V[\x90RV[RV[\x90a\tna\te`\x03a\t\x18a\x07\x80V[\x94a\t/a\t'_\x83\x01a\x04\xE3V[_\x88\x01a\x08\xE8V[a\tGa\t>`\x01\x83\x01a\x05\x07V[` \x88\x01a\x08\xF6V[a\t_a\tV`\x02\x83\x01a\x061V[`@\x88\x01a\t\x04V[\x01a\x05\x07V[``\x84\x01a\x08\xF6V[V[a\ty\x90a\t\x07V[\x90V[a\t\x84a\x07\xD8V[Pa\t\xA9a\t\x91_a\x04\x8AV[a\t\xA3a\t\x9D_a\x07\xE9V[\x91a\0\xD8V[\x11a\x08gV[a\t\xD8a\t\xD2_a\t\xCCa\t\xBC_a\x04\x8AV[a\t\xC6`\x01a\x08\x93V[\x90a\x08\xC3V[\x90a\x04\x97V[Pa\tpV[\x90V[_\x90V[a\t\xE7a\t\xDBV[Pa\t\xF1_a\x04\x8AV[\x90V[_\x1B\x90V[\x90a\n\x05`\xFF\x91a\t\xF4V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\n\x18\x90a\x024V[\x90V[\x90V[\x90a\n3a\n.a\n:\x92a\n\x0FV[a\n\x1BV[\x82Ta\t\xF9V[\x90UV[a\nI\x90`\x01a\n\x1EV[V[a\nWa\n\\\x91a\x04\xBFV[a\x03\xC6V[\x90V[a\ni\x90Ta\nKV[\x90V[_\x7FMockBridge: forced revert\0\0\0\0\0\0\0\x91\x01RV[a\n\xA0`\x19` \x92a\x08\x05V[a\n\xA9\x81a\nlV[\x01\x90V[a\n\xC2\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\n\x93V[\x90V[\x15a\n\xCCWV[a\n\xD4a\0\x97V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\n\xEA`\x04\x82\x01a\n\xADV[\x03\x90\xFD[a\x0B\x02a\n\xFDa\x0B\x07\x92a\0\xB4V[a\x07\xE6V[a\0\xB4V[\x90V[a\x0B\x13\x90a\n\xEEV[\x90V[a\x0B\x1F\x90a\x0B\nV[\x90V[a\x0B+\x90a\n\xEEV[\x90V[a\x0B7\x90a\x0B\"V[\x90V[a\x0BC\x90a\x0B\"V[\x90V[`\xE0\x1B\x90V[\x90PQ\x90a\x0BY\x82a\x029V[V[\x90` \x82\x82\x03\x12a\x0BtWa\x0Bq\x91_\x01a\x0BLV[\x90V[a\0\xA1V[`@\x90a\x0B\xA2a\x0B\xA9\x94\x96\x95\x93\x96a\x0B\x98``\x84\x01\x98_\x85\x01\x90a\x06\xA8V[` \x83\x01\x90a\x06\xA8V[\x01\x90a\x01\xD9V[V[a\x0B\xB3a\0\x97V[=_\x82>=\x90\xFD[\x90V[a\x0B\xC8`\x80a\x07kV[\x90V[_\x80\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x0B\xEDWa\x0B\xE9` \x91a\x01\0V[\x01\x90V[a\x05\xF4V[\x90\x82_\x93\x92\x827\x01RV[\x90\x92\x91\x92a\x0C\x12a\x0C\r\x82a\x0B\xCFV[a\x07kV[\x93\x81\x85R` \x85\x01\x90\x82\x84\x01\x11a\x0C.Wa\x0C,\x92a\x0B\xF2V[V[a\x0B\xCBV[a\x0C>\x916\x91a\x0B\xFDV[\x90V[_R` _ \x90V[T\x90V[a\x0CW\x81a\x0CJV[\x82\x10\x15a\x0CqWa\x0Ci`\x04\x91a\x0CAV[\x91\x02\x01\x90_\x90V[a\x04vV[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[a\x0C\x93\x90Qa\0\xBFV[\x90V[\x90a\x0C\xA7`\x01\x80`\xA0\x1B\x03\x91a\t\xF4V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x0C\xBA\x90a\x0B\"V[\x90V[\x90V[\x90a\x0C\xD5a\x0C\xD0a\x0C\xDC\x92a\x0C\xB1V[a\x0C\xBDV[\x82Ta\x0C\x96V[\x90UV[a\x0C\xEA\x90Qa\0\xD8V[\x90V[\x90a\x0C\xF9_\x19\x91a\t\xF4V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\r\x17a\r\x12a\r\x1C\x92a\0\xD8V[a\x07\xE6V[a\0\xD8V[\x90V[\x90V[\x90a\r7a\r2a\r>\x92a\r\x03V[a\r\x1FV[\x82Ta\x0C\xEDV[\x90UV[Q\x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a\ro\x91\x02\x91a\ri_\x19\x84a\rPV[\x92a\rPV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x91\x90a\r\x8Fa\r\x8Aa\r\x97\x93a\r\x03V[a\r\x1FV[\x90\x83Ta\rTV[\x90UV[a\r\xAD\x91a\r\xA7a\t\xDBV[\x91a\ryV[V[[\x81\x81\x10a\r\xBBWPPV[\x80a\r\xC8_`\x01\x93a\r\x9BV[\x01a\r\xB0V[\x91\x90`\x1F\x81\x11a\r\xDEW[PPPV[a\r\xEAa\x0E\x0F\x93a\x05RV[\x90` a\r\xF6\x84a\rFV[\x83\x01\x93\x10a\x0E\x17W[a\x0E\x08\x90a\rFV[\x01\x90a\r\xAFV[_\x80\x80a\r\xD9V[\x91Pa\x0E\x08\x81\x92\x90Pa\r\xFFV[\x90a\x0E5\x90_\x19\x90`\x08\x02a\x03\xC2V[\x19\x16\x90V[\x81a\x0ED\x91a\x0E%V[\x90`\x02\x02\x17\x90V[\x90a\x0EV\x81a\0\xE8V[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x0F\x16Wa\x0Ez\x82a\x0Et\x85Ta\x05(V[\x85a\r\xCEV[` \x90`\x1F\x83\x11`\x01\x14a\x0E\xAEW\x91\x80\x91a\x0E\x9D\x93_\x92a\x0E\xA2W[PPa\x0E:V[\x90U[V[\x90\x91P\x01Q_\x80a\x0E\x96V[`\x1F\x19\x83\x16\x91a\x0E\xBD\x85a\x05RV[\x92_[\x81\x81\x10a\x0E\xFEWP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\x0E\xE4W[PPP\x02\x01\x90Ua\x0E\xA0V[a\x0E\xF4\x91\x01Q`\x1F\x84\x16\x90a\x0E%V[\x90U_\x80\x80a\x0E\xD8V[\x91\x93` `\x01\x81\x92\x87\x87\x01Q\x81U\x01\x95\x01\x92\x01a\x0E\xC0V[a\x05\xF4V[\x90a\x0F%\x91a\x0ELV[V[\x90a\x0F\x84```\x03a\x0F\x8A\x94a\x0FJ_\x82\x01a\x0FD_\x88\x01a\x0C\x89V[\x90a\x0C\xC0V[a\x0Fc`\x01\x82\x01a\x0F]` \x88\x01a\x0C\xE0V[\x90a\r\"V[a\x0F|`\x02\x82\x01a\x0Fv`@\x88\x01a\rBV[\x90a\x0F\x1BV[\x01\x92\x01a\x0C\xE0V[\x90a\r\"V[V[\x91\x90a\x0F\x9DWa\x0F\x9B\x91a\x0F'V[V[a\x0CvV[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15a\x0F\xD2W\x82a\x0F\xCA\x91`\x01a\x0F\xD0\x95\x01\x81Ua\x0CNV[\x90a\x0F\x8CV[V[a\x05\xF4V[\x90\x91\x92a\x0F\xF5a\x0F\xF0a\x0F\xEA`\x01a\n_V[\x15a\x024V[a\n\xC5V[a\x10\x06a\x10\x01\x83a\x0B\x16V[a\x0B.V[\x93` c#\xB8r\xDD\x953\x90a\x107_a\x10\x1E0a\x0B:V[\x99a\x10B\x8Aa\x10+a\0\x97V[\x9C\x8D\x97\x88\x96\x87\x95a\x0BFV[\x85R`\x04\x85\x01a\x0ByV[\x03\x92Z\xF1\x94\x85\x15a\x10\xDAWa\x10\x95a\x10\xA7\x93a\x10\x9E\x92a\x10\xAC\x98a\x10\xAEW[Pa\x10k_a\x0B\xBBV[\x95\x96\x93a\x10\x904\x95a\x10\x87a\x10~a\x0B\xBEV[\x9A_\x8C\x01a\x08\xE8V[` \x8A\x01a\x08\xF6V[a\x0C3V[`@\x86\x01a\t\x04V[``\x84\x01a\x08\xF6V[a\x0F\xA2V[V[a\x10\xCE\x90` =\x81\x11a\x10\xD3W[a\x10\xC6\x81\x83a\x06\x08V[\x81\x01\x90a\x0B[V[a\x10aV[P=a\x10\xBCV[a\x0B\xABV[a\x10\xFAa\x10\xF5a\x10\xEF`\x01a\n_V[\x15a\x024V[a\n\xC5V[V[a\x11\x10a\x11\x0Ba\x11\x15\x92a\x07\xE3V[a\x07\xE6V[a\0\xB4V[\x90V[a\x11!\x90a\x10\xFCV[\x90V[a\x11?a\x11:a\x114`\x01a\n_V[\x15a\x024V[a\n\xC5V[a\x11\xA8a\x11K_a\x0B\xBBV[a\x11T_a\x11\x18V[\x90a\x11\xA3_a\x11\x9Aa\x11\x91_6\x90a\x11\x8Ca\x11\x834\x96a\x11~a\x11ua\x0B\xBEV[\x9B_\x8D\x01a\x08\xE8V[a\x07\xE9V[` \x8A\x01a\x08\xF6V[a\x0C3V[`@\x86\x01a\t\x04V[``\x84\x01a\x08\xF6V[a\x0F\xA2V[V",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361015610028575b361561001e5761001c611124565b005b6100266110df565b005b6100325f35610091565b8063246ce2c61461008c5780633ae0d321146100875780636813d78714610082578063c759c78e1461007d578063d3072d82146100785763d71f00a10361000e57610732565b610423565b610395565b61027f565b6101fb565b6101a4565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f9103126100af57565b6100a1565b60018060a01b031690565b6100c8906100b4565b90565b6100d4906100bf565b9052565b90565b6100e4906100d8565b9052565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b61012961013260209361013793610120816100e8565b938480936100ec565b958691016100f5565b610100565b0190565b906101899060608061017e6080840161015a5f8801515f8701906100cb565b61016c602088015160208701906100db565b6040870151858203604087015261010a565b9401519101906100db565b90565b6101a19160208201915f81840391015261013b565b90565b346101d4576101b43660046100a5565b6101d06101bf61097c565b6101c7610097565b9182918261018c565b0390f35b61009d565b6101e2906100d8565b9052565b91906101f9905f602085019401906101d9565b565b3461022b5761020b3660046100a5565b6102276102166109df565b61021e610097565b918291826101e6565b0390f35b61009d565b5f80fd5b151590565b61024281610234565b0361024957565b5f80fd5b9050359061025a82610239565b565b9060208282031261027557610272915f0161024d565b90565b6100a1565b5f0190565b346102ad5761029761029236600461025c565b610a3e565b61029f610097565b806102a98161027a565b0390f35b61009d565b6102bb816100bf565b036102c257565b5f80fd5b905035906102d3826102b2565b565b6102de816100d8565b036102e557565b5f80fd5b905035906102f6826102d5565b565b5f80fd5b5f80fd5b5f80fd5b909182601f8301121561033e5781359167ffffffffffffffff831161033957602001926001830284011161033457565b610300565b6102fc565b6102f8565b916060838303126103905761035a825f85016102c6565b9261036883602083016102e9565b92604082013567ffffffffffffffff811161038b576103879201610304565b9091565b610230565b6100a1565b6103ac6103a3366004610343565b92919091610fd7565b6103b4610097565b806103be8161027a565b0390f35b1c90565b60ff1690565b6103dc9060086103e193026103c2565b6103c6565b90565b906103ef91546103cc565b90565b6103fe60015f906103e4565b90565b61040a90610234565b9052565b9190610421905f60208501940190610401565b565b34610453576104333660046100a5565b61044f61043e6103f2565b610446610097565b9182918261040e565b0390f35b61009d565b906020828203126104715761046e915f016102e9565b90565b6100a1565b634e487b7160e01b5f52603260045260245ffd5b5490565b5f5260205f2090565b6104a08161048a565b8210156104ba576104b260049161048e565b910201905f90565b610476565b5f1c90565b60018060a01b031690565b6104db6104e0916104bf565b6104c4565b90565b6104ed90546104cf565b90565b90565b6104ff610504916104bf565b6104f0565b90565b61051190546104f3565b90565b634e487b7160e01b5f52602260045260245ffd5b9060016002830492168015610548575b602083101461054357565b610514565b91607f1691610538565b5f5260205f2090565b905f929180549061057561056e83610528565b80946100ec565b916001811690815f146105cc5750600114610590575b505050565b61059d9192939450610552565b915f925b8184106105b457505001905f808061058b565b600181602092959395548486015201910192906105a1565b92949550505060ff19168252151560200201905f808061058b565b906105f19161055b565b90565b634e487b7160e01b5f52604160045260245ffd5b9061061290610100565b810190811067ffffffffffffffff82111761062c57604052565b6105f4565b9061065161064a92610641610097565b938480926105e7565b0383610608565b565b5f9061065e8261048a565b8110156106a45761066e91610497565b509061067b5f83016104e3565b9161068860018201610507565b916106a1600361069a60028501610631565b9301610507565b90565b5f80fd5b6106b1906100bf565b9052565b60209181520190565b6106dd6106e66020936106eb936106d4816100e8565b938480936106b5565b958691016100f5565b610100565b0190565b9493916060916107309461071b6107289361071160808b01945f8c01906106a8565b60208a01906101d9565b87820360408901526106be565b9401906101d9565b565b346107665761076261074d610748366004610458565b610653565b90610759949294610097565b948594856106ef565b0390f35b61009d565b9061077e610777610097565b9283610608565b565b61078a608061076b565b90565b5f90565b5f90565b606090565b6107a2610780565b906020808080856107b161078d565b8152016107bc610791565b8152016107c7610795565b8152016107d2610791565b81525050565b6107e061079a565b90565b90565b90565b6107fd6107f8610802926107e3565b6107e6565b6100d8565b90565b60209181520190565b5f7f4e6f206272696467652063616c6c730000000000000000000000000000000000910152565b610842600f602092610805565b61084b8161080e565b0190565b6108649060208101905f818303910152610835565b90565b1561086e57565b610876610097565b62461bcd60e51b81528061088c6004820161084f565b0390fd5b90565b6108a76108a26108ac92610890565b6107e6565b6100d8565b90565b634e487b7160e01b5f52601160045260245ffd5b6108d26108d8919392936100d8565b926100d8565b82039182116108e357565b6108af565b906108f2906100bf565b9052565b90610900906100d8565b9052565b52565b9061096e6109656003610918610780565b9461092f6109275f83016104e3565b5f88016108e8565b61094761093e60018301610507565b602088016108f6565b61095f61095660028301610631565b60408801610904565b01610507565b606084016108f6565b565b61097990610907565b90565b6109846107d8565b506109a96109915f61048a565b6109a361099d5f6107e9565b916100d8565b11610867565b6109d86109d25f6109cc6109bc5f61048a565b6109c66001610893565b906108c3565b90610497565b50610970565b90565b5f90565b6109e76109db565b506109f15f61048a565b90565b5f1b90565b90610a0560ff916109f4565b9181191691161790565b610a1890610234565b90565b90565b90610a33610a2e610a3a92610a0f565b610a1b565b82546109f9565b9055565b610a49906001610a1e565b565b610a57610a5c916104bf565b6103c6565b90565b610a699054610a4b565b90565b5f7f4d6f636b4272696467653a20666f726365642072657665727400000000000000910152565b610aa06019602092610805565b610aa981610a6c565b0190565b610ac29060208101905f818303910152610a93565b90565b15610acc57565b610ad4610097565b62461bcd60e51b815280610aea60048201610aad565b0390fd5b610b02610afd610b07926100b4565b6107e6565b6100b4565b90565b610b1390610aee565b90565b610b1f90610b0a565b90565b610b2b90610aee565b90565b610b3790610b22565b90565b610b4390610b22565b90565b60e01b90565b90505190610b5982610239565b565b90602082820312610b7457610b71915f01610b4c565b90565b6100a1565b604090610ba2610ba99496959396610b9860608401985f8501906106a8565b60208301906106a8565b01906101d9565b565b610bb3610097565b3d5f823e3d90fd5b90565b610bc8608061076b565b90565b5f80fd5b67ffffffffffffffff8111610bed57610be9602091610100565b0190565b6105f4565b90825f939282370152565b90929192610c12610c0d82610bcf565b61076b565b93818552602085019082840111610c2e57610c2c92610bf2565b565b610bcb565b610c3e913691610bfd565b90565b5f5260205f2090565b5490565b610c5781610c4a565b821015610c7157610c69600491610c41565b910201905f90565b610476565b634e487b7160e01b5f525f60045260245ffd5b610c9390516100bf565b90565b90610ca760018060a01b03916109f4565b9181191691161790565b610cba90610b22565b90565b90565b90610cd5610cd0610cdc92610cb1565b610cbd565b8254610c96565b9055565b610cea90516100d8565b90565b90610cf95f19916109f4565b9181191691161790565b610d17610d12610d1c926100d8565b6107e6565b6100d8565b90565b90565b90610d37610d32610d3e92610d03565b610d1f565b8254610ced565b9055565b5190565b601f602091010490565b1b90565b91906008610d6f910291610d695f1984610d50565b92610d50565b9181191691161790565b9190610d8f610d8a610d9793610d03565b610d1f565b908354610d54565b9055565b610dad91610da76109db565b91610d79565b565b5b818110610dbb575050565b80610dc85f600193610d9b565b01610db0565b9190601f8111610dde575b505050565b610dea610e0f93610552565b906020610df684610d46565b83019310610e17575b610e0890610d46565b0190610daf565b5f8080610dd9565b9150610e0881929050610dff565b90610e35905f19906008026103c2565b191690565b81610e4491610e25565b906002021790565b90610e56816100e8565b9067ffffffffffffffff8211610f1657610e7a82610e748554610528565b85610dce565b602090601f8311600114610eae57918091610e9d935f92610ea2575b5050610e3a565b90555b565b90915001515f80610e96565b601f19831691610ebd85610552565b925f5b818110610efe57509160029391856001969410610ee4575b50505002019055610ea0565b610ef4910151601f841690610e25565b90555f8080610ed8565b91936020600181928787015181550195019201610ec0565b6105f4565b90610f2591610e4c565b565b90610f8460606003610f8a94610f4a5f8201610f445f8801610c89565b90610cc0565b610f6360018201610f5d60208801610ce0565b90610d22565b610f7c60028201610f7660408801610d42565b90610f1b565b019201610ce0565b90610d22565b565b9190610f9d57610f9b91610f27565b565b610c76565b9081549168010000000000000000831015610fd25782610fca916001610fd095018155610c4e565b90610f8c565b565b6105f4565b909192610ff5610ff0610fea6001610a5f565b15610234565b610ac5565b61100661100183610b16565b610b2e565b9360206323b872dd9533906110375f61101e30610b3a565b996110428a61102b610097565b9c8d9788968795610b46565b855260048501610b79565b03925af19485156110da576110956110a79361109e926110ac986110ae575b5061106b5f610bbb565b959693611090349561108761107e610bbe565b9a5f8c016108e8565b60208a016108f6565b610c33565b60408601610904565b606084016108f6565b610fa2565b565b6110ce9060203d81116110d3575b6110c68183610608565b810190610b5b565b611061565b503d6110bc565b610bab565b6110fa6110f56110ef6001610a5f565b15610234565b610ac5565b565b61111061110b611115926107e3565b6107e6565b6100b4565b90565b611121906110fc565b90565b61113f61113a6111346001610a5f565b15610234565b610ac5565b6111a861114b5f610bbb565b6111545f611118565b906111a35f61119a6111915f369061118c611183349661117e611175610bbe565b9b5f8d016108e8565b6107e9565b60208a016108f6565b610c33565b60408601610904565b606084016108f6565b610fa2565b56
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0(W[6\x15a\0\x1EWa\0\x1Ca\x11$V[\0[a\0&a\x10\xDFV[\0[a\x002_5a\0\x91V[\x80c$l\xE2\xC6\x14a\0\x8CW\x80c:\xE0\xD3!\x14a\0\x87W\x80ch\x13\xD7\x87\x14a\0\x82W\x80c\xC7Y\xC7\x8E\x14a\0}W\x80c\xD3\x07-\x82\x14a\0xWc\xD7\x1F\0\xA1\x03a\0\x0EWa\x072V[a\x04#V[a\x03\x95V[a\x02\x7FV[a\x01\xFBV[a\x01\xA4V[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x91\x03\x12a\0\xAFWV[a\0\xA1V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\0\xC8\x90a\0\xB4V[\x90V[a\0\xD4\x90a\0\xBFV[\x90RV[\x90V[a\0\xE4\x90a\0\xD8V[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[`\x1F\x80\x19\x91\x01\x16\x90V[a\x01)a\x012` \x93a\x017\x93a\x01 \x81a\0\xE8V[\x93\x84\x80\x93a\0\xECV[\x95\x86\x91\x01a\0\xF5V[a\x01\0V[\x01\x90V[\x90a\x01\x89\x90``\x80a\x01~`\x80\x84\x01a\x01Z_\x88\x01Q_\x87\x01\x90a\0\xCBV[a\x01l` \x88\x01Q` \x87\x01\x90a\0\xDBV[`@\x87\x01Q\x85\x82\x03`@\x87\x01Ra\x01\nV[\x94\x01Q\x91\x01\x90a\0\xDBV[\x90V[a\x01\xA1\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x01;V[\x90V[4a\x01\xD4Wa\x01\xB46`\x04a\0\xA5V[a\x01\xD0a\x01\xBFa\t|V[a\x01\xC7a\0\x97V[\x91\x82\x91\x82a\x01\x8CV[\x03\x90\xF3[a\0\x9DV[a\x01\xE2\x90a\0\xD8V[\x90RV[\x91\x90a\x01\xF9\x90_` \x85\x01\x94\x01\x90a\x01\xD9V[V[4a\x02+Wa\x02\x0B6`\x04a\0\xA5V[a\x02'a\x02\x16a\t\xDFV[a\x02\x1Ea\0\x97V[\x91\x82\x91\x82a\x01\xE6V[\x03\x90\xF3[a\0\x9DV[_\x80\xFD[\x15\x15\x90V[a\x02B\x81a\x024V[\x03a\x02IWV[_\x80\xFD[\x90P5\x90a\x02Z\x82a\x029V[V[\x90` \x82\x82\x03\x12a\x02uWa\x02r\x91_\x01a\x02MV[\x90V[a\0\xA1V[_\x01\x90V[4a\x02\xADWa\x02\x97a\x02\x926`\x04a\x02\\V[a\n>V[a\x02\x9Fa\0\x97V[\x80a\x02\xA9\x81a\x02zV[\x03\x90\xF3[a\0\x9DV[a\x02\xBB\x81a\0\xBFV[\x03a\x02\xC2WV[_\x80\xFD[\x90P5\x90a\x02\xD3\x82a\x02\xB2V[V[a\x02\xDE\x81a\0\xD8V[\x03a\x02\xE5WV[_\x80\xFD[\x90P5\x90a\x02\xF6\x82a\x02\xD5V[V[_\x80\xFD[_\x80\xFD[_\x80\xFD[\x90\x91\x82`\x1F\x83\x01\x12\x15a\x03>W\x815\x91g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x039W` \x01\x92`\x01\x83\x02\x84\x01\x11a\x034WV[a\x03\0V[a\x02\xFCV[a\x02\xF8V[\x91``\x83\x83\x03\x12a\x03\x90Wa\x03Z\x82_\x85\x01a\x02\xC6V[\x92a\x03h\x83` \x83\x01a\x02\xE9V[\x92`@\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x03\x8BWa\x03\x87\x92\x01a\x03\x04V[\x90\x91V[a\x020V[a\0\xA1V[a\x03\xACa\x03\xA36`\x04a\x03CV[\x92\x91\x90\x91a\x0F\xD7V[a\x03\xB4a\0\x97V[\x80a\x03\xBE\x81a\x02zV[\x03\x90\xF3[\x1C\x90V[`\xFF\x16\x90V[a\x03\xDC\x90`\x08a\x03\xE1\x93\x02a\x03\xC2V[a\x03\xC6V[\x90V[\x90a\x03\xEF\x91Ta\x03\xCCV[\x90V[a\x03\xFE`\x01_\x90a\x03\xE4V[\x90V[a\x04\n\x90a\x024V[\x90RV[\x91\x90a\x04!\x90_` \x85\x01\x94\x01\x90a\x04\x01V[V[4a\x04SWa\x0436`\x04a\0\xA5V[a\x04Oa\x04>a\x03\xF2V[a\x04Fa\0\x97V[\x91\x82\x91\x82a\x04\x0EV[\x03\x90\xF3[a\0\x9DV[\x90` \x82\x82\x03\x12a\x04qWa\x04n\x91_\x01a\x02\xE9V[\x90V[a\0\xA1V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[T\x90V[_R` _ \x90V[a\x04\xA0\x81a\x04\x8AV[\x82\x10\x15a\x04\xBAWa\x04\xB2`\x04\x91a\x04\x8EV[\x91\x02\x01\x90_\x90V[a\x04vV[_\x1C\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x04\xDBa\x04\xE0\x91a\x04\xBFV[a\x04\xC4V[\x90V[a\x04\xED\x90Ta\x04\xCFV[\x90V[\x90V[a\x04\xFFa\x05\x04\x91a\x04\xBFV[a\x04\xF0V[\x90V[a\x05\x11\x90Ta\x04\xF3V[\x90V[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x05HW[` \x83\x10\x14a\x05CWV[a\x05\x14V[\x91`\x7F\x16\x91a\x058V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x05ua\x05n\x83a\x05(V[\x80\x94a\0\xECV[\x91`\x01\x81\x16\x90\x81_\x14a\x05\xCCWP`\x01\x14a\x05\x90W[PPPV[a\x05\x9D\x91\x92\x93\x94Pa\x05RV[\x91_\x92[\x81\x84\x10a\x05\xB4WPP\x01\x90_\x80\x80a\x05\x8BV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x05\xA1V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x05\x8BV[\x90a\x05\xF1\x91a\x05[V[\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x06\x12\x90a\x01\0V[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x06,W`@RV[a\x05\xF4V[\x90a\x06Qa\x06J\x92a\x06Aa\0\x97V[\x93\x84\x80\x92a\x05\xE7V[\x03\x83a\x06\x08V[V[_\x90a\x06^\x82a\x04\x8AV[\x81\x10\x15a\x06\xA4Wa\x06n\x91a\x04\x97V[P\x90a\x06{_\x83\x01a\x04\xE3V[\x91a\x06\x88`\x01\x82\x01a\x05\x07V[\x91a\x06\xA1`\x03a\x06\x9A`\x02\x85\x01a\x061V[\x93\x01a\x05\x07V[\x90V[_\x80\xFD[a\x06\xB1\x90a\0\xBFV[\x90RV[` \x91\x81R\x01\x90V[a\x06\xDDa\x06\xE6` \x93a\x06\xEB\x93a\x06\xD4\x81a\0\xE8V[\x93\x84\x80\x93a\x06\xB5V[\x95\x86\x91\x01a\0\xF5V[a\x01\0V[\x01\x90V[\x94\x93\x91``\x91a\x070\x94a\x07\x1Ba\x07(\x93a\x07\x11`\x80\x8B\x01\x94_\x8C\x01\x90a\x06\xA8V[` \x8A\x01\x90a\x01\xD9V[\x87\x82\x03`@\x89\x01Ra\x06\xBEV[\x94\x01\x90a\x01\xD9V[V[4a\x07fWa\x07ba\x07Ma\x07H6`\x04a\x04XV[a\x06SV[\x90a\x07Y\x94\x92\x94a\0\x97V[\x94\x85\x94\x85a\x06\xEFV[\x03\x90\xF3[a\0\x9DV[\x90a\x07~a\x07wa\0\x97V[\x92\x83a\x06\x08V[V[a\x07\x8A`\x80a\x07kV[\x90V[_\x90V[_\x90V[``\x90V[a\x07\xA2a\x07\x80V[\x90` \x80\x80\x80\x85a\x07\xB1a\x07\x8DV[\x81R\x01a\x07\xBCa\x07\x91V[\x81R\x01a\x07\xC7a\x07\x95V[\x81R\x01a\x07\xD2a\x07\x91V[\x81RPPV[a\x07\xE0a\x07\x9AV[\x90V[\x90V[\x90V[a\x07\xFDa\x07\xF8a\x08\x02\x92a\x07\xE3V[a\x07\xE6V[a\0\xD8V[\x90V[` \x91\x81R\x01\x90V[_\x7FNo bridge calls\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x08B`\x0F` \x92a\x08\x05V[a\x08K\x81a\x08\x0EV[\x01\x90V[a\x08d\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x085V[\x90V[\x15a\x08nWV[a\x08va\0\x97V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x08\x8C`\x04\x82\x01a\x08OV[\x03\x90\xFD[\x90V[a\x08\xA7a\x08\xA2a\x08\xAC\x92a\x08\x90V[a\x07\xE6V[a\0\xD8V[\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\x08\xD2a\x08\xD8\x91\x93\x92\x93a\0\xD8V[\x92a\0\xD8V[\x82\x03\x91\x82\x11a\x08\xE3WV[a\x08\xAFV[\x90a\x08\xF2\x90a\0\xBFV[\x90RV[\x90a\t\0\x90a\0\xD8V[\x90RV[RV[\x90a\tna\te`\x03a\t\x18a\x07\x80V[\x94a\t/a\t'_\x83\x01a\x04\xE3V[_\x88\x01a\x08\xE8V[a\tGa\t>`\x01\x83\x01a\x05\x07V[` \x88\x01a\x08\xF6V[a\t_a\tV`\x02\x83\x01a\x061V[`@\x88\x01a\t\x04V[\x01a\x05\x07V[``\x84\x01a\x08\xF6V[V[a\ty\x90a\t\x07V[\x90V[a\t\x84a\x07\xD8V[Pa\t\xA9a\t\x91_a\x04\x8AV[a\t\xA3a\t\x9D_a\x07\xE9V[\x91a\0\xD8V[\x11a\x08gV[a\t\xD8a\t\xD2_a\t\xCCa\t\xBC_a\x04\x8AV[a\t\xC6`\x01a\x08\x93V[\x90a\x08\xC3V[\x90a\x04\x97V[Pa\tpV[\x90V[_\x90V[a\t\xE7a\t\xDBV[Pa\t\xF1_a\x04\x8AV[\x90V[_\x1B\x90V[\x90a\n\x05`\xFF\x91a\t\xF4V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\n\x18\x90a\x024V[\x90V[\x90V[\x90a\n3a\n.a\n:\x92a\n\x0FV[a\n\x1BV[\x82Ta\t\xF9V[\x90UV[a\nI\x90`\x01a\n\x1EV[V[a\nWa\n\\\x91a\x04\xBFV[a\x03\xC6V[\x90V[a\ni\x90Ta\nKV[\x90V[_\x7FMockBridge: forced revert\0\0\0\0\0\0\0\x91\x01RV[a\n\xA0`\x19` \x92a\x08\x05V[a\n\xA9\x81a\nlV[\x01\x90V[a\n\xC2\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\n\x93V[\x90V[\x15a\n\xCCWV[a\n\xD4a\0\x97V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\n\xEA`\x04\x82\x01a\n\xADV[\x03\x90\xFD[a\x0B\x02a\n\xFDa\x0B\x07\x92a\0\xB4V[a\x07\xE6V[a\0\xB4V[\x90V[a\x0B\x13\x90a\n\xEEV[\x90V[a\x0B\x1F\x90a\x0B\nV[\x90V[a\x0B+\x90a\n\xEEV[\x90V[a\x0B7\x90a\x0B\"V[\x90V[a\x0BC\x90a\x0B\"V[\x90V[`\xE0\x1B\x90V[\x90PQ\x90a\x0BY\x82a\x029V[V[\x90` \x82\x82\x03\x12a\x0BtWa\x0Bq\x91_\x01a\x0BLV[\x90V[a\0\xA1V[`@\x90a\x0B\xA2a\x0B\xA9\x94\x96\x95\x93\x96a\x0B\x98``\x84\x01\x98_\x85\x01\x90a\x06\xA8V[` \x83\x01\x90a\x06\xA8V[\x01\x90a\x01\xD9V[V[a\x0B\xB3a\0\x97V[=_\x82>=\x90\xFD[\x90V[a\x0B\xC8`\x80a\x07kV[\x90V[_\x80\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x0B\xEDWa\x0B\xE9` \x91a\x01\0V[\x01\x90V[a\x05\xF4V[\x90\x82_\x93\x92\x827\x01RV[\x90\x92\x91\x92a\x0C\x12a\x0C\r\x82a\x0B\xCFV[a\x07kV[\x93\x81\x85R` \x85\x01\x90\x82\x84\x01\x11a\x0C.Wa\x0C,\x92a\x0B\xF2V[V[a\x0B\xCBV[a\x0C>\x916\x91a\x0B\xFDV[\x90V[_R` _ \x90V[T\x90V[a\x0CW\x81a\x0CJV[\x82\x10\x15a\x0CqWa\x0Ci`\x04\x91a\x0CAV[\x91\x02\x01\x90_\x90V[a\x04vV[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[a\x0C\x93\x90Qa\0\xBFV[\x90V[\x90a\x0C\xA7`\x01\x80`\xA0\x1B\x03\x91a\t\xF4V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x0C\xBA\x90a\x0B\"V[\x90V[\x90V[\x90a\x0C\xD5a\x0C\xD0a\x0C\xDC\x92a\x0C\xB1V[a\x0C\xBDV[\x82Ta\x0C\x96V[\x90UV[a\x0C\xEA\x90Qa\0\xD8V[\x90V[\x90a\x0C\xF9_\x19\x91a\t\xF4V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\r\x17a\r\x12a\r\x1C\x92a\0\xD8V[a\x07\xE6V[a\0\xD8V[\x90V[\x90V[\x90a\r7a\r2a\r>\x92a\r\x03V[a\r\x1FV[\x82Ta\x0C\xEDV[\x90UV[Q\x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a\ro\x91\x02\x91a\ri_\x19\x84a\rPV[\x92a\rPV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x91\x90a\r\x8Fa\r\x8Aa\r\x97\x93a\r\x03V[a\r\x1FV[\x90\x83Ta\rTV[\x90UV[a\r\xAD\x91a\r\xA7a\t\xDBV[\x91a\ryV[V[[\x81\x81\x10a\r\xBBWPPV[\x80a\r\xC8_`\x01\x93a\r\x9BV[\x01a\r\xB0V[\x91\x90`\x1F\x81\x11a\r\xDEW[PPPV[a\r\xEAa\x0E\x0F\x93a\x05RV[\x90` a\r\xF6\x84a\rFV[\x83\x01\x93\x10a\x0E\x17W[a\x0E\x08\x90a\rFV[\x01\x90a\r\xAFV[_\x80\x80a\r\xD9V[\x91Pa\x0E\x08\x81\x92\x90Pa\r\xFFV[\x90a\x0E5\x90_\x19\x90`\x08\x02a\x03\xC2V[\x19\x16\x90V[\x81a\x0ED\x91a\x0E%V[\x90`\x02\x02\x17\x90V[\x90a\x0EV\x81a\0\xE8V[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x0F\x16Wa\x0Ez\x82a\x0Et\x85Ta\x05(V[\x85a\r\xCEV[` \x90`\x1F\x83\x11`\x01\x14a\x0E\xAEW\x91\x80\x91a\x0E\x9D\x93_\x92a\x0E\xA2W[PPa\x0E:V[\x90U[V[\x90\x91P\x01Q_\x80a\x0E\x96V[`\x1F\x19\x83\x16\x91a\x0E\xBD\x85a\x05RV[\x92_[\x81\x81\x10a\x0E\xFEWP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\x0E\xE4W[PPP\x02\x01\x90Ua\x0E\xA0V[a\x0E\xF4\x91\x01Q`\x1F\x84\x16\x90a\x0E%V[\x90U_\x80\x80a\x0E\xD8V[\x91\x93` `\x01\x81\x92\x87\x87\x01Q\x81U\x01\x95\x01\x92\x01a\x0E\xC0V[a\x05\xF4V[\x90a\x0F%\x91a\x0ELV[V[\x90a\x0F\x84```\x03a\x0F\x8A\x94a\x0FJ_\x82\x01a\x0FD_\x88\x01a\x0C\x89V[\x90a\x0C\xC0V[a\x0Fc`\x01\x82\x01a\x0F]` \x88\x01a\x0C\xE0V[\x90a\r\"V[a\x0F|`\x02\x82\x01a\x0Fv`@\x88\x01a\rBV[\x90a\x0F\x1BV[\x01\x92\x01a\x0C\xE0V[\x90a\r\"V[V[\x91\x90a\x0F\x9DWa\x0F\x9B\x91a\x0F'V[V[a\x0CvV[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15a\x0F\xD2W\x82a\x0F\xCA\x91`\x01a\x0F\xD0\x95\x01\x81Ua\x0CNV[\x90a\x0F\x8CV[V[a\x05\xF4V[\x90\x91\x92a\x0F\xF5a\x0F\xF0a\x0F\xEA`\x01a\n_V[\x15a\x024V[a\n\xC5V[a\x10\x06a\x10\x01\x83a\x0B\x16V[a\x0B.V[\x93` c#\xB8r\xDD\x953\x90a\x107_a\x10\x1E0a\x0B:V[\x99a\x10B\x8Aa\x10+a\0\x97V[\x9C\x8D\x97\x88\x96\x87\x95a\x0BFV[\x85R`\x04\x85\x01a\x0ByV[\x03\x92Z\xF1\x94\x85\x15a\x10\xDAWa\x10\x95a\x10\xA7\x93a\x10\x9E\x92a\x10\xAC\x98a\x10\xAEW[Pa\x10k_a\x0B\xBBV[\x95\x96\x93a\x10\x904\x95a\x10\x87a\x10~a\x0B\xBEV[\x9A_\x8C\x01a\x08\xE8V[` \x8A\x01a\x08\xF6V[a\x0C3V[`@\x86\x01a\t\x04V[``\x84\x01a\x08\xF6V[a\x0F\xA2V[V[a\x10\xCE\x90` =\x81\x11a\x10\xD3W[a\x10\xC6\x81\x83a\x06\x08V[\x81\x01\x90a\x0B[V[a\x10aV[P=a\x10\xBCV[a\x0B\xABV[a\x10\xFAa\x10\xF5a\x10\xEF`\x01a\n_V[\x15a\x024V[a\n\xC5V[V[a\x11\x10a\x11\x0Ba\x11\x15\x92a\x07\xE3V[a\x07\xE6V[a\0\xB4V[\x90V[a\x11!\x90a\x10\xFCV[\x90V[a\x11?a\x11:a\x114`\x01a\n_V[\x15a\x024V[a\n\xC5V[a\x11\xA8a\x11K_a\x0B\xBBV[a\x11T_a\x11\x18V[\x90a\x11\xA3_a\x11\x9Aa\x11\x91_6\x90a\x11\x8Ca\x11\x834\x96a\x11~a\x11ua\x0B\xBEV[\x9B_\x8D\x01a\x08\xE8V[a\x07\xE9V[` \x8A\x01a\x08\xF6V[a\x0C3V[`@\x86\x01a\t\x04V[``\x84\x01a\x08\xF6V[a\x0F\xA2V[V",
    );
    /**```solidity
struct BridgeCall { address token; uint256 amount; bytes data; uint256 value; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BridgeCall {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BridgeCall> for UnderlyingRustTuple<'_> {
            fn from(value: BridgeCall) -> Self {
                (value.token, value.amount, value.data, value.value)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BridgeCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    token: tuple.0,
                    amount: tuple.1,
                    data: tuple.2,
                    value: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for BridgeCall {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for BridgeCall {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BridgeCall {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for BridgeCall {
            const NAME: &'static str = "BridgeCall";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "BridgeCall(address token,uint256 amount,bytes data,uint256 value)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.token,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.data,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.value)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BridgeCall {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.token,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.data,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.value)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.token,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.data,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.value,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Function with signature `bridgeCalls(uint256)` and selector `0xd71f00a1`.
```solidity
function bridgeCalls(uint256) external view returns (address token, uint256 amount, bytes memory data, uint256 value);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeCallsCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`bridgeCalls(uint256)`](bridgeCallsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeCallsReturn {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeCallsCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeCallsCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeCallsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeCallsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeCallsReturn) -> Self {
                    (value.token, value.amount, value.data, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeCallsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        token: tuple.0,
                        amount: tuple.1,
                        data: tuple.2,
                        value: tuple.3,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeCallsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeCallsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeCalls(uint256)";
            const SELECTOR: [u8; 4] = [215u8, 31u8, 0u8, 161u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeTokens(address,uint256,bytes)` and selector `0xc759c78e`.
```solidity
function bridgeTokens(address token, uint256 amount, bytes memory data) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeTokensCall {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`bridgeTokens(address,uint256,bytes)`](bridgeTokensCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeTokensReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeTokensCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeTokensCall) -> Self {
                    (value.token, value.amount, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeTokensCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        token: tuple.0,
                        amount: tuple.1,
                        data: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeTokensReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeTokensReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeTokensReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeTokensCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeTokensReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeTokens(address,uint256,bytes)";
            const SELECTOR: [u8; 4] = [199u8, 89u8, 199u8, 142u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBridgeCallCount()` and selector `0x3ae0d321`.
```solidity
function getBridgeCallCount() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeCallCountCall {}
    ///Container type for the return parameters of the [`getBridgeCallCount()`](getBridgeCallCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeCallCountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeCallCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeCallCountCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeCallCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeCallCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeCallCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeCallCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBridgeCallCountCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBridgeCallCountReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBridgeCallCount()";
            const SELECTOR: [u8; 4] = [58u8, 224u8, 211u8, 33u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getLastBridgeCall()` and selector `0x246ce2c6`.
```solidity
function getLastBridgeCall() external view returns (BridgeCall memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getLastBridgeCallCall {}
    ///Container type for the return parameters of the [`getLastBridgeCall()`](getLastBridgeCallCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getLastBridgeCallReturn {
        #[allow(missing_docs)]
        pub _0: <BridgeCall as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLastBridgeCallCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getLastBridgeCallCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getLastBridgeCallCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BridgeCall,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BridgeCall as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLastBridgeCallReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getLastBridgeCallReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getLastBridgeCallReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getLastBridgeCallCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getLastBridgeCallReturn;
            type ReturnTuple<'a> = (BridgeCall,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getLastBridgeCall()";
            const SELECTOR: [u8; 4] = [36u8, 108u8, 226u8, 198u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setShouldRevert(bool)` and selector `0x6813d787`.
```solidity
function setShouldRevert(bool _shouldRevert) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setShouldRevertCall {
        #[allow(missing_docs)]
        pub _shouldRevert: bool,
    }
    ///Container type for the return parameters of the [`setShouldRevert(bool)`](setShouldRevertCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setShouldRevertReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setShouldRevertCall> for UnderlyingRustTuple<'_> {
                fn from(value: setShouldRevertCall) -> Self {
                    (value._shouldRevert,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setShouldRevertCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _shouldRevert: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setShouldRevertReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setShouldRevertReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setShouldRevertReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setShouldRevertCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bool,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setShouldRevertReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setShouldRevert(bool)";
            const SELECTOR: [u8; 4] = [104u8, 19u8, 215u8, 135u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self._shouldRevert,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `shouldRevert()` and selector `0xd3072d82`.
```solidity
function shouldRevert() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct shouldRevertCall {}
    ///Container type for the return parameters of the [`shouldRevert()`](shouldRevertCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct shouldRevertReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<shouldRevertCall> for UnderlyingRustTuple<'_> {
                fn from(value: shouldRevertCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for shouldRevertCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<shouldRevertReturn> for UnderlyingRustTuple<'_> {
                fn from(value: shouldRevertReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for shouldRevertReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for shouldRevertCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = shouldRevertReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "shouldRevert()";
            const SELECTOR: [u8; 4] = [211u8, 7u8, 45u8, 130u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`MockBridgeTarget`](self) function calls.
    pub enum MockBridgeTargetCalls {
        #[allow(missing_docs)]
        bridgeCalls(bridgeCallsCall),
        #[allow(missing_docs)]
        bridgeTokens(bridgeTokensCall),
        #[allow(missing_docs)]
        getBridgeCallCount(getBridgeCallCountCall),
        #[allow(missing_docs)]
        getLastBridgeCall(getLastBridgeCallCall),
        #[allow(missing_docs)]
        setShouldRevert(setShouldRevertCall),
        #[allow(missing_docs)]
        shouldRevert(shouldRevertCall),
    }
    #[automatically_derived]
    impl MockBridgeTargetCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [36u8, 108u8, 226u8, 198u8],
            [58u8, 224u8, 211u8, 33u8],
            [104u8, 19u8, 215u8, 135u8],
            [199u8, 89u8, 199u8, 142u8],
            [211u8, 7u8, 45u8, 130u8],
            [215u8, 31u8, 0u8, 161u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for MockBridgeTargetCalls {
        const NAME: &'static str = "MockBridgeTargetCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 6usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::bridgeCalls(_) => {
                    <bridgeCallsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeTokens(_) => {
                    <bridgeTokensCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBridgeCallCount(_) => {
                    <getBridgeCallCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getLastBridgeCall(_) => {
                    <getLastBridgeCallCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setShouldRevert(_) => {
                    <setShouldRevertCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::shouldRevert(_) => {
                    <shouldRevertCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<MockBridgeTargetCalls>] = &[
                {
                    fn getLastBridgeCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeTargetCalls> {
                        <getLastBridgeCallCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeTargetCalls::getLastBridgeCall)
                    }
                    getLastBridgeCall
                },
                {
                    fn getBridgeCallCount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeTargetCalls> {
                        <getBridgeCallCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeTargetCalls::getBridgeCallCount)
                    }
                    getBridgeCallCount
                },
                {
                    fn setShouldRevert(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeTargetCalls> {
                        <setShouldRevertCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeTargetCalls::setShouldRevert)
                    }
                    setShouldRevert
                },
                {
                    fn bridgeTokens(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeTargetCalls> {
                        <bridgeTokensCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeTargetCalls::bridgeTokens)
                    }
                    bridgeTokens
                },
                {
                    fn shouldRevert(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeTargetCalls> {
                        <shouldRevertCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeTargetCalls::shouldRevert)
                    }
                    shouldRevert
                },
                {
                    fn bridgeCalls(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockBridgeTargetCalls> {
                        <bridgeCallsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockBridgeTargetCalls::bridgeCalls)
                    }
                    bridgeCalls
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::bridgeCalls(inner) => {
                    <bridgeCallsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bridgeTokens(inner) => {
                    <bridgeTokensCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBridgeCallCount(inner) => {
                    <getBridgeCallCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getLastBridgeCall(inner) => {
                    <getLastBridgeCallCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setShouldRevert(inner) => {
                    <setShouldRevertCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::shouldRevert(inner) => {
                    <shouldRevertCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::bridgeCalls(inner) => {
                    <bridgeCallsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeTokens(inner) => {
                    <bridgeTokensCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBridgeCallCount(inner) => {
                    <getBridgeCallCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getLastBridgeCall(inner) => {
                    <getLastBridgeCallCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setShouldRevert(inner) => {
                    <setShouldRevertCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::shouldRevert(inner) => {
                    <shouldRevertCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`MockBridgeTarget`](self) contract instance.

See the [wrapper's documentation](`MockBridgeTargetInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> MockBridgeTargetInstance<T, P, N> {
        MockBridgeTargetInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<MockBridgeTargetInstance<T, P, N>>,
    > {
        MockBridgeTargetInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        MockBridgeTargetInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`MockBridgeTarget`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`MockBridgeTarget`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct MockBridgeTargetInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for MockBridgeTargetInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("MockBridgeTargetInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MockBridgeTargetInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`MockBridgeTarget`](self) contract instance.

See the [wrapper's documentation](`MockBridgeTargetInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<MockBridgeTargetInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> MockBridgeTargetInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> MockBridgeTargetInstance<T, P, N> {
            MockBridgeTargetInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MockBridgeTargetInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`bridgeCalls`] function.
        pub fn bridgeCalls(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeCallsCall, N> {
            self.call_builder(&bridgeCallsCall { _0 })
        }
        ///Creates a new call builder for the [`bridgeTokens`] function.
        pub fn bridgeTokens(
            &self,
            token: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeTokensCall, N> {
            self.call_builder(
                &bridgeTokensCall {
                    token,
                    amount,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`getBridgeCallCount`] function.
        pub fn getBridgeCallCount(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBridgeCallCountCall, N> {
            self.call_builder(&getBridgeCallCountCall {})
        }
        ///Creates a new call builder for the [`getLastBridgeCall`] function.
        pub fn getLastBridgeCall(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getLastBridgeCallCall, N> {
            self.call_builder(&getLastBridgeCallCall {})
        }
        ///Creates a new call builder for the [`setShouldRevert`] function.
        pub fn setShouldRevert(
            &self,
            _shouldRevert: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, setShouldRevertCall, N> {
            self.call_builder(
                &setShouldRevertCall {
                    _shouldRevert,
                },
            )
        }
        ///Creates a new call builder for the [`shouldRevert`] function.
        pub fn shouldRevert(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, shouldRevertCall, N> {
            self.call_builder(&shouldRevertCall {})
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MockBridgeTargetInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
