///Module containing a contract's types and functions.
/**

```solidity
library Checkpoints {
    struct Checkpoint208 { uint48 _key; uint208 _value; }
}
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod Checkpoints {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /**```solidity
struct Checkpoint208 { uint48 _key; uint208 _value; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Checkpoint208 {
        #[allow(missing_docs)]
        pub _key: alloy::sol_types::private::primitives::aliases::U48,
        #[allow(missing_docs)]
        pub _value: alloy::sol_types::private::primitives::aliases::U208,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<48>,
            alloy::sol_types::sol_data::Uint<208>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U48,
            alloy::sol_types::private::primitives::aliases::U208,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Checkpoint208> for UnderlyingRustTuple<'_> {
            fn from(value: Checkpoint208) -> Self {
                (value._key, value._value)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Checkpoint208 {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    _key: tuple.0,
                    _value: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Checkpoint208 {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Checkpoint208 {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(&self._key),
                    <alloy::sol_types::sol_data::Uint<
                        208,
                    > as alloy_sol_types::SolType>::tokenize(&self._value),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Checkpoint208 {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Checkpoint208 {
            const NAME: &'static str = "Checkpoint208";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Checkpoint208(uint48 _key,uint208 _value)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self._key)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        208,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self._value)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Checkpoint208 {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust._key)
                    + <alloy::sol_types::sol_data::Uint<
                        208,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust._value,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    48,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust._key,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    208,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust._value,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`Checkpoints`](self) contract instance.

See the [wrapper's documentation](`CheckpointsInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> CheckpointsInstance<T, P, N> {
        CheckpointsInstance::<T, P, N>::new(address, provider)
    }
    /**A [`Checkpoints`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`Checkpoints`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct CheckpointsInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for CheckpointsInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("CheckpointsInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > CheckpointsInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`Checkpoints`](self) contract instance.

See the [wrapper's documentation](`CheckpointsInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> CheckpointsInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> CheckpointsInstance<T, P, N> {
            CheckpointsInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > CheckpointsInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > CheckpointsInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
///Module containing a contract's types and functions.
/**

```solidity
library IBridgeRateLimiter {
    struct BridgeConfig { uint256 dailyMintLimit; uint256 dailyBurnLimit; bool isActive; }
}
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod IBridgeRateLimiter {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /**```solidity
struct BridgeConfig { uint256 dailyMintLimit; uint256 dailyBurnLimit; bool isActive; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BridgeConfig {
        #[allow(missing_docs)]
        pub dailyMintLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub dailyBurnLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub isActive: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Bool,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            bool,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BridgeConfig> for UnderlyingRustTuple<'_> {
            fn from(value: BridgeConfig) -> Self {
                (value.dailyMintLimit, value.dailyBurnLimit, value.isActive)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BridgeConfig {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    dailyMintLimit: tuple.0,
                    dailyBurnLimit: tuple.1,
                    isActive: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for BridgeConfig {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for BridgeConfig {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.dailyMintLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.dailyBurnLimit),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.isActive,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BridgeConfig {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for BridgeConfig {
            const NAME: &'static str = "BridgeConfig";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "BridgeConfig(uint256 dailyMintLimit,uint256 dailyBurnLimit,bool isActive)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.dailyMintLimit,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.dailyBurnLimit,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.isActive,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BridgeConfig {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.dailyMintLimit,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.dailyBurnLimit,
                    )
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.isActive,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.dailyMintLimit,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.dailyBurnLimit,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.isActive,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`IBridgeRateLimiter`](self) contract instance.

See the [wrapper's documentation](`IBridgeRateLimiterInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> IBridgeRateLimiterInstance<T, P, N> {
        IBridgeRateLimiterInstance::<T, P, N>::new(address, provider)
    }
    /**A [`IBridgeRateLimiter`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`IBridgeRateLimiter`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct IBridgeRateLimiterInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for IBridgeRateLimiterInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("IBridgeRateLimiterInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > IBridgeRateLimiterInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`IBridgeRateLimiter`](self) contract instance.

See the [wrapper's documentation](`IBridgeRateLimiterInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> IBridgeRateLimiterInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> IBridgeRateLimiterInstance<T, P, N> {
            IBridgeRateLimiterInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > IBridgeRateLimiterInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > IBridgeRateLimiterInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
/**

Generated by the following Solidity interface...
```solidity
library Checkpoints {
    struct Checkpoint208 {
        uint48 _key;
        uint208 _value;
    }
}

library IBridgeRateLimiter {
    struct BridgeConfig {
        uint256 dailyMintLimit;
        uint256 dailyBurnLimit;
        bool isActive;
    }
}

interface SyndicateTokenCrosschain {
    error AccessControlBadConfirmation();
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
    error BridgeMustBeContract();
    error BridgeNotActive(address bridge);
    error BurnOnlyDuringLockPeriod();
    error CannotAddSelfAsBridge();
    error CheckpointUnorderedInsertion();
    error ECDSAInvalidSignature();
    error ECDSAInvalidSignatureLength(uint256 length);
    error ECDSAInvalidSignatureS(bytes32 s);
    error ERC20ExceededSafeSupply(uint256 increasedSupply, uint256 cap);
    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);
    error ERC20InvalidApprover(address approver);
    error ERC20InvalidReceiver(address receiver);
    error ERC20InvalidSender(address sender);
    error ERC20InvalidSpender(address spender);
    error ERC2612ExpiredSignature(uint256 deadline);
    error ERC2612InvalidSigner(address signer, address owner);
    error ERC5805FutureLookup(uint256 timepoint, uint48 clock);
    error ERC6372InconsistentClock();
    error ExceedsTotalSupply();
    error InsufficientBurnLimit(address bridge, uint256 requested, uint256 available);
    error InsufficientEmissionBudget();
    error InsufficientMintLimit(address bridge, uint256 requested, uint256 available);
    error InvalidAccountNonce(address account, uint256 currentNonce);
    error InvalidShortString();
    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);
    error StringTooLong(string str);
    error TransfersLocked();
    error UnauthorizedBridge(address bridge);
    error UnlockTimestampInPast();
    error UnlockTimestampTooLate();
    error UnreasonableBurnLimit();
    error UnreasonableMintLimit();
    error VotesExpiredSignature(uint256 expiry);
    error ZeroAddress();
    error ZeroAmount();

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event BridgeActiveStatusChanged(address indexed bridge, bool isActive);
    event BridgeAdded(address indexed bridge, uint256 dailyMintLimit, uint256 dailyBurnLimit);
    event BridgeLimitsSet(address indexed bridge, uint256 dailyMintLimit, uint256 dailyBurnLimit);
    event BridgeRemoved(address indexed bridge);
    event CrosschainBurn(address indexed from, uint256 amount, address indexed bridge);
    event CrosschainMint(address indexed to, uint256 amount, address indexed bridge);
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    event DelegateVotesChanged(address indexed delegate, uint256 previousVotes, uint256 newVotes);
    event EIP712DomainChanged();
    event EmissionBudgetAllocated(address indexed bridge, uint256 amount);
    event EmissionBudgetConsumed(address indexed bridge, uint256 amount);
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
    event TokensBurnedByManager(address indexed from, uint256 amount, address indexed burner);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event UnlockTimestampUpdated(uint256 oldTimestamp, uint256 newTimestamp, address indexed updatedBy);

    constructor(address defaultAdmin, address syndTreasuryAddress);

    function AIRDROP_MANAGER_ROLE() external view returns (bytes32);
    function BRIDGE_MANAGER_ROLE() external view returns (bytes32);
    function CLOCK_MODE() external view returns (string memory);
    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function EMISSION_BUDGET_MANAGER_ROLE() external view returns (bytes32);
    function EMISSION_MINTER_ROLE() external view returns (bytes32);
    function INITIAL_MINT_SUPPLY() external view returns (uint256);
    function MAX_LOCK_DURATION() external view returns (uint256);
    function TOTAL_SUPPLY() external view returns (uint256);
    function allocateEmissionBudget(address bridge, uint256 amount) external;
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function bridgeConfigs(address) external view returns (uint256 dailyMintLimit, uint256 dailyBurnLimit, bool isActive);
    function bridgeEmissionBudgets(address) external view returns (uint256);
    function burn(uint256 amount) external;
    function burnFrom(address from, uint256 amount) external;
    function checkpoints(address account, uint32 pos) external view returns (Checkpoints.Checkpoint208 memory);
    function clock() external view returns (uint48);
    function crosschainBurn(address from, uint256 amount) external;
    function crosschainMint(address to, uint256 amount) external;
    function decimals() external view returns (uint8);
    function delegate(address delegatee) external;
    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;
    function delegates(address account) external view returns (address);
    function eip712Domain() external view returns (bytes1 fields, string memory name, string memory version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] memory extensions);
    function getAllBridges() external view returns (address[] memory allBridges);
    function getAvailableBurnLimit(address bridge) external view returns (uint256 available);
    function getAvailableMintLimit(address bridge) external view returns (uint256 available);
    function getBridgeAtIndex(uint256 index) external view returns (address bridge);
    function getBridgeConfig(address bridge) external view returns (IBridgeRateLimiter.BridgeConfig memory config);
    function getBridgeCount() external view returns (uint256 count);
    function getCurrentTotalSupply() external view returns (uint256);
    function getEmissionBudget(address bridge) external view returns (uint256 budget);
    function getPastTotalSupply(uint256 timepoint) external view returns (uint256);
    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);
    function getPastVotingPower(address account, uint256 blockNumber) external view returns (uint256);
    function getRemainingEmissions() external view returns (uint256);
    function getRemainingLockTime() external view returns (uint256);
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function getVotes(address account) external view returns (uint256);
    function getVotingPower(address account) external view returns (uint256);
    function grantRole(bytes32 role, address account) external;
    function hasRole(bytes32 role, address account) external view returns (bool);
    function hourlyBurnUsage(address, uint256) external view returns (uint256);
    function hourlyMintUsage(address, uint256) external view returns (uint256);
    function isBridgeAuthorized(address bridge) external view returns (bool authorized);
    function maxLockTimestamp() external view returns (uint256);
    function mint(address to, uint256 amount) external;
    function name() external view returns (string memory);
    function nonces(address owner) external view returns (uint256);
    function numCheckpoints(address account) external view returns (uint32);
    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
    function removeBridge(address bridge) external;
    function renounceRole(bytes32 role, address callerConfirmation) external;
    function revokeRole(bytes32 role, address account) external;
    function setBridgeActive(address bridge, bool isActive) external;
    function setBridgeLimits(address bridge, uint256 dailyMintLimit, uint256 dailyBurnLimit) external;
    function setUnlockTimestamp(uint256 newUnlockTimestamp) external;
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
    function symbol() external view returns (string memory);
    function totalSupply() external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
    function transfersLocked() external view returns (bool);
    function unlockTimestamp() external view returns (uint256);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "defaultAdmin",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "syndTreasuryAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "AIRDROP_MANAGER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "BRIDGE_MANAGER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "CLOCK_MODE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DEFAULT_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DOMAIN_SEPARATOR",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSION_BUDGET_MANAGER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSION_MINTER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "INITIAL_MINT_SUPPLY",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "MAX_LOCK_DURATION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "TOTAL_SUPPLY",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "allocateEmissionBudget",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "allowance",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "approve",
    "inputs": [
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "balanceOf",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeConfigs",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "dailyMintLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "dailyBurnLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "isActive",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeEmissionBudgets",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "burn",
    "inputs": [
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "burnFrom",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkpoints",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "pos",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct Checkpoints.Checkpoint208",
        "components": [
          {
            "name": "_key",
            "type": "uint48",
            "internalType": "uint48"
          },
          {
            "name": "_value",
            "type": "uint208",
            "internalType": "uint208"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "clock",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint48",
        "internalType": "uint48"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "crosschainBurn",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "crosschainMint",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "decimals",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "uint8"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "delegate",
    "inputs": [
      {
        "name": "delegatee",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "delegateBySig",
    "inputs": [
      {
        "name": "delegatee",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "nonce",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "expiry",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "v",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "r",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "delegates",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "eip712Domain",
    "inputs": [],
    "outputs": [
      {
        "name": "fields",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "version",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "verifyingContract",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "salt",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "extensions",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getAllBridges",
    "inputs": [],
    "outputs": [
      {
        "name": "allBridges",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getAvailableBurnLimit",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "available",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getAvailableMintLimit",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "available",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBridgeAtIndex",
    "inputs": [
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBridgeConfig",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "config",
        "type": "tuple",
        "internalType": "struct IBridgeRateLimiter.BridgeConfig",
        "components": [
          {
            "name": "dailyMintLimit",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "dailyBurnLimit",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "isActive",
            "type": "bool",
            "internalType": "bool"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBridgeCount",
    "inputs": [],
    "outputs": [
      {
        "name": "count",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCurrentTotalSupply",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getEmissionBudget",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "budget",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPastTotalSupply",
    "inputs": [
      {
        "name": "timepoint",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPastVotes",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "timepoint",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPastVotingPower",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "blockNumber",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRemainingEmissions",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRemainingLockTime",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleAdmin",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getVotes",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getVotingPower",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "grantRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "hasRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "hourlyBurnUsage",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "hourlyMintUsage",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isBridgeAuthorized",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "authorized",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "maxLockTimestamp",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "mint",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "name",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "nonces",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "numCheckpoints",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "permit",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "deadline",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "v",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "r",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeBridge",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "callerConfirmation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBridgeActive",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "isActive",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBridgeLimits",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "dailyMintLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "dailyBurnLimit",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setUnlockTimestamp",
    "inputs": [
      {
        "name": "newUnlockTimestamp",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "symbol",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "totalSupply",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "transfer",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferFrom",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transfersLocked",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "unlockTimestamp",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "event",
    "name": "Approval",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "spender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeActiveStatusChanged",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "isActive",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeAdded",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "dailyMintLimit",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "dailyBurnLimit",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeLimitsSet",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "dailyMintLimit",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "dailyBurnLimit",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeRemoved",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "CrosschainBurn",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "bridge",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "CrosschainMint",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "bridge",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DelegateChanged",
    "inputs": [
      {
        "name": "delegator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "fromDelegate",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "toDelegate",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DelegateVotesChanged",
    "inputs": [
      {
        "name": "delegate",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "previousVotes",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "newVotes",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EIP712DomainChanged",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EmissionBudgetAllocated",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EmissionBudgetConsumed",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleAdminChanged",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "previousAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleGranted",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleRevoked",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TokensBurnedByManager",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "burner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Transfer",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "UnlockTimestampUpdated",
    "inputs": [
      {
        "name": "oldTimestamp",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "newTimestamp",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "updatedBy",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AccessControlBadConfirmation",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AccessControlUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "neededRole",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "BridgeMustBeContract",
    "inputs": []
  },
  {
    "type": "error",
    "name": "BridgeNotActive",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "BurnOnlyDuringLockPeriod",
    "inputs": []
  },
  {
    "type": "error",
    "name": "CannotAddSelfAsBridge",
    "inputs": []
  },
  {
    "type": "error",
    "name": "CheckpointUnorderedInsertion",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignature",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureLength",
    "inputs": [
      {
        "name": "length",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureS",
    "inputs": [
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20ExceededSafeSupply",
    "inputs": [
      {
        "name": "increasedSupply",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "cap",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InsufficientAllowance",
    "inputs": [
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "allowance",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "needed",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InsufficientBalance",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "balance",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "needed",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidApprover",
    "inputs": [
      {
        "name": "approver",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidReceiver",
    "inputs": [
      {
        "name": "receiver",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidSender",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidSpender",
    "inputs": [
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC2612ExpiredSignature",
    "inputs": [
      {
        "name": "deadline",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC2612InvalidSigner",
    "inputs": [
      {
        "name": "signer",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC5805FutureLookup",
    "inputs": [
      {
        "name": "timepoint",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "clock",
        "type": "uint48",
        "internalType": "uint48"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC6372InconsistentClock",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ExceedsTotalSupply",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientBurnLimit",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "requested",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "available",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientEmissionBudget",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientMintLimit",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "requested",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "available",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidAccountNonce",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "currentNonce",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidShortString",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SafeCastOverflowedUintDowncast",
    "inputs": [
      {
        "name": "bits",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "StringTooLong",
    "inputs": [
      {
        "name": "str",
        "type": "string",
        "internalType": "string"
      }
    ]
  },
  {
    "type": "error",
    "name": "TransfersLocked",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UnauthorizedBridge",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "UnlockTimestampInPast",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UnlockTimestampTooLate",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UnreasonableBurnLimit",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UnreasonableMintLimit",
    "inputs": []
  },
  {
    "type": "error",
    "name": "VotesExpiredSignature",
    "inputs": [
      {
        "name": "expiry",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ZeroAddress",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroAmount",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod SyndicateTokenCrosschain {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x610180604052346100845761001b610015610158565b906101c2565b610023610089565b616d10611d138239608051816146b4015260a051816146eb015260c0518161467b015260e05181615386015261010051816153ab01526101205181614c8e01526101405181614cce01526101605181818161128501526134f50152616d1090f35b61008f565b60405190565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b906100bb90610093565b810190811060018060401b038211176100d357604052565b61009d565b906100eb6100e4610089565b92836100b1565b565b5f80fd5b60018060a01b031690565b610105906100f1565b90565b610111816100fc565b0361011857565b5f80fd5b9050519061012982610108565b565b91906040838203126101535780610147610150925f860161011c565b9360200161011c565b90565b6100ed565b610176618a238038038061016b816100d8565b92833981019061012b565b9091565b7fcce296b040332a080e6df13515a3ec2869e21cd20f7344af0987ddb938d8bd2190565b7f820372a9faf82db3cc5fc36ffab5f096eef69b95fbf50591e0d71447aa1ba70090565b6101cf6101ef92826101f2565b6101e16101da61017a565b82906109d1565b506101ea61019e565b6109d1565b50565b906101fc916101fe565b565b906102089161044d565b565b60018060401b03811161022657610222602091610093565b0190565b61009d565b9061023d6102388361020a565b6100d8565b918252565b5f7f53796e6469636174650000000000000000000000000000000000000000000000910152565b610273600961022b565b9061028060208301610242565b565b61028a610269565b90565b5f7f53594e4400000000000000000000000000000000000000000000000000000000910152565b6102be600461022b565b906102cb6020830161028d565b565b6102d56102b4565b90565b90565b90565b6102f26102ed6102f7926102d8565b6102db565b6100f1565b90565b610303906102de565b90565b5f0190565b90565b90565b61032561032061032a9261030b565b6102db565b61030e565b90565b6103396276a700610311565b90565b634e487b7160e01b5f52601160045260245ffd5b61035f6103659193929361030e565b9261030e565b820180921161037057565b61033c565b61038961038461038e926102d8565b6102db565b61030e565b90565b5f1b90565b906103a25f1991610391565b9181191691161790565b6103c06103bb6103c59261030e565b6102db565b61030e565b90565b90565b906103e06103db6103e7926103ac565b6103c8565b8254610396565b9055565b90565b6104026103fd610407926102d8565b610391565b6103eb565b90565b6104135f6103ee565b90565b90565b61042d61042861043292610416565b6102db565b61030e565b90565b61044a6b02e87669c308736a04000000610419565b90565b9061046f610459610282565b610461610282565b6104696102cd565b91610535565b8161048a61048461047f5f6102fa565b6100fc565b916100fc565b1461051957806104aa6104a461049f5f6102fa565b6100fc565b916100fc565b146104fd576104ec6104fb926104c8426104c261032d565b90610350565b610160526104df6104d85f610375565b600c6103cb565b6104e761040a565b6109d1565b506104f5610435565b90610a9f565b565b5f63d92e233d60e01b81528061051560048201610306565b0390fd5b5f63d92e233d60e01b81528061053160048201610306565b0390fd5b906105409291610542565b565b9061054d929161054f565b565b9061055a929161055c565b565b906105679291610569565b565b9061057492916105c1565b565b5f7f3100000000000000000000000000000000000000000000000000000000000000910152565b6105a7600161022b565b906105b460208301610576565b565b6105be61059d565b90565b906105d592916105cf6105b6565b906105d7565b565b906105e3939291610629565b565b90565b90565b60200190565b5190565b61060961060461060e926100f1565b6102db565b6100f1565b90565b61061a906105f5565b90565b61062690610611565b90565b61063a61068a9461066f93946106be565b61064e8161064860066105e5565b90610b4c565b610120526106668361066060076105e5565b90610b4c565b610140526105e8565b61068161067b826105f1565b916105eb565b2060e0526105e8565b61069c610696826105f1565b916105eb565b20610100524660a0526106ad610c51565b6080526106b93061061d565b60c052565b906106c8916106ca565b565b906106d4916106d6565b565b906106e091610927565b565b634e487b7160e01b5f525f60045260245ffd5b5190565b634e487b7160e01b5f52602260045260245ffd5b906001600283049216801561072d575b602083101461072857565b6106f9565b91607f169161071d565b5f5260205f2090565b601f602091010490565b1b90565b919060086107699102916107635f198461074a565b9261074a565b9181191691161790565b9190610789610784610791936103ac565b6103c8565b90835461074e565b9055565b5f90565b6107ab916107a5610795565b91610773565b565b5b8181106107b9575050565b806107c65f600193610799565b016107ae565b9190601f81116107dc575b505050565b6107e861080d93610737565b9060206107f484610740565b83019310610815575b61080690610740565b01906107ad565b5f80806107d7565b9150610806819290506107fd565b1c90565b90610837905f1990600802610823565b191690565b8161084691610827565b906002021790565b90610858816106f5565b9060018060401b0382116109165761087a82610874855461070d565b856107cc565b602090601f83116001146108ae5791809161089d935f926108a2575b505061083c565b90555b565b90915001515f80610896565b601f198316916108bd85610737565b925f5b8181106108fe575091600293918560019694106108e4575b505050020190556108a0565b6108f4910151601f841690610827565b90555f80806108d8565b919360206001819287870151815501950192016108c0565b61009d565b906109259161084e565b565b9061093661093d92600361091b565b600461091b565b565b5f90565b151590565b610951906103eb565b90565b9061095e90610948565b5f5260205260405f2090565b61097390610611565b90565b906109809061096a565b5f5260205260405f2090565b9061099860ff91610391565b9181191691161790565b6109ab90610943565b90565b90565b906109c66109c16109cd926109a2565b6109ae565b825461098c565b9055565b6109d961093f565b506109ee6109e8828490610cee565b15610943565b5f14610a7757610a166001610a115f610a0960058690610954565b018590610976565b6109b1565b90610a1f610d1c565b90610a5c610a56610a507f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d95610948565b9261096a565b9261096a565b92610a65610089565b80610a6f81610306565b0390a4600190565b50505f90565b610a86906100fc565b9052565b9190610a9d905f60208501940190610a7d565b565b80610aba610ab4610aaf5f6102fa565b6100fc565b916100fc565b14610ad657610ad491610acc5f6102fa565b919091610d4d565b565b610af9610ae25f6102fa565b5f91829163ec442f0560e01b835260048301610a8a565b0390fd5b5f90565b90565b610b18610b13610b1d92610b01565b6102db565b61030e565b90565b90565b610b37610b32610b3c92610b20565b610391565b6103eb565b90565b610b4960ff610b23565b90565b90610b55610afd565b50610b67610b62836105e8565b6105f1565b610b7a610b746020610b04565b9161030e565b105f14610b8e5750610b8b90610ee7565b90565b5f610b9c610ba29392610df7565b0161091b565b610bb2610bad610b3f565b610948565b90565b5f90565b7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f90565b610be790516103eb565b90565b610bf3906103eb565b9052565b610c009061030e565b9052565b90959492610c4f94610c3e610c4892610c34608096610c2a60a088019c5f890190610bea565b6020870190610bea565b6040850190610bea565b6060830190610bf7565b0190610a7d565b565b610c59610bb5565b50610c62610bb9565b610cac610c6f60e0610bdd565b91610c9d610c7e610100610bdd565b46610c883061061d565b91610c91610089565b96879560208701610c04565b602082018103825203826100b1565b610cbe610cb8826105f1565b916105eb565b2090565b5f1c90565b60ff1690565b610cd9610cde91610cc2565b610cc7565b90565b610ceb9054610ccd565b90565b610d15915f610d0a610d1093610d0261093f565b506005610954565b01610976565b610ce1565b90565b5f90565b610d24610d18565b503390565b7f84fe74c71a28b69aa960486ca0e8c1418c86e9ea2cd6b5849b95e2c8f407a67490565b9182610d69610d63610d5e5f6102fa565b6100fc565b916100fc565b141580610dd4575b610d84575b610d829291909161100b565b565b610d8c610f95565b80610db3575b15610d76575f6336e278fd60e21b815280610daf60048201610306565b0390fd5b50610dcf610dc9610dc2610d29565b3390610cee565b15610943565b610d92565b5081610df0610dea610de55f6102fa565b6100fc565b916100fc565b1415610d71565b90565b90565b610e11610e0c610e1692610dfa565b6102db565b61030e565b90565b60209181520190565b90825f9392825e0152565b610e4c610e55602093610e5a93610e43816106f5565b93848093610e19565b95869101610e22565b610093565b0190565b610e739160208201915f818403910152610e2d565b90565b610e90610e8b610e85836105f1565b926105eb565b610bdd565b9060208110610e9e575b5090565b610eb0905f199060200360080261074a565b165f610e9a565b610ec3610ec891610cc2565b6103ac565b90565b610edf610eda610ee49261030e565b610391565b6103eb565b90565b610eef610afd565b50610ef9816105e8565b90610f03826105f1565b610f16610f10601f610dfd565b9161030e565b11610f4b5750610f4381610f3d610f37610f32610f4895610e76565b610eb7565b916105f1565b17610ecb565b610948565b90565b610f6d90610f57610089565b91829163305a27a960e01b835260048301610e5e565b0390fd5b90565b610f80610f8591610cc2565b610f71565b90565b610f929054610f74565b90565b610f9d61093f565b50610fa8600c610f88565b610fba610fb45f610375565b9161030e565b141580610fc5575b90565b5042610fe2610fdc610fd7600c610f88565b61030e565b9161030e565b10610fc2565b91602061100992949361100260408201965f830190610bf7565b0190610bf7565b565b929161101984838391611114565b8361103461102e6110295f6102fa565b6100fc565b916100fc565b14611049575b61104792939190916112e1565b565b611051611283565b9361105a6112c0565b948061106e6110688861030e565b9161030e565b1161107b5750935061103a565b85906110975f928392630e58ae9360e11b845260048401610fe8565b0390fd5b906110a59061096a565b5f5260205260405f2090565b6040906110da6110e194969593966110d060608401985f850190610a7d565b6020830190610bf7565b0190610bf7565b565b906110ee910361030e565b90565b906110fc910161030e565b90565b9190611112905f60208501940190610bf7565b565b9190918061113261112c6111275f6102fa565b6100fc565b916100fc565b145f146112135761115661114f8361114a6002610f88565b610350565b60026103cb565b5b8261117261116c6111675f6102fa565b6100fc565b916100fc565b145f146111e75761119661118f8361118a6002610f88565b6110e3565b60026103cb565b5b9190916111e26111d06111ca7fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9361096a565b9361096a565b936111d9610089565b918291826110ff565b0390a3565b61120e826112086111f95f879061109b565b9161120383610f88565b6110f1565b906103cb565b611197565b6112266112215f839061109b565b610f88565b806112396112338561030e565b9161030e565b106112615761124c61125c9184906110e3565b6112575f849061109b565b6103cb565b611157565b9061127f9091925f93849363391434e360e21b8552600485016110b1565b0390fd5b61128b610795565b506112966002610f88565b90565b60018060d01b031690565b6112b86112b36112bd92611299565b6102db565b61030e565b90565b6112c8610795565b506112d860018060d01b036112a4565b90565b90565b90565b9161133961133361134094806113076113016112fc5f6102fa565b6100fc565b916100fc565b14611371575b8461132861132261131d5f6102fa565b6100fc565b916100fc565b14611342575b611569565b92611569565b909161159e565b565b61136a600b600261136461135e61135889611453565b936112db565b916112de565b906114a6565b505061132e565b611399600b600161139361138d61138789611453565b936112db565b916112de565b906114a6565b505061130d565b5f90565b6113b06113b691611299565b91611299565b019060018060d01b0382116113c757565b61033c565b906113df916113d96113a0565b506113a4565b90565b90565b60ff1690565b6113ff6113fa611404926113e2565b6102db565b6113e5565b90565b611410906113eb565b9052565b91602061143592949361142e60408201965f830190611407565b0190610bf7565b565b61144b6114466114509261030e565b6102db565b611299565b90565b61145b6113a0565b508061147561146f60018060d01b036112a4565b9161030e565b116114865761148390611437565b90565b60d06114a25f9283926306dfcc6560e41b845260048401611414565b0390fd5b906114dc6114e293926114b76113a0565b506114c06113a0565b5080936114d56114ce611750565b94926117fd565b9091611ce3565b91611872565b91909190565b6114f46114fa91611299565b91611299565b90039060018060d01b03821161150c57565b61033c565b906115249161151e6113a0565b506114e8565b90565b906115319061096a565b5f5260205260405f2090565b60018060a01b031690565b61155461155991610cc2565b61153d565b90565b6115669054611548565b90565b61158061158591611578610d18565b506009611527565b61155c565b90565b906115929061096a565b5f5260205260405f2090565b919091806115b46115ae856100fc565b916100fc565b141580611732575b6115c6575b505050565b806115e16115db6115d65f6102fa565b6100fc565b916100fc565b036116a2575b50816116036115fd6115f85f6102fa565b6100fc565b916100fc565b0361160f575b806115c1565b61165661164961165092611625600a8690611588565b9061164361163d611637600193611453565b936112db565b916112de565b906114a6565b92906112a4565b916112a4565b9190916116837fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a7249261096a565b9261169861168f610089565b92839283610fe8565b0390a25f80611609565b6116e16116e76116da6116b7600a8590611588565b60026116d46116ce6116c889611453565b936112db565b916112de565b906114a6565b92906112a4565b916112a4565b9190916117147fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a7249261096a565b92611729611720610089565b92839283610fe8565b0390a25f6115e7565b50816117466117405f610375565b9161030e565b116115bc565b5f90565b61175861174c565b506117616118a1565b90565b5490565b90565b61177f61177a61178492611768565b6102db565b61030e565b90565b61179661179c9193929361030e565b9261030e565b82039182116117a757565b61033c565b90565b60301c90565b60018060d01b031690565b6117cc6117d1916117af565b6117b5565b90565b6117de90546117c0565b90565b6117f56117f06117fa926102d8565b6102db565b611299565b90565b6118056113a0565b506118115f8201611764565b8061182461181e5f610375565b9161030e565b145f1461183a5750506118365f6117e1565b5b90565b6118675f9161186261185c8461186d960192611856600161176b565b90611787565b916117ac565b6118b6565b016117d4565b611837565b916118965f61189b946118836113a0565b5061188c6113a0565b50019291926117ac565b611abb565b91909190565b6118a961174c565b506118b343611c7c565b90565b5f5260205f200190565b5490565b6118ce60406100d8565b90565b65ffffffffffff1690565b906118e6906118d1565b9052565b906118f490611299565b9052565b5f5260205f2090565b634e487b7160e01b5f52603260045260245ffd5b61191e816118c0565b821015611938576119306001916118f8565b910201905f90565b611901565b61194790516118d1565b90565b9061195b65ffffffffffff91610391565b9181191691161790565b61197961197461197e926118d1565b6102db565b6118d1565b90565b90565b906119996119946119a092611965565b611981565b825461194a565b9055565b6119ae9051611299565b90565b60301b90565b906119c965ffffffffffff19916119b1565b9181191691161790565b6119e76119e26119ec92611299565b6102db565b611299565b90565b90565b90611a07611a02611a0e926119d3565b6119ef565b82546119b7565b9055565b90611a3c60205f611a4294611a34828201611a2e84880161193d565b90611984565b0192016119a4565b906119f2565b565b9190611a5557611a5391611a12565b565b6106e2565b9081549168010000000000000000831015611a8a5782611a82916001611a8895018155611915565b90611a44565b565b61009d565b65ffffffffffff1690565b611aa6611aab91610cc2565b611a8f565b90565b611ab89054611a9a565b90565b90929192611ac76113a0565b50611ad06113a0565b50611ada826118c0565b80611aed611ae75f610375565b9161030e565b115f14611bbd57611b1390611b0d8491611b07600161176b565b90611787565b906118b6565b90611b1f5f8301611aae565b92611b2b5f84016117d4565b9380611b3f611b39856118d1565b916118d1565b11611ba157611b56611b50846118d1565b916118d1565b145f14611b71575050611b6c905f8591016119f2565b5b9190565b611b9c9250611b9786611b8e611b856118c4565b945f86016118dc565b602084016118ea565b611a5a565b611b6d565b5f632520601d60e01b815280611bb960048201610306565b0390fd5b50611be891611be385611bda611bd16118c4565b945f86016118dc565b602084016118ea565b611a5a565b611bf15f6117e1565b9190565b611c09611c04611c0e926118d1565b6102db565b61030e565b90565b90565b611c28611c23611c2d92611c11565b6102db565b6113e5565b90565b611c3990611c14565b9052565b916020611c5e929493611c5760408201965f830190611c30565b0190610bf7565b565b611c74611c6f611c799261030e565b6102db565b6118d1565b90565b611c8461174c565b5080611c9e611c9865ffffffffffff611bf5565b9161030e565b11611caf57611cac90611c60565b90565b6030611ccb5f9283926306dfcc6560e41b845260048401611c3d565b0390fd5b634e487b7160e01b5f52605160045260245ffd5b91909180600114611d0257600203611ccf57611cfe91611511565b905b565b50611d0c916113cc565b90611d0056fe60806040526004361015610013575b611dc8565b61001d5f3561044c565b806301042d7a1461044757806301ffc9a71461044257806304df017d1461043d578063050732fb1461043857806306fdde0314610433578063095ea7b31461042e57806318160ddd1461042957806318bf50771461042457806323b872dd1461041f578063248a9ca31461041a5780632869366b146104155780632b8c49e3146104105780632f2ff15d1461040b57806330d3e8eb14610406578063313ce567146104015780633644e515146103fc57806336568abe146103f75780633a46b1a8146103f257806340c10f19146103ed578063427ac0ca146103e857806342966c68146103e35780634bdd36ce146103de5780634bf5d7e9146103d95780634f1bfc9e146103d4578063587cde1e146103cf5780635a4239e9146103ca5780635a5db1bb146103c55780635c19a95c146103c05780635d4c6285146103bb57806363a0daac146103b657806365145534146103b15780636fcfff45146103ac57806370a08231146103a757806372cbdcc8146103a257806378fb7fd21461039d57806379cc6790146103985780637a8cd156146103935780637ecebe001461038e57806383f1211b146103895780638426adf214610384578063844c90261461037f57806384b0196e1461037a5780638a542521146103755780638d3343d6146103705780638e539e8c1461036b578063902d55a51461036657806391d148541461036157806391ddadf41461035c57806394aa22f21461035757806395d89b41146103525780639ab24eb01461034d5780639b7ef64b14610348578063a217fddf14610343578063a9059cbb1461033e578063aa082a9d14610339578063b0ca253e14610334578063b7cdc61c1461032f578063bb4d44361461032a578063c02ae75414610325578063c3cda52014610320578063c4fc45a81461031b578063c9ab000614610316578063d505accf14610311578063d547741f1461030c578063dd62ed3e14610307578063f1127ed8146103025763f75e85120361000e57611d93565b611d2e565b611c4a565b611be9565b611baf565b611b0b565b611a86565b6119f4565b611938565b611903565b6118ce565b611869565b611834565b6117ef565b6117ba565b61174a565b6116d3565b61169e565b611669565b611634565b6115d1565b61159c565b611525565b6114f0565b61148c565b611421565b6112dc565b6112a7565b61124e565b611219565b6111e4565b6111b0565b61117b565b611146565b611072565b61103d565b610fdd565b610fa9565b610f39565b610ee5565b610eb0565b610e7c565b610e47565b610df0565b610d82565b610d4d565b610d1a565b610cc4565b610bc9565b610b93565b610b5f565b610b2a565b610af5565b610a98565b610a64565b610a03565b6109ce565b61096a565b6108ce565b610860565b61082b565b6107f5565b6107c0565b610711565b6106de565b610686565b6105dc565b60e01c90565b60405190565b5f80fd5b5f80fd5b60018060a01b031690565b61047490610460565b90565b6104808161046b565b0361048757565b5f80fd5b9050359061049882610477565b565b90565b6104a68161049a565b036104ad57565b5f80fd5b905035906104be8261049d565b565b91906040838203126104e857806104dc6104e5925f860161048b565b936020016104b1565b90565b61045c565b90565b6105046104ff61050992610460565b6104ed565b610460565b90565b610515906104f0565b90565b6105219061050c565b90565b9061052e90610518565b5f5260205260405f2090565b61054e6105496105539261049a565b6104ed565b61049a565b90565b906105609061053a565b5f5260205260405f2090565b1c90565b90565b610583906008610588930261056c565b610570565b90565b906105969154610573565b90565b6105b26105b7926105ad6011935f94610524565b610556565b61058b565b90565b6105c39061049a565b9052565b91906105da905f602085019401906105ba565b565b3461060d576106096105f86105f23660046104c0565b90610599565b610600610452565b918291826105c7565b0390f35b610458565b63ffffffff60e01b1690565b61062781610612565b0361062e57565b5f80fd5b9050359061063f8261061e565b565b9060208282031261065a57610657915f01610632565b90565b61045c565b151590565b61066d9061065f565b9052565b9190610684905f60208501940190610664565b565b346106b6576106b26106a161069c366004610641565b611e65565b6106a9610452565b91829182610671565b0390f35b610458565b906020828203126106d4576106d1915f0161048b565b90565b61045c565b5f0190565b3461070c576106f66106f13660046106bb565b612097565b6106fe610452565b80610708816106d9565b0390f35b610458565b346107415761073d61072c6107273660046106bb565b6120a2565b610734610452565b918291826105c7565b0390f35b610458565b5f91031261075057565b61045c565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b61079661079f6020936107a49361078d81610755565b93848093610759565b95869101610762565b61076d565b0190565b6107bd9160208201915f818403910152610777565b90565b346107f0576107d0366004610746565b6107ec6107db61221a565b6107e3610452565b918291826107a8565b0390f35b610458565b346108265761082261081161080b3660046104c0565b90612230565b610819610452565b91829182610671565b0390f35b610458565b3461085b5761083b366004610746565b610857610846612252565b61084e610452565b918291826105c7565b0390f35b610458565b3461088f576108796108733660046104c0565b906122a9565b610881610452565b8061088b816106d9565b0390f35b610458565b90916060828403126108c9576108c66108af845f850161048b565b936108bd816020860161048b565b936040016104b1565b90565b61045c565b346108ff576108fb6108ea6108e4366004610894565b91612424565b6108f2610452565b91829182610671565b0390f35b610458565b90565b61091081610904565b0361091757565b5f80fd5b9050359061092882610907565b565b9060208282031261094357610940915f0161091b565b90565b61045c565b61095190610904565b9052565b9190610968905f60208501940190610948565b565b3461099a5761099661098561098036600461092a565b61249d565b61098d610452565b91829182610955565b0390f35b610458565b906109a990610518565b5f5260205260405f2090565b6109cb906109c66010915f9261099f565b61058b565b90565b346109fe576109fa6109e96109e43660046106bb565b6109b5565b6109f1610452565b918291826105c7565b0390f35b610458565b34610a3257610a1c610a163660046104c0565b906124bf565b610a24610452565b80610a2e816106d9565b0390f35b610458565b9190604083820312610a5f5780610a53610a5c925f860161091b565b9360200161048b565b90565b61045c565b34610a9357610a7d610a77366004610a37565b90612610565b610a85610452565b80610a8f816106d9565b0390f35b610458565b34610ac857610ac4610ab3610aae3660046106bb565b61276c565b610abb610452565b918291826105c7565b0390f35b610458565b60ff1690565b610adc90610acd565b9052565b9190610af3905f60208501940190610ad3565b565b34610b2557610b05366004610746565b610b21610b106128a7565b610b18610452565b91829182610ae0565b0390f35b610458565b34610b5a57610b3a366004610746565b610b56610b456128bd565b610b4d610452565b91829182610955565b0390f35b610458565b34610b8e57610b78610b72366004610a37565b906128d1565b610b80610452565b80610b8a816106d9565b0390f35b610458565b34610bc457610bc0610baf610ba93660046104c0565b9061294e565b610bb7610452565b918291826105c7565b0390f35b610458565b34610bf857610be2610bdc3660046104c0565b90612a6c565b610bea610452565b80610bf4816106d9565b0390f35b610458565b90610c0790610518565b5f5260205260405f2090565b5f1c90565b610c24610c2991610c13565b610570565b90565b610c369054610c18565b90565b60ff1690565b610c4b610c5091610c13565b610c39565b90565b610c5d9054610c3f565b90565b610c6b90600d610bfd565b610c765f8201610c2c565b91610c8f6002610c8860018501610c2c565b9301610c53565b90565b604090610cbb610cc29496959396610cb160608401985f8501906105ba565b60208301906105ba565b0190610664565b565b34610cf757610cf3610cdf610cda3660046106bb565b610c60565b610cea939193610452565b93849384610c92565b0390f35b610458565b90602082820312610d1557610d12915f016104b1565b90565b61045c565b34610d4857610d32610d2d366004610cfc565b612a78565b610d3a610452565b80610d44816106d9565b0390f35b610458565b34610d7d57610d5d366004610746565b610d79610d68612ab8565b610d70610452565b918291826105c7565b0390f35b610458565b34610db257610d92366004610746565b610dae610d9d612b62565b610da5610452565b918291826107a8565b0390f35b610458565b90565b610dce610dc9610dd392610db7565b6104ed565b61049a565b90565b610de26276a700610dba565b90565b610ded610dd6565b90565b34610e2057610e00366004610746565b610e1c610e0b610de5565b610e13610452565b918291826105c7565b0390f35b610458565b610e2e9061046b565b9052565b9190610e45905f60208501940190610e25565b565b34610e7757610e73610e62610e5d3660046106bb565b612bfe565b610e6a610452565b91829182610e32565b0390f35b610458565b34610eab57610e95610e8f3660046104c0565b90612d8b565b610e9d610452565b80610ea7816106d9565b0390f35b610458565b34610ee057610edc610ecb610ec6366004610cfc565b612e3f565b610ed3610452565b91829182610e32565b0390f35b610458565b34610f1357610efd610ef83660046106bb565b612e8b565b610f05610452565b80610f0f816106d9565b0390f35b610458565b610f31610f3692610f2c6012935f94610524565b610556565b61058b565b90565b34610f6a57610f66610f55610f4f3660046104c0565b90610f18565b610f5d610452565b918291826105c7565b0390f35b610458565b9091606082840312610fa457610fa1610f8a845f850161048b565b93610f9881602086016104b1565b936040016104b1565b90565b61045c565b34610fd857610fc2610fbc366004610f6f565b916131e2565b610fca610452565b80610fd4816106d9565b0390f35b610458565b3461100d57610fed366004610746565b611009610ff86131ef565b611000610452565b918291826105c7565b0390f35b610458565b63ffffffff1690565b61102490611012565b9052565b919061103b905f6020850194019061101b565b565b3461106d576110696110586110533660046106bb565b613211565b611060610452565b91829182611028565b0390f35b610458565b346110a25761109e61108d6110883660046106bb565b613226565b611095610452565b918291826105c7565b0390f35b610458565b5190565b60209181520190565b60200190565b6110c39061046b565b9052565b906110d4816020936110ba565b0190565b60200190565b906110fb6110f56110ee846110a7565b80936110ab565b926110b4565b905f5b81811061110b5750505090565b90919261112461111e60019286516110c7565b946110d8565b91019190916110fe565b6111439160208201915f8184039101526110de565b90565b3461117657611156366004610746565b611172611161613249565b611169610452565b9182918261112e565b0390f35b610458565b346111ab576111a76111966111913660046106bb565b613267565b61119e610452565b91829182610671565b0390f35b610458565b346111df576111c96111c33660046104c0565b906133cc565b6111d1610452565b806111db816106d9565b0390f35b610458565b34611214576111f4366004610746565b6112106111ff6133d8565b611207610452565b918291826105c7565b0390f35b610458565b346112495761124561123461122f3660046106bb565b613450565b61123c610452565b918291826105c7565b0390f35b610458565b3461127e5761125e366004610746565b61127a611269613465565b611271610452565b91829182610671565b0390f35b610458565b7f000000000000000000000000000000000000000000000000000000000000000090565b346112d7576112b7366004610746565b6112d36112c2611283565b6112ca610452565b918291826105c7565b0390f35b610458565b3461130a576112f46112ef366004610cfc565b6135b8565b6112fc610452565b80611306816106d9565b0390f35b610458565b60ff60f81b1690565b6113219061130f565b9052565b5190565b60209181520190565b60200190565b6113419061049a565b9052565b9061135281602093611338565b0190565b60200190565b9061137961137361136c84611325565b8093611329565b92611332565b905f5b8181106113895750505090565b9091926113a261139c6001928651611345565b94611356565b910191909161137c565b939591946113fd6113f2611411956113e46114079561141e9c9a6113d760e08c01925f8d0190611318565b8a820360208c0152610777565b9088820360408a0152610777565b9760608701906105ba565b6080850190610e25565b60a0830190610948565b60c081840391015261135c565b90565b3461145857611431366004610746565b61145461143c613640565b9361144b979597939193610452565b978897886113ac565b0390f35b610458565b7f84fe74c71a28b69aa960486ca0e8c1418c86e9ea2cd6b5849b95e2c8f407a67490565b61148961145d565b90565b346114bc5761149c366004610746565b6114b86114a7611481565b6114af610452565b91829182610955565b0390f35b610458565b7f9b12e0c5707e494915e58b0564f18aaad9b74ac69bfc815a1edadc8e4bd032eb90565b6114ed6114c1565b90565b3461152057611500366004610746565b61151c61150b6114e5565b611513610452565b91829182610955565b0390f35b610458565b346115555761155161154061153b366004610cfc565b6136ca565b611548610452565b918291826105c7565b0390f35b610458565b90565b61157161156c6115769261155a565b6104ed565b61049a565b90565b61158e6b033b2e3c9fd0803ce800000061155d565b90565b611599611579565b90565b346115cc576115ac366004610746565b6115c86115b7611591565b6115bf610452565b918291826105c7565b0390f35b610458565b34611602576115fe6115ed6115e7366004610a37565b90613711565b6115f5610452565b91829182610671565b0390f35b610458565b65ffffffffffff1690565b61161b90611607565b9052565b9190611632905f60208501940190611612565b565b3461166457611644366004610746565b61166061164f61373f565b611657610452565b9182918261161f565b0390f35b610458565b346116995761169561168461167f3660046106bb565b613753565b61168c610452565b918291826105c7565b0390f35b610458565b346116ce576116ae366004610746565b6116ca6116b9613869565b6116c1610452565b918291826107a8565b0390f35b610458565b34611703576116ff6116ee6116e93660046106bb565b61387f565b6116f6610452565b918291826105c7565b0390f35b610458565b90565b61171f61171a61172492611708565b6104ed565b61049a565b90565b61173c6b02e87669c308736a0400000061170b565b90565b611747611727565b90565b3461177a5761175a366004610746565b61177661176561173f565b61176d610452565b918291826105c7565b0390f35b610458565b90565b5f1b90565b61179b6117966117a09261177f565b611782565b610904565b90565b6117ac5f611787565b90565b6117b76117a3565b90565b346117ea576117ca366004610746565b6117e66117d56117af565b6117dd610452565b91829182610955565b0390f35b610458565b346118205761181c61180b6118053660046104c0565b906138ae565b611813610452565b91829182610671565b0390f35b610458565b611831600c5f9061058b565b90565b3461186457611844366004610746565b61186061184f611825565b611857610452565b918291826105c7565b0390f35b610458565b3461189a5761189661188561187f3660046104c0565b906138d0565b61188d610452565b918291826105c7565b0390f35b610458565b7f820372a9faf82db3cc5fc36ffab5f096eef69b95fbf50591e0d71447aa1ba70090565b6118cb61189f565b90565b346118fe576118de366004610746565b6118fa6118e96118c3565b6118f1610452565b91829182610955565b0390f35b610458565b346119335761192f61191e6119193660046106bb565b6138e6565b611926610452565b918291826105c7565b0390f35b610458565b3461196857611948366004610746565b6119646119536138fb565b61195b610452565b918291826105c7565b0390f35b610458565b61197681610acd565b0361197d57565b5f80fd5b9050359061198e8261196d565b565b909160c0828403126119ef576119a8835f840161048b565b926119b681602085016104b1565b926119c482604083016104b1565b926119ec6119d58460608501611981565b936119e3816080860161091b565b9360a00161091b565b90565b61045c565b34611a2957611a13611a07366004611990565b9493909392919261397b565b611a1b610452565b80611a25816106d9565b0390f35b610458565b611a379061065f565b9052565b90604080611a6f93611a535f8201515f860190611338565b611a6560208201516020860190611338565b0151910190611a2e565b565b9190611a84905f60608501940190611a3b565b565b34611ab657611ab2611aa1611a9c3660046106bb565b613a72565b611aa9610452565b91829182611a71565b0390f35b610458565b611ac48161065f565b03611acb57565b5f80fd5b90503590611adc82611abb565b565b9190604083820312611b065780611afa611b03925f860161048b565b93602001611acf565b90565b61045c565b34611b3a57611b24611b1e366004611ade565b90613b85565b611b2c610452565b80611b36816106d9565b0390f35b610458565b60e081830312611baa57611b55825f830161048b565b92611b63836020840161048b565b92611b7181604085016104b1565b92611b7f82606083016104b1565b92611ba7611b908460808501611981565b93611b9e8160a0860161091b565b9360c00161091b565b90565b61045c565b34611be457611bce611bc2366004611b3f565b95949094939193613c33565b611bd6610452565b80611be0816106d9565b0390f35b610458565b34611c1857611c02611bfc366004610a37565b90613d51565b611c0a610452565b80611c14816106d9565b0390f35b610458565b9190604083820312611c455780611c39611c42925f860161048b565b9360200161048b565b90565b61045c565b34611c7b57611c77611c66611c60366004611c1d565b90613d73565b611c6e610452565b918291826105c7565b0390f35b610458565b611c8981611012565b03611c9057565b5f80fd5b90503590611ca182611c80565b565b9190604083820312611ccb5780611cbf611cc8925f860161048b565b93602001611c94565b90565b61045c565b611cd990611607565b9052565b60018060d01b031690565b611cf190611cdd565b9052565b90602080611d1793611d0d5f8201515f860190611cd0565b0151910190611ce8565b565b9190611d2c905f60408501940190611cf5565b565b34611d5f57611d5b611d4a611d44366004611ca3565b90613de1565b611d52610452565b91829182611d19565b0390f35b610458565b7fcce296b040332a080e6df13515a3ec2869e21cd20f7344af0987ddb938d8bd2190565b611d90611d64565b90565b34611dc357611da3366004610746565b611dbf611dae611d88565b611db6610452565b91829182610955565b0390f35b610458565b5f80fd5b5f90565b634e487b7160e01b5f52601160045260245ffd5b611df0611df691611cdd565b91611cdd565b019060018060d01b038211611e0757565b611dd0565b90611e1f91611e19611dcc565b50611de4565b90565b611e2e611e3491611cdd565b91611cdd565b90039060018060d01b038211611e4657565b611dd0565b90611e5e91611e58611dcc565b50611e22565b90565b5f90565b611e6d611e61565b5080611e88611e82630cccc66560e21b610612565b91610612565b148015611eac575b908115611e9c575b5090565b611ea69150613df7565b5f611e98565b5080611ec7611ec163b2752ac960e01b610612565b91610612565b14611e90565b611ee690611ee1611edc611d64565b613e37565b611fc4565b565b611efc611ef7611f019261177f565b6104ed565b610460565b90565b611f0d90611ee8565b90565b90565b1b90565b91906008611f32910291611f2c5f1984611f13565b92611f13565b9181191691161790565b90565b9190611f55611f50611f5d9361053a565b611f3c565b908354611f17565b9055565b5f90565b611f7791611f71611f61565b91611f3f565b565b60025f91611f8983808301611f65565b611f968360018301611f65565b0155565b634e487b7160e01b5f525f60045260245ffd5b905f03611fbf57611fbd90611f79565b565b611f9a565b80611fdf611fd9611fd45f611f04565b61046b565b9161046b565b1461207b57612001611ffb611ff4600e611f10565b8390613e92565b1561065f565b61205c5761201a5f612015600d8490610bfd565b611fad565b6120447f5d9d5034656cb3ebfb0655057cd7f9b4077a9b42ff42ce223cbac5bc586d212691610518565b9061204d610452565b80612057816106d9565b0390a2565b612077905f918291636585b60d60e01b835260048301610e32565b0390fd5b5f63d92e233d60e01b815280612093600482016106d9565b0390fd5b6120a090611ecd565b565b6120b96120be916120b1611f61565b50601061099f565b610c2c565b90565b606090565b634e487b7160e01b5f52602260045260245ffd5b90600160028304921680156120fa575b60208310146120f557565b6120c6565b91607f16916120ea565b60209181520190565b5f5260205f2090565b905f9291805490612130612129836120da565b8094612104565b916001811690815f14612187575060011461214b575b505050565b612158919293945061210d565b915f925b81841061216f57505001905f8080612146565b6001816020929593955484860152019101929061215c565b92949550505060ff19168252151560200201905f8080612146565b906121ac91612116565b90565b634e487b7160e01b5f52604160045260245ffd5b906121cd9061076d565b810190811067ffffffffffffffff8211176121e757604052565b6121af565b9061220c612205926121fc610452565b938480926121a2565b03836121c3565b565b612217906121ec565b90565b6122226120c1565b5061222d600361220e565b90565b61224d9161223c611e61565b50612245613ecc565b919091613ed9565b600190565b61225a611f61565b506122656002610c2c565b90565b61227c6122776122819261177f565b6104ed565b61049a565b90565b6122936122999193929361049a565b9261049a565b82018092116122a457565b611dd0565b806122c46122be6122b95f611f04565b61046b565b9161046b565b1461240857816122dc6122d65f612268565b9161049a565b146123ec576122f36122ec612252565b8390612284565b61230c612306612301611579565b61049a565b9161049a565b116123d05761231c338390613f1e565b612327338390614114565b61232f613465565b806123af575b612393576123448183906141c8565b339061238e61237c6123767fde22baff038e3a3e08407cbdf617deed74e869a7ba517df611e33131c6e6ea0493610518565b93610518565b93612385610452565b918291826105c7565b0390a3565b5f6336e278fd60e21b8152806123ab600482016106d9565b0390fd5b506123cb6123c56123be61145d565b3390613711565b1561065f565b612335565b5f63177e3fc360e01b8152806123e8600482016106d9565b0390fd5b5f631f2a200560e01b815280612404600482016106d9565b0390fd5b5f63d92e233d60e01b815280612420600482016106d9565b0390fd5b9161244e92612431611e61565b5061244661243d613ecc565b82908491614234565b9190916142c0565b600190565b5f90565b61246090610904565b90565b9061246d90612457565b5f5260205260405f2090565b90565b61248861248d91610c13565b612479565b90565b61249a905461247c565b90565b60016124b66124bc926124ae612453565b506005612463565b01612490565b90565b806124da6124d46124cf5f611f04565b61046b565b9161046b565b146125ca57816124f26124ec5f612268565b9161049a565b146125ae5761250233839061435d565b3361251561250f8361046b565b9161046b565b03612575575b612526818390614556565b339061257061255e6125587fb90795a66650155983e242cac3e1ac1a4dc26f8ed2987f3ce416a34e00111fd493610518565b93610518565b93612567610452565b918291826105c7565b0390a3565b612580813390613d73565b61259261258c5f612268565b9161049a565b0361259d575b61251b565b6125a981338491614234565b612598565b5f631f2a200560e01b8152806125c6600482016106d9565b0390fd5b5f63d92e233d60e01b8152806125e2600482016106d9565b0390fd5b90612601916125fc6125f78261249d565b613e37565b612603565b565b9061260d916145b5565b50565b9061261a916125e6565b565b906126269061049a565b9052565b906126349061065f565b9052565b9061264b612644610452565b92836121c3565b565b6126576060612638565b90565b906126a96126a0600261266b61264d565b9461268261267a5f8301610c2c565b5f880161261c565b61269a61269160018301610c2c565b6020880161261c565b01610c53565b6040840161262a565b565b6126b49061265a565b90565b90565b6126ce6126c96126d3926126b7565b6104ed565b61049a565b90565b634e487b7160e01b5f52601260045260245ffd5b6126f66126fc9161049a565b9161049a565b908115612707570490565b6126d6565b6001612718910161049a565b90565b90565b61273261272d6127379261271b565b6104ed565b61049a565b90565b61274961274f9193929361049a565b9261049a565b820391821161275a57565b611dd0565b612769905161049a565b90565b612774611f61565b50612789612784600d8390610bfd565b6126ab565b9061279f42612799610e106126ba565b906126ea565b6127a85f612268565b906127b25f612268565b5b806127c76127c1601861271e565b9161049a565b101561283357816127e06127da8361049a565b9161049a565b10156127f5575b6127f09061270c565b6127b3565b9161282b6127f09161282561282061280f60128990610524565b61281a87899061273a565b90610556565b610c2c565b90612284565b9290506127e7565b505090506128436020830161275f565b61285561284f8361049a565b9161049a565b115f146128745761286b6020612870930161275f565b61273a565b5b90565b505061287f5f612268565b612871565b5f90565b90565b61289f61289a6128a492612888565b6104ed565b610acd565b90565b6128af612884565b506128ba601261288b565b90565b6128c5612453565b506128ce614661565b90565b90806128ec6128e66128e1613ecc565b61046b565b9161046b565b036128fd576128fa9161471b565b50565b5f63334bd91960e11b815280612915600482016106d9565b0390fd5b9061292390610518565b5f5260205260405f2090565b90565b61294661294161294b92611cdd565b6104ed565b61049a565b90565b6129859161297a61297461296f61298094612967611f61565b50600a612919565b61292f565b916147fc565b90614911565b612932565b90565b906129a29161299d6129986114c1565b613e37565b6129a4565b565b90816129c06129ba6129b55f611f04565b61046b565b9161046b565b14612a5057806129d86129d25f612268565b9161049a565b14612a34576129ef6129e8612252565b8290612284565b612a08612a026129fd611579565b61049a565b9161049a565b11612a1857612a16916141c8565b565b5f63177e3fc360e01b815280612a30600482016106d9565b0390fd5b5f631f2a200560e01b815280612a4c600482016106d9565b0390fd5b5f63d92e233d60e01b815280612a68600482016106d9565b0390fd5b90612a7691612988565b565b80612a8b612a855f612268565b9161049a565b14612a9c57612a9a9033614556565b565b5f631f2a200560e01b815280612ab4600482016106d9565b0390fd5b612ac0611f61565b50612ada612acc611579565b612ad4612252565b9061273a565b90565b67ffffffffffffffff8111612afb57612af760209161076d565b0190565b6121af565b90612b12612b0d83612add565b612638565b918252565b5f7f6d6f64653d626c6f636b6e756d6265722666726f6d3d64656661756c74000000910152565b612b48601d612b00565b90612b5560208301612b17565b565b612b5f612b3e565b90565b612b6a6120c1565b50612b7361373f565b612b8c612b86612b81614a38565b611607565b91611607565b03612b9c57612b99612b57565b90565b5f6301bfc1c560e61b815280612bb4600482016106d9565b0390fd5b5f90565b90612bc690610518565b5f5260205260405f2090565b60018060a01b031690565b612be9612bee91610c13565b612bd2565b90565b612bfb9054612bdd565b90565b612c15612c1a91612c0d612bb8565b506009612bbc565b612bf1565b90565b90612c3791612c32612c2d61189f565b613e37565b612c6f565b565b90612c455f1991611782565b9181191691161790565b90612c64612c5f612c6b9261053a565b611f3c565b8254612c39565b9055565b80612c8a612c84612c7f5f611f04565b61046b565b9161046b565b14612d6f5781612ca2612c9c5f612268565b9161049a565b14612d5357612cc4612cbe612cb7600e611f10565b8390614a4d565b1561065f565b612d3457612cf082612cea612cdb6010859061099f565b91612ce583610c2c565b612284565b90612c4f565b612d2f612d1d7f9ca03dbd5193fbb7974173cedd0bdf6841dd14c3cbfa735aab77ff1dd1139fb392610518565b92612d26610452565b918291826105c7565b0390a2565b612d4f905f918291636585b60d60e01b835260048301610e32565b0390fd5b5f631f2a200560e01b815280612d6b600482016106d9565b0390fd5b5f63d92e233d60e01b815280612d87600482016106d9565b0390fd5b90612d9591612c1d565b565b60207f6f7574206f6620626f756e647300000000000000000000000000000000000000917f53796e646963617465546f6b656e43726f7373636861696e3a20696e646578205f8201520152565b612df1602d604092610759565b612dfa81612d97565b0190565b612e139060208101905f818303910152612de4565b90565b15612e1d57565b612e25610452565b62461bcd60e51b815280612e3b60048201612dfe565b0390fd5b612e8890612e4b612bb8565b50612e7981612e73612e6d612e68612e63600e611f10565b614a87565b61049a565b9161049a565b10612e16565b612e83600e611f10565b614ad6565b90565b612e9c90612e97613ecc565b614b4c565b565b90612eb99291612eb4612eaf611d64565b613e37565b612f95565b565b916020612edc929493612ed560408201965f8301906105ba565b01906105ba565b565b612ee86060612638565b90565b612ef5905161065f565b90565b90612f0460ff91611782565b9181191691161790565b612f179061065f565b90565b90565b90612f32612f2d612f3992612f0e565b612f1a565b8254612ef8565b9055565b90612f8160406002612f8794612f605f8201612f5a5f880161275f565b90612c4f565b612f7960018201612f736020880161275f565b90612c4f565b019201612eeb565b90612f1d565b565b90612f9391612f3d565b565b80612fb0612faa612fa55f611f04565b61046b565b9161046b565b146131c65780612fc8612fc23361046b565b9161046b565b146131aa57803b612fe1612fdb5f612268565b9161049a565b1461318e5781612ffa612ff45f1961049a565b9161049a565b14158061316d575b613151578261301a6130145f1961049a565b9161049a565b141580613130575b6131155761303a613033600e611f10565b8290614bd7565b6130ca575b613084826130738561306a600191613061613058612ede565b955f870161261c565b6020850161261c565b6040830161262a565b61307f600d8490610bfd565b612f89565b90916130b07faa807d0abf30d91968c7478c66b6d82521a106af13eda036e2036da9af16895892610518565b926130c56130bc610452565b92839283612ebb565b0390a2565b808290846130f87fdb03f97dc5840a71e69be7470e4761af10a1237973e81c12d0dc2813895a652692610518565b9261310d613104610452565b92839283612ebb565b0390a261303f565b5f6258ccad60e81b81528061312c600482016106d9565b0390fd5b508261314b613145613140611579565b61049a565b9161049a565b11613022565b5f630a395c0160e01b815280613169600482016106d9565b0390fd5b508161318861318261317d611579565b61049a565b9161049a565b11613002565b5f63412a18ed60e11b8152806131a6600482016106d9565b0390fd5b5f63fb8ce8c960e01b8152806131c2600482016106d9565b0390fd5b5f63d92e233d60e01b8152806131de600482016106d9565b0390fd5b906131ed9291612e9e565b565b6131f7611f61565b5061320a613205600e611f10565b614a87565b90565b5f90565b6132239061321d61320d565b50614c11565b90565b61323c61324191613235611f61565b505f61099f565b610c2c565b90565b606090565b613251613244565b5061326461325f600e611f10565b614c40565b90565b61326f611e61565b50613297613287613282600d8490610bfd565b6126ab565b91613292600e611f10565b614a4d565b90816132a2575b5090565b6132af9150604001612eeb565b5f61329e565b906132cf916132ca6132c561145d565b613e37565b6132d1565b565b806132ec6132e66132e15f611f04565b61046b565b9161046b565b146133b057816133046132fe5f612268565b9161049a565b146133945761331a613314613465565b1561065f565b61337857613329818390614556565b339061337361336161335b7fbef4f81c1814c641ede85ebaacf19d048b2c5b55980adfa6ef0f956c651335a293610518565b93610518565b9361336a610452565b918291826105c7565b0390a3565b5f63b8b5ca2d60e01b815280613390600482016106d9565b0390fd5b5f631f2a200560e01b8152806133ac600482016106d9565b0390fd5b5f63d92e233d60e01b8152806133c8600482016106d9565b0390fd5b906133d6916132b5565b565b6133e0611f61565b506133eb600c610c2c565b6133fd6133f75f612268565b9161049a565b14801561342c575b6134205761341d613416600c610c2c565b429061273a565b90565b6134295f612268565b90565b504261344961344361343e600c610c2c565b61049a565b9161049a565b1015613405565b6134629061345c611f61565b50614c68565b90565b61346d611e61565b50613478600c610c2c565b61348a6134845f612268565b9161049a565b141580613495575b90565b50426134b26134ac6134a7600c610c2c565b61049a565b9161049a565b10613492565b6134d1906134cc6134c76117a3565b613e37565b6134d3565b565b806134e66134e04261049a565b9161049a565b111561359c578061351f6135197f000000000000000000000000000000000000000000000000000000000000000061049a565b9161049a565b116135805761352e600c610c2c565b61353982600c612c4f565b9033906135667fdd6896dcf1d4b311cca87dd19bbba2ea9ce2f867c1568878a0438a66a1afeeec92610518565b9261357b613572610452565b92839283612ebb565b0390a2565b5f63ef69af6560e01b815280613598600482016106d9565b0390fd5b5f63a565835360e01b8152806135b4600482016106d9565b0390fd5b6135c1906134b8565b565b5f90565b606090565b6135d59061050c565b90565b67ffffffffffffffff81116135f05760208091020190565b6121af565b90613607613602836135d8565b612638565b918252565b369037565b9061363661361e836135f5565b9260208061362c86936135d8565b920191039061360c565b565b600f60f81b90565b6136486135c3565b506136516120c1565b5061365a6120c1565b50613663611f61565b5061366c612bb8565b50613675612453565b5061367e6135c7565b50613687614c80565b90613690614cc0565b90469061369c306135cc565b906136a65f611787565b906136b86136b35f612268565b613611565b906136c1613638565b96959493929190565b6136f36136f8916136d9611f61565b506136ed6136e7600b61292f565b916147fc565b90614911565b612932565b90565b9061370590610518565b5f5260205260405f2090565b613738915f61372d61373393613725611e61565b506005612463565b016136fb565b610c53565b90565b5f90565b61374761373b565b50613750614a38565b90565b61375b611f61565b5061377061376b600d8390610bfd565b6126ab565b9061378642613780610e106126ba565b906126ea565b61378f5f612268565b906137995f612268565b5b806137ae6137a8601861271e565b9161049a565b101561381a57816137c76137c18361049a565b9161049a565b10156137dc575b6137d79061270c565b61379a565b916138126137d79161380c6138076137f660118990610524565b61380187899061273a565b90610556565b610c2c565b90612284565b9290506137ce565b505090506138295f830161275f565b61383b6138358361049a565b9161049a565b115f14613859576138505f613855930161275f565b61273a565b5b90565b50506138645f612268565b613856565b6138716120c1565b5061387c600461220e565b90565b6138a66138a161389c6138ab93613894611f61565b50600a612919565b61292f565b614d00565b612932565b90565b6138cb916138ba611e61565b506138c3613ecc565b9190916142c0565b600190565b906138e3916138dd611f61565b5061294e565b90565b6138f8906138f2611f61565b5061387f565b90565b613903611f61565b5061390c612252565b90565b7fe48329057bfd03d55e49b547132e39cffd9c1820ad7b9d4c5307691425d15adf90565b61396861396f9461395e606094989795613954608086019a5f870190610948565b6020850190610e25565b60408301906105ba565b01906105ba565b565b60200190565b5190565b939594909291954261399561398f8961049a565b9161049a565b11613a0e5791613a0091613a07936139f7613a0c98996139df6139b661390f565b6139d08b938b6139c4610452565b95869460208601613933565b602082018103825203826121c3565b6139f16139eb82613977565b91613971565b20614d75565b92909192614d92565b9182614ddc565b614b4c565b565b613a29875f918291632341d78760e11b8352600483016105c7565b0390fd5b5f90565b5f90565b613a3d61264d565b906020808084613a4b613a2d565b815201613a56613a2d565b815201613a61613a31565b81525050565b613a6f613a35565b90565b613a89613a8e91613a81613a67565b50600d610bfd565b6126ab565b90565b90613aab91613aa6613aa1611d64565b613e37565b613aad565b565b80613ac8613ac2613abd5f611f04565b61046b565b9161046b565b14613b6957613aea613ae4613add600e611f10565b8390614a4d565b1561065f565b613b4a57613b06826002613b00600d8590610bfd565b01612f1d565b613b45613b337f9c8668db324845065d2b9a2a183bd3141f63018f548282daf18da49ccbf88c3392610518565b92613b3c610452565b91829182610671565b0390a2565b613b65905f918291636585b60d60e01b835260048301610e32565b0390fd5b5f63d92e233d60e01b815280613b81600482016106d9565b0390fd5b90613b8f91613a91565b565b7f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c990565b9194613bfd613c0792989795613bf360a096613be9613c0e9a613bdf60c08a019e5f8b0190610948565b6020890190610e25565b6040870190610e25565b60608501906105ba565b60808301906105ba565b01906105ba565b565b916020613c31929493613c2a60408201965f830190610e25565b0190610e25565b565b969591939294909442613c4e613c488361049a565b9161049a565b11613d085790613cb7613cc0949392613c9f613c68613b91565b613c908c80948c91613c7a8d91614e1f565b9192613c84610452565b97889660208801613bb5565b602082018103825203826121c3565b613cb1613cab82613977565b91613971565b20614d75565b92909192614d92565b80613cd3613ccd8761046b565b9161046b565b03613ce85750613ce69293919091613ed9565b565b8490613d045f9283926325c0072360e11b845260048401613c10565b0390fd5b613d23905f91829163313c898160e11b8352600483016105c7565b0390fd5b90613d4291613d3d613d388261249d565b613e37565b613d44565b565b90613d4e9161471b565b50565b90613d5b91613d27565b565b90613d6790610518565b5f5260205260405f2090565b613d9891613d8e613d9392613d86611f61565b506001613d5d565b61099f565b610c2c565b90565b613da56040612638565b90565b5f90565b5f90565b613db8613d9b565b9060208083613dc5613da8565b815201613dd0613dac565b81525050565b613dde613db0565b90565b90613df491613dee613dd6565b50614e52565b90565b613dff611e61565b5080613e1a613e14637965db0b60e01b610612565b91610612565b14908115613e27575b5090565b613e319150614e7a565b5f613e23565b613e4990613e43613ecc565b90614ec3565b565b613e54906104f0565b90565b613e6b613e66613e7092610460565b6104ed565b61049a565b90565b613e87613e82613e8c9261049a565b611782565b610904565b90565b90565b90613ec4613ebe613eb9613eb45f613ec996613eac611e61565b500194613e4b565b613e57565b613e73565b91613e8f565b615040565b90565b613ed4612bb8565b503390565b91613ee79291600192615146565b565b90565b604090613f15613f1c9496959396613f0b60608401985f850190610e25565b60208301906105ba565b01906105ba565b565b613f32613f2d600d8390610bfd565b613ee9565b91613f50613f4a613f43600e611f10565b8490614a4d565b1561065f565b80156140f9575b6140da57613f7042613f6a610e106126ba565b906126ea565b613f795f612268565b91613f835f612268565b5b80613f98613f92601861271e565b9161049a565b10156140045782613fb1613fab8361049a565b9161049a565b1015613fc6575b613fc19061270c565b613f84565b92613ffc613fc191613ff6613ff1613fe060118a90610524565b613feb888a9061273a565b90610556565b610c2c565b90612284565b939050613fb8565b5091909293614014828490612284565b61403061402a6140255f8501610c2c565b61049a565b9161049a565b1161406a575050614053614068939261404e61406293946011610524565b610556565b9161405d83610c2c565b612284565b90612c4f565b565b8493506140785f8201610c2c565b61408a6140848461049a565b9161049a565b115f146140c7576140c3916140a35f6140a89301610c2c565b61273a565b5b9291925f9384936340ed367b60e01b855260048501613eec565b0390fd5b50506140c36140d55f612268565b6140a9565b6140f5825f918291636585b60d60e01b835260048301610e32565b0390fd5b5061410f61410960028501610c53565b1561065f565b613f57565b6141286141236010839061099f565b610c2c565b61413b614135849261049a565b9161049a565b116141ac57614168826141626141536010859061099f565b9161415d83610c2c565b61273a565b90612c4f565b6141a76141957fbc23ec7f1313150b047bff83d0845b0564baa134698dd11bb0acd0f7d416de7d92610518565b9261419e610452565b918291826105c7565b0390a2565b5f631eb7845760e21b8152806141c4600482016106d9565b0390fd5b806141e36141dd6141d85f611f04565b61046b565b9161046b565b146141ff576141fd916141f55f611f04565b919091615255565b565b61422261420b5f611f04565b5f91829163ec442f0560e01b835260048301610e32565b0390fd5b90614231910361049a565b90565b929192614242818390613d73565b90816142576142515f1961049a565b9161049a565b10614264575b5050509050565b816142776142718761049a565b9161049a565b1061429d57614294939461428c919392614226565b905f92615146565b805f808061425d565b506142bc849291925f938493637dc7a0d960e11b855260048501613eec565b0390fd5b91826142dc6142d66142d15f611f04565b61046b565b9161046b565b1461433657816142fc6142f66142f15f611f04565b61046b565b9161046b565b1461430f5761430d92919091615255565b565b61433261431b5f611f04565b5f91829163ec442f0560e01b835260048301610e32565b0390fd5b6143596143425f611f04565b5f918291634b637e8f60e11b835260048301610e32565b0390fd5b61437161436c600d8390610bfd565b613ee9565b9161438f614389614382600e611f10565b8490614a4d565b1561065f565b801561453b575b61451c576143af426143a9610e106126ba565b906126ea565b6143b85f612268565b916143c25f612268565b5b806143d76143d1601861271e565b9161049a565b101561444357826143f06143ea8361049a565b9161049a565b1015614405575b6144009061270c565b6143c3565b9261443b6144009161443561443061441f60128a90610524565b61442a888a9061273a565b90610556565b610c2c565b90612284565b9390506143f7565b5091909293614453828490612284565b61447061446a61446560018501610c2c565b61049a565b9161049a565b116144aa5750506144936144a8939261448e6144a293946012610524565b610556565b9161449d83610c2c565b612284565b90612c4f565b565b8493506144b960018201610c2c565b6144cb6144c58461049a565b9161049a565b115f1461450957614505916144e560016144ea9301610c2c565b61273a565b5b9291925f9384936372ff4bd160e11b855260048501613eec565b0390fd5b50506145056145175f612268565b6144eb565b614537825f918291636585b60d60e01b835260048301610e32565b0390fd5b5061455161454b60028501610c53565b1561065f565b614396565b908161457261456c6145675f611f04565b61046b565b9161046b565b1461458e5761458c91906145855f611f04565b9091615255565b565b6145b161459a5f611f04565b5f918291634b637e8f60e11b835260048301610e32565b0390fd5b6145bd611e61565b506145d26145cc828490613711565b1561065f565b5f1461465b576145fa60016145f55f6145ed60058690612463565b0185906136fb565b612f1d565b90614603613ecc565b9061464061463a6146347f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d95612457565b92610518565b92610518565b92614649610452565b80614653816106d9565b0390a4600190565b50505f90565b614669612453565b50614673306135cc565b6146a561469f7f000000000000000000000000000000000000000000000000000000000000000061046b565b9161046b565b14806146e1575b5f146146d6577f000000000000000000000000000000000000000000000000000000000000000090565b6146de615370565b90565b504661471561470f7f000000000000000000000000000000000000000000000000000000000000000061049a565b9161049a565b146146ac565b614723611e61565b5061472f818390613711565b5f146147b7576147565f6147515f61474960058690612463565b0185906136fb565b612f1d565b9061475f613ecc565b9061479c6147966147907ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b95612457565b92610518565b92610518565b926147a5610452565b806147af816106d9565b0390a4600190565b50505f90565b6147d16147cc6147d692611607565b6104ed565b61049a565b90565b9160206147fa9294936147f360408201965f8301906105ba565b0190611612565b565b61480461373b565b5061480d61373f565b8161482061481a836147bd565b9161049a565b1015614833575061483090615479565b90565b9061484e5f928392637669fc0f60e11b8452600484016147d9565b0390fd5b5490565b90565b61486d61486861487292614856565b6104ed565b61049a565b90565b90565b65ffffffffffff1690565b61488f61489491610c13565b614878565b90565b6148a19054614883565b90565b90565b6148bb6148b66148c0926148a4565b6104ed565b61049a565b90565b60301c90565b60018060d01b031690565b6148e06148e5916148c3565b6148c9565b90565b6148f290546148d4565b90565b61490961490461490e9261177f565b6104ed565b611cdd565b90565b906149659061491e611dcc565b5061492a5f8401614852565b6149335f612268565b9080806149496149436005614859565b9161049a565b116149c6575b50906149605f860193919293614875565b615ab4565b806149786149725f612268565b9161049a565b145f1461498e57505061498a5f6148f5565b5b90565b6149bb5f916149b66149b0846149c19601926149aa60016148a7565b9061273a565b91614875565b615aaa565b016148e8565b61498b565b806149d46149da929161573f565b9061273a565b9083614a0c614a06614a015f6149fb818c016149f68991614875565b615aaa565b01614897565b611607565b91611607565b105f14614a1d5750905b905f61494f565b9150614a3390614a2d60016148a7565b90612284565b614a16565b614a4061373b565b50614a4a43615479565b90565b90614a7f614a79614a74614a6f5f614a8496614a67611e61565b500194613e4b565b613e57565b613e73565b91613e8f565b615b43565b90565b614a9e5f614aa392614a97611f61565b5001613e8f565b615b78565b90565b614ab2614ab791610c13565b61053a565b90565b614ace614ac9614ad39261049a565b6104ed565b610460565b90565b614b01614afc614b0b93614af75f614b0695614af0612bb8565b5001613e8f565b615b8f565b614aa6565b614aba565b61050c565b90565b90614b1f60018060a01b0391611782565b9181191691161790565b90565b90614b41614b3c614b4892610518565b614b29565b8254614b0e565b9055565b90614bd591614bcf614b5d82612bfe565b614b7284614b6d60098690612bbc565b614b2c565b82818590614bb2614bac614ba67f3134e8a2e6d97e929a7e54011ea5485d7d196dd5f0ba4d4ef95803e8e3fc257f95610518565b92610518565b92610518565b92614bbb610452565b80614bc5816106d9565b0390a49291615bb0565b91615bc8565b565b90614c09614c03614bfe614bf95f614c0e96614bf1611e61565b500194613e4b565b613e57565b613e73565b91613e8f565b615dab565b90565b614c38614c33614c2e614c3d93614c2661320d565b50600a612919565b61292f565b615e0e565b615e8d565b90565b614c575f614c5c92614c50613244565b5001613e8f565b615faf565b614c64613244565b5090565b614c7a90614c74611f61565b50615fc6565b90565b90565b614c886120c1565b50614cbd7f0000000000000000000000000000000000000000000000000000000000000000614cb76006614c7d565b906160e1565b90565b614cc86120c1565b50614cfd7f0000000000000000000000000000000000000000000000000000000000000000614cf76007614c7d565b906160e1565b90565b614d08611dcc565b50614d145f8201614852565b80614d27614d215f612268565b9161049a565b145f14614d3d575050614d395f6148f5565b5b90565b614d6a5f91614d65614d5f84614d70960192614d5960016148a7565b9061273a565b91614875565b615aaa565b016148e8565b614d3a565b614d8f90614d81612453565b50614d8a614661565b61612f565b90565b92614dad92614db694614da3612bb8565b50929091926161e1565b9092919261630c565b90565b916020614dda929493614dd360408201965f830190610e25565b01906105ba565b565b614de581614e1f565b91614df8614df28461049a565b9161049a565b03614e01575050565b614e1b5f9283926301d4b62360e61b845260048401614db9565b0390fd5b614e3390614e2b611f61565b50600861099f565b614e4f614e3f82610c2c565b91614e498361270c565b90612c4f565b90565b90614e72614e6d614e7793614e65613dd6565b50600a612919565b61292f565b61646e565b90565b614e82611e61565b50614e9c614e966301ffc9a760e01b610612565b91610612565b1490565b916020614ec1929493614eba60408201965f830190610e25565b0190610948565b565b90614ed8614ed2838390613711565b1561065f565b614ee0575050565b614efa5f92839263e2517d3f60e01b845260048401614ea0565b0390fd5b90614f0890612457565b5f5260205260405f2090565b5490565b634e487b7160e01b5f52603260045260245ffd5b5f5260205f2090565b614f3e81614f14565b821015614f5857614f50600191614f2c565b910201905f90565b614f18565b614f6d906008614f72930261056c565b612479565b90565b90614f809154614f5d565b90565b614f8c90610c13565b90565b9190614fa5614fa0614fad93612457565b614f83565b908354611f17565b9055565b90565b634e487b7160e01b5f52603160045260245ffd5b5490565b5f5260205f2090565b614fde81614fc8565b821015614ff857614ff0600191614fcc565b910201905f90565b614f18565b61500f91615009612453565b91614f8f565b565b61501a81614fc8565b801561503b5760019003906150386150328383614fd5565b90614ffd565b55565b614fb4565b615048611e61565b5061505f61505a600183018490614efe565b610c2c565b908161507361506d5f612268565b9161049a565b14155f1461513f576150f19260016150ec928461509a5f96615094856148a7565b9061273a565b6150b76150a8888501614f14565b6150b1866148a7565b9061273a565b816150ca6150c48361049a565b9161049a565b036150f6575b5050506150e66150e1868301614fb1565b615011565b01614efe565b611f65565b600190565b6151379261512961511561510f615132948c8901614f35565b90614f75565b9361512385918c8901614f35565b90614f8f565b91858501614efe565b612c4f565b5f80806150d0565b5050505f90565b90928161516361515d6151585f611f04565b61046b565b9161046b565b1461522e578361518361517d6151785f611f04565b61046b565b9161046b565b14615207576151a7836151a261519b60018690613d5d565b879061099f565b612c4f565b6151b1575b505050565b9190916151fc6151ea6151e47f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92593610518565b93610518565b936151f3610452565b918291826105c7565b0390a35f80806151ac565b61522a6152135f611f04565b5f918291634a1406b160e11b835260048301610e32565b0390fd5b61525161523a5f611f04565b5f91829163e602df0560e01b835260048301610e32565b0390fd5b918261527161526b6152665f611f04565b61046b565b9161046b565b1415806152dc575b61528c575b61528a9291909161648f565b565b615294613465565b806152bb575b1561527e575f6336e278fd60e21b8152806152b7600482016106d9565b0390fd5b506152d76152d16152ca61145d565b3390613711565b1561065f565b61529a565b50816152f86152f26152ed5f611f04565b61046b565b9161046b565b1415615279565b7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f90565b9095949261536e9461535d6153679261535360809661534960a088019c5f890190610948565b6020870190610948565b6040850190610948565b60608301906105ba565b0190610e25565b565b615378612453565b506153816152ff565b6153f87f0000000000000000000000000000000000000000000000000000000000000000916153e97f0000000000000000000000000000000000000000000000000000000000000000466153d4306135cc565b916153dd610452565b96879560208701615323565b602082018103825203826121c3565b61540a61540482613977565b91613971565b2090565b90565b61542561542061542a9261540e565b6104ed565b610acd565b90565b61543690615411565b9052565b91602061545b92949361545460408201965f83019061542d565b01906105ba565b565b61547161546c6154769261049a565b6104ed565b611607565b90565b61548161373b565b508061549b61549565ffffffffffff6147bd565b9161049a565b116154ac576154a99061545d565b90565b60306154c85f9283926306dfcc6560e41b84526004840161543a565b0390fd5b90565b6154e36154de6154e8926154cc565b6104ed565b61049a565b90565b90565b6155026154fd615507926154eb565b6104ed565b610acd565b90565b6155299061552361551d61552e94610acd565b9161049a565b9061056c565b61049a565b90565b90565b61554861554361554d92615531565b6104ed565b610acd565b90565b61556f9061556961556361557494610acd565b9161049a565b90611f13565b61049a565b90565b90565b61558e61558961559392615577565b6104ed565b61049a565b90565b90565b6155ad6155a86155b292615596565b6104ed565b610acd565b90565b90565b6155cc6155c76155d1926155b5565b6104ed565b61049a565b90565b90565b6155eb6155e66155f0926155d4565b6104ed565b610acd565b90565b90565b61560a61560561560f926155f3565b6104ed565b61049a565b90565b90565b61562961562461562e92615612565b6104ed565b610acd565b90565b90565b61564861564361564d92615631565b6104ed565b61049a565b90565b90565b61566761566261566c92615650565b6104ed565b610acd565b90565b61568361567e615688926155d4565b6104ed565b61049a565b90565b90565b6156a261569d6156a79261568b565b6104ed565b610acd565b90565b6156be6156b96156c392615650565b6104ed565b61049a565b90565b6156da6156d56156df926148a4565b6104ed565b610acd565b90565b90565b6156f96156f46156fe926156e2565b6104ed565b61049a565b90565b9061570c910261049a565b90565b61571b6157219161049a565b9161049a565b90811561572c570490565b6126d6565b9061573c910161049a565b90565b615747611f61565b508061575c61575660016148a7565b9161049a565b1115615aa7578061597161594e61593e61592e61591e61590e6158fe6158ee6158de6158ce6158be8b6158b86158b16159779f6158916158816158a1926157a360016148a7565b90806157bb6157b5600160801b6154cf565b9161049a565b1015615a79575b806157de6157d86801000000000000000061557a565b9161049a565b1015615a4b575b806157fd6157f76401000000006155b8565b9161049a565b1015615a1d575b8061581a615814620100006155f6565b9161049a565b10156159ef575b80615836615830610100615634565b9161049a565b10156159c1575b8061585161584b601061566f565b9161049a565b1015615993575b61586b61586560046156aa565b9161049a565b101561597a575b61587c60036156e5565b615701565b61588b60016156c6565b9061550a565b61589b818661570f565b90615731565b6158ab60016156c6565b9061550a565b809261570f565b90615731565b6158c860016156c6565b9061550a565b6158d8818c61570f565b90615731565b6158e860016156c6565b9061550a565b6158f8818a61570f565b90615731565b61590860016156c6565b9061550a565b615918818861570f565b90615731565b61592860016156c6565b9061550a565b615938818661570f565b90615731565b61594860016156c6565b9061550a565b9161596b61596561596085809461570f565b61049a565b9161049a565b1161651f565b90614226565b90565b61598e9061598860016156c6565b90615550565b615872565b6159aa6159bb916159a46004615653565b9061550a565b916159b5600261568e565b90615550565b90615858565b6159d86159e9916159d26008615615565b9061550a565b916159e36004615653565b90615550565b9061583d565b615a06615a1791615a0060106155d7565b9061550a565b91615a116008615615565b90615550565b90615821565b615a34615a4591615a2e6020615599565b9061550a565b91615a3f60106155d7565b90615550565b90615804565b615a62615a7391615a5c6040615534565b9061550a565b91615a6d6020615599565b90615550565b906157e5565b615a90615aa191615a8a60806154ee565b9061550a565b91615a9b6040615534565b90615550565b906157c2565b90565b5f5260205f200190565b93919092615ac0611f61565b505b81615ad5615acf8361049a565b9161049a565b1015615b3b57615ae6828290616549565b90615afc5f615af6888590615aaa565b01614897565b615b0e615b0887611607565b91611607565b115f14615b1e5750915b91615ac2565b929150615b3590615b2f60016148a7565b90612284565b90615b18565b925050915090565b615b61916001615b5c92615b55611e61565b5001614efe565b610c2c565b615b73615b6d5f612268565b9161049a565b141590565b5f615b8c91615b85611f61565b5001614f14565b90565b615bad915f615ba792615ba0612453565b5001614f35565b90614f75565b90565b615bc290615bbc611f61565b50613226565b90565b90565b91909180615bde615bd88561046b565b9161046b565b141580615d5c575b615bf0575b505050565b80615c0b615c05615c005f611f04565b61046b565b9161046b565b03615ccc575b5081615c2d615c27615c225f611f04565b61046b565b9161046b565b03615c39575b80615beb565b615c80615c73615c7a92615c4f600a8690612919565b90615c6d615c67615c616001936165e2565b9361292f565b91615bc5565b90616635565b9290612932565b91612932565b919091615cad7fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a72492610518565b92615cc2615cb9610452565b92839283612ebb565b0390a25f80615c33565b615d0b615d11615d04615ce1600a8590612919565b6002615cfe615cf8615cf2896165e2565b9361292f565b91615bc5565b90616635565b9290612932565b91612932565b919091615d3e7fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a72492610518565b92615d53615d4a610452565b92839283612ebb565b0390a25f615c11565b5081615d70615d6a5f612268565b9161049a565b11615be6565b9081549168010000000000000000831015615da65782615d9e916001615da495018155614fd5565b90614f8f565b565b6121af565b615db3611e61565b50615dc8615dc2828490615b43565b1561065f565b5f14615e0857615dfe615e0392615dea615de35f8501614fb1565b8290615d76565b6001615df75f8501614f14565b9301614efe565b612c4f565b600190565b50505f90565b5f615e2291615e1b611f61565b5001614852565b90565b615e39615e34615e3e92611012565b6104ed565b61049a565b90565b615e4a90615599565b9052565b916020615e6f929493615e6860408201965f830190615e41565b01906105ba565b565b615e85615e80615e8a9261049a565b6104ed565b611012565b90565b615e9561320d565b5080615ead615ea763ffffffff615e25565b9161049a565b11615ebe57615ebb90615e71565b90565b6020615eda5f9283926306dfcc6560e41b845260048401615e4e565b0390fd5b606090565b60209181520190565b615ef590610904565b9052565b90615f0681602093615eec565b0190565b615f14905461247c565b90565b60010190565b90615f3a615f34615f2d84614f14565b8093615ee3565b92614f2c565b905f5b818110615f4a5750505090565b909192615f6a615f64600192615f5f87615f0a565b615ef9565b94615f17565b9101919091615f3d565b90615f7e91615f1d565b90565b90615fa1615f9a92615f91610452565b93848092615f74565b03836121c3565b565b615fac90615f81565b90565b5f615fc391615fbc615ede565b5001615fa3565b90565b615fdd615fe291615fd5611f61565b50600861099f565b610c2c565b90565b90565b615ffc615ff761600192615fe5565b611782565b610904565b90565b61600e60ff615fe8565b90565b5f5260205f2090565b905f929180549061603461602d836120da565b8094612104565b916001811690815f1461608b575060011461604f575b505050565b61605c9192939450616011565b915f925b81841061607357505001905f808061604a565b60018160209295939554848601520191019290616060565b92949550505060ff19168252151560200201905f808061604a565b906160b09161601a565b90565b906160d36160cc926160c3610452565b938480926160a6565b03836121c3565b565b6160de906160b3565b90565b906160ea6120c1565b506160f482612457565b61610d616107616102616004565b610904565b91610904565b14155f14616122575061611f906166bf565b90565b61612c91506160d5565b90565b60429161613a612453565b50604051917f19010000000000000000000000000000000000000000000000000000000000008352600283015260228201522090565b5f90565b90565b61618b61618661619092616174565b6104ed565b61049a565b90565b6161c86161cf946161be6060949897956161b4608086019a5f870190610948565b6020850190610ad3565b6040830190610948565b0190610948565b565b6161d9610452565b3d5f823e3d90fd5b9392936161ec612bb8565b506161f5616170565b506161fe612453565b5061620885614aa6565b61623a6162347f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0616177565b9161049a565b116162c7579061625d602094955f94939293616254610452565b94859485616193565b838052039060015afa156162c2576162755f51611782565b8061629061628a6162855f611f04565b61046b565b9161046b565b146162a6575f916162a05f611787565b91929190565b506162b05f611f04565b6001916162bc5f611787565b91929190565b6161d1565b5050506162d35f611f04565b9060039291929190565b634e487b7160e01b5f52602160045260245ffd5b600411156162fb57565b6162dd565b9061630a826162f1565b565b8061631f6163195f616300565b91616300565b145f1461632a575050565b8061633e6163386001616300565b91616300565b145f14616361575f63f645eedf60e01b81528061635d600482016106d9565b0390fd5b8061637561636f6002616300565b91616300565b145f146163a35761639f61638883614aa6565b5f91829163fce698f760e01b8352600483016105c7565b0390fd5b6163b66163b06003616300565b91616300565b146163be5750565b6163d9905f9182916335e2f38360e21b835260048301610955565b0390fd5b5f5260205f2090565b6163ef81614852565b821015616409576164016001916163dd565b910201905f90565b614f18565b9061641890611607565b9052565b9061642690611cdd565b9052565b906164606164575f61643a613d9b565b94616451616449838301614897565b83880161640e565b016148e8565b6020840161641c565b565b61646b9061642a565b90565b61648c915f6164869261647f613dd6565b50016163e6565b50616462565b90565b929161649d848383916166ef565b836164b86164b26164ad5f611f04565b61046b565b9161046b565b146164cd575b6164cb9293919091616879565b565b6164d5612252565b936164de61685e565b94806164f26164ec8861049a565b9161049a565b116164ff575093506164be565b859061651b5f928392630e58ae9360e11b845260048401612ebb565b0390fd5b616527611f61565b50151590565b61654161653c6165469261568b565b6104ed565b61049a565b90565b61656e61657492616558611f61565b508281169218616568600261652d565b906126ea565b90612284565b90565b90565b61658e61658961659392616577565b6104ed565b610acd565b90565b61659f9061657a565b9052565b9160206165c49294936165bd60408201965f830190616596565b01906105ba565b565b6165da6165d56165df9261049a565b6104ed565b611cdd565b90565b6165ea611dcc565b50806166046165fe60018060d01b03612932565b9161049a565b1161661557616612906165c6565b90565b60d06166315f9283926306dfcc6560e41b8452600484016165a3565b0390fd5b9061666b6166719392616646611dcc565b5061664f611dcc565b50809361666461665d61373f565b9492614d00565b9091616ce1565b91616938565b91909190565b61668b61668661669092615596565b6104ed565b61049a565b90565b369037565b906166bd6166a583612b00565b926020806166b38693612add565b9201910390616693565b565b6166c76120c1565b506166d1816169a2565b906166e46166df6020616677565b616698565b918252602082015290565b9190918061670d6167076167025f611f04565b61046b565b9161046b565b145f146167ee5761673161672a836167256002610c2c565b612284565b6002612c4f565b5b8261674d6167476167425f611f04565b61046b565b9161046b565b145f146167c25761677161676a836167656002610c2c565b614226565b6002612c4f565b5b9190916167bd6167ab6167a57fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef93610518565b93610518565b936167b4610452565b918291826105c7565b0390a3565b6167e9826167e36167d45f879061099f565b916167de83610c2c565b615731565b90612c4f565b616772565b6168016167fc5f839061099f565b610c2c565b8061681461680e8561049a565b9161049a565b1061683c57616827616837918490614226565b6168325f849061099f565b612c4f565b616732565b9061685a9091925f93849363391434e360e21b855260048501613eec565b0390fd5b616866611f61565b5061687660018060d01b03612932565b90565b916168d16168cb6168d8948061689f6168996168945f611f04565b61046b565b9161046b565b14616909575b846168c06168ba6168b55f611f04565b61046b565b9161046b565b146168da575b612bfe565b92612bfe565b9091615bc8565b565b616902600b60026168fc6168f66168f0896165e2565b9361292f565b91615bc5565b90616635565b50506168c6565b616931600b600161692b61692561691f896165e2565b9361292f565b91615bc5565b90616635565b50506168a5565b9161695c5f61696194616949611dcc565b50616952611dcc565b5001929192614875565b616b93565b91909190565b61697b61697661698092615fe5565b6104ed565b61049a565b90565b90565b61699a61699561699f92616983565b6104ed565b61049a565b90565b6169b76169bc916169b1611f61565b50612457565b614aa6565b6169c660ff616967565b16806169db6169d5601f616986565b9161049a565b116169e35790565b5f632cd44ac360e21b8152806169fb600482016106d9565b0390fd5b5490565b616a0d6040612638565b90565b5f5260205f2090565b616a22816169ff565b821015616a3c57616a34600191616a10565b910201905f90565b614f18565b616a4b9051611607565b90565b90616a5f65ffffffffffff91611782565b9181191691161790565b616a7d616a78616a8292611607565b6104ed565b611607565b90565b90565b90616a9d616a98616aa492616a69565b616a85565b8254616a4e565b9055565b616ab29051611cdd565b90565b60301b90565b90616acd65ffffffffffff1991616ab5565b9181191691161790565b616aeb616ae6616af092611cdd565b6104ed565b611cdd565b90565b90565b90616b0b616b06616b1292616ad7565b616af3565b8254616abb565b9055565b90616b4060205f616b4694616b38828201616b32848801616a41565b90616a88565b019201616aa8565b90616af6565b565b9190616b5957616b5791616b16565b565b611f9a565b9081549168010000000000000000831015616b8e5782616b86916001616b8c95018155616a19565b90616b48565b565b6121af565b90929192616b9f611dcc565b50616ba8611dcc565b50616bb2826169ff565b80616bc5616bbf5f612268565b9161049a565b115f14616c9557616beb90616be58491616bdf60016148a7565b9061273a565b90615aaa565b90616bf75f8301614897565b92616c035f84016148e8565b9380616c17616c1185611607565b91611607565b11616c7957616c2e616c2884611607565b91611607565b145f14616c49575050616c44905f859101616af6565b5b9190565b616c749250616c6f86616c66616c5d616a03565b945f860161640e565b6020840161641c565b616b5e565b616c45565b5f632520601d60e01b815280616c91600482016106d9565b0390fd5b50616cc091616cbb85616cb2616ca9616a03565b945f860161640e565b6020840161641c565b616b5e565b616cc95f6148f5565b9190565b634e487b7160e01b5f52605160045260245ffd5b91909180600114616d0057600203616ccd57616cfc91611e4b565b905b565b50616d0a91611e0c565b90616cfe56
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"a\x01\x80`@R4a\0\x84Wa\0\x1Ba\0\x15a\x01XV[\x90a\x01\xC2V[a\0#a\0\x89V[am\x10a\x1D\x13\x829`\x80Q\x81aF\xB4\x01R`\xA0Q\x81aF\xEB\x01R`\xC0Q\x81aF{\x01R`\xE0Q\x81aS\x86\x01Ra\x01\0Q\x81aS\xAB\x01Ra\x01 Q\x81aL\x8E\x01Ra\x01@Q\x81aL\xCE\x01Ra\x01`Q\x81\x81\x81a\x12\x85\x01Ra4\xF5\x01Ram\x10\x90\xF3[a\0\x8FV[`@Q\x90V[_\x80\xFD[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\0\xBB\x90a\0\x93V[\x81\x01\x90\x81\x10`\x01\x80`@\x1B\x03\x82\x11\x17a\0\xD3W`@RV[a\0\x9DV[\x90a\0\xEBa\0\xE4a\0\x89V[\x92\x83a\0\xB1V[V[_\x80\xFD[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x01\x05\x90a\0\xF1V[\x90V[a\x01\x11\x81a\0\xFCV[\x03a\x01\x18WV[_\x80\xFD[\x90PQ\x90a\x01)\x82a\x01\x08V[V[\x91\x90`@\x83\x82\x03\x12a\x01SW\x80a\x01Ga\x01P\x92_\x86\x01a\x01\x1CV[\x93` \x01a\x01\x1CV[\x90V[a\0\xEDV[a\x01va\x8A#\x808\x03\x80a\x01k\x81a\0\xD8V[\x92\x839\x81\x01\x90a\x01+V[\x90\x91V[\x7F\xCC\xE2\x96\xB0@3*\x08\x0Em\xF15\x15\xA3\xEC(i\xE2\x1C\xD2\x0FsD\xAF\t\x87\xDD\xB98\xD8\xBD!\x90V[\x7F\x82\x03r\xA9\xFA\xF8-\xB3\xCC_\xC3o\xFA\xB5\xF0\x96\xEE\xF6\x9B\x95\xFB\xF5\x05\x91\xE0\xD7\x14G\xAA\x1B\xA7\0\x90V[a\x01\xCFa\x01\xEF\x92\x82a\x01\xF2V[a\x01\xE1a\x01\xDAa\x01zV[\x82\x90a\t\xD1V[Pa\x01\xEAa\x01\x9EV[a\t\xD1V[PV[\x90a\x01\xFC\x91a\x01\xFEV[V[\x90a\x02\x08\x91a\x04MV[V[`\x01\x80`@\x1B\x03\x81\x11a\x02&Wa\x02\"` \x91a\0\x93V[\x01\x90V[a\0\x9DV[\x90a\x02=a\x028\x83a\x02\nV[a\0\xD8V[\x91\x82RV[_\x7FSyndicate\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x02s`\ta\x02+V[\x90a\x02\x80` \x83\x01a\x02BV[V[a\x02\x8Aa\x02iV[\x90V[_\x7FSYND\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x02\xBE`\x04a\x02+V[\x90a\x02\xCB` \x83\x01a\x02\x8DV[V[a\x02\xD5a\x02\xB4V[\x90V[\x90V[\x90V[a\x02\xF2a\x02\xEDa\x02\xF7\x92a\x02\xD8V[a\x02\xDBV[a\0\xF1V[\x90V[a\x03\x03\x90a\x02\xDEV[\x90V[_\x01\x90V[\x90V[\x90V[a\x03%a\x03 a\x03*\x92a\x03\x0BV[a\x02\xDBV[a\x03\x0EV[\x90V[a\x039bv\xA7\0a\x03\x11V[\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\x03_a\x03e\x91\x93\x92\x93a\x03\x0EV[\x92a\x03\x0EV[\x82\x01\x80\x92\x11a\x03pWV[a\x03<V[a\x03\x89a\x03\x84a\x03\x8E\x92a\x02\xD8V[a\x02\xDBV[a\x03\x0EV[\x90V[_\x1B\x90V[\x90a\x03\xA2_\x19\x91a\x03\x91V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x03\xC0a\x03\xBBa\x03\xC5\x92a\x03\x0EV[a\x02\xDBV[a\x03\x0EV[\x90V[\x90V[\x90a\x03\xE0a\x03\xDBa\x03\xE7\x92a\x03\xACV[a\x03\xC8V[\x82Ta\x03\x96V[\x90UV[\x90V[a\x04\x02a\x03\xFDa\x04\x07\x92a\x02\xD8V[a\x03\x91V[a\x03\xEBV[\x90V[a\x04\x13_a\x03\xEEV[\x90V[\x90V[a\x04-a\x04(a\x042\x92a\x04\x16V[a\x02\xDBV[a\x03\x0EV[\x90V[a\x04Jk\x02\xE8vi\xC3\x08sj\x04\0\0\0a\x04\x19V[\x90V[\x90a\x04oa\x04Ya\x02\x82V[a\x04aa\x02\x82V[a\x04ia\x02\xCDV[\x91a\x055V[\x81a\x04\x8Aa\x04\x84a\x04\x7F_a\x02\xFAV[a\0\xFCV[\x91a\0\xFCV[\x14a\x05\x19W\x80a\x04\xAAa\x04\xA4a\x04\x9F_a\x02\xFAV[a\0\xFCV[\x91a\0\xFCV[\x14a\x04\xFDWa\x04\xECa\x04\xFB\x92a\x04\xC8Ba\x04\xC2a\x03-V[\x90a\x03PV[a\x01`Ra\x04\xDFa\x04\xD8_a\x03uV[`\x0Ca\x03\xCBV[a\x04\xE7a\x04\nV[a\t\xD1V[Pa\x04\xF5a\x045V[\x90a\n\x9FV[V[_c\xD9.#=`\xE0\x1B\x81R\x80a\x05\x15`\x04\x82\x01a\x03\x06V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a\x051`\x04\x82\x01a\x03\x06V[\x03\x90\xFD[\x90a\x05@\x92\x91a\x05BV[V[\x90a\x05M\x92\x91a\x05OV[V[\x90a\x05Z\x92\x91a\x05\\V[V[\x90a\x05g\x92\x91a\x05iV[V[\x90a\x05t\x92\x91a\x05\xC1V[V[_\x7F1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x05\xA7`\x01a\x02+V[\x90a\x05\xB4` \x83\x01a\x05vV[V[a\x05\xBEa\x05\x9DV[\x90V[\x90a\x05\xD5\x92\x91a\x05\xCFa\x05\xB6V[\x90a\x05\xD7V[V[\x90a\x05\xE3\x93\x92\x91a\x06)V[V[\x90V[\x90V[` \x01\x90V[Q\x90V[a\x06\ta\x06\x04a\x06\x0E\x92a\0\xF1V[a\x02\xDBV[a\0\xF1V[\x90V[a\x06\x1A\x90a\x05\xF5V[\x90V[a\x06&\x90a\x06\x11V[\x90V[a\x06:a\x06\x8A\x94a\x06o\x93\x94a\x06\xBEV[a\x06N\x81a\x06H`\x06a\x05\xE5V[\x90a\x0BLV[a\x01 Ra\x06f\x83a\x06``\x07a\x05\xE5V[\x90a\x0BLV[a\x01@Ra\x05\xE8V[a\x06\x81a\x06{\x82a\x05\xF1V[\x91a\x05\xEBV[ `\xE0Ra\x05\xE8V[a\x06\x9Ca\x06\x96\x82a\x05\xF1V[\x91a\x05\xEBV[ a\x01\0RF`\xA0Ra\x06\xADa\x0CQV[`\x80Ra\x06\xB90a\x06\x1DV[`\xC0RV[\x90a\x06\xC8\x91a\x06\xCAV[V[\x90a\x06\xD4\x91a\x06\xD6V[V[\x90a\x06\xE0\x91a\t'V[V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[Q\x90V[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x07-W[` \x83\x10\x14a\x07(WV[a\x06\xF9V[\x91`\x7F\x16\x91a\x07\x1DV[_R` _ \x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a\x07i\x91\x02\x91a\x07c_\x19\x84a\x07JV[\x92a\x07JV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x91\x90a\x07\x89a\x07\x84a\x07\x91\x93a\x03\xACV[a\x03\xC8V[\x90\x83Ta\x07NV[\x90UV[_\x90V[a\x07\xAB\x91a\x07\xA5a\x07\x95V[\x91a\x07sV[V[[\x81\x81\x10a\x07\xB9WPPV[\x80a\x07\xC6_`\x01\x93a\x07\x99V[\x01a\x07\xAEV[\x91\x90`\x1F\x81\x11a\x07\xDCW[PPPV[a\x07\xE8a\x08\r\x93a\x077V[\x90` a\x07\xF4\x84a\x07@V[\x83\x01\x93\x10a\x08\x15W[a\x08\x06\x90a\x07@V[\x01\x90a\x07\xADV[_\x80\x80a\x07\xD7V[\x91Pa\x08\x06\x81\x92\x90Pa\x07\xFDV[\x1C\x90V[\x90a\x087\x90_\x19\x90`\x08\x02a\x08#V[\x19\x16\x90V[\x81a\x08F\x91a\x08'V[\x90`\x02\x02\x17\x90V[\x90a\x08X\x81a\x06\xF5V[\x90`\x01\x80`@\x1B\x03\x82\x11a\t\x16Wa\x08z\x82a\x08t\x85Ta\x07\rV[\x85a\x07\xCCV[` \x90`\x1F\x83\x11`\x01\x14a\x08\xAEW\x91\x80\x91a\x08\x9D\x93_\x92a\x08\xA2W[PPa\x08<V[\x90U[V[\x90\x91P\x01Q_\x80a\x08\x96V[`\x1F\x19\x83\x16\x91a\x08\xBD\x85a\x077V[\x92_[\x81\x81\x10a\x08\xFEWP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\x08\xE4W[PPP\x02\x01\x90Ua\x08\xA0V[a\x08\xF4\x91\x01Q`\x1F\x84\x16\x90a\x08'V[\x90U_\x80\x80a\x08\xD8V[\x91\x93` `\x01\x81\x92\x87\x87\x01Q\x81U\x01\x95\x01\x92\x01a\x08\xC0V[a\0\x9DV[\x90a\t%\x91a\x08NV[V[\x90a\t6a\t=\x92`\x03a\t\x1BV[`\x04a\t\x1BV[V[_\x90V[\x15\x15\x90V[a\tQ\x90a\x03\xEBV[\x90V[\x90a\t^\x90a\tHV[_R` R`@_ \x90V[a\ts\x90a\x06\x11V[\x90V[\x90a\t\x80\x90a\tjV[_R` R`@_ \x90V[\x90a\t\x98`\xFF\x91a\x03\x91V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\t\xAB\x90a\tCV[\x90V[\x90V[\x90a\t\xC6a\t\xC1a\t\xCD\x92a\t\xA2V[a\t\xAEV[\x82Ta\t\x8CV[\x90UV[a\t\xD9a\t?V[Pa\t\xEEa\t\xE8\x82\x84\x90a\x0C\xEEV[\x15a\tCV[_\x14a\nwWa\n\x16`\x01a\n\x11_a\n\t`\x05\x86\x90a\tTV[\x01\x85\x90a\tvV[a\t\xB1V[\x90a\n\x1Fa\r\x1CV[\x90a\n\\a\nVa\nP\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a\tHV[\x92a\tjV[\x92a\tjV[\x92a\nea\0\x89V[\x80a\no\x81a\x03\x06V[\x03\x90\xA4`\x01\x90V[PP_\x90V[a\n\x86\x90a\0\xFCV[\x90RV[\x91\x90a\n\x9D\x90_` \x85\x01\x94\x01\x90a\n}V[V[\x80a\n\xBAa\n\xB4a\n\xAF_a\x02\xFAV[a\0\xFCV[\x91a\0\xFCV[\x14a\n\xD6Wa\n\xD4\x91a\n\xCC_a\x02\xFAV[\x91\x90\x91a\rMV[V[a\n\xF9a\n\xE2_a\x02\xFAV[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\n\x8AV[\x03\x90\xFD[_\x90V[\x90V[a\x0B\x18a\x0B\x13a\x0B\x1D\x92a\x0B\x01V[a\x02\xDBV[a\x03\x0EV[\x90V[\x90V[a\x0B7a\x0B2a\x0B<\x92a\x0B V[a\x03\x91V[a\x03\xEBV[\x90V[a\x0BI`\xFFa\x0B#V[\x90V[\x90a\x0BUa\n\xFDV[Pa\x0Bga\x0Bb\x83a\x05\xE8V[a\x05\xF1V[a\x0Bza\x0Bt` a\x0B\x04V[\x91a\x03\x0EV[\x10_\x14a\x0B\x8EWPa\x0B\x8B\x90a\x0E\xE7V[\x90V[_a\x0B\x9Ca\x0B\xA2\x93\x92a\r\xF7V[\x01a\t\x1BV[a\x0B\xB2a\x0B\xADa\x0B?V[a\tHV[\x90V[_\x90V[\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x90V[a\x0B\xE7\x90Qa\x03\xEBV[\x90V[a\x0B\xF3\x90a\x03\xEBV[\x90RV[a\x0C\0\x90a\x03\x0EV[\x90RV[\x90\x95\x94\x92a\x0CO\x94a\x0C>a\x0CH\x92a\x0C4`\x80\x96a\x0C*`\xA0\x88\x01\x9C_\x89\x01\x90a\x0B\xEAV[` \x87\x01\x90a\x0B\xEAV[`@\x85\x01\x90a\x0B\xEAV[``\x83\x01\x90a\x0B\xF7V[\x01\x90a\n}V[V[a\x0CYa\x0B\xB5V[Pa\x0Cba\x0B\xB9V[a\x0C\xACa\x0Co`\xE0a\x0B\xDDV[\x91a\x0C\x9Da\x0C~a\x01\0a\x0B\xDDV[Fa\x0C\x880a\x06\x1DV[\x91a\x0C\x91a\0\x89V[\x96\x87\x95` \x87\x01a\x0C\x04V[` \x82\x01\x81\x03\x82R\x03\x82a\0\xB1V[a\x0C\xBEa\x0C\xB8\x82a\x05\xF1V[\x91a\x05\xEBV[ \x90V[_\x1C\x90V[`\xFF\x16\x90V[a\x0C\xD9a\x0C\xDE\x91a\x0C\xC2V[a\x0C\xC7V[\x90V[a\x0C\xEB\x90Ta\x0C\xCDV[\x90V[a\r\x15\x91_a\r\na\r\x10\x93a\r\x02a\t?V[P`\x05a\tTV[\x01a\tvV[a\x0C\xE1V[\x90V[_\x90V[a\r$a\r\x18V[P3\x90V[\x7F\x84\xFEt\xC7\x1A(\xB6\x9A\xA9`Hl\xA0\xE8\xC1A\x8C\x86\xE9\xEA,\xD6\xB5\x84\x9B\x95\xE2\xC8\xF4\x07\xA6t\x90V[\x91\x82a\ria\rca\r^_a\x02\xFAV[a\0\xFCV[\x91a\0\xFCV[\x14\x15\x80a\r\xD4W[a\r\x84W[a\r\x82\x92\x91\x90\x91a\x10\x0BV[V[a\r\x8Ca\x0F\x95V[\x80a\r\xB3W[\x15a\rvW_c6\xE2x\xFD`\xE2\x1B\x81R\x80a\r\xAF`\x04\x82\x01a\x03\x06V[\x03\x90\xFD[Pa\r\xCFa\r\xC9a\r\xC2a\r)V[3\x90a\x0C\xEEV[\x15a\tCV[a\r\x92V[P\x81a\r\xF0a\r\xEAa\r\xE5_a\x02\xFAV[a\0\xFCV[\x91a\0\xFCV[\x14\x15a\rqV[\x90V[\x90V[a\x0E\x11a\x0E\x0Ca\x0E\x16\x92a\r\xFAV[a\x02\xDBV[a\x03\x0EV[\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[a\x0ELa\x0EU` \x93a\x0EZ\x93a\x0EC\x81a\x06\xF5V[\x93\x84\x80\x93a\x0E\x19V[\x95\x86\x91\x01a\x0E\"V[a\0\x93V[\x01\x90V[a\x0Es\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x0E-V[\x90V[a\x0E\x90a\x0E\x8Ba\x0E\x85\x83a\x05\xF1V[\x92a\x05\xEBV[a\x0B\xDDV[\x90` \x81\x10a\x0E\x9EW[P\x90V[a\x0E\xB0\x90_\x19\x90` \x03`\x08\x02a\x07JV[\x16_a\x0E\x9AV[a\x0E\xC3a\x0E\xC8\x91a\x0C\xC2V[a\x03\xACV[\x90V[a\x0E\xDFa\x0E\xDAa\x0E\xE4\x92a\x03\x0EV[a\x03\x91V[a\x03\xEBV[\x90V[a\x0E\xEFa\n\xFDV[Pa\x0E\xF9\x81a\x05\xE8V[\x90a\x0F\x03\x82a\x05\xF1V[a\x0F\x16a\x0F\x10`\x1Fa\r\xFDV[\x91a\x03\x0EV[\x11a\x0FKWPa\x0FC\x81a\x0F=a\x0F7a\x0F2a\x0FH\x95a\x0EvV[a\x0E\xB7V[\x91a\x05\xF1V[\x17a\x0E\xCBV[a\tHV[\x90V[a\x0Fm\x90a\x0FWa\0\x89V[\x91\x82\x91c0Z'\xA9`\xE0\x1B\x83R`\x04\x83\x01a\x0E^V[\x03\x90\xFD[\x90V[a\x0F\x80a\x0F\x85\x91a\x0C\xC2V[a\x0FqV[\x90V[a\x0F\x92\x90Ta\x0FtV[\x90V[a\x0F\x9Da\t?V[Pa\x0F\xA8`\x0Ca\x0F\x88V[a\x0F\xBAa\x0F\xB4_a\x03uV[\x91a\x03\x0EV[\x14\x15\x80a\x0F\xC5W[\x90V[PBa\x0F\xE2a\x0F\xDCa\x0F\xD7`\x0Ca\x0F\x88V[a\x03\x0EV[\x91a\x03\x0EV[\x10a\x0F\xC2V[\x91` a\x10\t\x92\x94\x93a\x10\x02`@\x82\x01\x96_\x83\x01\x90a\x0B\xF7V[\x01\x90a\x0B\xF7V[V[\x92\x91a\x10\x19\x84\x83\x83\x91a\x11\x14V[\x83a\x104a\x10.a\x10)_a\x02\xFAV[a\0\xFCV[\x91a\0\xFCV[\x14a\x10IW[a\x10G\x92\x93\x91\x90\x91a\x12\xE1V[V[a\x10Qa\x12\x83V[\x93a\x10Za\x12\xC0V[\x94\x80a\x10na\x10h\x88a\x03\x0EV[\x91a\x03\x0EV[\x11a\x10{WP\x93Pa\x10:V[\x85\x90a\x10\x97_\x92\x83\x92c\x0EX\xAE\x93`\xE1\x1B\x84R`\x04\x84\x01a\x0F\xE8V[\x03\x90\xFD[\x90a\x10\xA5\x90a\tjV[_R` R`@_ \x90V[`@\x90a\x10\xDAa\x10\xE1\x94\x96\x95\x93\x96a\x10\xD0``\x84\x01\x98_\x85\x01\x90a\n}V[` \x83\x01\x90a\x0B\xF7V[\x01\x90a\x0B\xF7V[V[\x90a\x10\xEE\x91\x03a\x03\x0EV[\x90V[\x90a\x10\xFC\x91\x01a\x03\x0EV[\x90V[\x91\x90a\x11\x12\x90_` \x85\x01\x94\x01\x90a\x0B\xF7V[V[\x91\x90\x91\x80a\x112a\x11,a\x11'_a\x02\xFAV[a\0\xFCV[\x91a\0\xFCV[\x14_\x14a\x12\x13Wa\x11Va\x11O\x83a\x11J`\x02a\x0F\x88V[a\x03PV[`\x02a\x03\xCBV[[\x82a\x11ra\x11la\x11g_a\x02\xFAV[a\0\xFCV[\x91a\0\xFCV[\x14_\x14a\x11\xE7Wa\x11\x96a\x11\x8F\x83a\x11\x8A`\x02a\x0F\x88V[a\x10\xE3V[`\x02a\x03\xCBV[[\x91\x90\x91a\x11\xE2a\x11\xD0a\x11\xCA\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x93a\tjV[\x93a\tjV[\x93a\x11\xD9a\0\x89V[\x91\x82\x91\x82a\x10\xFFV[\x03\x90\xA3V[a\x12\x0E\x82a\x12\x08a\x11\xF9_\x87\x90a\x10\x9BV[\x91a\x12\x03\x83a\x0F\x88V[a\x10\xF1V[\x90a\x03\xCBV[a\x11\x97V[a\x12&a\x12!_\x83\x90a\x10\x9BV[a\x0F\x88V[\x80a\x129a\x123\x85a\x03\x0EV[\x91a\x03\x0EV[\x10a\x12aWa\x12La\x12\\\x91\x84\x90a\x10\xE3V[a\x12W_\x84\x90a\x10\x9BV[a\x03\xCBV[a\x11WV[\x90a\x12\x7F\x90\x91\x92_\x93\x84\x93c9\x144\xE3`\xE2\x1B\x85R`\x04\x85\x01a\x10\xB1V[\x03\x90\xFD[a\x12\x8Ba\x07\x95V[Pa\x12\x96`\x02a\x0F\x88V[\x90V[`\x01\x80`\xD0\x1B\x03\x16\x90V[a\x12\xB8a\x12\xB3a\x12\xBD\x92a\x12\x99V[a\x02\xDBV[a\x03\x0EV[\x90V[a\x12\xC8a\x07\x95V[Pa\x12\xD8`\x01\x80`\xD0\x1B\x03a\x12\xA4V[\x90V[\x90V[\x90V[\x91a\x139a\x133a\x13@\x94\x80a\x13\x07a\x13\x01a\x12\xFC_a\x02\xFAV[a\0\xFCV[\x91a\0\xFCV[\x14a\x13qW[\x84a\x13(a\x13\"a\x13\x1D_a\x02\xFAV[a\0\xFCV[\x91a\0\xFCV[\x14a\x13BW[a\x15iV[\x92a\x15iV[\x90\x91a\x15\x9EV[V[a\x13j`\x0B`\x02a\x13da\x13^a\x13X\x89a\x14SV[\x93a\x12\xDBV[\x91a\x12\xDEV[\x90a\x14\xA6V[PPa\x13.V[a\x13\x99`\x0B`\x01a\x13\x93a\x13\x8Da\x13\x87\x89a\x14SV[\x93a\x12\xDBV[\x91a\x12\xDEV[\x90a\x14\xA6V[PPa\x13\rV[_\x90V[a\x13\xB0a\x13\xB6\x91a\x12\x99V[\x91a\x12\x99V[\x01\x90`\x01\x80`\xD0\x1B\x03\x82\x11a\x13\xC7WV[a\x03<V[\x90a\x13\xDF\x91a\x13\xD9a\x13\xA0V[Pa\x13\xA4V[\x90V[\x90V[`\xFF\x16\x90V[a\x13\xFFa\x13\xFAa\x14\x04\x92a\x13\xE2V[a\x02\xDBV[a\x13\xE5V[\x90V[a\x14\x10\x90a\x13\xEBV[\x90RV[\x91` a\x145\x92\x94\x93a\x14.`@\x82\x01\x96_\x83\x01\x90a\x14\x07V[\x01\x90a\x0B\xF7V[V[a\x14Ka\x14Fa\x14P\x92a\x03\x0EV[a\x02\xDBV[a\x12\x99V[\x90V[a\x14[a\x13\xA0V[P\x80a\x14ua\x14o`\x01\x80`\xD0\x1B\x03a\x12\xA4V[\x91a\x03\x0EV[\x11a\x14\x86Wa\x14\x83\x90a\x147V[\x90V[`\xD0a\x14\xA2_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01a\x14\x14V[\x03\x90\xFD[\x90a\x14\xDCa\x14\xE2\x93\x92a\x14\xB7a\x13\xA0V[Pa\x14\xC0a\x13\xA0V[P\x80\x93a\x14\xD5a\x14\xCEa\x17PV[\x94\x92a\x17\xFDV[\x90\x91a\x1C\xE3V[\x91a\x18rV[\x91\x90\x91\x90V[a\x14\xF4a\x14\xFA\x91a\x12\x99V[\x91a\x12\x99V[\x90\x03\x90`\x01\x80`\xD0\x1B\x03\x82\x11a\x15\x0CWV[a\x03<V[\x90a\x15$\x91a\x15\x1Ea\x13\xA0V[Pa\x14\xE8V[\x90V[\x90a\x151\x90a\tjV[_R` R`@_ \x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x15Ta\x15Y\x91a\x0C\xC2V[a\x15=V[\x90V[a\x15f\x90Ta\x15HV[\x90V[a\x15\x80a\x15\x85\x91a\x15xa\r\x18V[P`\ta\x15'V[a\x15\\V[\x90V[\x90a\x15\x92\x90a\tjV[_R` R`@_ \x90V[\x91\x90\x91\x80a\x15\xB4a\x15\xAE\x85a\0\xFCV[\x91a\0\xFCV[\x14\x15\x80a\x172W[a\x15\xC6W[PPPV[\x80a\x15\xE1a\x15\xDBa\x15\xD6_a\x02\xFAV[a\0\xFCV[\x91a\0\xFCV[\x03a\x16\xA2W[P\x81a\x16\x03a\x15\xFDa\x15\xF8_a\x02\xFAV[a\0\xFCV[\x91a\0\xFCV[\x03a\x16\x0FW[\x80a\x15\xC1V[a\x16Va\x16Ia\x16P\x92a\x16%`\n\x86\x90a\x15\x88V[\x90a\x16Ca\x16=a\x167`\x01\x93a\x14SV[\x93a\x12\xDBV[\x91a\x12\xDEV[\x90a\x14\xA6V[\x92\x90a\x12\xA4V[\x91a\x12\xA4V[\x91\x90\x91a\x16\x83\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\tjV[\x92a\x16\x98a\x16\x8Fa\0\x89V[\x92\x83\x92\x83a\x0F\xE8V[\x03\x90\xA2_\x80a\x16\tV[a\x16\xE1a\x16\xE7a\x16\xDAa\x16\xB7`\n\x85\x90a\x15\x88V[`\x02a\x16\xD4a\x16\xCEa\x16\xC8\x89a\x14SV[\x93a\x12\xDBV[\x91a\x12\xDEV[\x90a\x14\xA6V[\x92\x90a\x12\xA4V[\x91a\x12\xA4V[\x91\x90\x91a\x17\x14\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\tjV[\x92a\x17)a\x17 a\0\x89V[\x92\x83\x92\x83a\x0F\xE8V[\x03\x90\xA2_a\x15\xE7V[P\x81a\x17Fa\x17@_a\x03uV[\x91a\x03\x0EV[\x11a\x15\xBCV[_\x90V[a\x17Xa\x17LV[Pa\x17aa\x18\xA1V[\x90V[T\x90V[\x90V[a\x17\x7Fa\x17za\x17\x84\x92a\x17hV[a\x02\xDBV[a\x03\x0EV[\x90V[a\x17\x96a\x17\x9C\x91\x93\x92\x93a\x03\x0EV[\x92a\x03\x0EV[\x82\x03\x91\x82\x11a\x17\xA7WV[a\x03<V[\x90V[`0\x1C\x90V[`\x01\x80`\xD0\x1B\x03\x16\x90V[a\x17\xCCa\x17\xD1\x91a\x17\xAFV[a\x17\xB5V[\x90V[a\x17\xDE\x90Ta\x17\xC0V[\x90V[a\x17\xF5a\x17\xF0a\x17\xFA\x92a\x02\xD8V[a\x02\xDBV[a\x12\x99V[\x90V[a\x18\x05a\x13\xA0V[Pa\x18\x11_\x82\x01a\x17dV[\x80a\x18$a\x18\x1E_a\x03uV[\x91a\x03\x0EV[\x14_\x14a\x18:WPPa\x186_a\x17\xE1V[[\x90V[a\x18g_\x91a\x18ba\x18\\\x84a\x18m\x96\x01\x92a\x18V`\x01a\x17kV[\x90a\x17\x87V[\x91a\x17\xACV[a\x18\xB6V[\x01a\x17\xD4V[a\x187V[\x91a\x18\x96_a\x18\x9B\x94a\x18\x83a\x13\xA0V[Pa\x18\x8Ca\x13\xA0V[P\x01\x92\x91\x92a\x17\xACV[a\x1A\xBBV[\x91\x90\x91\x90V[a\x18\xA9a\x17LV[Pa\x18\xB3Ca\x1C|V[\x90V[_R` _ \x01\x90V[T\x90V[a\x18\xCE`@a\0\xD8V[\x90V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[\x90a\x18\xE6\x90a\x18\xD1V[\x90RV[\x90a\x18\xF4\x90a\x12\x99V[\x90RV[_R` _ \x90V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[a\x19\x1E\x81a\x18\xC0V[\x82\x10\x15a\x198Wa\x190`\x01\x91a\x18\xF8V[\x91\x02\x01\x90_\x90V[a\x19\x01V[a\x19G\x90Qa\x18\xD1V[\x90V[\x90a\x19[e\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x03\x91V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x19ya\x19ta\x19~\x92a\x18\xD1V[a\x02\xDBV[a\x18\xD1V[\x90V[\x90V[\x90a\x19\x99a\x19\x94a\x19\xA0\x92a\x19eV[a\x19\x81V[\x82Ta\x19JV[\x90UV[a\x19\xAE\x90Qa\x12\x99V[\x90V[`0\x1B\x90V[\x90a\x19\xC9e\xFF\xFF\xFF\xFF\xFF\xFF\x19\x91a\x19\xB1V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x19\xE7a\x19\xE2a\x19\xEC\x92a\x12\x99V[a\x02\xDBV[a\x12\x99V[\x90V[\x90V[\x90a\x1A\x07a\x1A\x02a\x1A\x0E\x92a\x19\xD3V[a\x19\xEFV[\x82Ta\x19\xB7V[\x90UV[\x90a\x1A<` _a\x1AB\x94a\x1A4\x82\x82\x01a\x1A.\x84\x88\x01a\x19=V[\x90a\x19\x84V[\x01\x92\x01a\x19\xA4V[\x90a\x19\xF2V[V[\x91\x90a\x1AUWa\x1AS\x91a\x1A\x12V[V[a\x06\xE2V[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15a\x1A\x8AW\x82a\x1A\x82\x91`\x01a\x1A\x88\x95\x01\x81Ua\x19\x15V[\x90a\x1ADV[V[a\0\x9DV[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x1A\xA6a\x1A\xAB\x91a\x0C\xC2V[a\x1A\x8FV[\x90V[a\x1A\xB8\x90Ta\x1A\x9AV[\x90V[\x90\x92\x91\x92a\x1A\xC7a\x13\xA0V[Pa\x1A\xD0a\x13\xA0V[Pa\x1A\xDA\x82a\x18\xC0V[\x80a\x1A\xEDa\x1A\xE7_a\x03uV[\x91a\x03\x0EV[\x11_\x14a\x1B\xBDWa\x1B\x13\x90a\x1B\r\x84\x91a\x1B\x07`\x01a\x17kV[\x90a\x17\x87V[\x90a\x18\xB6V[\x90a\x1B\x1F_\x83\x01a\x1A\xAEV[\x92a\x1B+_\x84\x01a\x17\xD4V[\x93\x80a\x1B?a\x1B9\x85a\x18\xD1V[\x91a\x18\xD1V[\x11a\x1B\xA1Wa\x1BVa\x1BP\x84a\x18\xD1V[\x91a\x18\xD1V[\x14_\x14a\x1BqWPPa\x1Bl\x90_\x85\x91\x01a\x19\xF2V[[\x91\x90V[a\x1B\x9C\x92Pa\x1B\x97\x86a\x1B\x8Ea\x1B\x85a\x18\xC4V[\x94_\x86\x01a\x18\xDCV[` \x84\x01a\x18\xEAV[a\x1AZV[a\x1BmV[_c% `\x1D`\xE0\x1B\x81R\x80a\x1B\xB9`\x04\x82\x01a\x03\x06V[\x03\x90\xFD[Pa\x1B\xE8\x91a\x1B\xE3\x85a\x1B\xDAa\x1B\xD1a\x18\xC4V[\x94_\x86\x01a\x18\xDCV[` \x84\x01a\x18\xEAV[a\x1AZV[a\x1B\xF1_a\x17\xE1V[\x91\x90V[a\x1C\ta\x1C\x04a\x1C\x0E\x92a\x18\xD1V[a\x02\xDBV[a\x03\x0EV[\x90V[\x90V[a\x1C(a\x1C#a\x1C-\x92a\x1C\x11V[a\x02\xDBV[a\x13\xE5V[\x90V[a\x1C9\x90a\x1C\x14V[\x90RV[\x91` a\x1C^\x92\x94\x93a\x1CW`@\x82\x01\x96_\x83\x01\x90a\x1C0V[\x01\x90a\x0B\xF7V[V[a\x1Cta\x1Coa\x1Cy\x92a\x03\x0EV[a\x02\xDBV[a\x18\xD1V[\x90V[a\x1C\x84a\x17LV[P\x80a\x1C\x9Ea\x1C\x98e\xFF\xFF\xFF\xFF\xFF\xFFa\x1B\xF5V[\x91a\x03\x0EV[\x11a\x1C\xAFWa\x1C\xAC\x90a\x1C`V[\x90V[`0a\x1C\xCB_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01a\x1C=V[\x03\x90\xFD[cNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[\x91\x90\x91\x80`\x01\x14a\x1D\x02W`\x02\x03a\x1C\xCFWa\x1C\xFE\x91a\x15\x11V[\x90[V[Pa\x1D\x0C\x91a\x13\xCCV[\x90a\x1D\0V\xFE`\x80`@R`\x046\x10\x15a\0\x13W[a\x1D\xC8V[a\0\x1D_5a\x04LV[\x80c\x01\x04-z\x14a\x04GW\x80c\x01\xFF\xC9\xA7\x14a\x04BW\x80c\x04\xDF\x01}\x14a\x04=W\x80c\x05\x072\xFB\x14a\x048W\x80c\x06\xFD\xDE\x03\x14a\x043W\x80c\t^\xA7\xB3\x14a\x04.W\x80c\x18\x16\r\xDD\x14a\x04)W\x80c\x18\xBFPw\x14a\x04$W\x80c#\xB8r\xDD\x14a\x04\x1FW\x80c$\x8A\x9C\xA3\x14a\x04\x1AW\x80c(i6k\x14a\x04\x15W\x80c+\x8CI\xE3\x14a\x04\x10W\x80c//\xF1]\x14a\x04\x0BW\x80c0\xD3\xE8\xEB\x14a\x04\x06W\x80c1<\xE5g\x14a\x04\x01W\x80c6D\xE5\x15\x14a\x03\xFCW\x80c6V\x8A\xBE\x14a\x03\xF7W\x80c:F\xB1\xA8\x14a\x03\xF2W\x80c@\xC1\x0F\x19\x14a\x03\xEDW\x80cBz\xC0\xCA\x14a\x03\xE8W\x80cB\x96lh\x14a\x03\xE3W\x80cK\xDD6\xCE\x14a\x03\xDEW\x80cK\xF5\xD7\xE9\x14a\x03\xD9W\x80cO\x1B\xFC\x9E\x14a\x03\xD4W\x80cX|\xDE\x1E\x14a\x03\xCFW\x80cZB9\xE9\x14a\x03\xCAW\x80cZ]\xB1\xBB\x14a\x03\xC5W\x80c\\\x19\xA9\\\x14a\x03\xC0W\x80c]Lb\x85\x14a\x03\xBBW\x80cc\xA0\xDA\xAC\x14a\x03\xB6W\x80ce\x14U4\x14a\x03\xB1W\x80co\xCF\xFFE\x14a\x03\xACW\x80cp\xA0\x821\x14a\x03\xA7W\x80cr\xCB\xDC\xC8\x14a\x03\xA2W\x80cx\xFB\x7F\xD2\x14a\x03\x9DW\x80cy\xCCg\x90\x14a\x03\x98W\x80cz\x8C\xD1V\x14a\x03\x93W\x80c~\xCE\xBE\0\x14a\x03\x8EW\x80c\x83\xF1!\x1B\x14a\x03\x89W\x80c\x84&\xAD\xF2\x14a\x03\x84W\x80c\x84L\x90&\x14a\x03\x7FW\x80c\x84\xB0\x19n\x14a\x03zW\x80c\x8AT%!\x14a\x03uW\x80c\x8D3C\xD6\x14a\x03pW\x80c\x8ES\x9E\x8C\x14a\x03kW\x80c\x90-U\xA5\x14a\x03fW\x80c\x91\xD1HT\x14a\x03aW\x80c\x91\xDD\xAD\xF4\x14a\x03\\W\x80c\x94\xAA\"\xF2\x14a\x03WW\x80c\x95\xD8\x9BA\x14a\x03RW\x80c\x9A\xB2N\xB0\x14a\x03MW\x80c\x9B~\xF6K\x14a\x03HW\x80c\xA2\x17\xFD\xDF\x14a\x03CW\x80c\xA9\x05\x9C\xBB\x14a\x03>W\x80c\xAA\x08*\x9D\x14a\x039W\x80c\xB0\xCA%>\x14a\x034W\x80c\xB7\xCD\xC6\x1C\x14a\x03/W\x80c\xBBMD6\x14a\x03*W\x80c\xC0*\xE7T\x14a\x03%W\x80c\xC3\xCD\xA5 \x14a\x03 W\x80c\xC4\xFCE\xA8\x14a\x03\x1BW\x80c\xC9\xAB\0\x06\x14a\x03\x16W\x80c\xD5\x05\xAC\xCF\x14a\x03\x11W\x80c\xD5Gt\x1F\x14a\x03\x0CW\x80c\xDDb\xED>\x14a\x03\x07W\x80c\xF1\x12~\xD8\x14a\x03\x02Wc\xF7^\x85\x12\x03a\0\x0EWa\x1D\x93V[a\x1D.V[a\x1CJV[a\x1B\xE9V[a\x1B\xAFV[a\x1B\x0BV[a\x1A\x86V[a\x19\xF4V[a\x198V[a\x19\x03V[a\x18\xCEV[a\x18iV[a\x184V[a\x17\xEFV[a\x17\xBAV[a\x17JV[a\x16\xD3V[a\x16\x9EV[a\x16iV[a\x164V[a\x15\xD1V[a\x15\x9CV[a\x15%V[a\x14\xF0V[a\x14\x8CV[a\x14!V[a\x12\xDCV[a\x12\xA7V[a\x12NV[a\x12\x19V[a\x11\xE4V[a\x11\xB0V[a\x11{V[a\x11FV[a\x10rV[a\x10=V[a\x0F\xDDV[a\x0F\xA9V[a\x0F9V[a\x0E\xE5V[a\x0E\xB0V[a\x0E|V[a\x0EGV[a\r\xF0V[a\r\x82V[a\rMV[a\r\x1AV[a\x0C\xC4V[a\x0B\xC9V[a\x0B\x93V[a\x0B_V[a\x0B*V[a\n\xF5V[a\n\x98V[a\ndV[a\n\x03V[a\t\xCEV[a\tjV[a\x08\xCEV[a\x08`V[a\x08+V[a\x07\xF5V[a\x07\xC0V[a\x07\x11V[a\x06\xDEV[a\x06\x86V[a\x05\xDCV[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x04t\x90a\x04`V[\x90V[a\x04\x80\x81a\x04kV[\x03a\x04\x87WV[_\x80\xFD[\x90P5\x90a\x04\x98\x82a\x04wV[V[\x90V[a\x04\xA6\x81a\x04\x9AV[\x03a\x04\xADWV[_\x80\xFD[\x90P5\x90a\x04\xBE\x82a\x04\x9DV[V[\x91\x90`@\x83\x82\x03\x12a\x04\xE8W\x80a\x04\xDCa\x04\xE5\x92_\x86\x01a\x04\x8BV[\x93` \x01a\x04\xB1V[\x90V[a\x04\\V[\x90V[a\x05\x04a\x04\xFFa\x05\t\x92a\x04`V[a\x04\xEDV[a\x04`V[\x90V[a\x05\x15\x90a\x04\xF0V[\x90V[a\x05!\x90a\x05\x0CV[\x90V[\x90a\x05.\x90a\x05\x18V[_R` R`@_ \x90V[a\x05Na\x05Ia\x05S\x92a\x04\x9AV[a\x04\xEDV[a\x04\x9AV[\x90V[\x90a\x05`\x90a\x05:V[_R` R`@_ \x90V[\x1C\x90V[\x90V[a\x05\x83\x90`\x08a\x05\x88\x93\x02a\x05lV[a\x05pV[\x90V[\x90a\x05\x96\x91Ta\x05sV[\x90V[a\x05\xB2a\x05\xB7\x92a\x05\xAD`\x11\x93_\x94a\x05$V[a\x05VV[a\x05\x8BV[\x90V[a\x05\xC3\x90a\x04\x9AV[\x90RV[\x91\x90a\x05\xDA\x90_` \x85\x01\x94\x01\x90a\x05\xBAV[V[4a\x06\rWa\x06\ta\x05\xF8a\x05\xF26`\x04a\x04\xC0V[\x90a\x05\x99V[a\x06\0a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[c\xFF\xFF\xFF\xFF`\xE0\x1B\x16\x90V[a\x06'\x81a\x06\x12V[\x03a\x06.WV[_\x80\xFD[\x90P5\x90a\x06?\x82a\x06\x1EV[V[\x90` \x82\x82\x03\x12a\x06ZWa\x06W\x91_\x01a\x062V[\x90V[a\x04\\V[\x15\x15\x90V[a\x06m\x90a\x06_V[\x90RV[\x91\x90a\x06\x84\x90_` \x85\x01\x94\x01\x90a\x06dV[V[4a\x06\xB6Wa\x06\xB2a\x06\xA1a\x06\x9C6`\x04a\x06AV[a\x1EeV[a\x06\xA9a\x04RV[\x91\x82\x91\x82a\x06qV[\x03\x90\xF3[a\x04XV[\x90` \x82\x82\x03\x12a\x06\xD4Wa\x06\xD1\x91_\x01a\x04\x8BV[\x90V[a\x04\\V[_\x01\x90V[4a\x07\x0CWa\x06\xF6a\x06\xF16`\x04a\x06\xBBV[a \x97V[a\x06\xFEa\x04RV[\x80a\x07\x08\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[4a\x07AWa\x07=a\x07,a\x07'6`\x04a\x06\xBBV[a \xA2V[a\x074a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[_\x91\x03\x12a\x07PWV[a\x04\\V[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[`\x1F\x80\x19\x91\x01\x16\x90V[a\x07\x96a\x07\x9F` \x93a\x07\xA4\x93a\x07\x8D\x81a\x07UV[\x93\x84\x80\x93a\x07YV[\x95\x86\x91\x01a\x07bV[a\x07mV[\x01\x90V[a\x07\xBD\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x07wV[\x90V[4a\x07\xF0Wa\x07\xD06`\x04a\x07FV[a\x07\xECa\x07\xDBa\"\x1AV[a\x07\xE3a\x04RV[\x91\x82\x91\x82a\x07\xA8V[\x03\x90\xF3[a\x04XV[4a\x08&Wa\x08\"a\x08\x11a\x08\x0B6`\x04a\x04\xC0V[\x90a\"0V[a\x08\x19a\x04RV[\x91\x82\x91\x82a\x06qV[\x03\x90\xF3[a\x04XV[4a\x08[Wa\x08;6`\x04a\x07FV[a\x08Wa\x08Fa\"RV[a\x08Na\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[4a\x08\x8FWa\x08ya\x08s6`\x04a\x04\xC0V[\x90a\"\xA9V[a\x08\x81a\x04RV[\x80a\x08\x8B\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[\x90\x91``\x82\x84\x03\x12a\x08\xC9Wa\x08\xC6a\x08\xAF\x84_\x85\x01a\x04\x8BV[\x93a\x08\xBD\x81` \x86\x01a\x04\x8BV[\x93`@\x01a\x04\xB1V[\x90V[a\x04\\V[4a\x08\xFFWa\x08\xFBa\x08\xEAa\x08\xE46`\x04a\x08\x94V[\x91a$$V[a\x08\xF2a\x04RV[\x91\x82\x91\x82a\x06qV[\x03\x90\xF3[a\x04XV[\x90V[a\t\x10\x81a\t\x04V[\x03a\t\x17WV[_\x80\xFD[\x90P5\x90a\t(\x82a\t\x07V[V[\x90` \x82\x82\x03\x12a\tCWa\t@\x91_\x01a\t\x1BV[\x90V[a\x04\\V[a\tQ\x90a\t\x04V[\x90RV[\x91\x90a\th\x90_` \x85\x01\x94\x01\x90a\tHV[V[4a\t\x9AWa\t\x96a\t\x85a\t\x806`\x04a\t*V[a$\x9DV[a\t\x8Da\x04RV[\x91\x82\x91\x82a\tUV[\x03\x90\xF3[a\x04XV[\x90a\t\xA9\x90a\x05\x18V[_R` R`@_ \x90V[a\t\xCB\x90a\t\xC6`\x10\x91_\x92a\t\x9FV[a\x05\x8BV[\x90V[4a\t\xFEWa\t\xFAa\t\xE9a\t\xE46`\x04a\x06\xBBV[a\t\xB5V[a\t\xF1a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[4a\n2Wa\n\x1Ca\n\x166`\x04a\x04\xC0V[\x90a$\xBFV[a\n$a\x04RV[\x80a\n.\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[\x91\x90`@\x83\x82\x03\x12a\n_W\x80a\nSa\n\\\x92_\x86\x01a\t\x1BV[\x93` \x01a\x04\x8BV[\x90V[a\x04\\V[4a\n\x93Wa\n}a\nw6`\x04a\n7V[\x90a&\x10V[a\n\x85a\x04RV[\x80a\n\x8F\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[4a\n\xC8Wa\n\xC4a\n\xB3a\n\xAE6`\x04a\x06\xBBV[a'lV[a\n\xBBa\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[`\xFF\x16\x90V[a\n\xDC\x90a\n\xCDV[\x90RV[\x91\x90a\n\xF3\x90_` \x85\x01\x94\x01\x90a\n\xD3V[V[4a\x0B%Wa\x0B\x056`\x04a\x07FV[a\x0B!a\x0B\x10a(\xA7V[a\x0B\x18a\x04RV[\x91\x82\x91\x82a\n\xE0V[\x03\x90\xF3[a\x04XV[4a\x0BZWa\x0B:6`\x04a\x07FV[a\x0BVa\x0BEa(\xBDV[a\x0BMa\x04RV[\x91\x82\x91\x82a\tUV[\x03\x90\xF3[a\x04XV[4a\x0B\x8EWa\x0Bxa\x0Br6`\x04a\n7V[\x90a(\xD1V[a\x0B\x80a\x04RV[\x80a\x0B\x8A\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[4a\x0B\xC4Wa\x0B\xC0a\x0B\xAFa\x0B\xA96`\x04a\x04\xC0V[\x90a)NV[a\x0B\xB7a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[4a\x0B\xF8Wa\x0B\xE2a\x0B\xDC6`\x04a\x04\xC0V[\x90a*lV[a\x0B\xEAa\x04RV[\x80a\x0B\xF4\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[\x90a\x0C\x07\x90a\x05\x18V[_R` R`@_ \x90V[_\x1C\x90V[a\x0C$a\x0C)\x91a\x0C\x13V[a\x05pV[\x90V[a\x0C6\x90Ta\x0C\x18V[\x90V[`\xFF\x16\x90V[a\x0CKa\x0CP\x91a\x0C\x13V[a\x0C9V[\x90V[a\x0C]\x90Ta\x0C?V[\x90V[a\x0Ck\x90`\ra\x0B\xFDV[a\x0Cv_\x82\x01a\x0C,V[\x91a\x0C\x8F`\x02a\x0C\x88`\x01\x85\x01a\x0C,V[\x93\x01a\x0CSV[\x90V[`@\x90a\x0C\xBBa\x0C\xC2\x94\x96\x95\x93\x96a\x0C\xB1``\x84\x01\x98_\x85\x01\x90a\x05\xBAV[` \x83\x01\x90a\x05\xBAV[\x01\x90a\x06dV[V[4a\x0C\xF7Wa\x0C\xF3a\x0C\xDFa\x0C\xDA6`\x04a\x06\xBBV[a\x0C`V[a\x0C\xEA\x93\x91\x93a\x04RV[\x93\x84\x93\x84a\x0C\x92V[\x03\x90\xF3[a\x04XV[\x90` \x82\x82\x03\x12a\r\x15Wa\r\x12\x91_\x01a\x04\xB1V[\x90V[a\x04\\V[4a\rHWa\r2a\r-6`\x04a\x0C\xFCV[a*xV[a\r:a\x04RV[\x80a\rD\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[4a\r}Wa\r]6`\x04a\x07FV[a\rya\rha*\xB8V[a\rpa\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[4a\r\xB2Wa\r\x926`\x04a\x07FV[a\r\xAEa\r\x9Da+bV[a\r\xA5a\x04RV[\x91\x82\x91\x82a\x07\xA8V[\x03\x90\xF3[a\x04XV[\x90V[a\r\xCEa\r\xC9a\r\xD3\x92a\r\xB7V[a\x04\xEDV[a\x04\x9AV[\x90V[a\r\xE2bv\xA7\0a\r\xBAV[\x90V[a\r\xEDa\r\xD6V[\x90V[4a\x0E Wa\x0E\x006`\x04a\x07FV[a\x0E\x1Ca\x0E\x0Ba\r\xE5V[a\x0E\x13a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[a\x0E.\x90a\x04kV[\x90RV[\x91\x90a\x0EE\x90_` \x85\x01\x94\x01\x90a\x0E%V[V[4a\x0EwWa\x0Esa\x0Eba\x0E]6`\x04a\x06\xBBV[a+\xFEV[a\x0Eja\x04RV[\x91\x82\x91\x82a\x0E2V[\x03\x90\xF3[a\x04XV[4a\x0E\xABWa\x0E\x95a\x0E\x8F6`\x04a\x04\xC0V[\x90a-\x8BV[a\x0E\x9Da\x04RV[\x80a\x0E\xA7\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[4a\x0E\xE0Wa\x0E\xDCa\x0E\xCBa\x0E\xC66`\x04a\x0C\xFCV[a.?V[a\x0E\xD3a\x04RV[\x91\x82\x91\x82a\x0E2V[\x03\x90\xF3[a\x04XV[4a\x0F\x13Wa\x0E\xFDa\x0E\xF86`\x04a\x06\xBBV[a.\x8BV[a\x0F\x05a\x04RV[\x80a\x0F\x0F\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[a\x0F1a\x0F6\x92a\x0F,`\x12\x93_\x94a\x05$V[a\x05VV[a\x05\x8BV[\x90V[4a\x0FjWa\x0Ffa\x0FUa\x0FO6`\x04a\x04\xC0V[\x90a\x0F\x18V[a\x0F]a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[\x90\x91``\x82\x84\x03\x12a\x0F\xA4Wa\x0F\xA1a\x0F\x8A\x84_\x85\x01a\x04\x8BV[\x93a\x0F\x98\x81` \x86\x01a\x04\xB1V[\x93`@\x01a\x04\xB1V[\x90V[a\x04\\V[4a\x0F\xD8Wa\x0F\xC2a\x0F\xBC6`\x04a\x0FoV[\x91a1\xE2V[a\x0F\xCAa\x04RV[\x80a\x0F\xD4\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[4a\x10\rWa\x0F\xED6`\x04a\x07FV[a\x10\ta\x0F\xF8a1\xEFV[a\x10\0a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[c\xFF\xFF\xFF\xFF\x16\x90V[a\x10$\x90a\x10\x12V[\x90RV[\x91\x90a\x10;\x90_` \x85\x01\x94\x01\x90a\x10\x1BV[V[4a\x10mWa\x10ia\x10Xa\x10S6`\x04a\x06\xBBV[a2\x11V[a\x10`a\x04RV[\x91\x82\x91\x82a\x10(V[\x03\x90\xF3[a\x04XV[4a\x10\xA2Wa\x10\x9Ea\x10\x8Da\x10\x886`\x04a\x06\xBBV[a2&V[a\x10\x95a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[Q\x90V[` \x91\x81R\x01\x90V[` \x01\x90V[a\x10\xC3\x90a\x04kV[\x90RV[\x90a\x10\xD4\x81` \x93a\x10\xBAV[\x01\x90V[` \x01\x90V[\x90a\x10\xFBa\x10\xF5a\x10\xEE\x84a\x10\xA7V[\x80\x93a\x10\xABV[\x92a\x10\xB4V[\x90_[\x81\x81\x10a\x11\x0BWPPP\x90V[\x90\x91\x92a\x11$a\x11\x1E`\x01\x92\x86Qa\x10\xC7V[\x94a\x10\xD8V[\x91\x01\x91\x90\x91a\x10\xFEV[a\x11C\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x10\xDEV[\x90V[4a\x11vWa\x11V6`\x04a\x07FV[a\x11ra\x11aa2IV[a\x11ia\x04RV[\x91\x82\x91\x82a\x11.V[\x03\x90\xF3[a\x04XV[4a\x11\xABWa\x11\xA7a\x11\x96a\x11\x916`\x04a\x06\xBBV[a2gV[a\x11\x9Ea\x04RV[\x91\x82\x91\x82a\x06qV[\x03\x90\xF3[a\x04XV[4a\x11\xDFWa\x11\xC9a\x11\xC36`\x04a\x04\xC0V[\x90a3\xCCV[a\x11\xD1a\x04RV[\x80a\x11\xDB\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[4a\x12\x14Wa\x11\xF46`\x04a\x07FV[a\x12\x10a\x11\xFFa3\xD8V[a\x12\x07a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[4a\x12IWa\x12Ea\x124a\x12/6`\x04a\x06\xBBV[a4PV[a\x12<a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[4a\x12~Wa\x12^6`\x04a\x07FV[a\x12za\x12ia4eV[a\x12qa\x04RV[\x91\x82\x91\x82a\x06qV[\x03\x90\xF3[a\x04XV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[4a\x12\xD7Wa\x12\xB76`\x04a\x07FV[a\x12\xD3a\x12\xC2a\x12\x83V[a\x12\xCAa\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[4a\x13\nWa\x12\xF4a\x12\xEF6`\x04a\x0C\xFCV[a5\xB8V[a\x12\xFCa\x04RV[\x80a\x13\x06\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[`\xFF`\xF8\x1B\x16\x90V[a\x13!\x90a\x13\x0FV[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[` \x01\x90V[a\x13A\x90a\x04\x9AV[\x90RV[\x90a\x13R\x81` \x93a\x138V[\x01\x90V[` \x01\x90V[\x90a\x13ya\x13sa\x13l\x84a\x13%V[\x80\x93a\x13)V[\x92a\x132V[\x90_[\x81\x81\x10a\x13\x89WPPP\x90V[\x90\x91\x92a\x13\xA2a\x13\x9C`\x01\x92\x86Qa\x13EV[\x94a\x13VV[\x91\x01\x91\x90\x91a\x13|V[\x93\x95\x91\x94a\x13\xFDa\x13\xF2a\x14\x11\x95a\x13\xE4a\x14\x07\x95a\x14\x1E\x9C\x9Aa\x13\xD7`\xE0\x8C\x01\x92_\x8D\x01\x90a\x13\x18V[\x8A\x82\x03` \x8C\x01Ra\x07wV[\x90\x88\x82\x03`@\x8A\x01Ra\x07wV[\x97``\x87\x01\x90a\x05\xBAV[`\x80\x85\x01\x90a\x0E%V[`\xA0\x83\x01\x90a\tHV[`\xC0\x81\x84\x03\x91\x01Ra\x13\\V[\x90V[4a\x14XWa\x1416`\x04a\x07FV[a\x14Ta\x14<a6@V[\x93a\x14K\x97\x95\x97\x93\x91\x93a\x04RV[\x97\x88\x97\x88a\x13\xACV[\x03\x90\xF3[a\x04XV[\x7F\x84\xFEt\xC7\x1A(\xB6\x9A\xA9`Hl\xA0\xE8\xC1A\x8C\x86\xE9\xEA,\xD6\xB5\x84\x9B\x95\xE2\xC8\xF4\x07\xA6t\x90V[a\x14\x89a\x14]V[\x90V[4a\x14\xBCWa\x14\x9C6`\x04a\x07FV[a\x14\xB8a\x14\xA7a\x14\x81V[a\x14\xAFa\x04RV[\x91\x82\x91\x82a\tUV[\x03\x90\xF3[a\x04XV[\x7F\x9B\x12\xE0\xC5p~II\x15\xE5\x8B\x05d\xF1\x8A\xAA\xD9\xB7J\xC6\x9B\xFC\x81Z\x1E\xDA\xDC\x8EK\xD02\xEB\x90V[a\x14\xEDa\x14\xC1V[\x90V[4a\x15 Wa\x15\x006`\x04a\x07FV[a\x15\x1Ca\x15\x0Ba\x14\xE5V[a\x15\x13a\x04RV[\x91\x82\x91\x82a\tUV[\x03\x90\xF3[a\x04XV[4a\x15UWa\x15Qa\x15@a\x15;6`\x04a\x0C\xFCV[a6\xCAV[a\x15Ha\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[\x90V[a\x15qa\x15la\x15v\x92a\x15ZV[a\x04\xEDV[a\x04\x9AV[\x90V[a\x15\x8Ek\x03;.<\x9F\xD0\x80<\xE8\0\0\0a\x15]V[\x90V[a\x15\x99a\x15yV[\x90V[4a\x15\xCCWa\x15\xAC6`\x04a\x07FV[a\x15\xC8a\x15\xB7a\x15\x91V[a\x15\xBFa\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[4a\x16\x02Wa\x15\xFEa\x15\xEDa\x15\xE76`\x04a\n7V[\x90a7\x11V[a\x15\xF5a\x04RV[\x91\x82\x91\x82a\x06qV[\x03\x90\xF3[a\x04XV[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x16\x1B\x90a\x16\x07V[\x90RV[\x91\x90a\x162\x90_` \x85\x01\x94\x01\x90a\x16\x12V[V[4a\x16dWa\x16D6`\x04a\x07FV[a\x16`a\x16Oa7?V[a\x16Wa\x04RV[\x91\x82\x91\x82a\x16\x1FV[\x03\x90\xF3[a\x04XV[4a\x16\x99Wa\x16\x95a\x16\x84a\x16\x7F6`\x04a\x06\xBBV[a7SV[a\x16\x8Ca\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[4a\x16\xCEWa\x16\xAE6`\x04a\x07FV[a\x16\xCAa\x16\xB9a8iV[a\x16\xC1a\x04RV[\x91\x82\x91\x82a\x07\xA8V[\x03\x90\xF3[a\x04XV[4a\x17\x03Wa\x16\xFFa\x16\xEEa\x16\xE96`\x04a\x06\xBBV[a8\x7FV[a\x16\xF6a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[\x90V[a\x17\x1Fa\x17\x1Aa\x17$\x92a\x17\x08V[a\x04\xEDV[a\x04\x9AV[\x90V[a\x17<k\x02\xE8vi\xC3\x08sj\x04\0\0\0a\x17\x0BV[\x90V[a\x17Ga\x17'V[\x90V[4a\x17zWa\x17Z6`\x04a\x07FV[a\x17va\x17ea\x17?V[a\x17ma\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[\x90V[_\x1B\x90V[a\x17\x9Ba\x17\x96a\x17\xA0\x92a\x17\x7FV[a\x17\x82V[a\t\x04V[\x90V[a\x17\xAC_a\x17\x87V[\x90V[a\x17\xB7a\x17\xA3V[\x90V[4a\x17\xEAWa\x17\xCA6`\x04a\x07FV[a\x17\xE6a\x17\xD5a\x17\xAFV[a\x17\xDDa\x04RV[\x91\x82\x91\x82a\tUV[\x03\x90\xF3[a\x04XV[4a\x18 Wa\x18\x1Ca\x18\x0Ba\x18\x056`\x04a\x04\xC0V[\x90a8\xAEV[a\x18\x13a\x04RV[\x91\x82\x91\x82a\x06qV[\x03\x90\xF3[a\x04XV[a\x181`\x0C_\x90a\x05\x8BV[\x90V[4a\x18dWa\x18D6`\x04a\x07FV[a\x18`a\x18Oa\x18%V[a\x18Wa\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[4a\x18\x9AWa\x18\x96a\x18\x85a\x18\x7F6`\x04a\x04\xC0V[\x90a8\xD0V[a\x18\x8Da\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[\x7F\x82\x03r\xA9\xFA\xF8-\xB3\xCC_\xC3o\xFA\xB5\xF0\x96\xEE\xF6\x9B\x95\xFB\xF5\x05\x91\xE0\xD7\x14G\xAA\x1B\xA7\0\x90V[a\x18\xCBa\x18\x9FV[\x90V[4a\x18\xFEWa\x18\xDE6`\x04a\x07FV[a\x18\xFAa\x18\xE9a\x18\xC3V[a\x18\xF1a\x04RV[\x91\x82\x91\x82a\tUV[\x03\x90\xF3[a\x04XV[4a\x193Wa\x19/a\x19\x1Ea\x19\x196`\x04a\x06\xBBV[a8\xE6V[a\x19&a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[4a\x19hWa\x19H6`\x04a\x07FV[a\x19da\x19Sa8\xFBV[a\x19[a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[a\x19v\x81a\n\xCDV[\x03a\x19}WV[_\x80\xFD[\x90P5\x90a\x19\x8E\x82a\x19mV[V[\x90\x91`\xC0\x82\x84\x03\x12a\x19\xEFWa\x19\xA8\x83_\x84\x01a\x04\x8BV[\x92a\x19\xB6\x81` \x85\x01a\x04\xB1V[\x92a\x19\xC4\x82`@\x83\x01a\x04\xB1V[\x92a\x19\xECa\x19\xD5\x84``\x85\x01a\x19\x81V[\x93a\x19\xE3\x81`\x80\x86\x01a\t\x1BV[\x93`\xA0\x01a\t\x1BV[\x90V[a\x04\\V[4a\x1A)Wa\x1A\x13a\x1A\x076`\x04a\x19\x90V[\x94\x93\x90\x93\x92\x91\x92a9{V[a\x1A\x1Ba\x04RV[\x80a\x1A%\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[a\x1A7\x90a\x06_V[\x90RV[\x90`@\x80a\x1Ao\x93a\x1AS_\x82\x01Q_\x86\x01\x90a\x138V[a\x1Ae` \x82\x01Q` \x86\x01\x90a\x138V[\x01Q\x91\x01\x90a\x1A.V[V[\x91\x90a\x1A\x84\x90_``\x85\x01\x94\x01\x90a\x1A;V[V[4a\x1A\xB6Wa\x1A\xB2a\x1A\xA1a\x1A\x9C6`\x04a\x06\xBBV[a:rV[a\x1A\xA9a\x04RV[\x91\x82\x91\x82a\x1AqV[\x03\x90\xF3[a\x04XV[a\x1A\xC4\x81a\x06_V[\x03a\x1A\xCBWV[_\x80\xFD[\x90P5\x90a\x1A\xDC\x82a\x1A\xBBV[V[\x91\x90`@\x83\x82\x03\x12a\x1B\x06W\x80a\x1A\xFAa\x1B\x03\x92_\x86\x01a\x04\x8BV[\x93` \x01a\x1A\xCFV[\x90V[a\x04\\V[4a\x1B:Wa\x1B$a\x1B\x1E6`\x04a\x1A\xDEV[\x90a;\x85V[a\x1B,a\x04RV[\x80a\x1B6\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[`\xE0\x81\x83\x03\x12a\x1B\xAAWa\x1BU\x82_\x83\x01a\x04\x8BV[\x92a\x1Bc\x83` \x84\x01a\x04\x8BV[\x92a\x1Bq\x81`@\x85\x01a\x04\xB1V[\x92a\x1B\x7F\x82``\x83\x01a\x04\xB1V[\x92a\x1B\xA7a\x1B\x90\x84`\x80\x85\x01a\x19\x81V[\x93a\x1B\x9E\x81`\xA0\x86\x01a\t\x1BV[\x93`\xC0\x01a\t\x1BV[\x90V[a\x04\\V[4a\x1B\xE4Wa\x1B\xCEa\x1B\xC26`\x04a\x1B?V[\x95\x94\x90\x94\x93\x91\x93a<3V[a\x1B\xD6a\x04RV[\x80a\x1B\xE0\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[4a\x1C\x18Wa\x1C\x02a\x1B\xFC6`\x04a\n7V[\x90a=QV[a\x1C\na\x04RV[\x80a\x1C\x14\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[\x91\x90`@\x83\x82\x03\x12a\x1CEW\x80a\x1C9a\x1CB\x92_\x86\x01a\x04\x8BV[\x93` \x01a\x04\x8BV[\x90V[a\x04\\V[4a\x1C{Wa\x1Cwa\x1Cfa\x1C`6`\x04a\x1C\x1DV[\x90a=sV[a\x1Cna\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[a\x1C\x89\x81a\x10\x12V[\x03a\x1C\x90WV[_\x80\xFD[\x90P5\x90a\x1C\xA1\x82a\x1C\x80V[V[\x91\x90`@\x83\x82\x03\x12a\x1C\xCBW\x80a\x1C\xBFa\x1C\xC8\x92_\x86\x01a\x04\x8BV[\x93` \x01a\x1C\x94V[\x90V[a\x04\\V[a\x1C\xD9\x90a\x16\x07V[\x90RV[`\x01\x80`\xD0\x1B\x03\x16\x90V[a\x1C\xF1\x90a\x1C\xDDV[\x90RV[\x90` \x80a\x1D\x17\x93a\x1D\r_\x82\x01Q_\x86\x01\x90a\x1C\xD0V[\x01Q\x91\x01\x90a\x1C\xE8V[V[\x91\x90a\x1D,\x90_`@\x85\x01\x94\x01\x90a\x1C\xF5V[V[4a\x1D_Wa\x1D[a\x1DJa\x1DD6`\x04a\x1C\xA3V[\x90a=\xE1V[a\x1DRa\x04RV[\x91\x82\x91\x82a\x1D\x19V[\x03\x90\xF3[a\x04XV[\x7F\xCC\xE2\x96\xB0@3*\x08\x0Em\xF15\x15\xA3\xEC(i\xE2\x1C\xD2\x0FsD\xAF\t\x87\xDD\xB98\xD8\xBD!\x90V[a\x1D\x90a\x1DdV[\x90V[4a\x1D\xC3Wa\x1D\xA36`\x04a\x07FV[a\x1D\xBFa\x1D\xAEa\x1D\x88V[a\x1D\xB6a\x04RV[\x91\x82\x91\x82a\tUV[\x03\x90\xF3[a\x04XV[_\x80\xFD[_\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\x1D\xF0a\x1D\xF6\x91a\x1C\xDDV[\x91a\x1C\xDDV[\x01\x90`\x01\x80`\xD0\x1B\x03\x82\x11a\x1E\x07WV[a\x1D\xD0V[\x90a\x1E\x1F\x91a\x1E\x19a\x1D\xCCV[Pa\x1D\xE4V[\x90V[a\x1E.a\x1E4\x91a\x1C\xDDV[\x91a\x1C\xDDV[\x90\x03\x90`\x01\x80`\xD0\x1B\x03\x82\x11a\x1EFWV[a\x1D\xD0V[\x90a\x1E^\x91a\x1EXa\x1D\xCCV[Pa\x1E\"V[\x90V[_\x90V[a\x1Ema\x1EaV[P\x80a\x1E\x88a\x1E\x82c\x0C\xCC\xC6e`\xE2\x1Ba\x06\x12V[\x91a\x06\x12V[\x14\x80\x15a\x1E\xACW[\x90\x81\x15a\x1E\x9CW[P\x90V[a\x1E\xA6\x91Pa=\xF7V[_a\x1E\x98V[P\x80a\x1E\xC7a\x1E\xC1c\xB2u*\xC9`\xE0\x1Ba\x06\x12V[\x91a\x06\x12V[\x14a\x1E\x90V[a\x1E\xE6\x90a\x1E\xE1a\x1E\xDCa\x1DdV[a>7V[a\x1F\xC4V[V[a\x1E\xFCa\x1E\xF7a\x1F\x01\x92a\x17\x7FV[a\x04\xEDV[a\x04`V[\x90V[a\x1F\r\x90a\x1E\xE8V[\x90V[\x90V[\x1B\x90V[\x91\x90`\x08a\x1F2\x91\x02\x91a\x1F,_\x19\x84a\x1F\x13V[\x92a\x1F\x13V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90V[\x91\x90a\x1FUa\x1FPa\x1F]\x93a\x05:V[a\x1F<V[\x90\x83Ta\x1F\x17V[\x90UV[_\x90V[a\x1Fw\x91a\x1Fqa\x1FaV[\x91a\x1F?V[V[`\x02_\x91a\x1F\x89\x83\x80\x83\x01a\x1FeV[a\x1F\x96\x83`\x01\x83\x01a\x1FeV[\x01UV[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[\x90_\x03a\x1F\xBFWa\x1F\xBD\x90a\x1FyV[V[a\x1F\x9AV[\x80a\x1F\xDFa\x1F\xD9a\x1F\xD4_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14a {Wa \x01a\x1F\xFBa\x1F\xF4`\x0Ea\x1F\x10V[\x83\x90a>\x92V[\x15a\x06_V[a \\Wa \x1A_a \x15`\r\x84\x90a\x0B\xFDV[a\x1F\xADV[a D\x7F]\x9DP4el\xB3\xEB\xFB\x06U\x05|\xD7\xF9\xB4\x07z\x9BB\xFFB\xCE\"<\xBA\xC5\xBCXm!&\x91a\x05\x18V[\x90a Ma\x04RV[\x80a W\x81a\x06\xD9V[\x03\x90\xA2V[a w\x90_\x91\x82\x91ce\x85\xB6\r`\xE0\x1B\x83R`\x04\x83\x01a\x0E2V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a \x93`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[a \xA0\x90a\x1E\xCDV[V[a \xB9a \xBE\x91a \xB1a\x1FaV[P`\x10a\t\x9FV[a\x0C,V[\x90V[``\x90V[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a \xFAW[` \x83\x10\x14a \xF5WV[a \xC6V[\x91`\x7F\x16\x91a \xEAV[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a!0a!)\x83a \xDAV[\x80\x94a!\x04V[\x91`\x01\x81\x16\x90\x81_\x14a!\x87WP`\x01\x14a!KW[PPPV[a!X\x91\x92\x93\x94Pa!\rV[\x91_\x92[\x81\x84\x10a!oWPP\x01\x90_\x80\x80a!FV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a!\\V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a!FV[\x90a!\xAC\x91a!\x16V[\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a!\xCD\x90a\x07mV[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a!\xE7W`@RV[a!\xAFV[\x90a\"\x0Ca\"\x05\x92a!\xFCa\x04RV[\x93\x84\x80\x92a!\xA2V[\x03\x83a!\xC3V[V[a\"\x17\x90a!\xECV[\x90V[a\"\"a \xC1V[Pa\"-`\x03a\"\x0EV[\x90V[a\"M\x91a\"<a\x1EaV[Pa\"Ea>\xCCV[\x91\x90\x91a>\xD9V[`\x01\x90V[a\"Za\x1FaV[Pa\"e`\x02a\x0C,V[\x90V[a\"|a\"wa\"\x81\x92a\x17\x7FV[a\x04\xEDV[a\x04\x9AV[\x90V[a\"\x93a\"\x99\x91\x93\x92\x93a\x04\x9AV[\x92a\x04\x9AV[\x82\x01\x80\x92\x11a\"\xA4WV[a\x1D\xD0V[\x80a\"\xC4a\"\xBEa\"\xB9_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14a$\x08W\x81a\"\xDCa\"\xD6_a\"hV[\x91a\x04\x9AV[\x14a#\xECWa\"\xF3a\"\xECa\"RV[\x83\x90a\"\x84V[a#\x0Ca#\x06a#\x01a\x15yV[a\x04\x9AV[\x91a\x04\x9AV[\x11a#\xD0Wa#\x1C3\x83\x90a?\x1EV[a#'3\x83\x90aA\x14V[a#/a4eV[\x80a#\xAFW[a#\x93Wa#D\x81\x83\x90aA\xC8V[3\x90a#\x8Ea#|a#v\x7F\xDE\"\xBA\xFF\x03\x8E:>\x08@|\xBD\xF6\x17\xDE\xEDt\xE8i\xA7\xBAQ}\xF6\x11\xE311\xC6\xE6\xEA\x04\x93a\x05\x18V[\x93a\x05\x18V[\x93a#\x85a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xA3V[_c6\xE2x\xFD`\xE2\x1B\x81R\x80a#\xAB`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[Pa#\xCBa#\xC5a#\xBEa\x14]V[3\x90a7\x11V[\x15a\x06_V[a#5V[_c\x17~?\xC3`\xE0\x1B\x81R\x80a#\xE8`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a$\x04`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a$ `\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[\x91a$N\x92a$1a\x1EaV[Pa$Fa$=a>\xCCV[\x82\x90\x84\x91aB4V[\x91\x90\x91aB\xC0V[`\x01\x90V[_\x90V[a$`\x90a\t\x04V[\x90V[\x90a$m\x90a$WV[_R` R`@_ \x90V[\x90V[a$\x88a$\x8D\x91a\x0C\x13V[a$yV[\x90V[a$\x9A\x90Ta$|V[\x90V[`\x01a$\xB6a$\xBC\x92a$\xAEa$SV[P`\x05a$cV[\x01a$\x90V[\x90V[\x80a$\xDAa$\xD4a$\xCF_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14a%\xCAW\x81a$\xF2a$\xEC_a\"hV[\x91a\x04\x9AV[\x14a%\xAEWa%\x023\x83\x90aC]V[3a%\x15a%\x0F\x83a\x04kV[\x91a\x04kV[\x03a%uW[a%&\x81\x83\x90aEVV[3\x90a%pa%^a%X\x7F\xB9\x07\x95\xA6fP\x15Y\x83\xE2B\xCA\xC3\xE1\xAC\x1AM\xC2o\x8E\xD2\x98\x7F<\xE4\x16\xA3N\0\x11\x1F\xD4\x93a\x05\x18V[\x93a\x05\x18V[\x93a%ga\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xA3V[a%\x80\x813\x90a=sV[a%\x92a%\x8C_a\"hV[\x91a\x04\x9AV[\x03a%\x9DW[a%\x1BV[a%\xA9\x813\x84\x91aB4V[a%\x98V[_c\x1F* \x05`\xE0\x1B\x81R\x80a%\xC6`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a%\xE2`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[\x90a&\x01\x91a%\xFCa%\xF7\x82a$\x9DV[a>7V[a&\x03V[V[\x90a&\r\x91aE\xB5V[PV[\x90a&\x1A\x91a%\xE6V[V[\x90a&&\x90a\x04\x9AV[\x90RV[\x90a&4\x90a\x06_V[\x90RV[\x90a&Ka&Da\x04RV[\x92\x83a!\xC3V[V[a&W``a&8V[\x90V[\x90a&\xA9a&\xA0`\x02a&ka&MV[\x94a&\x82a&z_\x83\x01a\x0C,V[_\x88\x01a&\x1CV[a&\x9Aa&\x91`\x01\x83\x01a\x0C,V[` \x88\x01a&\x1CV[\x01a\x0CSV[`@\x84\x01a&*V[V[a&\xB4\x90a&ZV[\x90V[\x90V[a&\xCEa&\xC9a&\xD3\x92a&\xB7V[a\x04\xEDV[a\x04\x9AV[\x90V[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[a&\xF6a&\xFC\x91a\x04\x9AV[\x91a\x04\x9AV[\x90\x81\x15a'\x07W\x04\x90V[a&\xD6V[`\x01a'\x18\x91\x01a\x04\x9AV[\x90V[\x90V[a'2a'-a'7\x92a'\x1BV[a\x04\xEDV[a\x04\x9AV[\x90V[a'Ia'O\x91\x93\x92\x93a\x04\x9AV[\x92a\x04\x9AV[\x82\x03\x91\x82\x11a'ZWV[a\x1D\xD0V[a'i\x90Qa\x04\x9AV[\x90V[a'ta\x1FaV[Pa'\x89a'\x84`\r\x83\x90a\x0B\xFDV[a&\xABV[\x90a'\x9FBa'\x99a\x0E\x10a&\xBAV[\x90a&\xEAV[a'\xA8_a\"hV[\x90a'\xB2_a\"hV[[\x80a'\xC7a'\xC1`\x18a'\x1EV[\x91a\x04\x9AV[\x10\x15a(3W\x81a'\xE0a'\xDA\x83a\x04\x9AV[\x91a\x04\x9AV[\x10\x15a'\xF5W[a'\xF0\x90a'\x0CV[a'\xB3V[\x91a(+a'\xF0\x91a(%a( a(\x0F`\x12\x89\x90a\x05$V[a(\x1A\x87\x89\x90a':V[\x90a\x05VV[a\x0C,V[\x90a\"\x84V[\x92\x90Pa'\xE7V[PP\x90Pa(C` \x83\x01a'_V[a(Ua(O\x83a\x04\x9AV[\x91a\x04\x9AV[\x11_\x14a(tWa(k` a(p\x93\x01a'_V[a':V[[\x90V[PPa(\x7F_a\"hV[a(qV[_\x90V[\x90V[a(\x9Fa(\x9Aa(\xA4\x92a(\x88V[a\x04\xEDV[a\n\xCDV[\x90V[a(\xAFa(\x84V[Pa(\xBA`\x12a(\x8BV[\x90V[a(\xC5a$SV[Pa(\xCEaFaV[\x90V[\x90\x80a(\xECa(\xE6a(\xE1a>\xCCV[a\x04kV[\x91a\x04kV[\x03a(\xFDWa(\xFA\x91aG\x1BV[PV[_c3K\xD9\x19`\xE1\x1B\x81R\x80a)\x15`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[\x90a)#\x90a\x05\x18V[_R` R`@_ \x90V[\x90V[a)Fa)Aa)K\x92a\x1C\xDDV[a\x04\xEDV[a\x04\x9AV[\x90V[a)\x85\x91a)za)ta)oa)\x80\x94a)ga\x1FaV[P`\na)\x19V[a)/V[\x91aG\xFCV[\x90aI\x11V[a)2V[\x90V[\x90a)\xA2\x91a)\x9Da)\x98a\x14\xC1V[a>7V[a)\xA4V[V[\x90\x81a)\xC0a)\xBAa)\xB5_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14a*PW\x80a)\xD8a)\xD2_a\"hV[\x91a\x04\x9AV[\x14a*4Wa)\xEFa)\xE8a\"RV[\x82\x90a\"\x84V[a*\x08a*\x02a)\xFDa\x15yV[a\x04\x9AV[\x91a\x04\x9AV[\x11a*\x18Wa*\x16\x91aA\xC8V[V[_c\x17~?\xC3`\xE0\x1B\x81R\x80a*0`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a*L`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a*h`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[\x90a*v\x91a)\x88V[V[\x80a*\x8Ba*\x85_a\"hV[\x91a\x04\x9AV[\x14a*\x9CWa*\x9A\x903aEVV[V[_c\x1F* \x05`\xE0\x1B\x81R\x80a*\xB4`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[a*\xC0a\x1FaV[Pa*\xDAa*\xCCa\x15yV[a*\xD4a\"RV[\x90a':V[\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a*\xFBWa*\xF7` \x91a\x07mV[\x01\x90V[a!\xAFV[\x90a+\x12a+\r\x83a*\xDDV[a&8V[\x91\x82RV[_\x7Fmode=blocknumber&from=default\0\0\0\x91\x01RV[a+H`\x1Da+\0V[\x90a+U` \x83\x01a+\x17V[V[a+_a+>V[\x90V[a+ja \xC1V[Pa+sa7?V[a+\x8Ca+\x86a+\x81aJ8V[a\x16\x07V[\x91a\x16\x07V[\x03a+\x9CWa+\x99a+WV[\x90V[_c\x01\xBF\xC1\xC5`\xE6\x1B\x81R\x80a+\xB4`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[_\x90V[\x90a+\xC6\x90a\x05\x18V[_R` R`@_ \x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a+\xE9a+\xEE\x91a\x0C\x13V[a+\xD2V[\x90V[a+\xFB\x90Ta+\xDDV[\x90V[a,\x15a,\x1A\x91a,\ra+\xB8V[P`\ta+\xBCV[a+\xF1V[\x90V[\x90a,7\x91a,2a,-a\x18\x9FV[a>7V[a,oV[V[\x90a,E_\x19\x91a\x17\x82V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a,da,_a,k\x92a\x05:V[a\x1F<V[\x82Ta,9V[\x90UV[\x80a,\x8Aa,\x84a,\x7F_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14a-oW\x81a,\xA2a,\x9C_a\"hV[\x91a\x04\x9AV[\x14a-SWa,\xC4a,\xBEa,\xB7`\x0Ea\x1F\x10V[\x83\x90aJMV[\x15a\x06_V[a-4Wa,\xF0\x82a,\xEAa,\xDB`\x10\x85\x90a\t\x9FV[\x91a,\xE5\x83a\x0C,V[a\"\x84V[\x90a,OV[a-/a-\x1D\x7F\x9C\xA0=\xBDQ\x93\xFB\xB7\x97As\xCE\xDD\x0B\xDFhA\xDD\x14\xC3\xCB\xFAsZ\xABw\xFF\x1D\xD1\x13\x9F\xB3\x92a\x05\x18V[\x92a-&a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xA2V[a-O\x90_\x91\x82\x91ce\x85\xB6\r`\xE0\x1B\x83R`\x04\x83\x01a\x0E2V[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a-k`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a-\x87`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[\x90a-\x95\x91a,\x1DV[V[` \x7Fout of bounds\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7FSyndicateTokenCrosschain: index _\x82\x01R\x01RV[a-\xF1`-`@\x92a\x07YV[a-\xFA\x81a-\x97V[\x01\x90V[a.\x13\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra-\xE4V[\x90V[\x15a.\x1DWV[a.%a\x04RV[bF\x1B\xCD`\xE5\x1B\x81R\x80a.;`\x04\x82\x01a-\xFEV[\x03\x90\xFD[a.\x88\x90a.Ka+\xB8V[Pa.y\x81a.sa.ma.ha.c`\x0Ea\x1F\x10V[aJ\x87V[a\x04\x9AV[\x91a\x04\x9AV[\x10a.\x16V[a.\x83`\x0Ea\x1F\x10V[aJ\xD6V[\x90V[a.\x9C\x90a.\x97a>\xCCV[aKLV[V[\x90a.\xB9\x92\x91a.\xB4a.\xAFa\x1DdV[a>7V[a/\x95V[V[\x91` a.\xDC\x92\x94\x93a.\xD5`@\x82\x01\x96_\x83\x01\x90a\x05\xBAV[\x01\x90a\x05\xBAV[V[a.\xE8``a&8V[\x90V[a.\xF5\x90Qa\x06_V[\x90V[\x90a/\x04`\xFF\x91a\x17\x82V[\x91\x81\x19\x16\x91\x16\x17\x90V[a/\x17\x90a\x06_V[\x90V[\x90V[\x90a/2a/-a/9\x92a/\x0EV[a/\x1AV[\x82Ta.\xF8V[\x90UV[\x90a/\x81`@`\x02a/\x87\x94a/`_\x82\x01a/Z_\x88\x01a'_V[\x90a,OV[a/y`\x01\x82\x01a/s` \x88\x01a'_V[\x90a,OV[\x01\x92\x01a.\xEBV[\x90a/\x1DV[V[\x90a/\x93\x91a/=V[V[\x80a/\xB0a/\xAAa/\xA5_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14a1\xC6W\x80a/\xC8a/\xC23a\x04kV[\x91a\x04kV[\x14a1\xAAW\x80;a/\xE1a/\xDB_a\"hV[\x91a\x04\x9AV[\x14a1\x8EW\x81a/\xFAa/\xF4_\x19a\x04\x9AV[\x91a\x04\x9AV[\x14\x15\x80a1mW[a1QW\x82a0\x1Aa0\x14_\x19a\x04\x9AV[\x91a\x04\x9AV[\x14\x15\x80a10W[a1\x15Wa0:a03`\x0Ea\x1F\x10V[\x82\x90aK\xD7V[a0\xCAW[a0\x84\x82a0s\x85a0j`\x01\x91a0aa0Xa.\xDEV[\x95_\x87\x01a&\x1CV[` \x85\x01a&\x1CV[`@\x83\x01a&*V[a0\x7F`\r\x84\x90a\x0B\xFDV[a/\x89V[\x90\x91a0\xB0\x7F\xAA\x80}\n\xBF0\xD9\x19h\xC7G\x8Cf\xB6\xD8%!\xA1\x06\xAF\x13\xED\xA06\xE2\x03m\xA9\xAF\x16\x89X\x92a\x05\x18V[\x92a0\xC5a0\xBCa\x04RV[\x92\x83\x92\x83a.\xBBV[\x03\x90\xA2V[\x80\x82\x90\x84a0\xF8\x7F\xDB\x03\xF9}\xC5\x84\nq\xE6\x9B\xE7G\x0EGa\xAF\x10\xA1#ys\xE8\x1C\x12\xD0\xDC(\x13\x89Ze&\x92a\x05\x18V[\x92a1\ra1\x04a\x04RV[\x92\x83\x92\x83a.\xBBV[\x03\x90\xA2a0?V[_bX\xCC\xAD`\xE8\x1B\x81R\x80a1,`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[P\x82a1Ka1Ea1@a\x15yV[a\x04\x9AV[\x91a\x04\x9AV[\x11a0\"V[_c\n9\\\x01`\xE0\x1B\x81R\x80a1i`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[P\x81a1\x88a1\x82a1}a\x15yV[a\x04\x9AV[\x91a\x04\x9AV[\x11a0\x02V[_cA*\x18\xED`\xE1\x1B\x81R\x80a1\xA6`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[_c\xFB\x8C\xE8\xC9`\xE0\x1B\x81R\x80a1\xC2`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a1\xDE`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[\x90a1\xED\x92\x91a.\x9EV[V[a1\xF7a\x1FaV[Pa2\na2\x05`\x0Ea\x1F\x10V[aJ\x87V[\x90V[_\x90V[a2#\x90a2\x1Da2\rV[PaL\x11V[\x90V[a2<a2A\x91a25a\x1FaV[P_a\t\x9FV[a\x0C,V[\x90V[``\x90V[a2Qa2DV[Pa2da2_`\x0Ea\x1F\x10V[aL@V[\x90V[a2oa\x1EaV[Pa2\x97a2\x87a2\x82`\r\x84\x90a\x0B\xFDV[a&\xABV[\x91a2\x92`\x0Ea\x1F\x10V[aJMV[\x90\x81a2\xA2W[P\x90V[a2\xAF\x91P`@\x01a.\xEBV[_a2\x9EV[\x90a2\xCF\x91a2\xCAa2\xC5a\x14]V[a>7V[a2\xD1V[V[\x80a2\xECa2\xE6a2\xE1_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14a3\xB0W\x81a3\x04a2\xFE_a\"hV[\x91a\x04\x9AV[\x14a3\x94Wa3\x1Aa3\x14a4eV[\x15a\x06_V[a3xWa3)\x81\x83\x90aEVV[3\x90a3sa3aa3[\x7F\xBE\xF4\xF8\x1C\x18\x14\xC6A\xED\xE8^\xBA\xAC\xF1\x9D\x04\x8B,[U\x98\n\xDF\xA6\xEF\x0F\x95le\x135\xA2\x93a\x05\x18V[\x93a\x05\x18V[\x93a3ja\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xA3V[_c\xB8\xB5\xCA-`\xE0\x1B\x81R\x80a3\x90`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a3\xAC`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a3\xC8`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[\x90a3\xD6\x91a2\xB5V[V[a3\xE0a\x1FaV[Pa3\xEB`\x0Ca\x0C,V[a3\xFDa3\xF7_a\"hV[\x91a\x04\x9AV[\x14\x80\x15a4,W[a4 Wa4\x1Da4\x16`\x0Ca\x0C,V[B\x90a':V[\x90V[a4)_a\"hV[\x90V[PBa4Ia4Ca4>`\x0Ca\x0C,V[a\x04\x9AV[\x91a\x04\x9AV[\x10\x15a4\x05V[a4b\x90a4\\a\x1FaV[PaLhV[\x90V[a4ma\x1EaV[Pa4x`\x0Ca\x0C,V[a4\x8Aa4\x84_a\"hV[\x91a\x04\x9AV[\x14\x15\x80a4\x95W[\x90V[PBa4\xB2a4\xACa4\xA7`\x0Ca\x0C,V[a\x04\x9AV[\x91a\x04\x9AV[\x10a4\x92V[a4\xD1\x90a4\xCCa4\xC7a\x17\xA3V[a>7V[a4\xD3V[V[\x80a4\xE6a4\xE0Ba\x04\x9AV[\x91a\x04\x9AV[\x11\x15a5\x9CW\x80a5\x1Fa5\x19\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04\x9AV[\x91a\x04\x9AV[\x11a5\x80Wa5.`\x0Ca\x0C,V[a59\x82`\x0Ca,OV[\x903\x90a5f\x7F\xDDh\x96\xDC\xF1\xD4\xB3\x11\xCC\xA8}\xD1\x9B\xBB\xA2\xEA\x9C\xE2\xF8g\xC1V\x88x\xA0C\x8Af\xA1\xAF\xEE\xEC\x92a\x05\x18V[\x92a5{a5ra\x04RV[\x92\x83\x92\x83a.\xBBV[\x03\x90\xA2V[_c\xEFi\xAFe`\xE0\x1B\x81R\x80a5\x98`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[_c\xA5e\x83S`\xE0\x1B\x81R\x80a5\xB4`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[a5\xC1\x90a4\xB8V[V[_\x90V[``\x90V[a5\xD5\x90a\x05\x0CV[\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a5\xF0W` \x80\x91\x02\x01\x90V[a!\xAFV[\x90a6\x07a6\x02\x83a5\xD8V[a&8V[\x91\x82RV[6\x907V[\x90a66a6\x1E\x83a5\xF5V[\x92` \x80a6,\x86\x93a5\xD8V[\x92\x01\x91\x03\x90a6\x0CV[V[`\x0F`\xF8\x1B\x90V[a6Ha5\xC3V[Pa6Qa \xC1V[Pa6Za \xC1V[Pa6ca\x1FaV[Pa6la+\xB8V[Pa6ua$SV[Pa6~a5\xC7V[Pa6\x87aL\x80V[\x90a6\x90aL\xC0V[\x90F\x90a6\x9C0a5\xCCV[\x90a6\xA6_a\x17\x87V[\x90a6\xB8a6\xB3_a\"hV[a6\x11V[\x90a6\xC1a68V[\x96\x95\x94\x93\x92\x91\x90V[a6\xF3a6\xF8\x91a6\xD9a\x1FaV[Pa6\xEDa6\xE7`\x0Ba)/V[\x91aG\xFCV[\x90aI\x11V[a)2V[\x90V[\x90a7\x05\x90a\x05\x18V[_R` R`@_ \x90V[a78\x91_a7-a73\x93a7%a\x1EaV[P`\x05a$cV[\x01a6\xFBV[a\x0CSV[\x90V[_\x90V[a7Ga7;V[Pa7PaJ8V[\x90V[a7[a\x1FaV[Pa7pa7k`\r\x83\x90a\x0B\xFDV[a&\xABV[\x90a7\x86Ba7\x80a\x0E\x10a&\xBAV[\x90a&\xEAV[a7\x8F_a\"hV[\x90a7\x99_a\"hV[[\x80a7\xAEa7\xA8`\x18a'\x1EV[\x91a\x04\x9AV[\x10\x15a8\x1AW\x81a7\xC7a7\xC1\x83a\x04\x9AV[\x91a\x04\x9AV[\x10\x15a7\xDCW[a7\xD7\x90a'\x0CV[a7\x9AV[\x91a8\x12a7\xD7\x91a8\x0Ca8\x07a7\xF6`\x11\x89\x90a\x05$V[a8\x01\x87\x89\x90a':V[\x90a\x05VV[a\x0C,V[\x90a\"\x84V[\x92\x90Pa7\xCEV[PP\x90Pa8)_\x83\x01a'_V[a8;a85\x83a\x04\x9AV[\x91a\x04\x9AV[\x11_\x14a8YWa8P_a8U\x93\x01a'_V[a':V[[\x90V[PPa8d_a\"hV[a8VV[a8qa \xC1V[Pa8|`\x04a\"\x0EV[\x90V[a8\xA6a8\xA1a8\x9Ca8\xAB\x93a8\x94a\x1FaV[P`\na)\x19V[a)/V[aM\0V[a)2V[\x90V[a8\xCB\x91a8\xBAa\x1EaV[Pa8\xC3a>\xCCV[\x91\x90\x91aB\xC0V[`\x01\x90V[\x90a8\xE3\x91a8\xDDa\x1FaV[Pa)NV[\x90V[a8\xF8\x90a8\xF2a\x1FaV[Pa8\x7FV[\x90V[a9\x03a\x1FaV[Pa9\x0Ca\"RV[\x90V[\x7F\xE4\x83)\x05{\xFD\x03\xD5^I\xB5G\x13.9\xCF\xFD\x9C\x18 \xAD{\x9DLS\x07i\x14%\xD1Z\xDF\x90V[a9ha9o\x94a9^``\x94\x98\x97\x95a9T`\x80\x86\x01\x9A_\x87\x01\x90a\tHV[` \x85\x01\x90a\x0E%V[`@\x83\x01\x90a\x05\xBAV[\x01\x90a\x05\xBAV[V[` \x01\x90V[Q\x90V[\x93\x95\x94\x90\x92\x91\x95Ba9\x95a9\x8F\x89a\x04\x9AV[\x91a\x04\x9AV[\x11a:\x0EW\x91a:\0\x91a:\x07\x93a9\xF7a:\x0C\x98\x99a9\xDFa9\xB6a9\x0FV[a9\xD0\x8B\x93\x8Ba9\xC4a\x04RV[\x95\x86\x94` \x86\x01a93V[` \x82\x01\x81\x03\x82R\x03\x82a!\xC3V[a9\xF1a9\xEB\x82a9wV[\x91a9qV[ aMuV[\x92\x90\x91\x92aM\x92V[\x91\x82aM\xDCV[aKLV[V[a:)\x87_\x91\x82\x91c#A\xD7\x87`\xE1\x1B\x83R`\x04\x83\x01a\x05\xC7V[\x03\x90\xFD[_\x90V[_\x90V[a:=a&MV[\x90` \x80\x80\x84a:Ka:-V[\x81R\x01a:Va:-V[\x81R\x01a:aa:1V[\x81RPPV[a:oa:5V[\x90V[a:\x89a:\x8E\x91a:\x81a:gV[P`\ra\x0B\xFDV[a&\xABV[\x90V[\x90a:\xAB\x91a:\xA6a:\xA1a\x1DdV[a>7V[a:\xADV[V[\x80a:\xC8a:\xC2a:\xBD_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14a;iWa:\xEAa:\xE4a:\xDD`\x0Ea\x1F\x10V[\x83\x90aJMV[\x15a\x06_V[a;JWa;\x06\x82`\x02a;\0`\r\x85\x90a\x0B\xFDV[\x01a/\x1DV[a;Ea;3\x7F\x9C\x86h\xDB2HE\x06]+\x9A*\x18;\xD3\x14\x1Fc\x01\x8FT\x82\x82\xDA\xF1\x8D\xA4\x9C\xCB\xF8\x8C3\x92a\x05\x18V[\x92a;<a\x04RV[\x91\x82\x91\x82a\x06qV[\x03\x90\xA2V[a;e\x90_\x91\x82\x91ce\x85\xB6\r`\xE0\x1B\x83R`\x04\x83\x01a\x0E2V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a;\x81`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[\x90a;\x8F\x91a:\x91V[V[\x7Fnq\xED\xAE\x12\xB1\xB9\x7FM\x1F`7\x0F\xEF\x10\x10_\xA2\xFA\xAE\x01&\x11J\x16\x9Cd\x84]a&\xC9\x90V[\x91\x94a;\xFDa<\x07\x92\x98\x97\x95a;\xF3`\xA0\x96a;\xE9a<\x0E\x9Aa;\xDF`\xC0\x8A\x01\x9E_\x8B\x01\x90a\tHV[` \x89\x01\x90a\x0E%V[`@\x87\x01\x90a\x0E%V[``\x85\x01\x90a\x05\xBAV[`\x80\x83\x01\x90a\x05\xBAV[\x01\x90a\x05\xBAV[V[\x91` a<1\x92\x94\x93a<*`@\x82\x01\x96_\x83\x01\x90a\x0E%V[\x01\x90a\x0E%V[V[\x96\x95\x91\x93\x92\x94\x90\x94Ba<Na<H\x83a\x04\x9AV[\x91a\x04\x9AV[\x11a=\x08W\x90a<\xB7a<\xC0\x94\x93\x92a<\x9Fa<ha;\x91V[a<\x90\x8C\x80\x94\x8C\x91a<z\x8D\x91aN\x1FV[\x91\x92a<\x84a\x04RV[\x97\x88\x96` \x88\x01a;\xB5V[` \x82\x01\x81\x03\x82R\x03\x82a!\xC3V[a<\xB1a<\xAB\x82a9wV[\x91a9qV[ aMuV[\x92\x90\x91\x92aM\x92V[\x80a<\xD3a<\xCD\x87a\x04kV[\x91a\x04kV[\x03a<\xE8WPa<\xE6\x92\x93\x91\x90\x91a>\xD9V[V[\x84\x90a=\x04_\x92\x83\x92c%\xC0\x07#`\xE1\x1B\x84R`\x04\x84\x01a<\x10V[\x03\x90\xFD[a=#\x90_\x91\x82\x91c1<\x89\x81`\xE1\x1B\x83R`\x04\x83\x01a\x05\xC7V[\x03\x90\xFD[\x90a=B\x91a==a=8\x82a$\x9DV[a>7V[a=DV[V[\x90a=N\x91aG\x1BV[PV[\x90a=[\x91a='V[V[\x90a=g\x90a\x05\x18V[_R` R`@_ \x90V[a=\x98\x91a=\x8Ea=\x93\x92a=\x86a\x1FaV[P`\x01a=]V[a\t\x9FV[a\x0C,V[\x90V[a=\xA5`@a&8V[\x90V[_\x90V[_\x90V[a=\xB8a=\x9BV[\x90` \x80\x83a=\xC5a=\xA8V[\x81R\x01a=\xD0a=\xACV[\x81RPPV[a=\xDEa=\xB0V[\x90V[\x90a=\xF4\x91a=\xEEa=\xD6V[PaNRV[\x90V[a=\xFFa\x1EaV[P\x80a>\x1Aa>\x14cye\xDB\x0B`\xE0\x1Ba\x06\x12V[\x91a\x06\x12V[\x14\x90\x81\x15a>'W[P\x90V[a>1\x91PaNzV[_a>#V[a>I\x90a>Ca>\xCCV[\x90aN\xC3V[V[a>T\x90a\x04\xF0V[\x90V[a>ka>fa>p\x92a\x04`V[a\x04\xEDV[a\x04\x9AV[\x90V[a>\x87a>\x82a>\x8C\x92a\x04\x9AV[a\x17\x82V[a\t\x04V[\x90V[\x90V[\x90a>\xC4a>\xBEa>\xB9a>\xB4_a>\xC9\x96a>\xACa\x1EaV[P\x01\x94a>KV[a>WV[a>sV[\x91a>\x8FV[aP@V[\x90V[a>\xD4a+\xB8V[P3\x90V[\x91a>\xE7\x92\x91`\x01\x92aQFV[V[\x90V[`@\x90a?\x15a?\x1C\x94\x96\x95\x93\x96a?\x0B``\x84\x01\x98_\x85\x01\x90a\x0E%V[` \x83\x01\x90a\x05\xBAV[\x01\x90a\x05\xBAV[V[a?2a?-`\r\x83\x90a\x0B\xFDV[a>\xE9V[\x91a?Pa?Ja?C`\x0Ea\x1F\x10V[\x84\x90aJMV[\x15a\x06_V[\x80\x15a@\xF9W[a@\xDAWa?pBa?ja\x0E\x10a&\xBAV[\x90a&\xEAV[a?y_a\"hV[\x91a?\x83_a\"hV[[\x80a?\x98a?\x92`\x18a'\x1EV[\x91a\x04\x9AV[\x10\x15a@\x04W\x82a?\xB1a?\xAB\x83a\x04\x9AV[\x91a\x04\x9AV[\x10\x15a?\xC6W[a?\xC1\x90a'\x0CV[a?\x84V[\x92a?\xFCa?\xC1\x91a?\xF6a?\xF1a?\xE0`\x11\x8A\x90a\x05$V[a?\xEB\x88\x8A\x90a':V[\x90a\x05VV[a\x0C,V[\x90a\"\x84V[\x93\x90Pa?\xB8V[P\x91\x90\x92\x93a@\x14\x82\x84\x90a\"\x84V[a@0a@*a@%_\x85\x01a\x0C,V[a\x04\x9AV[\x91a\x04\x9AV[\x11a@jWPPa@Sa@h\x93\x92a@Na@b\x93\x94`\x11a\x05$V[a\x05VV[\x91a@]\x83a\x0C,V[a\"\x84V[\x90a,OV[V[\x84\x93Pa@x_\x82\x01a\x0C,V[a@\x8Aa@\x84\x84a\x04\x9AV[\x91a\x04\x9AV[\x11_\x14a@\xC7Wa@\xC3\x91a@\xA3_a@\xA8\x93\x01a\x0C,V[a':V[[\x92\x91\x92_\x93\x84\x93c@\xED6{`\xE0\x1B\x85R`\x04\x85\x01a>\xECV[\x03\x90\xFD[PPa@\xC3a@\xD5_a\"hV[a@\xA9V[a@\xF5\x82_\x91\x82\x91ce\x85\xB6\r`\xE0\x1B\x83R`\x04\x83\x01a\x0E2V[\x03\x90\xFD[PaA\x0FaA\t`\x02\x85\x01a\x0CSV[\x15a\x06_V[a?WV[aA(aA#`\x10\x83\x90a\t\x9FV[a\x0C,V[aA;aA5\x84\x92a\x04\x9AV[\x91a\x04\x9AV[\x11aA\xACWaAh\x82aAbaAS`\x10\x85\x90a\t\x9FV[\x91aA]\x83a\x0C,V[a':V[\x90a,OV[aA\xA7aA\x95\x7F\xBC#\xEC\x7F\x13\x13\x15\x0B\x04{\xFF\x83\xD0\x84[\x05d\xBA\xA14i\x8D\xD1\x1B\xB0\xAC\xD0\xF7\xD4\x16\xDE}\x92a\x05\x18V[\x92aA\x9Ea\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xA2V[_c\x1E\xB7\x84W`\xE2\x1B\x81R\x80aA\xC4`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[\x80aA\xE3aA\xDDaA\xD8_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14aA\xFFWaA\xFD\x91aA\xF5_a\x1F\x04V[\x91\x90\x91aRUV[V[aB\"aB\x0B_a\x1F\x04V[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x0E2V[\x03\x90\xFD[\x90aB1\x91\x03a\x04\x9AV[\x90V[\x92\x91\x92aBB\x81\x83\x90a=sV[\x90\x81aBWaBQ_\x19a\x04\x9AV[\x91a\x04\x9AV[\x10aBdW[PPP\x90PV[\x81aBwaBq\x87a\x04\x9AV[\x91a\x04\x9AV[\x10aB\x9DWaB\x94\x93\x94aB\x8C\x91\x93\x92aB&V[\x90_\x92aQFV[\x80_\x80\x80aB]V[PaB\xBC\x84\x92\x91\x92_\x93\x84\x93c}\xC7\xA0\xD9`\xE1\x1B\x85R`\x04\x85\x01a>\xECV[\x03\x90\xFD[\x91\x82aB\xDCaB\xD6aB\xD1_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14aC6W\x81aB\xFCaB\xF6aB\xF1_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14aC\x0FWaC\r\x92\x91\x90\x91aRUV[V[aC2aC\x1B_a\x1F\x04V[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x0E2V[\x03\x90\xFD[aCYaCB_a\x1F\x04V[_\x91\x82\x91cKc~\x8F`\xE1\x1B\x83R`\x04\x83\x01a\x0E2V[\x03\x90\xFD[aCqaCl`\r\x83\x90a\x0B\xFDV[a>\xE9V[\x91aC\x8FaC\x89aC\x82`\x0Ea\x1F\x10V[\x84\x90aJMV[\x15a\x06_V[\x80\x15aE;W[aE\x1CWaC\xAFBaC\xA9a\x0E\x10a&\xBAV[\x90a&\xEAV[aC\xB8_a\"hV[\x91aC\xC2_a\"hV[[\x80aC\xD7aC\xD1`\x18a'\x1EV[\x91a\x04\x9AV[\x10\x15aDCW\x82aC\xF0aC\xEA\x83a\x04\x9AV[\x91a\x04\x9AV[\x10\x15aD\x05W[aD\0\x90a'\x0CV[aC\xC3V[\x92aD;aD\0\x91aD5aD0aD\x1F`\x12\x8A\x90a\x05$V[aD*\x88\x8A\x90a':V[\x90a\x05VV[a\x0C,V[\x90a\"\x84V[\x93\x90PaC\xF7V[P\x91\x90\x92\x93aDS\x82\x84\x90a\"\x84V[aDpaDjaDe`\x01\x85\x01a\x0C,V[a\x04\x9AV[\x91a\x04\x9AV[\x11aD\xAAWPPaD\x93aD\xA8\x93\x92aD\x8EaD\xA2\x93\x94`\x12a\x05$V[a\x05VV[\x91aD\x9D\x83a\x0C,V[a\"\x84V[\x90a,OV[V[\x84\x93PaD\xB9`\x01\x82\x01a\x0C,V[aD\xCBaD\xC5\x84a\x04\x9AV[\x91a\x04\x9AV[\x11_\x14aE\tWaE\x05\x91aD\xE5`\x01aD\xEA\x93\x01a\x0C,V[a':V[[\x92\x91\x92_\x93\x84\x93cr\xFFK\xD1`\xE1\x1B\x85R`\x04\x85\x01a>\xECV[\x03\x90\xFD[PPaE\x05aE\x17_a\"hV[aD\xEBV[aE7\x82_\x91\x82\x91ce\x85\xB6\r`\xE0\x1B\x83R`\x04\x83\x01a\x0E2V[\x03\x90\xFD[PaEQaEK`\x02\x85\x01a\x0CSV[\x15a\x06_V[aC\x96V[\x90\x81aEraElaEg_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14aE\x8EWaE\x8C\x91\x90aE\x85_a\x1F\x04V[\x90\x91aRUV[V[aE\xB1aE\x9A_a\x1F\x04V[_\x91\x82\x91cKc~\x8F`\xE1\x1B\x83R`\x04\x83\x01a\x0E2V[\x03\x90\xFD[aE\xBDa\x1EaV[PaE\xD2aE\xCC\x82\x84\x90a7\x11V[\x15a\x06_V[_\x14aF[WaE\xFA`\x01aE\xF5_aE\xED`\x05\x86\x90a$cV[\x01\x85\x90a6\xFBV[a/\x1DV[\x90aF\x03a>\xCCV[\x90aF@aF:aF4\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a$WV[\x92a\x05\x18V[\x92a\x05\x18V[\x92aFIa\x04RV[\x80aFS\x81a\x06\xD9V[\x03\x90\xA4`\x01\x90V[PP_\x90V[aFia$SV[PaFs0a5\xCCV[aF\xA5aF\x9F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04kV[\x91a\x04kV[\x14\x80aF\xE1W[_\x14aF\xD6W\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[aF\xDEaSpV[\x90V[PFaG\x15aG\x0F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04\x9AV[\x91a\x04\x9AV[\x14aF\xACV[aG#a\x1EaV[PaG/\x81\x83\x90a7\x11V[_\x14aG\xB7WaGV_aGQ_aGI`\x05\x86\x90a$cV[\x01\x85\x90a6\xFBV[a/\x1DV[\x90aG_a>\xCCV[\x90aG\x9CaG\x96aG\x90\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x95a$WV[\x92a\x05\x18V[\x92a\x05\x18V[\x92aG\xA5a\x04RV[\x80aG\xAF\x81a\x06\xD9V[\x03\x90\xA4`\x01\x90V[PP_\x90V[aG\xD1aG\xCCaG\xD6\x92a\x16\x07V[a\x04\xEDV[a\x04\x9AV[\x90V[\x91` aG\xFA\x92\x94\x93aG\xF3`@\x82\x01\x96_\x83\x01\x90a\x05\xBAV[\x01\x90a\x16\x12V[V[aH\x04a7;V[PaH\ra7?V[\x81aH aH\x1A\x83aG\xBDV[\x91a\x04\x9AV[\x10\x15aH3WPaH0\x90aTyV[\x90V[\x90aHN_\x92\x83\x92cvi\xFC\x0F`\xE1\x1B\x84R`\x04\x84\x01aG\xD9V[\x03\x90\xFD[T\x90V[\x90V[aHmaHhaHr\x92aHVV[a\x04\xEDV[a\x04\x9AV[\x90V[\x90V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[aH\x8FaH\x94\x91a\x0C\x13V[aHxV[\x90V[aH\xA1\x90TaH\x83V[\x90V[\x90V[aH\xBBaH\xB6aH\xC0\x92aH\xA4V[a\x04\xEDV[a\x04\x9AV[\x90V[`0\x1C\x90V[`\x01\x80`\xD0\x1B\x03\x16\x90V[aH\xE0aH\xE5\x91aH\xC3V[aH\xC9V[\x90V[aH\xF2\x90TaH\xD4V[\x90V[aI\taI\x04aI\x0E\x92a\x17\x7FV[a\x04\xEDV[a\x1C\xDDV[\x90V[\x90aIe\x90aI\x1Ea\x1D\xCCV[PaI*_\x84\x01aHRV[aI3_a\"hV[\x90\x80\x80aIIaIC`\x05aHYV[\x91a\x04\x9AV[\x11aI\xC6W[P\x90aI`_\x86\x01\x93\x91\x92\x93aHuV[aZ\xB4V[\x80aIxaIr_a\"hV[\x91a\x04\x9AV[\x14_\x14aI\x8EWPPaI\x8A_aH\xF5V[[\x90V[aI\xBB_\x91aI\xB6aI\xB0\x84aI\xC1\x96\x01\x92aI\xAA`\x01aH\xA7V[\x90a':V[\x91aHuV[aZ\xAAV[\x01aH\xE8V[aI\x8BV[\x80aI\xD4aI\xDA\x92\x91aW?V[\x90a':V[\x90\x83aJ\x0CaJ\x06aJ\x01_aI\xFB\x81\x8C\x01aI\xF6\x89\x91aHuV[aZ\xAAV[\x01aH\x97V[a\x16\x07V[\x91a\x16\x07V[\x10_\x14aJ\x1DWP\x90[\x90_aIOV[\x91PaJ3\x90aJ-`\x01aH\xA7V[\x90a\"\x84V[aJ\x16V[aJ@a7;V[PaJJCaTyV[\x90V[\x90aJ\x7FaJyaJtaJo_aJ\x84\x96aJga\x1EaV[P\x01\x94a>KV[a>WV[a>sV[\x91a>\x8FV[a[CV[\x90V[aJ\x9E_aJ\xA3\x92aJ\x97a\x1FaV[P\x01a>\x8FV[a[xV[\x90V[aJ\xB2aJ\xB7\x91a\x0C\x13V[a\x05:V[\x90V[aJ\xCEaJ\xC9aJ\xD3\x92a\x04\x9AV[a\x04\xEDV[a\x04`V[\x90V[aK\x01aJ\xFCaK\x0B\x93aJ\xF7_aK\x06\x95aJ\xF0a+\xB8V[P\x01a>\x8FV[a[\x8FV[aJ\xA6V[aJ\xBAV[a\x05\x0CV[\x90V[\x90aK\x1F`\x01\x80`\xA0\x1B\x03\x91a\x17\x82V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90V[\x90aKAaK<aKH\x92a\x05\x18V[aK)V[\x82TaK\x0EV[\x90UV[\x90aK\xD5\x91aK\xCFaK]\x82a+\xFEV[aKr\x84aKm`\t\x86\x90a+\xBCV[aK,V[\x82\x81\x85\x90aK\xB2aK\xACaK\xA6\x7F14\xE8\xA2\xE6\xD9~\x92\x9A~T\x01\x1E\xA5H]}\x19m\xD5\xF0\xBAMN\xF9X\x03\xE8\xE3\xFC%\x7F\x95a\x05\x18V[\x92a\x05\x18V[\x92a\x05\x18V[\x92aK\xBBa\x04RV[\x80aK\xC5\x81a\x06\xD9V[\x03\x90\xA4\x92\x91a[\xB0V[\x91a[\xC8V[V[\x90aL\taL\x03aK\xFEaK\xF9_aL\x0E\x96aK\xF1a\x1EaV[P\x01\x94a>KV[a>WV[a>sV[\x91a>\x8FV[a]\xABV[\x90V[aL8aL3aL.aL=\x93aL&a2\rV[P`\na)\x19V[a)/V[a^\x0EV[a^\x8DV[\x90V[aLW_aL\\\x92aLPa2DV[P\x01a>\x8FV[a_\xAFV[aLda2DV[P\x90V[aLz\x90aLta\x1FaV[Pa_\xC6V[\x90V[\x90V[aL\x88a \xC1V[PaL\xBD\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0aL\xB7`\x06aL}V[\x90a`\xE1V[\x90V[aL\xC8a \xC1V[PaL\xFD\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0aL\xF7`\x07aL}V[\x90a`\xE1V[\x90V[aM\x08a\x1D\xCCV[PaM\x14_\x82\x01aHRV[\x80aM'aM!_a\"hV[\x91a\x04\x9AV[\x14_\x14aM=WPPaM9_aH\xF5V[[\x90V[aMj_\x91aMeaM_\x84aMp\x96\x01\x92aMY`\x01aH\xA7V[\x90a':V[\x91aHuV[aZ\xAAV[\x01aH\xE8V[aM:V[aM\x8F\x90aM\x81a$SV[PaM\x8AaFaV[aa/V[\x90V[\x92aM\xAD\x92aM\xB6\x94aM\xA3a+\xB8V[P\x92\x90\x91\x92aa\xE1V[\x90\x92\x91\x92ac\x0CV[\x90V[\x91` aM\xDA\x92\x94\x93aM\xD3`@\x82\x01\x96_\x83\x01\x90a\x0E%V[\x01\x90a\x05\xBAV[V[aM\xE5\x81aN\x1FV[\x91aM\xF8aM\xF2\x84a\x04\x9AV[\x91a\x04\x9AV[\x03aN\x01WPPV[aN\x1B_\x92\x83\x92c\x01\xD4\xB6#`\xE6\x1B\x84R`\x04\x84\x01aM\xB9V[\x03\x90\xFD[aN3\x90aN+a\x1FaV[P`\x08a\t\x9FV[aNOaN?\x82a\x0C,V[\x91aNI\x83a'\x0CV[\x90a,OV[\x90V[\x90aNraNmaNw\x93aNea=\xD6V[P`\na)\x19V[a)/V[adnV[\x90V[aN\x82a\x1EaV[PaN\x9CaN\x96c\x01\xFF\xC9\xA7`\xE0\x1Ba\x06\x12V[\x91a\x06\x12V[\x14\x90V[\x91` aN\xC1\x92\x94\x93aN\xBA`@\x82\x01\x96_\x83\x01\x90a\x0E%V[\x01\x90a\tHV[V[\x90aN\xD8aN\xD2\x83\x83\x90a7\x11V[\x15a\x06_V[aN\xE0WPPV[aN\xFA_\x92\x83\x92c\xE2Q}?`\xE0\x1B\x84R`\x04\x84\x01aN\xA0V[\x03\x90\xFD[\x90aO\x08\x90a$WV[_R` R`@_ \x90V[T\x90V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[_R` _ \x90V[aO>\x81aO\x14V[\x82\x10\x15aOXWaOP`\x01\x91aO,V[\x91\x02\x01\x90_\x90V[aO\x18V[aOm\x90`\x08aOr\x93\x02a\x05lV[a$yV[\x90V[\x90aO\x80\x91TaO]V[\x90V[aO\x8C\x90a\x0C\x13V[\x90V[\x91\x90aO\xA5aO\xA0aO\xAD\x93a$WV[aO\x83V[\x90\x83Ta\x1F\x17V[\x90UV[\x90V[cNH{q`\xE0\x1B_R`1`\x04R`$_\xFD[T\x90V[_R` _ \x90V[aO\xDE\x81aO\xC8V[\x82\x10\x15aO\xF8WaO\xF0`\x01\x91aO\xCCV[\x91\x02\x01\x90_\x90V[aO\x18V[aP\x0F\x91aP\ta$SV[\x91aO\x8FV[V[aP\x1A\x81aO\xC8V[\x80\x15aP;W`\x01\x90\x03\x90aP8aP2\x83\x83aO\xD5V[\x90aO\xFDV[UV[aO\xB4V[aPHa\x1EaV[PaP_aPZ`\x01\x83\x01\x84\x90aN\xFEV[a\x0C,V[\x90\x81aPsaPm_a\"hV[\x91a\x04\x9AV[\x14\x15_\x14aQ?WaP\xF1\x92`\x01aP\xEC\x92\x84aP\x9A_\x96aP\x94\x85aH\xA7V[\x90a':V[aP\xB7aP\xA8\x88\x85\x01aO\x14V[aP\xB1\x86aH\xA7V[\x90a':V[\x81aP\xCAaP\xC4\x83a\x04\x9AV[\x91a\x04\x9AV[\x03aP\xF6W[PPPaP\xE6aP\xE1\x86\x83\x01aO\xB1V[aP\x11V[\x01aN\xFEV[a\x1FeV[`\x01\x90V[aQ7\x92aQ)aQ\x15aQ\x0FaQ2\x94\x8C\x89\x01aO5V[\x90aOuV[\x93aQ#\x85\x91\x8C\x89\x01aO5V[\x90aO\x8FV[\x91\x85\x85\x01aN\xFEV[a,OV[_\x80\x80aP\xD0V[PPP_\x90V[\x90\x92\x81aQcaQ]aQX_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14aR.W\x83aQ\x83aQ}aQx_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14aR\x07WaQ\xA7\x83aQ\xA2aQ\x9B`\x01\x86\x90a=]V[\x87\x90a\t\x9FV[a,OV[aQ\xB1W[PPPV[\x91\x90\x91aQ\xFCaQ\xEAaQ\xE4\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%\x93a\x05\x18V[\x93a\x05\x18V[\x93aQ\xF3a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xA3_\x80\x80aQ\xACV[aR*aR\x13_a\x1F\x04V[_\x91\x82\x91cJ\x14\x06\xB1`\xE1\x1B\x83R`\x04\x83\x01a\x0E2V[\x03\x90\xFD[aRQaR:_a\x1F\x04V[_\x91\x82\x91c\xE6\x02\xDF\x05`\xE0\x1B\x83R`\x04\x83\x01a\x0E2V[\x03\x90\xFD[\x91\x82aRqaRkaRf_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14\x15\x80aR\xDCW[aR\x8CW[aR\x8A\x92\x91\x90\x91ad\x8FV[V[aR\x94a4eV[\x80aR\xBBW[\x15aR~W_c6\xE2x\xFD`\xE2\x1B\x81R\x80aR\xB7`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[PaR\xD7aR\xD1aR\xCAa\x14]V[3\x90a7\x11V[\x15a\x06_V[aR\x9AV[P\x81aR\xF8aR\xF2aR\xED_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14\x15aRyV[\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x90V[\x90\x95\x94\x92aSn\x94aS]aSg\x92aSS`\x80\x96aSI`\xA0\x88\x01\x9C_\x89\x01\x90a\tHV[` \x87\x01\x90a\tHV[`@\x85\x01\x90a\tHV[``\x83\x01\x90a\x05\xBAV[\x01\x90a\x0E%V[V[aSxa$SV[PaS\x81aR\xFFV[aS\xF8\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91aS\xE9\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0FaS\xD40a5\xCCV[\x91aS\xDDa\x04RV[\x96\x87\x95` \x87\x01aS#V[` \x82\x01\x81\x03\x82R\x03\x82a!\xC3V[aT\naT\x04\x82a9wV[\x91a9qV[ \x90V[\x90V[aT%aT aT*\x92aT\x0EV[a\x04\xEDV[a\n\xCDV[\x90V[aT6\x90aT\x11V[\x90RV[\x91` aT[\x92\x94\x93aTT`@\x82\x01\x96_\x83\x01\x90aT-V[\x01\x90a\x05\xBAV[V[aTqaTlaTv\x92a\x04\x9AV[a\x04\xEDV[a\x16\x07V[\x90V[aT\x81a7;V[P\x80aT\x9BaT\x95e\xFF\xFF\xFF\xFF\xFF\xFFaG\xBDV[\x91a\x04\x9AV[\x11aT\xACWaT\xA9\x90aT]V[\x90V[`0aT\xC8_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01aT:V[\x03\x90\xFD[\x90V[aT\xE3aT\xDEaT\xE8\x92aT\xCCV[a\x04\xEDV[a\x04\x9AV[\x90V[\x90V[aU\x02aT\xFDaU\x07\x92aT\xEBV[a\x04\xEDV[a\n\xCDV[\x90V[aU)\x90aU#aU\x1DaU.\x94a\n\xCDV[\x91a\x04\x9AV[\x90a\x05lV[a\x04\x9AV[\x90V[\x90V[aUHaUCaUM\x92aU1V[a\x04\xEDV[a\n\xCDV[\x90V[aUo\x90aUiaUcaUt\x94a\n\xCDV[\x91a\x04\x9AV[\x90a\x1F\x13V[a\x04\x9AV[\x90V[\x90V[aU\x8EaU\x89aU\x93\x92aUwV[a\x04\xEDV[a\x04\x9AV[\x90V[\x90V[aU\xADaU\xA8aU\xB2\x92aU\x96V[a\x04\xEDV[a\n\xCDV[\x90V[\x90V[aU\xCCaU\xC7aU\xD1\x92aU\xB5V[a\x04\xEDV[a\x04\x9AV[\x90V[\x90V[aU\xEBaU\xE6aU\xF0\x92aU\xD4V[a\x04\xEDV[a\n\xCDV[\x90V[\x90V[aV\naV\x05aV\x0F\x92aU\xF3V[a\x04\xEDV[a\x04\x9AV[\x90V[\x90V[aV)aV$aV.\x92aV\x12V[a\x04\xEDV[a\n\xCDV[\x90V[\x90V[aVHaVCaVM\x92aV1V[a\x04\xEDV[a\x04\x9AV[\x90V[\x90V[aVgaVbaVl\x92aVPV[a\x04\xEDV[a\n\xCDV[\x90V[aV\x83aV~aV\x88\x92aU\xD4V[a\x04\xEDV[a\x04\x9AV[\x90V[\x90V[aV\xA2aV\x9DaV\xA7\x92aV\x8BV[a\x04\xEDV[a\n\xCDV[\x90V[aV\xBEaV\xB9aV\xC3\x92aVPV[a\x04\xEDV[a\x04\x9AV[\x90V[aV\xDAaV\xD5aV\xDF\x92aH\xA4V[a\x04\xEDV[a\n\xCDV[\x90V[\x90V[aV\xF9aV\xF4aV\xFE\x92aV\xE2V[a\x04\xEDV[a\x04\x9AV[\x90V[\x90aW\x0C\x91\x02a\x04\x9AV[\x90V[aW\x1BaW!\x91a\x04\x9AV[\x91a\x04\x9AV[\x90\x81\x15aW,W\x04\x90V[a&\xD6V[\x90aW<\x91\x01a\x04\x9AV[\x90V[aWGa\x1FaV[P\x80aW\\aWV`\x01aH\xA7V[\x91a\x04\x9AV[\x11\x15aZ\xA7W\x80aYqaYNaY>aY.aY\x1EaY\x0EaX\xFEaX\xEEaX\xDEaX\xCEaX\xBE\x8BaX\xB8aX\xB1aYw\x9FaX\x91aX\x81aX\xA1\x92aW\xA3`\x01aH\xA7V[\x90\x80aW\xBBaW\xB5`\x01`\x80\x1BaT\xCFV[\x91a\x04\x9AV[\x10\x15aZyW[\x80aW\xDEaW\xD8h\x01\0\0\0\0\0\0\0\0aUzV[\x91a\x04\x9AV[\x10\x15aZKW[\x80aW\xFDaW\xF7d\x01\0\0\0\0aU\xB8V[\x91a\x04\x9AV[\x10\x15aZ\x1DW[\x80aX\x1AaX\x14b\x01\0\0aU\xF6V[\x91a\x04\x9AV[\x10\x15aY\xEFW[\x80aX6aX0a\x01\0aV4V[\x91a\x04\x9AV[\x10\x15aY\xC1W[\x80aXQaXK`\x10aVoV[\x91a\x04\x9AV[\x10\x15aY\x93W[aXkaXe`\x04aV\xAAV[\x91a\x04\x9AV[\x10\x15aYzW[aX|`\x03aV\xE5V[aW\x01V[aX\x8B`\x01aV\xC6V[\x90aU\nV[aX\x9B\x81\x86aW\x0FV[\x90aW1V[aX\xAB`\x01aV\xC6V[\x90aU\nV[\x80\x92aW\x0FV[\x90aW1V[aX\xC8`\x01aV\xC6V[\x90aU\nV[aX\xD8\x81\x8CaW\x0FV[\x90aW1V[aX\xE8`\x01aV\xC6V[\x90aU\nV[aX\xF8\x81\x8AaW\x0FV[\x90aW1V[aY\x08`\x01aV\xC6V[\x90aU\nV[aY\x18\x81\x88aW\x0FV[\x90aW1V[aY(`\x01aV\xC6V[\x90aU\nV[aY8\x81\x86aW\x0FV[\x90aW1V[aYH`\x01aV\xC6V[\x90aU\nV[\x91aYkaYeaY`\x85\x80\x94aW\x0FV[a\x04\x9AV[\x91a\x04\x9AV[\x11ae\x1FV[\x90aB&V[\x90V[aY\x8E\x90aY\x88`\x01aV\xC6V[\x90aUPV[aXrV[aY\xAAaY\xBB\x91aY\xA4`\x04aVSV[\x90aU\nV[\x91aY\xB5`\x02aV\x8EV[\x90aUPV[\x90aXXV[aY\xD8aY\xE9\x91aY\xD2`\x08aV\x15V[\x90aU\nV[\x91aY\xE3`\x04aVSV[\x90aUPV[\x90aX=V[aZ\x06aZ\x17\x91aZ\0`\x10aU\xD7V[\x90aU\nV[\x91aZ\x11`\x08aV\x15V[\x90aUPV[\x90aX!V[aZ4aZE\x91aZ.` aU\x99V[\x90aU\nV[\x91aZ?`\x10aU\xD7V[\x90aUPV[\x90aX\x04V[aZbaZs\x91aZ\\`@aU4V[\x90aU\nV[\x91aZm` aU\x99V[\x90aUPV[\x90aW\xE5V[aZ\x90aZ\xA1\x91aZ\x8A`\x80aT\xEEV[\x90aU\nV[\x91aZ\x9B`@aU4V[\x90aUPV[\x90aW\xC2V[\x90V[_R` _ \x01\x90V[\x93\x91\x90\x92aZ\xC0a\x1FaV[P[\x81aZ\xD5aZ\xCF\x83a\x04\x9AV[\x91a\x04\x9AV[\x10\x15a[;WaZ\xE6\x82\x82\x90aeIV[\x90aZ\xFC_aZ\xF6\x88\x85\x90aZ\xAAV[\x01aH\x97V[a[\x0Ea[\x08\x87a\x16\x07V[\x91a\x16\x07V[\x11_\x14a[\x1EWP\x91[\x91aZ\xC2V[\x92\x91Pa[5\x90a[/`\x01aH\xA7V[\x90a\"\x84V[\x90a[\x18V[\x92PP\x91P\x90V[a[a\x91`\x01a[\\\x92a[Ua\x1EaV[P\x01aN\xFEV[a\x0C,V[a[sa[m_a\"hV[\x91a\x04\x9AV[\x14\x15\x90V[_a[\x8C\x91a[\x85a\x1FaV[P\x01aO\x14V[\x90V[a[\xAD\x91_a[\xA7\x92a[\xA0a$SV[P\x01aO5V[\x90aOuV[\x90V[a[\xC2\x90a[\xBCa\x1FaV[Pa2&V[\x90V[\x90V[\x91\x90\x91\x80a[\xDEa[\xD8\x85a\x04kV[\x91a\x04kV[\x14\x15\x80a]\\W[a[\xF0W[PPPV[\x80a\\\x0Ba\\\x05a\\\0_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x03a\\\xCCW[P\x81a\\-a\\'a\\\"_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x03a\\9W[\x80a[\xEBV[a\\\x80a\\sa\\z\x92a\\O`\n\x86\x90a)\x19V[\x90a\\ma\\ga\\a`\x01\x93ae\xE2V[\x93a)/V[\x91a[\xC5V[\x90af5V[\x92\x90a)2V[\x91a)2V[\x91\x90\x91a\\\xAD\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\x05\x18V[\x92a\\\xC2a\\\xB9a\x04RV[\x92\x83\x92\x83a.\xBBV[\x03\x90\xA2_\x80a\\3V[a]\x0Ba]\x11a]\x04a\\\xE1`\n\x85\x90a)\x19V[`\x02a\\\xFEa\\\xF8a\\\xF2\x89ae\xE2V[\x93a)/V[\x91a[\xC5V[\x90af5V[\x92\x90a)2V[\x91a)2V[\x91\x90\x91a]>\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\x05\x18V[\x92a]Sa]Ja\x04RV[\x92\x83\x92\x83a.\xBBV[\x03\x90\xA2_a\\\x11V[P\x81a]pa]j_a\"hV[\x91a\x04\x9AV[\x11a[\xE6V[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15a]\xA6W\x82a]\x9E\x91`\x01a]\xA4\x95\x01\x81UaO\xD5V[\x90aO\x8FV[V[a!\xAFV[a]\xB3a\x1EaV[Pa]\xC8a]\xC2\x82\x84\x90a[CV[\x15a\x06_V[_\x14a^\x08Wa]\xFEa^\x03\x92a]\xEAa]\xE3_\x85\x01aO\xB1V[\x82\x90a]vV[`\x01a]\xF7_\x85\x01aO\x14V[\x93\x01aN\xFEV[a,OV[`\x01\x90V[PP_\x90V[_a^\"\x91a^\x1Ba\x1FaV[P\x01aHRV[\x90V[a^9a^4a^>\x92a\x10\x12V[a\x04\xEDV[a\x04\x9AV[\x90V[a^J\x90aU\x99V[\x90RV[\x91` a^o\x92\x94\x93a^h`@\x82\x01\x96_\x83\x01\x90a^AV[\x01\x90a\x05\xBAV[V[a^\x85a^\x80a^\x8A\x92a\x04\x9AV[a\x04\xEDV[a\x10\x12V[\x90V[a^\x95a2\rV[P\x80a^\xADa^\xA7c\xFF\xFF\xFF\xFFa^%V[\x91a\x04\x9AV[\x11a^\xBEWa^\xBB\x90a^qV[\x90V[` a^\xDA_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01a^NV[\x03\x90\xFD[``\x90V[` \x91\x81R\x01\x90V[a^\xF5\x90a\t\x04V[\x90RV[\x90a_\x06\x81` \x93a^\xECV[\x01\x90V[a_\x14\x90Ta$|V[\x90V[`\x01\x01\x90V[\x90a_:a_4a_-\x84aO\x14V[\x80\x93a^\xE3V[\x92aO,V[\x90_[\x81\x81\x10a_JWPPP\x90V[\x90\x91\x92a_ja_d`\x01\x92a__\x87a_\nV[a^\xF9V[\x94a_\x17V[\x91\x01\x91\x90\x91a_=V[\x90a_~\x91a_\x1DV[\x90V[\x90a_\xA1a_\x9A\x92a_\x91a\x04RV[\x93\x84\x80\x92a_tV[\x03\x83a!\xC3V[V[a_\xAC\x90a_\x81V[\x90V[_a_\xC3\x91a_\xBCa^\xDEV[P\x01a_\xA3V[\x90V[a_\xDDa_\xE2\x91a_\xD5a\x1FaV[P`\x08a\t\x9FV[a\x0C,V[\x90V[\x90V[a_\xFCa_\xF7a`\x01\x92a_\xE5V[a\x17\x82V[a\t\x04V[\x90V[a`\x0E`\xFFa_\xE8V[\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a`4a`-\x83a \xDAV[\x80\x94a!\x04V[\x91`\x01\x81\x16\x90\x81_\x14a`\x8BWP`\x01\x14a`OW[PPPV[a`\\\x91\x92\x93\x94Pa`\x11V[\x91_\x92[\x81\x84\x10a`sWPP\x01\x90_\x80\x80a`JV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a``V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a`JV[\x90a`\xB0\x91a`\x1AV[\x90V[\x90a`\xD3a`\xCC\x92a`\xC3a\x04RV[\x93\x84\x80\x92a`\xA6V[\x03\x83a!\xC3V[V[a`\xDE\x90a`\xB3V[\x90V[\x90a`\xEAa \xC1V[Pa`\xF4\x82a$WV[aa\raa\x07aa\x02a`\x04V[a\t\x04V[\x91a\t\x04V[\x14\x15_\x14aa\"WPaa\x1F\x90af\xBFV[\x90V[aa,\x91Pa`\xD5V[\x90V[`B\x91aa:a$SV[P`@Q\x91\x7F\x19\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83R`\x02\x83\x01R`\"\x82\x01R \x90V[_\x90V[\x90V[aa\x8Baa\x86aa\x90\x92aatV[a\x04\xEDV[a\x04\x9AV[\x90V[aa\xC8aa\xCF\x94aa\xBE``\x94\x98\x97\x95aa\xB4`\x80\x86\x01\x9A_\x87\x01\x90a\tHV[` \x85\x01\x90a\n\xD3V[`@\x83\x01\x90a\tHV[\x01\x90a\tHV[V[aa\xD9a\x04RV[=_\x82>=\x90\xFD[\x93\x92\x93aa\xECa+\xB8V[Paa\xF5aapV[Paa\xFEa$SV[Pab\x08\x85aJ\xA6V[ab:ab4\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0aawV[\x91a\x04\x9AV[\x11ab\xC7W\x90ab]` \x94\x95_\x94\x93\x92\x93abTa\x04RV[\x94\x85\x94\x85aa\x93V[\x83\x80R\x03\x90`\x01Z\xFA\x15ab\xC2Wabu_Qa\x17\x82V[\x80ab\x90ab\x8Aab\x85_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14ab\xA6W_\x91ab\xA0_a\x17\x87V[\x91\x92\x91\x90V[Pab\xB0_a\x1F\x04V[`\x01\x91ab\xBC_a\x17\x87V[\x91\x92\x91\x90V[aa\xD1V[PPPab\xD3_a\x1F\x04V[\x90`\x03\x92\x91\x92\x91\x90V[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x04\x11\x15ab\xFBWV[ab\xDDV[\x90ac\n\x82ab\xF1V[V[\x80ac\x1Fac\x19_ac\0V[\x91ac\0V[\x14_\x14ac*WPPV[\x80ac>ac8`\x01ac\0V[\x91ac\0V[\x14_\x14acaW_c\xF6E\xEE\xDF`\xE0\x1B\x81R\x80ac]`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[\x80acuaco`\x02ac\0V[\x91ac\0V[\x14_\x14ac\xA3Wac\x9Fac\x88\x83aJ\xA6V[_\x91\x82\x91c\xFC\xE6\x98\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x05\xC7V[\x03\x90\xFD[ac\xB6ac\xB0`\x03ac\0V[\x91ac\0V[\x14ac\xBEWPV[ac\xD9\x90_\x91\x82\x91c5\xE2\xF3\x83`\xE2\x1B\x83R`\x04\x83\x01a\tUV[\x03\x90\xFD[_R` _ \x90V[ac\xEF\x81aHRV[\x82\x10\x15ad\tWad\x01`\x01\x91ac\xDDV[\x91\x02\x01\x90_\x90V[aO\x18V[\x90ad\x18\x90a\x16\x07V[\x90RV[\x90ad&\x90a\x1C\xDDV[\x90RV[\x90ad`adW_ad:a=\x9BV[\x94adQadI\x83\x83\x01aH\x97V[\x83\x88\x01ad\x0EV[\x01aH\xE8V[` \x84\x01ad\x1CV[V[adk\x90ad*V[\x90V[ad\x8C\x91_ad\x86\x92ad\x7Fa=\xD6V[P\x01ac\xE6V[PadbV[\x90V[\x92\x91ad\x9D\x84\x83\x83\x91af\xEFV[\x83ad\xB8ad\xB2ad\xAD_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14ad\xCDW[ad\xCB\x92\x93\x91\x90\x91ahyV[V[ad\xD5a\"RV[\x93ad\xDEah^V[\x94\x80ad\xF2ad\xEC\x88a\x04\x9AV[\x91a\x04\x9AV[\x11ad\xFFWP\x93Pad\xBEV[\x85\x90ae\x1B_\x92\x83\x92c\x0EX\xAE\x93`\xE1\x1B\x84R`\x04\x84\x01a.\xBBV[\x03\x90\xFD[ae'a\x1FaV[P\x15\x15\x90V[aeAae<aeF\x92aV\x8BV[a\x04\xEDV[a\x04\x9AV[\x90V[aenaet\x92aeXa\x1FaV[P\x82\x81\x16\x92\x18aeh`\x02ae-V[\x90a&\xEAV[\x90a\"\x84V[\x90V[\x90V[ae\x8Eae\x89ae\x93\x92aewV[a\x04\xEDV[a\n\xCDV[\x90V[ae\x9F\x90aezV[\x90RV[\x91` ae\xC4\x92\x94\x93ae\xBD`@\x82\x01\x96_\x83\x01\x90ae\x96V[\x01\x90a\x05\xBAV[V[ae\xDAae\xD5ae\xDF\x92a\x04\x9AV[a\x04\xEDV[a\x1C\xDDV[\x90V[ae\xEAa\x1D\xCCV[P\x80af\x04ae\xFE`\x01\x80`\xD0\x1B\x03a)2V[\x91a\x04\x9AV[\x11af\x15Waf\x12\x90ae\xC6V[\x90V[`\xD0af1_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01ae\xA3V[\x03\x90\xFD[\x90afkafq\x93\x92afFa\x1D\xCCV[PafOa\x1D\xCCV[P\x80\x93afdaf]a7?V[\x94\x92aM\0V[\x90\x91al\xE1V[\x91ai8V[\x91\x90\x91\x90V[af\x8Baf\x86af\x90\x92aU\x96V[a\x04\xEDV[a\x04\x9AV[\x90V[6\x907V[\x90af\xBDaf\xA5\x83a+\0V[\x92` \x80af\xB3\x86\x93a*\xDDV[\x92\x01\x91\x03\x90af\x93V[V[af\xC7a \xC1V[Paf\xD1\x81ai\xA2V[\x90af\xE4af\xDF` afwV[af\x98V[\x91\x82R` \x82\x01R\x90V[\x91\x90\x91\x80ag\rag\x07ag\x02_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14_\x14ag\xEEWag1ag*\x83ag%`\x02a\x0C,V[a\"\x84V[`\x02a,OV[[\x82agMagGagB_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14_\x14ag\xC2Wagqagj\x83age`\x02a\x0C,V[aB&V[`\x02a,OV[[\x91\x90\x91ag\xBDag\xABag\xA5\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x93a\x05\x18V[\x93a\x05\x18V[\x93ag\xB4a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xA3V[ag\xE9\x82ag\xE3ag\xD4_\x87\x90a\t\x9FV[\x91ag\xDE\x83a\x0C,V[aW1V[\x90a,OV[agrV[ah\x01ag\xFC_\x83\x90a\t\x9FV[a\x0C,V[\x80ah\x14ah\x0E\x85a\x04\x9AV[\x91a\x04\x9AV[\x10ah<Wah'ah7\x91\x84\x90aB&V[ah2_\x84\x90a\t\x9FV[a,OV[ag2V[\x90ahZ\x90\x91\x92_\x93\x84\x93c9\x144\xE3`\xE2\x1B\x85R`\x04\x85\x01a>\xECV[\x03\x90\xFD[ahfa\x1FaV[Pahv`\x01\x80`\xD0\x1B\x03a)2V[\x90V[\x91ah\xD1ah\xCBah\xD8\x94\x80ah\x9Fah\x99ah\x94_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14ai\tW[\x84ah\xC0ah\xBAah\xB5_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14ah\xDAW[a+\xFEV[\x92a+\xFEV[\x90\x91a[\xC8V[V[ai\x02`\x0B`\x02ah\xFCah\xF6ah\xF0\x89ae\xE2V[\x93a)/V[\x91a[\xC5V[\x90af5V[PPah\xC6V[ai1`\x0B`\x01ai+ai%ai\x1F\x89ae\xE2V[\x93a)/V[\x91a[\xC5V[\x90af5V[PPah\xA5V[\x91ai\\_aia\x94aiIa\x1D\xCCV[PaiRa\x1D\xCCV[P\x01\x92\x91\x92aHuV[ak\x93V[\x91\x90\x91\x90V[ai{aivai\x80\x92a_\xE5V[a\x04\xEDV[a\x04\x9AV[\x90V[\x90V[ai\x9Aai\x95ai\x9F\x92ai\x83V[a\x04\xEDV[a\x04\x9AV[\x90V[ai\xB7ai\xBC\x91ai\xB1a\x1FaV[Pa$WV[aJ\xA6V[ai\xC6`\xFFaigV[\x16\x80ai\xDBai\xD5`\x1Fai\x86V[\x91a\x04\x9AV[\x11ai\xE3W\x90V[_c,\xD4J\xC3`\xE2\x1B\x81R\x80ai\xFB`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[T\x90V[aj\r`@a&8V[\x90V[_R` _ \x90V[aj\"\x81ai\xFFV[\x82\x10\x15aj<Waj4`\x01\x91aj\x10V[\x91\x02\x01\x90_\x90V[aO\x18V[ajK\x90Qa\x16\x07V[\x90V[\x90aj_e\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x17\x82V[\x91\x81\x19\x16\x91\x16\x17\x90V[aj}ajxaj\x82\x92a\x16\x07V[a\x04\xEDV[a\x16\x07V[\x90V[\x90V[\x90aj\x9Daj\x98aj\xA4\x92ajiV[aj\x85V[\x82TajNV[\x90UV[aj\xB2\x90Qa\x1C\xDDV[\x90V[`0\x1B\x90V[\x90aj\xCDe\xFF\xFF\xFF\xFF\xFF\xFF\x19\x91aj\xB5V[\x91\x81\x19\x16\x91\x16\x17\x90V[aj\xEBaj\xE6aj\xF0\x92a\x1C\xDDV[a\x04\xEDV[a\x1C\xDDV[\x90V[\x90V[\x90ak\x0Bak\x06ak\x12\x92aj\xD7V[aj\xF3V[\x82Taj\xBBV[\x90UV[\x90ak@` _akF\x94ak8\x82\x82\x01ak2\x84\x88\x01ajAV[\x90aj\x88V[\x01\x92\x01aj\xA8V[\x90aj\xF6V[V[\x91\x90akYWakW\x91ak\x16V[V[a\x1F\x9AV[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15ak\x8EW\x82ak\x86\x91`\x01ak\x8C\x95\x01\x81Uaj\x19V[\x90akHV[V[a!\xAFV[\x90\x92\x91\x92ak\x9Fa\x1D\xCCV[Pak\xA8a\x1D\xCCV[Pak\xB2\x82ai\xFFV[\x80ak\xC5ak\xBF_a\"hV[\x91a\x04\x9AV[\x11_\x14al\x95Wak\xEB\x90ak\xE5\x84\x91ak\xDF`\x01aH\xA7V[\x90a':V[\x90aZ\xAAV[\x90ak\xF7_\x83\x01aH\x97V[\x92al\x03_\x84\x01aH\xE8V[\x93\x80al\x17al\x11\x85a\x16\x07V[\x91a\x16\x07V[\x11alyWal.al(\x84a\x16\x07V[\x91a\x16\x07V[\x14_\x14alIWPPalD\x90_\x85\x91\x01aj\xF6V[[\x91\x90V[alt\x92Palo\x86alfal]aj\x03V[\x94_\x86\x01ad\x0EV[` \x84\x01ad\x1CV[ak^V[alEV[_c% `\x1D`\xE0\x1B\x81R\x80al\x91`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[Pal\xC0\x91al\xBB\x85al\xB2al\xA9aj\x03V[\x94_\x86\x01ad\x0EV[` \x84\x01ad\x1CV[ak^V[al\xC9_aH\xF5V[\x91\x90V[cNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[\x91\x90\x91\x80`\x01\x14am\0W`\x02\x03al\xCDWal\xFC\x91a\x1EKV[\x90[V[Pam\n\x91a\x1E\x0CV[\x90al\xFEV",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361015610013575b611dc8565b61001d5f3561044c565b806301042d7a1461044757806301ffc9a71461044257806304df017d1461043d578063050732fb1461043857806306fdde0314610433578063095ea7b31461042e57806318160ddd1461042957806318bf50771461042457806323b872dd1461041f578063248a9ca31461041a5780632869366b146104155780632b8c49e3146104105780632f2ff15d1461040b57806330d3e8eb14610406578063313ce567146104015780633644e515146103fc57806336568abe146103f75780633a46b1a8146103f257806340c10f19146103ed578063427ac0ca146103e857806342966c68146103e35780634bdd36ce146103de5780634bf5d7e9146103d95780634f1bfc9e146103d4578063587cde1e146103cf5780635a4239e9146103ca5780635a5db1bb146103c55780635c19a95c146103c05780635d4c6285146103bb57806363a0daac146103b657806365145534146103b15780636fcfff45146103ac57806370a08231146103a757806372cbdcc8146103a257806378fb7fd21461039d57806379cc6790146103985780637a8cd156146103935780637ecebe001461038e57806383f1211b146103895780638426adf214610384578063844c90261461037f57806384b0196e1461037a5780638a542521146103755780638d3343d6146103705780638e539e8c1461036b578063902d55a51461036657806391d148541461036157806391ddadf41461035c57806394aa22f21461035757806395d89b41146103525780639ab24eb01461034d5780639b7ef64b14610348578063a217fddf14610343578063a9059cbb1461033e578063aa082a9d14610339578063b0ca253e14610334578063b7cdc61c1461032f578063bb4d44361461032a578063c02ae75414610325578063c3cda52014610320578063c4fc45a81461031b578063c9ab000614610316578063d505accf14610311578063d547741f1461030c578063dd62ed3e14610307578063f1127ed8146103025763f75e85120361000e57611d93565b611d2e565b611c4a565b611be9565b611baf565b611b0b565b611a86565b6119f4565b611938565b611903565b6118ce565b611869565b611834565b6117ef565b6117ba565b61174a565b6116d3565b61169e565b611669565b611634565b6115d1565b61159c565b611525565b6114f0565b61148c565b611421565b6112dc565b6112a7565b61124e565b611219565b6111e4565b6111b0565b61117b565b611146565b611072565b61103d565b610fdd565b610fa9565b610f39565b610ee5565b610eb0565b610e7c565b610e47565b610df0565b610d82565b610d4d565b610d1a565b610cc4565b610bc9565b610b93565b610b5f565b610b2a565b610af5565b610a98565b610a64565b610a03565b6109ce565b61096a565b6108ce565b610860565b61082b565b6107f5565b6107c0565b610711565b6106de565b610686565b6105dc565b60e01c90565b60405190565b5f80fd5b5f80fd5b60018060a01b031690565b61047490610460565b90565b6104808161046b565b0361048757565b5f80fd5b9050359061049882610477565b565b90565b6104a68161049a565b036104ad57565b5f80fd5b905035906104be8261049d565b565b91906040838203126104e857806104dc6104e5925f860161048b565b936020016104b1565b90565b61045c565b90565b6105046104ff61050992610460565b6104ed565b610460565b90565b610515906104f0565b90565b6105219061050c565b90565b9061052e90610518565b5f5260205260405f2090565b61054e6105496105539261049a565b6104ed565b61049a565b90565b906105609061053a565b5f5260205260405f2090565b1c90565b90565b610583906008610588930261056c565b610570565b90565b906105969154610573565b90565b6105b26105b7926105ad6011935f94610524565b610556565b61058b565b90565b6105c39061049a565b9052565b91906105da905f602085019401906105ba565b565b3461060d576106096105f86105f23660046104c0565b90610599565b610600610452565b918291826105c7565b0390f35b610458565b63ffffffff60e01b1690565b61062781610612565b0361062e57565b5f80fd5b9050359061063f8261061e565b565b9060208282031261065a57610657915f01610632565b90565b61045c565b151590565b61066d9061065f565b9052565b9190610684905f60208501940190610664565b565b346106b6576106b26106a161069c366004610641565b611e65565b6106a9610452565b91829182610671565b0390f35b610458565b906020828203126106d4576106d1915f0161048b565b90565b61045c565b5f0190565b3461070c576106f66106f13660046106bb565b612097565b6106fe610452565b80610708816106d9565b0390f35b610458565b346107415761073d61072c6107273660046106bb565b6120a2565b610734610452565b918291826105c7565b0390f35b610458565b5f91031261075057565b61045c565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b61079661079f6020936107a49361078d81610755565b93848093610759565b95869101610762565b61076d565b0190565b6107bd9160208201915f818403910152610777565b90565b346107f0576107d0366004610746565b6107ec6107db61221a565b6107e3610452565b918291826107a8565b0390f35b610458565b346108265761082261081161080b3660046104c0565b90612230565b610819610452565b91829182610671565b0390f35b610458565b3461085b5761083b366004610746565b610857610846612252565b61084e610452565b918291826105c7565b0390f35b610458565b3461088f576108796108733660046104c0565b906122a9565b610881610452565b8061088b816106d9565b0390f35b610458565b90916060828403126108c9576108c66108af845f850161048b565b936108bd816020860161048b565b936040016104b1565b90565b61045c565b346108ff576108fb6108ea6108e4366004610894565b91612424565b6108f2610452565b91829182610671565b0390f35b610458565b90565b61091081610904565b0361091757565b5f80fd5b9050359061092882610907565b565b9060208282031261094357610940915f0161091b565b90565b61045c565b61095190610904565b9052565b9190610968905f60208501940190610948565b565b3461099a5761099661098561098036600461092a565b61249d565b61098d610452565b91829182610955565b0390f35b610458565b906109a990610518565b5f5260205260405f2090565b6109cb906109c66010915f9261099f565b61058b565b90565b346109fe576109fa6109e96109e43660046106bb565b6109b5565b6109f1610452565b918291826105c7565b0390f35b610458565b34610a3257610a1c610a163660046104c0565b906124bf565b610a24610452565b80610a2e816106d9565b0390f35b610458565b9190604083820312610a5f5780610a53610a5c925f860161091b565b9360200161048b565b90565b61045c565b34610a9357610a7d610a77366004610a37565b90612610565b610a85610452565b80610a8f816106d9565b0390f35b610458565b34610ac857610ac4610ab3610aae3660046106bb565b61276c565b610abb610452565b918291826105c7565b0390f35b610458565b60ff1690565b610adc90610acd565b9052565b9190610af3905f60208501940190610ad3565b565b34610b2557610b05366004610746565b610b21610b106128a7565b610b18610452565b91829182610ae0565b0390f35b610458565b34610b5a57610b3a366004610746565b610b56610b456128bd565b610b4d610452565b91829182610955565b0390f35b610458565b34610b8e57610b78610b72366004610a37565b906128d1565b610b80610452565b80610b8a816106d9565b0390f35b610458565b34610bc457610bc0610baf610ba93660046104c0565b9061294e565b610bb7610452565b918291826105c7565b0390f35b610458565b34610bf857610be2610bdc3660046104c0565b90612a6c565b610bea610452565b80610bf4816106d9565b0390f35b610458565b90610c0790610518565b5f5260205260405f2090565b5f1c90565b610c24610c2991610c13565b610570565b90565b610c369054610c18565b90565b60ff1690565b610c4b610c5091610c13565b610c39565b90565b610c5d9054610c3f565b90565b610c6b90600d610bfd565b610c765f8201610c2c565b91610c8f6002610c8860018501610c2c565b9301610c53565b90565b604090610cbb610cc29496959396610cb160608401985f8501906105ba565b60208301906105ba565b0190610664565b565b34610cf757610cf3610cdf610cda3660046106bb565b610c60565b610cea939193610452565b93849384610c92565b0390f35b610458565b90602082820312610d1557610d12915f016104b1565b90565b61045c565b34610d4857610d32610d2d366004610cfc565b612a78565b610d3a610452565b80610d44816106d9565b0390f35b610458565b34610d7d57610d5d366004610746565b610d79610d68612ab8565b610d70610452565b918291826105c7565b0390f35b610458565b34610db257610d92366004610746565b610dae610d9d612b62565b610da5610452565b918291826107a8565b0390f35b610458565b90565b610dce610dc9610dd392610db7565b6104ed565b61049a565b90565b610de26276a700610dba565b90565b610ded610dd6565b90565b34610e2057610e00366004610746565b610e1c610e0b610de5565b610e13610452565b918291826105c7565b0390f35b610458565b610e2e9061046b565b9052565b9190610e45905f60208501940190610e25565b565b34610e7757610e73610e62610e5d3660046106bb565b612bfe565b610e6a610452565b91829182610e32565b0390f35b610458565b34610eab57610e95610e8f3660046104c0565b90612d8b565b610e9d610452565b80610ea7816106d9565b0390f35b610458565b34610ee057610edc610ecb610ec6366004610cfc565b612e3f565b610ed3610452565b91829182610e32565b0390f35b610458565b34610f1357610efd610ef83660046106bb565b612e8b565b610f05610452565b80610f0f816106d9565b0390f35b610458565b610f31610f3692610f2c6012935f94610524565b610556565b61058b565b90565b34610f6a57610f66610f55610f4f3660046104c0565b90610f18565b610f5d610452565b918291826105c7565b0390f35b610458565b9091606082840312610fa457610fa1610f8a845f850161048b565b93610f9881602086016104b1565b936040016104b1565b90565b61045c565b34610fd857610fc2610fbc366004610f6f565b916131e2565b610fca610452565b80610fd4816106d9565b0390f35b610458565b3461100d57610fed366004610746565b611009610ff86131ef565b611000610452565b918291826105c7565b0390f35b610458565b63ffffffff1690565b61102490611012565b9052565b919061103b905f6020850194019061101b565b565b3461106d576110696110586110533660046106bb565b613211565b611060610452565b91829182611028565b0390f35b610458565b346110a25761109e61108d6110883660046106bb565b613226565b611095610452565b918291826105c7565b0390f35b610458565b5190565b60209181520190565b60200190565b6110c39061046b565b9052565b906110d4816020936110ba565b0190565b60200190565b906110fb6110f56110ee846110a7565b80936110ab565b926110b4565b905f5b81811061110b5750505090565b90919261112461111e60019286516110c7565b946110d8565b91019190916110fe565b6111439160208201915f8184039101526110de565b90565b3461117657611156366004610746565b611172611161613249565b611169610452565b9182918261112e565b0390f35b610458565b346111ab576111a76111966111913660046106bb565b613267565b61119e610452565b91829182610671565b0390f35b610458565b346111df576111c96111c33660046104c0565b906133cc565b6111d1610452565b806111db816106d9565b0390f35b610458565b34611214576111f4366004610746565b6112106111ff6133d8565b611207610452565b918291826105c7565b0390f35b610458565b346112495761124561123461122f3660046106bb565b613450565b61123c610452565b918291826105c7565b0390f35b610458565b3461127e5761125e366004610746565b61127a611269613465565b611271610452565b91829182610671565b0390f35b610458565b7f000000000000000000000000000000000000000000000000000000000000000090565b346112d7576112b7366004610746565b6112d36112c2611283565b6112ca610452565b918291826105c7565b0390f35b610458565b3461130a576112f46112ef366004610cfc565b6135b8565b6112fc610452565b80611306816106d9565b0390f35b610458565b60ff60f81b1690565b6113219061130f565b9052565b5190565b60209181520190565b60200190565b6113419061049a565b9052565b9061135281602093611338565b0190565b60200190565b9061137961137361136c84611325565b8093611329565b92611332565b905f5b8181106113895750505090565b9091926113a261139c6001928651611345565b94611356565b910191909161137c565b939591946113fd6113f2611411956113e46114079561141e9c9a6113d760e08c01925f8d0190611318565b8a820360208c0152610777565b9088820360408a0152610777565b9760608701906105ba565b6080850190610e25565b60a0830190610948565b60c081840391015261135c565b90565b3461145857611431366004610746565b61145461143c613640565b9361144b979597939193610452565b978897886113ac565b0390f35b610458565b7f84fe74c71a28b69aa960486ca0e8c1418c86e9ea2cd6b5849b95e2c8f407a67490565b61148961145d565b90565b346114bc5761149c366004610746565b6114b86114a7611481565b6114af610452565b91829182610955565b0390f35b610458565b7f9b12e0c5707e494915e58b0564f18aaad9b74ac69bfc815a1edadc8e4bd032eb90565b6114ed6114c1565b90565b3461152057611500366004610746565b61151c61150b6114e5565b611513610452565b91829182610955565b0390f35b610458565b346115555761155161154061153b366004610cfc565b6136ca565b611548610452565b918291826105c7565b0390f35b610458565b90565b61157161156c6115769261155a565b6104ed565b61049a565b90565b61158e6b033b2e3c9fd0803ce800000061155d565b90565b611599611579565b90565b346115cc576115ac366004610746565b6115c86115b7611591565b6115bf610452565b918291826105c7565b0390f35b610458565b34611602576115fe6115ed6115e7366004610a37565b90613711565b6115f5610452565b91829182610671565b0390f35b610458565b65ffffffffffff1690565b61161b90611607565b9052565b9190611632905f60208501940190611612565b565b3461166457611644366004610746565b61166061164f61373f565b611657610452565b9182918261161f565b0390f35b610458565b346116995761169561168461167f3660046106bb565b613753565b61168c610452565b918291826105c7565b0390f35b610458565b346116ce576116ae366004610746565b6116ca6116b9613869565b6116c1610452565b918291826107a8565b0390f35b610458565b34611703576116ff6116ee6116e93660046106bb565b61387f565b6116f6610452565b918291826105c7565b0390f35b610458565b90565b61171f61171a61172492611708565b6104ed565b61049a565b90565b61173c6b02e87669c308736a0400000061170b565b90565b611747611727565b90565b3461177a5761175a366004610746565b61177661176561173f565b61176d610452565b918291826105c7565b0390f35b610458565b90565b5f1b90565b61179b6117966117a09261177f565b611782565b610904565b90565b6117ac5f611787565b90565b6117b76117a3565b90565b346117ea576117ca366004610746565b6117e66117d56117af565b6117dd610452565b91829182610955565b0390f35b610458565b346118205761181c61180b6118053660046104c0565b906138ae565b611813610452565b91829182610671565b0390f35b610458565b611831600c5f9061058b565b90565b3461186457611844366004610746565b61186061184f611825565b611857610452565b918291826105c7565b0390f35b610458565b3461189a5761189661188561187f3660046104c0565b906138d0565b61188d610452565b918291826105c7565b0390f35b610458565b7f820372a9faf82db3cc5fc36ffab5f096eef69b95fbf50591e0d71447aa1ba70090565b6118cb61189f565b90565b346118fe576118de366004610746565b6118fa6118e96118c3565b6118f1610452565b91829182610955565b0390f35b610458565b346119335761192f61191e6119193660046106bb565b6138e6565b611926610452565b918291826105c7565b0390f35b610458565b3461196857611948366004610746565b6119646119536138fb565b61195b610452565b918291826105c7565b0390f35b610458565b61197681610acd565b0361197d57565b5f80fd5b9050359061198e8261196d565b565b909160c0828403126119ef576119a8835f840161048b565b926119b681602085016104b1565b926119c482604083016104b1565b926119ec6119d58460608501611981565b936119e3816080860161091b565b9360a00161091b565b90565b61045c565b34611a2957611a13611a07366004611990565b9493909392919261397b565b611a1b610452565b80611a25816106d9565b0390f35b610458565b611a379061065f565b9052565b90604080611a6f93611a535f8201515f860190611338565b611a6560208201516020860190611338565b0151910190611a2e565b565b9190611a84905f60608501940190611a3b565b565b34611ab657611ab2611aa1611a9c3660046106bb565b613a72565b611aa9610452565b91829182611a71565b0390f35b610458565b611ac48161065f565b03611acb57565b5f80fd5b90503590611adc82611abb565b565b9190604083820312611b065780611afa611b03925f860161048b565b93602001611acf565b90565b61045c565b34611b3a57611b24611b1e366004611ade565b90613b85565b611b2c610452565b80611b36816106d9565b0390f35b610458565b60e081830312611baa57611b55825f830161048b565b92611b63836020840161048b565b92611b7181604085016104b1565b92611b7f82606083016104b1565b92611ba7611b908460808501611981565b93611b9e8160a0860161091b565b9360c00161091b565b90565b61045c565b34611be457611bce611bc2366004611b3f565b95949094939193613c33565b611bd6610452565b80611be0816106d9565b0390f35b610458565b34611c1857611c02611bfc366004610a37565b90613d51565b611c0a610452565b80611c14816106d9565b0390f35b610458565b9190604083820312611c455780611c39611c42925f860161048b565b9360200161048b565b90565b61045c565b34611c7b57611c77611c66611c60366004611c1d565b90613d73565b611c6e610452565b918291826105c7565b0390f35b610458565b611c8981611012565b03611c9057565b5f80fd5b90503590611ca182611c80565b565b9190604083820312611ccb5780611cbf611cc8925f860161048b565b93602001611c94565b90565b61045c565b611cd990611607565b9052565b60018060d01b031690565b611cf190611cdd565b9052565b90602080611d1793611d0d5f8201515f860190611cd0565b0151910190611ce8565b565b9190611d2c905f60408501940190611cf5565b565b34611d5f57611d5b611d4a611d44366004611ca3565b90613de1565b611d52610452565b91829182611d19565b0390f35b610458565b7fcce296b040332a080e6df13515a3ec2869e21cd20f7344af0987ddb938d8bd2190565b611d90611d64565b90565b34611dc357611da3366004610746565b611dbf611dae611d88565b611db6610452565b91829182610955565b0390f35b610458565b5f80fd5b5f90565b634e487b7160e01b5f52601160045260245ffd5b611df0611df691611cdd565b91611cdd565b019060018060d01b038211611e0757565b611dd0565b90611e1f91611e19611dcc565b50611de4565b90565b611e2e611e3491611cdd565b91611cdd565b90039060018060d01b038211611e4657565b611dd0565b90611e5e91611e58611dcc565b50611e22565b90565b5f90565b611e6d611e61565b5080611e88611e82630cccc66560e21b610612565b91610612565b148015611eac575b908115611e9c575b5090565b611ea69150613df7565b5f611e98565b5080611ec7611ec163b2752ac960e01b610612565b91610612565b14611e90565b611ee690611ee1611edc611d64565b613e37565b611fc4565b565b611efc611ef7611f019261177f565b6104ed565b610460565b90565b611f0d90611ee8565b90565b90565b1b90565b91906008611f32910291611f2c5f1984611f13565b92611f13565b9181191691161790565b90565b9190611f55611f50611f5d9361053a565b611f3c565b908354611f17565b9055565b5f90565b611f7791611f71611f61565b91611f3f565b565b60025f91611f8983808301611f65565b611f968360018301611f65565b0155565b634e487b7160e01b5f525f60045260245ffd5b905f03611fbf57611fbd90611f79565b565b611f9a565b80611fdf611fd9611fd45f611f04565b61046b565b9161046b565b1461207b57612001611ffb611ff4600e611f10565b8390613e92565b1561065f565b61205c5761201a5f612015600d8490610bfd565b611fad565b6120447f5d9d5034656cb3ebfb0655057cd7f9b4077a9b42ff42ce223cbac5bc586d212691610518565b9061204d610452565b80612057816106d9565b0390a2565b612077905f918291636585b60d60e01b835260048301610e32565b0390fd5b5f63d92e233d60e01b815280612093600482016106d9565b0390fd5b6120a090611ecd565b565b6120b96120be916120b1611f61565b50601061099f565b610c2c565b90565b606090565b634e487b7160e01b5f52602260045260245ffd5b90600160028304921680156120fa575b60208310146120f557565b6120c6565b91607f16916120ea565b60209181520190565b5f5260205f2090565b905f9291805490612130612129836120da565b8094612104565b916001811690815f14612187575060011461214b575b505050565b612158919293945061210d565b915f925b81841061216f57505001905f8080612146565b6001816020929593955484860152019101929061215c565b92949550505060ff19168252151560200201905f8080612146565b906121ac91612116565b90565b634e487b7160e01b5f52604160045260245ffd5b906121cd9061076d565b810190811067ffffffffffffffff8211176121e757604052565b6121af565b9061220c612205926121fc610452565b938480926121a2565b03836121c3565b565b612217906121ec565b90565b6122226120c1565b5061222d600361220e565b90565b61224d9161223c611e61565b50612245613ecc565b919091613ed9565b600190565b61225a611f61565b506122656002610c2c565b90565b61227c6122776122819261177f565b6104ed565b61049a565b90565b6122936122999193929361049a565b9261049a565b82018092116122a457565b611dd0565b806122c46122be6122b95f611f04565b61046b565b9161046b565b1461240857816122dc6122d65f612268565b9161049a565b146123ec576122f36122ec612252565b8390612284565b61230c612306612301611579565b61049a565b9161049a565b116123d05761231c338390613f1e565b612327338390614114565b61232f613465565b806123af575b612393576123448183906141c8565b339061238e61237c6123767fde22baff038e3a3e08407cbdf617deed74e869a7ba517df611e33131c6e6ea0493610518565b93610518565b93612385610452565b918291826105c7565b0390a3565b5f6336e278fd60e21b8152806123ab600482016106d9565b0390fd5b506123cb6123c56123be61145d565b3390613711565b1561065f565b612335565b5f63177e3fc360e01b8152806123e8600482016106d9565b0390fd5b5f631f2a200560e01b815280612404600482016106d9565b0390fd5b5f63d92e233d60e01b815280612420600482016106d9565b0390fd5b9161244e92612431611e61565b5061244661243d613ecc565b82908491614234565b9190916142c0565b600190565b5f90565b61246090610904565b90565b9061246d90612457565b5f5260205260405f2090565b90565b61248861248d91610c13565b612479565b90565b61249a905461247c565b90565b60016124b66124bc926124ae612453565b506005612463565b01612490565b90565b806124da6124d46124cf5f611f04565b61046b565b9161046b565b146125ca57816124f26124ec5f612268565b9161049a565b146125ae5761250233839061435d565b3361251561250f8361046b565b9161046b565b03612575575b612526818390614556565b339061257061255e6125587fb90795a66650155983e242cac3e1ac1a4dc26f8ed2987f3ce416a34e00111fd493610518565b93610518565b93612567610452565b918291826105c7565b0390a3565b612580813390613d73565b61259261258c5f612268565b9161049a565b0361259d575b61251b565b6125a981338491614234565b612598565b5f631f2a200560e01b8152806125c6600482016106d9565b0390fd5b5f63d92e233d60e01b8152806125e2600482016106d9565b0390fd5b90612601916125fc6125f78261249d565b613e37565b612603565b565b9061260d916145b5565b50565b9061261a916125e6565b565b906126269061049a565b9052565b906126349061065f565b9052565b9061264b612644610452565b92836121c3565b565b6126576060612638565b90565b906126a96126a0600261266b61264d565b9461268261267a5f8301610c2c565b5f880161261c565b61269a61269160018301610c2c565b6020880161261c565b01610c53565b6040840161262a565b565b6126b49061265a565b90565b90565b6126ce6126c96126d3926126b7565b6104ed565b61049a565b90565b634e487b7160e01b5f52601260045260245ffd5b6126f66126fc9161049a565b9161049a565b908115612707570490565b6126d6565b6001612718910161049a565b90565b90565b61273261272d6127379261271b565b6104ed565b61049a565b90565b61274961274f9193929361049a565b9261049a565b820391821161275a57565b611dd0565b612769905161049a565b90565b612774611f61565b50612789612784600d8390610bfd565b6126ab565b9061279f42612799610e106126ba565b906126ea565b6127a85f612268565b906127b25f612268565b5b806127c76127c1601861271e565b9161049a565b101561283357816127e06127da8361049a565b9161049a565b10156127f5575b6127f09061270c565b6127b3565b9161282b6127f09161282561282061280f60128990610524565b61281a87899061273a565b90610556565b610c2c565b90612284565b9290506127e7565b505090506128436020830161275f565b61285561284f8361049a565b9161049a565b115f146128745761286b6020612870930161275f565b61273a565b5b90565b505061287f5f612268565b612871565b5f90565b90565b61289f61289a6128a492612888565b6104ed565b610acd565b90565b6128af612884565b506128ba601261288b565b90565b6128c5612453565b506128ce614661565b90565b90806128ec6128e66128e1613ecc565b61046b565b9161046b565b036128fd576128fa9161471b565b50565b5f63334bd91960e11b815280612915600482016106d9565b0390fd5b9061292390610518565b5f5260205260405f2090565b90565b61294661294161294b92611cdd565b6104ed565b61049a565b90565b6129859161297a61297461296f61298094612967611f61565b50600a612919565b61292f565b916147fc565b90614911565b612932565b90565b906129a29161299d6129986114c1565b613e37565b6129a4565b565b90816129c06129ba6129b55f611f04565b61046b565b9161046b565b14612a5057806129d86129d25f612268565b9161049a565b14612a34576129ef6129e8612252565b8290612284565b612a08612a026129fd611579565b61049a565b9161049a565b11612a1857612a16916141c8565b565b5f63177e3fc360e01b815280612a30600482016106d9565b0390fd5b5f631f2a200560e01b815280612a4c600482016106d9565b0390fd5b5f63d92e233d60e01b815280612a68600482016106d9565b0390fd5b90612a7691612988565b565b80612a8b612a855f612268565b9161049a565b14612a9c57612a9a9033614556565b565b5f631f2a200560e01b815280612ab4600482016106d9565b0390fd5b612ac0611f61565b50612ada612acc611579565b612ad4612252565b9061273a565b90565b67ffffffffffffffff8111612afb57612af760209161076d565b0190565b6121af565b90612b12612b0d83612add565b612638565b918252565b5f7f6d6f64653d626c6f636b6e756d6265722666726f6d3d64656661756c74000000910152565b612b48601d612b00565b90612b5560208301612b17565b565b612b5f612b3e565b90565b612b6a6120c1565b50612b7361373f565b612b8c612b86612b81614a38565b611607565b91611607565b03612b9c57612b99612b57565b90565b5f6301bfc1c560e61b815280612bb4600482016106d9565b0390fd5b5f90565b90612bc690610518565b5f5260205260405f2090565b60018060a01b031690565b612be9612bee91610c13565b612bd2565b90565b612bfb9054612bdd565b90565b612c15612c1a91612c0d612bb8565b506009612bbc565b612bf1565b90565b90612c3791612c32612c2d61189f565b613e37565b612c6f565b565b90612c455f1991611782565b9181191691161790565b90612c64612c5f612c6b9261053a565b611f3c565b8254612c39565b9055565b80612c8a612c84612c7f5f611f04565b61046b565b9161046b565b14612d6f5781612ca2612c9c5f612268565b9161049a565b14612d5357612cc4612cbe612cb7600e611f10565b8390614a4d565b1561065f565b612d3457612cf082612cea612cdb6010859061099f565b91612ce583610c2c565b612284565b90612c4f565b612d2f612d1d7f9ca03dbd5193fbb7974173cedd0bdf6841dd14c3cbfa735aab77ff1dd1139fb392610518565b92612d26610452565b918291826105c7565b0390a2565b612d4f905f918291636585b60d60e01b835260048301610e32565b0390fd5b5f631f2a200560e01b815280612d6b600482016106d9565b0390fd5b5f63d92e233d60e01b815280612d87600482016106d9565b0390fd5b90612d9591612c1d565b565b60207f6f7574206f6620626f756e647300000000000000000000000000000000000000917f53796e646963617465546f6b656e43726f7373636861696e3a20696e646578205f8201520152565b612df1602d604092610759565b612dfa81612d97565b0190565b612e139060208101905f818303910152612de4565b90565b15612e1d57565b612e25610452565b62461bcd60e51b815280612e3b60048201612dfe565b0390fd5b612e8890612e4b612bb8565b50612e7981612e73612e6d612e68612e63600e611f10565b614a87565b61049a565b9161049a565b10612e16565b612e83600e611f10565b614ad6565b90565b612e9c90612e97613ecc565b614b4c565b565b90612eb99291612eb4612eaf611d64565b613e37565b612f95565b565b916020612edc929493612ed560408201965f8301906105ba565b01906105ba565b565b612ee86060612638565b90565b612ef5905161065f565b90565b90612f0460ff91611782565b9181191691161790565b612f179061065f565b90565b90565b90612f32612f2d612f3992612f0e565b612f1a565b8254612ef8565b9055565b90612f8160406002612f8794612f605f8201612f5a5f880161275f565b90612c4f565b612f7960018201612f736020880161275f565b90612c4f565b019201612eeb565b90612f1d565b565b90612f9391612f3d565b565b80612fb0612faa612fa55f611f04565b61046b565b9161046b565b146131c65780612fc8612fc23361046b565b9161046b565b146131aa57803b612fe1612fdb5f612268565b9161049a565b1461318e5781612ffa612ff45f1961049a565b9161049a565b14158061316d575b613151578261301a6130145f1961049a565b9161049a565b141580613130575b6131155761303a613033600e611f10565b8290614bd7565b6130ca575b613084826130738561306a600191613061613058612ede565b955f870161261c565b6020850161261c565b6040830161262a565b61307f600d8490610bfd565b612f89565b90916130b07faa807d0abf30d91968c7478c66b6d82521a106af13eda036e2036da9af16895892610518565b926130c56130bc610452565b92839283612ebb565b0390a2565b808290846130f87fdb03f97dc5840a71e69be7470e4761af10a1237973e81c12d0dc2813895a652692610518565b9261310d613104610452565b92839283612ebb565b0390a261303f565b5f6258ccad60e81b81528061312c600482016106d9565b0390fd5b508261314b613145613140611579565b61049a565b9161049a565b11613022565b5f630a395c0160e01b815280613169600482016106d9565b0390fd5b508161318861318261317d611579565b61049a565b9161049a565b11613002565b5f63412a18ed60e11b8152806131a6600482016106d9565b0390fd5b5f63fb8ce8c960e01b8152806131c2600482016106d9565b0390fd5b5f63d92e233d60e01b8152806131de600482016106d9565b0390fd5b906131ed9291612e9e565b565b6131f7611f61565b5061320a613205600e611f10565b614a87565b90565b5f90565b6132239061321d61320d565b50614c11565b90565b61323c61324191613235611f61565b505f61099f565b610c2c565b90565b606090565b613251613244565b5061326461325f600e611f10565b614c40565b90565b61326f611e61565b50613297613287613282600d8490610bfd565b6126ab565b91613292600e611f10565b614a4d565b90816132a2575b5090565b6132af9150604001612eeb565b5f61329e565b906132cf916132ca6132c561145d565b613e37565b6132d1565b565b806132ec6132e66132e15f611f04565b61046b565b9161046b565b146133b057816133046132fe5f612268565b9161049a565b146133945761331a613314613465565b1561065f565b61337857613329818390614556565b339061337361336161335b7fbef4f81c1814c641ede85ebaacf19d048b2c5b55980adfa6ef0f956c651335a293610518565b93610518565b9361336a610452565b918291826105c7565b0390a3565b5f63b8b5ca2d60e01b815280613390600482016106d9565b0390fd5b5f631f2a200560e01b8152806133ac600482016106d9565b0390fd5b5f63d92e233d60e01b8152806133c8600482016106d9565b0390fd5b906133d6916132b5565b565b6133e0611f61565b506133eb600c610c2c565b6133fd6133f75f612268565b9161049a565b14801561342c575b6134205761341d613416600c610c2c565b429061273a565b90565b6134295f612268565b90565b504261344961344361343e600c610c2c565b61049a565b9161049a565b1015613405565b6134629061345c611f61565b50614c68565b90565b61346d611e61565b50613478600c610c2c565b61348a6134845f612268565b9161049a565b141580613495575b90565b50426134b26134ac6134a7600c610c2c565b61049a565b9161049a565b10613492565b6134d1906134cc6134c76117a3565b613e37565b6134d3565b565b806134e66134e04261049a565b9161049a565b111561359c578061351f6135197f000000000000000000000000000000000000000000000000000000000000000061049a565b9161049a565b116135805761352e600c610c2c565b61353982600c612c4f565b9033906135667fdd6896dcf1d4b311cca87dd19bbba2ea9ce2f867c1568878a0438a66a1afeeec92610518565b9261357b613572610452565b92839283612ebb565b0390a2565b5f63ef69af6560e01b815280613598600482016106d9565b0390fd5b5f63a565835360e01b8152806135b4600482016106d9565b0390fd5b6135c1906134b8565b565b5f90565b606090565b6135d59061050c565b90565b67ffffffffffffffff81116135f05760208091020190565b6121af565b90613607613602836135d8565b612638565b918252565b369037565b9061363661361e836135f5565b9260208061362c86936135d8565b920191039061360c565b565b600f60f81b90565b6136486135c3565b506136516120c1565b5061365a6120c1565b50613663611f61565b5061366c612bb8565b50613675612453565b5061367e6135c7565b50613687614c80565b90613690614cc0565b90469061369c306135cc565b906136a65f611787565b906136b86136b35f612268565b613611565b906136c1613638565b96959493929190565b6136f36136f8916136d9611f61565b506136ed6136e7600b61292f565b916147fc565b90614911565b612932565b90565b9061370590610518565b5f5260205260405f2090565b613738915f61372d61373393613725611e61565b506005612463565b016136fb565b610c53565b90565b5f90565b61374761373b565b50613750614a38565b90565b61375b611f61565b5061377061376b600d8390610bfd565b6126ab565b9061378642613780610e106126ba565b906126ea565b61378f5f612268565b906137995f612268565b5b806137ae6137a8601861271e565b9161049a565b101561381a57816137c76137c18361049a565b9161049a565b10156137dc575b6137d79061270c565b61379a565b916138126137d79161380c6138076137f660118990610524565b61380187899061273a565b90610556565b610c2c565b90612284565b9290506137ce565b505090506138295f830161275f565b61383b6138358361049a565b9161049a565b115f14613859576138505f613855930161275f565b61273a565b5b90565b50506138645f612268565b613856565b6138716120c1565b5061387c600461220e565b90565b6138a66138a161389c6138ab93613894611f61565b50600a612919565b61292f565b614d00565b612932565b90565b6138cb916138ba611e61565b506138c3613ecc565b9190916142c0565b600190565b906138e3916138dd611f61565b5061294e565b90565b6138f8906138f2611f61565b5061387f565b90565b613903611f61565b5061390c612252565b90565b7fe48329057bfd03d55e49b547132e39cffd9c1820ad7b9d4c5307691425d15adf90565b61396861396f9461395e606094989795613954608086019a5f870190610948565b6020850190610e25565b60408301906105ba565b01906105ba565b565b60200190565b5190565b939594909291954261399561398f8961049a565b9161049a565b11613a0e5791613a0091613a07936139f7613a0c98996139df6139b661390f565b6139d08b938b6139c4610452565b95869460208601613933565b602082018103825203826121c3565b6139f16139eb82613977565b91613971565b20614d75565b92909192614d92565b9182614ddc565b614b4c565b565b613a29875f918291632341d78760e11b8352600483016105c7565b0390fd5b5f90565b5f90565b613a3d61264d565b906020808084613a4b613a2d565b815201613a56613a2d565b815201613a61613a31565b81525050565b613a6f613a35565b90565b613a89613a8e91613a81613a67565b50600d610bfd565b6126ab565b90565b90613aab91613aa6613aa1611d64565b613e37565b613aad565b565b80613ac8613ac2613abd5f611f04565b61046b565b9161046b565b14613b6957613aea613ae4613add600e611f10565b8390614a4d565b1561065f565b613b4a57613b06826002613b00600d8590610bfd565b01612f1d565b613b45613b337f9c8668db324845065d2b9a2a183bd3141f63018f548282daf18da49ccbf88c3392610518565b92613b3c610452565b91829182610671565b0390a2565b613b65905f918291636585b60d60e01b835260048301610e32565b0390fd5b5f63d92e233d60e01b815280613b81600482016106d9565b0390fd5b90613b8f91613a91565b565b7f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c990565b9194613bfd613c0792989795613bf360a096613be9613c0e9a613bdf60c08a019e5f8b0190610948565b6020890190610e25565b6040870190610e25565b60608501906105ba565b60808301906105ba565b01906105ba565b565b916020613c31929493613c2a60408201965f830190610e25565b0190610e25565b565b969591939294909442613c4e613c488361049a565b9161049a565b11613d085790613cb7613cc0949392613c9f613c68613b91565b613c908c80948c91613c7a8d91614e1f565b9192613c84610452565b97889660208801613bb5565b602082018103825203826121c3565b613cb1613cab82613977565b91613971565b20614d75565b92909192614d92565b80613cd3613ccd8761046b565b9161046b565b03613ce85750613ce69293919091613ed9565b565b8490613d045f9283926325c0072360e11b845260048401613c10565b0390fd5b613d23905f91829163313c898160e11b8352600483016105c7565b0390fd5b90613d4291613d3d613d388261249d565b613e37565b613d44565b565b90613d4e9161471b565b50565b90613d5b91613d27565b565b90613d6790610518565b5f5260205260405f2090565b613d9891613d8e613d9392613d86611f61565b506001613d5d565b61099f565b610c2c565b90565b613da56040612638565b90565b5f90565b5f90565b613db8613d9b565b9060208083613dc5613da8565b815201613dd0613dac565b81525050565b613dde613db0565b90565b90613df491613dee613dd6565b50614e52565b90565b613dff611e61565b5080613e1a613e14637965db0b60e01b610612565b91610612565b14908115613e27575b5090565b613e319150614e7a565b5f613e23565b613e4990613e43613ecc565b90614ec3565b565b613e54906104f0565b90565b613e6b613e66613e7092610460565b6104ed565b61049a565b90565b613e87613e82613e8c9261049a565b611782565b610904565b90565b90565b90613ec4613ebe613eb9613eb45f613ec996613eac611e61565b500194613e4b565b613e57565b613e73565b91613e8f565b615040565b90565b613ed4612bb8565b503390565b91613ee79291600192615146565b565b90565b604090613f15613f1c9496959396613f0b60608401985f850190610e25565b60208301906105ba565b01906105ba565b565b613f32613f2d600d8390610bfd565b613ee9565b91613f50613f4a613f43600e611f10565b8490614a4d565b1561065f565b80156140f9575b6140da57613f7042613f6a610e106126ba565b906126ea565b613f795f612268565b91613f835f612268565b5b80613f98613f92601861271e565b9161049a565b10156140045782613fb1613fab8361049a565b9161049a565b1015613fc6575b613fc19061270c565b613f84565b92613ffc613fc191613ff6613ff1613fe060118a90610524565b613feb888a9061273a565b90610556565b610c2c565b90612284565b939050613fb8565b5091909293614014828490612284565b61403061402a6140255f8501610c2c565b61049a565b9161049a565b1161406a575050614053614068939261404e61406293946011610524565b610556565b9161405d83610c2c565b612284565b90612c4f565b565b8493506140785f8201610c2c565b61408a6140848461049a565b9161049a565b115f146140c7576140c3916140a35f6140a89301610c2c565b61273a565b5b9291925f9384936340ed367b60e01b855260048501613eec565b0390fd5b50506140c36140d55f612268565b6140a9565b6140f5825f918291636585b60d60e01b835260048301610e32565b0390fd5b5061410f61410960028501610c53565b1561065f565b613f57565b6141286141236010839061099f565b610c2c565b61413b614135849261049a565b9161049a565b116141ac57614168826141626141536010859061099f565b9161415d83610c2c565b61273a565b90612c4f565b6141a76141957fbc23ec7f1313150b047bff83d0845b0564baa134698dd11bb0acd0f7d416de7d92610518565b9261419e610452565b918291826105c7565b0390a2565b5f631eb7845760e21b8152806141c4600482016106d9565b0390fd5b806141e36141dd6141d85f611f04565b61046b565b9161046b565b146141ff576141fd916141f55f611f04565b919091615255565b565b61422261420b5f611f04565b5f91829163ec442f0560e01b835260048301610e32565b0390fd5b90614231910361049a565b90565b929192614242818390613d73565b90816142576142515f1961049a565b9161049a565b10614264575b5050509050565b816142776142718761049a565b9161049a565b1061429d57614294939461428c919392614226565b905f92615146565b805f808061425d565b506142bc849291925f938493637dc7a0d960e11b855260048501613eec565b0390fd5b91826142dc6142d66142d15f611f04565b61046b565b9161046b565b1461433657816142fc6142f66142f15f611f04565b61046b565b9161046b565b1461430f5761430d92919091615255565b565b61433261431b5f611f04565b5f91829163ec442f0560e01b835260048301610e32565b0390fd5b6143596143425f611f04565b5f918291634b637e8f60e11b835260048301610e32565b0390fd5b61437161436c600d8390610bfd565b613ee9565b9161438f614389614382600e611f10565b8490614a4d565b1561065f565b801561453b575b61451c576143af426143a9610e106126ba565b906126ea565b6143b85f612268565b916143c25f612268565b5b806143d76143d1601861271e565b9161049a565b101561444357826143f06143ea8361049a565b9161049a565b1015614405575b6144009061270c565b6143c3565b9261443b6144009161443561443061441f60128a90610524565b61442a888a9061273a565b90610556565b610c2c565b90612284565b9390506143f7565b5091909293614453828490612284565b61447061446a61446560018501610c2c565b61049a565b9161049a565b116144aa5750506144936144a8939261448e6144a293946012610524565b610556565b9161449d83610c2c565b612284565b90612c4f565b565b8493506144b960018201610c2c565b6144cb6144c58461049a565b9161049a565b115f1461450957614505916144e560016144ea9301610c2c565b61273a565b5b9291925f9384936372ff4bd160e11b855260048501613eec565b0390fd5b50506145056145175f612268565b6144eb565b614537825f918291636585b60d60e01b835260048301610e32565b0390fd5b5061455161454b60028501610c53565b1561065f565b614396565b908161457261456c6145675f611f04565b61046b565b9161046b565b1461458e5761458c91906145855f611f04565b9091615255565b565b6145b161459a5f611f04565b5f918291634b637e8f60e11b835260048301610e32565b0390fd5b6145bd611e61565b506145d26145cc828490613711565b1561065f565b5f1461465b576145fa60016145f55f6145ed60058690612463565b0185906136fb565b612f1d565b90614603613ecc565b9061464061463a6146347f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d95612457565b92610518565b92610518565b92614649610452565b80614653816106d9565b0390a4600190565b50505f90565b614669612453565b50614673306135cc565b6146a561469f7f000000000000000000000000000000000000000000000000000000000000000061046b565b9161046b565b14806146e1575b5f146146d6577f000000000000000000000000000000000000000000000000000000000000000090565b6146de615370565b90565b504661471561470f7f000000000000000000000000000000000000000000000000000000000000000061049a565b9161049a565b146146ac565b614723611e61565b5061472f818390613711565b5f146147b7576147565f6147515f61474960058690612463565b0185906136fb565b612f1d565b9061475f613ecc565b9061479c6147966147907ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b95612457565b92610518565b92610518565b926147a5610452565b806147af816106d9565b0390a4600190565b50505f90565b6147d16147cc6147d692611607565b6104ed565b61049a565b90565b9160206147fa9294936147f360408201965f8301906105ba565b0190611612565b565b61480461373b565b5061480d61373f565b8161482061481a836147bd565b9161049a565b1015614833575061483090615479565b90565b9061484e5f928392637669fc0f60e11b8452600484016147d9565b0390fd5b5490565b90565b61486d61486861487292614856565b6104ed565b61049a565b90565b90565b65ffffffffffff1690565b61488f61489491610c13565b614878565b90565b6148a19054614883565b90565b90565b6148bb6148b66148c0926148a4565b6104ed565b61049a565b90565b60301c90565b60018060d01b031690565b6148e06148e5916148c3565b6148c9565b90565b6148f290546148d4565b90565b61490961490461490e9261177f565b6104ed565b611cdd565b90565b906149659061491e611dcc565b5061492a5f8401614852565b6149335f612268565b9080806149496149436005614859565b9161049a565b116149c6575b50906149605f860193919293614875565b615ab4565b806149786149725f612268565b9161049a565b145f1461498e57505061498a5f6148f5565b5b90565b6149bb5f916149b66149b0846149c19601926149aa60016148a7565b9061273a565b91614875565b615aaa565b016148e8565b61498b565b806149d46149da929161573f565b9061273a565b9083614a0c614a06614a015f6149fb818c016149f68991614875565b615aaa565b01614897565b611607565b91611607565b105f14614a1d5750905b905f61494f565b9150614a3390614a2d60016148a7565b90612284565b614a16565b614a4061373b565b50614a4a43615479565b90565b90614a7f614a79614a74614a6f5f614a8496614a67611e61565b500194613e4b565b613e57565b613e73565b91613e8f565b615b43565b90565b614a9e5f614aa392614a97611f61565b5001613e8f565b615b78565b90565b614ab2614ab791610c13565b61053a565b90565b614ace614ac9614ad39261049a565b6104ed565b610460565b90565b614b01614afc614b0b93614af75f614b0695614af0612bb8565b5001613e8f565b615b8f565b614aa6565b614aba565b61050c565b90565b90614b1f60018060a01b0391611782565b9181191691161790565b90565b90614b41614b3c614b4892610518565b614b29565b8254614b0e565b9055565b90614bd591614bcf614b5d82612bfe565b614b7284614b6d60098690612bbc565b614b2c565b82818590614bb2614bac614ba67f3134e8a2e6d97e929a7e54011ea5485d7d196dd5f0ba4d4ef95803e8e3fc257f95610518565b92610518565b92610518565b92614bbb610452565b80614bc5816106d9565b0390a49291615bb0565b91615bc8565b565b90614c09614c03614bfe614bf95f614c0e96614bf1611e61565b500194613e4b565b613e57565b613e73565b91613e8f565b615dab565b90565b614c38614c33614c2e614c3d93614c2661320d565b50600a612919565b61292f565b615e0e565b615e8d565b90565b614c575f614c5c92614c50613244565b5001613e8f565b615faf565b614c64613244565b5090565b614c7a90614c74611f61565b50615fc6565b90565b90565b614c886120c1565b50614cbd7f0000000000000000000000000000000000000000000000000000000000000000614cb76006614c7d565b906160e1565b90565b614cc86120c1565b50614cfd7f0000000000000000000000000000000000000000000000000000000000000000614cf76007614c7d565b906160e1565b90565b614d08611dcc565b50614d145f8201614852565b80614d27614d215f612268565b9161049a565b145f14614d3d575050614d395f6148f5565b5b90565b614d6a5f91614d65614d5f84614d70960192614d5960016148a7565b9061273a565b91614875565b615aaa565b016148e8565b614d3a565b614d8f90614d81612453565b50614d8a614661565b61612f565b90565b92614dad92614db694614da3612bb8565b50929091926161e1565b9092919261630c565b90565b916020614dda929493614dd360408201965f830190610e25565b01906105ba565b565b614de581614e1f565b91614df8614df28461049a565b9161049a565b03614e01575050565b614e1b5f9283926301d4b62360e61b845260048401614db9565b0390fd5b614e3390614e2b611f61565b50600861099f565b614e4f614e3f82610c2c565b91614e498361270c565b90612c4f565b90565b90614e72614e6d614e7793614e65613dd6565b50600a612919565b61292f565b61646e565b90565b614e82611e61565b50614e9c614e966301ffc9a760e01b610612565b91610612565b1490565b916020614ec1929493614eba60408201965f830190610e25565b0190610948565b565b90614ed8614ed2838390613711565b1561065f565b614ee0575050565b614efa5f92839263e2517d3f60e01b845260048401614ea0565b0390fd5b90614f0890612457565b5f5260205260405f2090565b5490565b634e487b7160e01b5f52603260045260245ffd5b5f5260205f2090565b614f3e81614f14565b821015614f5857614f50600191614f2c565b910201905f90565b614f18565b614f6d906008614f72930261056c565b612479565b90565b90614f809154614f5d565b90565b614f8c90610c13565b90565b9190614fa5614fa0614fad93612457565b614f83565b908354611f17565b9055565b90565b634e487b7160e01b5f52603160045260245ffd5b5490565b5f5260205f2090565b614fde81614fc8565b821015614ff857614ff0600191614fcc565b910201905f90565b614f18565b61500f91615009612453565b91614f8f565b565b61501a81614fc8565b801561503b5760019003906150386150328383614fd5565b90614ffd565b55565b614fb4565b615048611e61565b5061505f61505a600183018490614efe565b610c2c565b908161507361506d5f612268565b9161049a565b14155f1461513f576150f19260016150ec928461509a5f96615094856148a7565b9061273a565b6150b76150a8888501614f14565b6150b1866148a7565b9061273a565b816150ca6150c48361049a565b9161049a565b036150f6575b5050506150e66150e1868301614fb1565b615011565b01614efe565b611f65565b600190565b6151379261512961511561510f615132948c8901614f35565b90614f75565b9361512385918c8901614f35565b90614f8f565b91858501614efe565b612c4f565b5f80806150d0565b5050505f90565b90928161516361515d6151585f611f04565b61046b565b9161046b565b1461522e578361518361517d6151785f611f04565b61046b565b9161046b565b14615207576151a7836151a261519b60018690613d5d565b879061099f565b612c4f565b6151b1575b505050565b9190916151fc6151ea6151e47f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92593610518565b93610518565b936151f3610452565b918291826105c7565b0390a35f80806151ac565b61522a6152135f611f04565b5f918291634a1406b160e11b835260048301610e32565b0390fd5b61525161523a5f611f04565b5f91829163e602df0560e01b835260048301610e32565b0390fd5b918261527161526b6152665f611f04565b61046b565b9161046b565b1415806152dc575b61528c575b61528a9291909161648f565b565b615294613465565b806152bb575b1561527e575f6336e278fd60e21b8152806152b7600482016106d9565b0390fd5b506152d76152d16152ca61145d565b3390613711565b1561065f565b61529a565b50816152f86152f26152ed5f611f04565b61046b565b9161046b565b1415615279565b7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f90565b9095949261536e9461535d6153679261535360809661534960a088019c5f890190610948565b6020870190610948565b6040850190610948565b60608301906105ba565b0190610e25565b565b615378612453565b506153816152ff565b6153f87f0000000000000000000000000000000000000000000000000000000000000000916153e97f0000000000000000000000000000000000000000000000000000000000000000466153d4306135cc565b916153dd610452565b96879560208701615323565b602082018103825203826121c3565b61540a61540482613977565b91613971565b2090565b90565b61542561542061542a9261540e565b6104ed565b610acd565b90565b61543690615411565b9052565b91602061545b92949361545460408201965f83019061542d565b01906105ba565b565b61547161546c6154769261049a565b6104ed565b611607565b90565b61548161373b565b508061549b61549565ffffffffffff6147bd565b9161049a565b116154ac576154a99061545d565b90565b60306154c85f9283926306dfcc6560e41b84526004840161543a565b0390fd5b90565b6154e36154de6154e8926154cc565b6104ed565b61049a565b90565b90565b6155026154fd615507926154eb565b6104ed565b610acd565b90565b6155299061552361551d61552e94610acd565b9161049a565b9061056c565b61049a565b90565b90565b61554861554361554d92615531565b6104ed565b610acd565b90565b61556f9061556961556361557494610acd565b9161049a565b90611f13565b61049a565b90565b90565b61558e61558961559392615577565b6104ed565b61049a565b90565b90565b6155ad6155a86155b292615596565b6104ed565b610acd565b90565b90565b6155cc6155c76155d1926155b5565b6104ed565b61049a565b90565b90565b6155eb6155e66155f0926155d4565b6104ed565b610acd565b90565b90565b61560a61560561560f926155f3565b6104ed565b61049a565b90565b90565b61562961562461562e92615612565b6104ed565b610acd565b90565b90565b61564861564361564d92615631565b6104ed565b61049a565b90565b90565b61566761566261566c92615650565b6104ed565b610acd565b90565b61568361567e615688926155d4565b6104ed565b61049a565b90565b90565b6156a261569d6156a79261568b565b6104ed565b610acd565b90565b6156be6156b96156c392615650565b6104ed565b61049a565b90565b6156da6156d56156df926148a4565b6104ed565b610acd565b90565b90565b6156f96156f46156fe926156e2565b6104ed565b61049a565b90565b9061570c910261049a565b90565b61571b6157219161049a565b9161049a565b90811561572c570490565b6126d6565b9061573c910161049a565b90565b615747611f61565b508061575c61575660016148a7565b9161049a565b1115615aa7578061597161594e61593e61592e61591e61590e6158fe6158ee6158de6158ce6158be8b6158b86158b16159779f6158916158816158a1926157a360016148a7565b90806157bb6157b5600160801b6154cf565b9161049a565b1015615a79575b806157de6157d86801000000000000000061557a565b9161049a565b1015615a4b575b806157fd6157f76401000000006155b8565b9161049a565b1015615a1d575b8061581a615814620100006155f6565b9161049a565b10156159ef575b80615836615830610100615634565b9161049a565b10156159c1575b8061585161584b601061566f565b9161049a565b1015615993575b61586b61586560046156aa565b9161049a565b101561597a575b61587c60036156e5565b615701565b61588b60016156c6565b9061550a565b61589b818661570f565b90615731565b6158ab60016156c6565b9061550a565b809261570f565b90615731565b6158c860016156c6565b9061550a565b6158d8818c61570f565b90615731565b6158e860016156c6565b9061550a565b6158f8818a61570f565b90615731565b61590860016156c6565b9061550a565b615918818861570f565b90615731565b61592860016156c6565b9061550a565b615938818661570f565b90615731565b61594860016156c6565b9061550a565b9161596b61596561596085809461570f565b61049a565b9161049a565b1161651f565b90614226565b90565b61598e9061598860016156c6565b90615550565b615872565b6159aa6159bb916159a46004615653565b9061550a565b916159b5600261568e565b90615550565b90615858565b6159d86159e9916159d26008615615565b9061550a565b916159e36004615653565b90615550565b9061583d565b615a06615a1791615a0060106155d7565b9061550a565b91615a116008615615565b90615550565b90615821565b615a34615a4591615a2e6020615599565b9061550a565b91615a3f60106155d7565b90615550565b90615804565b615a62615a7391615a5c6040615534565b9061550a565b91615a6d6020615599565b90615550565b906157e5565b615a90615aa191615a8a60806154ee565b9061550a565b91615a9b6040615534565b90615550565b906157c2565b90565b5f5260205f200190565b93919092615ac0611f61565b505b81615ad5615acf8361049a565b9161049a565b1015615b3b57615ae6828290616549565b90615afc5f615af6888590615aaa565b01614897565b615b0e615b0887611607565b91611607565b115f14615b1e5750915b91615ac2565b929150615b3590615b2f60016148a7565b90612284565b90615b18565b925050915090565b615b61916001615b5c92615b55611e61565b5001614efe565b610c2c565b615b73615b6d5f612268565b9161049a565b141590565b5f615b8c91615b85611f61565b5001614f14565b90565b615bad915f615ba792615ba0612453565b5001614f35565b90614f75565b90565b615bc290615bbc611f61565b50613226565b90565b90565b91909180615bde615bd88561046b565b9161046b565b141580615d5c575b615bf0575b505050565b80615c0b615c05615c005f611f04565b61046b565b9161046b565b03615ccc575b5081615c2d615c27615c225f611f04565b61046b565b9161046b565b03615c39575b80615beb565b615c80615c73615c7a92615c4f600a8690612919565b90615c6d615c67615c616001936165e2565b9361292f565b91615bc5565b90616635565b9290612932565b91612932565b919091615cad7fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a72492610518565b92615cc2615cb9610452565b92839283612ebb565b0390a25f80615c33565b615d0b615d11615d04615ce1600a8590612919565b6002615cfe615cf8615cf2896165e2565b9361292f565b91615bc5565b90616635565b9290612932565b91612932565b919091615d3e7fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a72492610518565b92615d53615d4a610452565b92839283612ebb565b0390a25f615c11565b5081615d70615d6a5f612268565b9161049a565b11615be6565b9081549168010000000000000000831015615da65782615d9e916001615da495018155614fd5565b90614f8f565b565b6121af565b615db3611e61565b50615dc8615dc2828490615b43565b1561065f565b5f14615e0857615dfe615e0392615dea615de35f8501614fb1565b8290615d76565b6001615df75f8501614f14565b9301614efe565b612c4f565b600190565b50505f90565b5f615e2291615e1b611f61565b5001614852565b90565b615e39615e34615e3e92611012565b6104ed565b61049a565b90565b615e4a90615599565b9052565b916020615e6f929493615e6860408201965f830190615e41565b01906105ba565b565b615e85615e80615e8a9261049a565b6104ed565b611012565b90565b615e9561320d565b5080615ead615ea763ffffffff615e25565b9161049a565b11615ebe57615ebb90615e71565b90565b6020615eda5f9283926306dfcc6560e41b845260048401615e4e565b0390fd5b606090565b60209181520190565b615ef590610904565b9052565b90615f0681602093615eec565b0190565b615f14905461247c565b90565b60010190565b90615f3a615f34615f2d84614f14565b8093615ee3565b92614f2c565b905f5b818110615f4a5750505090565b909192615f6a615f64600192615f5f87615f0a565b615ef9565b94615f17565b9101919091615f3d565b90615f7e91615f1d565b90565b90615fa1615f9a92615f91610452565b93848092615f74565b03836121c3565b565b615fac90615f81565b90565b5f615fc391615fbc615ede565b5001615fa3565b90565b615fdd615fe291615fd5611f61565b50600861099f565b610c2c565b90565b90565b615ffc615ff761600192615fe5565b611782565b610904565b90565b61600e60ff615fe8565b90565b5f5260205f2090565b905f929180549061603461602d836120da565b8094612104565b916001811690815f1461608b575060011461604f575b505050565b61605c9192939450616011565b915f925b81841061607357505001905f808061604a565b60018160209295939554848601520191019290616060565b92949550505060ff19168252151560200201905f808061604a565b906160b09161601a565b90565b906160d36160cc926160c3610452565b938480926160a6565b03836121c3565b565b6160de906160b3565b90565b906160ea6120c1565b506160f482612457565b61610d616107616102616004565b610904565b91610904565b14155f14616122575061611f906166bf565b90565b61612c91506160d5565b90565b60429161613a612453565b50604051917f19010000000000000000000000000000000000000000000000000000000000008352600283015260228201522090565b5f90565b90565b61618b61618661619092616174565b6104ed565b61049a565b90565b6161c86161cf946161be6060949897956161b4608086019a5f870190610948565b6020850190610ad3565b6040830190610948565b0190610948565b565b6161d9610452565b3d5f823e3d90fd5b9392936161ec612bb8565b506161f5616170565b506161fe612453565b5061620885614aa6565b61623a6162347f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0616177565b9161049a565b116162c7579061625d602094955f94939293616254610452565b94859485616193565b838052039060015afa156162c2576162755f51611782565b8061629061628a6162855f611f04565b61046b565b9161046b565b146162a6575f916162a05f611787565b91929190565b506162b05f611f04565b6001916162bc5f611787565b91929190565b6161d1565b5050506162d35f611f04565b9060039291929190565b634e487b7160e01b5f52602160045260245ffd5b600411156162fb57565b6162dd565b9061630a826162f1565b565b8061631f6163195f616300565b91616300565b145f1461632a575050565b8061633e6163386001616300565b91616300565b145f14616361575f63f645eedf60e01b81528061635d600482016106d9565b0390fd5b8061637561636f6002616300565b91616300565b145f146163a35761639f61638883614aa6565b5f91829163fce698f760e01b8352600483016105c7565b0390fd5b6163b66163b06003616300565b91616300565b146163be5750565b6163d9905f9182916335e2f38360e21b835260048301610955565b0390fd5b5f5260205f2090565b6163ef81614852565b821015616409576164016001916163dd565b910201905f90565b614f18565b9061641890611607565b9052565b9061642690611cdd565b9052565b906164606164575f61643a613d9b565b94616451616449838301614897565b83880161640e565b016148e8565b6020840161641c565b565b61646b9061642a565b90565b61648c915f6164869261647f613dd6565b50016163e6565b50616462565b90565b929161649d848383916166ef565b836164b86164b26164ad5f611f04565b61046b565b9161046b565b146164cd575b6164cb9293919091616879565b565b6164d5612252565b936164de61685e565b94806164f26164ec8861049a565b9161049a565b116164ff575093506164be565b859061651b5f928392630e58ae9360e11b845260048401612ebb565b0390fd5b616527611f61565b50151590565b61654161653c6165469261568b565b6104ed565b61049a565b90565b61656e61657492616558611f61565b508281169218616568600261652d565b906126ea565b90612284565b90565b90565b61658e61658961659392616577565b6104ed565b610acd565b90565b61659f9061657a565b9052565b9160206165c49294936165bd60408201965f830190616596565b01906105ba565b565b6165da6165d56165df9261049a565b6104ed565b611cdd565b90565b6165ea611dcc565b50806166046165fe60018060d01b03612932565b9161049a565b1161661557616612906165c6565b90565b60d06166315f9283926306dfcc6560e41b8452600484016165a3565b0390fd5b9061666b6166719392616646611dcc565b5061664f611dcc565b50809361666461665d61373f565b9492614d00565b9091616ce1565b91616938565b91909190565b61668b61668661669092615596565b6104ed565b61049a565b90565b369037565b906166bd6166a583612b00565b926020806166b38693612add565b9201910390616693565b565b6166c76120c1565b506166d1816169a2565b906166e46166df6020616677565b616698565b918252602082015290565b9190918061670d6167076167025f611f04565b61046b565b9161046b565b145f146167ee5761673161672a836167256002610c2c565b612284565b6002612c4f565b5b8261674d6167476167425f611f04565b61046b565b9161046b565b145f146167c25761677161676a836167656002610c2c565b614226565b6002612c4f565b5b9190916167bd6167ab6167a57fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef93610518565b93610518565b936167b4610452565b918291826105c7565b0390a3565b6167e9826167e36167d45f879061099f565b916167de83610c2c565b615731565b90612c4f565b616772565b6168016167fc5f839061099f565b610c2c565b8061681461680e8561049a565b9161049a565b1061683c57616827616837918490614226565b6168325f849061099f565b612c4f565b616732565b9061685a9091925f93849363391434e360e21b855260048501613eec565b0390fd5b616866611f61565b5061687660018060d01b03612932565b90565b916168d16168cb6168d8948061689f6168996168945f611f04565b61046b565b9161046b565b14616909575b846168c06168ba6168b55f611f04565b61046b565b9161046b565b146168da575b612bfe565b92612bfe565b9091615bc8565b565b616902600b60026168fc6168f66168f0896165e2565b9361292f565b91615bc5565b90616635565b50506168c6565b616931600b600161692b61692561691f896165e2565b9361292f565b91615bc5565b90616635565b50506168a5565b9161695c5f61696194616949611dcc565b50616952611dcc565b5001929192614875565b616b93565b91909190565b61697b61697661698092615fe5565b6104ed565b61049a565b90565b90565b61699a61699561699f92616983565b6104ed565b61049a565b90565b6169b76169bc916169b1611f61565b50612457565b614aa6565b6169c660ff616967565b16806169db6169d5601f616986565b9161049a565b116169e35790565b5f632cd44ac360e21b8152806169fb600482016106d9565b0390fd5b5490565b616a0d6040612638565b90565b5f5260205f2090565b616a22816169ff565b821015616a3c57616a34600191616a10565b910201905f90565b614f18565b616a4b9051611607565b90565b90616a5f65ffffffffffff91611782565b9181191691161790565b616a7d616a78616a8292611607565b6104ed565b611607565b90565b90565b90616a9d616a98616aa492616a69565b616a85565b8254616a4e565b9055565b616ab29051611cdd565b90565b60301b90565b90616acd65ffffffffffff1991616ab5565b9181191691161790565b616aeb616ae6616af092611cdd565b6104ed565b611cdd565b90565b90565b90616b0b616b06616b1292616ad7565b616af3565b8254616abb565b9055565b90616b4060205f616b4694616b38828201616b32848801616a41565b90616a88565b019201616aa8565b90616af6565b565b9190616b5957616b5791616b16565b565b611f9a565b9081549168010000000000000000831015616b8e5782616b86916001616b8c95018155616a19565b90616b48565b565b6121af565b90929192616b9f611dcc565b50616ba8611dcc565b50616bb2826169ff565b80616bc5616bbf5f612268565b9161049a565b115f14616c9557616beb90616be58491616bdf60016148a7565b9061273a565b90615aaa565b90616bf75f8301614897565b92616c035f84016148e8565b9380616c17616c1185611607565b91611607565b11616c7957616c2e616c2884611607565b91611607565b145f14616c49575050616c44905f859101616af6565b5b9190565b616c749250616c6f86616c66616c5d616a03565b945f860161640e565b6020840161641c565b616b5e565b616c45565b5f632520601d60e01b815280616c91600482016106d9565b0390fd5b50616cc091616cbb85616cb2616ca9616a03565b945f860161640e565b6020840161641c565b616b5e565b616cc95f6148f5565b9190565b634e487b7160e01b5f52605160045260245ffd5b91909180600114616d0057600203616ccd57616cfc91611e4b565b905b565b50616d0a91611e0c565b90616cfe56
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x13W[a\x1D\xC8V[a\0\x1D_5a\x04LV[\x80c\x01\x04-z\x14a\x04GW\x80c\x01\xFF\xC9\xA7\x14a\x04BW\x80c\x04\xDF\x01}\x14a\x04=W\x80c\x05\x072\xFB\x14a\x048W\x80c\x06\xFD\xDE\x03\x14a\x043W\x80c\t^\xA7\xB3\x14a\x04.W\x80c\x18\x16\r\xDD\x14a\x04)W\x80c\x18\xBFPw\x14a\x04$W\x80c#\xB8r\xDD\x14a\x04\x1FW\x80c$\x8A\x9C\xA3\x14a\x04\x1AW\x80c(i6k\x14a\x04\x15W\x80c+\x8CI\xE3\x14a\x04\x10W\x80c//\xF1]\x14a\x04\x0BW\x80c0\xD3\xE8\xEB\x14a\x04\x06W\x80c1<\xE5g\x14a\x04\x01W\x80c6D\xE5\x15\x14a\x03\xFCW\x80c6V\x8A\xBE\x14a\x03\xF7W\x80c:F\xB1\xA8\x14a\x03\xF2W\x80c@\xC1\x0F\x19\x14a\x03\xEDW\x80cBz\xC0\xCA\x14a\x03\xE8W\x80cB\x96lh\x14a\x03\xE3W\x80cK\xDD6\xCE\x14a\x03\xDEW\x80cK\xF5\xD7\xE9\x14a\x03\xD9W\x80cO\x1B\xFC\x9E\x14a\x03\xD4W\x80cX|\xDE\x1E\x14a\x03\xCFW\x80cZB9\xE9\x14a\x03\xCAW\x80cZ]\xB1\xBB\x14a\x03\xC5W\x80c\\\x19\xA9\\\x14a\x03\xC0W\x80c]Lb\x85\x14a\x03\xBBW\x80cc\xA0\xDA\xAC\x14a\x03\xB6W\x80ce\x14U4\x14a\x03\xB1W\x80co\xCF\xFFE\x14a\x03\xACW\x80cp\xA0\x821\x14a\x03\xA7W\x80cr\xCB\xDC\xC8\x14a\x03\xA2W\x80cx\xFB\x7F\xD2\x14a\x03\x9DW\x80cy\xCCg\x90\x14a\x03\x98W\x80cz\x8C\xD1V\x14a\x03\x93W\x80c~\xCE\xBE\0\x14a\x03\x8EW\x80c\x83\xF1!\x1B\x14a\x03\x89W\x80c\x84&\xAD\xF2\x14a\x03\x84W\x80c\x84L\x90&\x14a\x03\x7FW\x80c\x84\xB0\x19n\x14a\x03zW\x80c\x8AT%!\x14a\x03uW\x80c\x8D3C\xD6\x14a\x03pW\x80c\x8ES\x9E\x8C\x14a\x03kW\x80c\x90-U\xA5\x14a\x03fW\x80c\x91\xD1HT\x14a\x03aW\x80c\x91\xDD\xAD\xF4\x14a\x03\\W\x80c\x94\xAA\"\xF2\x14a\x03WW\x80c\x95\xD8\x9BA\x14a\x03RW\x80c\x9A\xB2N\xB0\x14a\x03MW\x80c\x9B~\xF6K\x14a\x03HW\x80c\xA2\x17\xFD\xDF\x14a\x03CW\x80c\xA9\x05\x9C\xBB\x14a\x03>W\x80c\xAA\x08*\x9D\x14a\x039W\x80c\xB0\xCA%>\x14a\x034W\x80c\xB7\xCD\xC6\x1C\x14a\x03/W\x80c\xBBMD6\x14a\x03*W\x80c\xC0*\xE7T\x14a\x03%W\x80c\xC3\xCD\xA5 \x14a\x03 W\x80c\xC4\xFCE\xA8\x14a\x03\x1BW\x80c\xC9\xAB\0\x06\x14a\x03\x16W\x80c\xD5\x05\xAC\xCF\x14a\x03\x11W\x80c\xD5Gt\x1F\x14a\x03\x0CW\x80c\xDDb\xED>\x14a\x03\x07W\x80c\xF1\x12~\xD8\x14a\x03\x02Wc\xF7^\x85\x12\x03a\0\x0EWa\x1D\x93V[a\x1D.V[a\x1CJV[a\x1B\xE9V[a\x1B\xAFV[a\x1B\x0BV[a\x1A\x86V[a\x19\xF4V[a\x198V[a\x19\x03V[a\x18\xCEV[a\x18iV[a\x184V[a\x17\xEFV[a\x17\xBAV[a\x17JV[a\x16\xD3V[a\x16\x9EV[a\x16iV[a\x164V[a\x15\xD1V[a\x15\x9CV[a\x15%V[a\x14\xF0V[a\x14\x8CV[a\x14!V[a\x12\xDCV[a\x12\xA7V[a\x12NV[a\x12\x19V[a\x11\xE4V[a\x11\xB0V[a\x11{V[a\x11FV[a\x10rV[a\x10=V[a\x0F\xDDV[a\x0F\xA9V[a\x0F9V[a\x0E\xE5V[a\x0E\xB0V[a\x0E|V[a\x0EGV[a\r\xF0V[a\r\x82V[a\rMV[a\r\x1AV[a\x0C\xC4V[a\x0B\xC9V[a\x0B\x93V[a\x0B_V[a\x0B*V[a\n\xF5V[a\n\x98V[a\ndV[a\n\x03V[a\t\xCEV[a\tjV[a\x08\xCEV[a\x08`V[a\x08+V[a\x07\xF5V[a\x07\xC0V[a\x07\x11V[a\x06\xDEV[a\x06\x86V[a\x05\xDCV[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x04t\x90a\x04`V[\x90V[a\x04\x80\x81a\x04kV[\x03a\x04\x87WV[_\x80\xFD[\x90P5\x90a\x04\x98\x82a\x04wV[V[\x90V[a\x04\xA6\x81a\x04\x9AV[\x03a\x04\xADWV[_\x80\xFD[\x90P5\x90a\x04\xBE\x82a\x04\x9DV[V[\x91\x90`@\x83\x82\x03\x12a\x04\xE8W\x80a\x04\xDCa\x04\xE5\x92_\x86\x01a\x04\x8BV[\x93` \x01a\x04\xB1V[\x90V[a\x04\\V[\x90V[a\x05\x04a\x04\xFFa\x05\t\x92a\x04`V[a\x04\xEDV[a\x04`V[\x90V[a\x05\x15\x90a\x04\xF0V[\x90V[a\x05!\x90a\x05\x0CV[\x90V[\x90a\x05.\x90a\x05\x18V[_R` R`@_ \x90V[a\x05Na\x05Ia\x05S\x92a\x04\x9AV[a\x04\xEDV[a\x04\x9AV[\x90V[\x90a\x05`\x90a\x05:V[_R` R`@_ \x90V[\x1C\x90V[\x90V[a\x05\x83\x90`\x08a\x05\x88\x93\x02a\x05lV[a\x05pV[\x90V[\x90a\x05\x96\x91Ta\x05sV[\x90V[a\x05\xB2a\x05\xB7\x92a\x05\xAD`\x11\x93_\x94a\x05$V[a\x05VV[a\x05\x8BV[\x90V[a\x05\xC3\x90a\x04\x9AV[\x90RV[\x91\x90a\x05\xDA\x90_` \x85\x01\x94\x01\x90a\x05\xBAV[V[4a\x06\rWa\x06\ta\x05\xF8a\x05\xF26`\x04a\x04\xC0V[\x90a\x05\x99V[a\x06\0a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[c\xFF\xFF\xFF\xFF`\xE0\x1B\x16\x90V[a\x06'\x81a\x06\x12V[\x03a\x06.WV[_\x80\xFD[\x90P5\x90a\x06?\x82a\x06\x1EV[V[\x90` \x82\x82\x03\x12a\x06ZWa\x06W\x91_\x01a\x062V[\x90V[a\x04\\V[\x15\x15\x90V[a\x06m\x90a\x06_V[\x90RV[\x91\x90a\x06\x84\x90_` \x85\x01\x94\x01\x90a\x06dV[V[4a\x06\xB6Wa\x06\xB2a\x06\xA1a\x06\x9C6`\x04a\x06AV[a\x1EeV[a\x06\xA9a\x04RV[\x91\x82\x91\x82a\x06qV[\x03\x90\xF3[a\x04XV[\x90` \x82\x82\x03\x12a\x06\xD4Wa\x06\xD1\x91_\x01a\x04\x8BV[\x90V[a\x04\\V[_\x01\x90V[4a\x07\x0CWa\x06\xF6a\x06\xF16`\x04a\x06\xBBV[a \x97V[a\x06\xFEa\x04RV[\x80a\x07\x08\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[4a\x07AWa\x07=a\x07,a\x07'6`\x04a\x06\xBBV[a \xA2V[a\x074a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[_\x91\x03\x12a\x07PWV[a\x04\\V[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[`\x1F\x80\x19\x91\x01\x16\x90V[a\x07\x96a\x07\x9F` \x93a\x07\xA4\x93a\x07\x8D\x81a\x07UV[\x93\x84\x80\x93a\x07YV[\x95\x86\x91\x01a\x07bV[a\x07mV[\x01\x90V[a\x07\xBD\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x07wV[\x90V[4a\x07\xF0Wa\x07\xD06`\x04a\x07FV[a\x07\xECa\x07\xDBa\"\x1AV[a\x07\xE3a\x04RV[\x91\x82\x91\x82a\x07\xA8V[\x03\x90\xF3[a\x04XV[4a\x08&Wa\x08\"a\x08\x11a\x08\x0B6`\x04a\x04\xC0V[\x90a\"0V[a\x08\x19a\x04RV[\x91\x82\x91\x82a\x06qV[\x03\x90\xF3[a\x04XV[4a\x08[Wa\x08;6`\x04a\x07FV[a\x08Wa\x08Fa\"RV[a\x08Na\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[4a\x08\x8FWa\x08ya\x08s6`\x04a\x04\xC0V[\x90a\"\xA9V[a\x08\x81a\x04RV[\x80a\x08\x8B\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[\x90\x91``\x82\x84\x03\x12a\x08\xC9Wa\x08\xC6a\x08\xAF\x84_\x85\x01a\x04\x8BV[\x93a\x08\xBD\x81` \x86\x01a\x04\x8BV[\x93`@\x01a\x04\xB1V[\x90V[a\x04\\V[4a\x08\xFFWa\x08\xFBa\x08\xEAa\x08\xE46`\x04a\x08\x94V[\x91a$$V[a\x08\xF2a\x04RV[\x91\x82\x91\x82a\x06qV[\x03\x90\xF3[a\x04XV[\x90V[a\t\x10\x81a\t\x04V[\x03a\t\x17WV[_\x80\xFD[\x90P5\x90a\t(\x82a\t\x07V[V[\x90` \x82\x82\x03\x12a\tCWa\t@\x91_\x01a\t\x1BV[\x90V[a\x04\\V[a\tQ\x90a\t\x04V[\x90RV[\x91\x90a\th\x90_` \x85\x01\x94\x01\x90a\tHV[V[4a\t\x9AWa\t\x96a\t\x85a\t\x806`\x04a\t*V[a$\x9DV[a\t\x8Da\x04RV[\x91\x82\x91\x82a\tUV[\x03\x90\xF3[a\x04XV[\x90a\t\xA9\x90a\x05\x18V[_R` R`@_ \x90V[a\t\xCB\x90a\t\xC6`\x10\x91_\x92a\t\x9FV[a\x05\x8BV[\x90V[4a\t\xFEWa\t\xFAa\t\xE9a\t\xE46`\x04a\x06\xBBV[a\t\xB5V[a\t\xF1a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[4a\n2Wa\n\x1Ca\n\x166`\x04a\x04\xC0V[\x90a$\xBFV[a\n$a\x04RV[\x80a\n.\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[\x91\x90`@\x83\x82\x03\x12a\n_W\x80a\nSa\n\\\x92_\x86\x01a\t\x1BV[\x93` \x01a\x04\x8BV[\x90V[a\x04\\V[4a\n\x93Wa\n}a\nw6`\x04a\n7V[\x90a&\x10V[a\n\x85a\x04RV[\x80a\n\x8F\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[4a\n\xC8Wa\n\xC4a\n\xB3a\n\xAE6`\x04a\x06\xBBV[a'lV[a\n\xBBa\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[`\xFF\x16\x90V[a\n\xDC\x90a\n\xCDV[\x90RV[\x91\x90a\n\xF3\x90_` \x85\x01\x94\x01\x90a\n\xD3V[V[4a\x0B%Wa\x0B\x056`\x04a\x07FV[a\x0B!a\x0B\x10a(\xA7V[a\x0B\x18a\x04RV[\x91\x82\x91\x82a\n\xE0V[\x03\x90\xF3[a\x04XV[4a\x0BZWa\x0B:6`\x04a\x07FV[a\x0BVa\x0BEa(\xBDV[a\x0BMa\x04RV[\x91\x82\x91\x82a\tUV[\x03\x90\xF3[a\x04XV[4a\x0B\x8EWa\x0Bxa\x0Br6`\x04a\n7V[\x90a(\xD1V[a\x0B\x80a\x04RV[\x80a\x0B\x8A\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[4a\x0B\xC4Wa\x0B\xC0a\x0B\xAFa\x0B\xA96`\x04a\x04\xC0V[\x90a)NV[a\x0B\xB7a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[4a\x0B\xF8Wa\x0B\xE2a\x0B\xDC6`\x04a\x04\xC0V[\x90a*lV[a\x0B\xEAa\x04RV[\x80a\x0B\xF4\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[\x90a\x0C\x07\x90a\x05\x18V[_R` R`@_ \x90V[_\x1C\x90V[a\x0C$a\x0C)\x91a\x0C\x13V[a\x05pV[\x90V[a\x0C6\x90Ta\x0C\x18V[\x90V[`\xFF\x16\x90V[a\x0CKa\x0CP\x91a\x0C\x13V[a\x0C9V[\x90V[a\x0C]\x90Ta\x0C?V[\x90V[a\x0Ck\x90`\ra\x0B\xFDV[a\x0Cv_\x82\x01a\x0C,V[\x91a\x0C\x8F`\x02a\x0C\x88`\x01\x85\x01a\x0C,V[\x93\x01a\x0CSV[\x90V[`@\x90a\x0C\xBBa\x0C\xC2\x94\x96\x95\x93\x96a\x0C\xB1``\x84\x01\x98_\x85\x01\x90a\x05\xBAV[` \x83\x01\x90a\x05\xBAV[\x01\x90a\x06dV[V[4a\x0C\xF7Wa\x0C\xF3a\x0C\xDFa\x0C\xDA6`\x04a\x06\xBBV[a\x0C`V[a\x0C\xEA\x93\x91\x93a\x04RV[\x93\x84\x93\x84a\x0C\x92V[\x03\x90\xF3[a\x04XV[\x90` \x82\x82\x03\x12a\r\x15Wa\r\x12\x91_\x01a\x04\xB1V[\x90V[a\x04\\V[4a\rHWa\r2a\r-6`\x04a\x0C\xFCV[a*xV[a\r:a\x04RV[\x80a\rD\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[4a\r}Wa\r]6`\x04a\x07FV[a\rya\rha*\xB8V[a\rpa\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[4a\r\xB2Wa\r\x926`\x04a\x07FV[a\r\xAEa\r\x9Da+bV[a\r\xA5a\x04RV[\x91\x82\x91\x82a\x07\xA8V[\x03\x90\xF3[a\x04XV[\x90V[a\r\xCEa\r\xC9a\r\xD3\x92a\r\xB7V[a\x04\xEDV[a\x04\x9AV[\x90V[a\r\xE2bv\xA7\0a\r\xBAV[\x90V[a\r\xEDa\r\xD6V[\x90V[4a\x0E Wa\x0E\x006`\x04a\x07FV[a\x0E\x1Ca\x0E\x0Ba\r\xE5V[a\x0E\x13a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[a\x0E.\x90a\x04kV[\x90RV[\x91\x90a\x0EE\x90_` \x85\x01\x94\x01\x90a\x0E%V[V[4a\x0EwWa\x0Esa\x0Eba\x0E]6`\x04a\x06\xBBV[a+\xFEV[a\x0Eja\x04RV[\x91\x82\x91\x82a\x0E2V[\x03\x90\xF3[a\x04XV[4a\x0E\xABWa\x0E\x95a\x0E\x8F6`\x04a\x04\xC0V[\x90a-\x8BV[a\x0E\x9Da\x04RV[\x80a\x0E\xA7\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[4a\x0E\xE0Wa\x0E\xDCa\x0E\xCBa\x0E\xC66`\x04a\x0C\xFCV[a.?V[a\x0E\xD3a\x04RV[\x91\x82\x91\x82a\x0E2V[\x03\x90\xF3[a\x04XV[4a\x0F\x13Wa\x0E\xFDa\x0E\xF86`\x04a\x06\xBBV[a.\x8BV[a\x0F\x05a\x04RV[\x80a\x0F\x0F\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[a\x0F1a\x0F6\x92a\x0F,`\x12\x93_\x94a\x05$V[a\x05VV[a\x05\x8BV[\x90V[4a\x0FjWa\x0Ffa\x0FUa\x0FO6`\x04a\x04\xC0V[\x90a\x0F\x18V[a\x0F]a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[\x90\x91``\x82\x84\x03\x12a\x0F\xA4Wa\x0F\xA1a\x0F\x8A\x84_\x85\x01a\x04\x8BV[\x93a\x0F\x98\x81` \x86\x01a\x04\xB1V[\x93`@\x01a\x04\xB1V[\x90V[a\x04\\V[4a\x0F\xD8Wa\x0F\xC2a\x0F\xBC6`\x04a\x0FoV[\x91a1\xE2V[a\x0F\xCAa\x04RV[\x80a\x0F\xD4\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[4a\x10\rWa\x0F\xED6`\x04a\x07FV[a\x10\ta\x0F\xF8a1\xEFV[a\x10\0a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[c\xFF\xFF\xFF\xFF\x16\x90V[a\x10$\x90a\x10\x12V[\x90RV[\x91\x90a\x10;\x90_` \x85\x01\x94\x01\x90a\x10\x1BV[V[4a\x10mWa\x10ia\x10Xa\x10S6`\x04a\x06\xBBV[a2\x11V[a\x10`a\x04RV[\x91\x82\x91\x82a\x10(V[\x03\x90\xF3[a\x04XV[4a\x10\xA2Wa\x10\x9Ea\x10\x8Da\x10\x886`\x04a\x06\xBBV[a2&V[a\x10\x95a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[Q\x90V[` \x91\x81R\x01\x90V[` \x01\x90V[a\x10\xC3\x90a\x04kV[\x90RV[\x90a\x10\xD4\x81` \x93a\x10\xBAV[\x01\x90V[` \x01\x90V[\x90a\x10\xFBa\x10\xF5a\x10\xEE\x84a\x10\xA7V[\x80\x93a\x10\xABV[\x92a\x10\xB4V[\x90_[\x81\x81\x10a\x11\x0BWPPP\x90V[\x90\x91\x92a\x11$a\x11\x1E`\x01\x92\x86Qa\x10\xC7V[\x94a\x10\xD8V[\x91\x01\x91\x90\x91a\x10\xFEV[a\x11C\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x10\xDEV[\x90V[4a\x11vWa\x11V6`\x04a\x07FV[a\x11ra\x11aa2IV[a\x11ia\x04RV[\x91\x82\x91\x82a\x11.V[\x03\x90\xF3[a\x04XV[4a\x11\xABWa\x11\xA7a\x11\x96a\x11\x916`\x04a\x06\xBBV[a2gV[a\x11\x9Ea\x04RV[\x91\x82\x91\x82a\x06qV[\x03\x90\xF3[a\x04XV[4a\x11\xDFWa\x11\xC9a\x11\xC36`\x04a\x04\xC0V[\x90a3\xCCV[a\x11\xD1a\x04RV[\x80a\x11\xDB\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[4a\x12\x14Wa\x11\xF46`\x04a\x07FV[a\x12\x10a\x11\xFFa3\xD8V[a\x12\x07a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[4a\x12IWa\x12Ea\x124a\x12/6`\x04a\x06\xBBV[a4PV[a\x12<a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[4a\x12~Wa\x12^6`\x04a\x07FV[a\x12za\x12ia4eV[a\x12qa\x04RV[\x91\x82\x91\x82a\x06qV[\x03\x90\xF3[a\x04XV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[4a\x12\xD7Wa\x12\xB76`\x04a\x07FV[a\x12\xD3a\x12\xC2a\x12\x83V[a\x12\xCAa\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[4a\x13\nWa\x12\xF4a\x12\xEF6`\x04a\x0C\xFCV[a5\xB8V[a\x12\xFCa\x04RV[\x80a\x13\x06\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[`\xFF`\xF8\x1B\x16\x90V[a\x13!\x90a\x13\x0FV[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[` \x01\x90V[a\x13A\x90a\x04\x9AV[\x90RV[\x90a\x13R\x81` \x93a\x138V[\x01\x90V[` \x01\x90V[\x90a\x13ya\x13sa\x13l\x84a\x13%V[\x80\x93a\x13)V[\x92a\x132V[\x90_[\x81\x81\x10a\x13\x89WPPP\x90V[\x90\x91\x92a\x13\xA2a\x13\x9C`\x01\x92\x86Qa\x13EV[\x94a\x13VV[\x91\x01\x91\x90\x91a\x13|V[\x93\x95\x91\x94a\x13\xFDa\x13\xF2a\x14\x11\x95a\x13\xE4a\x14\x07\x95a\x14\x1E\x9C\x9Aa\x13\xD7`\xE0\x8C\x01\x92_\x8D\x01\x90a\x13\x18V[\x8A\x82\x03` \x8C\x01Ra\x07wV[\x90\x88\x82\x03`@\x8A\x01Ra\x07wV[\x97``\x87\x01\x90a\x05\xBAV[`\x80\x85\x01\x90a\x0E%V[`\xA0\x83\x01\x90a\tHV[`\xC0\x81\x84\x03\x91\x01Ra\x13\\V[\x90V[4a\x14XWa\x1416`\x04a\x07FV[a\x14Ta\x14<a6@V[\x93a\x14K\x97\x95\x97\x93\x91\x93a\x04RV[\x97\x88\x97\x88a\x13\xACV[\x03\x90\xF3[a\x04XV[\x7F\x84\xFEt\xC7\x1A(\xB6\x9A\xA9`Hl\xA0\xE8\xC1A\x8C\x86\xE9\xEA,\xD6\xB5\x84\x9B\x95\xE2\xC8\xF4\x07\xA6t\x90V[a\x14\x89a\x14]V[\x90V[4a\x14\xBCWa\x14\x9C6`\x04a\x07FV[a\x14\xB8a\x14\xA7a\x14\x81V[a\x14\xAFa\x04RV[\x91\x82\x91\x82a\tUV[\x03\x90\xF3[a\x04XV[\x7F\x9B\x12\xE0\xC5p~II\x15\xE5\x8B\x05d\xF1\x8A\xAA\xD9\xB7J\xC6\x9B\xFC\x81Z\x1E\xDA\xDC\x8EK\xD02\xEB\x90V[a\x14\xEDa\x14\xC1V[\x90V[4a\x15 Wa\x15\x006`\x04a\x07FV[a\x15\x1Ca\x15\x0Ba\x14\xE5V[a\x15\x13a\x04RV[\x91\x82\x91\x82a\tUV[\x03\x90\xF3[a\x04XV[4a\x15UWa\x15Qa\x15@a\x15;6`\x04a\x0C\xFCV[a6\xCAV[a\x15Ha\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[\x90V[a\x15qa\x15la\x15v\x92a\x15ZV[a\x04\xEDV[a\x04\x9AV[\x90V[a\x15\x8Ek\x03;.<\x9F\xD0\x80<\xE8\0\0\0a\x15]V[\x90V[a\x15\x99a\x15yV[\x90V[4a\x15\xCCWa\x15\xAC6`\x04a\x07FV[a\x15\xC8a\x15\xB7a\x15\x91V[a\x15\xBFa\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[4a\x16\x02Wa\x15\xFEa\x15\xEDa\x15\xE76`\x04a\n7V[\x90a7\x11V[a\x15\xF5a\x04RV[\x91\x82\x91\x82a\x06qV[\x03\x90\xF3[a\x04XV[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x16\x1B\x90a\x16\x07V[\x90RV[\x91\x90a\x162\x90_` \x85\x01\x94\x01\x90a\x16\x12V[V[4a\x16dWa\x16D6`\x04a\x07FV[a\x16`a\x16Oa7?V[a\x16Wa\x04RV[\x91\x82\x91\x82a\x16\x1FV[\x03\x90\xF3[a\x04XV[4a\x16\x99Wa\x16\x95a\x16\x84a\x16\x7F6`\x04a\x06\xBBV[a7SV[a\x16\x8Ca\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[4a\x16\xCEWa\x16\xAE6`\x04a\x07FV[a\x16\xCAa\x16\xB9a8iV[a\x16\xC1a\x04RV[\x91\x82\x91\x82a\x07\xA8V[\x03\x90\xF3[a\x04XV[4a\x17\x03Wa\x16\xFFa\x16\xEEa\x16\xE96`\x04a\x06\xBBV[a8\x7FV[a\x16\xF6a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[\x90V[a\x17\x1Fa\x17\x1Aa\x17$\x92a\x17\x08V[a\x04\xEDV[a\x04\x9AV[\x90V[a\x17<k\x02\xE8vi\xC3\x08sj\x04\0\0\0a\x17\x0BV[\x90V[a\x17Ga\x17'V[\x90V[4a\x17zWa\x17Z6`\x04a\x07FV[a\x17va\x17ea\x17?V[a\x17ma\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[\x90V[_\x1B\x90V[a\x17\x9Ba\x17\x96a\x17\xA0\x92a\x17\x7FV[a\x17\x82V[a\t\x04V[\x90V[a\x17\xAC_a\x17\x87V[\x90V[a\x17\xB7a\x17\xA3V[\x90V[4a\x17\xEAWa\x17\xCA6`\x04a\x07FV[a\x17\xE6a\x17\xD5a\x17\xAFV[a\x17\xDDa\x04RV[\x91\x82\x91\x82a\tUV[\x03\x90\xF3[a\x04XV[4a\x18 Wa\x18\x1Ca\x18\x0Ba\x18\x056`\x04a\x04\xC0V[\x90a8\xAEV[a\x18\x13a\x04RV[\x91\x82\x91\x82a\x06qV[\x03\x90\xF3[a\x04XV[a\x181`\x0C_\x90a\x05\x8BV[\x90V[4a\x18dWa\x18D6`\x04a\x07FV[a\x18`a\x18Oa\x18%V[a\x18Wa\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[4a\x18\x9AWa\x18\x96a\x18\x85a\x18\x7F6`\x04a\x04\xC0V[\x90a8\xD0V[a\x18\x8Da\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[\x7F\x82\x03r\xA9\xFA\xF8-\xB3\xCC_\xC3o\xFA\xB5\xF0\x96\xEE\xF6\x9B\x95\xFB\xF5\x05\x91\xE0\xD7\x14G\xAA\x1B\xA7\0\x90V[a\x18\xCBa\x18\x9FV[\x90V[4a\x18\xFEWa\x18\xDE6`\x04a\x07FV[a\x18\xFAa\x18\xE9a\x18\xC3V[a\x18\xF1a\x04RV[\x91\x82\x91\x82a\tUV[\x03\x90\xF3[a\x04XV[4a\x193Wa\x19/a\x19\x1Ea\x19\x196`\x04a\x06\xBBV[a8\xE6V[a\x19&a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[4a\x19hWa\x19H6`\x04a\x07FV[a\x19da\x19Sa8\xFBV[a\x19[a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[a\x19v\x81a\n\xCDV[\x03a\x19}WV[_\x80\xFD[\x90P5\x90a\x19\x8E\x82a\x19mV[V[\x90\x91`\xC0\x82\x84\x03\x12a\x19\xEFWa\x19\xA8\x83_\x84\x01a\x04\x8BV[\x92a\x19\xB6\x81` \x85\x01a\x04\xB1V[\x92a\x19\xC4\x82`@\x83\x01a\x04\xB1V[\x92a\x19\xECa\x19\xD5\x84``\x85\x01a\x19\x81V[\x93a\x19\xE3\x81`\x80\x86\x01a\t\x1BV[\x93`\xA0\x01a\t\x1BV[\x90V[a\x04\\V[4a\x1A)Wa\x1A\x13a\x1A\x076`\x04a\x19\x90V[\x94\x93\x90\x93\x92\x91\x92a9{V[a\x1A\x1Ba\x04RV[\x80a\x1A%\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[a\x1A7\x90a\x06_V[\x90RV[\x90`@\x80a\x1Ao\x93a\x1AS_\x82\x01Q_\x86\x01\x90a\x138V[a\x1Ae` \x82\x01Q` \x86\x01\x90a\x138V[\x01Q\x91\x01\x90a\x1A.V[V[\x91\x90a\x1A\x84\x90_``\x85\x01\x94\x01\x90a\x1A;V[V[4a\x1A\xB6Wa\x1A\xB2a\x1A\xA1a\x1A\x9C6`\x04a\x06\xBBV[a:rV[a\x1A\xA9a\x04RV[\x91\x82\x91\x82a\x1AqV[\x03\x90\xF3[a\x04XV[a\x1A\xC4\x81a\x06_V[\x03a\x1A\xCBWV[_\x80\xFD[\x90P5\x90a\x1A\xDC\x82a\x1A\xBBV[V[\x91\x90`@\x83\x82\x03\x12a\x1B\x06W\x80a\x1A\xFAa\x1B\x03\x92_\x86\x01a\x04\x8BV[\x93` \x01a\x1A\xCFV[\x90V[a\x04\\V[4a\x1B:Wa\x1B$a\x1B\x1E6`\x04a\x1A\xDEV[\x90a;\x85V[a\x1B,a\x04RV[\x80a\x1B6\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[`\xE0\x81\x83\x03\x12a\x1B\xAAWa\x1BU\x82_\x83\x01a\x04\x8BV[\x92a\x1Bc\x83` \x84\x01a\x04\x8BV[\x92a\x1Bq\x81`@\x85\x01a\x04\xB1V[\x92a\x1B\x7F\x82``\x83\x01a\x04\xB1V[\x92a\x1B\xA7a\x1B\x90\x84`\x80\x85\x01a\x19\x81V[\x93a\x1B\x9E\x81`\xA0\x86\x01a\t\x1BV[\x93`\xC0\x01a\t\x1BV[\x90V[a\x04\\V[4a\x1B\xE4Wa\x1B\xCEa\x1B\xC26`\x04a\x1B?V[\x95\x94\x90\x94\x93\x91\x93a<3V[a\x1B\xD6a\x04RV[\x80a\x1B\xE0\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[4a\x1C\x18Wa\x1C\x02a\x1B\xFC6`\x04a\n7V[\x90a=QV[a\x1C\na\x04RV[\x80a\x1C\x14\x81a\x06\xD9V[\x03\x90\xF3[a\x04XV[\x91\x90`@\x83\x82\x03\x12a\x1CEW\x80a\x1C9a\x1CB\x92_\x86\x01a\x04\x8BV[\x93` \x01a\x04\x8BV[\x90V[a\x04\\V[4a\x1C{Wa\x1Cwa\x1Cfa\x1C`6`\x04a\x1C\x1DV[\x90a=sV[a\x1Cna\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xF3[a\x04XV[a\x1C\x89\x81a\x10\x12V[\x03a\x1C\x90WV[_\x80\xFD[\x90P5\x90a\x1C\xA1\x82a\x1C\x80V[V[\x91\x90`@\x83\x82\x03\x12a\x1C\xCBW\x80a\x1C\xBFa\x1C\xC8\x92_\x86\x01a\x04\x8BV[\x93` \x01a\x1C\x94V[\x90V[a\x04\\V[a\x1C\xD9\x90a\x16\x07V[\x90RV[`\x01\x80`\xD0\x1B\x03\x16\x90V[a\x1C\xF1\x90a\x1C\xDDV[\x90RV[\x90` \x80a\x1D\x17\x93a\x1D\r_\x82\x01Q_\x86\x01\x90a\x1C\xD0V[\x01Q\x91\x01\x90a\x1C\xE8V[V[\x91\x90a\x1D,\x90_`@\x85\x01\x94\x01\x90a\x1C\xF5V[V[4a\x1D_Wa\x1D[a\x1DJa\x1DD6`\x04a\x1C\xA3V[\x90a=\xE1V[a\x1DRa\x04RV[\x91\x82\x91\x82a\x1D\x19V[\x03\x90\xF3[a\x04XV[\x7F\xCC\xE2\x96\xB0@3*\x08\x0Em\xF15\x15\xA3\xEC(i\xE2\x1C\xD2\x0FsD\xAF\t\x87\xDD\xB98\xD8\xBD!\x90V[a\x1D\x90a\x1DdV[\x90V[4a\x1D\xC3Wa\x1D\xA36`\x04a\x07FV[a\x1D\xBFa\x1D\xAEa\x1D\x88V[a\x1D\xB6a\x04RV[\x91\x82\x91\x82a\tUV[\x03\x90\xF3[a\x04XV[_\x80\xFD[_\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\x1D\xF0a\x1D\xF6\x91a\x1C\xDDV[\x91a\x1C\xDDV[\x01\x90`\x01\x80`\xD0\x1B\x03\x82\x11a\x1E\x07WV[a\x1D\xD0V[\x90a\x1E\x1F\x91a\x1E\x19a\x1D\xCCV[Pa\x1D\xE4V[\x90V[a\x1E.a\x1E4\x91a\x1C\xDDV[\x91a\x1C\xDDV[\x90\x03\x90`\x01\x80`\xD0\x1B\x03\x82\x11a\x1EFWV[a\x1D\xD0V[\x90a\x1E^\x91a\x1EXa\x1D\xCCV[Pa\x1E\"V[\x90V[_\x90V[a\x1Ema\x1EaV[P\x80a\x1E\x88a\x1E\x82c\x0C\xCC\xC6e`\xE2\x1Ba\x06\x12V[\x91a\x06\x12V[\x14\x80\x15a\x1E\xACW[\x90\x81\x15a\x1E\x9CW[P\x90V[a\x1E\xA6\x91Pa=\xF7V[_a\x1E\x98V[P\x80a\x1E\xC7a\x1E\xC1c\xB2u*\xC9`\xE0\x1Ba\x06\x12V[\x91a\x06\x12V[\x14a\x1E\x90V[a\x1E\xE6\x90a\x1E\xE1a\x1E\xDCa\x1DdV[a>7V[a\x1F\xC4V[V[a\x1E\xFCa\x1E\xF7a\x1F\x01\x92a\x17\x7FV[a\x04\xEDV[a\x04`V[\x90V[a\x1F\r\x90a\x1E\xE8V[\x90V[\x90V[\x1B\x90V[\x91\x90`\x08a\x1F2\x91\x02\x91a\x1F,_\x19\x84a\x1F\x13V[\x92a\x1F\x13V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90V[\x91\x90a\x1FUa\x1FPa\x1F]\x93a\x05:V[a\x1F<V[\x90\x83Ta\x1F\x17V[\x90UV[_\x90V[a\x1Fw\x91a\x1Fqa\x1FaV[\x91a\x1F?V[V[`\x02_\x91a\x1F\x89\x83\x80\x83\x01a\x1FeV[a\x1F\x96\x83`\x01\x83\x01a\x1FeV[\x01UV[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[\x90_\x03a\x1F\xBFWa\x1F\xBD\x90a\x1FyV[V[a\x1F\x9AV[\x80a\x1F\xDFa\x1F\xD9a\x1F\xD4_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14a {Wa \x01a\x1F\xFBa\x1F\xF4`\x0Ea\x1F\x10V[\x83\x90a>\x92V[\x15a\x06_V[a \\Wa \x1A_a \x15`\r\x84\x90a\x0B\xFDV[a\x1F\xADV[a D\x7F]\x9DP4el\xB3\xEB\xFB\x06U\x05|\xD7\xF9\xB4\x07z\x9BB\xFFB\xCE\"<\xBA\xC5\xBCXm!&\x91a\x05\x18V[\x90a Ma\x04RV[\x80a W\x81a\x06\xD9V[\x03\x90\xA2V[a w\x90_\x91\x82\x91ce\x85\xB6\r`\xE0\x1B\x83R`\x04\x83\x01a\x0E2V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a \x93`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[a \xA0\x90a\x1E\xCDV[V[a \xB9a \xBE\x91a \xB1a\x1FaV[P`\x10a\t\x9FV[a\x0C,V[\x90V[``\x90V[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a \xFAW[` \x83\x10\x14a \xF5WV[a \xC6V[\x91`\x7F\x16\x91a \xEAV[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a!0a!)\x83a \xDAV[\x80\x94a!\x04V[\x91`\x01\x81\x16\x90\x81_\x14a!\x87WP`\x01\x14a!KW[PPPV[a!X\x91\x92\x93\x94Pa!\rV[\x91_\x92[\x81\x84\x10a!oWPP\x01\x90_\x80\x80a!FV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a!\\V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a!FV[\x90a!\xAC\x91a!\x16V[\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a!\xCD\x90a\x07mV[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a!\xE7W`@RV[a!\xAFV[\x90a\"\x0Ca\"\x05\x92a!\xFCa\x04RV[\x93\x84\x80\x92a!\xA2V[\x03\x83a!\xC3V[V[a\"\x17\x90a!\xECV[\x90V[a\"\"a \xC1V[Pa\"-`\x03a\"\x0EV[\x90V[a\"M\x91a\"<a\x1EaV[Pa\"Ea>\xCCV[\x91\x90\x91a>\xD9V[`\x01\x90V[a\"Za\x1FaV[Pa\"e`\x02a\x0C,V[\x90V[a\"|a\"wa\"\x81\x92a\x17\x7FV[a\x04\xEDV[a\x04\x9AV[\x90V[a\"\x93a\"\x99\x91\x93\x92\x93a\x04\x9AV[\x92a\x04\x9AV[\x82\x01\x80\x92\x11a\"\xA4WV[a\x1D\xD0V[\x80a\"\xC4a\"\xBEa\"\xB9_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14a$\x08W\x81a\"\xDCa\"\xD6_a\"hV[\x91a\x04\x9AV[\x14a#\xECWa\"\xF3a\"\xECa\"RV[\x83\x90a\"\x84V[a#\x0Ca#\x06a#\x01a\x15yV[a\x04\x9AV[\x91a\x04\x9AV[\x11a#\xD0Wa#\x1C3\x83\x90a?\x1EV[a#'3\x83\x90aA\x14V[a#/a4eV[\x80a#\xAFW[a#\x93Wa#D\x81\x83\x90aA\xC8V[3\x90a#\x8Ea#|a#v\x7F\xDE\"\xBA\xFF\x03\x8E:>\x08@|\xBD\xF6\x17\xDE\xEDt\xE8i\xA7\xBAQ}\xF6\x11\xE311\xC6\xE6\xEA\x04\x93a\x05\x18V[\x93a\x05\x18V[\x93a#\x85a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xA3V[_c6\xE2x\xFD`\xE2\x1B\x81R\x80a#\xAB`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[Pa#\xCBa#\xC5a#\xBEa\x14]V[3\x90a7\x11V[\x15a\x06_V[a#5V[_c\x17~?\xC3`\xE0\x1B\x81R\x80a#\xE8`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a$\x04`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a$ `\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[\x91a$N\x92a$1a\x1EaV[Pa$Fa$=a>\xCCV[\x82\x90\x84\x91aB4V[\x91\x90\x91aB\xC0V[`\x01\x90V[_\x90V[a$`\x90a\t\x04V[\x90V[\x90a$m\x90a$WV[_R` R`@_ \x90V[\x90V[a$\x88a$\x8D\x91a\x0C\x13V[a$yV[\x90V[a$\x9A\x90Ta$|V[\x90V[`\x01a$\xB6a$\xBC\x92a$\xAEa$SV[P`\x05a$cV[\x01a$\x90V[\x90V[\x80a$\xDAa$\xD4a$\xCF_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14a%\xCAW\x81a$\xF2a$\xEC_a\"hV[\x91a\x04\x9AV[\x14a%\xAEWa%\x023\x83\x90aC]V[3a%\x15a%\x0F\x83a\x04kV[\x91a\x04kV[\x03a%uW[a%&\x81\x83\x90aEVV[3\x90a%pa%^a%X\x7F\xB9\x07\x95\xA6fP\x15Y\x83\xE2B\xCA\xC3\xE1\xAC\x1AM\xC2o\x8E\xD2\x98\x7F<\xE4\x16\xA3N\0\x11\x1F\xD4\x93a\x05\x18V[\x93a\x05\x18V[\x93a%ga\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xA3V[a%\x80\x813\x90a=sV[a%\x92a%\x8C_a\"hV[\x91a\x04\x9AV[\x03a%\x9DW[a%\x1BV[a%\xA9\x813\x84\x91aB4V[a%\x98V[_c\x1F* \x05`\xE0\x1B\x81R\x80a%\xC6`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a%\xE2`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[\x90a&\x01\x91a%\xFCa%\xF7\x82a$\x9DV[a>7V[a&\x03V[V[\x90a&\r\x91aE\xB5V[PV[\x90a&\x1A\x91a%\xE6V[V[\x90a&&\x90a\x04\x9AV[\x90RV[\x90a&4\x90a\x06_V[\x90RV[\x90a&Ka&Da\x04RV[\x92\x83a!\xC3V[V[a&W``a&8V[\x90V[\x90a&\xA9a&\xA0`\x02a&ka&MV[\x94a&\x82a&z_\x83\x01a\x0C,V[_\x88\x01a&\x1CV[a&\x9Aa&\x91`\x01\x83\x01a\x0C,V[` \x88\x01a&\x1CV[\x01a\x0CSV[`@\x84\x01a&*V[V[a&\xB4\x90a&ZV[\x90V[\x90V[a&\xCEa&\xC9a&\xD3\x92a&\xB7V[a\x04\xEDV[a\x04\x9AV[\x90V[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[a&\xF6a&\xFC\x91a\x04\x9AV[\x91a\x04\x9AV[\x90\x81\x15a'\x07W\x04\x90V[a&\xD6V[`\x01a'\x18\x91\x01a\x04\x9AV[\x90V[\x90V[a'2a'-a'7\x92a'\x1BV[a\x04\xEDV[a\x04\x9AV[\x90V[a'Ia'O\x91\x93\x92\x93a\x04\x9AV[\x92a\x04\x9AV[\x82\x03\x91\x82\x11a'ZWV[a\x1D\xD0V[a'i\x90Qa\x04\x9AV[\x90V[a'ta\x1FaV[Pa'\x89a'\x84`\r\x83\x90a\x0B\xFDV[a&\xABV[\x90a'\x9FBa'\x99a\x0E\x10a&\xBAV[\x90a&\xEAV[a'\xA8_a\"hV[\x90a'\xB2_a\"hV[[\x80a'\xC7a'\xC1`\x18a'\x1EV[\x91a\x04\x9AV[\x10\x15a(3W\x81a'\xE0a'\xDA\x83a\x04\x9AV[\x91a\x04\x9AV[\x10\x15a'\xF5W[a'\xF0\x90a'\x0CV[a'\xB3V[\x91a(+a'\xF0\x91a(%a( a(\x0F`\x12\x89\x90a\x05$V[a(\x1A\x87\x89\x90a':V[\x90a\x05VV[a\x0C,V[\x90a\"\x84V[\x92\x90Pa'\xE7V[PP\x90Pa(C` \x83\x01a'_V[a(Ua(O\x83a\x04\x9AV[\x91a\x04\x9AV[\x11_\x14a(tWa(k` a(p\x93\x01a'_V[a':V[[\x90V[PPa(\x7F_a\"hV[a(qV[_\x90V[\x90V[a(\x9Fa(\x9Aa(\xA4\x92a(\x88V[a\x04\xEDV[a\n\xCDV[\x90V[a(\xAFa(\x84V[Pa(\xBA`\x12a(\x8BV[\x90V[a(\xC5a$SV[Pa(\xCEaFaV[\x90V[\x90\x80a(\xECa(\xE6a(\xE1a>\xCCV[a\x04kV[\x91a\x04kV[\x03a(\xFDWa(\xFA\x91aG\x1BV[PV[_c3K\xD9\x19`\xE1\x1B\x81R\x80a)\x15`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[\x90a)#\x90a\x05\x18V[_R` R`@_ \x90V[\x90V[a)Fa)Aa)K\x92a\x1C\xDDV[a\x04\xEDV[a\x04\x9AV[\x90V[a)\x85\x91a)za)ta)oa)\x80\x94a)ga\x1FaV[P`\na)\x19V[a)/V[\x91aG\xFCV[\x90aI\x11V[a)2V[\x90V[\x90a)\xA2\x91a)\x9Da)\x98a\x14\xC1V[a>7V[a)\xA4V[V[\x90\x81a)\xC0a)\xBAa)\xB5_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14a*PW\x80a)\xD8a)\xD2_a\"hV[\x91a\x04\x9AV[\x14a*4Wa)\xEFa)\xE8a\"RV[\x82\x90a\"\x84V[a*\x08a*\x02a)\xFDa\x15yV[a\x04\x9AV[\x91a\x04\x9AV[\x11a*\x18Wa*\x16\x91aA\xC8V[V[_c\x17~?\xC3`\xE0\x1B\x81R\x80a*0`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a*L`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a*h`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[\x90a*v\x91a)\x88V[V[\x80a*\x8Ba*\x85_a\"hV[\x91a\x04\x9AV[\x14a*\x9CWa*\x9A\x903aEVV[V[_c\x1F* \x05`\xE0\x1B\x81R\x80a*\xB4`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[a*\xC0a\x1FaV[Pa*\xDAa*\xCCa\x15yV[a*\xD4a\"RV[\x90a':V[\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a*\xFBWa*\xF7` \x91a\x07mV[\x01\x90V[a!\xAFV[\x90a+\x12a+\r\x83a*\xDDV[a&8V[\x91\x82RV[_\x7Fmode=blocknumber&from=default\0\0\0\x91\x01RV[a+H`\x1Da+\0V[\x90a+U` \x83\x01a+\x17V[V[a+_a+>V[\x90V[a+ja \xC1V[Pa+sa7?V[a+\x8Ca+\x86a+\x81aJ8V[a\x16\x07V[\x91a\x16\x07V[\x03a+\x9CWa+\x99a+WV[\x90V[_c\x01\xBF\xC1\xC5`\xE6\x1B\x81R\x80a+\xB4`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[_\x90V[\x90a+\xC6\x90a\x05\x18V[_R` R`@_ \x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a+\xE9a+\xEE\x91a\x0C\x13V[a+\xD2V[\x90V[a+\xFB\x90Ta+\xDDV[\x90V[a,\x15a,\x1A\x91a,\ra+\xB8V[P`\ta+\xBCV[a+\xF1V[\x90V[\x90a,7\x91a,2a,-a\x18\x9FV[a>7V[a,oV[V[\x90a,E_\x19\x91a\x17\x82V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a,da,_a,k\x92a\x05:V[a\x1F<V[\x82Ta,9V[\x90UV[\x80a,\x8Aa,\x84a,\x7F_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14a-oW\x81a,\xA2a,\x9C_a\"hV[\x91a\x04\x9AV[\x14a-SWa,\xC4a,\xBEa,\xB7`\x0Ea\x1F\x10V[\x83\x90aJMV[\x15a\x06_V[a-4Wa,\xF0\x82a,\xEAa,\xDB`\x10\x85\x90a\t\x9FV[\x91a,\xE5\x83a\x0C,V[a\"\x84V[\x90a,OV[a-/a-\x1D\x7F\x9C\xA0=\xBDQ\x93\xFB\xB7\x97As\xCE\xDD\x0B\xDFhA\xDD\x14\xC3\xCB\xFAsZ\xABw\xFF\x1D\xD1\x13\x9F\xB3\x92a\x05\x18V[\x92a-&a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xA2V[a-O\x90_\x91\x82\x91ce\x85\xB6\r`\xE0\x1B\x83R`\x04\x83\x01a\x0E2V[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a-k`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a-\x87`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[\x90a-\x95\x91a,\x1DV[V[` \x7Fout of bounds\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7FSyndicateTokenCrosschain: index _\x82\x01R\x01RV[a-\xF1`-`@\x92a\x07YV[a-\xFA\x81a-\x97V[\x01\x90V[a.\x13\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra-\xE4V[\x90V[\x15a.\x1DWV[a.%a\x04RV[bF\x1B\xCD`\xE5\x1B\x81R\x80a.;`\x04\x82\x01a-\xFEV[\x03\x90\xFD[a.\x88\x90a.Ka+\xB8V[Pa.y\x81a.sa.ma.ha.c`\x0Ea\x1F\x10V[aJ\x87V[a\x04\x9AV[\x91a\x04\x9AV[\x10a.\x16V[a.\x83`\x0Ea\x1F\x10V[aJ\xD6V[\x90V[a.\x9C\x90a.\x97a>\xCCV[aKLV[V[\x90a.\xB9\x92\x91a.\xB4a.\xAFa\x1DdV[a>7V[a/\x95V[V[\x91` a.\xDC\x92\x94\x93a.\xD5`@\x82\x01\x96_\x83\x01\x90a\x05\xBAV[\x01\x90a\x05\xBAV[V[a.\xE8``a&8V[\x90V[a.\xF5\x90Qa\x06_V[\x90V[\x90a/\x04`\xFF\x91a\x17\x82V[\x91\x81\x19\x16\x91\x16\x17\x90V[a/\x17\x90a\x06_V[\x90V[\x90V[\x90a/2a/-a/9\x92a/\x0EV[a/\x1AV[\x82Ta.\xF8V[\x90UV[\x90a/\x81`@`\x02a/\x87\x94a/`_\x82\x01a/Z_\x88\x01a'_V[\x90a,OV[a/y`\x01\x82\x01a/s` \x88\x01a'_V[\x90a,OV[\x01\x92\x01a.\xEBV[\x90a/\x1DV[V[\x90a/\x93\x91a/=V[V[\x80a/\xB0a/\xAAa/\xA5_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14a1\xC6W\x80a/\xC8a/\xC23a\x04kV[\x91a\x04kV[\x14a1\xAAW\x80;a/\xE1a/\xDB_a\"hV[\x91a\x04\x9AV[\x14a1\x8EW\x81a/\xFAa/\xF4_\x19a\x04\x9AV[\x91a\x04\x9AV[\x14\x15\x80a1mW[a1QW\x82a0\x1Aa0\x14_\x19a\x04\x9AV[\x91a\x04\x9AV[\x14\x15\x80a10W[a1\x15Wa0:a03`\x0Ea\x1F\x10V[\x82\x90aK\xD7V[a0\xCAW[a0\x84\x82a0s\x85a0j`\x01\x91a0aa0Xa.\xDEV[\x95_\x87\x01a&\x1CV[` \x85\x01a&\x1CV[`@\x83\x01a&*V[a0\x7F`\r\x84\x90a\x0B\xFDV[a/\x89V[\x90\x91a0\xB0\x7F\xAA\x80}\n\xBF0\xD9\x19h\xC7G\x8Cf\xB6\xD8%!\xA1\x06\xAF\x13\xED\xA06\xE2\x03m\xA9\xAF\x16\x89X\x92a\x05\x18V[\x92a0\xC5a0\xBCa\x04RV[\x92\x83\x92\x83a.\xBBV[\x03\x90\xA2V[\x80\x82\x90\x84a0\xF8\x7F\xDB\x03\xF9}\xC5\x84\nq\xE6\x9B\xE7G\x0EGa\xAF\x10\xA1#ys\xE8\x1C\x12\xD0\xDC(\x13\x89Ze&\x92a\x05\x18V[\x92a1\ra1\x04a\x04RV[\x92\x83\x92\x83a.\xBBV[\x03\x90\xA2a0?V[_bX\xCC\xAD`\xE8\x1B\x81R\x80a1,`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[P\x82a1Ka1Ea1@a\x15yV[a\x04\x9AV[\x91a\x04\x9AV[\x11a0\"V[_c\n9\\\x01`\xE0\x1B\x81R\x80a1i`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[P\x81a1\x88a1\x82a1}a\x15yV[a\x04\x9AV[\x91a\x04\x9AV[\x11a0\x02V[_cA*\x18\xED`\xE1\x1B\x81R\x80a1\xA6`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[_c\xFB\x8C\xE8\xC9`\xE0\x1B\x81R\x80a1\xC2`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a1\xDE`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[\x90a1\xED\x92\x91a.\x9EV[V[a1\xF7a\x1FaV[Pa2\na2\x05`\x0Ea\x1F\x10V[aJ\x87V[\x90V[_\x90V[a2#\x90a2\x1Da2\rV[PaL\x11V[\x90V[a2<a2A\x91a25a\x1FaV[P_a\t\x9FV[a\x0C,V[\x90V[``\x90V[a2Qa2DV[Pa2da2_`\x0Ea\x1F\x10V[aL@V[\x90V[a2oa\x1EaV[Pa2\x97a2\x87a2\x82`\r\x84\x90a\x0B\xFDV[a&\xABV[\x91a2\x92`\x0Ea\x1F\x10V[aJMV[\x90\x81a2\xA2W[P\x90V[a2\xAF\x91P`@\x01a.\xEBV[_a2\x9EV[\x90a2\xCF\x91a2\xCAa2\xC5a\x14]V[a>7V[a2\xD1V[V[\x80a2\xECa2\xE6a2\xE1_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14a3\xB0W\x81a3\x04a2\xFE_a\"hV[\x91a\x04\x9AV[\x14a3\x94Wa3\x1Aa3\x14a4eV[\x15a\x06_V[a3xWa3)\x81\x83\x90aEVV[3\x90a3sa3aa3[\x7F\xBE\xF4\xF8\x1C\x18\x14\xC6A\xED\xE8^\xBA\xAC\xF1\x9D\x04\x8B,[U\x98\n\xDF\xA6\xEF\x0F\x95le\x135\xA2\x93a\x05\x18V[\x93a\x05\x18V[\x93a3ja\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xA3V[_c\xB8\xB5\xCA-`\xE0\x1B\x81R\x80a3\x90`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a3\xAC`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a3\xC8`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[\x90a3\xD6\x91a2\xB5V[V[a3\xE0a\x1FaV[Pa3\xEB`\x0Ca\x0C,V[a3\xFDa3\xF7_a\"hV[\x91a\x04\x9AV[\x14\x80\x15a4,W[a4 Wa4\x1Da4\x16`\x0Ca\x0C,V[B\x90a':V[\x90V[a4)_a\"hV[\x90V[PBa4Ia4Ca4>`\x0Ca\x0C,V[a\x04\x9AV[\x91a\x04\x9AV[\x10\x15a4\x05V[a4b\x90a4\\a\x1FaV[PaLhV[\x90V[a4ma\x1EaV[Pa4x`\x0Ca\x0C,V[a4\x8Aa4\x84_a\"hV[\x91a\x04\x9AV[\x14\x15\x80a4\x95W[\x90V[PBa4\xB2a4\xACa4\xA7`\x0Ca\x0C,V[a\x04\x9AV[\x91a\x04\x9AV[\x10a4\x92V[a4\xD1\x90a4\xCCa4\xC7a\x17\xA3V[a>7V[a4\xD3V[V[\x80a4\xE6a4\xE0Ba\x04\x9AV[\x91a\x04\x9AV[\x11\x15a5\x9CW\x80a5\x1Fa5\x19\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04\x9AV[\x91a\x04\x9AV[\x11a5\x80Wa5.`\x0Ca\x0C,V[a59\x82`\x0Ca,OV[\x903\x90a5f\x7F\xDDh\x96\xDC\xF1\xD4\xB3\x11\xCC\xA8}\xD1\x9B\xBB\xA2\xEA\x9C\xE2\xF8g\xC1V\x88x\xA0C\x8Af\xA1\xAF\xEE\xEC\x92a\x05\x18V[\x92a5{a5ra\x04RV[\x92\x83\x92\x83a.\xBBV[\x03\x90\xA2V[_c\xEFi\xAFe`\xE0\x1B\x81R\x80a5\x98`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[_c\xA5e\x83S`\xE0\x1B\x81R\x80a5\xB4`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[a5\xC1\x90a4\xB8V[V[_\x90V[``\x90V[a5\xD5\x90a\x05\x0CV[\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a5\xF0W` \x80\x91\x02\x01\x90V[a!\xAFV[\x90a6\x07a6\x02\x83a5\xD8V[a&8V[\x91\x82RV[6\x907V[\x90a66a6\x1E\x83a5\xF5V[\x92` \x80a6,\x86\x93a5\xD8V[\x92\x01\x91\x03\x90a6\x0CV[V[`\x0F`\xF8\x1B\x90V[a6Ha5\xC3V[Pa6Qa \xC1V[Pa6Za \xC1V[Pa6ca\x1FaV[Pa6la+\xB8V[Pa6ua$SV[Pa6~a5\xC7V[Pa6\x87aL\x80V[\x90a6\x90aL\xC0V[\x90F\x90a6\x9C0a5\xCCV[\x90a6\xA6_a\x17\x87V[\x90a6\xB8a6\xB3_a\"hV[a6\x11V[\x90a6\xC1a68V[\x96\x95\x94\x93\x92\x91\x90V[a6\xF3a6\xF8\x91a6\xD9a\x1FaV[Pa6\xEDa6\xE7`\x0Ba)/V[\x91aG\xFCV[\x90aI\x11V[a)2V[\x90V[\x90a7\x05\x90a\x05\x18V[_R` R`@_ \x90V[a78\x91_a7-a73\x93a7%a\x1EaV[P`\x05a$cV[\x01a6\xFBV[a\x0CSV[\x90V[_\x90V[a7Ga7;V[Pa7PaJ8V[\x90V[a7[a\x1FaV[Pa7pa7k`\r\x83\x90a\x0B\xFDV[a&\xABV[\x90a7\x86Ba7\x80a\x0E\x10a&\xBAV[\x90a&\xEAV[a7\x8F_a\"hV[\x90a7\x99_a\"hV[[\x80a7\xAEa7\xA8`\x18a'\x1EV[\x91a\x04\x9AV[\x10\x15a8\x1AW\x81a7\xC7a7\xC1\x83a\x04\x9AV[\x91a\x04\x9AV[\x10\x15a7\xDCW[a7\xD7\x90a'\x0CV[a7\x9AV[\x91a8\x12a7\xD7\x91a8\x0Ca8\x07a7\xF6`\x11\x89\x90a\x05$V[a8\x01\x87\x89\x90a':V[\x90a\x05VV[a\x0C,V[\x90a\"\x84V[\x92\x90Pa7\xCEV[PP\x90Pa8)_\x83\x01a'_V[a8;a85\x83a\x04\x9AV[\x91a\x04\x9AV[\x11_\x14a8YWa8P_a8U\x93\x01a'_V[a':V[[\x90V[PPa8d_a\"hV[a8VV[a8qa \xC1V[Pa8|`\x04a\"\x0EV[\x90V[a8\xA6a8\xA1a8\x9Ca8\xAB\x93a8\x94a\x1FaV[P`\na)\x19V[a)/V[aM\0V[a)2V[\x90V[a8\xCB\x91a8\xBAa\x1EaV[Pa8\xC3a>\xCCV[\x91\x90\x91aB\xC0V[`\x01\x90V[\x90a8\xE3\x91a8\xDDa\x1FaV[Pa)NV[\x90V[a8\xF8\x90a8\xF2a\x1FaV[Pa8\x7FV[\x90V[a9\x03a\x1FaV[Pa9\x0Ca\"RV[\x90V[\x7F\xE4\x83)\x05{\xFD\x03\xD5^I\xB5G\x13.9\xCF\xFD\x9C\x18 \xAD{\x9DLS\x07i\x14%\xD1Z\xDF\x90V[a9ha9o\x94a9^``\x94\x98\x97\x95a9T`\x80\x86\x01\x9A_\x87\x01\x90a\tHV[` \x85\x01\x90a\x0E%V[`@\x83\x01\x90a\x05\xBAV[\x01\x90a\x05\xBAV[V[` \x01\x90V[Q\x90V[\x93\x95\x94\x90\x92\x91\x95Ba9\x95a9\x8F\x89a\x04\x9AV[\x91a\x04\x9AV[\x11a:\x0EW\x91a:\0\x91a:\x07\x93a9\xF7a:\x0C\x98\x99a9\xDFa9\xB6a9\x0FV[a9\xD0\x8B\x93\x8Ba9\xC4a\x04RV[\x95\x86\x94` \x86\x01a93V[` \x82\x01\x81\x03\x82R\x03\x82a!\xC3V[a9\xF1a9\xEB\x82a9wV[\x91a9qV[ aMuV[\x92\x90\x91\x92aM\x92V[\x91\x82aM\xDCV[aKLV[V[a:)\x87_\x91\x82\x91c#A\xD7\x87`\xE1\x1B\x83R`\x04\x83\x01a\x05\xC7V[\x03\x90\xFD[_\x90V[_\x90V[a:=a&MV[\x90` \x80\x80\x84a:Ka:-V[\x81R\x01a:Va:-V[\x81R\x01a:aa:1V[\x81RPPV[a:oa:5V[\x90V[a:\x89a:\x8E\x91a:\x81a:gV[P`\ra\x0B\xFDV[a&\xABV[\x90V[\x90a:\xAB\x91a:\xA6a:\xA1a\x1DdV[a>7V[a:\xADV[V[\x80a:\xC8a:\xC2a:\xBD_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14a;iWa:\xEAa:\xE4a:\xDD`\x0Ea\x1F\x10V[\x83\x90aJMV[\x15a\x06_V[a;JWa;\x06\x82`\x02a;\0`\r\x85\x90a\x0B\xFDV[\x01a/\x1DV[a;Ea;3\x7F\x9C\x86h\xDB2HE\x06]+\x9A*\x18;\xD3\x14\x1Fc\x01\x8FT\x82\x82\xDA\xF1\x8D\xA4\x9C\xCB\xF8\x8C3\x92a\x05\x18V[\x92a;<a\x04RV[\x91\x82\x91\x82a\x06qV[\x03\x90\xA2V[a;e\x90_\x91\x82\x91ce\x85\xB6\r`\xE0\x1B\x83R`\x04\x83\x01a\x0E2V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a;\x81`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[\x90a;\x8F\x91a:\x91V[V[\x7Fnq\xED\xAE\x12\xB1\xB9\x7FM\x1F`7\x0F\xEF\x10\x10_\xA2\xFA\xAE\x01&\x11J\x16\x9Cd\x84]a&\xC9\x90V[\x91\x94a;\xFDa<\x07\x92\x98\x97\x95a;\xF3`\xA0\x96a;\xE9a<\x0E\x9Aa;\xDF`\xC0\x8A\x01\x9E_\x8B\x01\x90a\tHV[` \x89\x01\x90a\x0E%V[`@\x87\x01\x90a\x0E%V[``\x85\x01\x90a\x05\xBAV[`\x80\x83\x01\x90a\x05\xBAV[\x01\x90a\x05\xBAV[V[\x91` a<1\x92\x94\x93a<*`@\x82\x01\x96_\x83\x01\x90a\x0E%V[\x01\x90a\x0E%V[V[\x96\x95\x91\x93\x92\x94\x90\x94Ba<Na<H\x83a\x04\x9AV[\x91a\x04\x9AV[\x11a=\x08W\x90a<\xB7a<\xC0\x94\x93\x92a<\x9Fa<ha;\x91V[a<\x90\x8C\x80\x94\x8C\x91a<z\x8D\x91aN\x1FV[\x91\x92a<\x84a\x04RV[\x97\x88\x96` \x88\x01a;\xB5V[` \x82\x01\x81\x03\x82R\x03\x82a!\xC3V[a<\xB1a<\xAB\x82a9wV[\x91a9qV[ aMuV[\x92\x90\x91\x92aM\x92V[\x80a<\xD3a<\xCD\x87a\x04kV[\x91a\x04kV[\x03a<\xE8WPa<\xE6\x92\x93\x91\x90\x91a>\xD9V[V[\x84\x90a=\x04_\x92\x83\x92c%\xC0\x07#`\xE1\x1B\x84R`\x04\x84\x01a<\x10V[\x03\x90\xFD[a=#\x90_\x91\x82\x91c1<\x89\x81`\xE1\x1B\x83R`\x04\x83\x01a\x05\xC7V[\x03\x90\xFD[\x90a=B\x91a==a=8\x82a$\x9DV[a>7V[a=DV[V[\x90a=N\x91aG\x1BV[PV[\x90a=[\x91a='V[V[\x90a=g\x90a\x05\x18V[_R` R`@_ \x90V[a=\x98\x91a=\x8Ea=\x93\x92a=\x86a\x1FaV[P`\x01a=]V[a\t\x9FV[a\x0C,V[\x90V[a=\xA5`@a&8V[\x90V[_\x90V[_\x90V[a=\xB8a=\x9BV[\x90` \x80\x83a=\xC5a=\xA8V[\x81R\x01a=\xD0a=\xACV[\x81RPPV[a=\xDEa=\xB0V[\x90V[\x90a=\xF4\x91a=\xEEa=\xD6V[PaNRV[\x90V[a=\xFFa\x1EaV[P\x80a>\x1Aa>\x14cye\xDB\x0B`\xE0\x1Ba\x06\x12V[\x91a\x06\x12V[\x14\x90\x81\x15a>'W[P\x90V[a>1\x91PaNzV[_a>#V[a>I\x90a>Ca>\xCCV[\x90aN\xC3V[V[a>T\x90a\x04\xF0V[\x90V[a>ka>fa>p\x92a\x04`V[a\x04\xEDV[a\x04\x9AV[\x90V[a>\x87a>\x82a>\x8C\x92a\x04\x9AV[a\x17\x82V[a\t\x04V[\x90V[\x90V[\x90a>\xC4a>\xBEa>\xB9a>\xB4_a>\xC9\x96a>\xACa\x1EaV[P\x01\x94a>KV[a>WV[a>sV[\x91a>\x8FV[aP@V[\x90V[a>\xD4a+\xB8V[P3\x90V[\x91a>\xE7\x92\x91`\x01\x92aQFV[V[\x90V[`@\x90a?\x15a?\x1C\x94\x96\x95\x93\x96a?\x0B``\x84\x01\x98_\x85\x01\x90a\x0E%V[` \x83\x01\x90a\x05\xBAV[\x01\x90a\x05\xBAV[V[a?2a?-`\r\x83\x90a\x0B\xFDV[a>\xE9V[\x91a?Pa?Ja?C`\x0Ea\x1F\x10V[\x84\x90aJMV[\x15a\x06_V[\x80\x15a@\xF9W[a@\xDAWa?pBa?ja\x0E\x10a&\xBAV[\x90a&\xEAV[a?y_a\"hV[\x91a?\x83_a\"hV[[\x80a?\x98a?\x92`\x18a'\x1EV[\x91a\x04\x9AV[\x10\x15a@\x04W\x82a?\xB1a?\xAB\x83a\x04\x9AV[\x91a\x04\x9AV[\x10\x15a?\xC6W[a?\xC1\x90a'\x0CV[a?\x84V[\x92a?\xFCa?\xC1\x91a?\xF6a?\xF1a?\xE0`\x11\x8A\x90a\x05$V[a?\xEB\x88\x8A\x90a':V[\x90a\x05VV[a\x0C,V[\x90a\"\x84V[\x93\x90Pa?\xB8V[P\x91\x90\x92\x93a@\x14\x82\x84\x90a\"\x84V[a@0a@*a@%_\x85\x01a\x0C,V[a\x04\x9AV[\x91a\x04\x9AV[\x11a@jWPPa@Sa@h\x93\x92a@Na@b\x93\x94`\x11a\x05$V[a\x05VV[\x91a@]\x83a\x0C,V[a\"\x84V[\x90a,OV[V[\x84\x93Pa@x_\x82\x01a\x0C,V[a@\x8Aa@\x84\x84a\x04\x9AV[\x91a\x04\x9AV[\x11_\x14a@\xC7Wa@\xC3\x91a@\xA3_a@\xA8\x93\x01a\x0C,V[a':V[[\x92\x91\x92_\x93\x84\x93c@\xED6{`\xE0\x1B\x85R`\x04\x85\x01a>\xECV[\x03\x90\xFD[PPa@\xC3a@\xD5_a\"hV[a@\xA9V[a@\xF5\x82_\x91\x82\x91ce\x85\xB6\r`\xE0\x1B\x83R`\x04\x83\x01a\x0E2V[\x03\x90\xFD[PaA\x0FaA\t`\x02\x85\x01a\x0CSV[\x15a\x06_V[a?WV[aA(aA#`\x10\x83\x90a\t\x9FV[a\x0C,V[aA;aA5\x84\x92a\x04\x9AV[\x91a\x04\x9AV[\x11aA\xACWaAh\x82aAbaAS`\x10\x85\x90a\t\x9FV[\x91aA]\x83a\x0C,V[a':V[\x90a,OV[aA\xA7aA\x95\x7F\xBC#\xEC\x7F\x13\x13\x15\x0B\x04{\xFF\x83\xD0\x84[\x05d\xBA\xA14i\x8D\xD1\x1B\xB0\xAC\xD0\xF7\xD4\x16\xDE}\x92a\x05\x18V[\x92aA\x9Ea\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xA2V[_c\x1E\xB7\x84W`\xE2\x1B\x81R\x80aA\xC4`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[\x80aA\xE3aA\xDDaA\xD8_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14aA\xFFWaA\xFD\x91aA\xF5_a\x1F\x04V[\x91\x90\x91aRUV[V[aB\"aB\x0B_a\x1F\x04V[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x0E2V[\x03\x90\xFD[\x90aB1\x91\x03a\x04\x9AV[\x90V[\x92\x91\x92aBB\x81\x83\x90a=sV[\x90\x81aBWaBQ_\x19a\x04\x9AV[\x91a\x04\x9AV[\x10aBdW[PPP\x90PV[\x81aBwaBq\x87a\x04\x9AV[\x91a\x04\x9AV[\x10aB\x9DWaB\x94\x93\x94aB\x8C\x91\x93\x92aB&V[\x90_\x92aQFV[\x80_\x80\x80aB]V[PaB\xBC\x84\x92\x91\x92_\x93\x84\x93c}\xC7\xA0\xD9`\xE1\x1B\x85R`\x04\x85\x01a>\xECV[\x03\x90\xFD[\x91\x82aB\xDCaB\xD6aB\xD1_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14aC6W\x81aB\xFCaB\xF6aB\xF1_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14aC\x0FWaC\r\x92\x91\x90\x91aRUV[V[aC2aC\x1B_a\x1F\x04V[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x0E2V[\x03\x90\xFD[aCYaCB_a\x1F\x04V[_\x91\x82\x91cKc~\x8F`\xE1\x1B\x83R`\x04\x83\x01a\x0E2V[\x03\x90\xFD[aCqaCl`\r\x83\x90a\x0B\xFDV[a>\xE9V[\x91aC\x8FaC\x89aC\x82`\x0Ea\x1F\x10V[\x84\x90aJMV[\x15a\x06_V[\x80\x15aE;W[aE\x1CWaC\xAFBaC\xA9a\x0E\x10a&\xBAV[\x90a&\xEAV[aC\xB8_a\"hV[\x91aC\xC2_a\"hV[[\x80aC\xD7aC\xD1`\x18a'\x1EV[\x91a\x04\x9AV[\x10\x15aDCW\x82aC\xF0aC\xEA\x83a\x04\x9AV[\x91a\x04\x9AV[\x10\x15aD\x05W[aD\0\x90a'\x0CV[aC\xC3V[\x92aD;aD\0\x91aD5aD0aD\x1F`\x12\x8A\x90a\x05$V[aD*\x88\x8A\x90a':V[\x90a\x05VV[a\x0C,V[\x90a\"\x84V[\x93\x90PaC\xF7V[P\x91\x90\x92\x93aDS\x82\x84\x90a\"\x84V[aDpaDjaDe`\x01\x85\x01a\x0C,V[a\x04\x9AV[\x91a\x04\x9AV[\x11aD\xAAWPPaD\x93aD\xA8\x93\x92aD\x8EaD\xA2\x93\x94`\x12a\x05$V[a\x05VV[\x91aD\x9D\x83a\x0C,V[a\"\x84V[\x90a,OV[V[\x84\x93PaD\xB9`\x01\x82\x01a\x0C,V[aD\xCBaD\xC5\x84a\x04\x9AV[\x91a\x04\x9AV[\x11_\x14aE\tWaE\x05\x91aD\xE5`\x01aD\xEA\x93\x01a\x0C,V[a':V[[\x92\x91\x92_\x93\x84\x93cr\xFFK\xD1`\xE1\x1B\x85R`\x04\x85\x01a>\xECV[\x03\x90\xFD[PPaE\x05aE\x17_a\"hV[aD\xEBV[aE7\x82_\x91\x82\x91ce\x85\xB6\r`\xE0\x1B\x83R`\x04\x83\x01a\x0E2V[\x03\x90\xFD[PaEQaEK`\x02\x85\x01a\x0CSV[\x15a\x06_V[aC\x96V[\x90\x81aEraElaEg_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14aE\x8EWaE\x8C\x91\x90aE\x85_a\x1F\x04V[\x90\x91aRUV[V[aE\xB1aE\x9A_a\x1F\x04V[_\x91\x82\x91cKc~\x8F`\xE1\x1B\x83R`\x04\x83\x01a\x0E2V[\x03\x90\xFD[aE\xBDa\x1EaV[PaE\xD2aE\xCC\x82\x84\x90a7\x11V[\x15a\x06_V[_\x14aF[WaE\xFA`\x01aE\xF5_aE\xED`\x05\x86\x90a$cV[\x01\x85\x90a6\xFBV[a/\x1DV[\x90aF\x03a>\xCCV[\x90aF@aF:aF4\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a$WV[\x92a\x05\x18V[\x92a\x05\x18V[\x92aFIa\x04RV[\x80aFS\x81a\x06\xD9V[\x03\x90\xA4`\x01\x90V[PP_\x90V[aFia$SV[PaFs0a5\xCCV[aF\xA5aF\x9F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04kV[\x91a\x04kV[\x14\x80aF\xE1W[_\x14aF\xD6W\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[aF\xDEaSpV[\x90V[PFaG\x15aG\x0F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04\x9AV[\x91a\x04\x9AV[\x14aF\xACV[aG#a\x1EaV[PaG/\x81\x83\x90a7\x11V[_\x14aG\xB7WaGV_aGQ_aGI`\x05\x86\x90a$cV[\x01\x85\x90a6\xFBV[a/\x1DV[\x90aG_a>\xCCV[\x90aG\x9CaG\x96aG\x90\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x95a$WV[\x92a\x05\x18V[\x92a\x05\x18V[\x92aG\xA5a\x04RV[\x80aG\xAF\x81a\x06\xD9V[\x03\x90\xA4`\x01\x90V[PP_\x90V[aG\xD1aG\xCCaG\xD6\x92a\x16\x07V[a\x04\xEDV[a\x04\x9AV[\x90V[\x91` aG\xFA\x92\x94\x93aG\xF3`@\x82\x01\x96_\x83\x01\x90a\x05\xBAV[\x01\x90a\x16\x12V[V[aH\x04a7;V[PaH\ra7?V[\x81aH aH\x1A\x83aG\xBDV[\x91a\x04\x9AV[\x10\x15aH3WPaH0\x90aTyV[\x90V[\x90aHN_\x92\x83\x92cvi\xFC\x0F`\xE1\x1B\x84R`\x04\x84\x01aG\xD9V[\x03\x90\xFD[T\x90V[\x90V[aHmaHhaHr\x92aHVV[a\x04\xEDV[a\x04\x9AV[\x90V[\x90V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[aH\x8FaH\x94\x91a\x0C\x13V[aHxV[\x90V[aH\xA1\x90TaH\x83V[\x90V[\x90V[aH\xBBaH\xB6aH\xC0\x92aH\xA4V[a\x04\xEDV[a\x04\x9AV[\x90V[`0\x1C\x90V[`\x01\x80`\xD0\x1B\x03\x16\x90V[aH\xE0aH\xE5\x91aH\xC3V[aH\xC9V[\x90V[aH\xF2\x90TaH\xD4V[\x90V[aI\taI\x04aI\x0E\x92a\x17\x7FV[a\x04\xEDV[a\x1C\xDDV[\x90V[\x90aIe\x90aI\x1Ea\x1D\xCCV[PaI*_\x84\x01aHRV[aI3_a\"hV[\x90\x80\x80aIIaIC`\x05aHYV[\x91a\x04\x9AV[\x11aI\xC6W[P\x90aI`_\x86\x01\x93\x91\x92\x93aHuV[aZ\xB4V[\x80aIxaIr_a\"hV[\x91a\x04\x9AV[\x14_\x14aI\x8EWPPaI\x8A_aH\xF5V[[\x90V[aI\xBB_\x91aI\xB6aI\xB0\x84aI\xC1\x96\x01\x92aI\xAA`\x01aH\xA7V[\x90a':V[\x91aHuV[aZ\xAAV[\x01aH\xE8V[aI\x8BV[\x80aI\xD4aI\xDA\x92\x91aW?V[\x90a':V[\x90\x83aJ\x0CaJ\x06aJ\x01_aI\xFB\x81\x8C\x01aI\xF6\x89\x91aHuV[aZ\xAAV[\x01aH\x97V[a\x16\x07V[\x91a\x16\x07V[\x10_\x14aJ\x1DWP\x90[\x90_aIOV[\x91PaJ3\x90aJ-`\x01aH\xA7V[\x90a\"\x84V[aJ\x16V[aJ@a7;V[PaJJCaTyV[\x90V[\x90aJ\x7FaJyaJtaJo_aJ\x84\x96aJga\x1EaV[P\x01\x94a>KV[a>WV[a>sV[\x91a>\x8FV[a[CV[\x90V[aJ\x9E_aJ\xA3\x92aJ\x97a\x1FaV[P\x01a>\x8FV[a[xV[\x90V[aJ\xB2aJ\xB7\x91a\x0C\x13V[a\x05:V[\x90V[aJ\xCEaJ\xC9aJ\xD3\x92a\x04\x9AV[a\x04\xEDV[a\x04`V[\x90V[aK\x01aJ\xFCaK\x0B\x93aJ\xF7_aK\x06\x95aJ\xF0a+\xB8V[P\x01a>\x8FV[a[\x8FV[aJ\xA6V[aJ\xBAV[a\x05\x0CV[\x90V[\x90aK\x1F`\x01\x80`\xA0\x1B\x03\x91a\x17\x82V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90V[\x90aKAaK<aKH\x92a\x05\x18V[aK)V[\x82TaK\x0EV[\x90UV[\x90aK\xD5\x91aK\xCFaK]\x82a+\xFEV[aKr\x84aKm`\t\x86\x90a+\xBCV[aK,V[\x82\x81\x85\x90aK\xB2aK\xACaK\xA6\x7F14\xE8\xA2\xE6\xD9~\x92\x9A~T\x01\x1E\xA5H]}\x19m\xD5\xF0\xBAMN\xF9X\x03\xE8\xE3\xFC%\x7F\x95a\x05\x18V[\x92a\x05\x18V[\x92a\x05\x18V[\x92aK\xBBa\x04RV[\x80aK\xC5\x81a\x06\xD9V[\x03\x90\xA4\x92\x91a[\xB0V[\x91a[\xC8V[V[\x90aL\taL\x03aK\xFEaK\xF9_aL\x0E\x96aK\xF1a\x1EaV[P\x01\x94a>KV[a>WV[a>sV[\x91a>\x8FV[a]\xABV[\x90V[aL8aL3aL.aL=\x93aL&a2\rV[P`\na)\x19V[a)/V[a^\x0EV[a^\x8DV[\x90V[aLW_aL\\\x92aLPa2DV[P\x01a>\x8FV[a_\xAFV[aLda2DV[P\x90V[aLz\x90aLta\x1FaV[Pa_\xC6V[\x90V[\x90V[aL\x88a \xC1V[PaL\xBD\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0aL\xB7`\x06aL}V[\x90a`\xE1V[\x90V[aL\xC8a \xC1V[PaL\xFD\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0aL\xF7`\x07aL}V[\x90a`\xE1V[\x90V[aM\x08a\x1D\xCCV[PaM\x14_\x82\x01aHRV[\x80aM'aM!_a\"hV[\x91a\x04\x9AV[\x14_\x14aM=WPPaM9_aH\xF5V[[\x90V[aMj_\x91aMeaM_\x84aMp\x96\x01\x92aMY`\x01aH\xA7V[\x90a':V[\x91aHuV[aZ\xAAV[\x01aH\xE8V[aM:V[aM\x8F\x90aM\x81a$SV[PaM\x8AaFaV[aa/V[\x90V[\x92aM\xAD\x92aM\xB6\x94aM\xA3a+\xB8V[P\x92\x90\x91\x92aa\xE1V[\x90\x92\x91\x92ac\x0CV[\x90V[\x91` aM\xDA\x92\x94\x93aM\xD3`@\x82\x01\x96_\x83\x01\x90a\x0E%V[\x01\x90a\x05\xBAV[V[aM\xE5\x81aN\x1FV[\x91aM\xF8aM\xF2\x84a\x04\x9AV[\x91a\x04\x9AV[\x03aN\x01WPPV[aN\x1B_\x92\x83\x92c\x01\xD4\xB6#`\xE6\x1B\x84R`\x04\x84\x01aM\xB9V[\x03\x90\xFD[aN3\x90aN+a\x1FaV[P`\x08a\t\x9FV[aNOaN?\x82a\x0C,V[\x91aNI\x83a'\x0CV[\x90a,OV[\x90V[\x90aNraNmaNw\x93aNea=\xD6V[P`\na)\x19V[a)/V[adnV[\x90V[aN\x82a\x1EaV[PaN\x9CaN\x96c\x01\xFF\xC9\xA7`\xE0\x1Ba\x06\x12V[\x91a\x06\x12V[\x14\x90V[\x91` aN\xC1\x92\x94\x93aN\xBA`@\x82\x01\x96_\x83\x01\x90a\x0E%V[\x01\x90a\tHV[V[\x90aN\xD8aN\xD2\x83\x83\x90a7\x11V[\x15a\x06_V[aN\xE0WPPV[aN\xFA_\x92\x83\x92c\xE2Q}?`\xE0\x1B\x84R`\x04\x84\x01aN\xA0V[\x03\x90\xFD[\x90aO\x08\x90a$WV[_R` R`@_ \x90V[T\x90V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[_R` _ \x90V[aO>\x81aO\x14V[\x82\x10\x15aOXWaOP`\x01\x91aO,V[\x91\x02\x01\x90_\x90V[aO\x18V[aOm\x90`\x08aOr\x93\x02a\x05lV[a$yV[\x90V[\x90aO\x80\x91TaO]V[\x90V[aO\x8C\x90a\x0C\x13V[\x90V[\x91\x90aO\xA5aO\xA0aO\xAD\x93a$WV[aO\x83V[\x90\x83Ta\x1F\x17V[\x90UV[\x90V[cNH{q`\xE0\x1B_R`1`\x04R`$_\xFD[T\x90V[_R` _ \x90V[aO\xDE\x81aO\xC8V[\x82\x10\x15aO\xF8WaO\xF0`\x01\x91aO\xCCV[\x91\x02\x01\x90_\x90V[aO\x18V[aP\x0F\x91aP\ta$SV[\x91aO\x8FV[V[aP\x1A\x81aO\xC8V[\x80\x15aP;W`\x01\x90\x03\x90aP8aP2\x83\x83aO\xD5V[\x90aO\xFDV[UV[aO\xB4V[aPHa\x1EaV[PaP_aPZ`\x01\x83\x01\x84\x90aN\xFEV[a\x0C,V[\x90\x81aPsaPm_a\"hV[\x91a\x04\x9AV[\x14\x15_\x14aQ?WaP\xF1\x92`\x01aP\xEC\x92\x84aP\x9A_\x96aP\x94\x85aH\xA7V[\x90a':V[aP\xB7aP\xA8\x88\x85\x01aO\x14V[aP\xB1\x86aH\xA7V[\x90a':V[\x81aP\xCAaP\xC4\x83a\x04\x9AV[\x91a\x04\x9AV[\x03aP\xF6W[PPPaP\xE6aP\xE1\x86\x83\x01aO\xB1V[aP\x11V[\x01aN\xFEV[a\x1FeV[`\x01\x90V[aQ7\x92aQ)aQ\x15aQ\x0FaQ2\x94\x8C\x89\x01aO5V[\x90aOuV[\x93aQ#\x85\x91\x8C\x89\x01aO5V[\x90aO\x8FV[\x91\x85\x85\x01aN\xFEV[a,OV[_\x80\x80aP\xD0V[PPP_\x90V[\x90\x92\x81aQcaQ]aQX_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14aR.W\x83aQ\x83aQ}aQx_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14aR\x07WaQ\xA7\x83aQ\xA2aQ\x9B`\x01\x86\x90a=]V[\x87\x90a\t\x9FV[a,OV[aQ\xB1W[PPPV[\x91\x90\x91aQ\xFCaQ\xEAaQ\xE4\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%\x93a\x05\x18V[\x93a\x05\x18V[\x93aQ\xF3a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xA3_\x80\x80aQ\xACV[aR*aR\x13_a\x1F\x04V[_\x91\x82\x91cJ\x14\x06\xB1`\xE1\x1B\x83R`\x04\x83\x01a\x0E2V[\x03\x90\xFD[aRQaR:_a\x1F\x04V[_\x91\x82\x91c\xE6\x02\xDF\x05`\xE0\x1B\x83R`\x04\x83\x01a\x0E2V[\x03\x90\xFD[\x91\x82aRqaRkaRf_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14\x15\x80aR\xDCW[aR\x8CW[aR\x8A\x92\x91\x90\x91ad\x8FV[V[aR\x94a4eV[\x80aR\xBBW[\x15aR~W_c6\xE2x\xFD`\xE2\x1B\x81R\x80aR\xB7`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[PaR\xD7aR\xD1aR\xCAa\x14]V[3\x90a7\x11V[\x15a\x06_V[aR\x9AV[P\x81aR\xF8aR\xF2aR\xED_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14\x15aRyV[\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x90V[\x90\x95\x94\x92aSn\x94aS]aSg\x92aSS`\x80\x96aSI`\xA0\x88\x01\x9C_\x89\x01\x90a\tHV[` \x87\x01\x90a\tHV[`@\x85\x01\x90a\tHV[``\x83\x01\x90a\x05\xBAV[\x01\x90a\x0E%V[V[aSxa$SV[PaS\x81aR\xFFV[aS\xF8\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91aS\xE9\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0FaS\xD40a5\xCCV[\x91aS\xDDa\x04RV[\x96\x87\x95` \x87\x01aS#V[` \x82\x01\x81\x03\x82R\x03\x82a!\xC3V[aT\naT\x04\x82a9wV[\x91a9qV[ \x90V[\x90V[aT%aT aT*\x92aT\x0EV[a\x04\xEDV[a\n\xCDV[\x90V[aT6\x90aT\x11V[\x90RV[\x91` aT[\x92\x94\x93aTT`@\x82\x01\x96_\x83\x01\x90aT-V[\x01\x90a\x05\xBAV[V[aTqaTlaTv\x92a\x04\x9AV[a\x04\xEDV[a\x16\x07V[\x90V[aT\x81a7;V[P\x80aT\x9BaT\x95e\xFF\xFF\xFF\xFF\xFF\xFFaG\xBDV[\x91a\x04\x9AV[\x11aT\xACWaT\xA9\x90aT]V[\x90V[`0aT\xC8_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01aT:V[\x03\x90\xFD[\x90V[aT\xE3aT\xDEaT\xE8\x92aT\xCCV[a\x04\xEDV[a\x04\x9AV[\x90V[\x90V[aU\x02aT\xFDaU\x07\x92aT\xEBV[a\x04\xEDV[a\n\xCDV[\x90V[aU)\x90aU#aU\x1DaU.\x94a\n\xCDV[\x91a\x04\x9AV[\x90a\x05lV[a\x04\x9AV[\x90V[\x90V[aUHaUCaUM\x92aU1V[a\x04\xEDV[a\n\xCDV[\x90V[aUo\x90aUiaUcaUt\x94a\n\xCDV[\x91a\x04\x9AV[\x90a\x1F\x13V[a\x04\x9AV[\x90V[\x90V[aU\x8EaU\x89aU\x93\x92aUwV[a\x04\xEDV[a\x04\x9AV[\x90V[\x90V[aU\xADaU\xA8aU\xB2\x92aU\x96V[a\x04\xEDV[a\n\xCDV[\x90V[\x90V[aU\xCCaU\xC7aU\xD1\x92aU\xB5V[a\x04\xEDV[a\x04\x9AV[\x90V[\x90V[aU\xEBaU\xE6aU\xF0\x92aU\xD4V[a\x04\xEDV[a\n\xCDV[\x90V[\x90V[aV\naV\x05aV\x0F\x92aU\xF3V[a\x04\xEDV[a\x04\x9AV[\x90V[\x90V[aV)aV$aV.\x92aV\x12V[a\x04\xEDV[a\n\xCDV[\x90V[\x90V[aVHaVCaVM\x92aV1V[a\x04\xEDV[a\x04\x9AV[\x90V[\x90V[aVgaVbaVl\x92aVPV[a\x04\xEDV[a\n\xCDV[\x90V[aV\x83aV~aV\x88\x92aU\xD4V[a\x04\xEDV[a\x04\x9AV[\x90V[\x90V[aV\xA2aV\x9DaV\xA7\x92aV\x8BV[a\x04\xEDV[a\n\xCDV[\x90V[aV\xBEaV\xB9aV\xC3\x92aVPV[a\x04\xEDV[a\x04\x9AV[\x90V[aV\xDAaV\xD5aV\xDF\x92aH\xA4V[a\x04\xEDV[a\n\xCDV[\x90V[\x90V[aV\xF9aV\xF4aV\xFE\x92aV\xE2V[a\x04\xEDV[a\x04\x9AV[\x90V[\x90aW\x0C\x91\x02a\x04\x9AV[\x90V[aW\x1BaW!\x91a\x04\x9AV[\x91a\x04\x9AV[\x90\x81\x15aW,W\x04\x90V[a&\xD6V[\x90aW<\x91\x01a\x04\x9AV[\x90V[aWGa\x1FaV[P\x80aW\\aWV`\x01aH\xA7V[\x91a\x04\x9AV[\x11\x15aZ\xA7W\x80aYqaYNaY>aY.aY\x1EaY\x0EaX\xFEaX\xEEaX\xDEaX\xCEaX\xBE\x8BaX\xB8aX\xB1aYw\x9FaX\x91aX\x81aX\xA1\x92aW\xA3`\x01aH\xA7V[\x90\x80aW\xBBaW\xB5`\x01`\x80\x1BaT\xCFV[\x91a\x04\x9AV[\x10\x15aZyW[\x80aW\xDEaW\xD8h\x01\0\0\0\0\0\0\0\0aUzV[\x91a\x04\x9AV[\x10\x15aZKW[\x80aW\xFDaW\xF7d\x01\0\0\0\0aU\xB8V[\x91a\x04\x9AV[\x10\x15aZ\x1DW[\x80aX\x1AaX\x14b\x01\0\0aU\xF6V[\x91a\x04\x9AV[\x10\x15aY\xEFW[\x80aX6aX0a\x01\0aV4V[\x91a\x04\x9AV[\x10\x15aY\xC1W[\x80aXQaXK`\x10aVoV[\x91a\x04\x9AV[\x10\x15aY\x93W[aXkaXe`\x04aV\xAAV[\x91a\x04\x9AV[\x10\x15aYzW[aX|`\x03aV\xE5V[aW\x01V[aX\x8B`\x01aV\xC6V[\x90aU\nV[aX\x9B\x81\x86aW\x0FV[\x90aW1V[aX\xAB`\x01aV\xC6V[\x90aU\nV[\x80\x92aW\x0FV[\x90aW1V[aX\xC8`\x01aV\xC6V[\x90aU\nV[aX\xD8\x81\x8CaW\x0FV[\x90aW1V[aX\xE8`\x01aV\xC6V[\x90aU\nV[aX\xF8\x81\x8AaW\x0FV[\x90aW1V[aY\x08`\x01aV\xC6V[\x90aU\nV[aY\x18\x81\x88aW\x0FV[\x90aW1V[aY(`\x01aV\xC6V[\x90aU\nV[aY8\x81\x86aW\x0FV[\x90aW1V[aYH`\x01aV\xC6V[\x90aU\nV[\x91aYkaYeaY`\x85\x80\x94aW\x0FV[a\x04\x9AV[\x91a\x04\x9AV[\x11ae\x1FV[\x90aB&V[\x90V[aY\x8E\x90aY\x88`\x01aV\xC6V[\x90aUPV[aXrV[aY\xAAaY\xBB\x91aY\xA4`\x04aVSV[\x90aU\nV[\x91aY\xB5`\x02aV\x8EV[\x90aUPV[\x90aXXV[aY\xD8aY\xE9\x91aY\xD2`\x08aV\x15V[\x90aU\nV[\x91aY\xE3`\x04aVSV[\x90aUPV[\x90aX=V[aZ\x06aZ\x17\x91aZ\0`\x10aU\xD7V[\x90aU\nV[\x91aZ\x11`\x08aV\x15V[\x90aUPV[\x90aX!V[aZ4aZE\x91aZ.` aU\x99V[\x90aU\nV[\x91aZ?`\x10aU\xD7V[\x90aUPV[\x90aX\x04V[aZbaZs\x91aZ\\`@aU4V[\x90aU\nV[\x91aZm` aU\x99V[\x90aUPV[\x90aW\xE5V[aZ\x90aZ\xA1\x91aZ\x8A`\x80aT\xEEV[\x90aU\nV[\x91aZ\x9B`@aU4V[\x90aUPV[\x90aW\xC2V[\x90V[_R` _ \x01\x90V[\x93\x91\x90\x92aZ\xC0a\x1FaV[P[\x81aZ\xD5aZ\xCF\x83a\x04\x9AV[\x91a\x04\x9AV[\x10\x15a[;WaZ\xE6\x82\x82\x90aeIV[\x90aZ\xFC_aZ\xF6\x88\x85\x90aZ\xAAV[\x01aH\x97V[a[\x0Ea[\x08\x87a\x16\x07V[\x91a\x16\x07V[\x11_\x14a[\x1EWP\x91[\x91aZ\xC2V[\x92\x91Pa[5\x90a[/`\x01aH\xA7V[\x90a\"\x84V[\x90a[\x18V[\x92PP\x91P\x90V[a[a\x91`\x01a[\\\x92a[Ua\x1EaV[P\x01aN\xFEV[a\x0C,V[a[sa[m_a\"hV[\x91a\x04\x9AV[\x14\x15\x90V[_a[\x8C\x91a[\x85a\x1FaV[P\x01aO\x14V[\x90V[a[\xAD\x91_a[\xA7\x92a[\xA0a$SV[P\x01aO5V[\x90aOuV[\x90V[a[\xC2\x90a[\xBCa\x1FaV[Pa2&V[\x90V[\x90V[\x91\x90\x91\x80a[\xDEa[\xD8\x85a\x04kV[\x91a\x04kV[\x14\x15\x80a]\\W[a[\xF0W[PPPV[\x80a\\\x0Ba\\\x05a\\\0_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x03a\\\xCCW[P\x81a\\-a\\'a\\\"_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x03a\\9W[\x80a[\xEBV[a\\\x80a\\sa\\z\x92a\\O`\n\x86\x90a)\x19V[\x90a\\ma\\ga\\a`\x01\x93ae\xE2V[\x93a)/V[\x91a[\xC5V[\x90af5V[\x92\x90a)2V[\x91a)2V[\x91\x90\x91a\\\xAD\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\x05\x18V[\x92a\\\xC2a\\\xB9a\x04RV[\x92\x83\x92\x83a.\xBBV[\x03\x90\xA2_\x80a\\3V[a]\x0Ba]\x11a]\x04a\\\xE1`\n\x85\x90a)\x19V[`\x02a\\\xFEa\\\xF8a\\\xF2\x89ae\xE2V[\x93a)/V[\x91a[\xC5V[\x90af5V[\x92\x90a)2V[\x91a)2V[\x91\x90\x91a]>\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\x05\x18V[\x92a]Sa]Ja\x04RV[\x92\x83\x92\x83a.\xBBV[\x03\x90\xA2_a\\\x11V[P\x81a]pa]j_a\"hV[\x91a\x04\x9AV[\x11a[\xE6V[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15a]\xA6W\x82a]\x9E\x91`\x01a]\xA4\x95\x01\x81UaO\xD5V[\x90aO\x8FV[V[a!\xAFV[a]\xB3a\x1EaV[Pa]\xC8a]\xC2\x82\x84\x90a[CV[\x15a\x06_V[_\x14a^\x08Wa]\xFEa^\x03\x92a]\xEAa]\xE3_\x85\x01aO\xB1V[\x82\x90a]vV[`\x01a]\xF7_\x85\x01aO\x14V[\x93\x01aN\xFEV[a,OV[`\x01\x90V[PP_\x90V[_a^\"\x91a^\x1Ba\x1FaV[P\x01aHRV[\x90V[a^9a^4a^>\x92a\x10\x12V[a\x04\xEDV[a\x04\x9AV[\x90V[a^J\x90aU\x99V[\x90RV[\x91` a^o\x92\x94\x93a^h`@\x82\x01\x96_\x83\x01\x90a^AV[\x01\x90a\x05\xBAV[V[a^\x85a^\x80a^\x8A\x92a\x04\x9AV[a\x04\xEDV[a\x10\x12V[\x90V[a^\x95a2\rV[P\x80a^\xADa^\xA7c\xFF\xFF\xFF\xFFa^%V[\x91a\x04\x9AV[\x11a^\xBEWa^\xBB\x90a^qV[\x90V[` a^\xDA_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01a^NV[\x03\x90\xFD[``\x90V[` \x91\x81R\x01\x90V[a^\xF5\x90a\t\x04V[\x90RV[\x90a_\x06\x81` \x93a^\xECV[\x01\x90V[a_\x14\x90Ta$|V[\x90V[`\x01\x01\x90V[\x90a_:a_4a_-\x84aO\x14V[\x80\x93a^\xE3V[\x92aO,V[\x90_[\x81\x81\x10a_JWPPP\x90V[\x90\x91\x92a_ja_d`\x01\x92a__\x87a_\nV[a^\xF9V[\x94a_\x17V[\x91\x01\x91\x90\x91a_=V[\x90a_~\x91a_\x1DV[\x90V[\x90a_\xA1a_\x9A\x92a_\x91a\x04RV[\x93\x84\x80\x92a_tV[\x03\x83a!\xC3V[V[a_\xAC\x90a_\x81V[\x90V[_a_\xC3\x91a_\xBCa^\xDEV[P\x01a_\xA3V[\x90V[a_\xDDa_\xE2\x91a_\xD5a\x1FaV[P`\x08a\t\x9FV[a\x0C,V[\x90V[\x90V[a_\xFCa_\xF7a`\x01\x92a_\xE5V[a\x17\x82V[a\t\x04V[\x90V[a`\x0E`\xFFa_\xE8V[\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a`4a`-\x83a \xDAV[\x80\x94a!\x04V[\x91`\x01\x81\x16\x90\x81_\x14a`\x8BWP`\x01\x14a`OW[PPPV[a`\\\x91\x92\x93\x94Pa`\x11V[\x91_\x92[\x81\x84\x10a`sWPP\x01\x90_\x80\x80a`JV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a``V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a`JV[\x90a`\xB0\x91a`\x1AV[\x90V[\x90a`\xD3a`\xCC\x92a`\xC3a\x04RV[\x93\x84\x80\x92a`\xA6V[\x03\x83a!\xC3V[V[a`\xDE\x90a`\xB3V[\x90V[\x90a`\xEAa \xC1V[Pa`\xF4\x82a$WV[aa\raa\x07aa\x02a`\x04V[a\t\x04V[\x91a\t\x04V[\x14\x15_\x14aa\"WPaa\x1F\x90af\xBFV[\x90V[aa,\x91Pa`\xD5V[\x90V[`B\x91aa:a$SV[P`@Q\x91\x7F\x19\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83R`\x02\x83\x01R`\"\x82\x01R \x90V[_\x90V[\x90V[aa\x8Baa\x86aa\x90\x92aatV[a\x04\xEDV[a\x04\x9AV[\x90V[aa\xC8aa\xCF\x94aa\xBE``\x94\x98\x97\x95aa\xB4`\x80\x86\x01\x9A_\x87\x01\x90a\tHV[` \x85\x01\x90a\n\xD3V[`@\x83\x01\x90a\tHV[\x01\x90a\tHV[V[aa\xD9a\x04RV[=_\x82>=\x90\xFD[\x93\x92\x93aa\xECa+\xB8V[Paa\xF5aapV[Paa\xFEa$SV[Pab\x08\x85aJ\xA6V[ab:ab4\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0aawV[\x91a\x04\x9AV[\x11ab\xC7W\x90ab]` \x94\x95_\x94\x93\x92\x93abTa\x04RV[\x94\x85\x94\x85aa\x93V[\x83\x80R\x03\x90`\x01Z\xFA\x15ab\xC2Wabu_Qa\x17\x82V[\x80ab\x90ab\x8Aab\x85_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14ab\xA6W_\x91ab\xA0_a\x17\x87V[\x91\x92\x91\x90V[Pab\xB0_a\x1F\x04V[`\x01\x91ab\xBC_a\x17\x87V[\x91\x92\x91\x90V[aa\xD1V[PPPab\xD3_a\x1F\x04V[\x90`\x03\x92\x91\x92\x91\x90V[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x04\x11\x15ab\xFBWV[ab\xDDV[\x90ac\n\x82ab\xF1V[V[\x80ac\x1Fac\x19_ac\0V[\x91ac\0V[\x14_\x14ac*WPPV[\x80ac>ac8`\x01ac\0V[\x91ac\0V[\x14_\x14acaW_c\xF6E\xEE\xDF`\xE0\x1B\x81R\x80ac]`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[\x80acuaco`\x02ac\0V[\x91ac\0V[\x14_\x14ac\xA3Wac\x9Fac\x88\x83aJ\xA6V[_\x91\x82\x91c\xFC\xE6\x98\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x05\xC7V[\x03\x90\xFD[ac\xB6ac\xB0`\x03ac\0V[\x91ac\0V[\x14ac\xBEWPV[ac\xD9\x90_\x91\x82\x91c5\xE2\xF3\x83`\xE2\x1B\x83R`\x04\x83\x01a\tUV[\x03\x90\xFD[_R` _ \x90V[ac\xEF\x81aHRV[\x82\x10\x15ad\tWad\x01`\x01\x91ac\xDDV[\x91\x02\x01\x90_\x90V[aO\x18V[\x90ad\x18\x90a\x16\x07V[\x90RV[\x90ad&\x90a\x1C\xDDV[\x90RV[\x90ad`adW_ad:a=\x9BV[\x94adQadI\x83\x83\x01aH\x97V[\x83\x88\x01ad\x0EV[\x01aH\xE8V[` \x84\x01ad\x1CV[V[adk\x90ad*V[\x90V[ad\x8C\x91_ad\x86\x92ad\x7Fa=\xD6V[P\x01ac\xE6V[PadbV[\x90V[\x92\x91ad\x9D\x84\x83\x83\x91af\xEFV[\x83ad\xB8ad\xB2ad\xAD_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14ad\xCDW[ad\xCB\x92\x93\x91\x90\x91ahyV[V[ad\xD5a\"RV[\x93ad\xDEah^V[\x94\x80ad\xF2ad\xEC\x88a\x04\x9AV[\x91a\x04\x9AV[\x11ad\xFFWP\x93Pad\xBEV[\x85\x90ae\x1B_\x92\x83\x92c\x0EX\xAE\x93`\xE1\x1B\x84R`\x04\x84\x01a.\xBBV[\x03\x90\xFD[ae'a\x1FaV[P\x15\x15\x90V[aeAae<aeF\x92aV\x8BV[a\x04\xEDV[a\x04\x9AV[\x90V[aenaet\x92aeXa\x1FaV[P\x82\x81\x16\x92\x18aeh`\x02ae-V[\x90a&\xEAV[\x90a\"\x84V[\x90V[\x90V[ae\x8Eae\x89ae\x93\x92aewV[a\x04\xEDV[a\n\xCDV[\x90V[ae\x9F\x90aezV[\x90RV[\x91` ae\xC4\x92\x94\x93ae\xBD`@\x82\x01\x96_\x83\x01\x90ae\x96V[\x01\x90a\x05\xBAV[V[ae\xDAae\xD5ae\xDF\x92a\x04\x9AV[a\x04\xEDV[a\x1C\xDDV[\x90V[ae\xEAa\x1D\xCCV[P\x80af\x04ae\xFE`\x01\x80`\xD0\x1B\x03a)2V[\x91a\x04\x9AV[\x11af\x15Waf\x12\x90ae\xC6V[\x90V[`\xD0af1_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01ae\xA3V[\x03\x90\xFD[\x90afkafq\x93\x92afFa\x1D\xCCV[PafOa\x1D\xCCV[P\x80\x93afdaf]a7?V[\x94\x92aM\0V[\x90\x91al\xE1V[\x91ai8V[\x91\x90\x91\x90V[af\x8Baf\x86af\x90\x92aU\x96V[a\x04\xEDV[a\x04\x9AV[\x90V[6\x907V[\x90af\xBDaf\xA5\x83a+\0V[\x92` \x80af\xB3\x86\x93a*\xDDV[\x92\x01\x91\x03\x90af\x93V[V[af\xC7a \xC1V[Paf\xD1\x81ai\xA2V[\x90af\xE4af\xDF` afwV[af\x98V[\x91\x82R` \x82\x01R\x90V[\x91\x90\x91\x80ag\rag\x07ag\x02_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14_\x14ag\xEEWag1ag*\x83ag%`\x02a\x0C,V[a\"\x84V[`\x02a,OV[[\x82agMagGagB_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14_\x14ag\xC2Wagqagj\x83age`\x02a\x0C,V[aB&V[`\x02a,OV[[\x91\x90\x91ag\xBDag\xABag\xA5\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x93a\x05\x18V[\x93a\x05\x18V[\x93ag\xB4a\x04RV[\x91\x82\x91\x82a\x05\xC7V[\x03\x90\xA3V[ag\xE9\x82ag\xE3ag\xD4_\x87\x90a\t\x9FV[\x91ag\xDE\x83a\x0C,V[aW1V[\x90a,OV[agrV[ah\x01ag\xFC_\x83\x90a\t\x9FV[a\x0C,V[\x80ah\x14ah\x0E\x85a\x04\x9AV[\x91a\x04\x9AV[\x10ah<Wah'ah7\x91\x84\x90aB&V[ah2_\x84\x90a\t\x9FV[a,OV[ag2V[\x90ahZ\x90\x91\x92_\x93\x84\x93c9\x144\xE3`\xE2\x1B\x85R`\x04\x85\x01a>\xECV[\x03\x90\xFD[ahfa\x1FaV[Pahv`\x01\x80`\xD0\x1B\x03a)2V[\x90V[\x91ah\xD1ah\xCBah\xD8\x94\x80ah\x9Fah\x99ah\x94_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14ai\tW[\x84ah\xC0ah\xBAah\xB5_a\x1F\x04V[a\x04kV[\x91a\x04kV[\x14ah\xDAW[a+\xFEV[\x92a+\xFEV[\x90\x91a[\xC8V[V[ai\x02`\x0B`\x02ah\xFCah\xF6ah\xF0\x89ae\xE2V[\x93a)/V[\x91a[\xC5V[\x90af5V[PPah\xC6V[ai1`\x0B`\x01ai+ai%ai\x1F\x89ae\xE2V[\x93a)/V[\x91a[\xC5V[\x90af5V[PPah\xA5V[\x91ai\\_aia\x94aiIa\x1D\xCCV[PaiRa\x1D\xCCV[P\x01\x92\x91\x92aHuV[ak\x93V[\x91\x90\x91\x90V[ai{aivai\x80\x92a_\xE5V[a\x04\xEDV[a\x04\x9AV[\x90V[\x90V[ai\x9Aai\x95ai\x9F\x92ai\x83V[a\x04\xEDV[a\x04\x9AV[\x90V[ai\xB7ai\xBC\x91ai\xB1a\x1FaV[Pa$WV[aJ\xA6V[ai\xC6`\xFFaigV[\x16\x80ai\xDBai\xD5`\x1Fai\x86V[\x91a\x04\x9AV[\x11ai\xE3W\x90V[_c,\xD4J\xC3`\xE2\x1B\x81R\x80ai\xFB`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[T\x90V[aj\r`@a&8V[\x90V[_R` _ \x90V[aj\"\x81ai\xFFV[\x82\x10\x15aj<Waj4`\x01\x91aj\x10V[\x91\x02\x01\x90_\x90V[aO\x18V[ajK\x90Qa\x16\x07V[\x90V[\x90aj_e\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x17\x82V[\x91\x81\x19\x16\x91\x16\x17\x90V[aj}ajxaj\x82\x92a\x16\x07V[a\x04\xEDV[a\x16\x07V[\x90V[\x90V[\x90aj\x9Daj\x98aj\xA4\x92ajiV[aj\x85V[\x82TajNV[\x90UV[aj\xB2\x90Qa\x1C\xDDV[\x90V[`0\x1B\x90V[\x90aj\xCDe\xFF\xFF\xFF\xFF\xFF\xFF\x19\x91aj\xB5V[\x91\x81\x19\x16\x91\x16\x17\x90V[aj\xEBaj\xE6aj\xF0\x92a\x1C\xDDV[a\x04\xEDV[a\x1C\xDDV[\x90V[\x90V[\x90ak\x0Bak\x06ak\x12\x92aj\xD7V[aj\xF3V[\x82Taj\xBBV[\x90UV[\x90ak@` _akF\x94ak8\x82\x82\x01ak2\x84\x88\x01ajAV[\x90aj\x88V[\x01\x92\x01aj\xA8V[\x90aj\xF6V[V[\x91\x90akYWakW\x91ak\x16V[V[a\x1F\x9AV[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15ak\x8EW\x82ak\x86\x91`\x01ak\x8C\x95\x01\x81Uaj\x19V[\x90akHV[V[a!\xAFV[\x90\x92\x91\x92ak\x9Fa\x1D\xCCV[Pak\xA8a\x1D\xCCV[Pak\xB2\x82ai\xFFV[\x80ak\xC5ak\xBF_a\"hV[\x91a\x04\x9AV[\x11_\x14al\x95Wak\xEB\x90ak\xE5\x84\x91ak\xDF`\x01aH\xA7V[\x90a':V[\x90aZ\xAAV[\x90ak\xF7_\x83\x01aH\x97V[\x92al\x03_\x84\x01aH\xE8V[\x93\x80al\x17al\x11\x85a\x16\x07V[\x91a\x16\x07V[\x11alyWal.al(\x84a\x16\x07V[\x91a\x16\x07V[\x14_\x14alIWPPalD\x90_\x85\x91\x01aj\xF6V[[\x91\x90V[alt\x92Palo\x86alfal]aj\x03V[\x94_\x86\x01ad\x0EV[` \x84\x01ad\x1CV[ak^V[alEV[_c% `\x1D`\xE0\x1B\x81R\x80al\x91`\x04\x82\x01a\x06\xD9V[\x03\x90\xFD[Pal\xC0\x91al\xBB\x85al\xB2al\xA9aj\x03V[\x94_\x86\x01ad\x0EV[` \x84\x01ad\x1CV[ak^V[al\xC9_aH\xF5V[\x91\x90V[cNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[\x91\x90\x91\x80`\x01\x14am\0W`\x02\x03al\xCDWal\xFC\x91a\x1EKV[\x90[V[Pam\n\x91a\x1E\x0CV[\x90al\xFEV",
    );
    /**Custom error with signature `AccessControlBadConfirmation()` and selector `0x6697b232`.
```solidity
error AccessControlBadConfirmation();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlBadConfirmation {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlBadConfirmation>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlBadConfirmation) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlBadConfirmation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlBadConfirmation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlBadConfirmation()";
            const SELECTOR: [u8; 4] = [102u8, 151u8, 178u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `AccessControlUnauthorizedAccount(address,bytes32)` and selector `0xe2517d3f`.
```solidity
error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub neededRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlUnauthorizedAccount) -> Self {
                (value.account, value.neededRole)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    neededRole: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlUnauthorizedAccount(address,bytes32)";
            const SELECTOR: [u8; 4] = [226u8, 81u8, 125u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.neededRole),
                )
            }
        }
    };
    /**Custom error with signature `BridgeMustBeContract()` and selector `0x825431da`.
```solidity
error BridgeMustBeContract();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BridgeMustBeContract {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BridgeMustBeContract> for UnderlyingRustTuple<'_> {
            fn from(value: BridgeMustBeContract) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BridgeMustBeContract {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BridgeMustBeContract {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BridgeMustBeContract()";
            const SELECTOR: [u8; 4] = [130u8, 84u8, 49u8, 218u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `BridgeNotActive(address)` and selector `0xefda0e06`.
```solidity
error BridgeNotActive(address bridge);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BridgeNotActive {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BridgeNotActive> for UnderlyingRustTuple<'_> {
            fn from(value: BridgeNotActive) -> Self {
                (value.bridge,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BridgeNotActive {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { bridge: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BridgeNotActive {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BridgeNotActive(address)";
            const SELECTOR: [u8; 4] = [239u8, 218u8, 14u8, 6u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `BurnOnlyDuringLockPeriod()` and selector `0xb8b5ca2d`.
```solidity
error BurnOnlyDuringLockPeriod();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BurnOnlyDuringLockPeriod {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BurnOnlyDuringLockPeriod>
        for UnderlyingRustTuple<'_> {
            fn from(value: BurnOnlyDuringLockPeriod) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for BurnOnlyDuringLockPeriod {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BurnOnlyDuringLockPeriod {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BurnOnlyDuringLockPeriod()";
            const SELECTOR: [u8; 4] = [184u8, 181u8, 202u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `CannotAddSelfAsBridge()` and selector `0xfb8ce8c9`.
```solidity
error CannotAddSelfAsBridge();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CannotAddSelfAsBridge {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CannotAddSelfAsBridge> for UnderlyingRustTuple<'_> {
            fn from(value: CannotAddSelfAsBridge) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for CannotAddSelfAsBridge {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CannotAddSelfAsBridge {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CannotAddSelfAsBridge()";
            const SELECTOR: [u8; 4] = [251u8, 140u8, 232u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `CheckpointUnorderedInsertion()` and selector `0x2520601d`.
```solidity
error CheckpointUnorderedInsertion();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CheckpointUnorderedInsertion {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CheckpointUnorderedInsertion>
        for UnderlyingRustTuple<'_> {
            fn from(value: CheckpointUnorderedInsertion) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for CheckpointUnorderedInsertion {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CheckpointUnorderedInsertion {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CheckpointUnorderedInsertion()";
            const SELECTOR: [u8; 4] = [37u8, 32u8, 96u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignature()` and selector `0xf645eedf`.
```solidity
error ECDSAInvalidSignature();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignature {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignature> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignature) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignature()";
            const SELECTOR: [u8; 4] = [246u8, 69u8, 238u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureLength(uint256)` and selector `0xfce698f7`.
```solidity
error ECDSAInvalidSignatureLength(uint256 length);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureLength {
        #[allow(missing_docs)]
        pub length: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureLength>
        for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureLength) -> Self {
                (value.length,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ECDSAInvalidSignatureLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { length: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureLength(uint256)";
            const SELECTOR: [u8; 4] = [252u8, 230u8, 152u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.length),
                )
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureS(bytes32)` and selector `0xd78bce0c`.
```solidity
error ECDSAInvalidSignatureS(bytes32 s);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureS {
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureS> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureS) -> Self {
                (value.s,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignatureS {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { s: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureS {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureS(bytes32)";
            const SELECTOR: [u8; 4] = [215u8, 139u8, 206u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
        }
    };
    /**Custom error with signature `ERC20ExceededSafeSupply(uint256,uint256)` and selector `0x1cb15d26`.
```solidity
error ERC20ExceededSafeSupply(uint256 increasedSupply, uint256 cap);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20ExceededSafeSupply {
        #[allow(missing_docs)]
        pub increasedSupply: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub cap: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20ExceededSafeSupply> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20ExceededSafeSupply) -> Self {
                (value.increasedSupply, value.cap)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20ExceededSafeSupply {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    increasedSupply: tuple.0,
                    cap: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20ExceededSafeSupply {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20ExceededSafeSupply(uint256,uint256)";
            const SELECTOR: [u8; 4] = [28u8, 177u8, 93u8, 38u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.increasedSupply),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.cap),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InsufficientAllowance(address,uint256,uint256)` and selector `0xfb8f41b2`.
```solidity
error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InsufficientAllowance {
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub allowance: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub needed: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InsufficientAllowance>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InsufficientAllowance) -> Self {
                (value.spender, value.allowance, value.needed)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC20InsufficientAllowance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    spender: tuple.0,
                    allowance: tuple.1,
                    needed: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InsufficientAllowance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InsufficientAllowance(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [251u8, 143u8, 65u8, 178u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allowance),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.needed),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InsufficientBalance(address,uint256,uint256)` and selector `0xe450d38c`.
```solidity
error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InsufficientBalance {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub balance: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub needed: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InsufficientBalance>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InsufficientBalance) -> Self {
                (value.sender, value.balance, value.needed)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC20InsufficientBalance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    sender: tuple.0,
                    balance: tuple.1,
                    needed: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InsufficientBalance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InsufficientBalance(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [228u8, 80u8, 211u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.balance),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.needed),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidApprover(address)` and selector `0xe602df05`.
```solidity
error ERC20InvalidApprover(address approver);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidApprover {
        #[allow(missing_docs)]
        pub approver: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidApprover> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidApprover) -> Self {
                (value.approver,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidApprover {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { approver: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidApprover {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidApprover(address)";
            const SELECTOR: [u8; 4] = [230u8, 2u8, 223u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.approver,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidReceiver(address)` and selector `0xec442f05`.
```solidity
error ERC20InvalidReceiver(address receiver);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidReceiver {
        #[allow(missing_docs)]
        pub receiver: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidReceiver> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidReceiver) -> Self {
                (value.receiver,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidReceiver {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { receiver: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidReceiver {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidReceiver(address)";
            const SELECTOR: [u8; 4] = [236u8, 68u8, 47u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.receiver,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidSender(address)` and selector `0x96c6fd1e`.
```solidity
error ERC20InvalidSender(address sender);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidSender {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidSender> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidSender) -> Self {
                (value.sender,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidSender {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { sender: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidSender {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidSender(address)";
            const SELECTOR: [u8; 4] = [150u8, 198u8, 253u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidSpender(address)` and selector `0x94280d62`.
```solidity
error ERC20InvalidSpender(address spender);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidSpender {
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidSpender> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidSpender) -> Self {
                (value.spender,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidSpender {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { spender: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidSpender {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidSpender(address)";
            const SELECTOR: [u8; 4] = [148u8, 40u8, 13u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC2612ExpiredSignature(uint256)` and selector `0x62791302`.
```solidity
error ERC2612ExpiredSignature(uint256 deadline);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC2612ExpiredSignature {
        #[allow(missing_docs)]
        pub deadline: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC2612ExpiredSignature> for UnderlyingRustTuple<'_> {
            fn from(value: ERC2612ExpiredSignature) -> Self {
                (value.deadline,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC2612ExpiredSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { deadline: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC2612ExpiredSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC2612ExpiredSignature(uint256)";
            const SELECTOR: [u8; 4] = [98u8, 121u8, 19u8, 2u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.deadline),
                )
            }
        }
    };
    /**Custom error with signature `ERC2612InvalidSigner(address,address)` and selector `0x4b800e46`.
```solidity
error ERC2612InvalidSigner(address signer, address owner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC2612InvalidSigner {
        #[allow(missing_docs)]
        pub signer: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC2612InvalidSigner> for UnderlyingRustTuple<'_> {
            fn from(value: ERC2612InvalidSigner) -> Self {
                (value.signer, value.owner)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC2612InvalidSigner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    signer: tuple.0,
                    owner: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC2612InvalidSigner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC2612InvalidSigner(address,address)";
            const SELECTOR: [u8; 4] = [75u8, 128u8, 14u8, 70u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signer,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC5805FutureLookup(uint256,uint48)` and selector `0xecd3f81e`.
```solidity
error ERC5805FutureLookup(uint256 timepoint, uint48 clock);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC5805FutureLookup {
        #[allow(missing_docs)]
        pub timepoint: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub clock: alloy::sol_types::private::primitives::aliases::U48,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<48>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U48,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC5805FutureLookup> for UnderlyingRustTuple<'_> {
            fn from(value: ERC5805FutureLookup) -> Self {
                (value.timepoint, value.clock)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC5805FutureLookup {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    timepoint: tuple.0,
                    clock: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC5805FutureLookup {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC5805FutureLookup(uint256,uint48)";
            const SELECTOR: [u8; 4] = [236u8, 211u8, 248u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.timepoint),
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(&self.clock),
                )
            }
        }
    };
    /**Custom error with signature `ERC6372InconsistentClock()` and selector `0x6ff07140`.
```solidity
error ERC6372InconsistentClock();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC6372InconsistentClock {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC6372InconsistentClock>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC6372InconsistentClock) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC6372InconsistentClock {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC6372InconsistentClock {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC6372InconsistentClock()";
            const SELECTOR: [u8; 4] = [111u8, 240u8, 113u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ExceedsTotalSupply()` and selector `0x177e3fc3`.
```solidity
error ExceedsTotalSupply();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExceedsTotalSupply {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExceedsTotalSupply> for UnderlyingRustTuple<'_> {
            fn from(value: ExceedsTotalSupply) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ExceedsTotalSupply {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ExceedsTotalSupply {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ExceedsTotalSupply()";
            const SELECTOR: [u8; 4] = [23u8, 126u8, 63u8, 195u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InsufficientBurnLimit(address,uint256,uint256)` and selector `0xe5fe97a2`.
```solidity
error InsufficientBurnLimit(address bridge, uint256 requested, uint256 available);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientBurnLimit {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub requested: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub available: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientBurnLimit> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientBurnLimit) -> Self {
                (value.bridge, value.requested, value.available)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientBurnLimit {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    bridge: tuple.0,
                    requested: tuple.1,
                    available: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientBurnLimit {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientBurnLimit(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [229u8, 254u8, 151u8, 162u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.requested),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.available),
                )
            }
        }
    };
    /**Custom error with signature `InsufficientEmissionBudget()` and selector `0x7ade115c`.
```solidity
error InsufficientEmissionBudget();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientEmissionBudget {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientEmissionBudget>
        for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientEmissionBudget) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InsufficientEmissionBudget {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientEmissionBudget {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientEmissionBudget()";
            const SELECTOR: [u8; 4] = [122u8, 222u8, 17u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InsufficientMintLimit(address,uint256,uint256)` and selector `0x40ed367b`.
```solidity
error InsufficientMintLimit(address bridge, uint256 requested, uint256 available);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientMintLimit {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub requested: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub available: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientMintLimit> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientMintLimit) -> Self {
                (value.bridge, value.requested, value.available)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientMintLimit {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    bridge: tuple.0,
                    requested: tuple.1,
                    available: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientMintLimit {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientMintLimit(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [64u8, 237u8, 54u8, 123u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.requested),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.available),
                )
            }
        }
    };
    /**Custom error with signature `InvalidAccountNonce(address,uint256)` and selector `0x752d88c0`.
```solidity
error InvalidAccountNonce(address account, uint256 currentNonce);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidAccountNonce {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub currentNonce: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidAccountNonce> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidAccountNonce) -> Self {
                (value.account, value.currentNonce)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidAccountNonce {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    currentNonce: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidAccountNonce {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidAccountNonce(address,uint256)";
            const SELECTOR: [u8; 4] = [117u8, 45u8, 136u8, 192u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.currentNonce),
                )
            }
        }
    };
    /**Custom error with signature `InvalidShortString()` and selector `0xb3512b0c`.
```solidity
error InvalidShortString();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidShortString {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidShortString> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidShortString) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidShortString {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidShortString {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidShortString()";
            const SELECTOR: [u8; 4] = [179u8, 81u8, 43u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `SafeCastOverflowedUintDowncast(uint8,uint256)` and selector `0x6dfcc650`.
```solidity
error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SafeCastOverflowedUintDowncast {
        #[allow(missing_docs)]
        pub bits: u8,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            u8,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SafeCastOverflowedUintDowncast>
        for UnderlyingRustTuple<'_> {
            fn from(value: SafeCastOverflowedUintDowncast) -> Self {
                (value.bits, value.value)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SafeCastOverflowedUintDowncast {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    bits: tuple.0,
                    value: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SafeCastOverflowedUintDowncast {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SafeCastOverflowedUintDowncast(uint8,uint256)";
            const SELECTOR: [u8; 4] = [109u8, 252u8, 198u8, 80u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.bits),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
        }
    };
    /**Custom error with signature `StringTooLong(string)` and selector `0x305a27a9`.
```solidity
error StringTooLong(string str);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct StringTooLong {
        #[allow(missing_docs)]
        pub str: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<StringTooLong> for UnderlyingRustTuple<'_> {
            fn from(value: StringTooLong) -> Self {
                (value.str,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for StringTooLong {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { str: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for StringTooLong {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "StringTooLong(string)";
            const SELECTOR: [u8; 4] = [48u8, 90u8, 39u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.str,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `TransfersLocked()` and selector `0xdb89e3f4`.
```solidity
error TransfersLocked();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TransfersLocked {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TransfersLocked> for UnderlyingRustTuple<'_> {
            fn from(value: TransfersLocked) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TransfersLocked {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TransfersLocked {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TransfersLocked()";
            const SELECTOR: [u8; 4] = [219u8, 137u8, 227u8, 244u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `UnauthorizedBridge(address)` and selector `0x6585b60d`.
```solidity
error UnauthorizedBridge(address bridge);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UnauthorizedBridge {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnauthorizedBridge> for UnderlyingRustTuple<'_> {
            fn from(value: UnauthorizedBridge) -> Self {
                (value.bridge,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for UnauthorizedBridge {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { bridge: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UnauthorizedBridge {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UnauthorizedBridge(address)";
            const SELECTOR: [u8; 4] = [101u8, 133u8, 182u8, 13u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `UnlockTimestampInPast()` and selector `0xa5658353`.
```solidity
error UnlockTimestampInPast();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UnlockTimestampInPast {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnlockTimestampInPast> for UnderlyingRustTuple<'_> {
            fn from(value: UnlockTimestampInPast) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for UnlockTimestampInPast {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UnlockTimestampInPast {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UnlockTimestampInPast()";
            const SELECTOR: [u8; 4] = [165u8, 101u8, 131u8, 83u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `UnlockTimestampTooLate()` and selector `0xef69af65`.
```solidity
error UnlockTimestampTooLate();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UnlockTimestampTooLate {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnlockTimestampTooLate> for UnderlyingRustTuple<'_> {
            fn from(value: UnlockTimestampTooLate) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for UnlockTimestampTooLate {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UnlockTimestampTooLate {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UnlockTimestampTooLate()";
            const SELECTOR: [u8; 4] = [239u8, 105u8, 175u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `UnreasonableBurnLimit()` and selector `0x58ccad00`.
```solidity
error UnreasonableBurnLimit();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UnreasonableBurnLimit {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnreasonableBurnLimit> for UnderlyingRustTuple<'_> {
            fn from(value: UnreasonableBurnLimit) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for UnreasonableBurnLimit {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UnreasonableBurnLimit {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UnreasonableBurnLimit()";
            const SELECTOR: [u8; 4] = [88u8, 204u8, 173u8, 0u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `UnreasonableMintLimit()` and selector `0x0a395c01`.
```solidity
error UnreasonableMintLimit();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UnreasonableMintLimit {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnreasonableMintLimit> for UnderlyingRustTuple<'_> {
            fn from(value: UnreasonableMintLimit) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for UnreasonableMintLimit {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UnreasonableMintLimit {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UnreasonableMintLimit()";
            const SELECTOR: [u8; 4] = [10u8, 57u8, 92u8, 1u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `VotesExpiredSignature(uint256)` and selector `0x4683af0e`.
```solidity
error VotesExpiredSignature(uint256 expiry);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct VotesExpiredSignature {
        #[allow(missing_docs)]
        pub expiry: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<VotesExpiredSignature> for UnderlyingRustTuple<'_> {
            fn from(value: VotesExpiredSignature) -> Self {
                (value.expiry,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for VotesExpiredSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { expiry: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for VotesExpiredSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "VotesExpiredSignature(uint256)";
            const SELECTOR: [u8; 4] = [70u8, 131u8, 175u8, 14u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expiry),
                )
            }
        }
    };
    /**Custom error with signature `ZeroAddress()` and selector `0xd92e233d`.
```solidity
error ZeroAddress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAddress {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAddress> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAddress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAddress()";
            const SELECTOR: [u8; 4] = [217u8, 46u8, 35u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ZeroAmount()` and selector `0x1f2a2005`.
```solidity
error ZeroAmount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAmount {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAmount> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAmount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAmount()";
            const SELECTOR: [u8; 4] = [31u8, 42u8, 32u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Event with signature `Approval(address,address,uint256)` and selector `0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925`.
```solidity
event Approval(address indexed owner, address indexed spender, uint256 value);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Approval {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Approval {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Approval(address,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                140u8,
                91u8,
                225u8,
                229u8,
                235u8,
                236u8,
                125u8,
                91u8,
                209u8,
                79u8,
                113u8,
                66u8,
                125u8,
                30u8,
                132u8,
                243u8,
                221u8,
                3u8,
                20u8,
                192u8,
                247u8,
                178u8,
                41u8,
                30u8,
                91u8,
                32u8,
                10u8,
                200u8,
                199u8,
                195u8,
                185u8,
                37u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    owner: topics.1,
                    spender: topics.2,
                    value: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.owner.clone(), self.spender.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.owner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.spender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Approval {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Approval> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Approval) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeActiveStatusChanged(address,bool)` and selector `0x9c8668db324845065d2b9a2a183bd3141f63018f548282daf18da49ccbf88c33`.
```solidity
event BridgeActiveStatusChanged(address indexed bridge, bool isActive);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeActiveStatusChanged {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub isActive: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeActiveStatusChanged {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeActiveStatusChanged(address,bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                156u8,
                134u8,
                104u8,
                219u8,
                50u8,
                72u8,
                69u8,
                6u8,
                93u8,
                43u8,
                154u8,
                42u8,
                24u8,
                59u8,
                211u8,
                20u8,
                31u8,
                99u8,
                1u8,
                143u8,
                84u8,
                130u8,
                130u8,
                218u8,
                241u8,
                141u8,
                164u8,
                156u8,
                203u8,
                248u8,
                140u8,
                51u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    bridge: topics.1,
                    isActive: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.isActive,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.bridge.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridge,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeActiveStatusChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeActiveStatusChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &BridgeActiveStatusChanged,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeAdded(address,uint256,uint256)` and selector `0xdb03f97dc5840a71e69be7470e4761af10a1237973e81c12d0dc2813895a6526`.
```solidity
event BridgeAdded(address indexed bridge, uint256 dailyMintLimit, uint256 dailyBurnLimit);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeAdded {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub dailyMintLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub dailyBurnLimit: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeAdded {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeAdded(address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                219u8,
                3u8,
                249u8,
                125u8,
                197u8,
                132u8,
                10u8,
                113u8,
                230u8,
                155u8,
                231u8,
                71u8,
                14u8,
                71u8,
                97u8,
                175u8,
                16u8,
                161u8,
                35u8,
                121u8,
                115u8,
                232u8,
                28u8,
                18u8,
                208u8,
                220u8,
                40u8,
                19u8,
                137u8,
                90u8,
                101u8,
                38u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    bridge: topics.1,
                    dailyMintLimit: data.0,
                    dailyBurnLimit: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.dailyMintLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.dailyBurnLimit),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.bridge.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridge,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeAdded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeAdded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeAdded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeLimitsSet(address,uint256,uint256)` and selector `0xaa807d0abf30d91968c7478c66b6d82521a106af13eda036e2036da9af168958`.
```solidity
event BridgeLimitsSet(address indexed bridge, uint256 dailyMintLimit, uint256 dailyBurnLimit);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeLimitsSet {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub dailyMintLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub dailyBurnLimit: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeLimitsSet {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeLimitsSet(address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                170u8,
                128u8,
                125u8,
                10u8,
                191u8,
                48u8,
                217u8,
                25u8,
                104u8,
                199u8,
                71u8,
                140u8,
                102u8,
                182u8,
                216u8,
                37u8,
                33u8,
                161u8,
                6u8,
                175u8,
                19u8,
                237u8,
                160u8,
                54u8,
                226u8,
                3u8,
                109u8,
                169u8,
                175u8,
                22u8,
                137u8,
                88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    bridge: topics.1,
                    dailyMintLimit: data.0,
                    dailyBurnLimit: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.dailyMintLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.dailyBurnLimit),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.bridge.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridge,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeLimitsSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeLimitsSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeLimitsSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeRemoved(address)` and selector `0x5d9d5034656cb3ebfb0655057cd7f9b4077a9b42ff42ce223cbac5bc586d2126`.
```solidity
event BridgeRemoved(address indexed bridge);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeRemoved {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeRemoved {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeRemoved(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                93u8,
                157u8,
                80u8,
                52u8,
                101u8,
                108u8,
                179u8,
                235u8,
                251u8,
                6u8,
                85u8,
                5u8,
                124u8,
                215u8,
                249u8,
                180u8,
                7u8,
                122u8,
                155u8,
                66u8,
                255u8,
                66u8,
                206u8,
                34u8,
                60u8,
                186u8,
                197u8,
                188u8,
                88u8,
                109u8,
                33u8,
                38u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { bridge: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.bridge.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridge,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeRemoved {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeRemoved> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeRemoved) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `CrosschainBurn(address,uint256,address)` and selector `0xb90795a66650155983e242cac3e1ac1a4dc26f8ed2987f3ce416a34e00111fd4`.
```solidity
event CrosschainBurn(address indexed from, uint256 amount, address indexed bridge);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct CrosschainBurn {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for CrosschainBurn {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "CrosschainBurn(address,uint256,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                185u8,
                7u8,
                149u8,
                166u8,
                102u8,
                80u8,
                21u8,
                89u8,
                131u8,
                226u8,
                66u8,
                202u8,
                195u8,
                225u8,
                172u8,
                26u8,
                77u8,
                194u8,
                111u8,
                142u8,
                210u8,
                152u8,
                127u8,
                60u8,
                228u8,
                22u8,
                163u8,
                78u8,
                0u8,
                17u8,
                31u8,
                212u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    from: topics.1,
                    amount: data.0,
                    bridge: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.from.clone(), self.bridge.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.from,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridge,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for CrosschainBurn {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&CrosschainBurn> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &CrosschainBurn) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `CrosschainMint(address,uint256,address)` and selector `0xde22baff038e3a3e08407cbdf617deed74e869a7ba517df611e33131c6e6ea04`.
```solidity
event CrosschainMint(address indexed to, uint256 amount, address indexed bridge);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct CrosschainMint {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for CrosschainMint {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "CrosschainMint(address,uint256,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                222u8,
                34u8,
                186u8,
                255u8,
                3u8,
                142u8,
                58u8,
                62u8,
                8u8,
                64u8,
                124u8,
                189u8,
                246u8,
                23u8,
                222u8,
                237u8,
                116u8,
                232u8,
                105u8,
                167u8,
                186u8,
                81u8,
                125u8,
                246u8,
                17u8,
                227u8,
                49u8,
                49u8,
                198u8,
                230u8,
                234u8,
                4u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    to: topics.1,
                    amount: data.0,
                    bridge: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.to.clone(), self.bridge.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.to,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridge,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for CrosschainMint {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&CrosschainMint> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &CrosschainMint) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `DelegateChanged(address,address,address)` and selector `0x3134e8a2e6d97e929a7e54011ea5485d7d196dd5f0ba4d4ef95803e8e3fc257f`.
```solidity
event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DelegateChanged {
        #[allow(missing_docs)]
        pub delegator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub fromDelegate: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub toDelegate: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DelegateChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "DelegateChanged(address,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                49u8,
                52u8,
                232u8,
                162u8,
                230u8,
                217u8,
                126u8,
                146u8,
                154u8,
                126u8,
                84u8,
                1u8,
                30u8,
                165u8,
                72u8,
                93u8,
                125u8,
                25u8,
                109u8,
                213u8,
                240u8,
                186u8,
                77u8,
                78u8,
                249u8,
                88u8,
                3u8,
                232u8,
                227u8,
                252u8,
                37u8,
                127u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    delegator: topics.1,
                    fromDelegate: topics.2,
                    toDelegate: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.delegator.clone(),
                    self.fromDelegate.clone(),
                    self.toDelegate.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.delegator,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.fromDelegate,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.toDelegate,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DelegateChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DelegateChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &DelegateChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `DelegateVotesChanged(address,uint256,uint256)` and selector `0xdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a724`.
```solidity
event DelegateVotesChanged(address indexed delegate, uint256 previousVotes, uint256 newVotes);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DelegateVotesChanged {
        #[allow(missing_docs)]
        pub delegate: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub previousVotes: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub newVotes: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DelegateVotesChanged {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "DelegateVotesChanged(address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                222u8,
                194u8,
                186u8,
                205u8,
                210u8,
                240u8,
                91u8,
                89u8,
                222u8,
                52u8,
                218u8,
                155u8,
                82u8,
                61u8,
                255u8,
                139u8,
                228u8,
                46u8,
                94u8,
                56u8,
                232u8,
                24u8,
                200u8,
                47u8,
                219u8,
                11u8,
                174u8,
                119u8,
                67u8,
                135u8,
                167u8,
                36u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    delegate: topics.1,
                    previousVotes: data.0,
                    newVotes: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.previousVotes),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newVotes),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.delegate.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.delegate,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DelegateVotesChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DelegateVotesChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &DelegateVotesChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EIP712DomainChanged()` and selector `0x0a6387c9ea3628b88a633bb4f3b151770f70085117a15f9bf3787cda53f13d31`.
```solidity
event EIP712DomainChanged();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EIP712DomainChanged {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EIP712DomainChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "EIP712DomainChanged()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                10u8,
                99u8,
                135u8,
                201u8,
                234u8,
                54u8,
                40u8,
                184u8,
                138u8,
                99u8,
                59u8,
                180u8,
                243u8,
                177u8,
                81u8,
                119u8,
                15u8,
                112u8,
                8u8,
                81u8,
                23u8,
                161u8,
                95u8,
                155u8,
                243u8,
                120u8,
                124u8,
                218u8,
                83u8,
                241u8,
                61u8,
                49u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EIP712DomainChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EIP712DomainChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EIP712DomainChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EmissionBudgetAllocated(address,uint256)` and selector `0x9ca03dbd5193fbb7974173cedd0bdf6841dd14c3cbfa735aab77ff1dd1139fb3`.
```solidity
event EmissionBudgetAllocated(address indexed bridge, uint256 amount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EmissionBudgetAllocated {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EmissionBudgetAllocated {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "EmissionBudgetAllocated(address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                156u8,
                160u8,
                61u8,
                189u8,
                81u8,
                147u8,
                251u8,
                183u8,
                151u8,
                65u8,
                115u8,
                206u8,
                221u8,
                11u8,
                223u8,
                104u8,
                65u8,
                221u8,
                20u8,
                195u8,
                203u8,
                250u8,
                115u8,
                90u8,
                171u8,
                119u8,
                255u8,
                29u8,
                209u8,
                19u8,
                159u8,
                179u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    bridge: topics.1,
                    amount: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.bridge.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridge,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EmissionBudgetAllocated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EmissionBudgetAllocated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &EmissionBudgetAllocated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EmissionBudgetConsumed(address,uint256)` and selector `0xbc23ec7f1313150b047bff83d0845b0564baa134698dd11bb0acd0f7d416de7d`.
```solidity
event EmissionBudgetConsumed(address indexed bridge, uint256 amount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EmissionBudgetConsumed {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EmissionBudgetConsumed {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "EmissionBudgetConsumed(address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                188u8,
                35u8,
                236u8,
                127u8,
                19u8,
                19u8,
                21u8,
                11u8,
                4u8,
                123u8,
                255u8,
                131u8,
                208u8,
                132u8,
                91u8,
                5u8,
                100u8,
                186u8,
                161u8,
                52u8,
                105u8,
                141u8,
                209u8,
                27u8,
                176u8,
                172u8,
                208u8,
                247u8,
                212u8,
                22u8,
                222u8,
                125u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    bridge: topics.1,
                    amount: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.bridge.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridge,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EmissionBudgetConsumed {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EmissionBudgetConsumed> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EmissionBudgetConsumed) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleAdminChanged(bytes32,bytes32,bytes32)` and selector `0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff`.
```solidity
event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleAdminChanged {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub previousAdminRole: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newAdminRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleAdminChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "RoleAdminChanged(bytes32,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    previousAdminRole: topics.2,
                    newAdminRole: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.previousAdminRole.clone(),
                    self.newAdminRole.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.previousAdminRole);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newAdminRole);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleAdminChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleAdminChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleAdminChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleGranted(bytes32,address,address)` and selector `0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d`.
```solidity
event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleGranted {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleGranted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleGranted(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleGranted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleGranted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleGranted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleRevoked(bytes32,address,address)` and selector `0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b`.
```solidity
event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleRevoked {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleRevoked(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TokensBurnedByManager(address,uint256,address)` and selector `0xbef4f81c1814c641ede85ebaacf19d048b2c5b55980adfa6ef0f956c651335a2`.
```solidity
event TokensBurnedByManager(address indexed from, uint256 amount, address indexed burner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TokensBurnedByManager {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub burner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TokensBurnedByManager {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "TokensBurnedByManager(address,uint256,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                190u8,
                244u8,
                248u8,
                28u8,
                24u8,
                20u8,
                198u8,
                65u8,
                237u8,
                232u8,
                94u8,
                186u8,
                172u8,
                241u8,
                157u8,
                4u8,
                139u8,
                44u8,
                91u8,
                85u8,
                152u8,
                10u8,
                223u8,
                166u8,
                239u8,
                15u8,
                149u8,
                108u8,
                101u8,
                19u8,
                53u8,
                162u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    from: topics.1,
                    amount: data.0,
                    burner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.from.clone(), self.burner.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.from,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.burner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TokensBurnedByManager {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TokensBurnedByManager> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TokensBurnedByManager) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Transfer(address,address,uint256)` and selector `0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef`.
```solidity
event Transfer(address indexed from, address indexed to, uint256 value);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Transfer {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Transfer {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Transfer(address,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                221u8,
                242u8,
                82u8,
                173u8,
                27u8,
                226u8,
                200u8,
                155u8,
                105u8,
                194u8,
                176u8,
                104u8,
                252u8,
                55u8,
                141u8,
                170u8,
                149u8,
                43u8,
                167u8,
                241u8,
                99u8,
                196u8,
                161u8,
                22u8,
                40u8,
                245u8,
                90u8,
                77u8,
                245u8,
                35u8,
                179u8,
                239u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    from: topics.1,
                    to: topics.2,
                    value: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.from.clone(), self.to.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.from,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.to,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Transfer {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Transfer> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Transfer) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `UnlockTimestampUpdated(uint256,uint256,address)` and selector `0xdd6896dcf1d4b311cca87dd19bbba2ea9ce2f867c1568878a0438a66a1afeeec`.
```solidity
event UnlockTimestampUpdated(uint256 oldTimestamp, uint256 newTimestamp, address indexed updatedBy);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct UnlockTimestampUpdated {
        #[allow(missing_docs)]
        pub oldTimestamp: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub newTimestamp: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub updatedBy: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for UnlockTimestampUpdated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "UnlockTimestampUpdated(uint256,uint256,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                221u8,
                104u8,
                150u8,
                220u8,
                241u8,
                212u8,
                179u8,
                17u8,
                204u8,
                168u8,
                125u8,
                209u8,
                155u8,
                187u8,
                162u8,
                234u8,
                156u8,
                226u8,
                248u8,
                103u8,
                193u8,
                86u8,
                136u8,
                120u8,
                160u8,
                67u8,
                138u8,
                102u8,
                161u8,
                175u8,
                238u8,
                236u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldTimestamp: data.0,
                    newTimestamp: data.1,
                    updatedBy: topics.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.oldTimestamp),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newTimestamp),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.updatedBy.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.updatedBy,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for UnlockTimestampUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&UnlockTimestampUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &UnlockTimestampUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address defaultAdmin, address syndTreasuryAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub defaultAdmin: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub syndTreasuryAddress: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value.defaultAdmin, value.syndTreasuryAddress)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        defaultAdmin: tuple.0,
                        syndTreasuryAddress: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.defaultAdmin,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.syndTreasuryAddress,
                    ),
                )
            }
        }
    };
    /**Function with signature `AIRDROP_MANAGER_ROLE()` and selector `0x8a542521`.
```solidity
function AIRDROP_MANAGER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AIRDROP_MANAGER_ROLECall {}
    ///Container type for the return parameters of the [`AIRDROP_MANAGER_ROLE()`](AIRDROP_MANAGER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AIRDROP_MANAGER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<AIRDROP_MANAGER_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: AIRDROP_MANAGER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for AIRDROP_MANAGER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<AIRDROP_MANAGER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: AIRDROP_MANAGER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for AIRDROP_MANAGER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for AIRDROP_MANAGER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = AIRDROP_MANAGER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AIRDROP_MANAGER_ROLE()";
            const SELECTOR: [u8; 4] = [138u8, 84u8, 37u8, 33u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `BRIDGE_MANAGER_ROLE()` and selector `0xf75e8512`.
```solidity
function BRIDGE_MANAGER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_MANAGER_ROLECall {}
    ///Container type for the return parameters of the [`BRIDGE_MANAGER_ROLE()`](BRIDGE_MANAGER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_MANAGER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_MANAGER_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_MANAGER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_MANAGER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_MANAGER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_MANAGER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_MANAGER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for BRIDGE_MANAGER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = BRIDGE_MANAGER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BRIDGE_MANAGER_ROLE()";
            const SELECTOR: [u8; 4] = [247u8, 94u8, 133u8, 18u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `CLOCK_MODE()` and selector `0x4bf5d7e9`.
```solidity
function CLOCK_MODE() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CLOCK_MODECall {}
    ///Container type for the return parameters of the [`CLOCK_MODE()`](CLOCK_MODECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CLOCK_MODEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CLOCK_MODECall> for UnderlyingRustTuple<'_> {
                fn from(value: CLOCK_MODECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for CLOCK_MODECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CLOCK_MODEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: CLOCK_MODEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for CLOCK_MODEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for CLOCK_MODECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = CLOCK_MODEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CLOCK_MODE()";
            const SELECTOR: [u8; 4] = [75u8, 245u8, 215u8, 233u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `DEFAULT_ADMIN_ROLE()` and selector `0xa217fddf`.
```solidity
function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLECall {}
    ///Container type for the return parameters of the [`DEFAULT_ADMIN_ROLE()`](DEFAULT_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEFAULT_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DEFAULT_ADMIN_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEFAULT_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [162u8, 23u8, 253u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `DOMAIN_SEPARATOR()` and selector `0x3644e515`.
```solidity
function DOMAIN_SEPARATOR() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DOMAIN_SEPARATORCall {}
    ///Container type for the return parameters of the [`DOMAIN_SEPARATOR()`](DOMAIN_SEPARATORCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DOMAIN_SEPARATORReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DOMAIN_SEPARATORCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DOMAIN_SEPARATORCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DOMAIN_SEPARATORCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DOMAIN_SEPARATORReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DOMAIN_SEPARATORReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DOMAIN_SEPARATORReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DOMAIN_SEPARATORCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DOMAIN_SEPARATORReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DOMAIN_SEPARATOR()";
            const SELECTOR: [u8; 4] = [54u8, 68u8, 229u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSION_BUDGET_MANAGER_ROLE()` and selector `0xb7cdc61c`.
```solidity
function EMISSION_BUDGET_MANAGER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_BUDGET_MANAGER_ROLECall {}
    ///Container type for the return parameters of the [`EMISSION_BUDGET_MANAGER_ROLE()`](EMISSION_BUDGET_MANAGER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_BUDGET_MANAGER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_BUDGET_MANAGER_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_BUDGET_MANAGER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_BUDGET_MANAGER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_BUDGET_MANAGER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_BUDGET_MANAGER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_BUDGET_MANAGER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSION_BUDGET_MANAGER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSION_BUDGET_MANAGER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSION_BUDGET_MANAGER_ROLE()";
            const SELECTOR: [u8; 4] = [183u8, 205u8, 198u8, 28u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSION_MINTER_ROLE()` and selector `0x8d3343d6`.
```solidity
function EMISSION_MINTER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_MINTER_ROLECall {}
    ///Container type for the return parameters of the [`EMISSION_MINTER_ROLE()`](EMISSION_MINTER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_MINTER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_MINTER_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_MINTER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_MINTER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_MINTER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_MINTER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_MINTER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSION_MINTER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSION_MINTER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSION_MINTER_ROLE()";
            const SELECTOR: [u8; 4] = [141u8, 51u8, 67u8, 214u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `INITIAL_MINT_SUPPLY()` and selector `0x9b7ef64b`.
```solidity
function INITIAL_MINT_SUPPLY() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct INITIAL_MINT_SUPPLYCall {}
    ///Container type for the return parameters of the [`INITIAL_MINT_SUPPLY()`](INITIAL_MINT_SUPPLYCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct INITIAL_MINT_SUPPLYReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<INITIAL_MINT_SUPPLYCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: INITIAL_MINT_SUPPLYCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for INITIAL_MINT_SUPPLYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<INITIAL_MINT_SUPPLYReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: INITIAL_MINT_SUPPLYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for INITIAL_MINT_SUPPLYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for INITIAL_MINT_SUPPLYCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = INITIAL_MINT_SUPPLYReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "INITIAL_MINT_SUPPLY()";
            const SELECTOR: [u8; 4] = [155u8, 126u8, 246u8, 75u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `MAX_LOCK_DURATION()` and selector `0x4f1bfc9e`.
```solidity
function MAX_LOCK_DURATION() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MAX_LOCK_DURATIONCall {}
    ///Container type for the return parameters of the [`MAX_LOCK_DURATION()`](MAX_LOCK_DURATIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MAX_LOCK_DURATIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MAX_LOCK_DURATIONCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: MAX_LOCK_DURATIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MAX_LOCK_DURATIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MAX_LOCK_DURATIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: MAX_LOCK_DURATIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MAX_LOCK_DURATIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for MAX_LOCK_DURATIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = MAX_LOCK_DURATIONReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MAX_LOCK_DURATION()";
            const SELECTOR: [u8; 4] = [79u8, 27u8, 252u8, 158u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `TOTAL_SUPPLY()` and selector `0x902d55a5`.
```solidity
function TOTAL_SUPPLY() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_SUPPLYCall {}
    ///Container type for the return parameters of the [`TOTAL_SUPPLY()`](TOTAL_SUPPLYCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_SUPPLYReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_SUPPLYCall> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_SUPPLYCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_SUPPLYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_SUPPLYReturn> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_SUPPLYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_SUPPLYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for TOTAL_SUPPLYCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = TOTAL_SUPPLYReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TOTAL_SUPPLY()";
            const SELECTOR: [u8; 4] = [144u8, 45u8, 85u8, 165u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `allocateEmissionBudget(address,uint256)` and selector `0x5a4239e9`.
```solidity
function allocateEmissionBudget(address bridge, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allocateEmissionBudgetCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`allocateEmissionBudget(address,uint256)`](allocateEmissionBudgetCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allocateEmissionBudgetReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allocateEmissionBudgetCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: allocateEmissionBudgetCall) -> Self {
                    (value.bridge, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for allocateEmissionBudgetCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        bridge: tuple.0,
                        amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allocateEmissionBudgetReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: allocateEmissionBudgetReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for allocateEmissionBudgetReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for allocateEmissionBudgetCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = allocateEmissionBudgetReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "allocateEmissionBudget(address,uint256)";
            const SELECTOR: [u8; 4] = [90u8, 66u8, 57u8, 233u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `allowance(address,address)` and selector `0xdd62ed3e`.
```solidity
function allowance(address owner, address spender) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allowanceCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`allowance(address,address)`](allowanceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allowanceReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowanceCall> for UnderlyingRustTuple<'_> {
                fn from(value: allowanceCall) -> Self {
                    (value.owner, value.spender)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for allowanceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        spender: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowanceReturn> for UnderlyingRustTuple<'_> {
                fn from(value: allowanceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for allowanceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for allowanceCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = allowanceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "allowance(address,address)";
            const SELECTOR: [u8; 4] = [221u8, 98u8, 237u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `approve(address,uint256)` and selector `0x095ea7b3`.
```solidity
function approve(address spender, uint256 value) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveCall {
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`approve(address,uint256)`](approveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveCall> for UnderlyingRustTuple<'_> {
                fn from(value: approveCall) -> Self {
                    (value.spender, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        spender: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveReturn> for UnderlyingRustTuple<'_> {
                fn from(value: approveReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for approveCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = approveReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "approve(address,uint256)";
            const SELECTOR: [u8; 4] = [9u8, 94u8, 167u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `balanceOf(address)` and selector `0x70a08231`.
```solidity
function balanceOf(address account) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`balanceOf(address)`](balanceOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfCall> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfReturn> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for balanceOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = balanceOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "balanceOf(address)";
            const SELECTOR: [u8; 4] = [112u8, 160u8, 130u8, 49u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeConfigs(address)` and selector `0x427ac0ca`.
```solidity
function bridgeConfigs(address) external view returns (uint256 dailyMintLimit, uint256 dailyBurnLimit, bool isActive);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeConfigsCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`bridgeConfigs(address)`](bridgeConfigsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeConfigsReturn {
        #[allow(missing_docs)]
        pub dailyMintLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub dailyBurnLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub isActive: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeConfigsCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeConfigsCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeConfigsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                bool,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeConfigsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeConfigsReturn) -> Self {
                    (value.dailyMintLimit, value.dailyBurnLimit, value.isActive)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeConfigsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        dailyMintLimit: tuple.0,
                        dailyBurnLimit: tuple.1,
                        isActive: tuple.2,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeConfigsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeConfigsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bool,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeConfigs(address)";
            const SELECTOR: [u8; 4] = [66u8, 122u8, 192u8, 202u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeEmissionBudgets(address)` and selector `0x2869366b`.
```solidity
function bridgeEmissionBudgets(address) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeEmissionBudgetsCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`bridgeEmissionBudgets(address)`](bridgeEmissionBudgetsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeEmissionBudgetsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeEmissionBudgetsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: bridgeEmissionBudgetsCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for bridgeEmissionBudgetsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeEmissionBudgetsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: bridgeEmissionBudgetsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for bridgeEmissionBudgetsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeEmissionBudgetsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeEmissionBudgetsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeEmissionBudgets(address)";
            const SELECTOR: [u8; 4] = [40u8, 105u8, 54u8, 107u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `burn(uint256)` and selector `0x42966c68`.
```solidity
function burn(uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burnCall {
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`burn(uint256)`](burnCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burnReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burnCall> for UnderlyingRustTuple<'_> {
                fn from(value: burnCall) -> Self {
                    (value.amount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for burnCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { amount: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burnReturn> for UnderlyingRustTuple<'_> {
                fn from(value: burnReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for burnReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for burnCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = burnReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "burn(uint256)";
            const SELECTOR: [u8; 4] = [66u8, 150u8, 108u8, 104u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `burnFrom(address,uint256)` and selector `0x79cc6790`.
```solidity
function burnFrom(address from, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burnFromCall {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`burnFrom(address,uint256)`](burnFromCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burnFromReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burnFromCall> for UnderlyingRustTuple<'_> {
                fn from(value: burnFromCall) -> Self {
                    (value.from, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for burnFromCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        from: tuple.0,
                        amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burnFromReturn> for UnderlyingRustTuple<'_> {
                fn from(value: burnFromReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for burnFromReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for burnFromCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = burnFromReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "burnFrom(address,uint256)";
            const SELECTOR: [u8; 4] = [121u8, 204u8, 103u8, 144u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `checkpoints(address,uint32)` and selector `0xf1127ed8`.
```solidity
function checkpoints(address account, uint32 pos) external view returns (Checkpoints.Checkpoint208 memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkpointsCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub pos: u32,
    }
    ///Container type for the return parameters of the [`checkpoints(address,uint32)`](checkpointsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkpointsReturn {
        #[allow(missing_docs)]
        pub _0: <Checkpoints::Checkpoint208 as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, u32);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkpointsCall> for UnderlyingRustTuple<'_> {
                fn from(value: checkpointsCall) -> Self {
                    (value.account, value.pos)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for checkpointsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        account: tuple.0,
                        pos: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Checkpoints::Checkpoint208,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Checkpoints::Checkpoint208 as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkpointsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: checkpointsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for checkpointsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkpointsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkpointsReturn;
            type ReturnTuple<'a> = (Checkpoints::Checkpoint208,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkpoints(address,uint32)";
            const SELECTOR: [u8; 4] = [241u8, 18u8, 126u8, 216u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.pos),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `clock()` and selector `0x91ddadf4`.
```solidity
function clock() external view returns (uint48);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct clockCall {}
    ///Container type for the return parameters of the [`clock()`](clockCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct clockReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U48,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<clockCall> for UnderlyingRustTuple<'_> {
                fn from(value: clockCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for clockCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U48,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<clockReturn> for UnderlyingRustTuple<'_> {
                fn from(value: clockReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for clockReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for clockCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = clockReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "clock()";
            const SELECTOR: [u8; 4] = [145u8, 221u8, 173u8, 244u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `crosschainBurn(address,uint256)` and selector `0x2b8c49e3`.
```solidity
function crosschainBurn(address from, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct crosschainBurnCall {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`crosschainBurn(address,uint256)`](crosschainBurnCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct crosschainBurnReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<crosschainBurnCall> for UnderlyingRustTuple<'_> {
                fn from(value: crosschainBurnCall) -> Self {
                    (value.from, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for crosschainBurnCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        from: tuple.0,
                        amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<crosschainBurnReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: crosschainBurnReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for crosschainBurnReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for crosschainBurnCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = crosschainBurnReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "crosschainBurn(address,uint256)";
            const SELECTOR: [u8; 4] = [43u8, 140u8, 73u8, 227u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `crosschainMint(address,uint256)` and selector `0x18bf5077`.
```solidity
function crosschainMint(address to, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct crosschainMintCall {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`crosschainMint(address,uint256)`](crosschainMintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct crosschainMintReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<crosschainMintCall> for UnderlyingRustTuple<'_> {
                fn from(value: crosschainMintCall) -> Self {
                    (value.to, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for crosschainMintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<crosschainMintReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: crosschainMintReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for crosschainMintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for crosschainMintCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = crosschainMintReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "crosschainMint(address,uint256)";
            const SELECTOR: [u8; 4] = [24u8, 191u8, 80u8, 119u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `decimals()` and selector `0x313ce567`.
```solidity
function decimals() external view returns (uint8);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decimalsCall {}
    ///Container type for the return parameters of the [`decimals()`](decimalsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decimalsReturn {
        #[allow(missing_docs)]
        pub _0: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decimalsCall> for UnderlyingRustTuple<'_> {
                fn from(value: decimalsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for decimalsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decimalsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: decimalsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for decimalsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for decimalsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = decimalsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "decimals()";
            const SELECTOR: [u8; 4] = [49u8, 60u8, 229u8, 103u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `delegate(address)` and selector `0x5c19a95c`.
```solidity
function delegate(address delegatee) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateCall {
        #[allow(missing_docs)]
        pub delegatee: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`delegate(address)`](delegateCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateCall> for UnderlyingRustTuple<'_> {
                fn from(value: delegateCall) -> Self {
                    (value.delegatee,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegateCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { delegatee: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateReturn> for UnderlyingRustTuple<'_> {
                fn from(value: delegateReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegateReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for delegateCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = delegateReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "delegate(address)";
            const SELECTOR: [u8; 4] = [92u8, 25u8, 169u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.delegatee,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)` and selector `0xc3cda520`.
```solidity
function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateBySigCall {
        #[allow(missing_docs)]
        pub delegatee: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub expiry: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub v: u8,
        #[allow(missing_docs)]
        pub r: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)`](delegateBySigCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateBySigReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                u8,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateBySigCall> for UnderlyingRustTuple<'_> {
                fn from(value: delegateBySigCall) -> Self {
                    (
                        value.delegatee,
                        value.nonce,
                        value.expiry,
                        value.v,
                        value.r,
                        value.s,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegateBySigCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        delegatee: tuple.0,
                        nonce: tuple.1,
                        expiry: tuple.2,
                        v: tuple.3,
                        r: tuple.4,
                        s: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateBySigReturn> for UnderlyingRustTuple<'_> {
                fn from(value: delegateBySigReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegateBySigReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for delegateBySigCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = delegateBySigReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [195u8, 205u8, 165u8, 32u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.delegatee,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expiry),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.v),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.r),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `delegates(address)` and selector `0x587cde1e`.
```solidity
function delegates(address account) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegatesCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`delegates(address)`](delegatesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegatesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegatesCall> for UnderlyingRustTuple<'_> {
                fn from(value: delegatesCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegatesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegatesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: delegatesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegatesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for delegatesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = delegatesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "delegates(address)";
            const SELECTOR: [u8; 4] = [88u8, 124u8, 222u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `eip712Domain()` and selector `0x84b0196e`.
```solidity
function eip712Domain() external view returns (bytes1 fields, string memory name, string memory version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] memory extensions);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eip712DomainCall {}
    ///Container type for the return parameters of the [`eip712Domain()`](eip712DomainCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eip712DomainReturn {
        #[allow(missing_docs)]
        pub fields: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub name: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub version: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub verifyingContract: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub salt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub extensions: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eip712DomainCall> for UnderlyingRustTuple<'_> {
                fn from(value: eip712DomainCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eip712DomainCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eip712DomainReturn> for UnderlyingRustTuple<'_> {
                fn from(value: eip712DomainReturn) -> Self {
                    (
                        value.fields,
                        value.name,
                        value.version,
                        value.chainId,
                        value.verifyingContract,
                        value.salt,
                        value.extensions,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eip712DomainReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        fields: tuple.0,
                        name: tuple.1,
                        version: tuple.2,
                        chainId: tuple.3,
                        verifyingContract: tuple.4,
                        salt: tuple.5,
                        extensions: tuple.6,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for eip712DomainCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = eip712DomainReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "eip712Domain()";
            const SELECTOR: [u8; 4] = [132u8, 176u8, 25u8, 110u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getAllBridges()` and selector `0x72cbdcc8`.
```solidity
function getAllBridges() external view returns (address[] memory allBridges);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAllBridgesCall {}
    ///Container type for the return parameters of the [`getAllBridges()`](getAllBridgesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAllBridgesReturn {
        #[allow(missing_docs)]
        pub allBridges: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAllBridgesCall> for UnderlyingRustTuple<'_> {
                fn from(value: getAllBridgesCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getAllBridgesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAllBridgesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getAllBridgesReturn) -> Self {
                    (value.allBridges,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getAllBridgesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { allBridges: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAllBridgesCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getAllBridgesReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAllBridges()";
            const SELECTOR: [u8; 4] = [114u8, 203u8, 220u8, 200u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getAvailableBurnLimit(address)` and selector `0x30d3e8eb`.
```solidity
function getAvailableBurnLimit(address bridge) external view returns (uint256 available);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAvailableBurnLimitCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getAvailableBurnLimit(address)`](getAvailableBurnLimitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAvailableBurnLimitReturn {
        #[allow(missing_docs)]
        pub available: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAvailableBurnLimitCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAvailableBurnLimitCall) -> Self {
                    (value.bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAvailableBurnLimitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAvailableBurnLimitReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAvailableBurnLimitReturn) -> Self {
                    (value.available,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAvailableBurnLimitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { available: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAvailableBurnLimitCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getAvailableBurnLimitReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAvailableBurnLimit(address)";
            const SELECTOR: [u8; 4] = [48u8, 211u8, 232u8, 235u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getAvailableMintLimit(address)` and selector `0x94aa22f2`.
```solidity
function getAvailableMintLimit(address bridge) external view returns (uint256 available);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAvailableMintLimitCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getAvailableMintLimit(address)`](getAvailableMintLimitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAvailableMintLimitReturn {
        #[allow(missing_docs)]
        pub available: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAvailableMintLimitCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAvailableMintLimitCall) -> Self {
                    (value.bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAvailableMintLimitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAvailableMintLimitReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAvailableMintLimitReturn) -> Self {
                    (value.available,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAvailableMintLimitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { available: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAvailableMintLimitCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getAvailableMintLimitReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAvailableMintLimit(address)";
            const SELECTOR: [u8; 4] = [148u8, 170u8, 34u8, 242u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBridgeAtIndex(uint256)` and selector `0x5a5db1bb`.
```solidity
function getBridgeAtIndex(uint256 index) external view returns (address bridge);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeAtIndexCall {
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getBridgeAtIndex(uint256)`](getBridgeAtIndexCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeAtIndexReturn {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeAtIndexCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeAtIndexCall) -> Self {
                    (value.index,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeAtIndexCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { index: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeAtIndexReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeAtIndexReturn) -> Self {
                    (value.bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeAtIndexReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bridge: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBridgeAtIndexCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBridgeAtIndexReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBridgeAtIndex(uint256)";
            const SELECTOR: [u8; 4] = [90u8, 93u8, 177u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBridgeConfig(address)` and selector `0xc4fc45a8`.
```solidity
function getBridgeConfig(address bridge) external view returns (IBridgeRateLimiter.BridgeConfig memory config);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeConfigCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getBridgeConfig(address)`](getBridgeConfigCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeConfigReturn {
        #[allow(missing_docs)]
        pub config: <IBridgeRateLimiter::BridgeConfig as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeConfigCall> for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeConfigCall) -> Self {
                    (value.bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBridgeConfigCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (IBridgeRateLimiter::BridgeConfig,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <IBridgeRateLimiter::BridgeConfig as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeConfigReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeConfigReturn) -> Self {
                    (value.config,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeConfigReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { config: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBridgeConfigCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBridgeConfigReturn;
            type ReturnTuple<'a> = (IBridgeRateLimiter::BridgeConfig,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBridgeConfig(address)";
            const SELECTOR: [u8; 4] = [196u8, 252u8, 69u8, 168u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBridgeCount()` and selector `0x65145534`.
```solidity
function getBridgeCount() external view returns (uint256 count);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeCountCall {}
    ///Container type for the return parameters of the [`getBridgeCount()`](getBridgeCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeCountReturn {
        #[allow(missing_docs)]
        pub count: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeCountCall> for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeCountCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBridgeCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeCountReturn) -> Self {
                    (value.count,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { count: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBridgeCountCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBridgeCountReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBridgeCount()";
            const SELECTOR: [u8; 4] = [101u8, 20u8, 85u8, 52u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getCurrentTotalSupply()` and selector `0xc02ae754`.
```solidity
function getCurrentTotalSupply() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentTotalSupplyCall {}
    ///Container type for the return parameters of the [`getCurrentTotalSupply()`](getCurrentTotalSupplyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentTotalSupplyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentTotalSupplyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentTotalSupplyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentTotalSupplyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentTotalSupplyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentTotalSupplyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentTotalSupplyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCurrentTotalSupplyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getCurrentTotalSupplyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCurrentTotalSupply()";
            const SELECTOR: [u8; 4] = [192u8, 42u8, 231u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getEmissionBudget(address)` and selector `0x050732fb`.
```solidity
function getEmissionBudget(address bridge) external view returns (uint256 budget);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEmissionBudgetCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getEmissionBudget(address)`](getEmissionBudgetCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEmissionBudgetReturn {
        #[allow(missing_docs)]
        pub budget: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEmissionBudgetCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getEmissionBudgetCall) -> Self {
                    (value.bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getEmissionBudgetCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEmissionBudgetReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getEmissionBudgetReturn) -> Self {
                    (value.budget,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getEmissionBudgetReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { budget: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getEmissionBudgetCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getEmissionBudgetReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getEmissionBudget(address)";
            const SELECTOR: [u8; 4] = [5u8, 7u8, 50u8, 251u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getPastTotalSupply(uint256)` and selector `0x8e539e8c`.
```solidity
function getPastTotalSupply(uint256 timepoint) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastTotalSupplyCall {
        #[allow(missing_docs)]
        pub timepoint: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getPastTotalSupply(uint256)`](getPastTotalSupplyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastTotalSupplyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastTotalSupplyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPastTotalSupplyCall) -> Self {
                    (value.timepoint,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPastTotalSupplyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { timepoint: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastTotalSupplyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPastTotalSupplyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPastTotalSupplyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPastTotalSupplyCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPastTotalSupplyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPastTotalSupply(uint256)";
            const SELECTOR: [u8; 4] = [142u8, 83u8, 158u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.timepoint),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getPastVotes(address,uint256)` and selector `0x3a46b1a8`.
```solidity
function getPastVotes(address account, uint256 timepoint) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastVotesCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub timepoint: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getPastVotes(address,uint256)`](getPastVotesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastVotesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastVotesCall> for UnderlyingRustTuple<'_> {
                fn from(value: getPastVotesCall) -> Self {
                    (value.account, value.timepoint)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getPastVotesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        account: tuple.0,
                        timepoint: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastVotesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getPastVotesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getPastVotesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPastVotesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPastVotesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPastVotes(address,uint256)";
            const SELECTOR: [u8; 4] = [58u8, 70u8, 177u8, 168u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.timepoint),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getPastVotingPower(address,uint256)` and selector `0xb0ca253e`.
```solidity
function getPastVotingPower(address account, uint256 blockNumber) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastVotingPowerCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub blockNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getPastVotingPower(address,uint256)`](getPastVotingPowerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastVotingPowerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastVotingPowerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPastVotingPowerCall) -> Self {
                    (value.account, value.blockNumber)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPastVotingPowerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        account: tuple.0,
                        blockNumber: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastVotingPowerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPastVotingPowerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPastVotingPowerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPastVotingPowerCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPastVotingPowerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPastVotingPower(address,uint256)";
            const SELECTOR: [u8; 4] = [176u8, 202u8, 37u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNumber),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRemainingEmissions()` and selector `0x4bdd36ce`.
```solidity
function getRemainingEmissions() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRemainingEmissionsCall {}
    ///Container type for the return parameters of the [`getRemainingEmissions()`](getRemainingEmissionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRemainingEmissionsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRemainingEmissionsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRemainingEmissionsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRemainingEmissionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRemainingEmissionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRemainingEmissionsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRemainingEmissionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRemainingEmissionsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRemainingEmissionsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRemainingEmissions()";
            const SELECTOR: [u8; 4] = [75u8, 221u8, 54u8, 206u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRemainingLockTime()` and selector `0x7a8cd156`.
```solidity
function getRemainingLockTime() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRemainingLockTimeCall {}
    ///Container type for the return parameters of the [`getRemainingLockTime()`](getRemainingLockTimeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRemainingLockTimeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRemainingLockTimeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRemainingLockTimeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRemainingLockTimeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRemainingLockTimeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRemainingLockTimeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRemainingLockTimeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRemainingLockTimeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRemainingLockTimeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRemainingLockTime()";
            const SELECTOR: [u8; 4] = [122u8, 140u8, 209u8, 86u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRoleAdmin(bytes32)` and selector `0x248a9ca3`.
```solidity
function getRoleAdmin(bytes32 role) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getRoleAdmin(bytes32)`](getRoleAdminCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleAdminCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRoleAdminReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleAdmin(bytes32)";
            const SELECTOR: [u8; 4] = [36u8, 138u8, 156u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getVotes(address)` and selector `0x9ab24eb0`.
```solidity
function getVotes(address account) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVotesCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getVotes(address)`](getVotesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVotesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVotesCall> for UnderlyingRustTuple<'_> {
                fn from(value: getVotesCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVotesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVotesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getVotesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVotesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getVotesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getVotesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getVotes(address)";
            const SELECTOR: [u8; 4] = [154u8, 178u8, 78u8, 176u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getVotingPower(address)` and selector `0xbb4d4436`.
```solidity
function getVotingPower(address account) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVotingPowerCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getVotingPower(address)`](getVotingPowerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVotingPowerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVotingPowerCall> for UnderlyingRustTuple<'_> {
                fn from(value: getVotingPowerCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVotingPowerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVotingPowerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getVotingPowerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getVotingPowerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getVotingPowerCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getVotingPowerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getVotingPower(address)";
            const SELECTOR: [u8; 4] = [187u8, 77u8, 68u8, 54u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `grantRole(bytes32,address)` and selector `0x2f2ff15d`.
```solidity
function grantRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`grantRole(bytes32,address)`](grantRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for grantRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = grantRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "grantRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [47u8, 47u8, 241u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `hasRole(bytes32,address)` and selector `0x91d14854`.
```solidity
function hasRole(bytes32 role, address account) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`hasRole(bytes32,address)`](hasRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = hasRoleReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [145u8, 209u8, 72u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `hourlyBurnUsage(address,uint256)` and selector `0x5d4c6285`.
```solidity
function hourlyBurnUsage(address, uint256) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hourlyBurnUsageCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _1: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`hourlyBurnUsage(address,uint256)`](hourlyBurnUsageCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hourlyBurnUsageReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hourlyBurnUsageCall> for UnderlyingRustTuple<'_> {
                fn from(value: hourlyBurnUsageCall) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hourlyBurnUsageCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hourlyBurnUsageReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: hourlyBurnUsageReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for hourlyBurnUsageReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hourlyBurnUsageCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = hourlyBurnUsageReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hourlyBurnUsage(address,uint256)";
            const SELECTOR: [u8; 4] = [93u8, 76u8, 98u8, 133u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `hourlyMintUsage(address,uint256)` and selector `0x01042d7a`.
```solidity
function hourlyMintUsage(address, uint256) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hourlyMintUsageCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _1: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`hourlyMintUsage(address,uint256)`](hourlyMintUsageCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hourlyMintUsageReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hourlyMintUsageCall> for UnderlyingRustTuple<'_> {
                fn from(value: hourlyMintUsageCall) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hourlyMintUsageCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hourlyMintUsageReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: hourlyMintUsageReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for hourlyMintUsageReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hourlyMintUsageCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = hourlyMintUsageReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hourlyMintUsage(address,uint256)";
            const SELECTOR: [u8; 4] = [1u8, 4u8, 45u8, 122u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isBridgeAuthorized(address)` and selector `0x78fb7fd2`.
```solidity
function isBridgeAuthorized(address bridge) external view returns (bool authorized);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isBridgeAuthorizedCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`isBridgeAuthorized(address)`](isBridgeAuthorizedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isBridgeAuthorizedReturn {
        #[allow(missing_docs)]
        pub authorized: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isBridgeAuthorizedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isBridgeAuthorizedCall) -> Self {
                    (value.bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isBridgeAuthorizedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isBridgeAuthorizedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isBridgeAuthorizedReturn) -> Self {
                    (value.authorized,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isBridgeAuthorizedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { authorized: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isBridgeAuthorizedCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isBridgeAuthorizedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isBridgeAuthorized(address)";
            const SELECTOR: [u8; 4] = [120u8, 251u8, 127u8, 210u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `maxLockTimestamp()` and selector `0x8426adf2`.
```solidity
function maxLockTimestamp() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct maxLockTimestampCall {}
    ///Container type for the return parameters of the [`maxLockTimestamp()`](maxLockTimestampCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct maxLockTimestampReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<maxLockTimestampCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: maxLockTimestampCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for maxLockTimestampCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<maxLockTimestampReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: maxLockTimestampReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for maxLockTimestampReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for maxLockTimestampCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = maxLockTimestampReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "maxLockTimestamp()";
            const SELECTOR: [u8; 4] = [132u8, 38u8, 173u8, 242u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `mint(address,uint256)` and selector `0x40c10f19`.
```solidity
function mint(address to, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintCall {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`mint(address,uint256)`](mintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintCall> for UnderlyingRustTuple<'_> {
                fn from(value: mintCall) -> Self {
                    (value.to, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintReturn> for UnderlyingRustTuple<'_> {
                fn from(value: mintReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mintCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mintReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mint(address,uint256)";
            const SELECTOR: [u8; 4] = [64u8, 193u8, 15u8, 25u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `name()` and selector `0x06fdde03`.
```solidity
function name() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nameCall {}
    ///Container type for the return parameters of the [`name()`](nameCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nameReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nameCall> for UnderlyingRustTuple<'_> {
                fn from(value: nameCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nameCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nameReturn> for UnderlyingRustTuple<'_> {
                fn from(value: nameReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nameReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for nameCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = nameReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "name()";
            const SELECTOR: [u8; 4] = [6u8, 253u8, 222u8, 3u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `nonces(address)` and selector `0x7ecebe00`.
```solidity
function nonces(address owner) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct noncesCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`nonces(address)`](noncesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct noncesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<noncesCall> for UnderlyingRustTuple<'_> {
                fn from(value: noncesCall) -> Self {
                    (value.owner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for noncesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { owner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<noncesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: noncesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for noncesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for noncesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = noncesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "nonces(address)";
            const SELECTOR: [u8; 4] = [126u8, 206u8, 190u8, 0u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `numCheckpoints(address)` and selector `0x6fcfff45`.
```solidity
function numCheckpoints(address account) external view returns (uint32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct numCheckpointsCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`numCheckpoints(address)`](numCheckpointsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct numCheckpointsReturn {
        #[allow(missing_docs)]
        pub _0: u32,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<numCheckpointsCall> for UnderlyingRustTuple<'_> {
                fn from(value: numCheckpointsCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for numCheckpointsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<numCheckpointsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: numCheckpointsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for numCheckpointsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for numCheckpointsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = numCheckpointsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "numCheckpoints(address)";
            const SELECTOR: [u8; 4] = [111u8, 207u8, 255u8, 69u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `permit(address,address,uint256,uint256,uint8,bytes32,bytes32)` and selector `0xd505accf`.
```solidity
function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct permitCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub deadline: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub v: u8,
        #[allow(missing_docs)]
        pub r: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`permit(address,address,uint256,uint256,uint8,bytes32,bytes32)`](permitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct permitReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                u8,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<permitCall> for UnderlyingRustTuple<'_> {
                fn from(value: permitCall) -> Self {
                    (
                        value.owner,
                        value.spender,
                        value.value,
                        value.deadline,
                        value.v,
                        value.r,
                        value.s,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for permitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        spender: tuple.1,
                        value: tuple.2,
                        deadline: tuple.3,
                        v: tuple.4,
                        r: tuple.5,
                        s: tuple.6,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<permitReturn> for UnderlyingRustTuple<'_> {
                fn from(value: permitReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for permitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for permitCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = permitReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [213u8, 5u8, 172u8, 207u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.deadline),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.v),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.r),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `removeBridge(address)` and selector `0x04df017d`.
```solidity
function removeBridge(address bridge) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeBridgeCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`removeBridge(address)`](removeBridgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeBridgeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeBridgeCall> for UnderlyingRustTuple<'_> {
                fn from(value: removeBridgeCall) -> Self {
                    (value.bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeBridgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeBridgeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: removeBridgeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeBridgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeBridgeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeBridgeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeBridge(address)";
            const SELECTOR: [u8; 4] = [4u8, 223u8, 1u8, 125u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `renounceRole(bytes32,address)` and selector `0x36568abe`.
```solidity
function renounceRole(bytes32 role, address callerConfirmation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub callerConfirmation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`renounceRole(bytes32,address)`](renounceRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleCall) -> Self {
                    (value.role, value.callerConfirmation)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        callerConfirmation: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [54u8, 86u8, 138u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callerConfirmation,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `revokeRole(bytes32,address)` and selector `0xd547741f`.
```solidity
function revokeRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeRole(bytes32,address)`](revokeRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [213u8, 71u8, 116u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBridgeActive(address,bool)` and selector `0xc9ab0006`.
```solidity
function setBridgeActive(address bridge, bool isActive) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeActiveCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub isActive: bool,
    }
    ///Container type for the return parameters of the [`setBridgeActive(address,bool)`](setBridgeActiveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeActiveReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, bool);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeActiveCall> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeActiveCall) -> Self {
                    (value.bridge, value.isActive)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgeActiveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        bridge: tuple.0,
                        isActive: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeActiveReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeActiveReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setBridgeActiveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBridgeActiveCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBridgeActiveReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBridgeActive(address,bool)";
            const SELECTOR: [u8; 4] = [201u8, 171u8, 0u8, 6u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.isActive,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBridgeLimits(address,uint256,uint256)` and selector `0x63a0daac`.
```solidity
function setBridgeLimits(address bridge, uint256 dailyMintLimit, uint256 dailyBurnLimit) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeLimitsCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub dailyMintLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub dailyBurnLimit: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setBridgeLimits(address,uint256,uint256)`](setBridgeLimitsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeLimitsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeLimitsCall> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeLimitsCall) -> Self {
                    (value.bridge, value.dailyMintLimit, value.dailyBurnLimit)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgeLimitsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        bridge: tuple.0,
                        dailyMintLimit: tuple.1,
                        dailyBurnLimit: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeLimitsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeLimitsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setBridgeLimitsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBridgeLimitsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBridgeLimitsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBridgeLimits(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [99u8, 160u8, 218u8, 172u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.dailyMintLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.dailyBurnLimit),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setUnlockTimestamp(uint256)` and selector `0x844c9026`.
```solidity
function setUnlockTimestamp(uint256 newUnlockTimestamp) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setUnlockTimestampCall {
        #[allow(missing_docs)]
        pub newUnlockTimestamp: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setUnlockTimestamp(uint256)`](setUnlockTimestampCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setUnlockTimestampReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setUnlockTimestampCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setUnlockTimestampCall) -> Self {
                    (value.newUnlockTimestamp,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setUnlockTimestampCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newUnlockTimestamp: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setUnlockTimestampReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setUnlockTimestampReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setUnlockTimestampReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setUnlockTimestampCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setUnlockTimestampReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setUnlockTimestamp(uint256)";
            const SELECTOR: [u8; 4] = [132u8, 76u8, 144u8, 38u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newUnlockTimestamp),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
```solidity
function supportsInterface(bytes4 interfaceId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceCall {
        #[allow(missing_docs)]
        pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
    }
    ///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceCall) -> Self {
                    (value.interfaceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { interfaceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportsInterfaceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = supportsInterfaceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportsInterface(bytes4)";
            const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.interfaceId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `symbol()` and selector `0x95d89b41`.
```solidity
function symbol() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct symbolCall {}
    ///Container type for the return parameters of the [`symbol()`](symbolCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct symbolReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<symbolCall> for UnderlyingRustTuple<'_> {
                fn from(value: symbolCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for symbolCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<symbolReturn> for UnderlyingRustTuple<'_> {
                fn from(value: symbolReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for symbolReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for symbolCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = symbolReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "symbol()";
            const SELECTOR: [u8; 4] = [149u8, 216u8, 155u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `totalSupply()` and selector `0x18160ddd`.
```solidity
function totalSupply() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalSupplyCall {}
    ///Container type for the return parameters of the [`totalSupply()`](totalSupplyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalSupplyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalSupplyCall> for UnderlyingRustTuple<'_> {
                fn from(value: totalSupplyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalSupplyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalSupplyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: totalSupplyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalSupplyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for totalSupplyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = totalSupplyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "totalSupply()";
            const SELECTOR: [u8; 4] = [24u8, 22u8, 13u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transfer(address,uint256)` and selector `0xa9059cbb`.
```solidity
function transfer(address to, uint256 value) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferCall {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`transfer(address,uint256)`](transferCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferCall> for UnderlyingRustTuple<'_> {
                fn from(value: transferCall) -> Self {
                    (value.to, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferReturn> for UnderlyingRustTuple<'_> {
                fn from(value: transferReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transfer(address,uint256)";
            const SELECTOR: [u8; 4] = [169u8, 5u8, 156u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transferFrom(address,address,uint256)` and selector `0x23b872dd`.
```solidity
function transferFrom(address from, address to, uint256 value) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferFromCall {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`transferFrom(address,address,uint256)`](transferFromCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferFromReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferFromCall> for UnderlyingRustTuple<'_> {
                fn from(value: transferFromCall) -> Self {
                    (value.from, value.to, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        from: tuple.0,
                        to: tuple.1,
                        value: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferFromReturn> for UnderlyingRustTuple<'_> {
                fn from(value: transferFromReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferFromCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferFromReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferFrom(address,address,uint256)";
            const SELECTOR: [u8; 4] = [35u8, 184u8, 114u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transfersLocked()` and selector `0x83f1211b`.
```solidity
function transfersLocked() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transfersLockedCall {}
    ///Container type for the return parameters of the [`transfersLocked()`](transfersLockedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transfersLockedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transfersLockedCall> for UnderlyingRustTuple<'_> {
                fn from(value: transfersLockedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transfersLockedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transfersLockedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transfersLockedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transfersLockedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transfersLockedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transfersLockedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transfersLocked()";
            const SELECTOR: [u8; 4] = [131u8, 241u8, 33u8, 27u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `unlockTimestamp()` and selector `0xaa082a9d`.
```solidity
function unlockTimestamp() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unlockTimestampCall {}
    ///Container type for the return parameters of the [`unlockTimestamp()`](unlockTimestampCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unlockTimestampReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unlockTimestampCall> for UnderlyingRustTuple<'_> {
                fn from(value: unlockTimestampCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unlockTimestampCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unlockTimestampReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: unlockTimestampReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for unlockTimestampReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unlockTimestampCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = unlockTimestampReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unlockTimestamp()";
            const SELECTOR: [u8; 4] = [170u8, 8u8, 42u8, 157u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`SyndicateTokenCrosschain`](self) function calls.
    pub enum SyndicateTokenCrosschainCalls {
        #[allow(missing_docs)]
        AIRDROP_MANAGER_ROLE(AIRDROP_MANAGER_ROLECall),
        #[allow(missing_docs)]
        BRIDGE_MANAGER_ROLE(BRIDGE_MANAGER_ROLECall),
        #[allow(missing_docs)]
        CLOCK_MODE(CLOCK_MODECall),
        #[allow(missing_docs)]
        DEFAULT_ADMIN_ROLE(DEFAULT_ADMIN_ROLECall),
        #[allow(missing_docs)]
        DOMAIN_SEPARATOR(DOMAIN_SEPARATORCall),
        #[allow(missing_docs)]
        EMISSION_BUDGET_MANAGER_ROLE(EMISSION_BUDGET_MANAGER_ROLECall),
        #[allow(missing_docs)]
        EMISSION_MINTER_ROLE(EMISSION_MINTER_ROLECall),
        #[allow(missing_docs)]
        INITIAL_MINT_SUPPLY(INITIAL_MINT_SUPPLYCall),
        #[allow(missing_docs)]
        MAX_LOCK_DURATION(MAX_LOCK_DURATIONCall),
        #[allow(missing_docs)]
        TOTAL_SUPPLY(TOTAL_SUPPLYCall),
        #[allow(missing_docs)]
        allocateEmissionBudget(allocateEmissionBudgetCall),
        #[allow(missing_docs)]
        allowance(allowanceCall),
        #[allow(missing_docs)]
        approve(approveCall),
        #[allow(missing_docs)]
        balanceOf(balanceOfCall),
        #[allow(missing_docs)]
        bridgeConfigs(bridgeConfigsCall),
        #[allow(missing_docs)]
        bridgeEmissionBudgets(bridgeEmissionBudgetsCall),
        #[allow(missing_docs)]
        burn(burnCall),
        #[allow(missing_docs)]
        burnFrom(burnFromCall),
        #[allow(missing_docs)]
        checkpoints(checkpointsCall),
        #[allow(missing_docs)]
        clock(clockCall),
        #[allow(missing_docs)]
        crosschainBurn(crosschainBurnCall),
        #[allow(missing_docs)]
        crosschainMint(crosschainMintCall),
        #[allow(missing_docs)]
        decimals(decimalsCall),
        #[allow(missing_docs)]
        delegate(delegateCall),
        #[allow(missing_docs)]
        delegateBySig(delegateBySigCall),
        #[allow(missing_docs)]
        delegates(delegatesCall),
        #[allow(missing_docs)]
        eip712Domain(eip712DomainCall),
        #[allow(missing_docs)]
        getAllBridges(getAllBridgesCall),
        #[allow(missing_docs)]
        getAvailableBurnLimit(getAvailableBurnLimitCall),
        #[allow(missing_docs)]
        getAvailableMintLimit(getAvailableMintLimitCall),
        #[allow(missing_docs)]
        getBridgeAtIndex(getBridgeAtIndexCall),
        #[allow(missing_docs)]
        getBridgeConfig(getBridgeConfigCall),
        #[allow(missing_docs)]
        getBridgeCount(getBridgeCountCall),
        #[allow(missing_docs)]
        getCurrentTotalSupply(getCurrentTotalSupplyCall),
        #[allow(missing_docs)]
        getEmissionBudget(getEmissionBudgetCall),
        #[allow(missing_docs)]
        getPastTotalSupply(getPastTotalSupplyCall),
        #[allow(missing_docs)]
        getPastVotes(getPastVotesCall),
        #[allow(missing_docs)]
        getPastVotingPower(getPastVotingPowerCall),
        #[allow(missing_docs)]
        getRemainingEmissions(getRemainingEmissionsCall),
        #[allow(missing_docs)]
        getRemainingLockTime(getRemainingLockTimeCall),
        #[allow(missing_docs)]
        getRoleAdmin(getRoleAdminCall),
        #[allow(missing_docs)]
        getVotes(getVotesCall),
        #[allow(missing_docs)]
        getVotingPower(getVotingPowerCall),
        #[allow(missing_docs)]
        grantRole(grantRoleCall),
        #[allow(missing_docs)]
        hasRole(hasRoleCall),
        #[allow(missing_docs)]
        hourlyBurnUsage(hourlyBurnUsageCall),
        #[allow(missing_docs)]
        hourlyMintUsage(hourlyMintUsageCall),
        #[allow(missing_docs)]
        isBridgeAuthorized(isBridgeAuthorizedCall),
        #[allow(missing_docs)]
        maxLockTimestamp(maxLockTimestampCall),
        #[allow(missing_docs)]
        mint(mintCall),
        #[allow(missing_docs)]
        name(nameCall),
        #[allow(missing_docs)]
        nonces(noncesCall),
        #[allow(missing_docs)]
        numCheckpoints(numCheckpointsCall),
        #[allow(missing_docs)]
        permit(permitCall),
        #[allow(missing_docs)]
        removeBridge(removeBridgeCall),
        #[allow(missing_docs)]
        renounceRole(renounceRoleCall),
        #[allow(missing_docs)]
        revokeRole(revokeRoleCall),
        #[allow(missing_docs)]
        setBridgeActive(setBridgeActiveCall),
        #[allow(missing_docs)]
        setBridgeLimits(setBridgeLimitsCall),
        #[allow(missing_docs)]
        setUnlockTimestamp(setUnlockTimestampCall),
        #[allow(missing_docs)]
        supportsInterface(supportsInterfaceCall),
        #[allow(missing_docs)]
        symbol(symbolCall),
        #[allow(missing_docs)]
        totalSupply(totalSupplyCall),
        #[allow(missing_docs)]
        transfer(transferCall),
        #[allow(missing_docs)]
        transferFrom(transferFromCall),
        #[allow(missing_docs)]
        transfersLocked(transfersLockedCall),
        #[allow(missing_docs)]
        unlockTimestamp(unlockTimestampCall),
    }
    #[automatically_derived]
    impl SyndicateTokenCrosschainCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 4u8, 45u8, 122u8],
            [1u8, 255u8, 201u8, 167u8],
            [4u8, 223u8, 1u8, 125u8],
            [5u8, 7u8, 50u8, 251u8],
            [6u8, 253u8, 222u8, 3u8],
            [9u8, 94u8, 167u8, 179u8],
            [24u8, 22u8, 13u8, 221u8],
            [24u8, 191u8, 80u8, 119u8],
            [35u8, 184u8, 114u8, 221u8],
            [36u8, 138u8, 156u8, 163u8],
            [40u8, 105u8, 54u8, 107u8],
            [43u8, 140u8, 73u8, 227u8],
            [47u8, 47u8, 241u8, 93u8],
            [48u8, 211u8, 232u8, 235u8],
            [49u8, 60u8, 229u8, 103u8],
            [54u8, 68u8, 229u8, 21u8],
            [54u8, 86u8, 138u8, 190u8],
            [58u8, 70u8, 177u8, 168u8],
            [64u8, 193u8, 15u8, 25u8],
            [66u8, 122u8, 192u8, 202u8],
            [66u8, 150u8, 108u8, 104u8],
            [75u8, 221u8, 54u8, 206u8],
            [75u8, 245u8, 215u8, 233u8],
            [79u8, 27u8, 252u8, 158u8],
            [88u8, 124u8, 222u8, 30u8],
            [90u8, 66u8, 57u8, 233u8],
            [90u8, 93u8, 177u8, 187u8],
            [92u8, 25u8, 169u8, 92u8],
            [93u8, 76u8, 98u8, 133u8],
            [99u8, 160u8, 218u8, 172u8],
            [101u8, 20u8, 85u8, 52u8],
            [111u8, 207u8, 255u8, 69u8],
            [112u8, 160u8, 130u8, 49u8],
            [114u8, 203u8, 220u8, 200u8],
            [120u8, 251u8, 127u8, 210u8],
            [121u8, 204u8, 103u8, 144u8],
            [122u8, 140u8, 209u8, 86u8],
            [126u8, 206u8, 190u8, 0u8],
            [131u8, 241u8, 33u8, 27u8],
            [132u8, 38u8, 173u8, 242u8],
            [132u8, 76u8, 144u8, 38u8],
            [132u8, 176u8, 25u8, 110u8],
            [138u8, 84u8, 37u8, 33u8],
            [141u8, 51u8, 67u8, 214u8],
            [142u8, 83u8, 158u8, 140u8],
            [144u8, 45u8, 85u8, 165u8],
            [145u8, 209u8, 72u8, 84u8],
            [145u8, 221u8, 173u8, 244u8],
            [148u8, 170u8, 34u8, 242u8],
            [149u8, 216u8, 155u8, 65u8],
            [154u8, 178u8, 78u8, 176u8],
            [155u8, 126u8, 246u8, 75u8],
            [162u8, 23u8, 253u8, 223u8],
            [169u8, 5u8, 156u8, 187u8],
            [170u8, 8u8, 42u8, 157u8],
            [176u8, 202u8, 37u8, 62u8],
            [183u8, 205u8, 198u8, 28u8],
            [187u8, 77u8, 68u8, 54u8],
            [192u8, 42u8, 231u8, 84u8],
            [195u8, 205u8, 165u8, 32u8],
            [196u8, 252u8, 69u8, 168u8],
            [201u8, 171u8, 0u8, 6u8],
            [213u8, 5u8, 172u8, 207u8],
            [213u8, 71u8, 116u8, 31u8],
            [221u8, 98u8, 237u8, 62u8],
            [241u8, 18u8, 126u8, 216u8],
            [247u8, 94u8, 133u8, 18u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndicateTokenCrosschainCalls {
        const NAME: &'static str = "SyndicateTokenCrosschainCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 67usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AIRDROP_MANAGER_ROLE(_) => {
                    <AIRDROP_MANAGER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::BRIDGE_MANAGER_ROLE(_) => {
                    <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::CLOCK_MODE(_) => {
                    <CLOCK_MODECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DEFAULT_ADMIN_ROLE(_) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DOMAIN_SEPARATOR(_) => {
                    <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSION_BUDGET_MANAGER_ROLE(_) => {
                    <EMISSION_BUDGET_MANAGER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSION_MINTER_ROLE(_) => {
                    <EMISSION_MINTER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::INITIAL_MINT_SUPPLY(_) => {
                    <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::MAX_LOCK_DURATION(_) => {
                    <MAX_LOCK_DURATIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::TOTAL_SUPPLY(_) => {
                    <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::allocateEmissionBudget(_) => {
                    <allocateEmissionBudgetCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::allowance(_) => {
                    <allowanceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::approve(_) => <approveCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::balanceOf(_) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeConfigs(_) => {
                    <bridgeConfigsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeEmissionBudgets(_) => {
                    <bridgeEmissionBudgetsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::burn(_) => <burnCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::burnFrom(_) => <burnFromCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::checkpoints(_) => {
                    <checkpointsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::clock(_) => <clockCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::crosschainBurn(_) => {
                    <crosschainBurnCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::crosschainMint(_) => {
                    <crosschainMintCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::decimals(_) => <decimalsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::delegate(_) => <delegateCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::delegateBySig(_) => {
                    <delegateBySigCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::delegates(_) => {
                    <delegatesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::eip712Domain(_) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAllBridges(_) => {
                    <getAllBridgesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAvailableBurnLimit(_) => {
                    <getAvailableBurnLimitCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAvailableMintLimit(_) => {
                    <getAvailableMintLimitCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBridgeAtIndex(_) => {
                    <getBridgeAtIndexCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBridgeConfig(_) => {
                    <getBridgeConfigCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBridgeCount(_) => {
                    <getBridgeCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCurrentTotalSupply(_) => {
                    <getCurrentTotalSupplyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getEmissionBudget(_) => {
                    <getEmissionBudgetCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPastTotalSupply(_) => {
                    <getPastTotalSupplyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPastVotes(_) => {
                    <getPastVotesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPastVotingPower(_) => {
                    <getPastVotingPowerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRemainingEmissions(_) => {
                    <getRemainingEmissionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRemainingLockTime(_) => {
                    <getRemainingLockTimeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleAdmin(_) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getVotes(_) => <getVotesCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getVotingPower(_) => {
                    <getVotingPowerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::grantRole(_) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasRole(_) => <hasRoleCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::hourlyBurnUsage(_) => {
                    <hourlyBurnUsageCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hourlyMintUsage(_) => {
                    <hourlyMintUsageCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isBridgeAuthorized(_) => {
                    <isBridgeAuthorizedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::maxLockTimestamp(_) => {
                    <maxLockTimestampCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::mint(_) => <mintCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::name(_) => <nameCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::nonces(_) => <noncesCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::numCheckpoints(_) => {
                    <numCheckpointsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::permit(_) => <permitCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::removeBridge(_) => {
                    <removeBridgeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceRole(_) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeRole(_) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBridgeActive(_) => {
                    <setBridgeActiveCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBridgeLimits(_) => {
                    <setBridgeLimitsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setUnlockTimestamp(_) => {
                    <setUnlockTimestampCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::supportsInterface(_) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::symbol(_) => <symbolCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::totalSupply(_) => {
                    <totalSupplyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transfer(_) => <transferCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::transferFrom(_) => {
                    <transferFromCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transfersLocked(_) => {
                    <transfersLockedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::unlockTimestamp(_) => {
                    <unlockTimestampCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls>] = &[
                {
                    fn hourlyMintUsage(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <hourlyMintUsageCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::hourlyMintUsage)
                    }
                    hourlyMintUsage
                },
                {
                    fn supportsInterface(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn removeBridge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <removeBridgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::removeBridge)
                    }
                    removeBridge
                },
                {
                    fn getEmissionBudget(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getEmissionBudgetCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getEmissionBudget)
                    }
                    getEmissionBudget
                },
                {
                    fn name(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <nameCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::name)
                    }
                    name
                },
                {
                    fn approve(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <approveCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::approve)
                    }
                    approve
                },
                {
                    fn totalSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <totalSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::totalSupply)
                    }
                    totalSupply
                },
                {
                    fn crosschainMint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <crosschainMintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::crosschainMint)
                    }
                    crosschainMint
                },
                {
                    fn transferFrom(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <transferFromCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::transferFrom)
                    }
                    transferFrom
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn bridgeEmissionBudgets(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <bridgeEmissionBudgetsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::bridgeEmissionBudgets)
                    }
                    bridgeEmissionBudgets
                },
                {
                    fn crosschainBurn(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <crosschainBurnCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::crosschainBurn)
                    }
                    crosschainBurn
                },
                {
                    fn grantRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn getAvailableBurnLimit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getAvailableBurnLimitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getAvailableBurnLimit)
                    }
                    getAvailableBurnLimit
                },
                {
                    fn decimals(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <decimalsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::decimals)
                    }
                    decimals
                },
                {
                    fn DOMAIN_SEPARATOR(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::DOMAIN_SEPARATOR)
                    }
                    DOMAIN_SEPARATOR
                },
                {
                    fn renounceRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn getPastVotes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getPastVotesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getPastVotes)
                    }
                    getPastVotes
                },
                {
                    fn mint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <mintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::mint)
                    }
                    mint
                },
                {
                    fn bridgeConfigs(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <bridgeConfigsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::bridgeConfigs)
                    }
                    bridgeConfigs
                },
                {
                    fn burn(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <burnCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::burn)
                    }
                    burn
                },
                {
                    fn getRemainingEmissions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getRemainingEmissionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getRemainingEmissions)
                    }
                    getRemainingEmissions
                },
                {
                    fn CLOCK_MODE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <CLOCK_MODECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::CLOCK_MODE)
                    }
                    CLOCK_MODE
                },
                {
                    fn MAX_LOCK_DURATION(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <MAX_LOCK_DURATIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::MAX_LOCK_DURATION)
                    }
                    MAX_LOCK_DURATION
                },
                {
                    fn delegates(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <delegatesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::delegates)
                    }
                    delegates
                },
                {
                    fn allocateEmissionBudget(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <allocateEmissionBudgetCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::allocateEmissionBudget)
                    }
                    allocateEmissionBudget
                },
                {
                    fn getBridgeAtIndex(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getBridgeAtIndexCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getBridgeAtIndex)
                    }
                    getBridgeAtIndex
                },
                {
                    fn delegate(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <delegateCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::delegate)
                    }
                    delegate
                },
                {
                    fn hourlyBurnUsage(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <hourlyBurnUsageCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::hourlyBurnUsage)
                    }
                    hourlyBurnUsage
                },
                {
                    fn setBridgeLimits(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <setBridgeLimitsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::setBridgeLimits)
                    }
                    setBridgeLimits
                },
                {
                    fn getBridgeCount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getBridgeCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getBridgeCount)
                    }
                    getBridgeCount
                },
                {
                    fn numCheckpoints(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <numCheckpointsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::numCheckpoints)
                    }
                    numCheckpoints
                },
                {
                    fn balanceOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <balanceOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::balanceOf)
                    }
                    balanceOf
                },
                {
                    fn getAllBridges(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getAllBridgesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getAllBridges)
                    }
                    getAllBridges
                },
                {
                    fn isBridgeAuthorized(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <isBridgeAuthorizedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::isBridgeAuthorized)
                    }
                    isBridgeAuthorized
                },
                {
                    fn burnFrom(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <burnFromCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::burnFrom)
                    }
                    burnFrom
                },
                {
                    fn getRemainingLockTime(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getRemainingLockTimeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getRemainingLockTime)
                    }
                    getRemainingLockTime
                },
                {
                    fn nonces(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <noncesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::nonces)
                    }
                    nonces
                },
                {
                    fn transfersLocked(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <transfersLockedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::transfersLocked)
                    }
                    transfersLocked
                },
                {
                    fn maxLockTimestamp(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <maxLockTimestampCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::maxLockTimestamp)
                    }
                    maxLockTimestamp
                },
                {
                    fn setUnlockTimestamp(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <setUnlockTimestampCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::setUnlockTimestamp)
                    }
                    setUnlockTimestamp
                },
                {
                    fn eip712Domain(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <eip712DomainCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::eip712Domain)
                    }
                    eip712Domain
                },
                {
                    fn AIRDROP_MANAGER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <AIRDROP_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::AIRDROP_MANAGER_ROLE)
                    }
                    AIRDROP_MANAGER_ROLE
                },
                {
                    fn EMISSION_MINTER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <EMISSION_MINTER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::EMISSION_MINTER_ROLE)
                    }
                    EMISSION_MINTER_ROLE
                },
                {
                    fn getPastTotalSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getPastTotalSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getPastTotalSupply)
                    }
                    getPastTotalSupply
                },
                {
                    fn TOTAL_SUPPLY(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::TOTAL_SUPPLY)
                    }
                    TOTAL_SUPPLY
                },
                {
                    fn hasRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn clock(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <clockCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::clock)
                    }
                    clock
                },
                {
                    fn getAvailableMintLimit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getAvailableMintLimitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getAvailableMintLimit)
                    }
                    getAvailableMintLimit
                },
                {
                    fn symbol(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <symbolCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::symbol)
                    }
                    symbol
                },
                {
                    fn getVotes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getVotesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getVotes)
                    }
                    getVotes
                },
                {
                    fn INITIAL_MINT_SUPPLY(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::INITIAL_MINT_SUPPLY)
                    }
                    INITIAL_MINT_SUPPLY
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn transfer(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <transferCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::transfer)
                    }
                    transfer
                },
                {
                    fn unlockTimestamp(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <unlockTimestampCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::unlockTimestamp)
                    }
                    unlockTimestamp
                },
                {
                    fn getPastVotingPower(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getPastVotingPowerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getPastVotingPower)
                    }
                    getPastVotingPower
                },
                {
                    fn EMISSION_BUDGET_MANAGER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <EMISSION_BUDGET_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenCrosschainCalls::EMISSION_BUDGET_MANAGER_ROLE,
                            )
                    }
                    EMISSION_BUDGET_MANAGER_ROLE
                },
                {
                    fn getVotingPower(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getVotingPowerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getVotingPower)
                    }
                    getVotingPower
                },
                {
                    fn getCurrentTotalSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getCurrentTotalSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getCurrentTotalSupply)
                    }
                    getCurrentTotalSupply
                },
                {
                    fn delegateBySig(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <delegateBySigCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::delegateBySig)
                    }
                    delegateBySig
                },
                {
                    fn getBridgeConfig(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getBridgeConfigCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getBridgeConfig)
                    }
                    getBridgeConfig
                },
                {
                    fn setBridgeActive(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <setBridgeActiveCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::setBridgeActive)
                    }
                    setBridgeActive
                },
                {
                    fn permit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <permitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::permit)
                    }
                    permit
                },
                {
                    fn revokeRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn allowance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <allowanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::allowance)
                    }
                    allowance
                },
                {
                    fn checkpoints(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <checkpointsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::checkpoints)
                    }
                    checkpoints
                },
                {
                    fn BRIDGE_MANAGER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::BRIDGE_MANAGER_ROLE)
                    }
                    BRIDGE_MANAGER_ROLE
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AIRDROP_MANAGER_ROLE(inner) => {
                    <AIRDROP_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BRIDGE_MANAGER_ROLE(inner) => {
                    <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CLOCK_MODE(inner) => {
                    <CLOCK_MODECall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DOMAIN_SEPARATOR(inner) => {
                    <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSION_BUDGET_MANAGER_ROLE(inner) => {
                    <EMISSION_BUDGET_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSION_MINTER_ROLE(inner) => {
                    <EMISSION_MINTER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::INITIAL_MINT_SUPPLY(inner) => {
                    <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MAX_LOCK_DURATION(inner) => {
                    <MAX_LOCK_DURATIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TOTAL_SUPPLY(inner) => {
                    <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::allocateEmissionBudget(inner) => {
                    <allocateEmissionBudgetCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::allowance(inner) => {
                    <allowanceCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::approve(inner) => {
                    <approveCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::bridgeConfigs(inner) => {
                    <bridgeConfigsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bridgeEmissionBudgets(inner) => {
                    <bridgeEmissionBudgetsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::burn(inner) => {
                    <burnCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::burnFrom(inner) => {
                    <burnFromCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::checkpoints(inner) => {
                    <checkpointsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::clock(inner) => {
                    <clockCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::crosschainBurn(inner) => {
                    <crosschainBurnCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::crosschainMint(inner) => {
                    <crosschainMintCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::decimals(inner) => {
                    <decimalsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::delegate(inner) => {
                    <delegateCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::delegateBySig(inner) => {
                    <delegateBySigCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::delegates(inner) => {
                    <delegatesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::eip712Domain(inner) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAllBridges(inner) => {
                    <getAllBridgesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAvailableBurnLimit(inner) => {
                    <getAvailableBurnLimitCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAvailableMintLimit(inner) => {
                    <getAvailableMintLimitCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBridgeAtIndex(inner) => {
                    <getBridgeAtIndexCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBridgeConfig(inner) => {
                    <getBridgeConfigCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBridgeCount(inner) => {
                    <getBridgeCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getCurrentTotalSupply(inner) => {
                    <getCurrentTotalSupplyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getEmissionBudget(inner) => {
                    <getEmissionBudgetCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPastTotalSupply(inner) => {
                    <getPastTotalSupplyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPastVotes(inner) => {
                    <getPastVotesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPastVotingPower(inner) => {
                    <getPastVotingPowerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRemainingEmissions(inner) => {
                    <getRemainingEmissionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRemainingLockTime(inner) => {
                    <getRemainingLockTimeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getVotes(inner) => {
                    <getVotesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getVotingPower(inner) => {
                    <getVotingPowerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::hourlyBurnUsage(inner) => {
                    <hourlyBurnUsageCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::hourlyMintUsage(inner) => {
                    <hourlyMintUsageCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isBridgeAuthorized(inner) => {
                    <isBridgeAuthorizedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::maxLockTimestamp(inner) => {
                    <maxLockTimestampCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::mint(inner) => {
                    <mintCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::name(inner) => {
                    <nameCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::nonces(inner) => {
                    <noncesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::numCheckpoints(inner) => {
                    <numCheckpointsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::permit(inner) => {
                    <permitCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::removeBridge(inner) => {
                    <removeBridgeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setBridgeActive(inner) => {
                    <setBridgeActiveCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setBridgeLimits(inner) => {
                    <setBridgeLimitsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setUnlockTimestamp(inner) => {
                    <setUnlockTimestampCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::symbol(inner) => {
                    <symbolCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::totalSupply(inner) => {
                    <totalSupplyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transfer(inner) => {
                    <transferCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::transferFrom(inner) => {
                    <transferFromCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transfersLocked(inner) => {
                    <transfersLockedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::unlockTimestamp(inner) => {
                    <unlockTimestampCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AIRDROP_MANAGER_ROLE(inner) => {
                    <AIRDROP_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BRIDGE_MANAGER_ROLE(inner) => {
                    <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CLOCK_MODE(inner) => {
                    <CLOCK_MODECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DOMAIN_SEPARATOR(inner) => {
                    <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSION_BUDGET_MANAGER_ROLE(inner) => {
                    <EMISSION_BUDGET_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSION_MINTER_ROLE(inner) => {
                    <EMISSION_MINTER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::INITIAL_MINT_SUPPLY(inner) => {
                    <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MAX_LOCK_DURATION(inner) => {
                    <MAX_LOCK_DURATIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TOTAL_SUPPLY(inner) => {
                    <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::allocateEmissionBudget(inner) => {
                    <allocateEmissionBudgetCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::allowance(inner) => {
                    <allowanceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::approve(inner) => {
                    <approveCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeConfigs(inner) => {
                    <bridgeConfigsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeEmissionBudgets(inner) => {
                    <bridgeEmissionBudgetsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::burn(inner) => {
                    <burnCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::burnFrom(inner) => {
                    <burnFromCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkpoints(inner) => {
                    <checkpointsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::clock(inner) => {
                    <clockCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::crosschainBurn(inner) => {
                    <crosschainBurnCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::crosschainMint(inner) => {
                    <crosschainMintCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::decimals(inner) => {
                    <decimalsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::delegate(inner) => {
                    <delegateCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::delegateBySig(inner) => {
                    <delegateBySigCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::delegates(inner) => {
                    <delegatesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::eip712Domain(inner) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAllBridges(inner) => {
                    <getAllBridgesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAvailableBurnLimit(inner) => {
                    <getAvailableBurnLimitCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAvailableMintLimit(inner) => {
                    <getAvailableMintLimitCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBridgeAtIndex(inner) => {
                    <getBridgeAtIndexCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBridgeConfig(inner) => {
                    <getBridgeConfigCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBridgeCount(inner) => {
                    <getBridgeCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getCurrentTotalSupply(inner) => {
                    <getCurrentTotalSupplyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getEmissionBudget(inner) => {
                    <getEmissionBudgetCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPastTotalSupply(inner) => {
                    <getPastTotalSupplyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPastVotes(inner) => {
                    <getPastVotesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPastVotingPower(inner) => {
                    <getPastVotingPowerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRemainingEmissions(inner) => {
                    <getRemainingEmissionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRemainingLockTime(inner) => {
                    <getRemainingLockTimeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getVotes(inner) => {
                    <getVotesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getVotingPower(inner) => {
                    <getVotingPowerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::hourlyBurnUsage(inner) => {
                    <hourlyBurnUsageCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hourlyMintUsage(inner) => {
                    <hourlyMintUsageCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isBridgeAuthorized(inner) => {
                    <isBridgeAuthorizedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::maxLockTimestamp(inner) => {
                    <maxLockTimestampCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::mint(inner) => {
                    <mintCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::name(inner) => {
                    <nameCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::nonces(inner) => {
                    <noncesCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::numCheckpoints(inner) => {
                    <numCheckpointsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::permit(inner) => {
                    <permitCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::removeBridge(inner) => {
                    <removeBridgeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBridgeActive(inner) => {
                    <setBridgeActiveCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBridgeLimits(inner) => {
                    <setBridgeLimitsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setUnlockTimestamp(inner) => {
                    <setUnlockTimestampCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::symbol(inner) => {
                    <symbolCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::totalSupply(inner) => {
                    <totalSupplyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transfer(inner) => {
                    <transferCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferFrom(inner) => {
                    <transferFromCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transfersLocked(inner) => {
                    <transfersLockedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::unlockTimestamp(inner) => {
                    <unlockTimestampCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`SyndicateTokenCrosschain`](self) custom errors.
    pub enum SyndicateTokenCrosschainErrors {
        #[allow(missing_docs)]
        AccessControlBadConfirmation(AccessControlBadConfirmation),
        #[allow(missing_docs)]
        AccessControlUnauthorizedAccount(AccessControlUnauthorizedAccount),
        #[allow(missing_docs)]
        BridgeMustBeContract(BridgeMustBeContract),
        #[allow(missing_docs)]
        BridgeNotActive(BridgeNotActive),
        #[allow(missing_docs)]
        BurnOnlyDuringLockPeriod(BurnOnlyDuringLockPeriod),
        #[allow(missing_docs)]
        CannotAddSelfAsBridge(CannotAddSelfAsBridge),
        #[allow(missing_docs)]
        CheckpointUnorderedInsertion(CheckpointUnorderedInsertion),
        #[allow(missing_docs)]
        ECDSAInvalidSignature(ECDSAInvalidSignature),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureLength(ECDSAInvalidSignatureLength),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureS(ECDSAInvalidSignatureS),
        #[allow(missing_docs)]
        ERC20ExceededSafeSupply(ERC20ExceededSafeSupply),
        #[allow(missing_docs)]
        ERC20InsufficientAllowance(ERC20InsufficientAllowance),
        #[allow(missing_docs)]
        ERC20InsufficientBalance(ERC20InsufficientBalance),
        #[allow(missing_docs)]
        ERC20InvalidApprover(ERC20InvalidApprover),
        #[allow(missing_docs)]
        ERC20InvalidReceiver(ERC20InvalidReceiver),
        #[allow(missing_docs)]
        ERC20InvalidSender(ERC20InvalidSender),
        #[allow(missing_docs)]
        ERC20InvalidSpender(ERC20InvalidSpender),
        #[allow(missing_docs)]
        ERC2612ExpiredSignature(ERC2612ExpiredSignature),
        #[allow(missing_docs)]
        ERC2612InvalidSigner(ERC2612InvalidSigner),
        #[allow(missing_docs)]
        ERC5805FutureLookup(ERC5805FutureLookup),
        #[allow(missing_docs)]
        ERC6372InconsistentClock(ERC6372InconsistentClock),
        #[allow(missing_docs)]
        ExceedsTotalSupply(ExceedsTotalSupply),
        #[allow(missing_docs)]
        InsufficientBurnLimit(InsufficientBurnLimit),
        #[allow(missing_docs)]
        InsufficientEmissionBudget(InsufficientEmissionBudget),
        #[allow(missing_docs)]
        InsufficientMintLimit(InsufficientMintLimit),
        #[allow(missing_docs)]
        InvalidAccountNonce(InvalidAccountNonce),
        #[allow(missing_docs)]
        InvalidShortString(InvalidShortString),
        #[allow(missing_docs)]
        SafeCastOverflowedUintDowncast(SafeCastOverflowedUintDowncast),
        #[allow(missing_docs)]
        StringTooLong(StringTooLong),
        #[allow(missing_docs)]
        TransfersLocked(TransfersLocked),
        #[allow(missing_docs)]
        UnauthorizedBridge(UnauthorizedBridge),
        #[allow(missing_docs)]
        UnlockTimestampInPast(UnlockTimestampInPast),
        #[allow(missing_docs)]
        UnlockTimestampTooLate(UnlockTimestampTooLate),
        #[allow(missing_docs)]
        UnreasonableBurnLimit(UnreasonableBurnLimit),
        #[allow(missing_docs)]
        UnreasonableMintLimit(UnreasonableMintLimit),
        #[allow(missing_docs)]
        VotesExpiredSignature(VotesExpiredSignature),
        #[allow(missing_docs)]
        ZeroAddress(ZeroAddress),
        #[allow(missing_docs)]
        ZeroAmount(ZeroAmount),
    }
    #[automatically_derived]
    impl SyndicateTokenCrosschainErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [10u8, 57u8, 92u8, 1u8],
            [23u8, 126u8, 63u8, 195u8],
            [28u8, 177u8, 93u8, 38u8],
            [31u8, 42u8, 32u8, 5u8],
            [37u8, 32u8, 96u8, 29u8],
            [48u8, 90u8, 39u8, 169u8],
            [64u8, 237u8, 54u8, 123u8],
            [70u8, 131u8, 175u8, 14u8],
            [75u8, 128u8, 14u8, 70u8],
            [88u8, 204u8, 173u8, 0u8],
            [98u8, 121u8, 19u8, 2u8],
            [101u8, 133u8, 182u8, 13u8],
            [102u8, 151u8, 178u8, 50u8],
            [109u8, 252u8, 198u8, 80u8],
            [111u8, 240u8, 113u8, 64u8],
            [117u8, 45u8, 136u8, 192u8],
            [122u8, 222u8, 17u8, 92u8],
            [130u8, 84u8, 49u8, 218u8],
            [148u8, 40u8, 13u8, 98u8],
            [150u8, 198u8, 253u8, 30u8],
            [165u8, 101u8, 131u8, 83u8],
            [179u8, 81u8, 43u8, 12u8],
            [184u8, 181u8, 202u8, 45u8],
            [215u8, 139u8, 206u8, 12u8],
            [217u8, 46u8, 35u8, 61u8],
            [219u8, 137u8, 227u8, 244u8],
            [226u8, 81u8, 125u8, 63u8],
            [228u8, 80u8, 211u8, 140u8],
            [229u8, 254u8, 151u8, 162u8],
            [230u8, 2u8, 223u8, 5u8],
            [236u8, 68u8, 47u8, 5u8],
            [236u8, 211u8, 248u8, 30u8],
            [239u8, 105u8, 175u8, 101u8],
            [239u8, 218u8, 14u8, 6u8],
            [246u8, 69u8, 238u8, 223u8],
            [251u8, 140u8, 232u8, 201u8],
            [251u8, 143u8, 65u8, 178u8],
            [252u8, 230u8, 152u8, 247u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndicateTokenCrosschainErrors {
        const NAME: &'static str = "SyndicateTokenCrosschainErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 38usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AccessControlBadConfirmation(_) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AccessControlUnauthorizedAccount(_) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BridgeMustBeContract(_) => {
                    <BridgeMustBeContract as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BridgeNotActive(_) => {
                    <BridgeNotActive as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BurnOnlyDuringLockPeriod(_) => {
                    <BurnOnlyDuringLockPeriod as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CannotAddSelfAsBridge(_) => {
                    <CannotAddSelfAsBridge as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CheckpointUnorderedInsertion(_) => {
                    <CheckpointUnorderedInsertion as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignature(_) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureLength(_) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureS(_) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20ExceededSafeSupply(_) => {
                    <ERC20ExceededSafeSupply as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InsufficientAllowance(_) => {
                    <ERC20InsufficientAllowance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InsufficientBalance(_) => {
                    <ERC20InsufficientBalance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidApprover(_) => {
                    <ERC20InvalidApprover as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidReceiver(_) => {
                    <ERC20InvalidReceiver as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidSender(_) => {
                    <ERC20InvalidSender as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidSpender(_) => {
                    <ERC20InvalidSpender as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC2612ExpiredSignature(_) => {
                    <ERC2612ExpiredSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC2612InvalidSigner(_) => {
                    <ERC2612InvalidSigner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC5805FutureLookup(_) => {
                    <ERC5805FutureLookup as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC6372InconsistentClock(_) => {
                    <ERC6372InconsistentClock as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ExceedsTotalSupply(_) => {
                    <ExceedsTotalSupply as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientBurnLimit(_) => {
                    <InsufficientBurnLimit as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientEmissionBudget(_) => {
                    <InsufficientEmissionBudget as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientMintLimit(_) => {
                    <InsufficientMintLimit as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidAccountNonce(_) => {
                    <InvalidAccountNonce as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidShortString(_) => {
                    <InvalidShortString as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SafeCastOverflowedUintDowncast(_) => {
                    <SafeCastOverflowedUintDowncast as alloy_sol_types::SolError>::SELECTOR
                }
                Self::StringTooLong(_) => {
                    <StringTooLong as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TransfersLocked(_) => {
                    <TransfersLocked as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UnauthorizedBridge(_) => {
                    <UnauthorizedBridge as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UnlockTimestampInPast(_) => {
                    <UnlockTimestampInPast as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UnlockTimestampTooLate(_) => {
                    <UnlockTimestampTooLate as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UnreasonableBurnLimit(_) => {
                    <UnreasonableBurnLimit as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UnreasonableMintLimit(_) => {
                    <UnreasonableMintLimit as alloy_sol_types::SolError>::SELECTOR
                }
                Self::VotesExpiredSignature(_) => {
                    <VotesExpiredSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAddress(_) => {
                    <ZeroAddress as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAmount(_) => {
                    <ZeroAmount as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors>] = &[
                {
                    fn UnreasonableMintLimit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <UnreasonableMintLimit as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::UnreasonableMintLimit)
                    }
                    UnreasonableMintLimit
                },
                {
                    fn ExceedsTotalSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ExceedsTotalSupply as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::ExceedsTotalSupply)
                    }
                    ExceedsTotalSupply
                },
                {
                    fn ERC20ExceededSafeSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ERC20ExceededSafeSupply as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::ERC20ExceededSafeSupply)
                    }
                    ERC20ExceededSafeSupply
                },
                {
                    fn ZeroAmount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ZeroAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::ZeroAmount)
                    }
                    ZeroAmount
                },
                {
                    fn CheckpointUnorderedInsertion(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <CheckpointUnorderedInsertion as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenCrosschainErrors::CheckpointUnorderedInsertion,
                            )
                    }
                    CheckpointUnorderedInsertion
                },
                {
                    fn StringTooLong(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <StringTooLong as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::StringTooLong)
                    }
                    StringTooLong
                },
                {
                    fn InsufficientMintLimit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <InsufficientMintLimit as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::InsufficientMintLimit)
                    }
                    InsufficientMintLimit
                },
                {
                    fn VotesExpiredSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <VotesExpiredSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::VotesExpiredSignature)
                    }
                    VotesExpiredSignature
                },
                {
                    fn ERC2612InvalidSigner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ERC2612InvalidSigner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::ERC2612InvalidSigner)
                    }
                    ERC2612InvalidSigner
                },
                {
                    fn UnreasonableBurnLimit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <UnreasonableBurnLimit as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::UnreasonableBurnLimit)
                    }
                    UnreasonableBurnLimit
                },
                {
                    fn ERC2612ExpiredSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ERC2612ExpiredSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::ERC2612ExpiredSignature)
                    }
                    ERC2612ExpiredSignature
                },
                {
                    fn UnauthorizedBridge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <UnauthorizedBridge as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::UnauthorizedBridge)
                    }
                    UnauthorizedBridge
                },
                {
                    fn AccessControlBadConfirmation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenCrosschainErrors::AccessControlBadConfirmation,
                            )
                    }
                    AccessControlBadConfirmation
                },
                {
                    fn SafeCastOverflowedUintDowncast(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <SafeCastOverflowedUintDowncast as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenCrosschainErrors::SafeCastOverflowedUintDowncast,
                            )
                    }
                    SafeCastOverflowedUintDowncast
                },
                {
                    fn ERC6372InconsistentClock(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ERC6372InconsistentClock as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenCrosschainErrors::ERC6372InconsistentClock,
                            )
                    }
                    ERC6372InconsistentClock
                },
                {
                    fn InvalidAccountNonce(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <InvalidAccountNonce as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::InvalidAccountNonce)
                    }
                    InvalidAccountNonce
                },
                {
                    fn InsufficientEmissionBudget(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <InsufficientEmissionBudget as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenCrosschainErrors::InsufficientEmissionBudget,
                            )
                    }
                    InsufficientEmissionBudget
                },
                {
                    fn BridgeMustBeContract(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <BridgeMustBeContract as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::BridgeMustBeContract)
                    }
                    BridgeMustBeContract
                },
                {
                    fn ERC20InvalidSpender(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ERC20InvalidSpender as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::ERC20InvalidSpender)
                    }
                    ERC20InvalidSpender
                },
                {
                    fn ERC20InvalidSender(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ERC20InvalidSender as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::ERC20InvalidSender)
                    }
                    ERC20InvalidSender
                },
                {
                    fn UnlockTimestampInPast(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <UnlockTimestampInPast as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::UnlockTimestampInPast)
                    }
                    UnlockTimestampInPast
                },
                {
                    fn InvalidShortString(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <InvalidShortString as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::InvalidShortString)
                    }
                    InvalidShortString
                },
                {
                    fn BurnOnlyDuringLockPeriod(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <BurnOnlyDuringLockPeriod as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenCrosschainErrors::BurnOnlyDuringLockPeriod,
                            )
                    }
                    BurnOnlyDuringLockPeriod
                },
                {
                    fn ECDSAInvalidSignatureS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::ECDSAInvalidSignatureS)
                    }
                    ECDSAInvalidSignatureS
                },
                {
                    fn ZeroAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ZeroAddress as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::ZeroAddress)
                    }
                    ZeroAddress
                },
                {
                    fn TransfersLocked(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <TransfersLocked as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::TransfersLocked)
                    }
                    TransfersLocked
                },
                {
                    fn AccessControlUnauthorizedAccount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenCrosschainErrors::AccessControlUnauthorizedAccount,
                            )
                    }
                    AccessControlUnauthorizedAccount
                },
                {
                    fn ERC20InsufficientBalance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ERC20InsufficientBalance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenCrosschainErrors::ERC20InsufficientBalance,
                            )
                    }
                    ERC20InsufficientBalance
                },
                {
                    fn InsufficientBurnLimit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <InsufficientBurnLimit as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::InsufficientBurnLimit)
                    }
                    InsufficientBurnLimit
                },
                {
                    fn ERC20InvalidApprover(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ERC20InvalidApprover as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::ERC20InvalidApprover)
                    }
                    ERC20InvalidApprover
                },
                {
                    fn ERC20InvalidReceiver(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ERC20InvalidReceiver as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::ERC20InvalidReceiver)
                    }
                    ERC20InvalidReceiver
                },
                {
                    fn ERC5805FutureLookup(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ERC5805FutureLookup as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::ERC5805FutureLookup)
                    }
                    ERC5805FutureLookup
                },
                {
                    fn UnlockTimestampTooLate(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <UnlockTimestampTooLate as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::UnlockTimestampTooLate)
                    }
                    UnlockTimestampTooLate
                },
                {
                    fn BridgeNotActive(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <BridgeNotActive as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::BridgeNotActive)
                    }
                    BridgeNotActive
                },
                {
                    fn ECDSAInvalidSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::ECDSAInvalidSignature)
                    }
                    ECDSAInvalidSignature
                },
                {
                    fn CannotAddSelfAsBridge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <CannotAddSelfAsBridge as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::CannotAddSelfAsBridge)
                    }
                    CannotAddSelfAsBridge
                },
                {
                    fn ERC20InsufficientAllowance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ERC20InsufficientAllowance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenCrosschainErrors::ERC20InsufficientAllowance,
                            )
                    }
                    ERC20InsufficientAllowance
                },
                {
                    fn ECDSAInvalidSignatureLength(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenCrosschainErrors::ECDSAInvalidSignatureLength,
                            )
                    }
                    ECDSAInvalidSignatureLength
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BridgeMustBeContract(inner) => {
                    <BridgeMustBeContract as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BridgeNotActive(inner) => {
                    <BridgeNotActive as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BurnOnlyDuringLockPeriod(inner) => {
                    <BurnOnlyDuringLockPeriod as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CannotAddSelfAsBridge(inner) => {
                    <CannotAddSelfAsBridge as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CheckpointUnorderedInsertion(inner) => {
                    <CheckpointUnorderedInsertion as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20ExceededSafeSupply(inner) => {
                    <ERC20ExceededSafeSupply as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InsufficientAllowance(inner) => {
                    <ERC20InsufficientAllowance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InsufficientBalance(inner) => {
                    <ERC20InsufficientBalance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidApprover(inner) => {
                    <ERC20InvalidApprover as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidReceiver(inner) => {
                    <ERC20InvalidReceiver as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidSender(inner) => {
                    <ERC20InvalidSender as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidSpender(inner) => {
                    <ERC20InvalidSpender as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC2612ExpiredSignature(inner) => {
                    <ERC2612ExpiredSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC2612InvalidSigner(inner) => {
                    <ERC2612InvalidSigner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC5805FutureLookup(inner) => {
                    <ERC5805FutureLookup as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC6372InconsistentClock(inner) => {
                    <ERC6372InconsistentClock as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ExceedsTotalSupply(inner) => {
                    <ExceedsTotalSupply as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientBurnLimit(inner) => {
                    <InsufficientBurnLimit as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientEmissionBudget(inner) => {
                    <InsufficientEmissionBudget as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientMintLimit(inner) => {
                    <InsufficientMintLimit as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidAccountNonce(inner) => {
                    <InvalidAccountNonce as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidShortString(inner) => {
                    <InvalidShortString as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SafeCastOverflowedUintDowncast(inner) => {
                    <SafeCastOverflowedUintDowncast as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::StringTooLong(inner) => {
                    <StringTooLong as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::TransfersLocked(inner) => {
                    <TransfersLocked as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UnauthorizedBridge(inner) => {
                    <UnauthorizedBridge as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UnlockTimestampInPast(inner) => {
                    <UnlockTimestampInPast as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UnlockTimestampTooLate(inner) => {
                    <UnlockTimestampTooLate as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UnreasonableBurnLimit(inner) => {
                    <UnreasonableBurnLimit as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UnreasonableMintLimit(inner) => {
                    <UnreasonableMintLimit as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::VotesExpiredSignature(inner) => {
                    <VotesExpiredSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ZeroAmount(inner) => {
                    <ZeroAmount as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BridgeMustBeContract(inner) => {
                    <BridgeMustBeContract as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BridgeNotActive(inner) => {
                    <BridgeNotActive as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BurnOnlyDuringLockPeriod(inner) => {
                    <BurnOnlyDuringLockPeriod as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CannotAddSelfAsBridge(inner) => {
                    <CannotAddSelfAsBridge as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CheckpointUnorderedInsertion(inner) => {
                    <CheckpointUnorderedInsertion as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20ExceededSafeSupply(inner) => {
                    <ERC20ExceededSafeSupply as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InsufficientAllowance(inner) => {
                    <ERC20InsufficientAllowance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InsufficientBalance(inner) => {
                    <ERC20InsufficientBalance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidApprover(inner) => {
                    <ERC20InvalidApprover as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidReceiver(inner) => {
                    <ERC20InvalidReceiver as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidSender(inner) => {
                    <ERC20InvalidSender as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidSpender(inner) => {
                    <ERC20InvalidSpender as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC2612ExpiredSignature(inner) => {
                    <ERC2612ExpiredSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC2612InvalidSigner(inner) => {
                    <ERC2612InvalidSigner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC5805FutureLookup(inner) => {
                    <ERC5805FutureLookup as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC6372InconsistentClock(inner) => {
                    <ERC6372InconsistentClock as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ExceedsTotalSupply(inner) => {
                    <ExceedsTotalSupply as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientBurnLimit(inner) => {
                    <InsufficientBurnLimit as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientEmissionBudget(inner) => {
                    <InsufficientEmissionBudget as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientMintLimit(inner) => {
                    <InsufficientMintLimit as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidAccountNonce(inner) => {
                    <InvalidAccountNonce as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidShortString(inner) => {
                    <InvalidShortString as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SafeCastOverflowedUintDowncast(inner) => {
                    <SafeCastOverflowedUintDowncast as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::StringTooLong(inner) => {
                    <StringTooLong as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TransfersLocked(inner) => {
                    <TransfersLocked as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UnauthorizedBridge(inner) => {
                    <UnauthorizedBridge as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UnlockTimestampInPast(inner) => {
                    <UnlockTimestampInPast as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UnlockTimestampTooLate(inner) => {
                    <UnlockTimestampTooLate as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UnreasonableBurnLimit(inner) => {
                    <UnreasonableBurnLimit as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UnreasonableMintLimit(inner) => {
                    <UnreasonableMintLimit as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::VotesExpiredSignature(inner) => {
                    <VotesExpiredSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAmount(inner) => {
                    <ZeroAmount as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
            }
        }
    }
    ///Container for all the [`SyndicateTokenCrosschain`](self) events.
    pub enum SyndicateTokenCrosschainEvents {
        #[allow(missing_docs)]
        Approval(Approval),
        #[allow(missing_docs)]
        BridgeActiveStatusChanged(BridgeActiveStatusChanged),
        #[allow(missing_docs)]
        BridgeAdded(BridgeAdded),
        #[allow(missing_docs)]
        BridgeLimitsSet(BridgeLimitsSet),
        #[allow(missing_docs)]
        BridgeRemoved(BridgeRemoved),
        #[allow(missing_docs)]
        CrosschainBurn(CrosschainBurn),
        #[allow(missing_docs)]
        CrosschainMint(CrosschainMint),
        #[allow(missing_docs)]
        DelegateChanged(DelegateChanged),
        #[allow(missing_docs)]
        DelegateVotesChanged(DelegateVotesChanged),
        #[allow(missing_docs)]
        EIP712DomainChanged(EIP712DomainChanged),
        #[allow(missing_docs)]
        EmissionBudgetAllocated(EmissionBudgetAllocated),
        #[allow(missing_docs)]
        EmissionBudgetConsumed(EmissionBudgetConsumed),
        #[allow(missing_docs)]
        RoleAdminChanged(RoleAdminChanged),
        #[allow(missing_docs)]
        RoleGranted(RoleGranted),
        #[allow(missing_docs)]
        RoleRevoked(RoleRevoked),
        #[allow(missing_docs)]
        TokensBurnedByManager(TokensBurnedByManager),
        #[allow(missing_docs)]
        Transfer(Transfer),
        #[allow(missing_docs)]
        UnlockTimestampUpdated(UnlockTimestampUpdated),
    }
    #[automatically_derived]
    impl SyndicateTokenCrosschainEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                10u8,
                99u8,
                135u8,
                201u8,
                234u8,
                54u8,
                40u8,
                184u8,
                138u8,
                99u8,
                59u8,
                180u8,
                243u8,
                177u8,
                81u8,
                119u8,
                15u8,
                112u8,
                8u8,
                81u8,
                23u8,
                161u8,
                95u8,
                155u8,
                243u8,
                120u8,
                124u8,
                218u8,
                83u8,
                241u8,
                61u8,
                49u8,
            ],
            [
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ],
            [
                49u8,
                52u8,
                232u8,
                162u8,
                230u8,
                217u8,
                126u8,
                146u8,
                154u8,
                126u8,
                84u8,
                1u8,
                30u8,
                165u8,
                72u8,
                93u8,
                125u8,
                25u8,
                109u8,
                213u8,
                240u8,
                186u8,
                77u8,
                78u8,
                249u8,
                88u8,
                3u8,
                232u8,
                227u8,
                252u8,
                37u8,
                127u8,
            ],
            [
                93u8,
                157u8,
                80u8,
                52u8,
                101u8,
                108u8,
                179u8,
                235u8,
                251u8,
                6u8,
                85u8,
                5u8,
                124u8,
                215u8,
                249u8,
                180u8,
                7u8,
                122u8,
                155u8,
                66u8,
                255u8,
                66u8,
                206u8,
                34u8,
                60u8,
                186u8,
                197u8,
                188u8,
                88u8,
                109u8,
                33u8,
                38u8,
            ],
            [
                140u8,
                91u8,
                225u8,
                229u8,
                235u8,
                236u8,
                125u8,
                91u8,
                209u8,
                79u8,
                113u8,
                66u8,
                125u8,
                30u8,
                132u8,
                243u8,
                221u8,
                3u8,
                20u8,
                192u8,
                247u8,
                178u8,
                41u8,
                30u8,
                91u8,
                32u8,
                10u8,
                200u8,
                199u8,
                195u8,
                185u8,
                37u8,
            ],
            [
                156u8,
                134u8,
                104u8,
                219u8,
                50u8,
                72u8,
                69u8,
                6u8,
                93u8,
                43u8,
                154u8,
                42u8,
                24u8,
                59u8,
                211u8,
                20u8,
                31u8,
                99u8,
                1u8,
                143u8,
                84u8,
                130u8,
                130u8,
                218u8,
                241u8,
                141u8,
                164u8,
                156u8,
                203u8,
                248u8,
                140u8,
                51u8,
            ],
            [
                156u8,
                160u8,
                61u8,
                189u8,
                81u8,
                147u8,
                251u8,
                183u8,
                151u8,
                65u8,
                115u8,
                206u8,
                221u8,
                11u8,
                223u8,
                104u8,
                65u8,
                221u8,
                20u8,
                195u8,
                203u8,
                250u8,
                115u8,
                90u8,
                171u8,
                119u8,
                255u8,
                29u8,
                209u8,
                19u8,
                159u8,
                179u8,
            ],
            [
                170u8,
                128u8,
                125u8,
                10u8,
                191u8,
                48u8,
                217u8,
                25u8,
                104u8,
                199u8,
                71u8,
                140u8,
                102u8,
                182u8,
                216u8,
                37u8,
                33u8,
                161u8,
                6u8,
                175u8,
                19u8,
                237u8,
                160u8,
                54u8,
                226u8,
                3u8,
                109u8,
                169u8,
                175u8,
                22u8,
                137u8,
                88u8,
            ],
            [
                185u8,
                7u8,
                149u8,
                166u8,
                102u8,
                80u8,
                21u8,
                89u8,
                131u8,
                226u8,
                66u8,
                202u8,
                195u8,
                225u8,
                172u8,
                26u8,
                77u8,
                194u8,
                111u8,
                142u8,
                210u8,
                152u8,
                127u8,
                60u8,
                228u8,
                22u8,
                163u8,
                78u8,
                0u8,
                17u8,
                31u8,
                212u8,
            ],
            [
                188u8,
                35u8,
                236u8,
                127u8,
                19u8,
                19u8,
                21u8,
                11u8,
                4u8,
                123u8,
                255u8,
                131u8,
                208u8,
                132u8,
                91u8,
                5u8,
                100u8,
                186u8,
                161u8,
                52u8,
                105u8,
                141u8,
                209u8,
                27u8,
                176u8,
                172u8,
                208u8,
                247u8,
                212u8,
                22u8,
                222u8,
                125u8,
            ],
            [
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ],
            [
                190u8,
                244u8,
                248u8,
                28u8,
                24u8,
                20u8,
                198u8,
                65u8,
                237u8,
                232u8,
                94u8,
                186u8,
                172u8,
                241u8,
                157u8,
                4u8,
                139u8,
                44u8,
                91u8,
                85u8,
                152u8,
                10u8,
                223u8,
                166u8,
                239u8,
                15u8,
                149u8,
                108u8,
                101u8,
                19u8,
                53u8,
                162u8,
            ],
            [
                219u8,
                3u8,
                249u8,
                125u8,
                197u8,
                132u8,
                10u8,
                113u8,
                230u8,
                155u8,
                231u8,
                71u8,
                14u8,
                71u8,
                97u8,
                175u8,
                16u8,
                161u8,
                35u8,
                121u8,
                115u8,
                232u8,
                28u8,
                18u8,
                208u8,
                220u8,
                40u8,
                19u8,
                137u8,
                90u8,
                101u8,
                38u8,
            ],
            [
                221u8,
                104u8,
                150u8,
                220u8,
                241u8,
                212u8,
                179u8,
                17u8,
                204u8,
                168u8,
                125u8,
                209u8,
                155u8,
                187u8,
                162u8,
                234u8,
                156u8,
                226u8,
                248u8,
                103u8,
                193u8,
                86u8,
                136u8,
                120u8,
                160u8,
                67u8,
                138u8,
                102u8,
                161u8,
                175u8,
                238u8,
                236u8,
            ],
            [
                221u8,
                242u8,
                82u8,
                173u8,
                27u8,
                226u8,
                200u8,
                155u8,
                105u8,
                194u8,
                176u8,
                104u8,
                252u8,
                55u8,
                141u8,
                170u8,
                149u8,
                43u8,
                167u8,
                241u8,
                99u8,
                196u8,
                161u8,
                22u8,
                40u8,
                245u8,
                90u8,
                77u8,
                245u8,
                35u8,
                179u8,
                239u8,
            ],
            [
                222u8,
                34u8,
                186u8,
                255u8,
                3u8,
                142u8,
                58u8,
                62u8,
                8u8,
                64u8,
                124u8,
                189u8,
                246u8,
                23u8,
                222u8,
                237u8,
                116u8,
                232u8,
                105u8,
                167u8,
                186u8,
                81u8,
                125u8,
                246u8,
                17u8,
                227u8,
                49u8,
                49u8,
                198u8,
                230u8,
                234u8,
                4u8,
            ],
            [
                222u8,
                194u8,
                186u8,
                205u8,
                210u8,
                240u8,
                91u8,
                89u8,
                222u8,
                52u8,
                218u8,
                155u8,
                82u8,
                61u8,
                255u8,
                139u8,
                228u8,
                46u8,
                94u8,
                56u8,
                232u8,
                24u8,
                200u8,
                47u8,
                219u8,
                11u8,
                174u8,
                119u8,
                67u8,
                135u8,
                167u8,
                36u8,
            ],
            [
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for SyndicateTokenCrosschainEvents {
        const NAME: &'static str = "SyndicateTokenCrosschainEvents";
        const COUNT: usize = 18usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<Approval as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Approval as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Approval)
                }
                Some(
                    <BridgeActiveStatusChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BridgeActiveStatusChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeActiveStatusChanged)
                }
                Some(<BridgeAdded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <BridgeAdded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeAdded)
                }
                Some(<BridgeLimitsSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <BridgeLimitsSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeLimitsSet)
                }
                Some(<BridgeRemoved as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <BridgeRemoved as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeRemoved)
                }
                Some(<CrosschainBurn as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <CrosschainBurn as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::CrosschainBurn)
                }
                Some(<CrosschainMint as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <CrosschainMint as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::CrosschainMint)
                }
                Some(<DelegateChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <DelegateChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::DelegateChanged)
                }
                Some(
                    <DelegateVotesChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <DelegateVotesChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::DelegateVotesChanged)
                }
                Some(
                    <EIP712DomainChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <EIP712DomainChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EIP712DomainChanged)
                }
                Some(
                    <EmissionBudgetAllocated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <EmissionBudgetAllocated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EmissionBudgetAllocated)
                }
                Some(
                    <EmissionBudgetConsumed as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <EmissionBudgetConsumed as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EmissionBudgetConsumed)
                }
                Some(<RoleAdminChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleAdminChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleAdminChanged)
                }
                Some(<RoleGranted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleGranted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleGranted)
                }
                Some(<RoleRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleRevoked)
                }
                Some(
                    <TokensBurnedByManager as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <TokensBurnedByManager as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TokensBurnedByManager)
                }
                Some(<Transfer as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Transfer as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Transfer)
                }
                Some(
                    <UnlockTimestampUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <UnlockTimestampUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::UnlockTimestampUpdated)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for SyndicateTokenCrosschainEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Approval(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeActiveStatusChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeLimitsSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::CrosschainBurn(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::CrosschainMint(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DelegateChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DelegateVotesChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EIP712DomainChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EmissionBudgetAllocated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EmissionBudgetConsumed(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TokensBurnedByManager(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Transfer(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::UnlockTimestampUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Approval(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeActiveStatusChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeLimitsSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::CrosschainBurn(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::CrosschainMint(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DelegateChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DelegateVotesChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EIP712DomainChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EmissionBudgetAllocated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EmissionBudgetConsumed(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TokensBurnedByManager(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Transfer(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::UnlockTimestampUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`SyndicateTokenCrosschain`](self) contract instance.

See the [wrapper's documentation](`SyndicateTokenCrosschainInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> SyndicateTokenCrosschainInstance<T, P, N> {
        SyndicateTokenCrosschainInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        defaultAdmin: alloy::sol_types::private::Address,
        syndTreasuryAddress: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<SyndicateTokenCrosschainInstance<T, P, N>>,
    > {
        SyndicateTokenCrosschainInstance::<
            T,
            P,
            N,
        >::deploy(provider, defaultAdmin, syndTreasuryAddress)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        defaultAdmin: alloy::sol_types::private::Address,
        syndTreasuryAddress: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        SyndicateTokenCrosschainInstance::<
            T,
            P,
            N,
        >::deploy_builder(provider, defaultAdmin, syndTreasuryAddress)
    }
    /**A [`SyndicateTokenCrosschain`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`SyndicateTokenCrosschain`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct SyndicateTokenCrosschainInstance<
        T,
        P,
        N = alloy_contract::private::Ethereum,
    > {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for SyndicateTokenCrosschainInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("SyndicateTokenCrosschainInstance")
                .field(&self.address)
                .finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyndicateTokenCrosschainInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`SyndicateTokenCrosschain`](self) contract instance.

See the [wrapper's documentation](`SyndicateTokenCrosschainInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            defaultAdmin: alloy::sol_types::private::Address,
            syndTreasuryAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<SyndicateTokenCrosschainInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(
                provider,
                defaultAdmin,
                syndTreasuryAddress,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            defaultAdmin: alloy::sol_types::private::Address,
            syndTreasuryAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            defaultAdmin,
                            syndTreasuryAddress,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> SyndicateTokenCrosschainInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> SyndicateTokenCrosschainInstance<T, P, N> {
            SyndicateTokenCrosschainInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyndicateTokenCrosschainInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`AIRDROP_MANAGER_ROLE`] function.
        pub fn AIRDROP_MANAGER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, AIRDROP_MANAGER_ROLECall, N> {
            self.call_builder(&AIRDROP_MANAGER_ROLECall {})
        }
        ///Creates a new call builder for the [`BRIDGE_MANAGER_ROLE`] function.
        pub fn BRIDGE_MANAGER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, BRIDGE_MANAGER_ROLECall, N> {
            self.call_builder(&BRIDGE_MANAGER_ROLECall {})
        }
        ///Creates a new call builder for the [`CLOCK_MODE`] function.
        pub fn CLOCK_MODE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, CLOCK_MODECall, N> {
            self.call_builder(&CLOCK_MODECall {})
        }
        ///Creates a new call builder for the [`DEFAULT_ADMIN_ROLE`] function.
        pub fn DEFAULT_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, DEFAULT_ADMIN_ROLECall, N> {
            self.call_builder(&DEFAULT_ADMIN_ROLECall {})
        }
        ///Creates a new call builder for the [`DOMAIN_SEPARATOR`] function.
        pub fn DOMAIN_SEPARATOR(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, DOMAIN_SEPARATORCall, N> {
            self.call_builder(&DOMAIN_SEPARATORCall {})
        }
        ///Creates a new call builder for the [`EMISSION_BUDGET_MANAGER_ROLE`] function.
        pub fn EMISSION_BUDGET_MANAGER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSION_BUDGET_MANAGER_ROLECall, N> {
            self.call_builder(
                &EMISSION_BUDGET_MANAGER_ROLECall {
                },
            )
        }
        ///Creates a new call builder for the [`EMISSION_MINTER_ROLE`] function.
        pub fn EMISSION_MINTER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSION_MINTER_ROLECall, N> {
            self.call_builder(&EMISSION_MINTER_ROLECall {})
        }
        ///Creates a new call builder for the [`INITIAL_MINT_SUPPLY`] function.
        pub fn INITIAL_MINT_SUPPLY(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, INITIAL_MINT_SUPPLYCall, N> {
            self.call_builder(&INITIAL_MINT_SUPPLYCall {})
        }
        ///Creates a new call builder for the [`MAX_LOCK_DURATION`] function.
        pub fn MAX_LOCK_DURATION(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, MAX_LOCK_DURATIONCall, N> {
            self.call_builder(&MAX_LOCK_DURATIONCall {})
        }
        ///Creates a new call builder for the [`TOTAL_SUPPLY`] function.
        pub fn TOTAL_SUPPLY(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, TOTAL_SUPPLYCall, N> {
            self.call_builder(&TOTAL_SUPPLYCall {})
        }
        ///Creates a new call builder for the [`allocateEmissionBudget`] function.
        pub fn allocateEmissionBudget(
            &self,
            bridge: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, allocateEmissionBudgetCall, N> {
            self.call_builder(
                &allocateEmissionBudgetCall {
                    bridge,
                    amount,
                },
            )
        }
        ///Creates a new call builder for the [`allowance`] function.
        pub fn allowance(
            &self,
            owner: alloy::sol_types::private::Address,
            spender: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, allowanceCall, N> {
            self.call_builder(&allowanceCall { owner, spender })
        }
        ///Creates a new call builder for the [`approve`] function.
        pub fn approve(
            &self,
            spender: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, approveCall, N> {
            self.call_builder(&approveCall { spender, value })
        }
        ///Creates a new call builder for the [`balanceOf`] function.
        pub fn balanceOf(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, balanceOfCall, N> {
            self.call_builder(&balanceOfCall { account })
        }
        ///Creates a new call builder for the [`bridgeConfigs`] function.
        pub fn bridgeConfigs(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeConfigsCall, N> {
            self.call_builder(&bridgeConfigsCall { _0 })
        }
        ///Creates a new call builder for the [`bridgeEmissionBudgets`] function.
        pub fn bridgeEmissionBudgets(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeEmissionBudgetsCall, N> {
            self.call_builder(&bridgeEmissionBudgetsCall { _0 })
        }
        ///Creates a new call builder for the [`burn`] function.
        pub fn burn(
            &self,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, burnCall, N> {
            self.call_builder(&burnCall { amount })
        }
        ///Creates a new call builder for the [`burnFrom`] function.
        pub fn burnFrom(
            &self,
            from: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, burnFromCall, N> {
            self.call_builder(&burnFromCall { from, amount })
        }
        ///Creates a new call builder for the [`checkpoints`] function.
        pub fn checkpoints(
            &self,
            account: alloy::sol_types::private::Address,
            pos: u32,
        ) -> alloy_contract::SolCallBuilder<T, &P, checkpointsCall, N> {
            self.call_builder(&checkpointsCall { account, pos })
        }
        ///Creates a new call builder for the [`clock`] function.
        pub fn clock(&self) -> alloy_contract::SolCallBuilder<T, &P, clockCall, N> {
            self.call_builder(&clockCall {})
        }
        ///Creates a new call builder for the [`crosschainBurn`] function.
        pub fn crosschainBurn(
            &self,
            from: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, crosschainBurnCall, N> {
            self.call_builder(&crosschainBurnCall { from, amount })
        }
        ///Creates a new call builder for the [`crosschainMint`] function.
        pub fn crosschainMint(
            &self,
            to: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, crosschainMintCall, N> {
            self.call_builder(&crosschainMintCall { to, amount })
        }
        ///Creates a new call builder for the [`decimals`] function.
        pub fn decimals(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, decimalsCall, N> {
            self.call_builder(&decimalsCall {})
        }
        ///Creates a new call builder for the [`delegate`] function.
        pub fn delegate(
            &self,
            delegatee: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, delegateCall, N> {
            self.call_builder(&delegateCall { delegatee })
        }
        ///Creates a new call builder for the [`delegateBySig`] function.
        pub fn delegateBySig(
            &self,
            delegatee: alloy::sol_types::private::Address,
            nonce: alloy::sol_types::private::primitives::aliases::U256,
            expiry: alloy::sol_types::private::primitives::aliases::U256,
            v: u8,
            r: alloy::sol_types::private::FixedBytes<32>,
            s: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, delegateBySigCall, N> {
            self.call_builder(
                &delegateBySigCall {
                    delegatee,
                    nonce,
                    expiry,
                    v,
                    r,
                    s,
                },
            )
        }
        ///Creates a new call builder for the [`delegates`] function.
        pub fn delegates(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, delegatesCall, N> {
            self.call_builder(&delegatesCall { account })
        }
        ///Creates a new call builder for the [`eip712Domain`] function.
        pub fn eip712Domain(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, eip712DomainCall, N> {
            self.call_builder(&eip712DomainCall {})
        }
        ///Creates a new call builder for the [`getAllBridges`] function.
        pub fn getAllBridges(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getAllBridgesCall, N> {
            self.call_builder(&getAllBridgesCall {})
        }
        ///Creates a new call builder for the [`getAvailableBurnLimit`] function.
        pub fn getAvailableBurnLimit(
            &self,
            bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getAvailableBurnLimitCall, N> {
            self.call_builder(
                &getAvailableBurnLimitCall {
                    bridge,
                },
            )
        }
        ///Creates a new call builder for the [`getAvailableMintLimit`] function.
        pub fn getAvailableMintLimit(
            &self,
            bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getAvailableMintLimitCall, N> {
            self.call_builder(
                &getAvailableMintLimitCall {
                    bridge,
                },
            )
        }
        ///Creates a new call builder for the [`getBridgeAtIndex`] function.
        pub fn getBridgeAtIndex(
            &self,
            index: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBridgeAtIndexCall, N> {
            self.call_builder(&getBridgeAtIndexCall { index })
        }
        ///Creates a new call builder for the [`getBridgeConfig`] function.
        pub fn getBridgeConfig(
            &self,
            bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBridgeConfigCall, N> {
            self.call_builder(&getBridgeConfigCall { bridge })
        }
        ///Creates a new call builder for the [`getBridgeCount`] function.
        pub fn getBridgeCount(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBridgeCountCall, N> {
            self.call_builder(&getBridgeCountCall {})
        }
        ///Creates a new call builder for the [`getCurrentTotalSupply`] function.
        pub fn getCurrentTotalSupply(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getCurrentTotalSupplyCall, N> {
            self.call_builder(&getCurrentTotalSupplyCall {})
        }
        ///Creates a new call builder for the [`getEmissionBudget`] function.
        pub fn getEmissionBudget(
            &self,
            bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getEmissionBudgetCall, N> {
            self.call_builder(&getEmissionBudgetCall { bridge })
        }
        ///Creates a new call builder for the [`getPastTotalSupply`] function.
        pub fn getPastTotalSupply(
            &self,
            timepoint: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getPastTotalSupplyCall, N> {
            self.call_builder(
                &getPastTotalSupplyCall {
                    timepoint,
                },
            )
        }
        ///Creates a new call builder for the [`getPastVotes`] function.
        pub fn getPastVotes(
            &self,
            account: alloy::sol_types::private::Address,
            timepoint: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getPastVotesCall, N> {
            self.call_builder(
                &getPastVotesCall {
                    account,
                    timepoint,
                },
            )
        }
        ///Creates a new call builder for the [`getPastVotingPower`] function.
        pub fn getPastVotingPower(
            &self,
            account: alloy::sol_types::private::Address,
            blockNumber: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getPastVotingPowerCall, N> {
            self.call_builder(
                &getPastVotingPowerCall {
                    account,
                    blockNumber,
                },
            )
        }
        ///Creates a new call builder for the [`getRemainingEmissions`] function.
        pub fn getRemainingEmissions(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRemainingEmissionsCall, N> {
            self.call_builder(&getRemainingEmissionsCall {})
        }
        ///Creates a new call builder for the [`getRemainingLockTime`] function.
        pub fn getRemainingLockTime(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRemainingLockTimeCall, N> {
            self.call_builder(&getRemainingLockTimeCall {})
        }
        ///Creates a new call builder for the [`getRoleAdmin`] function.
        pub fn getRoleAdmin(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRoleAdminCall, N> {
            self.call_builder(&getRoleAdminCall { role })
        }
        ///Creates a new call builder for the [`getVotes`] function.
        pub fn getVotes(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getVotesCall, N> {
            self.call_builder(&getVotesCall { account })
        }
        ///Creates a new call builder for the [`getVotingPower`] function.
        pub fn getVotingPower(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getVotingPowerCall, N> {
            self.call_builder(&getVotingPowerCall { account })
        }
        ///Creates a new call builder for the [`grantRole`] function.
        pub fn grantRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, grantRoleCall, N> {
            self.call_builder(&grantRoleCall { role, account })
        }
        ///Creates a new call builder for the [`hasRole`] function.
        pub fn hasRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, hasRoleCall, N> {
            self.call_builder(&hasRoleCall { role, account })
        }
        ///Creates a new call builder for the [`hourlyBurnUsage`] function.
        pub fn hourlyBurnUsage(
            &self,
            _0: alloy::sol_types::private::Address,
            _1: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, hourlyBurnUsageCall, N> {
            self.call_builder(&hourlyBurnUsageCall { _0, _1 })
        }
        ///Creates a new call builder for the [`hourlyMintUsage`] function.
        pub fn hourlyMintUsage(
            &self,
            _0: alloy::sol_types::private::Address,
            _1: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, hourlyMintUsageCall, N> {
            self.call_builder(&hourlyMintUsageCall { _0, _1 })
        }
        ///Creates a new call builder for the [`isBridgeAuthorized`] function.
        pub fn isBridgeAuthorized(
            &self,
            bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, isBridgeAuthorizedCall, N> {
            self.call_builder(&isBridgeAuthorizedCall { bridge })
        }
        ///Creates a new call builder for the [`maxLockTimestamp`] function.
        pub fn maxLockTimestamp(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, maxLockTimestampCall, N> {
            self.call_builder(&maxLockTimestampCall {})
        }
        ///Creates a new call builder for the [`mint`] function.
        pub fn mint(
            &self,
            to: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, mintCall, N> {
            self.call_builder(&mintCall { to, amount })
        }
        ///Creates a new call builder for the [`name`] function.
        pub fn name(&self) -> alloy_contract::SolCallBuilder<T, &P, nameCall, N> {
            self.call_builder(&nameCall {})
        }
        ///Creates a new call builder for the [`nonces`] function.
        pub fn nonces(
            &self,
            owner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, noncesCall, N> {
            self.call_builder(&noncesCall { owner })
        }
        ///Creates a new call builder for the [`numCheckpoints`] function.
        pub fn numCheckpoints(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, numCheckpointsCall, N> {
            self.call_builder(&numCheckpointsCall { account })
        }
        ///Creates a new call builder for the [`permit`] function.
        pub fn permit(
            &self,
            owner: alloy::sol_types::private::Address,
            spender: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
            deadline: alloy::sol_types::private::primitives::aliases::U256,
            v: u8,
            r: alloy::sol_types::private::FixedBytes<32>,
            s: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, permitCall, N> {
            self.call_builder(
                &permitCall {
                    owner,
                    spender,
                    value,
                    deadline,
                    v,
                    r,
                    s,
                },
            )
        }
        ///Creates a new call builder for the [`removeBridge`] function.
        pub fn removeBridge(
            &self,
            bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, removeBridgeCall, N> {
            self.call_builder(&removeBridgeCall { bridge })
        }
        ///Creates a new call builder for the [`renounceRole`] function.
        pub fn renounceRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            callerConfirmation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceRoleCall, N> {
            self.call_builder(
                &renounceRoleCall {
                    role,
                    callerConfirmation,
                },
            )
        }
        ///Creates a new call builder for the [`revokeRole`] function.
        pub fn revokeRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, revokeRoleCall, N> {
            self.call_builder(&revokeRoleCall { role, account })
        }
        ///Creates a new call builder for the [`setBridgeActive`] function.
        pub fn setBridgeActive(
            &self,
            bridge: alloy::sol_types::private::Address,
            isActive: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBridgeActiveCall, N> {
            self.call_builder(
                &setBridgeActiveCall {
                    bridge,
                    isActive,
                },
            )
        }
        ///Creates a new call builder for the [`setBridgeLimits`] function.
        pub fn setBridgeLimits(
            &self,
            bridge: alloy::sol_types::private::Address,
            dailyMintLimit: alloy::sol_types::private::primitives::aliases::U256,
            dailyBurnLimit: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBridgeLimitsCall, N> {
            self.call_builder(
                &setBridgeLimitsCall {
                    bridge,
                    dailyMintLimit,
                    dailyBurnLimit,
                },
            )
        }
        ///Creates a new call builder for the [`setUnlockTimestamp`] function.
        pub fn setUnlockTimestamp(
            &self,
            newUnlockTimestamp: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, setUnlockTimestampCall, N> {
            self.call_builder(
                &setUnlockTimestampCall {
                    newUnlockTimestamp,
                },
            )
        }
        ///Creates a new call builder for the [`supportsInterface`] function.
        pub fn supportsInterface(
            &self,
            interfaceId: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<T, &P, supportsInterfaceCall, N> {
            self.call_builder(
                &supportsInterfaceCall {
                    interfaceId,
                },
            )
        }
        ///Creates a new call builder for the [`symbol`] function.
        pub fn symbol(&self) -> alloy_contract::SolCallBuilder<T, &P, symbolCall, N> {
            self.call_builder(&symbolCall {})
        }
        ///Creates a new call builder for the [`totalSupply`] function.
        pub fn totalSupply(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, totalSupplyCall, N> {
            self.call_builder(&totalSupplyCall {})
        }
        ///Creates a new call builder for the [`transfer`] function.
        pub fn transfer(
            &self,
            to: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferCall, N> {
            self.call_builder(&transferCall { to, value })
        }
        ///Creates a new call builder for the [`transferFrom`] function.
        pub fn transferFrom(
            &self,
            from: alloy::sol_types::private::Address,
            to: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferFromCall, N> {
            self.call_builder(
                &transferFromCall {
                    from,
                    to,
                    value,
                },
            )
        }
        ///Creates a new call builder for the [`transfersLocked`] function.
        pub fn transfersLocked(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, transfersLockedCall, N> {
            self.call_builder(&transfersLockedCall {})
        }
        ///Creates a new call builder for the [`unlockTimestamp`] function.
        pub fn unlockTimestamp(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, unlockTimestampCall, N> {
            self.call_builder(&unlockTimestampCall {})
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyndicateTokenCrosschainInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`Approval`] event.
        pub fn Approval_filter(&self) -> alloy_contract::Event<T, &P, Approval, N> {
            self.event_filter::<Approval>()
        }
        ///Creates a new event filter for the [`BridgeActiveStatusChanged`] event.
        pub fn BridgeActiveStatusChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeActiveStatusChanged, N> {
            self.event_filter::<BridgeActiveStatusChanged>()
        }
        ///Creates a new event filter for the [`BridgeAdded`] event.
        pub fn BridgeAdded_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeAdded, N> {
            self.event_filter::<BridgeAdded>()
        }
        ///Creates a new event filter for the [`BridgeLimitsSet`] event.
        pub fn BridgeLimitsSet_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeLimitsSet, N> {
            self.event_filter::<BridgeLimitsSet>()
        }
        ///Creates a new event filter for the [`BridgeRemoved`] event.
        pub fn BridgeRemoved_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeRemoved, N> {
            self.event_filter::<BridgeRemoved>()
        }
        ///Creates a new event filter for the [`CrosschainBurn`] event.
        pub fn CrosschainBurn_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, CrosschainBurn, N> {
            self.event_filter::<CrosschainBurn>()
        }
        ///Creates a new event filter for the [`CrosschainMint`] event.
        pub fn CrosschainMint_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, CrosschainMint, N> {
            self.event_filter::<CrosschainMint>()
        }
        ///Creates a new event filter for the [`DelegateChanged`] event.
        pub fn DelegateChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, DelegateChanged, N> {
            self.event_filter::<DelegateChanged>()
        }
        ///Creates a new event filter for the [`DelegateVotesChanged`] event.
        pub fn DelegateVotesChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, DelegateVotesChanged, N> {
            self.event_filter::<DelegateVotesChanged>()
        }
        ///Creates a new event filter for the [`EIP712DomainChanged`] event.
        pub fn EIP712DomainChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EIP712DomainChanged, N> {
            self.event_filter::<EIP712DomainChanged>()
        }
        ///Creates a new event filter for the [`EmissionBudgetAllocated`] event.
        pub fn EmissionBudgetAllocated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EmissionBudgetAllocated, N> {
            self.event_filter::<EmissionBudgetAllocated>()
        }
        ///Creates a new event filter for the [`EmissionBudgetConsumed`] event.
        pub fn EmissionBudgetConsumed_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EmissionBudgetConsumed, N> {
            self.event_filter::<EmissionBudgetConsumed>()
        }
        ///Creates a new event filter for the [`RoleAdminChanged`] event.
        pub fn RoleAdminChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleAdminChanged, N> {
            self.event_filter::<RoleAdminChanged>()
        }
        ///Creates a new event filter for the [`RoleGranted`] event.
        pub fn RoleGranted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleGranted, N> {
            self.event_filter::<RoleGranted>()
        }
        ///Creates a new event filter for the [`RoleRevoked`] event.
        pub fn RoleRevoked_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleRevoked, N> {
            self.event_filter::<RoleRevoked>()
        }
        ///Creates a new event filter for the [`TokensBurnedByManager`] event.
        pub fn TokensBurnedByManager_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TokensBurnedByManager, N> {
            self.event_filter::<TokensBurnedByManager>()
        }
        ///Creates a new event filter for the [`Transfer`] event.
        pub fn Transfer_filter(&self) -> alloy_contract::Event<T, &P, Transfer, N> {
            self.event_filter::<Transfer>()
        }
        ///Creates a new event filter for the [`UnlockTimestampUpdated`] event.
        pub fn UnlockTimestampUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, UnlockTimestampUpdated, N> {
            self.event_filter::<UnlockTimestampUpdated>()
        }
    }
}
