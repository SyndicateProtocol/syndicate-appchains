///Module containing a contract's types and functions.
/**

```solidity
library Checkpoints {
    struct Checkpoint208 { uint48 _key; uint208 _value; }
}
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod Checkpoints {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /**```solidity
struct Checkpoint208 { uint48 _key; uint208 _value; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Checkpoint208 {
        #[allow(missing_docs)]
        pub _key: alloy::sol_types::private::primitives::aliases::U48,
        #[allow(missing_docs)]
        pub _value: alloy::sol_types::private::primitives::aliases::U208,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<48>,
            alloy::sol_types::sol_data::Uint<208>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U48,
            alloy::sol_types::private::primitives::aliases::U208,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Checkpoint208> for UnderlyingRustTuple<'_> {
            fn from(value: Checkpoint208) -> Self {
                (value._key, value._value)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Checkpoint208 {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    _key: tuple.0,
                    _value: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Checkpoint208 {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Checkpoint208 {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(&self._key),
                    <alloy::sol_types::sol_data::Uint<
                        208,
                    > as alloy_sol_types::SolType>::tokenize(&self._value),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Checkpoint208 {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Checkpoint208 {
            const NAME: &'static str = "Checkpoint208";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Checkpoint208(uint48 _key,uint208 _value)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self._key)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        208,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self._value)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Checkpoint208 {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust._key)
                    + <alloy::sol_types::sol_data::Uint<
                        208,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust._value,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    48,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust._key,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    208,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust._value,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`Checkpoints`](self) contract instance.

See the [wrapper's documentation](`CheckpointsInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> CheckpointsInstance<T, P, N> {
        CheckpointsInstance::<T, P, N>::new(address, provider)
    }
    /**A [`Checkpoints`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`Checkpoints`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct CheckpointsInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for CheckpointsInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("CheckpointsInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > CheckpointsInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`Checkpoints`](self) contract instance.

See the [wrapper's documentation](`CheckpointsInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> CheckpointsInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> CheckpointsInstance<T, P, N> {
            CheckpointsInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > CheckpointsInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > CheckpointsInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
///Module containing a contract's types and functions.
/**

```solidity
library IBridgeRateLimiter {
    struct BridgeConfig { uint256 dailyMintLimit; uint256 dailyBurnLimit; uint256 lastMintTimestamp; uint256 lastBurnTimestamp; uint256 currentMintUsed; uint256 currentBurnUsed; bool isActive; }
}
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod IBridgeRateLimiter {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /**```solidity
struct BridgeConfig { uint256 dailyMintLimit; uint256 dailyBurnLimit; uint256 lastMintTimestamp; uint256 lastBurnTimestamp; uint256 currentMintUsed; uint256 currentBurnUsed; bool isActive; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BridgeConfig {
        #[allow(missing_docs)]
        pub dailyMintLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub dailyBurnLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub lastMintTimestamp: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub lastBurnTimestamp: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub currentMintUsed: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub currentBurnUsed: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub isActive: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Bool,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            bool,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BridgeConfig> for UnderlyingRustTuple<'_> {
            fn from(value: BridgeConfig) -> Self {
                (
                    value.dailyMintLimit,
                    value.dailyBurnLimit,
                    value.lastMintTimestamp,
                    value.lastBurnTimestamp,
                    value.currentMintUsed,
                    value.currentBurnUsed,
                    value.isActive,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BridgeConfig {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    dailyMintLimit: tuple.0,
                    dailyBurnLimit: tuple.1,
                    lastMintTimestamp: tuple.2,
                    lastBurnTimestamp: tuple.3,
                    currentMintUsed: tuple.4,
                    currentBurnUsed: tuple.5,
                    isActive: tuple.6,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for BridgeConfig {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for BridgeConfig {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.dailyMintLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.dailyBurnLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.lastMintTimestamp),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.lastBurnTimestamp),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.currentMintUsed),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.currentBurnUsed),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.isActive,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BridgeConfig {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for BridgeConfig {
            const NAME: &'static str = "BridgeConfig";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "BridgeConfig(uint256 dailyMintLimit,uint256 dailyBurnLimit,uint256 lastMintTimestamp,uint256 lastBurnTimestamp,uint256 currentMintUsed,uint256 currentBurnUsed,bool isActive)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.dailyMintLimit,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.dailyBurnLimit,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.lastMintTimestamp,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.lastBurnTimestamp,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.currentMintUsed,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.currentBurnUsed,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.isActive,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BridgeConfig {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.dailyMintLimit,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.dailyBurnLimit,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.lastMintTimestamp,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.lastBurnTimestamp,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.currentMintUsed,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.currentBurnUsed,
                    )
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.isActive,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.dailyMintLimit,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.dailyBurnLimit,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.lastMintTimestamp,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.lastBurnTimestamp,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.currentMintUsed,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.currentBurnUsed,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.isActive,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`IBridgeRateLimiter`](self) contract instance.

See the [wrapper's documentation](`IBridgeRateLimiterInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> IBridgeRateLimiterInstance<T, P, N> {
        IBridgeRateLimiterInstance::<T, P, N>::new(address, provider)
    }
    /**A [`IBridgeRateLimiter`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`IBridgeRateLimiter`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct IBridgeRateLimiterInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for IBridgeRateLimiterInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("IBridgeRateLimiterInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > IBridgeRateLimiterInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`IBridgeRateLimiter`](self) contract instance.

See the [wrapper's documentation](`IBridgeRateLimiterInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> IBridgeRateLimiterInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> IBridgeRateLimiterInstance<T, P, N> {
            IBridgeRateLimiterInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > IBridgeRateLimiterInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > IBridgeRateLimiterInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
/**

Generated by the following Solidity interface...
```solidity
library Checkpoints {
    struct Checkpoint208 {
        uint48 _key;
        uint208 _value;
    }
}

library IBridgeRateLimiter {
    struct BridgeConfig {
        uint256 dailyMintLimit;
        uint256 dailyBurnLimit;
        uint256 lastMintTimestamp;
        uint256 lastBurnTimestamp;
        uint256 currentMintUsed;
        uint256 currentBurnUsed;
        bool isActive;
    }
}

interface SyndicateTokenCrosschain {
    error AccessControlBadConfirmation();
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
    error BridgeNotActive(address bridge);
    error BurnOnlyDuringLockPeriod();
    error CheckpointUnorderedInsertion();
    error ECDSAInvalidSignature();
    error ECDSAInvalidSignatureLength(uint256 length);
    error ECDSAInvalidSignatureS(bytes32 s);
    error ERC20ExceededSafeSupply(uint256 increasedSupply, uint256 cap);
    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);
    error ERC20InvalidApprover(address approver);
    error ERC20InvalidReceiver(address receiver);
    error ERC20InvalidSender(address sender);
    error ERC20InvalidSpender(address spender);
    error ERC2612ExpiredSignature(uint256 deadline);
    error ERC2612InvalidSigner(address signer, address owner);
    error ERC5805FutureLookup(uint256 timepoint, uint48 clock);
    error ERC6372InconsistentClock();
    error ExceedsTotalSupply();
    error InsufficientBurnLimit(address bridge, uint256 requested, uint256 available);
    error InsufficientMintLimit(address bridge, uint256 requested, uint256 available);
    error InvalidAccountNonce(address account, uint256 currentNonce);
    error InvalidShortString();
    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);
    error StringTooLong(string str);
    error TransfersLocked();
    error UnauthorizedBridge(address bridge);
    error UnlockTimestampInPast();
    error UnlockTimestampTooLate();
    error VotesExpiredSignature(uint256 expiry);
    error ZeroAddress();
    error ZeroAmount();

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event BridgeActiveStatusChanged(address indexed bridge, bool isActive);
    event BridgeAdded(address indexed bridge, uint256 dailyMintLimit, uint256 dailyBurnLimit);
    event BridgeLimitsSet(address indexed bridge, uint256 dailyMintLimit, uint256 dailyBurnLimit);
    event BridgeRemoved(address indexed bridge);
    event CrosschainBurn(address indexed from, uint256 amount, address indexed bridge);
    event CrosschainMint(address indexed to, uint256 amount, address indexed bridge);
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    event DelegateVotesChanged(address indexed delegate, uint256 previousVotes, uint256 newVotes);
    event EIP712DomainChanged();
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
    event TokensBurnedByManager(address indexed from, uint256 amount, address indexed burner);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event UnlockTimestampUpdated(uint256 oldTimestamp, uint256 newTimestamp, address indexed updatedBy);

    constructor(address defaultAdmin, address syndTreasuryAddress);

    function AIRDROP_MANAGER_ROLE() external view returns (bytes32);
    function BRIDGE_MANAGER_ROLE() external view returns (bytes32);
    function CLOCK_MODE() external view returns (string memory);
    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function EMISSION_MINTER_ROLE() external view returns (bytes32);
    function INITIAL_MINT_SUPPLY() external view returns (uint256);
    function MAX_LOCK_DURATION() external view returns (uint256);
    function TOTAL_SUPPLY() external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function bridgeConfigs(address) external view returns (uint256 dailyMintLimit, uint256 dailyBurnLimit, uint256 lastMintTimestamp, uint256 lastBurnTimestamp, uint256 currentMintUsed, uint256 currentBurnUsed, bool isActive);
    function bridges(uint256) external view returns (address);
    function burn(uint256 amount) external;
    function burnFrom(address from, uint256 amount) external;
    function checkpoints(address account, uint32 pos) external view returns (Checkpoints.Checkpoint208 memory);
    function clock() external view returns (uint48);
    function crosschainBurn(address from, uint256 amount) external;
    function crosschainMint(address to, uint256 amount) external;
    function decimals() external view returns (uint8);
    function delegate(address delegatee) external;
    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;
    function delegates(address account) external view returns (address);
    function eip712Domain() external view returns (bytes1 fields, string memory name, string memory version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] memory extensions);
    function getAllBridges() external view returns (address[] memory allBridges);
    function getAvailableBurnLimit(address bridge) external view returns (uint256 available);
    function getAvailableMintLimit(address bridge) external view returns (uint256 available);
    function getBridgeAtIndex(uint256 index) external view returns (address bridge);
    function getBridgeConfig(address bridge) external view returns (IBridgeRateLimiter.BridgeConfig memory config);
    function getBridgeCount() external view returns (uint256 count);
    function getCurrentTotalSupply() external view returns (uint256);
    function getPastTotalSupply(uint256 timepoint) external view returns (uint256);
    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);
    function getPastVotingPower(address account, uint256 blockNumber) external view returns (uint256);
    function getRemainingEmissions() external view returns (uint256);
    function getRemainingLockTime() external view returns (uint256);
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function getVotes(address account) external view returns (uint256);
    function getVotingPower(address account) external view returns (uint256);
    function grantRole(bytes32 role, address account) external;
    function hasRole(bytes32 role, address account) external view returns (bool);
    function isBridgeAdded(address) external view returns (bool);
    function isBridgeAuthorized(address bridge) external view returns (bool authorized);
    function maxLockTimestamp() external view returns (uint256);
    function mint(address to, uint256 amount) external;
    function name() external view returns (string memory);
    function nonces(address owner) external view returns (uint256);
    function numCheckpoints(address account) external view returns (uint32);
    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
    function removeBridge(address bridge) external;
    function renounceRole(bytes32 role, address callerConfirmation) external;
    function revokeRole(bytes32 role, address account) external;
    function setBridgeActive(address bridge, bool isActive) external;
    function setBridgeLimits(address bridge, uint256 dailyMintLimit, uint256 dailyBurnLimit) external;
    function setUnlockTimestamp(uint256 newUnlockTimestamp) external;
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
    function symbol() external view returns (string memory);
    function totalSupply() external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
    function transfersLocked() external view returns (bool);
    function unlockTimestamp() external view returns (uint256);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "defaultAdmin",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "syndTreasuryAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "AIRDROP_MANAGER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "BRIDGE_MANAGER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "CLOCK_MODE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DEFAULT_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DOMAIN_SEPARATOR",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMISSION_MINTER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "INITIAL_MINT_SUPPLY",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "MAX_LOCK_DURATION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "TOTAL_SUPPLY",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "allowance",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "approve",
    "inputs": [
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "balanceOf",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeConfigs",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "dailyMintLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "dailyBurnLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "lastMintTimestamp",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "lastBurnTimestamp",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "currentMintUsed",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "currentBurnUsed",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "isActive",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridges",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "burn",
    "inputs": [
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "burnFrom",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "checkpoints",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "pos",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct Checkpoints.Checkpoint208",
        "components": [
          {
            "name": "_key",
            "type": "uint48",
            "internalType": "uint48"
          },
          {
            "name": "_value",
            "type": "uint208",
            "internalType": "uint208"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "clock",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint48",
        "internalType": "uint48"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "crosschainBurn",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "crosschainMint",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "decimals",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint8",
        "internalType": "uint8"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "delegate",
    "inputs": [
      {
        "name": "delegatee",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "delegateBySig",
    "inputs": [
      {
        "name": "delegatee",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "nonce",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "expiry",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "v",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "r",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "delegates",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "eip712Domain",
    "inputs": [],
    "outputs": [
      {
        "name": "fields",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "version",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "verifyingContract",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "salt",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "extensions",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getAllBridges",
    "inputs": [],
    "outputs": [
      {
        "name": "allBridges",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getAvailableBurnLimit",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "available",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getAvailableMintLimit",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "available",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBridgeAtIndex",
    "inputs": [
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBridgeConfig",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "config",
        "type": "tuple",
        "internalType": "struct IBridgeRateLimiter.BridgeConfig",
        "components": [
          {
            "name": "dailyMintLimit",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "dailyBurnLimit",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "lastMintTimestamp",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "lastBurnTimestamp",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "currentMintUsed",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "currentBurnUsed",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "isActive",
            "type": "bool",
            "internalType": "bool"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBridgeCount",
    "inputs": [],
    "outputs": [
      {
        "name": "count",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCurrentTotalSupply",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPastTotalSupply",
    "inputs": [
      {
        "name": "timepoint",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPastVotes",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "timepoint",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPastVotingPower",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "blockNumber",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRemainingEmissions",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRemainingLockTime",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleAdmin",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getVotes",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getVotingPower",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "grantRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "hasRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isBridgeAdded",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isBridgeAuthorized",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "authorized",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "maxLockTimestamp",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "mint",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "name",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "nonces",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "numCheckpoints",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "permit",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "deadline",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "v",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "r",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeBridge",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "callerConfirmation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBridgeActive",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "isActive",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBridgeLimits",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "dailyMintLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "dailyBurnLimit",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setUnlockTimestamp",
    "inputs": [
      {
        "name": "newUnlockTimestamp",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "symbol",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "totalSupply",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "transfer",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferFrom",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transfersLocked",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "unlockTimestamp",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "event",
    "name": "Approval",
    "inputs": [
      {
        "name": "owner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "spender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeActiveStatusChanged",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "isActive",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeAdded",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "dailyMintLimit",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "dailyBurnLimit",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeLimitsSet",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "dailyMintLimit",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "dailyBurnLimit",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgeRemoved",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "CrosschainBurn",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "bridge",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "CrosschainMint",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "bridge",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DelegateChanged",
    "inputs": [
      {
        "name": "delegator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "fromDelegate",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "toDelegate",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DelegateVotesChanged",
    "inputs": [
      {
        "name": "delegate",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "previousVotes",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "newVotes",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EIP712DomainChanged",
    "inputs": [],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleAdminChanged",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "previousAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleGranted",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleRevoked",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TokensBurnedByManager",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "burner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Transfer",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "UnlockTimestampUpdated",
    "inputs": [
      {
        "name": "oldTimestamp",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "newTimestamp",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "updatedBy",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AccessControlBadConfirmation",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AccessControlUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "neededRole",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "BridgeNotActive",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "BurnOnlyDuringLockPeriod",
    "inputs": []
  },
  {
    "type": "error",
    "name": "CheckpointUnorderedInsertion",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignature",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureLength",
    "inputs": [
      {
        "name": "length",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureS",
    "inputs": [
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20ExceededSafeSupply",
    "inputs": [
      {
        "name": "increasedSupply",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "cap",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InsufficientAllowance",
    "inputs": [
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "allowance",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "needed",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InsufficientBalance",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "balance",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "needed",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidApprover",
    "inputs": [
      {
        "name": "approver",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidReceiver",
    "inputs": [
      {
        "name": "receiver",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidSender",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC20InvalidSpender",
    "inputs": [
      {
        "name": "spender",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC2612ExpiredSignature",
    "inputs": [
      {
        "name": "deadline",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC2612InvalidSigner",
    "inputs": [
      {
        "name": "signer",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC5805FutureLookup",
    "inputs": [
      {
        "name": "timepoint",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "clock",
        "type": "uint48",
        "internalType": "uint48"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC6372InconsistentClock",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ExceedsTotalSupply",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientBurnLimit",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "requested",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "available",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientMintLimit",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "requested",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "available",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidAccountNonce",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "currentNonce",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidShortString",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SafeCastOverflowedUintDowncast",
    "inputs": [
      {
        "name": "bits",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "StringTooLong",
    "inputs": [
      {
        "name": "str",
        "type": "string",
        "internalType": "string"
      }
    ]
  },
  {
    "type": "error",
    "name": "TransfersLocked",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UnauthorizedBridge",
    "inputs": [
      {
        "name": "bridge",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "UnlockTimestampInPast",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UnlockTimestampTooLate",
    "inputs": []
  },
  {
    "type": "error",
    "name": "VotesExpiredSignature",
    "inputs": [
      {
        "name": "expiry",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ZeroAddress",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroAmount",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod SyndicateTokenCrosschain {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x610180604052346100845761001b610015610158565b9061019e565b610023610089565b6164e6611cdc8239608051816143ba015260a051816143f1015260c05181614381015260e05181614cff01526101005181614d240152610120518161484f0152610140518161488f01526101605181818161115401526134e501526164e690f35b61008f565b60405190565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b906100bb90610093565b810190811060018060401b038211176100d357604052565b61009d565b906100eb6100e4610089565b92836100b1565b565b5f80fd5b60018060a01b031690565b610105906100f1565b90565b610111816100fc565b0361011857565b5f80fd5b9050519061012982610108565b565b91906040838203126101535780610147610150925f860161011c565b9360200161011c565b90565b6100ed565b6101766181c28038038061016b816100d8565b92833981019061012b565b9091565b7fcce296b040332a080e6df13515a3ec2869e21cd20f7344af0987ddb938d8bd2190565b6101ab6101b892826101bb565b6101b361017a565b61099a565b50565b906101c5916101c7565b565b906101d191610416565b565b60018060401b0381116101ef576101eb602091610093565b0190565b61009d565b90610206610201836101d3565b6100d8565b918252565b5f7f53796e6469636174650000000000000000000000000000000000000000000000910152565b61023c60096101f4565b906102496020830161020b565b565b610253610232565b90565b5f7f53594e4400000000000000000000000000000000000000000000000000000000910152565b61028760046101f4565b9061029460208301610256565b565b61029e61027d565b90565b90565b90565b6102bb6102b66102c0926102a1565b6102a4565b6100f1565b90565b6102cc906102a7565b90565b5f0190565b90565b90565b6102ee6102e96102f3926102d4565b6102a4565b6102d7565b90565b6103026276a7006102da565b90565b634e487b7160e01b5f52601160045260245ffd5b61032861032e919392936102d7565b926102d7565b820180921161033957565b610305565b61035261034d610357926102a1565b6102a4565b6102d7565b90565b5f1b90565b9061036b5f199161035a565b9181191691161790565b61038961038461038e926102d7565b6102a4565b6102d7565b90565b90565b906103a96103a46103b092610375565b610391565b825461035f565b9055565b90565b6103cb6103c66103d0926102a1565b61035a565b6103b4565b90565b6103dc5f6103b7565b90565b90565b6103f66103f16103fb926103df565b6102a4565b6102d7565b90565b6104136b02e87669c308736a040000006103e2565b90565b9061043861042261024b565b61042a61024b565b610432610296565b916104fe565b8161045361044d6104485f6102c3565b6100fc565b916100fc565b146104e2578061047361046d6104685f6102c3565b6100fc565b916100fc565b146104c6576104b56104c4926104914261048b6102f6565b90610319565b610160526104a86104a15f61033e565b600c610394565b6104b06103d3565b61099a565b506104be6103fe565b90610a68565b565b5f63d92e233d60e01b8152806104de600482016102cf565b0390fd5b5f63d92e233d60e01b8152806104fa600482016102cf565b0390fd5b90610509929161050b565b565b906105169291610518565b565b906105239291610525565b565b906105309291610532565b565b9061053d929161058a565b565b5f7f3100000000000000000000000000000000000000000000000000000000000000910152565b61057060016101f4565b9061057d6020830161053f565b565b610587610566565b90565b9061059e929161059861057f565b906105a0565b565b906105ac9392916105f2565b565b90565b90565b60200190565b5190565b6105d26105cd6105d7926100f1565b6102a4565b6100f1565b90565b6105e3906105be565b90565b6105ef906105da565b90565b610603610653946106389394610687565b6106178161061160066105ae565b90610b15565b6101205261062f8361062960076105ae565b90610b15565b610140526105b1565b61064a610644826105ba565b916105b4565b2060e0526105b1565b61066561065f826105ba565b916105b4565b20610100524660a052610676610c1a565b608052610682306105e6565b60c052565b9061069191610693565b565b9061069d9161069f565b565b906106a9916108f0565b565b634e487b7160e01b5f525f60045260245ffd5b5190565b634e487b7160e01b5f52602260045260245ffd5b90600160028304921680156106f6575b60208310146106f157565b6106c2565b91607f16916106e6565b5f5260205f2090565b601f602091010490565b1b90565b9190600861073291029161072c5f1984610713565b92610713565b9181191691161790565b919061075261074d61075a93610375565b610391565b908354610717565b9055565b5f90565b6107749161076e61075e565b9161073c565b565b5b818110610782575050565b8061078f5f600193610762565b01610777565b9190601f81116107a5575b505050565b6107b16107d693610700565b9060206107bd84610709565b830193106107de575b6107cf90610709565b0190610776565b5f80806107a0565b91506107cf819290506107c6565b1c90565b90610800905f19906008026107ec565b191690565b8161080f916107f0565b906002021790565b90610821816106be565b9060018060401b0382116108df576108438261083d85546106d6565b85610795565b602090601f831160011461087757918091610866935f9261086b575b5050610805565b90555b565b90915001515f8061085f565b601f1983169161088685610700565b925f5b8181106108c7575091600293918560019694106108ad575b50505002019055610869565b6108bd910151601f8416906107f0565b90555f80806108a1565b91936020600181928787015181550195019201610889565b61009d565b906108ee91610817565b565b906108ff6109069260036108e4565b60046108e4565b565b5f90565b151590565b61091a906103b4565b90565b9061092790610911565b5f5260205260405f2090565b61093c906105da565b90565b9061094990610933565b5f5260205260405f2090565b9061096160ff9161035a565b9181191691161790565b6109749061090c565b90565b90565b9061098f61098a6109969261096b565b610977565b8254610955565b9055565b6109a2610908565b506109b76109b1828490610cb7565b1561090c565b5f14610a40576109df60016109da5f6109d26005869061091d565b01859061093f565b61097a565b906109e8610ce5565b90610a25610a1f610a197f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d95610911565b92610933565b92610933565b92610a2e610089565b80610a38816102cf565b0390a4600190565b50505f90565b610a4f906100fc565b9052565b9190610a66905f60208501940190610a46565b565b80610a83610a7d610a785f6102c3565b6100fc565b916100fc565b14610a9f57610a9d91610a955f6102c3565b919091610d16565b565b610ac2610aab5f6102c3565b5f91829163ec442f0560e01b835260048301610a53565b0390fd5b5f90565b90565b610ae1610adc610ae692610aca565b6102a4565b6102d7565b90565b90565b610b00610afb610b0592610ae9565b61035a565b6103b4565b90565b610b1260ff610aec565b90565b90610b1e610ac6565b50610b30610b2b836105b1565b6105ba565b610b43610b3d6020610acd565b916102d7565b105f14610b575750610b5490610eb0565b90565b5f610b65610b6b9392610dc0565b016108e4565b610b7b610b76610b08565b610911565b90565b5f90565b7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f90565b610bb090516103b4565b90565b610bbc906103b4565b9052565b610bc9906102d7565b9052565b90959492610c1894610c07610c1192610bfd608096610bf360a088019c5f890190610bb3565b6020870190610bb3565b6040850190610bb3565b6060830190610bc0565b0190610a46565b565b610c22610b7e565b50610c2b610b82565b610c75610c3860e0610ba6565b91610c66610c47610100610ba6565b46610c51306105e6565b91610c5a610089565b96879560208701610bcd565b602082018103825203826100b1565b610c87610c81826105ba565b916105b4565b2090565b5f1c90565b60ff1690565b610ca2610ca791610c8b565b610c90565b90565b610cb49054610c96565b90565b610cde915f610cd3610cd993610ccb610908565b50600561091d565b0161093f565b610caa565b90565b5f90565b610ced610ce1565b503390565b7f84fe74c71a28b69aa960486ca0e8c1418c86e9ea2cd6b5849b95e2c8f407a67490565b9182610d32610d2c610d275f6102c3565b6100fc565b916100fc565b141580610d9d575b610d4d575b610d4b92919091610fd4565b565b610d55610f5e565b80610d7c575b15610d3f575f6336e278fd60e21b815280610d78600482016102cf565b0390fd5b50610d98610d92610d8b610cf2565b3390610cb7565b1561090c565b610d5b565b5081610db9610db3610dae5f6102c3565b6100fc565b916100fc565b1415610d3a565b90565b90565b610dda610dd5610ddf92610dc3565b6102a4565b6102d7565b90565b60209181520190565b90825f9392825e0152565b610e15610e1e602093610e2393610e0c816106be565b93848093610de2565b95869101610deb565b610093565b0190565b610e3c9160208201915f818403910152610df6565b90565b610e59610e54610e4e836105ba565b926105b4565b610ba6565b9060208110610e67575b5090565b610e79905f1990602003600802610713565b165f610e63565b610e8c610e9191610c8b565b610375565b90565b610ea8610ea3610ead926102d7565b61035a565b6103b4565b90565b610eb8610ac6565b50610ec2816105b1565b90610ecc826105ba565b610edf610ed9601f610dc6565b916102d7565b11610f145750610f0c81610f06610f00610efb610f1195610e3f565b610e80565b916105ba565b17610e94565b610911565b90565b610f3690610f20610089565b91829163305a27a960e01b835260048301610e27565b0390fd5b90565b610f49610f4e91610c8b565b610f3a565b90565b610f5b9054610f3d565b90565b610f66610908565b50610f71600c610f51565b610f83610f7d5f61033e565b916102d7565b141580610f8e575b90565b5042610fab610fa5610fa0600c610f51565b6102d7565b916102d7565b10610f8b565b916020610fd2929493610fcb60408201965f830190610bc0565b0190610bc0565b565b9291610fe2848383916110dd565b83610ffd610ff7610ff25f6102c3565b6100fc565b916100fc565b14611012575b61101092939190916112aa565b565b61101a61124c565b93611023611289565b9480611037611031886102d7565b916102d7565b1161104457509350611003565b85906110605f928392630e58ae9360e11b845260048401610fb1565b0390fd5b9061106e90610933565b5f5260205260405f2090565b6040906110a36110aa949695939661109960608401985f850190610a46565b6020830190610bc0565b0190610bc0565b565b906110b791036102d7565b90565b906110c591016102d7565b90565b91906110db905f60208501940190610bc0565b565b919091806110fb6110f56110f05f6102c3565b6100fc565b916100fc565b145f146111dc5761111f611118836111136002610f51565b610319565b6002610394565b5b8261113b6111356111305f6102c3565b6100fc565b916100fc565b145f146111b05761115f611158836111536002610f51565b6110ac565b6002610394565b5b9190916111ab6111996111937fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef93610933565b93610933565b936111a2610089565b918291826110c8565b0390a3565b6111d7826111d16111c25f8790611064565b916111cc83610f51565b6110ba565b90610394565b611160565b6111ef6111ea5f8390611064565b610f51565b806112026111fc856102d7565b916102d7565b1061122a576112156112259184906110ac565b6112205f8490611064565b610394565b611120565b906112489091925f93849363391434e360e21b85526004850161107a565b0390fd5b61125461075e565b5061125f6002610f51565b90565b60018060d01b031690565b61128161127c61128692611262565b6102a4565b6102d7565b90565b61129161075e565b506112a160018060d01b0361126d565b90565b90565b90565b916113026112fc61130994806112d06112ca6112c55f6102c3565b6100fc565b916100fc565b1461133a575b846112f16112eb6112e65f6102c3565b6100fc565b916100fc565b1461130b575b611532565b92611532565b9091611567565b565b611333600b600261132d6113276113218961141c565b936112a4565b916112a7565b9061146f565b50506112f7565b611362600b600161135c6113566113508961141c565b936112a4565b916112a7565b9061146f565b50506112d6565b5f90565b61137961137f91611262565b91611262565b019060018060d01b03821161139057565b610305565b906113a8916113a2611369565b5061136d565b90565b90565b60ff1690565b6113c86113c36113cd926113ab565b6102a4565b6113ae565b90565b6113d9906113b4565b9052565b9160206113fe9294936113f760408201965f8301906113d0565b0190610bc0565b565b61141461140f611419926102d7565b6102a4565b611262565b90565b611424611369565b508061143e61143860018060d01b0361126d565b916102d7565b1161144f5761144c90611400565b90565b60d061146b5f9283926306dfcc6560e41b8452600484016113dd565b0390fd5b906114a56114ab9392611480611369565b50611489611369565b50809361149e611497611719565b94926117c6565b9091611cac565b9161183b565b91909190565b6114bd6114c391611262565b91611262565b90039060018060d01b0382116114d557565b610305565b906114ed916114e7611369565b506114b1565b90565b906114fa90610933565b5f5260205260405f2090565b60018060a01b031690565b61151d61152291610c8b565b611506565b90565b61152f9054611511565b90565b61154961154e91611541610ce1565b5060096114f0565b611525565b90565b9061155b90610933565b5f5260205260405f2090565b9190918061157d611577856100fc565b916100fc565b1415806116fb575b61158f575b505050565b806115aa6115a461159f5f6102c3565b6100fc565b916100fc565b0361166b575b50816115cc6115c66115c15f6102c3565b6100fc565b916100fc565b036115d8575b8061158a565b61161f611612611619926115ee600a8690611551565b9061160c61160661160060019361141c565b936112a4565b916112a7565b9061146f565b929061126d565b9161126d565b91909161164c7fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a72492610933565b92611661611658610089565b92839283610fb1565b0390a25f806115d2565b6116aa6116b06116a3611680600a8590611551565b600261169d6116976116918961141c565b936112a4565b916112a7565b9061146f565b929061126d565b9161126d565b9190916116dd7fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a72492610933565b926116f26116e9610089565b92839283610fb1565b0390a25f6115b0565b508161170f6117095f61033e565b916102d7565b11611585565b5f90565b611721611715565b5061172a61186a565b90565b5490565b90565b61174861174361174d92611731565b6102a4565b6102d7565b90565b61175f611765919392936102d7565b926102d7565b820391821161177057565b610305565b90565b60301c90565b60018060d01b031690565b61179561179a91611778565b61177e565b90565b6117a79054611789565b90565b6117be6117b96117c3926102a1565b6102a4565b611262565b90565b6117ce611369565b506117da5f820161172d565b806117ed6117e75f61033e565b916102d7565b145f146118035750506117ff5f6117aa565b5b90565b6118305f9161182b6118258461183696019261181f6001611734565b90611750565b91611775565b61187f565b0161179d565b611800565b9161185f5f6118649461184c611369565b50611855611369565b5001929192611775565b611a84565b91909190565b611872611715565b5061187c43611c45565b90565b5f5260205f200190565b5490565b61189760406100d8565b90565b65ffffffffffff1690565b906118af9061189a565b9052565b906118bd90611262565b9052565b5f5260205f2090565b634e487b7160e01b5f52603260045260245ffd5b6118e781611889565b821015611901576118f96001916118c1565b910201905f90565b6118ca565b611910905161189a565b90565b9061192465ffffffffffff9161035a565b9181191691161790565b61194261193d6119479261189a565b6102a4565b61189a565b90565b90565b9061196261195d6119699261192e565b61194a565b8254611913565b9055565b6119779051611262565b90565b60301b90565b9061199265ffffffffffff199161197a565b9181191691161790565b6119b06119ab6119b592611262565b6102a4565b611262565b90565b90565b906119d06119cb6119d79261199c565b6119b8565b8254611980565b9055565b90611a0560205f611a0b946119fd8282016119f7848801611906565b9061194d565b01920161196d565b906119bb565b565b9190611a1e57611a1c916119db565b565b6106ab565b9081549168010000000000000000831015611a535782611a4b916001611a51950181556118de565b90611a0d565b565b61009d565b65ffffffffffff1690565b611a6f611a7491610c8b565b611a58565b90565b611a819054611a63565b90565b90929192611a90611369565b50611a99611369565b50611aa382611889565b80611ab6611ab05f61033e565b916102d7565b115f14611b8657611adc90611ad68491611ad06001611734565b90611750565b9061187f565b90611ae85f8301611a77565b92611af45f840161179d565b9380611b08611b028561189a565b9161189a565b11611b6a57611b1f611b198461189a565b9161189a565b145f14611b3a575050611b35905f8591016119bb565b5b9190565b611b659250611b6086611b57611b4e61188d565b945f86016118a5565b602084016118b3565b611a23565b611b36565b5f632520601d60e01b815280611b82600482016102cf565b0390fd5b50611bb191611bac85611ba3611b9a61188d565b945f86016118a5565b602084016118b3565b611a23565b611bba5f6117aa565b9190565b611bd2611bcd611bd79261189a565b6102a4565b6102d7565b90565b90565b611bf1611bec611bf692611bda565b6102a4565b6113ae565b90565b611c0290611bdd565b9052565b916020611c27929493611c2060408201965f830190611bf9565b0190610bc0565b565b611c3d611c38611c42926102d7565b6102a4565b61189a565b90565b611c4d611715565b5080611c67611c6165ffffffffffff611bbe565b916102d7565b11611c7857611c7590611c29565b90565b6030611c945f9283926306dfcc6560e41b845260048401611c06565b0390fd5b634e487b7160e01b5f52605160045260245ffd5b91909180600114611ccb57600203611c9857611cc7916114da565b905b565b50611cd591611395565b90611cc956fe60806040526004361015610013575b611d7c565b61001d5f3561040c565b806301ffc9a71461040757806304df017d1461040257806306fdde03146103fd578063095ea7b3146103f857806318160ddd146103f357806318bf5077146103ee57806323b872dd146103e9578063248a9ca3146103e45780632b8c49e3146103df5780632f2ff15d146103da57806330d3e8eb146103d5578063313ce567146103d05780633644e515146103cb57806336568abe146103c65780633a46b1a8146103c157806340c10f19146103bc578063427ac0ca146103b757806342966c68146103b25780634bdd36ce146103ad5780634bf5d7e9146103a85780634f1bfc9e146103a3578063587cde1e1461039e5780635a5db1bb146103995780635c19a95c1461039457806363a0daac1461038f578063651455341461038a5780636a96e3ed146103855780636fcfff451461038057806370a082311461037b57806372cbdcc81461037657806378fb7fd21461037157806379cc67901461036c5780637a8cd156146103675780637ecebe001461036257806383f1211b1461035d5780638426adf214610358578063844c90261461035357806384b0196e1461034e5780638a542521146103495780638d3343d6146103445780638e539e8c1461033f578063902d55a51461033a57806391d148541461033557806391ddadf41461033057806394aa22f21461032b57806395d89b41146103265780639ab24eb0146103215780639b7ef64b1461031c578063a217fddf14610317578063a3c4470514610312578063a9059cbb1461030d578063aa082a9d14610308578063b0ca253e14610303578063bb4d4436146102fe578063c02ae754146102f9578063c3cda520146102f4578063c4fc45a8146102ef578063c9ab0006146102ea578063d505accf146102e5578063d547741f146102e0578063dd62ed3e146102db578063f1127ed8146102d65763f75e85120361000e57611d47565b611ce2565b611bfe565b611b9d565b611b63565b611abf565b611a3a565b611960565b6118a4565b61186f565b611839565b611804565b611799565b611764565b611689565b611619565b6115a2565b61156d565b611538565b611503565b6114a0565b61146b565b6113f4565b6113bf565b61135b565b6112f0565b6111ab565b611176565b61111d565b6110e8565b6110b3565b61107f565b61104a565b611015565b610f41565b610f0c565b610eac565b610e1e565b610dea565b610d7d565b610d48565b610d13565b610cbc565b610c4e565b610c19565b610be6565b610b8c565b6109ed565b6109b7565b610983565b61094e565b610919565b6108bc565b610888565b610827565b6107f2565b610756565b6106e8565b6106b3565b61065b565b6105d3565b610526565b610494565b60e01c90565b60405190565b5f80fd5b5f80fd5b63ffffffff60e01b1690565b61043581610420565b0361043c57565b5f80fd5b9050359061044d8261042c565b565b9060208282031261046857610465915f01610440565b90565b61041c565b151590565b61047b9061046d565b9052565b9190610492905f60208501940190610472565b565b346104c4576104c06104af6104aa36600461044f565b611e19565b6104b7610412565b9182918261047f565b0390f35b610418565b60018060a01b031690565b6104dd906104c9565b90565b6104e9816104d4565b036104f057565b5f80fd5b90503590610501826104e0565b565b9060208282031261051c57610519915f016104f4565b90565b61041c565b5f0190565b346105545761053e610539366004610503565b612308565b610546610412565b8061055081610521565b0390f35b610418565b5f91031261056357565b61041c565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b6105a96105b26020936105b7936105a081610568565b9384809361056c565b95869101610575565b610580565b0190565b6105d09160208201915f81840391015261058a565b90565b34610603576105e3366004610559565b6105ff6105ee61246c565b6105f6610412565b918291826105bb565b0390f35b610418565b90565b61061481610608565b0361061b57565b5f80fd5b9050359061062c8261060b565b565b9190604083820312610656578061064a610653925f86016104f4565b9360200161061f565b90565b61041c565b3461068c5761068861067761067136600461062e565b90612482565b61067f610412565b9182918261047f565b0390f35b610418565b61069a90610608565b9052565b91906106b1905f60208501940190610691565b565b346106e3576106c3366004610559565b6106df6106ce6124a4565b6106d6610412565b9182918261069e565b0390f35b610418565b34610717576107016106fb36600461062e565b906124ba565b610709610412565b8061071381610521565b0390f35b610418565b90916060828403126107515761074e610737845f85016104f4565b9361074581602086016104f4565b9360400161061f565b90565b61041c565b346107875761078361077261076c36600461071c565b9161258f565b61077a610412565b9182918261047f565b0390f35b610418565b90565b6107988161078c565b0361079f57565b5f80fd5b905035906107b08261078f565b565b906020828203126107cb576107c8915f016107a3565b90565b61041c565b6107d99061078c565b9052565b91906107f0905f602085019401906107d0565b565b346108225761081e61080d6108083660046107b2565b612608565b610815610412565b918291826107dd565b0390f35b610418565b346108565761084061083a36600461062e565b9061262a565b610848610412565b8061085281610521565b0390f35b610418565b91906040838203126108835780610877610880925f86016107a3565b936020016104f4565b90565b61041c565b346108b7576108a161089b36600461085b565b9061277b565b6108a9610412565b806108b381610521565b0390f35b610418565b346108ec576108e86108d76108d2366004610503565b6128d3565b6108df610412565b9182918261069e565b0390f35b610418565b60ff1690565b610900906108f1565b9052565b9190610917905f602085019401906108f7565b565b3461094957610929366004610559565b61094561093461297f565b61093c610412565b91829182610904565b0390f35b610418565b3461097e5761095e366004610559565b61097a610969612995565b610971610412565b918291826107dd565b0390f35b610418565b346109b25761099c61099636600461085b565b906129a9565b6109a4610412565b806109ae81610521565b0390f35b610418565b346109e8576109e46109d36109cd36600461062e565b90612a26565b6109db610412565b9182918261069e565b0390f35b610418565b34610a1c57610a06610a0036600461062e565b90612b44565b610a0e610412565b80610a1881610521565b0390f35b610418565b90565b610a38610a33610a3d926104c9565b610a21565b6104c9565b90565b610a4990610a24565b90565b610a5590610a40565b90565b90610a6290610a4c565b5f5260205260405f2090565b5f1c90565b90565b610a82610a8791610a6e565b610a73565b90565b610a949054610a76565b90565b60ff1690565b610aa9610aae91610a6e565b610a97565b90565b610abb9054610a9d565b90565b610ac990600d610a58565b610ad45f8201610a8a565b91610ae160018301610a8a565b91610aee60028201610a8a565b91610afb60038301610a8a565b91610b0860048201610a8a565b91610b216006610b1a60058501610a8a565b9301610ab1565b90565b949290979695939160e08601985f8701610b3d91610691565b60208601610b4a91610691565b60408501610b5791610691565b60608401610b6491610691565b60808301610b7191610691565b60a08201610b7e91610691565b60c001610b8a91610472565b565b34610bc357610bbf610ba7610ba2366004610503565b610abe565b93610bb6979597939193610412565b97889788610b24565b0390f35b610418565b90602082820312610be157610bde915f0161061f565b90565b61041c565b34610c1457610bfe610bf9366004610bc8565b612b50565b610c06610412565b80610c1081610521565b0390f35b610418565b34610c4957610c29366004610559565b610c45610c34612b90565b610c3c610412565b9182918261069e565b0390f35b610418565b34610c7e57610c5e366004610559565b610c7a610c69612c3a565b610c71610412565b918291826105bb565b0390f35b610418565b90565b610c9a610c95610c9f92610c83565b610a21565b610608565b90565b610cae6276a700610c86565b90565b610cb9610ca2565b90565b34610cec57610ccc366004610559565b610ce8610cd7610cb1565b610cdf610412565b9182918261069e565b0390f35b610418565b610cfa906104d4565b9052565b9190610d11905f60208501940190610cf1565b565b34610d4357610d3f610d2e610d29366004610503565b612cc7565b610d36610412565b91829182610cfe565b0390f35b610418565b34610d7857610d74610d63610d5e366004610bc8565b612d8e565b610d6b610412565b91829182610cfe565b0390f35b610418565b34610dab57610d95610d90366004610503565b612dd3565b610d9d610412565b80610da781610521565b0390f35b610418565b9091606082840312610de557610de2610dcb845f85016104f4565b93610dd9816020860161061f565b9360400161061f565b90565b61041c565b34610e1957610e03610dfd366004610db0565b9161311e565b610e0b610412565b80610e1581610521565b0390f35b610418565b34610e4e57610e2e366004610559565b610e4a610e3961312b565b610e41610412565b9182918261069e565b0390f35b610418565b90610e5d90610a4c565b5f5260205260405f2090565b1c90565b610e7d906008610e829302610e69565b610a97565b90565b90610e909154610e6d565b90565b610ea990610ea4600f915f92610e53565b610e85565b90565b34610edc57610ed8610ec7610ec2366004610503565b610e93565b610ecf610412565b9182918261047f565b0390f35b610418565b63ffffffff1690565b610ef390610ee1565b9052565b9190610f0a905f60208501940190610eea565b565b34610f3c57610f38610f27610f22366004610503565b613145565b610f2f610412565b91829182610ef7565b0390f35b610418565b34610f7157610f6d610f5c610f57366004610503565b613170565b610f64610412565b9182918261069e565b0390f35b610418565b5190565b60209181520190565b60200190565b610f92906104d4565b9052565b90610fa381602093610f89565b0190565b60200190565b90610fca610fc4610fbd84610f76565b8093610f7a565b92610f83565b905f5b818110610fda5750505090565b909192610ff3610fed6001928651610f96565b94610fa7565b9101919091610fcd565b6110129160208201915f818403910152610fad565b90565b3461104557611025366004610559565b611041611030613241565b611038610412565b91829182610ffd565b0390f35b610418565b3461107a57611076611065611060366004610503565b613257565b61106d610412565b9182918261047f565b0390f35b610418565b346110ae5761109861109236600461062e565b906133bc565b6110a0610412565b806110aa81610521565b0390f35b610418565b346110e3576110c3366004610559565b6110df6110ce6133c8565b6110d6610412565b9182918261069e565b0390f35b610418565b34611118576111146111036110fe366004610503565b613440565b61110b610412565b9182918261069e565b0390f35b610418565b3461114d5761112d366004610559565b611149611138613455565b611140610412565b9182918261047f565b0390f35b610418565b7f000000000000000000000000000000000000000000000000000000000000000090565b346111a657611186366004610559565b6111a2611191611152565b611199610412565b9182918261069e565b0390f35b610418565b346111d9576111c36111be366004610bc8565b6135a8565b6111cb610412565b806111d581610521565b0390f35b610418565b60ff60f81b1690565b6111f0906111de565b9052565b5190565b60209181520190565b60200190565b61121090610608565b9052565b9061122181602093611207565b0190565b60200190565b9061124861124261123b846111f4565b80936111f8565b92611201565b905f5b8181106112585750505090565b90919261127161126b6001928651611214565b94611225565b910191909161124b565b939591946112cc6112c16112e0956112b36112d6956112ed9c9a6112a660e08c01925f8d01906111e7565b8a820360208c015261058a565b9088820360408a015261058a565b976060870190610691565b6080850190610cf1565b60a08301906107d0565b60c081840391015261122b565b90565b3461132757611300366004610559565b61132361130b613630565b9361131a979597939193610412565b9788978861127b565b0390f35b610418565b7f84fe74c71a28b69aa960486ca0e8c1418c86e9ea2cd6b5849b95e2c8f407a67490565b61135861132c565b90565b3461138b5761136b366004610559565b611387611376611350565b61137e610412565b918291826107dd565b0390f35b610418565b7f9b12e0c5707e494915e58b0564f18aaad9b74ac69bfc815a1edadc8e4bd032eb90565b6113bc611390565b90565b346113ef576113cf366004610559565b6113eb6113da6113b4565b6113e2610412565b918291826107dd565b0390f35b610418565b346114245761142061140f61140a366004610bc8565b6136ba565b611417610412565b9182918261069e565b0390f35b610418565b90565b61144061143b61144592611429565b610a21565b610608565b90565b61145d6b033b2e3c9fd0803ce800000061142c565b90565b611468611448565b90565b3461149b5761147b366004610559565b611497611486611460565b61148e610412565b9182918261069e565b0390f35b610418565b346114d1576114cd6114bc6114b636600461085b565b906136eb565b6114c4610412565b9182918261047f565b0390f35b610418565b65ffffffffffff1690565b6114ea906114d6565b9052565b9190611501905f602085019401906114e1565b565b3461153357611513366004610559565b61152f61151e613719565b611526610412565b918291826114ee565b0390f35b610418565b346115685761156461155361154e366004610503565b61372d565b61155b610412565b9182918261069e565b0390f35b610418565b3461159d5761157d366004610559565b6115996115886137b4565b611590610412565b918291826105bb565b0390f35b610418565b346115d2576115ce6115bd6115b8366004610503565b6137ca565b6115c5610412565b9182918261069e565b0390f35b610418565b90565b6115ee6115e96115f3926115d7565b610a21565b610608565b90565b61160b6b02e87669c308736a040000006115da565b90565b6116166115f6565b90565b3461164957611629366004610559565b61164561163461160e565b61163c610412565b9182918261069e565b0390f35b610418565b90565b5f1b90565b61166a61166561166f9261164e565b611651565b61078c565b90565b61167b5f611656565b90565b611686611672565b90565b346116b957611699366004610559565b6116b56116a461167e565b6116ac610412565b918291826107dd565b0390f35b610418565b634e487b7160e01b5f52603260045260245ffd5b5490565b5f5260205f2090565b6116e8816116d2565b821015611702576116fa6001916116d6565b910201905f90565b6116be565b60018060a01b031690565b6117229060086117279302610e69565b611707565b90565b906117359154611712565b90565b600e611743816116d2565b8210156117605761175d91611757916116df565b9061172a565b90565b5f80fd5b346117945761179061177f61177a366004610bc8565b611738565b611787610412565b91829182610cfe565b0390f35b610418565b346117ca576117c66117b56117af36600461062e565b906137f9565b6117bd610412565b9182918261047f565b0390f35b610418565b6117df9060086117e49302610e69565b610a73565b90565b906117f291546117cf565b90565b611801600c5f906117e7565b90565b3461183457611814366004610559565b61183061181f6117f5565b611827610412565b9182918261069e565b0390f35b610418565b3461186a5761186661185561184f36600461062e565b9061381b565b61185d610412565b9182918261069e565b0390f35b610418565b3461189f5761189b61188a611885366004610503565b613831565b611892610412565b9182918261069e565b0390f35b610418565b346118d4576118b4366004610559565b6118d06118bf613846565b6118c7610412565b9182918261069e565b0390f35b610418565b6118e2816108f1565b036118e957565b5f80fd5b905035906118fa826118d9565b565b909160c08284031261195b57611914835f84016104f4565b92611922816020850161061f565b92611930826040830161061f565b9261195861194184606085016118ed565b9361194f81608086016107a3565b9360a0016107a3565b90565b61041c565b346119955761197f6119733660046118fc565b949390939291926138c6565b611987610412565b8061199181610521565b0390f35b610418565b6119a39061046d565b9052565b9060c080611a23936119bf5f8201515f860190611207565b6119d160208201516020860190611207565b6119e360408201516040860190611207565b6119f560608201516060860190611207565b611a0760808201516080860190611207565b611a1960a082015160a0860190611207565b015191019061199a565b565b9190611a38905f60e085019401906119a7565b565b34611a6a57611a66611a55611a50366004610503565b6139ed565b611a5d610412565b91829182611a25565b0390f35b610418565b611a788161046d565b03611a7f57565b5f80fd5b90503590611a9082611a6f565b565b9190604083820312611aba5780611aae611ab7925f86016104f4565b93602001611a83565b90565b61041c565b34611aee57611ad8611ad2366004611a92565b90613b00565b611ae0610412565b80611aea81610521565b0390f35b610418565b60e081830312611b5e57611b09825f83016104f4565b92611b1783602084016104f4565b92611b25816040850161061f565b92611b33826060830161061f565b92611b5b611b4484608085016118ed565b93611b528160a086016107a3565b9360c0016107a3565b90565b61041c565b34611b9857611b82611b76366004611af3565b95949094939193613bae565b611b8a610412565b80611b9481610521565b0390f35b610418565b34611bcc57611bb6611bb036600461085b565b90613ccc565b611bbe610412565b80611bc881610521565b0390f35b610418565b9190604083820312611bf95780611bed611bf6925f86016104f4565b936020016104f4565b90565b61041c565b34611c2f57611c2b611c1a611c14366004611bd1565b90613cee565b611c22610412565b9182918261069e565b0390f35b610418565b611c3d81610ee1565b03611c4457565b5f80fd5b90503590611c5582611c34565b565b9190604083820312611c7f5780611c73611c7c925f86016104f4565b93602001611c48565b90565b61041c565b611c8d906114d6565b9052565b60018060d01b031690565b611ca590611c91565b9052565b90602080611ccb93611cc15f8201515f860190611c84565b0151910190611c9c565b565b9190611ce0905f60408501940190611ca9565b565b34611d1357611d0f611cfe611cf8366004611c57565b90613d5c565b611d06610412565b91829182611ccd565b0390f35b610418565b7fcce296b040332a080e6df13515a3ec2869e21cd20f7344af0987ddb938d8bd2190565b611d44611d18565b90565b34611d7757611d57366004610559565b611d73611d62611d3c565b611d6a610412565b918291826107dd565b0390f35b610418565b5f80fd5b5f90565b634e487b7160e01b5f52601160045260245ffd5b611da4611daa91611c91565b91611c91565b019060018060d01b038211611dbb57565b611d84565b90611dd391611dcd611d80565b50611d98565b90565b611de2611de891611c91565b91611c91565b90039060018060d01b038211611dfa57565b611d84565b90611e1291611e0c611d80565b50611dd6565b90565b5f90565b611e21611e15565b5080611e3c611e36630cccc66560e21b610420565b91610420565b148015611e60575b908115611e50575b5090565b611e5a9150613d72565b5f611e4c565b5080611e7b611e7563b2752ac960e01b610420565b91610420565b14611e44565b611e9a90611e95611e90611d18565b613db2565b61215b565b565b611eb0611eab611eb59261164e565b610a21565b6104c9565b90565b611ec190611e9c565b90565b1b90565b91906008611ee3910291611edd5f1984611ec4565b92611ec4565b9181191691161790565b611f01611efc611f0692610608565b610a21565b610608565b90565b90565b9190611f22611f1d611f2a93611eed565b611f09565b908354611ec8565b9055565b5f90565b611f4491611f3e611f2e565b91611f0c565b565b60065f91611f5683808301611f32565b611f638360018301611f32565b611f708360028301611f32565b611f7d8360038301611f32565b611f8a8360048301611f32565b611f978360058301611f32565b0155565b634e487b7160e01b5f525f60045260245ffd5b905f03611fc057611fbe90611f46565b565b611f9b565b90611fd160ff91611651565b9181191691161790565b611fe49061046d565b90565b90565b90611fff611ffa61200692611fdb565b611fe7565b8254611fc5565b9055565b61201e6120196120239261164e565b610a21565b610608565b90565b60016120329101610608565b90565b90565b61204c61204761205192612035565b610a21565b610608565b90565b61206361206991939293610608565b92610608565b820391821161207457565b611d84565b9190600861209991029161209360018060a01b0384611ec4565b92611ec4565b9181191691161790565b90565b91906120bc6120b76120c493610a4c565b6120a3565b908354612079565b9055565b90565b634e487b7160e01b5f52603160045260245ffd5b5490565b5f5260205f2090565b6120f5816120df565b82101561210f576121076001916120e3565b910201905f90565b6116be565b5f90565b61212a91612124612114565b916120a6565b565b612135816120df565b801561215657600190039061215361214d83836120ec565b90612118565b55565b6120cb565b8061217661217061216b5f611eb8565b6104d4565b916104d4565b146122ec5761219861219261218d600f8490610e53565b610ab1565b1561046d565b6122cd576121b15f6121ac600d8490610a58565b611fae565b6121c65f6121c1600f8490610e53565b611fea565b6121cf5f61200a565b5b806121ec6121e66121e1600e6116d2565b610608565b91610608565b10156122c757612207612201600e83906116df565b9061172a565b612219612213846104d4565b916104d4565b1461222c5761222790612026565b6121d0565b6122729061226c61226461225e600e612258612248600e6116d2565b6122526001612038565b90612054565b906116df565b9061172a565b91600e6116df565b906120a6565b61228461227f600e6120c8565b61212c565b5b6122af7f5d9d5034656cb3ebfb0655057cd7f9b4077a9b42ff42ce223cbac5bc586d212691610a4c565b906122b8610412565b806122c281610521565b0390a2565b50612285565b6122e8905f918291636585b60d60e01b835260048301610cfe565b0390fd5b5f63d92e233d60e01b81528061230460048201610521565b0390fd5b61231190611e81565b565b606090565b634e487b7160e01b5f52602260045260245ffd5b906001600283049216801561234c575b602083101461234757565b612318565b91607f169161233c565b60209181520190565b5f5260205f2090565b905f929180549061238261237b8361232c565b8094612356565b916001811690815f146123d9575060011461239d575b505050565b6123aa919293945061235f565b915f925b8184106123c157505001905f8080612398565b600181602092959395548486015201910192906123ae565b92949550505060ff19168252151560200201905f8080612398565b906123fe91612368565b90565b634e487b7160e01b5f52604160045260245ffd5b9061241f90610580565b810190811067ffffffffffffffff82111761243957604052565b612401565b9061245e6124579261244e610412565b938480926123f4565b0383612415565b565b6124699061243e565b90565b612474612313565b5061247f6003612460565b90565b61249f9161248e611e15565b50612497613dc6565b919091613dd3565b600190565b6124ac611f2e565b506124b76002610a8a565b90565b806124d56124cf6124ca5f611eb8565b6104d4565b916104d4565b1461257357816124ed6124e75f61200a565b91610608565b14612557576124fd338390613e18565b612508818390613f6f565b339061255261254061253a7fde22baff038e3a3e08407cbdf617deed74e869a7ba517df611e33131c6e6ea0493610a4c565b93610a4c565b93612549610412565b9182918261069e565b0390a3565b5f631f2a200560e01b81528061256f60048201610521565b0390fd5b5f63d92e233d60e01b81528061258b60048201610521565b0390fd5b916125b99261259c611e15565b506125b16125a8613dc6565b82908491613fdb565b919091614067565b600190565b5f90565b6125cb9061078c565b90565b906125d8906125c2565b5f5260205260405f2090565b90565b6125f36125f891610a6e565b6125e4565b90565b61260590546125e7565b90565b6001612621612627926126196125be565b5060056125ce565b016125fb565b90565b8061264561263f61263a5f611eb8565b6104d4565b916104d4565b14612735578161265d6126575f61200a565b91610608565b146127195761266d338390614104565b3361268061267a836104d4565b916104d4565b036126e0575b61269181839061425c565b33906126db6126c96126c37fb90795a66650155983e242cac3e1ac1a4dc26f8ed2987f3ce416a34e00111fd493610a4c565b93610a4c565b936126d2610412565b9182918261069e565b0390a3565b6126eb813390613cee565b6126fd6126f75f61200a565b91610608565b03612708575b612686565b61271481338491613fdb565b612703565b5f631f2a200560e01b81528061273160048201610521565b0390fd5b5f63d92e233d60e01b81528061274d60048201610521565b0390fd5b9061276c9161276761276282612608565b613db2565b61276e565b565b90612778916142bb565b50565b9061278591612751565b565b9061279190610608565b9052565b9061279f9061046d565b9052565b906127b66127af610412565b9283612415565b565b6127c260e06127a3565b90565b9061287461286b60066127d66127b8565b946127ed6127e55f8301610a8a565b5f8801612787565b6128056127fc60018301610a8a565b60208801612787565b61281d61281460028301610a8a565b60408801612787565b61283561282c60038301610a8a565b60608801612787565b61284d61284460048301610a8a565b60808801612787565b61286561285c60058301610a8a565b60a08801612787565b01610ab1565b60c08401612795565b565b61287f906127c5565b90565b61288c9051610608565b90565b90565b6128a66128a16128ab9261288f565b610a21565b610608565b90565b6128bd6128c391939293610608565b92610608565b82018092116128ce57565b611d84565b6128ea6128ef916128e2611f2e565b50600d610a58565b612876565b4261292261291c61291761290560608601612882565b61291162015180612892565b906128ae565b610608565b91610608565b101561294d578061294460a061293d602061294a9501612882565b9201612882565b90612054565b90565b60206129599101612882565b90565b5f90565b90565b61297761297261297c92612960565b610a21565b6108f1565b90565b61298761295c565b506129926012612963565b90565b61299d6125be565b506129a6614367565b90565b90806129c46129be6129b9613dc6565b6104d4565b916104d4565b036129d5576129d291614421565b50565b5f63334bd91960e11b8152806129ed60048201610521565b0390fd5b906129fb90610a4c565b5f5260205260405f2090565b90565b612a1e612a19612a2392611c91565b610a21565b610608565b90565b612a5d91612a52612a4c612a47612a5894612a3f611f2e565b50600a6129f1565b612a07565b91614502565b906145f8565b612a0a565b90565b90612a7a91612a75612a70611390565b613db2565b612a7c565b565b9081612a98612a92612a8d5f611eb8565b6104d4565b916104d4565b14612b285780612ab0612aaa5f61200a565b91610608565b14612b0c57612ac7612ac06124a4565b82906128ae565b612ae0612ada612ad5611448565b610608565b91610608565b11612af057612aee91613f6f565b565b5f63177e3fc360e01b815280612b0860048201610521565b0390fd5b5f631f2a200560e01b815280612b2460048201610521565b0390fd5b5f63d92e233d60e01b815280612b4060048201610521565b0390fd5b90612b4e91612a60565b565b80612b63612b5d5f61200a565b91610608565b14612b7457612b72903361425c565b565b5f631f2a200560e01b815280612b8c60048201610521565b0390fd5b612b98611f2e565b50612bb2612ba4611448565b612bac6124a4565b90612054565b90565b67ffffffffffffffff8111612bd357612bcf602091610580565b0190565b612401565b90612bea612be583612bb5565b6127a3565b918252565b5f7f6d6f64653d626c6f636b6e756d6265722666726f6d3d64656661756c74000000910152565b612c20601d612bd8565b90612c2d60208301612bef565b565b612c37612c16565b90565b612c42612313565b50612c4b613719565b612c64612c5e612c5961471f565b6114d6565b916114d6565b03612c7457612c71612c2f565b90565b5f6301bfc1c560e61b815280612c8c60048201610521565b0390fd5b90612c9a90610a4c565b5f5260205260405f2090565b612cb2612cb791610a6e565b611707565b90565b612cc49054612ca6565b90565b612cde612ce391612cd6612114565b506009612c90565b612cba565b90565b60207f6f7574206f6620626f756e647300000000000000000000000000000000000000917f53796e646963617465546f6b656e43726f7373636861696e3a20696e646578205f8201520152565b612d40602d60409261056c565b612d4981612ce6565b0190565b612d629060208101905f818303910152612d33565b90565b15612d6c57565b612d74610412565b62461bcd60e51b815280612d8a60048201612d4d565b0390fd5b612dca612dd091612d9d612114565b50612dc381612dbd612db7612db2600e6116d2565b610608565b91610608565b10612d65565b600e6116df565b9061172a565b90565b612de490612ddf613dc6565b61476f565b565b90612e019291612dfc612df7611d18565b613db2565b612f67565b565b9081549168010000000000000000831015612e335782612e2b916001612e31950181556120ec565b906120a6565b565b612401565b916020612e59929493612e5260408201965f830190610691565b0190610691565b565b612e6560e06127a3565b90565b90612e745f1991611651565b9181191691161790565b90612e93612e8e612e9a92611eed565b611f09565b8254612e68565b9055565b612ea8905161046d565b90565b90612f5360c06006612f5994612ece5f8201612ec85f8801612882565b90612e7e565b612ee760018201612ee160208801612882565b90612e7e565b612f0060028201612efa60408801612882565b90612e7e565b612f1960038201612f1360608801612882565b90612e7e565b612f3260048201612f2c60808801612882565b90612e7e565b612f4b60058201612f4560a08801612882565b90612e7e565b019201612e9e565b90611fea565b565b90612f6591612eab565b565b80612f82612f7c612f775f611eb8565b6104d4565b916104d4565b1461310257612fa4612f9e612f99600f8490610e53565b610ab1565b1561046d565b61308d575b818342425f905f92600194612fbc612e5b565b965f880190612fca91612787565b6020870190612fd891612787565b6040860190612fe691612787565b6060850190612ff491612787565b612ffd9061200a565b608084019061300b91612787565b6130149061200a565b60a083019061302291612787565b60c082019061303091612795565b600d8261303c91610a58565b9061304691612f5b565b907faa807d0abf30d91968c7478c66b6d82521a106af13eda036e2036da9af1689589161307290610a4c565b9261307b610412565b9182916130889183612e38565b0390a2565b6130a161309a600e6120c8565b8290612e03565b6130b760016130b2600f8490610e53565b611fea565b808290846130e57fdb03f97dc5840a71e69be7470e4761af10a1237973e81c12d0dc2813895a652692610a4c565b926130fa6130f1610412565b92839283612e38565b0390a2612fa9565b5f63d92e233d60e01b81528061311a60048201610521565b0390fd5b906131299291612de6565b565b613133611f2e565b5061313e600e6116d2565b90565b5f90565b61315790613151613141565b506147fa565b90565b9061316490610a4c565b5f5260205260405f2090565b61318661318b9161317f611f2e565b505f61315a565b610a8a565b90565b606090565b60209181520190565b6131a69054612ca6565b90565b60010190565b906131cc6131c66131bf846116d2565b8093613193565b926116d6565b905f5b8181106131dc5750505090565b9091926131fc6131f66001926131f18761319c565b610f96565b946131a9565b91019190916131cf565b90613210916131af565b90565b9061323361322c92613223610412565b93848092613206565b0383612415565b565b61323e90613213565b90565b61324961318e565b50613254600e613235565b90565b61325f611e15565b5061328761328261327a613275600d8590610a58565b612876565b92600f610e53565b610ab1565b9081613292575b5090565b61329f915060c001612e9e565b5f61328e565b906132bf916132ba6132b561132c565b613db2565b6132c1565b565b806132dc6132d66132d15f611eb8565b6104d4565b916104d4565b146133a057816132f46132ee5f61200a565b91610608565b146133845761330a613304613455565b1561046d565b6133685761331981839061425c565b339061336361335161334b7fbef4f81c1814c641ede85ebaacf19d048b2c5b55980adfa6ef0f956c651335a293610a4c565b93610a4c565b9361335a610412565b9182918261069e565b0390a3565b5f63b8b5ca2d60e01b81528061338060048201610521565b0390fd5b5f631f2a200560e01b81528061339c60048201610521565b0390fd5b5f63d92e233d60e01b8152806133b860048201610521565b0390fd5b906133c6916132a5565b565b6133d0611f2e565b506133db600c610a8a565b6133ed6133e75f61200a565b91610608565b14801561341c575b6134105761340d613406600c610a8a565b4290612054565b90565b6134195f61200a565b90565b504261343961343361342e600c610a8a565b610608565b91610608565b10156133f5565b6134529061344c611f2e565b50614829565b90565b61345d611e15565b50613468600c610a8a565b61347a6134745f61200a565b91610608565b141580613485575b90565b50426134a261349c613497600c610a8a565b610608565b91610608565b10613482565b6134c1906134bc6134b7611672565b613db2565b6134c3565b565b806134d66134d042610608565b91610608565b111561358c578061350f6135097f0000000000000000000000000000000000000000000000000000000000000000610608565b91610608565b116135705761351e600c610a8a565b61352982600c612e7e565b9033906135567fdd6896dcf1d4b311cca87dd19bbba2ea9ce2f867c1568878a0438a66a1afeeec92610a4c565b9261356b613562610412565b92839283612e38565b0390a2565b5f63ef69af6560e01b81528061358860048201610521565b0390fd5b5f63a565835360e01b8152806135a460048201610521565b0390fd5b6135b1906134a8565b565b5f90565b606090565b6135c590610a40565b90565b67ffffffffffffffff81116135e05760208091020190565b612401565b906135f76135f2836135c8565b6127a3565b918252565b369037565b9061362661360e836135e5565b9260208061361c86936135c8565b92019103906135fc565b565b600f60f81b90565b6136386135b3565b50613641612313565b5061364a612313565b50613653611f2e565b5061365c612114565b506136656125be565b5061366e6135b7565b50613677614841565b90613680614881565b90469061368c306135bc565b906136965f611656565b906136a86136a35f61200a565b613601565b906136b1613628565b96959493929190565b6136e36136e8916136c9611f2e565b506136dd6136d7600b612a07565b91614502565b906145f8565b612a0a565b90565b613712915f61370761370d936136ff611e15565b5060056125ce565b01610e53565b610ab1565b90565b5f90565b613721613715565b5061372a61471f565b90565b6137446137499161373c611f2e565b50600d610a58565b612876565b4261377c61377661377161375f60408601612882565b61376b62015180612892565b906128ae565b610608565b91610608565b10156137a6578061379d60806137965f6137a39501612882565b9201612882565b90612054565b90565b5f6137b19101612882565b90565b6137bc612313565b506137c76004612460565b90565b6137f16137ec6137e76137f6936137df611f2e565b50600a6129f1565b612a07565b6148c1565b612a0a565b90565b61381691613805611e15565b5061380e613dc6565b919091614067565b600190565b9061382e91613828611f2e565b50612a26565b90565b6138439061383d611f2e565b506137ca565b90565b61384e611f2e565b506138576124a4565b90565b7fe48329057bfd03d55e49b547132e39cffd9c1820ad7b9d4c5307691425d15adf90565b6138b36138ba946138a960609498979561389f608086019a5f8701906107d0565b6020850190610cf1565b6040830190610691565b0190610691565b565b60200190565b5190565b93959490929195426138e06138da89610608565b91610608565b11613959579161394b9161395293613942613957989961392a61390161385a565b61391b8b938b61390f610412565b9586946020860161387e565b60208201810382520382612415565b61393c613936826138c2565b916138bc565b20614936565b92909192614953565b918261499d565b61476f565b565b613974875f918291632341d78760e11b83526004830161069e565b0390fd5b5f90565b5f90565b6139886127b8565b9060208080808080808861399a613978565b8152016139a5613978565b8152016139b0613978565b8152016139bb613978565b8152016139c6613978565b8152016139d1613978565b8152016139dc61397c565b81525050565b6139ea613980565b90565b613a04613a09916139fc6139e2565b50600d610a58565b612876565b90565b90613a2691613a21613a1c611d18565b613db2565b613a28565b565b80613a43613a3d613a385f611eb8565b6104d4565b916104d4565b14613ae457613a65613a5f613a5a600f8490610e53565b610ab1565b1561046d565b613ac557613a81826006613a7b600d8590610a58565b01611fea565b613ac0613aae7f9c8668db324845065d2b9a2a183bd3141f63018f548282daf18da49ccbf88c3392610a4c565b92613ab7610412565b9182918261047f565b0390a2565b613ae0905f918291636585b60d60e01b835260048301610cfe565b0390fd5b5f63d92e233d60e01b815280613afc60048201610521565b0390fd5b90613b0a91613a0c565b565b7f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c990565b9194613b78613b8292989795613b6e60a096613b64613b899a613b5a60c08a019e5f8b01906107d0565b6020890190610cf1565b6040870190610cf1565b6060850190610691565b6080830190610691565b0190610691565b565b916020613bac929493613ba560408201965f830190610cf1565b0190610cf1565b565b969591939294909442613bc9613bc383610608565b91610608565b11613c835790613c32613c3b949392613c1a613be3613b0c565b613c0b8c80948c91613bf58d916149e0565b9192613bff610412565b97889660208801613b30565b60208201810382520382612415565b613c2c613c26826138c2565b916138bc565b20614936565b92909192614953565b80613c4e613c48876104d4565b916104d4565b03613c635750613c619293919091613dd3565b565b8490613c7f5f9283926325c0072360e11b845260048401613b8b565b0390fd5b613c9e905f91829163313c898160e11b83526004830161069e565b0390fd5b90613cbd91613cb8613cb382612608565b613db2565b613cbf565b565b90613cc991614421565b50565b90613cd691613ca2565b565b90613ce290610a4c565b5f5260205260405f2090565b613d1391613d09613d0e92613d01611f2e565b506001613cd8565b61315a565b610a8a565b90565b613d2060406127a3565b90565b5f90565b5f90565b613d33613d16565b9060208083613d40613d23565b815201613d4b613d27565b81525050565b613d59613d2b565b90565b90613d6f91613d69613d51565b50614a13565b90565b613d7a611e15565b5080613d95613d8f637965db0b60e01b610420565b91610420565b14908115613da2575b5090565b613dac9150614a3b565b5f613d9e565b613dc490613dbe613dc6565b90614a84565b565b613dce612114565b503390565b91613de19291600192614abf565b565b90565b604090613e0f613e169496959396613e0560608401985f850190610cf1565b6020830190610691565b0190610691565b565b90613e2d613e28600d8490610a58565b613de3565b91613e4b613e45613e40600f8490610e53565b610ab1565b1561046d565b8015613f54575b613f355742613e89613e83613e7e613e6c60028801610a8a565b613e7862015180612892565b906128ae565b610608565b91610608565b1015613f0e575b613eb0613e9e5f8501610a8a565b613eaa60048601610a8a565b90612054565b9082613ec4613ebe84610608565b91610608565b11613eee57505090613ee66004613eec93920191613ee183610a8a565b6128ae565b90612e7e565b565b613f0a83925f9384936340ed367b60e01b855260048501613de6565b0390fd5b613f23613f1a5f61200a565b60048501612e7e565b613f304260028501612e7e565b613e90565b613f50905f918291636585b60d60e01b835260048301610cfe565b0390fd5b50613f6a613f6460068501610ab1565b1561046d565b613e52565b80613f8a613f84613f7f5f611eb8565b6104d4565b916104d4565b14613fa657613fa491613f9c5f611eb8565b919091614bce565b565b613fc9613fb25f611eb8565b5f91829163ec442f0560e01b835260048301610cfe565b0390fd5b90613fd89103610608565b90565b929192613fe9818390613cee565b9081613ffe613ff85f19610608565b91610608565b1061400b575b5050509050565b8161401e61401887610608565b91610608565b106140445761403b9394614033919392613fcd565b905f92614abf565b805f8080614004565b50614063849291925f938493637dc7a0d960e11b855260048501613de6565b0390fd5b918261408361407d6140785f611eb8565b6104d4565b916104d4565b146140dd57816140a361409d6140985f611eb8565b6104d4565b916104d4565b146140b6576140b492919091614bce565b565b6140d96140c25f611eb8565b5f91829163ec442f0560e01b835260048301610cfe565b0390fd5b6141006140e95f611eb8565b5f918291634b637e8f60e11b835260048301610cfe565b0390fd5b90614119614114600d8490610a58565b613de3565b9161413761413161412c600f8490610e53565b610ab1565b1561046d565b8015614241575b614222574261417561416f61416a61415860038801610a8a565b61416462015180612892565b906128ae565b610608565b91610608565b10156141fb575b61419d61418b60018501610a8a565b61419760058601610a8a565b90612054565b90826141b16141ab84610608565b91610608565b116141db575050906141d360056141d9939201916141ce83610a8a565b6128ae565b90612e7e565b565b6141f783925f9384936372ff4bd160e11b855260048501613de6565b0390fd5b6142106142075f61200a565b60058501612e7e565b61421d4260038501612e7e565b61417c565b61423d905f918291636585b60d60e01b835260048301610cfe565b0390fd5b5061425761425160068501610ab1565b1561046d565b61413e565b908161427861427261426d5f611eb8565b6104d4565b916104d4565b1461429457614292919061428b5f611eb8565b9091614bce565b565b6142b76142a05f611eb8565b5f918291634b637e8f60e11b835260048301610cfe565b0390fd5b6142c3611e15565b506142d86142d28284906136eb565b1561046d565b5f146143615761430060016142fb5f6142f3600586906125ce565b018590610e53565b611fea565b90614309613dc6565b9061434661434061433a7f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d956125c2565b92610a4c565b92610a4c565b9261434f610412565b8061435981610521565b0390a4600190565b50505f90565b61436f6125be565b50614379306135bc565b6143ab6143a57f00000000000000000000000000000000000000000000000000000000000000006104d4565b916104d4565b14806143e7575b5f146143dc577f000000000000000000000000000000000000000000000000000000000000000090565b6143e4614ce9565b90565b504661441b6144157f0000000000000000000000000000000000000000000000000000000000000000610608565b91610608565b146143b2565b614429611e15565b506144358183906136eb565b5f146144bd5761445c5f6144575f61444f600586906125ce565b018590610e53565b611fea565b90614465613dc6565b906144a261449c6144967ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b956125c2565b92610a4c565b92610a4c565b926144ab610412565b806144b581610521565b0390a4600190565b50505f90565b6144d76144d26144dc926114d6565b610a21565b610608565b90565b9160206145009294936144f960408201965f830190610691565b01906114e1565b565b61450a613715565b50614513613719565b81614526614520836144c3565b91610608565b1015614539575061453690614df2565b90565b906145545f928392637669fc0f60e11b8452600484016144df565b0390fd5b5490565b90565b61457361456e6145789261455c565b610a21565b610608565b90565b90565b65ffffffffffff1690565b61459561459a91610a6e565b61457e565b90565b6145a79054614589565b90565b60301c90565b60018060d01b031690565b6145c76145cc916145aa565b6145b0565b90565b6145d990546145bb565b90565b6145f06145eb6145f59261164e565b610a21565b611c91565b90565b9061464c90614605611d80565b506146115f8401614558565b61461a5f61200a565b90808061463061462a600561455f565b91610608565b116146ad575b50906146475f86019391929361457b565b615441565b8061465f6146595f61200a565b91610608565b145f146146755750506146715f6145dc565b5b90565b6146a25f9161469d614697846146a89601926146916001612038565b90612054565b9161457b565b615437565b016145cf565b614672565b806146bb6146c192916150cc565b90612054565b90836146f36146ed6146e85f6146e2818c016146dd899161457b565b615437565b0161459d565b6114d6565b916114d6565b105f146147045750905b905f614636565b915061471a906147146001612038565b906128ae565b6146fd565b614727613715565b5061473143614df2565b90565b9061474560018060a01b0391611651565b9181191691161790565b9061476461475f61476b92610a4c565b6120a3565b8254614734565b9055565b906147f8916147f261478082612cc7565b6147958461479060098690612c90565b61474f565b828185906147d56147cf6147c97f3134e8a2e6d97e929a7e54011ea5485d7d196dd5f0ba4d4ef95803e8e3fc257f95610a4c565b92610a4c565b92610a4c565b926147de610412565b806147e881610521565b0390a492916154d0565b916154e8565b565b61482161481c6148176148269361480f613141565b50600a6129f1565b612a07565b615696565b615715565b90565b61483b90614835611f2e565b50615766565b90565b90565b614849612313565b5061487e7f0000000000000000000000000000000000000000000000000000000000000000614878600661483e565b90615881565b90565b614889612313565b506148be7f00000000000000000000000000000000000000000000000000000000000000006148b8600761483e565b90615881565b90565b6148c9611d80565b506148d55f8201614558565b806148e86148e25f61200a565b91610608565b145f146148fe5750506148fa5f6145dc565b5b90565b61492b5f916149266149208461493196019261491a6001612038565b90612054565b9161457b565b615437565b016145cf565b6148fb565b614950906149426125be565b5061494b614367565b6158cf565b90565b9261496e9261497794614964612114565b5092909192615995565b90929192615ac0565b90565b91602061499b92949361499460408201965f830190610cf1565b0190610691565b565b6149a6816149e0565b916149b96149b384610608565b91610608565b036149c2575050565b6149dc5f9283926301d4b62360e61b84526004840161497a565b0390fd5b6149f4906149ec611f2e565b50600861315a565b614a10614a0082610a8a565b91614a0a83612026565b90612e7e565b90565b90614a33614a2e614a3893614a26613d51565b50600a6129f1565b612a07565b615c22565b90565b614a43611e15565b50614a5d614a576301ffc9a760e01b610420565b91610420565b1490565b916020614a82929493614a7b60408201965f830190610cf1565b01906107d0565b565b90614a99614a938383906136eb565b1561046d565b614aa1575050565b614abb5f92839263e2517d3f60e01b845260048401614a61565b0390fd5b909281614adc614ad6614ad15f611eb8565b6104d4565b916104d4565b14614ba75783614afc614af6614af15f611eb8565b6104d4565b916104d4565b14614b8057614b2083614b1b614b1460018690613cd8565b879061315a565b612e7e565b614b2a575b505050565b919091614b75614b63614b5d7f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92593610a4c565b93610a4c565b93614b6c610412565b9182918261069e565b0390a35f8080614b25565b614ba3614b8c5f611eb8565b5f918291634a1406b160e11b835260048301610cfe565b0390fd5b614bca614bb35f611eb8565b5f91829163e602df0560e01b835260048301610cfe565b0390fd5b9182614bea614be4614bdf5f611eb8565b6104d4565b916104d4565b141580614c55575b614c05575b614c0392919091615c43565b565b614c0d613455565b80614c34575b15614bf7575f6336e278fd60e21b815280614c3060048201610521565b0390fd5b50614c50614c4a614c4361132c565b33906136eb565b1561046d565b614c13565b5081614c71614c6b614c665f611eb8565b6104d4565b916104d4565b1415614bf2565b7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f90565b90959492614ce794614cd6614ce092614ccc608096614cc260a088019c5f8901906107d0565b60208701906107d0565b60408501906107d0565b6060830190610691565b0190610cf1565b565b614cf16125be565b50614cfa614c78565b614d717f000000000000000000000000000000000000000000000000000000000000000091614d627f000000000000000000000000000000000000000000000000000000000000000046614d4d306135bc565b91614d56610412565b96879560208701614c9c565b60208201810382520382612415565b614d83614d7d826138c2565b916138bc565b2090565b90565b614d9e614d99614da392614d87565b610a21565b6108f1565b90565b614daf90614d8a565b9052565b916020614dd4929493614dcd60408201965f830190614da6565b0190610691565b565b614dea614de5614def92610608565b610a21565b6114d6565b90565b614dfa613715565b5080614e14614e0e65ffffffffffff6144c3565b91610608565b11614e2557614e2290614dd6565b90565b6030614e415f9283926306dfcc6560e41b845260048401614db3565b0390fd5b90565b614e5c614e57614e6192614e45565b610a21565b610608565b90565b90565b614e7b614e76614e8092614e64565b610a21565b6108f1565b90565b614ea290614e9c614e96614ea7946108f1565b91610608565b90610e69565b610608565b90565b90565b614ec1614ebc614ec692614eaa565b610a21565b6108f1565b90565b614ee890614ee2614edc614eed946108f1565b91610608565b90611ec4565b610608565b90565b90565b614f07614f02614f0c92614ef0565b610a21565b610608565b90565b90565b614f26614f21614f2b92614f0f565b610a21565b6108f1565b90565b90565b614f45614f40614f4a92614f2e565b610a21565b610608565b90565b90565b614f64614f5f614f6992614f4d565b610a21565b6108f1565b90565b90565b614f83614f7e614f8892614f6c565b610a21565b610608565b90565b90565b614fa2614f9d614fa792614f8b565b610a21565b6108f1565b90565b90565b614fc1614fbc614fc692614faa565b610a21565b610608565b90565b90565b614fe0614fdb614fe592614fc9565b610a21565b6108f1565b90565b614ffc614ff761500192614f4d565b610a21565b610608565b90565b90565b61501b61501661502092615004565b610a21565b6108f1565b90565b61503761503261503c92614fc9565b610a21565b610608565b90565b61505361504e61505892612035565b610a21565b6108f1565b90565b90565b61507261506d6150779261505b565b610a21565b610608565b90565b906150859102610608565b90565b634e487b7160e01b5f52601260045260245ffd5b6150a86150ae91610608565b91610608565b9081156150b9570490565b615088565b906150c99101610608565b90565b6150d4611f2e565b50806150e96150e36001612038565b91610608565b111561543457806152fe6152db6152cb6152bb6152ab61529b61528b61527b61526b61525b61524b8b61524561523e6153049f61521e61520e61522e926151306001612038565b9080615148615142600160801b614e48565b91610608565b1015615406575b8061516b61516568010000000000000000614ef3565b91610608565b10156153d8575b8061518a615184640100000000614f31565b91610608565b10156153aa575b806151a76151a162010000614f6f565b91610608565b101561537c575b806151c36151bd610100614fad565b91610608565b101561534e575b806151de6151d86010614fe8565b91610608565b1015615320575b6151f86151f26004615023565b91610608565b1015615307575b615209600361505e565b61507a565b615218600161503f565b90614e83565b615228818661509c565b906150be565b615238600161503f565b90614e83565b809261509c565b906150be565b615255600161503f565b90614e83565b615265818c61509c565b906150be565b615275600161503f565b90614e83565b615285818a61509c565b906150be565b615295600161503f565b90614e83565b6152a5818861509c565b906150be565b6152b5600161503f565b90614e83565b6152c5818661509c565b906150be565b6152d5600161503f565b90614e83565b916152f86152f26152ed85809461509c565b610608565b91610608565b11615cd3565b90613fcd565b90565b61531b90615315600161503f565b90614ec9565b6151ff565b615337615348916153316004614fcc565b90614e83565b916153426002615007565b90614ec9565b906151e5565b6153656153769161535f6008614f8e565b90614e83565b916153706004614fcc565b90614ec9565b906151ca565b6153936153a49161538d6010614f50565b90614e83565b9161539e6008614f8e565b90614ec9565b906151ae565b6153c16153d2916153bb6020614f12565b90614e83565b916153cc6010614f50565b90614ec9565b90615191565b6153ef615400916153e96040614ead565b90614e83565b916153fa6020614f12565b90614ec9565b90615172565b61541d61542e916154176080614e67565b90614e83565b916154286040614ead565b90614ec9565b9061514f565b90565b5f5260205f200190565b9391909261544d611f2e565b505b8161546261545c83610608565b91610608565b10156154c857615473828290615d1f565b906154895f615483888590615437565b0161459d565b61549b615495876114d6565b916114d6565b115f146154ab5750915b9161544f565b9291506154c2906154bc6001612038565b906128ae565b906154a5565b925050915090565b6154e2906154dc611f2e565b50613170565b90565b90565b919091806154fe6154f8856104d4565b916104d4565b14158061567c575b615510575b505050565b8061552b6155256155205f611eb8565b6104d4565b916104d4565b036155ec575b508161554d6155476155425f611eb8565b6104d4565b916104d4565b03615559575b8061550b565b6155a061559361559a9261556f600a86906129f1565b9061558d615587615581600193615db8565b93612a07565b916154e5565b90615e0b565b9290612a0a565b91612a0a565b9190916155cd7fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a72492610a4c565b926155e26155d9610412565b92839283612e38565b0390a25f80615553565b61562b615631615624615601600a85906129f1565b600261561e61561861561289615db8565b93612a07565b916154e5565b90615e0b565b9290612a0a565b91612a0a565b91909161565e7fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a72492610a4c565b9261567361566a610412565b92839283612e38565b0390a25f615531565b508161569061568a5f61200a565b91610608565b11615506565b5f6156aa916156a3611f2e565b5001614558565b90565b6156c16156bc6156c692610ee1565b610a21565b610608565b90565b6156d290614f12565b9052565b9160206156f79294936156f060408201965f8301906156c9565b0190610691565b565b61570d61570861571292610608565b610a21565b610ee1565b90565b61571d613141565b508061573561572f63ffffffff6156ad565b91610608565b1161574657615743906156f9565b90565b60206157625f9283926306dfcc6560e41b8452600484016156d6565b0390fd5b61577d61578291615775611f2e565b50600861315a565b610a8a565b90565b90565b61579c6157976157a192615785565b611651565b61078c565b90565b6157ae60ff615788565b90565b5f5260205f2090565b905f92918054906157d46157cd8361232c565b8094612356565b916001811690815f1461582b57506001146157ef575b505050565b6157fc91929394506157b1565b915f925b81841061581357505001905f80806157ea565b60018160209295939554848601520191019290615800565b92949550505060ff19168252151560200201905f80806157ea565b90615850916157ba565b90565b9061587361586c92615863610412565b93848092615846565b0383612415565b565b61587e90615853565b90565b9061588a612313565b50615894826125c2565b6158ad6158a76158a26157a4565b61078c565b9161078c565b14155f146158c257506158bf90615e95565b90565b6158cc9150615875565b90565b6042916158da6125be565b50604051917f19010000000000000000000000000000000000000000000000000000000000008352600283015260228201522090565b5f90565b61592061592591610a6e565b611eed565b90565b90565b61593f61593a61594492615928565b610a21565b610608565b90565b61597c61598394615972606094989795615968608086019a5f8701906107d0565b60208501906108f7565b60408301906107d0565b01906107d0565b565b61598d610412565b3d5f823e3d90fd5b9392936159a0612114565b506159a9615910565b506159b26125be565b506159bc85615914565b6159ee6159e87f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a061592b565b91610608565b11615a7b5790615a11602094955f94939293615a08610412565b94859485615947565b838052039060015afa15615a7657615a295f51611651565b80615a44615a3e615a395f611eb8565b6104d4565b916104d4565b14615a5a575f91615a545f611656565b91929190565b50615a645f611eb8565b600191615a705f611656565b91929190565b615985565b505050615a875f611eb8565b9060039291929190565b634e487b7160e01b5f52602160045260245ffd5b60041115615aaf57565b615a91565b90615abe82615aa5565b565b80615ad3615acd5f615ab4565b91615ab4565b145f14615ade575050565b80615af2615aec6001615ab4565b91615ab4565b145f14615b15575f63f645eedf60e01b815280615b1160048201610521565b0390fd5b80615b29615b236002615ab4565b91615ab4565b145f14615b5757615b53615b3c83615914565b5f91829163fce698f760e01b83526004830161069e565b0390fd5b615b6a615b646003615ab4565b91615ab4565b14615b725750565b615b8d905f9182916335e2f38360e21b8352600483016107dd565b0390fd5b5f5260205f2090565b615ba381614558565b821015615bbd57615bb5600191615b91565b910201905f90565b6116be565b90615bcc906114d6565b9052565b90615bda90611c91565b9052565b90615c14615c0b5f615bee613d16565b94615c05615bfd83830161459d565b838801615bc2565b016145cf565b60208401615bd0565b565b615c1f90615bde565b90565b615c40915f615c3a92615c33613d51565b5001615b9a565b50615c16565b90565b9291615c5184838391615ec5565b83615c6c615c66615c615f611eb8565b6104d4565b916104d4565b14615c81575b615c7f929391909161604f565b565b615c896124a4565b93615c92616034565b9480615ca6615ca088610608565b91610608565b11615cb357509350615c72565b8590615ccf5f928392630e58ae9360e11b845260048401612e38565b0390fd5b615cdb611f2e565b50151590565b615cf5615cf0615cfa92615004565b610a21565b610608565b90565b615d09615d0f91610608565b91610608565b908115615d1a570490565b615088565b615d44615d4a92615d2e611f2e565b508281169218615d3e6002615ce1565b90615cfd565b906128ae565b90565b90565b615d64615d5f615d6992615d4d565b610a21565b6108f1565b90565b615d7590615d50565b9052565b916020615d9a929493615d9360408201965f830190615d6c565b0190610691565b565b615db0615dab615db592610608565b610a21565b611c91565b90565b615dc0611d80565b5080615dda615dd460018060d01b03612a0a565b91610608565b11615deb57615de890615d9c565b90565b60d0615e075f9283926306dfcc6560e41b845260048401615d79565b0390fd5b90615e41615e479392615e1c611d80565b50615e25611d80565b508093615e3a615e33613719565b94926148c1565b90916164b7565b9161610e565b91909190565b615e61615e5c615e6692614f0f565b610a21565b610608565b90565b369037565b90615e93615e7b83612bd8565b92602080615e898693612bb5565b9201910390615e69565b565b615e9d612313565b50615ea781616178565b90615eba615eb56020615e4d565b615e6e565b918252602082015290565b91909180615ee3615edd615ed85f611eb8565b6104d4565b916104d4565b145f14615fc457615f07615f0083615efb6002610a8a565b6128ae565b6002612e7e565b5b82615f23615f1d615f185f611eb8565b6104d4565b916104d4565b145f14615f9857615f47615f4083615f3b6002610a8a565b613fcd565b6002612e7e565b5b919091615f93615f81615f7b7fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef93610a4c565b93610a4c565b93615f8a610412565b9182918261069e565b0390a3565b615fbf82615fb9615faa5f879061315a565b91615fb483610a8a565b6150be565b90612e7e565b615f48565b615fd7615fd25f839061315a565b610a8a565b80615fea615fe485610608565b91610608565b1061601257615ffd61600d918490613fcd565b6160085f849061315a565b612e7e565b615f08565b906160309091925f93849363391434e360e21b855260048501613de6565b0390fd5b61603c611f2e565b5061604c60018060d01b03612a0a565b90565b916160a76160a16160ae948061607561606f61606a5f611eb8565b6104d4565b916104d4565b146160df575b8461609661609061608b5f611eb8565b6104d4565b916104d4565b146160b0575b612cc7565b92612cc7565b90916154e8565b565b6160d8600b60026160d26160cc6160c689615db8565b93612a07565b916154e5565b90615e0b565b505061609c565b616107600b60016161016160fb6160f589615db8565b93612a07565b916154e5565b90615e0b565b505061607b565b916161325f6161379461611f611d80565b50616128611d80565b500192919261457b565b616369565b91909190565b61615161614c61615692615785565b610a21565b610608565b90565b90565b61617061616b61617592616159565b610a21565b610608565b90565b61618d61619291616187611f2e565b506125c2565b615914565b61619c60ff61613d565b16806161b16161ab601f61615c565b91610608565b116161b95790565b5f632cd44ac360e21b8152806161d160048201610521565b0390fd5b5490565b6161e360406127a3565b90565b5f5260205f2090565b6161f8816161d5565b8210156162125761620a6001916161e6565b910201905f90565b6116be565b61622190516114d6565b90565b9061623565ffffffffffff91611651565b9181191691161790565b61625361624e616258926114d6565b610a21565b6114d6565b90565b90565b9061627361626e61627a9261623f565b61625b565b8254616224565b9055565b6162889051611c91565b90565b60301b90565b906162a365ffffffffffff199161628b565b9181191691161790565b6162c16162bc6162c692611c91565b610a21565b611c91565b90565b90565b906162e16162dc6162e8926162ad565b6162c9565b8254616291565b9055565b9061631660205f61631c9461630e828201616308848801616217565b9061625e565b01920161627e565b906162cc565b565b919061632f5761632d916162ec565b565b611f9b565b9081549168010000000000000000831015616364578261635c916001616362950181556161ef565b9061631e565b565b612401565b90929192616375611d80565b5061637e611d80565b50616388826161d5565b8061639b6163955f61200a565b91610608565b115f1461646b576163c1906163bb84916163b56001612038565b90612054565b90615437565b906163cd5f830161459d565b926163d95f84016145cf565b93806163ed6163e7856114d6565b916114d6565b1161644f576164046163fe846114d6565b916114d6565b145f1461641f57505061641a905f8591016162cc565b5b9190565b61644a92506164458661643c6164336161d9565b945f8601615bc2565b60208401615bd0565b616334565b61641b565b5f632520601d60e01b81528061646760048201610521565b0390fd5b50616496916164918561648861647f6161d9565b945f8601615bc2565b60208401615bd0565b616334565b61649f5f6145dc565b9190565b634e487b7160e01b5f52605160045260245ffd5b919091806001146164d6576002036164a3576164d291611dff565b905b565b506164e091611dc0565b906164d456
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"a\x01\x80`@R4a\0\x84Wa\0\x1Ba\0\x15a\x01XV[\x90a\x01\x9EV[a\0#a\0\x89V[ad\xE6a\x1C\xDC\x829`\x80Q\x81aC\xBA\x01R`\xA0Q\x81aC\xF1\x01R`\xC0Q\x81aC\x81\x01R`\xE0Q\x81aL\xFF\x01Ra\x01\0Q\x81aM$\x01Ra\x01 Q\x81aHO\x01Ra\x01@Q\x81aH\x8F\x01Ra\x01`Q\x81\x81\x81a\x11T\x01Ra4\xE5\x01Rad\xE6\x90\xF3[a\0\x8FV[`@Q\x90V[_\x80\xFD[`\x1F\x80\x19\x91\x01\x16\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\0\xBB\x90a\0\x93V[\x81\x01\x90\x81\x10`\x01\x80`@\x1B\x03\x82\x11\x17a\0\xD3W`@RV[a\0\x9DV[\x90a\0\xEBa\0\xE4a\0\x89V[\x92\x83a\0\xB1V[V[_\x80\xFD[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x01\x05\x90a\0\xF1V[\x90V[a\x01\x11\x81a\0\xFCV[\x03a\x01\x18WV[_\x80\xFD[\x90PQ\x90a\x01)\x82a\x01\x08V[V[\x91\x90`@\x83\x82\x03\x12a\x01SW\x80a\x01Ga\x01P\x92_\x86\x01a\x01\x1CV[\x93` \x01a\x01\x1CV[\x90V[a\0\xEDV[a\x01va\x81\xC2\x808\x03\x80a\x01k\x81a\0\xD8V[\x92\x839\x81\x01\x90a\x01+V[\x90\x91V[\x7F\xCC\xE2\x96\xB0@3*\x08\x0Em\xF15\x15\xA3\xEC(i\xE2\x1C\xD2\x0FsD\xAF\t\x87\xDD\xB98\xD8\xBD!\x90V[a\x01\xABa\x01\xB8\x92\x82a\x01\xBBV[a\x01\xB3a\x01zV[a\t\x9AV[PV[\x90a\x01\xC5\x91a\x01\xC7V[V[\x90a\x01\xD1\x91a\x04\x16V[V[`\x01\x80`@\x1B\x03\x81\x11a\x01\xEFWa\x01\xEB` \x91a\0\x93V[\x01\x90V[a\0\x9DV[\x90a\x02\x06a\x02\x01\x83a\x01\xD3V[a\0\xD8V[\x91\x82RV[_\x7FSyndicate\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x02<`\ta\x01\xF4V[\x90a\x02I` \x83\x01a\x02\x0BV[V[a\x02Sa\x022V[\x90V[_\x7FSYND\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x02\x87`\x04a\x01\xF4V[\x90a\x02\x94` \x83\x01a\x02VV[V[a\x02\x9Ea\x02}V[\x90V[\x90V[\x90V[a\x02\xBBa\x02\xB6a\x02\xC0\x92a\x02\xA1V[a\x02\xA4V[a\0\xF1V[\x90V[a\x02\xCC\x90a\x02\xA7V[\x90V[_\x01\x90V[\x90V[\x90V[a\x02\xEEa\x02\xE9a\x02\xF3\x92a\x02\xD4V[a\x02\xA4V[a\x02\xD7V[\x90V[a\x03\x02bv\xA7\0a\x02\xDAV[\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\x03(a\x03.\x91\x93\x92\x93a\x02\xD7V[\x92a\x02\xD7V[\x82\x01\x80\x92\x11a\x039WV[a\x03\x05V[a\x03Ra\x03Ma\x03W\x92a\x02\xA1V[a\x02\xA4V[a\x02\xD7V[\x90V[_\x1B\x90V[\x90a\x03k_\x19\x91a\x03ZV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x03\x89a\x03\x84a\x03\x8E\x92a\x02\xD7V[a\x02\xA4V[a\x02\xD7V[\x90V[\x90V[\x90a\x03\xA9a\x03\xA4a\x03\xB0\x92a\x03uV[a\x03\x91V[\x82Ta\x03_V[\x90UV[\x90V[a\x03\xCBa\x03\xC6a\x03\xD0\x92a\x02\xA1V[a\x03ZV[a\x03\xB4V[\x90V[a\x03\xDC_a\x03\xB7V[\x90V[\x90V[a\x03\xF6a\x03\xF1a\x03\xFB\x92a\x03\xDFV[a\x02\xA4V[a\x02\xD7V[\x90V[a\x04\x13k\x02\xE8vi\xC3\x08sj\x04\0\0\0a\x03\xE2V[\x90V[\x90a\x048a\x04\"a\x02KV[a\x04*a\x02KV[a\x042a\x02\x96V[\x91a\x04\xFEV[\x81a\x04Sa\x04Ma\x04H_a\x02\xC3V[a\0\xFCV[\x91a\0\xFCV[\x14a\x04\xE2W\x80a\x04sa\x04ma\x04h_a\x02\xC3V[a\0\xFCV[\x91a\0\xFCV[\x14a\x04\xC6Wa\x04\xB5a\x04\xC4\x92a\x04\x91Ba\x04\x8Ba\x02\xF6V[\x90a\x03\x19V[a\x01`Ra\x04\xA8a\x04\xA1_a\x03>V[`\x0Ca\x03\x94V[a\x04\xB0a\x03\xD3V[a\t\x9AV[Pa\x04\xBEa\x03\xFEV[\x90a\nhV[V[_c\xD9.#=`\xE0\x1B\x81R\x80a\x04\xDE`\x04\x82\x01a\x02\xCFV[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a\x04\xFA`\x04\x82\x01a\x02\xCFV[\x03\x90\xFD[\x90a\x05\t\x92\x91a\x05\x0BV[V[\x90a\x05\x16\x92\x91a\x05\x18V[V[\x90a\x05#\x92\x91a\x05%V[V[\x90a\x050\x92\x91a\x052V[V[\x90a\x05=\x92\x91a\x05\x8AV[V[_\x7F1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x05p`\x01a\x01\xF4V[\x90a\x05}` \x83\x01a\x05?V[V[a\x05\x87a\x05fV[\x90V[\x90a\x05\x9E\x92\x91a\x05\x98a\x05\x7FV[\x90a\x05\xA0V[V[\x90a\x05\xAC\x93\x92\x91a\x05\xF2V[V[\x90V[\x90V[` \x01\x90V[Q\x90V[a\x05\xD2a\x05\xCDa\x05\xD7\x92a\0\xF1V[a\x02\xA4V[a\0\xF1V[\x90V[a\x05\xE3\x90a\x05\xBEV[\x90V[a\x05\xEF\x90a\x05\xDAV[\x90V[a\x06\x03a\x06S\x94a\x068\x93\x94a\x06\x87V[a\x06\x17\x81a\x06\x11`\x06a\x05\xAEV[\x90a\x0B\x15V[a\x01 Ra\x06/\x83a\x06)`\x07a\x05\xAEV[\x90a\x0B\x15V[a\x01@Ra\x05\xB1V[a\x06Ja\x06D\x82a\x05\xBAV[\x91a\x05\xB4V[ `\xE0Ra\x05\xB1V[a\x06ea\x06_\x82a\x05\xBAV[\x91a\x05\xB4V[ a\x01\0RF`\xA0Ra\x06va\x0C\x1AV[`\x80Ra\x06\x820a\x05\xE6V[`\xC0RV[\x90a\x06\x91\x91a\x06\x93V[V[\x90a\x06\x9D\x91a\x06\x9FV[V[\x90a\x06\xA9\x91a\x08\xF0V[V[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[Q\x90V[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x06\xF6W[` \x83\x10\x14a\x06\xF1WV[a\x06\xC2V[\x91`\x7F\x16\x91a\x06\xE6V[_R` _ \x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a\x072\x91\x02\x91a\x07,_\x19\x84a\x07\x13V[\x92a\x07\x13V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x91\x90a\x07Ra\x07Ma\x07Z\x93a\x03uV[a\x03\x91V[\x90\x83Ta\x07\x17V[\x90UV[_\x90V[a\x07t\x91a\x07na\x07^V[\x91a\x07<V[V[[\x81\x81\x10a\x07\x82WPPV[\x80a\x07\x8F_`\x01\x93a\x07bV[\x01a\x07wV[\x91\x90`\x1F\x81\x11a\x07\xA5W[PPPV[a\x07\xB1a\x07\xD6\x93a\x07\0V[\x90` a\x07\xBD\x84a\x07\tV[\x83\x01\x93\x10a\x07\xDEW[a\x07\xCF\x90a\x07\tV[\x01\x90a\x07vV[_\x80\x80a\x07\xA0V[\x91Pa\x07\xCF\x81\x92\x90Pa\x07\xC6V[\x1C\x90V[\x90a\x08\0\x90_\x19\x90`\x08\x02a\x07\xECV[\x19\x16\x90V[\x81a\x08\x0F\x91a\x07\xF0V[\x90`\x02\x02\x17\x90V[\x90a\x08!\x81a\x06\xBEV[\x90`\x01\x80`@\x1B\x03\x82\x11a\x08\xDFWa\x08C\x82a\x08=\x85Ta\x06\xD6V[\x85a\x07\x95V[` \x90`\x1F\x83\x11`\x01\x14a\x08wW\x91\x80\x91a\x08f\x93_\x92a\x08kW[PPa\x08\x05V[\x90U[V[\x90\x91P\x01Q_\x80a\x08_V[`\x1F\x19\x83\x16\x91a\x08\x86\x85a\x07\0V[\x92_[\x81\x81\x10a\x08\xC7WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\x08\xADW[PPP\x02\x01\x90Ua\x08iV[a\x08\xBD\x91\x01Q`\x1F\x84\x16\x90a\x07\xF0V[\x90U_\x80\x80a\x08\xA1V[\x91\x93` `\x01\x81\x92\x87\x87\x01Q\x81U\x01\x95\x01\x92\x01a\x08\x89V[a\0\x9DV[\x90a\x08\xEE\x91a\x08\x17V[V[\x90a\x08\xFFa\t\x06\x92`\x03a\x08\xE4V[`\x04a\x08\xE4V[V[_\x90V[\x15\x15\x90V[a\t\x1A\x90a\x03\xB4V[\x90V[\x90a\t'\x90a\t\x11V[_R` R`@_ \x90V[a\t<\x90a\x05\xDAV[\x90V[\x90a\tI\x90a\t3V[_R` R`@_ \x90V[\x90a\ta`\xFF\x91a\x03ZV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\tt\x90a\t\x0CV[\x90V[\x90V[\x90a\t\x8Fa\t\x8Aa\t\x96\x92a\tkV[a\twV[\x82Ta\tUV[\x90UV[a\t\xA2a\t\x08V[Pa\t\xB7a\t\xB1\x82\x84\x90a\x0C\xB7V[\x15a\t\x0CV[_\x14a\n@Wa\t\xDF`\x01a\t\xDA_a\t\xD2`\x05\x86\x90a\t\x1DV[\x01\x85\x90a\t?V[a\tzV[\x90a\t\xE8a\x0C\xE5V[\x90a\n%a\n\x1Fa\n\x19\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a\t\x11V[\x92a\t3V[\x92a\t3V[\x92a\n.a\0\x89V[\x80a\n8\x81a\x02\xCFV[\x03\x90\xA4`\x01\x90V[PP_\x90V[a\nO\x90a\0\xFCV[\x90RV[\x91\x90a\nf\x90_` \x85\x01\x94\x01\x90a\nFV[V[\x80a\n\x83a\n}a\nx_a\x02\xC3V[a\0\xFCV[\x91a\0\xFCV[\x14a\n\x9FWa\n\x9D\x91a\n\x95_a\x02\xC3V[\x91\x90\x91a\r\x16V[V[a\n\xC2a\n\xAB_a\x02\xC3V[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\nSV[\x03\x90\xFD[_\x90V[\x90V[a\n\xE1a\n\xDCa\n\xE6\x92a\n\xCAV[a\x02\xA4V[a\x02\xD7V[\x90V[\x90V[a\x0B\0a\n\xFBa\x0B\x05\x92a\n\xE9V[a\x03ZV[a\x03\xB4V[\x90V[a\x0B\x12`\xFFa\n\xECV[\x90V[\x90a\x0B\x1Ea\n\xC6V[Pa\x0B0a\x0B+\x83a\x05\xB1V[a\x05\xBAV[a\x0BCa\x0B=` a\n\xCDV[\x91a\x02\xD7V[\x10_\x14a\x0BWWPa\x0BT\x90a\x0E\xB0V[\x90V[_a\x0Bea\x0Bk\x93\x92a\r\xC0V[\x01a\x08\xE4V[a\x0B{a\x0Bva\x0B\x08V[a\t\x11V[\x90V[_\x90V[\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x90V[a\x0B\xB0\x90Qa\x03\xB4V[\x90V[a\x0B\xBC\x90a\x03\xB4V[\x90RV[a\x0B\xC9\x90a\x02\xD7V[\x90RV[\x90\x95\x94\x92a\x0C\x18\x94a\x0C\x07a\x0C\x11\x92a\x0B\xFD`\x80\x96a\x0B\xF3`\xA0\x88\x01\x9C_\x89\x01\x90a\x0B\xB3V[` \x87\x01\x90a\x0B\xB3V[`@\x85\x01\x90a\x0B\xB3V[``\x83\x01\x90a\x0B\xC0V[\x01\x90a\nFV[V[a\x0C\"a\x0B~V[Pa\x0C+a\x0B\x82V[a\x0Cua\x0C8`\xE0a\x0B\xA6V[\x91a\x0Cfa\x0CGa\x01\0a\x0B\xA6V[Fa\x0CQ0a\x05\xE6V[\x91a\x0CZa\0\x89V[\x96\x87\x95` \x87\x01a\x0B\xCDV[` \x82\x01\x81\x03\x82R\x03\x82a\0\xB1V[a\x0C\x87a\x0C\x81\x82a\x05\xBAV[\x91a\x05\xB4V[ \x90V[_\x1C\x90V[`\xFF\x16\x90V[a\x0C\xA2a\x0C\xA7\x91a\x0C\x8BV[a\x0C\x90V[\x90V[a\x0C\xB4\x90Ta\x0C\x96V[\x90V[a\x0C\xDE\x91_a\x0C\xD3a\x0C\xD9\x93a\x0C\xCBa\t\x08V[P`\x05a\t\x1DV[\x01a\t?V[a\x0C\xAAV[\x90V[_\x90V[a\x0C\xEDa\x0C\xE1V[P3\x90V[\x7F\x84\xFEt\xC7\x1A(\xB6\x9A\xA9`Hl\xA0\xE8\xC1A\x8C\x86\xE9\xEA,\xD6\xB5\x84\x9B\x95\xE2\xC8\xF4\x07\xA6t\x90V[\x91\x82a\r2a\r,a\r'_a\x02\xC3V[a\0\xFCV[\x91a\0\xFCV[\x14\x15\x80a\r\x9DW[a\rMW[a\rK\x92\x91\x90\x91a\x0F\xD4V[V[a\rUa\x0F^V[\x80a\r|W[\x15a\r?W_c6\xE2x\xFD`\xE2\x1B\x81R\x80a\rx`\x04\x82\x01a\x02\xCFV[\x03\x90\xFD[Pa\r\x98a\r\x92a\r\x8Ba\x0C\xF2V[3\x90a\x0C\xB7V[\x15a\t\x0CV[a\r[V[P\x81a\r\xB9a\r\xB3a\r\xAE_a\x02\xC3V[a\0\xFCV[\x91a\0\xFCV[\x14\x15a\r:V[\x90V[\x90V[a\r\xDAa\r\xD5a\r\xDF\x92a\r\xC3V[a\x02\xA4V[a\x02\xD7V[\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[a\x0E\x15a\x0E\x1E` \x93a\x0E#\x93a\x0E\x0C\x81a\x06\xBEV[\x93\x84\x80\x93a\r\xE2V[\x95\x86\x91\x01a\r\xEBV[a\0\x93V[\x01\x90V[a\x0E<\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\r\xF6V[\x90V[a\x0EYa\x0ETa\x0EN\x83a\x05\xBAV[\x92a\x05\xB4V[a\x0B\xA6V[\x90` \x81\x10a\x0EgW[P\x90V[a\x0Ey\x90_\x19\x90` \x03`\x08\x02a\x07\x13V[\x16_a\x0EcV[a\x0E\x8Ca\x0E\x91\x91a\x0C\x8BV[a\x03uV[\x90V[a\x0E\xA8a\x0E\xA3a\x0E\xAD\x92a\x02\xD7V[a\x03ZV[a\x03\xB4V[\x90V[a\x0E\xB8a\n\xC6V[Pa\x0E\xC2\x81a\x05\xB1V[\x90a\x0E\xCC\x82a\x05\xBAV[a\x0E\xDFa\x0E\xD9`\x1Fa\r\xC6V[\x91a\x02\xD7V[\x11a\x0F\x14WPa\x0F\x0C\x81a\x0F\x06a\x0F\0a\x0E\xFBa\x0F\x11\x95a\x0E?V[a\x0E\x80V[\x91a\x05\xBAV[\x17a\x0E\x94V[a\t\x11V[\x90V[a\x0F6\x90a\x0F a\0\x89V[\x91\x82\x91c0Z'\xA9`\xE0\x1B\x83R`\x04\x83\x01a\x0E'V[\x03\x90\xFD[\x90V[a\x0FIa\x0FN\x91a\x0C\x8BV[a\x0F:V[\x90V[a\x0F[\x90Ta\x0F=V[\x90V[a\x0Ffa\t\x08V[Pa\x0Fq`\x0Ca\x0FQV[a\x0F\x83a\x0F}_a\x03>V[\x91a\x02\xD7V[\x14\x15\x80a\x0F\x8EW[\x90V[PBa\x0F\xABa\x0F\xA5a\x0F\xA0`\x0Ca\x0FQV[a\x02\xD7V[\x91a\x02\xD7V[\x10a\x0F\x8BV[\x91` a\x0F\xD2\x92\x94\x93a\x0F\xCB`@\x82\x01\x96_\x83\x01\x90a\x0B\xC0V[\x01\x90a\x0B\xC0V[V[\x92\x91a\x0F\xE2\x84\x83\x83\x91a\x10\xDDV[\x83a\x0F\xFDa\x0F\xF7a\x0F\xF2_a\x02\xC3V[a\0\xFCV[\x91a\0\xFCV[\x14a\x10\x12W[a\x10\x10\x92\x93\x91\x90\x91a\x12\xAAV[V[a\x10\x1Aa\x12LV[\x93a\x10#a\x12\x89V[\x94\x80a\x107a\x101\x88a\x02\xD7V[\x91a\x02\xD7V[\x11a\x10DWP\x93Pa\x10\x03V[\x85\x90a\x10`_\x92\x83\x92c\x0EX\xAE\x93`\xE1\x1B\x84R`\x04\x84\x01a\x0F\xB1V[\x03\x90\xFD[\x90a\x10n\x90a\t3V[_R` R`@_ \x90V[`@\x90a\x10\xA3a\x10\xAA\x94\x96\x95\x93\x96a\x10\x99``\x84\x01\x98_\x85\x01\x90a\nFV[` \x83\x01\x90a\x0B\xC0V[\x01\x90a\x0B\xC0V[V[\x90a\x10\xB7\x91\x03a\x02\xD7V[\x90V[\x90a\x10\xC5\x91\x01a\x02\xD7V[\x90V[\x91\x90a\x10\xDB\x90_` \x85\x01\x94\x01\x90a\x0B\xC0V[V[\x91\x90\x91\x80a\x10\xFBa\x10\xF5a\x10\xF0_a\x02\xC3V[a\0\xFCV[\x91a\0\xFCV[\x14_\x14a\x11\xDCWa\x11\x1Fa\x11\x18\x83a\x11\x13`\x02a\x0FQV[a\x03\x19V[`\x02a\x03\x94V[[\x82a\x11;a\x115a\x110_a\x02\xC3V[a\0\xFCV[\x91a\0\xFCV[\x14_\x14a\x11\xB0Wa\x11_a\x11X\x83a\x11S`\x02a\x0FQV[a\x10\xACV[`\x02a\x03\x94V[[\x91\x90\x91a\x11\xABa\x11\x99a\x11\x93\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x93a\t3V[\x93a\t3V[\x93a\x11\xA2a\0\x89V[\x91\x82\x91\x82a\x10\xC8V[\x03\x90\xA3V[a\x11\xD7\x82a\x11\xD1a\x11\xC2_\x87\x90a\x10dV[\x91a\x11\xCC\x83a\x0FQV[a\x10\xBAV[\x90a\x03\x94V[a\x11`V[a\x11\xEFa\x11\xEA_\x83\x90a\x10dV[a\x0FQV[\x80a\x12\x02a\x11\xFC\x85a\x02\xD7V[\x91a\x02\xD7V[\x10a\x12*Wa\x12\x15a\x12%\x91\x84\x90a\x10\xACV[a\x12 _\x84\x90a\x10dV[a\x03\x94V[a\x11 V[\x90a\x12H\x90\x91\x92_\x93\x84\x93c9\x144\xE3`\xE2\x1B\x85R`\x04\x85\x01a\x10zV[\x03\x90\xFD[a\x12Ta\x07^V[Pa\x12_`\x02a\x0FQV[\x90V[`\x01\x80`\xD0\x1B\x03\x16\x90V[a\x12\x81a\x12|a\x12\x86\x92a\x12bV[a\x02\xA4V[a\x02\xD7V[\x90V[a\x12\x91a\x07^V[Pa\x12\xA1`\x01\x80`\xD0\x1B\x03a\x12mV[\x90V[\x90V[\x90V[\x91a\x13\x02a\x12\xFCa\x13\t\x94\x80a\x12\xD0a\x12\xCAa\x12\xC5_a\x02\xC3V[a\0\xFCV[\x91a\0\xFCV[\x14a\x13:W[\x84a\x12\xF1a\x12\xEBa\x12\xE6_a\x02\xC3V[a\0\xFCV[\x91a\0\xFCV[\x14a\x13\x0BW[a\x152V[\x92a\x152V[\x90\x91a\x15gV[V[a\x133`\x0B`\x02a\x13-a\x13'a\x13!\x89a\x14\x1CV[\x93a\x12\xA4V[\x91a\x12\xA7V[\x90a\x14oV[PPa\x12\xF7V[a\x13b`\x0B`\x01a\x13\\a\x13Va\x13P\x89a\x14\x1CV[\x93a\x12\xA4V[\x91a\x12\xA7V[\x90a\x14oV[PPa\x12\xD6V[_\x90V[a\x13ya\x13\x7F\x91a\x12bV[\x91a\x12bV[\x01\x90`\x01\x80`\xD0\x1B\x03\x82\x11a\x13\x90WV[a\x03\x05V[\x90a\x13\xA8\x91a\x13\xA2a\x13iV[Pa\x13mV[\x90V[\x90V[`\xFF\x16\x90V[a\x13\xC8a\x13\xC3a\x13\xCD\x92a\x13\xABV[a\x02\xA4V[a\x13\xAEV[\x90V[a\x13\xD9\x90a\x13\xB4V[\x90RV[\x91` a\x13\xFE\x92\x94\x93a\x13\xF7`@\x82\x01\x96_\x83\x01\x90a\x13\xD0V[\x01\x90a\x0B\xC0V[V[a\x14\x14a\x14\x0Fa\x14\x19\x92a\x02\xD7V[a\x02\xA4V[a\x12bV[\x90V[a\x14$a\x13iV[P\x80a\x14>a\x148`\x01\x80`\xD0\x1B\x03a\x12mV[\x91a\x02\xD7V[\x11a\x14OWa\x14L\x90a\x14\0V[\x90V[`\xD0a\x14k_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01a\x13\xDDV[\x03\x90\xFD[\x90a\x14\xA5a\x14\xAB\x93\x92a\x14\x80a\x13iV[Pa\x14\x89a\x13iV[P\x80\x93a\x14\x9Ea\x14\x97a\x17\x19V[\x94\x92a\x17\xC6V[\x90\x91a\x1C\xACV[\x91a\x18;V[\x91\x90\x91\x90V[a\x14\xBDa\x14\xC3\x91a\x12bV[\x91a\x12bV[\x90\x03\x90`\x01\x80`\xD0\x1B\x03\x82\x11a\x14\xD5WV[a\x03\x05V[\x90a\x14\xED\x91a\x14\xE7a\x13iV[Pa\x14\xB1V[\x90V[\x90a\x14\xFA\x90a\t3V[_R` R`@_ \x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x15\x1Da\x15\"\x91a\x0C\x8BV[a\x15\x06V[\x90V[a\x15/\x90Ta\x15\x11V[\x90V[a\x15Ia\x15N\x91a\x15Aa\x0C\xE1V[P`\ta\x14\xF0V[a\x15%V[\x90V[\x90a\x15[\x90a\t3V[_R` R`@_ \x90V[\x91\x90\x91\x80a\x15}a\x15w\x85a\0\xFCV[\x91a\0\xFCV[\x14\x15\x80a\x16\xFBW[a\x15\x8FW[PPPV[\x80a\x15\xAAa\x15\xA4a\x15\x9F_a\x02\xC3V[a\0\xFCV[\x91a\0\xFCV[\x03a\x16kW[P\x81a\x15\xCCa\x15\xC6a\x15\xC1_a\x02\xC3V[a\0\xFCV[\x91a\0\xFCV[\x03a\x15\xD8W[\x80a\x15\x8AV[a\x16\x1Fa\x16\x12a\x16\x19\x92a\x15\xEE`\n\x86\x90a\x15QV[\x90a\x16\x0Ca\x16\x06a\x16\0`\x01\x93a\x14\x1CV[\x93a\x12\xA4V[\x91a\x12\xA7V[\x90a\x14oV[\x92\x90a\x12mV[\x91a\x12mV[\x91\x90\x91a\x16L\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\t3V[\x92a\x16aa\x16Xa\0\x89V[\x92\x83\x92\x83a\x0F\xB1V[\x03\x90\xA2_\x80a\x15\xD2V[a\x16\xAAa\x16\xB0a\x16\xA3a\x16\x80`\n\x85\x90a\x15QV[`\x02a\x16\x9Da\x16\x97a\x16\x91\x89a\x14\x1CV[\x93a\x12\xA4V[\x91a\x12\xA7V[\x90a\x14oV[\x92\x90a\x12mV[\x91a\x12mV[\x91\x90\x91a\x16\xDD\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\t3V[\x92a\x16\xF2a\x16\xE9a\0\x89V[\x92\x83\x92\x83a\x0F\xB1V[\x03\x90\xA2_a\x15\xB0V[P\x81a\x17\x0Fa\x17\t_a\x03>V[\x91a\x02\xD7V[\x11a\x15\x85V[_\x90V[a\x17!a\x17\x15V[Pa\x17*a\x18jV[\x90V[T\x90V[\x90V[a\x17Ha\x17Ca\x17M\x92a\x171V[a\x02\xA4V[a\x02\xD7V[\x90V[a\x17_a\x17e\x91\x93\x92\x93a\x02\xD7V[\x92a\x02\xD7V[\x82\x03\x91\x82\x11a\x17pWV[a\x03\x05V[\x90V[`0\x1C\x90V[`\x01\x80`\xD0\x1B\x03\x16\x90V[a\x17\x95a\x17\x9A\x91a\x17xV[a\x17~V[\x90V[a\x17\xA7\x90Ta\x17\x89V[\x90V[a\x17\xBEa\x17\xB9a\x17\xC3\x92a\x02\xA1V[a\x02\xA4V[a\x12bV[\x90V[a\x17\xCEa\x13iV[Pa\x17\xDA_\x82\x01a\x17-V[\x80a\x17\xEDa\x17\xE7_a\x03>V[\x91a\x02\xD7V[\x14_\x14a\x18\x03WPPa\x17\xFF_a\x17\xAAV[[\x90V[a\x180_\x91a\x18+a\x18%\x84a\x186\x96\x01\x92a\x18\x1F`\x01a\x174V[\x90a\x17PV[\x91a\x17uV[a\x18\x7FV[\x01a\x17\x9DV[a\x18\0V[\x91a\x18__a\x18d\x94a\x18La\x13iV[Pa\x18Ua\x13iV[P\x01\x92\x91\x92a\x17uV[a\x1A\x84V[\x91\x90\x91\x90V[a\x18ra\x17\x15V[Pa\x18|Ca\x1CEV[\x90V[_R` _ \x01\x90V[T\x90V[a\x18\x97`@a\0\xD8V[\x90V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[\x90a\x18\xAF\x90a\x18\x9AV[\x90RV[\x90a\x18\xBD\x90a\x12bV[\x90RV[_R` _ \x90V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[a\x18\xE7\x81a\x18\x89V[\x82\x10\x15a\x19\x01Wa\x18\xF9`\x01\x91a\x18\xC1V[\x91\x02\x01\x90_\x90V[a\x18\xCAV[a\x19\x10\x90Qa\x18\x9AV[\x90V[\x90a\x19$e\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x03ZV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x19Ba\x19=a\x19G\x92a\x18\x9AV[a\x02\xA4V[a\x18\x9AV[\x90V[\x90V[\x90a\x19ba\x19]a\x19i\x92a\x19.V[a\x19JV[\x82Ta\x19\x13V[\x90UV[a\x19w\x90Qa\x12bV[\x90V[`0\x1B\x90V[\x90a\x19\x92e\xFF\xFF\xFF\xFF\xFF\xFF\x19\x91a\x19zV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x19\xB0a\x19\xABa\x19\xB5\x92a\x12bV[a\x02\xA4V[a\x12bV[\x90V[\x90V[\x90a\x19\xD0a\x19\xCBa\x19\xD7\x92a\x19\x9CV[a\x19\xB8V[\x82Ta\x19\x80V[\x90UV[\x90a\x1A\x05` _a\x1A\x0B\x94a\x19\xFD\x82\x82\x01a\x19\xF7\x84\x88\x01a\x19\x06V[\x90a\x19MV[\x01\x92\x01a\x19mV[\x90a\x19\xBBV[V[\x91\x90a\x1A\x1EWa\x1A\x1C\x91a\x19\xDBV[V[a\x06\xABV[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15a\x1ASW\x82a\x1AK\x91`\x01a\x1AQ\x95\x01\x81Ua\x18\xDEV[\x90a\x1A\rV[V[a\0\x9DV[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x1Aoa\x1At\x91a\x0C\x8BV[a\x1AXV[\x90V[a\x1A\x81\x90Ta\x1AcV[\x90V[\x90\x92\x91\x92a\x1A\x90a\x13iV[Pa\x1A\x99a\x13iV[Pa\x1A\xA3\x82a\x18\x89V[\x80a\x1A\xB6a\x1A\xB0_a\x03>V[\x91a\x02\xD7V[\x11_\x14a\x1B\x86Wa\x1A\xDC\x90a\x1A\xD6\x84\x91a\x1A\xD0`\x01a\x174V[\x90a\x17PV[\x90a\x18\x7FV[\x90a\x1A\xE8_\x83\x01a\x1AwV[\x92a\x1A\xF4_\x84\x01a\x17\x9DV[\x93\x80a\x1B\x08a\x1B\x02\x85a\x18\x9AV[\x91a\x18\x9AV[\x11a\x1BjWa\x1B\x1Fa\x1B\x19\x84a\x18\x9AV[\x91a\x18\x9AV[\x14_\x14a\x1B:WPPa\x1B5\x90_\x85\x91\x01a\x19\xBBV[[\x91\x90V[a\x1Be\x92Pa\x1B`\x86a\x1BWa\x1BNa\x18\x8DV[\x94_\x86\x01a\x18\xA5V[` \x84\x01a\x18\xB3V[a\x1A#V[a\x1B6V[_c% `\x1D`\xE0\x1B\x81R\x80a\x1B\x82`\x04\x82\x01a\x02\xCFV[\x03\x90\xFD[Pa\x1B\xB1\x91a\x1B\xAC\x85a\x1B\xA3a\x1B\x9Aa\x18\x8DV[\x94_\x86\x01a\x18\xA5V[` \x84\x01a\x18\xB3V[a\x1A#V[a\x1B\xBA_a\x17\xAAV[\x91\x90V[a\x1B\xD2a\x1B\xCDa\x1B\xD7\x92a\x18\x9AV[a\x02\xA4V[a\x02\xD7V[\x90V[\x90V[a\x1B\xF1a\x1B\xECa\x1B\xF6\x92a\x1B\xDAV[a\x02\xA4V[a\x13\xAEV[\x90V[a\x1C\x02\x90a\x1B\xDDV[\x90RV[\x91` a\x1C'\x92\x94\x93a\x1C `@\x82\x01\x96_\x83\x01\x90a\x1B\xF9V[\x01\x90a\x0B\xC0V[V[a\x1C=a\x1C8a\x1CB\x92a\x02\xD7V[a\x02\xA4V[a\x18\x9AV[\x90V[a\x1CMa\x17\x15V[P\x80a\x1Cga\x1Cae\xFF\xFF\xFF\xFF\xFF\xFFa\x1B\xBEV[\x91a\x02\xD7V[\x11a\x1CxWa\x1Cu\x90a\x1C)V[\x90V[`0a\x1C\x94_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01a\x1C\x06V[\x03\x90\xFD[cNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[\x91\x90\x91\x80`\x01\x14a\x1C\xCBW`\x02\x03a\x1C\x98Wa\x1C\xC7\x91a\x14\xDAV[\x90[V[Pa\x1C\xD5\x91a\x13\x95V[\x90a\x1C\xC9V\xFE`\x80`@R`\x046\x10\x15a\0\x13W[a\x1D|V[a\0\x1D_5a\x04\x0CV[\x80c\x01\xFF\xC9\xA7\x14a\x04\x07W\x80c\x04\xDF\x01}\x14a\x04\x02W\x80c\x06\xFD\xDE\x03\x14a\x03\xFDW\x80c\t^\xA7\xB3\x14a\x03\xF8W\x80c\x18\x16\r\xDD\x14a\x03\xF3W\x80c\x18\xBFPw\x14a\x03\xEEW\x80c#\xB8r\xDD\x14a\x03\xE9W\x80c$\x8A\x9C\xA3\x14a\x03\xE4W\x80c+\x8CI\xE3\x14a\x03\xDFW\x80c//\xF1]\x14a\x03\xDAW\x80c0\xD3\xE8\xEB\x14a\x03\xD5W\x80c1<\xE5g\x14a\x03\xD0W\x80c6D\xE5\x15\x14a\x03\xCBW\x80c6V\x8A\xBE\x14a\x03\xC6W\x80c:F\xB1\xA8\x14a\x03\xC1W\x80c@\xC1\x0F\x19\x14a\x03\xBCW\x80cBz\xC0\xCA\x14a\x03\xB7W\x80cB\x96lh\x14a\x03\xB2W\x80cK\xDD6\xCE\x14a\x03\xADW\x80cK\xF5\xD7\xE9\x14a\x03\xA8W\x80cO\x1B\xFC\x9E\x14a\x03\xA3W\x80cX|\xDE\x1E\x14a\x03\x9EW\x80cZ]\xB1\xBB\x14a\x03\x99W\x80c\\\x19\xA9\\\x14a\x03\x94W\x80cc\xA0\xDA\xAC\x14a\x03\x8FW\x80ce\x14U4\x14a\x03\x8AW\x80cj\x96\xE3\xED\x14a\x03\x85W\x80co\xCF\xFFE\x14a\x03\x80W\x80cp\xA0\x821\x14a\x03{W\x80cr\xCB\xDC\xC8\x14a\x03vW\x80cx\xFB\x7F\xD2\x14a\x03qW\x80cy\xCCg\x90\x14a\x03lW\x80cz\x8C\xD1V\x14a\x03gW\x80c~\xCE\xBE\0\x14a\x03bW\x80c\x83\xF1!\x1B\x14a\x03]W\x80c\x84&\xAD\xF2\x14a\x03XW\x80c\x84L\x90&\x14a\x03SW\x80c\x84\xB0\x19n\x14a\x03NW\x80c\x8AT%!\x14a\x03IW\x80c\x8D3C\xD6\x14a\x03DW\x80c\x8ES\x9E\x8C\x14a\x03?W\x80c\x90-U\xA5\x14a\x03:W\x80c\x91\xD1HT\x14a\x035W\x80c\x91\xDD\xAD\xF4\x14a\x030W\x80c\x94\xAA\"\xF2\x14a\x03+W\x80c\x95\xD8\x9BA\x14a\x03&W\x80c\x9A\xB2N\xB0\x14a\x03!W\x80c\x9B~\xF6K\x14a\x03\x1CW\x80c\xA2\x17\xFD\xDF\x14a\x03\x17W\x80c\xA3\xC4G\x05\x14a\x03\x12W\x80c\xA9\x05\x9C\xBB\x14a\x03\rW\x80c\xAA\x08*\x9D\x14a\x03\x08W\x80c\xB0\xCA%>\x14a\x03\x03W\x80c\xBBMD6\x14a\x02\xFEW\x80c\xC0*\xE7T\x14a\x02\xF9W\x80c\xC3\xCD\xA5 \x14a\x02\xF4W\x80c\xC4\xFCE\xA8\x14a\x02\xEFW\x80c\xC9\xAB\0\x06\x14a\x02\xEAW\x80c\xD5\x05\xAC\xCF\x14a\x02\xE5W\x80c\xD5Gt\x1F\x14a\x02\xE0W\x80c\xDDb\xED>\x14a\x02\xDBW\x80c\xF1\x12~\xD8\x14a\x02\xD6Wc\xF7^\x85\x12\x03a\0\x0EWa\x1DGV[a\x1C\xE2V[a\x1B\xFEV[a\x1B\x9DV[a\x1BcV[a\x1A\xBFV[a\x1A:V[a\x19`V[a\x18\xA4V[a\x18oV[a\x189V[a\x18\x04V[a\x17\x99V[a\x17dV[a\x16\x89V[a\x16\x19V[a\x15\xA2V[a\x15mV[a\x158V[a\x15\x03V[a\x14\xA0V[a\x14kV[a\x13\xF4V[a\x13\xBFV[a\x13[V[a\x12\xF0V[a\x11\xABV[a\x11vV[a\x11\x1DV[a\x10\xE8V[a\x10\xB3V[a\x10\x7FV[a\x10JV[a\x10\x15V[a\x0FAV[a\x0F\x0CV[a\x0E\xACV[a\x0E\x1EV[a\r\xEAV[a\r}V[a\rHV[a\r\x13V[a\x0C\xBCV[a\x0CNV[a\x0C\x19V[a\x0B\xE6V[a\x0B\x8CV[a\t\xEDV[a\t\xB7V[a\t\x83V[a\tNV[a\t\x19V[a\x08\xBCV[a\x08\x88V[a\x08'V[a\x07\xF2V[a\x07VV[a\x06\xE8V[a\x06\xB3V[a\x06[V[a\x05\xD3V[a\x05&V[a\x04\x94V[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[c\xFF\xFF\xFF\xFF`\xE0\x1B\x16\x90V[a\x045\x81a\x04 V[\x03a\x04<WV[_\x80\xFD[\x90P5\x90a\x04M\x82a\x04,V[V[\x90` \x82\x82\x03\x12a\x04hWa\x04e\x91_\x01a\x04@V[\x90V[a\x04\x1CV[\x15\x15\x90V[a\x04{\x90a\x04mV[\x90RV[\x91\x90a\x04\x92\x90_` \x85\x01\x94\x01\x90a\x04rV[V[4a\x04\xC4Wa\x04\xC0a\x04\xAFa\x04\xAA6`\x04a\x04OV[a\x1E\x19V[a\x04\xB7a\x04\x12V[\x91\x82\x91\x82a\x04\x7FV[\x03\x90\xF3[a\x04\x18V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x04\xDD\x90a\x04\xC9V[\x90V[a\x04\xE9\x81a\x04\xD4V[\x03a\x04\xF0WV[_\x80\xFD[\x90P5\x90a\x05\x01\x82a\x04\xE0V[V[\x90` \x82\x82\x03\x12a\x05\x1CWa\x05\x19\x91_\x01a\x04\xF4V[\x90V[a\x04\x1CV[_\x01\x90V[4a\x05TWa\x05>a\x0596`\x04a\x05\x03V[a#\x08V[a\x05Fa\x04\x12V[\x80a\x05P\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[_\x91\x03\x12a\x05cWV[a\x04\x1CV[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[`\x1F\x80\x19\x91\x01\x16\x90V[a\x05\xA9a\x05\xB2` \x93a\x05\xB7\x93a\x05\xA0\x81a\x05hV[\x93\x84\x80\x93a\x05lV[\x95\x86\x91\x01a\x05uV[a\x05\x80V[\x01\x90V[a\x05\xD0\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x05\x8AV[\x90V[4a\x06\x03Wa\x05\xE36`\x04a\x05YV[a\x05\xFFa\x05\xEEa$lV[a\x05\xF6a\x04\x12V[\x91\x82\x91\x82a\x05\xBBV[\x03\x90\xF3[a\x04\x18V[\x90V[a\x06\x14\x81a\x06\x08V[\x03a\x06\x1BWV[_\x80\xFD[\x90P5\x90a\x06,\x82a\x06\x0BV[V[\x91\x90`@\x83\x82\x03\x12a\x06VW\x80a\x06Ja\x06S\x92_\x86\x01a\x04\xF4V[\x93` \x01a\x06\x1FV[\x90V[a\x04\x1CV[4a\x06\x8CWa\x06\x88a\x06wa\x06q6`\x04a\x06.V[\x90a$\x82V[a\x06\x7Fa\x04\x12V[\x91\x82\x91\x82a\x04\x7FV[\x03\x90\xF3[a\x04\x18V[a\x06\x9A\x90a\x06\x08V[\x90RV[\x91\x90a\x06\xB1\x90_` \x85\x01\x94\x01\x90a\x06\x91V[V[4a\x06\xE3Wa\x06\xC36`\x04a\x05YV[a\x06\xDFa\x06\xCEa$\xA4V[a\x06\xD6a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[4a\x07\x17Wa\x07\x01a\x06\xFB6`\x04a\x06.V[\x90a$\xBAV[a\x07\ta\x04\x12V[\x80a\x07\x13\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[\x90\x91``\x82\x84\x03\x12a\x07QWa\x07Na\x077\x84_\x85\x01a\x04\xF4V[\x93a\x07E\x81` \x86\x01a\x04\xF4V[\x93`@\x01a\x06\x1FV[\x90V[a\x04\x1CV[4a\x07\x87Wa\x07\x83a\x07ra\x07l6`\x04a\x07\x1CV[\x91a%\x8FV[a\x07za\x04\x12V[\x91\x82\x91\x82a\x04\x7FV[\x03\x90\xF3[a\x04\x18V[\x90V[a\x07\x98\x81a\x07\x8CV[\x03a\x07\x9FWV[_\x80\xFD[\x90P5\x90a\x07\xB0\x82a\x07\x8FV[V[\x90` \x82\x82\x03\x12a\x07\xCBWa\x07\xC8\x91_\x01a\x07\xA3V[\x90V[a\x04\x1CV[a\x07\xD9\x90a\x07\x8CV[\x90RV[\x91\x90a\x07\xF0\x90_` \x85\x01\x94\x01\x90a\x07\xD0V[V[4a\x08\"Wa\x08\x1Ea\x08\ra\x08\x086`\x04a\x07\xB2V[a&\x08V[a\x08\x15a\x04\x12V[\x91\x82\x91\x82a\x07\xDDV[\x03\x90\xF3[a\x04\x18V[4a\x08VWa\x08@a\x08:6`\x04a\x06.V[\x90a&*V[a\x08Ha\x04\x12V[\x80a\x08R\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[\x91\x90`@\x83\x82\x03\x12a\x08\x83W\x80a\x08wa\x08\x80\x92_\x86\x01a\x07\xA3V[\x93` \x01a\x04\xF4V[\x90V[a\x04\x1CV[4a\x08\xB7Wa\x08\xA1a\x08\x9B6`\x04a\x08[V[\x90a'{V[a\x08\xA9a\x04\x12V[\x80a\x08\xB3\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[4a\x08\xECWa\x08\xE8a\x08\xD7a\x08\xD26`\x04a\x05\x03V[a(\xD3V[a\x08\xDFa\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[`\xFF\x16\x90V[a\t\0\x90a\x08\xF1V[\x90RV[\x91\x90a\t\x17\x90_` \x85\x01\x94\x01\x90a\x08\xF7V[V[4a\tIWa\t)6`\x04a\x05YV[a\tEa\t4a)\x7FV[a\t<a\x04\x12V[\x91\x82\x91\x82a\t\x04V[\x03\x90\xF3[a\x04\x18V[4a\t~Wa\t^6`\x04a\x05YV[a\tza\tia)\x95V[a\tqa\x04\x12V[\x91\x82\x91\x82a\x07\xDDV[\x03\x90\xF3[a\x04\x18V[4a\t\xB2Wa\t\x9Ca\t\x966`\x04a\x08[V[\x90a)\xA9V[a\t\xA4a\x04\x12V[\x80a\t\xAE\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[4a\t\xE8Wa\t\xE4a\t\xD3a\t\xCD6`\x04a\x06.V[\x90a*&V[a\t\xDBa\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[4a\n\x1CWa\n\x06a\n\x006`\x04a\x06.V[\x90a+DV[a\n\x0Ea\x04\x12V[\x80a\n\x18\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[\x90V[a\n8a\n3a\n=\x92a\x04\xC9V[a\n!V[a\x04\xC9V[\x90V[a\nI\x90a\n$V[\x90V[a\nU\x90a\n@V[\x90V[\x90a\nb\x90a\nLV[_R` R`@_ \x90V[_\x1C\x90V[\x90V[a\n\x82a\n\x87\x91a\nnV[a\nsV[\x90V[a\n\x94\x90Ta\nvV[\x90V[`\xFF\x16\x90V[a\n\xA9a\n\xAE\x91a\nnV[a\n\x97V[\x90V[a\n\xBB\x90Ta\n\x9DV[\x90V[a\n\xC9\x90`\ra\nXV[a\n\xD4_\x82\x01a\n\x8AV[\x91a\n\xE1`\x01\x83\x01a\n\x8AV[\x91a\n\xEE`\x02\x82\x01a\n\x8AV[\x91a\n\xFB`\x03\x83\x01a\n\x8AV[\x91a\x0B\x08`\x04\x82\x01a\n\x8AV[\x91a\x0B!`\x06a\x0B\x1A`\x05\x85\x01a\n\x8AV[\x93\x01a\n\xB1V[\x90V[\x94\x92\x90\x97\x96\x95\x93\x91`\xE0\x86\x01\x98_\x87\x01a\x0B=\x91a\x06\x91V[` \x86\x01a\x0BJ\x91a\x06\x91V[`@\x85\x01a\x0BW\x91a\x06\x91V[``\x84\x01a\x0Bd\x91a\x06\x91V[`\x80\x83\x01a\x0Bq\x91a\x06\x91V[`\xA0\x82\x01a\x0B~\x91a\x06\x91V[`\xC0\x01a\x0B\x8A\x91a\x04rV[V[4a\x0B\xC3Wa\x0B\xBFa\x0B\xA7a\x0B\xA26`\x04a\x05\x03V[a\n\xBEV[\x93a\x0B\xB6\x97\x95\x97\x93\x91\x93a\x04\x12V[\x97\x88\x97\x88a\x0B$V[\x03\x90\xF3[a\x04\x18V[\x90` \x82\x82\x03\x12a\x0B\xE1Wa\x0B\xDE\x91_\x01a\x06\x1FV[\x90V[a\x04\x1CV[4a\x0C\x14Wa\x0B\xFEa\x0B\xF96`\x04a\x0B\xC8V[a+PV[a\x0C\x06a\x04\x12V[\x80a\x0C\x10\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[4a\x0CIWa\x0C)6`\x04a\x05YV[a\x0CEa\x0C4a+\x90V[a\x0C<a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[4a\x0C~Wa\x0C^6`\x04a\x05YV[a\x0Cza\x0Cia,:V[a\x0Cqa\x04\x12V[\x91\x82\x91\x82a\x05\xBBV[\x03\x90\xF3[a\x04\x18V[\x90V[a\x0C\x9Aa\x0C\x95a\x0C\x9F\x92a\x0C\x83V[a\n!V[a\x06\x08V[\x90V[a\x0C\xAEbv\xA7\0a\x0C\x86V[\x90V[a\x0C\xB9a\x0C\xA2V[\x90V[4a\x0C\xECWa\x0C\xCC6`\x04a\x05YV[a\x0C\xE8a\x0C\xD7a\x0C\xB1V[a\x0C\xDFa\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[a\x0C\xFA\x90a\x04\xD4V[\x90RV[\x91\x90a\r\x11\x90_` \x85\x01\x94\x01\x90a\x0C\xF1V[V[4a\rCWa\r?a\r.a\r)6`\x04a\x05\x03V[a,\xC7V[a\r6a\x04\x12V[\x91\x82\x91\x82a\x0C\xFEV[\x03\x90\xF3[a\x04\x18V[4a\rxWa\rta\rca\r^6`\x04a\x0B\xC8V[a-\x8EV[a\rka\x04\x12V[\x91\x82\x91\x82a\x0C\xFEV[\x03\x90\xF3[a\x04\x18V[4a\r\xABWa\r\x95a\r\x906`\x04a\x05\x03V[a-\xD3V[a\r\x9Da\x04\x12V[\x80a\r\xA7\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[\x90\x91``\x82\x84\x03\x12a\r\xE5Wa\r\xE2a\r\xCB\x84_\x85\x01a\x04\xF4V[\x93a\r\xD9\x81` \x86\x01a\x06\x1FV[\x93`@\x01a\x06\x1FV[\x90V[a\x04\x1CV[4a\x0E\x19Wa\x0E\x03a\r\xFD6`\x04a\r\xB0V[\x91a1\x1EV[a\x0E\x0Ba\x04\x12V[\x80a\x0E\x15\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[4a\x0ENWa\x0E.6`\x04a\x05YV[a\x0EJa\x0E9a1+V[a\x0EAa\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[\x90a\x0E]\x90a\nLV[_R` R`@_ \x90V[\x1C\x90V[a\x0E}\x90`\x08a\x0E\x82\x93\x02a\x0EiV[a\n\x97V[\x90V[\x90a\x0E\x90\x91Ta\x0EmV[\x90V[a\x0E\xA9\x90a\x0E\xA4`\x0F\x91_\x92a\x0ESV[a\x0E\x85V[\x90V[4a\x0E\xDCWa\x0E\xD8a\x0E\xC7a\x0E\xC26`\x04a\x05\x03V[a\x0E\x93V[a\x0E\xCFa\x04\x12V[\x91\x82\x91\x82a\x04\x7FV[\x03\x90\xF3[a\x04\x18V[c\xFF\xFF\xFF\xFF\x16\x90V[a\x0E\xF3\x90a\x0E\xE1V[\x90RV[\x91\x90a\x0F\n\x90_` \x85\x01\x94\x01\x90a\x0E\xEAV[V[4a\x0F<Wa\x0F8a\x0F'a\x0F\"6`\x04a\x05\x03V[a1EV[a\x0F/a\x04\x12V[\x91\x82\x91\x82a\x0E\xF7V[\x03\x90\xF3[a\x04\x18V[4a\x0FqWa\x0Fma\x0F\\a\x0FW6`\x04a\x05\x03V[a1pV[a\x0Fda\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[Q\x90V[` \x91\x81R\x01\x90V[` \x01\x90V[a\x0F\x92\x90a\x04\xD4V[\x90RV[\x90a\x0F\xA3\x81` \x93a\x0F\x89V[\x01\x90V[` \x01\x90V[\x90a\x0F\xCAa\x0F\xC4a\x0F\xBD\x84a\x0FvV[\x80\x93a\x0FzV[\x92a\x0F\x83V[\x90_[\x81\x81\x10a\x0F\xDAWPPP\x90V[\x90\x91\x92a\x0F\xF3a\x0F\xED`\x01\x92\x86Qa\x0F\x96V[\x94a\x0F\xA7V[\x91\x01\x91\x90\x91a\x0F\xCDV[a\x10\x12\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x0F\xADV[\x90V[4a\x10EWa\x10%6`\x04a\x05YV[a\x10Aa\x100a2AV[a\x108a\x04\x12V[\x91\x82\x91\x82a\x0F\xFDV[\x03\x90\xF3[a\x04\x18V[4a\x10zWa\x10va\x10ea\x10`6`\x04a\x05\x03V[a2WV[a\x10ma\x04\x12V[\x91\x82\x91\x82a\x04\x7FV[\x03\x90\xF3[a\x04\x18V[4a\x10\xAEWa\x10\x98a\x10\x926`\x04a\x06.V[\x90a3\xBCV[a\x10\xA0a\x04\x12V[\x80a\x10\xAA\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[4a\x10\xE3Wa\x10\xC36`\x04a\x05YV[a\x10\xDFa\x10\xCEa3\xC8V[a\x10\xD6a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[4a\x11\x18Wa\x11\x14a\x11\x03a\x10\xFE6`\x04a\x05\x03V[a4@V[a\x11\x0Ba\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[4a\x11MWa\x11-6`\x04a\x05YV[a\x11Ia\x118a4UV[a\x11@a\x04\x12V[\x91\x82\x91\x82a\x04\x7FV[\x03\x90\xF3[a\x04\x18V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[4a\x11\xA6Wa\x11\x866`\x04a\x05YV[a\x11\xA2a\x11\x91a\x11RV[a\x11\x99a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[4a\x11\xD9Wa\x11\xC3a\x11\xBE6`\x04a\x0B\xC8V[a5\xA8V[a\x11\xCBa\x04\x12V[\x80a\x11\xD5\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[`\xFF`\xF8\x1B\x16\x90V[a\x11\xF0\x90a\x11\xDEV[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[` \x01\x90V[a\x12\x10\x90a\x06\x08V[\x90RV[\x90a\x12!\x81` \x93a\x12\x07V[\x01\x90V[` \x01\x90V[\x90a\x12Ha\x12Ba\x12;\x84a\x11\xF4V[\x80\x93a\x11\xF8V[\x92a\x12\x01V[\x90_[\x81\x81\x10a\x12XWPPP\x90V[\x90\x91\x92a\x12qa\x12k`\x01\x92\x86Qa\x12\x14V[\x94a\x12%V[\x91\x01\x91\x90\x91a\x12KV[\x93\x95\x91\x94a\x12\xCCa\x12\xC1a\x12\xE0\x95a\x12\xB3a\x12\xD6\x95a\x12\xED\x9C\x9Aa\x12\xA6`\xE0\x8C\x01\x92_\x8D\x01\x90a\x11\xE7V[\x8A\x82\x03` \x8C\x01Ra\x05\x8AV[\x90\x88\x82\x03`@\x8A\x01Ra\x05\x8AV[\x97``\x87\x01\x90a\x06\x91V[`\x80\x85\x01\x90a\x0C\xF1V[`\xA0\x83\x01\x90a\x07\xD0V[`\xC0\x81\x84\x03\x91\x01Ra\x12+V[\x90V[4a\x13'Wa\x13\x006`\x04a\x05YV[a\x13#a\x13\x0Ba60V[\x93a\x13\x1A\x97\x95\x97\x93\x91\x93a\x04\x12V[\x97\x88\x97\x88a\x12{V[\x03\x90\xF3[a\x04\x18V[\x7F\x84\xFEt\xC7\x1A(\xB6\x9A\xA9`Hl\xA0\xE8\xC1A\x8C\x86\xE9\xEA,\xD6\xB5\x84\x9B\x95\xE2\xC8\xF4\x07\xA6t\x90V[a\x13Xa\x13,V[\x90V[4a\x13\x8BWa\x13k6`\x04a\x05YV[a\x13\x87a\x13va\x13PV[a\x13~a\x04\x12V[\x91\x82\x91\x82a\x07\xDDV[\x03\x90\xF3[a\x04\x18V[\x7F\x9B\x12\xE0\xC5p~II\x15\xE5\x8B\x05d\xF1\x8A\xAA\xD9\xB7J\xC6\x9B\xFC\x81Z\x1E\xDA\xDC\x8EK\xD02\xEB\x90V[a\x13\xBCa\x13\x90V[\x90V[4a\x13\xEFWa\x13\xCF6`\x04a\x05YV[a\x13\xEBa\x13\xDAa\x13\xB4V[a\x13\xE2a\x04\x12V[\x91\x82\x91\x82a\x07\xDDV[\x03\x90\xF3[a\x04\x18V[4a\x14$Wa\x14 a\x14\x0Fa\x14\n6`\x04a\x0B\xC8V[a6\xBAV[a\x14\x17a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[\x90V[a\x14@a\x14;a\x14E\x92a\x14)V[a\n!V[a\x06\x08V[\x90V[a\x14]k\x03;.<\x9F\xD0\x80<\xE8\0\0\0a\x14,V[\x90V[a\x14ha\x14HV[\x90V[4a\x14\x9BWa\x14{6`\x04a\x05YV[a\x14\x97a\x14\x86a\x14`V[a\x14\x8Ea\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[4a\x14\xD1Wa\x14\xCDa\x14\xBCa\x14\xB66`\x04a\x08[V[\x90a6\xEBV[a\x14\xC4a\x04\x12V[\x91\x82\x91\x82a\x04\x7FV[\x03\x90\xF3[a\x04\x18V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x14\xEA\x90a\x14\xD6V[\x90RV[\x91\x90a\x15\x01\x90_` \x85\x01\x94\x01\x90a\x14\xE1V[V[4a\x153Wa\x15\x136`\x04a\x05YV[a\x15/a\x15\x1Ea7\x19V[a\x15&a\x04\x12V[\x91\x82\x91\x82a\x14\xEEV[\x03\x90\xF3[a\x04\x18V[4a\x15hWa\x15da\x15Sa\x15N6`\x04a\x05\x03V[a7-V[a\x15[a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[4a\x15\x9DWa\x15}6`\x04a\x05YV[a\x15\x99a\x15\x88a7\xB4V[a\x15\x90a\x04\x12V[\x91\x82\x91\x82a\x05\xBBV[\x03\x90\xF3[a\x04\x18V[4a\x15\xD2Wa\x15\xCEa\x15\xBDa\x15\xB86`\x04a\x05\x03V[a7\xCAV[a\x15\xC5a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[\x90V[a\x15\xEEa\x15\xE9a\x15\xF3\x92a\x15\xD7V[a\n!V[a\x06\x08V[\x90V[a\x16\x0Bk\x02\xE8vi\xC3\x08sj\x04\0\0\0a\x15\xDAV[\x90V[a\x16\x16a\x15\xF6V[\x90V[4a\x16IWa\x16)6`\x04a\x05YV[a\x16Ea\x164a\x16\x0EV[a\x16<a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[\x90V[_\x1B\x90V[a\x16ja\x16ea\x16o\x92a\x16NV[a\x16QV[a\x07\x8CV[\x90V[a\x16{_a\x16VV[\x90V[a\x16\x86a\x16rV[\x90V[4a\x16\xB9Wa\x16\x996`\x04a\x05YV[a\x16\xB5a\x16\xA4a\x16~V[a\x16\xACa\x04\x12V[\x91\x82\x91\x82a\x07\xDDV[\x03\x90\xF3[a\x04\x18V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[T\x90V[_R` _ \x90V[a\x16\xE8\x81a\x16\xD2V[\x82\x10\x15a\x17\x02Wa\x16\xFA`\x01\x91a\x16\xD6V[\x91\x02\x01\x90_\x90V[a\x16\xBEV[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x17\"\x90`\x08a\x17'\x93\x02a\x0EiV[a\x17\x07V[\x90V[\x90a\x175\x91Ta\x17\x12V[\x90V[`\x0Ea\x17C\x81a\x16\xD2V[\x82\x10\x15a\x17`Wa\x17]\x91a\x17W\x91a\x16\xDFV[\x90a\x17*V[\x90V[_\x80\xFD[4a\x17\x94Wa\x17\x90a\x17\x7Fa\x17z6`\x04a\x0B\xC8V[a\x178V[a\x17\x87a\x04\x12V[\x91\x82\x91\x82a\x0C\xFEV[\x03\x90\xF3[a\x04\x18V[4a\x17\xCAWa\x17\xC6a\x17\xB5a\x17\xAF6`\x04a\x06.V[\x90a7\xF9V[a\x17\xBDa\x04\x12V[\x91\x82\x91\x82a\x04\x7FV[\x03\x90\xF3[a\x04\x18V[a\x17\xDF\x90`\x08a\x17\xE4\x93\x02a\x0EiV[a\nsV[\x90V[\x90a\x17\xF2\x91Ta\x17\xCFV[\x90V[a\x18\x01`\x0C_\x90a\x17\xE7V[\x90V[4a\x184Wa\x18\x146`\x04a\x05YV[a\x180a\x18\x1Fa\x17\xF5V[a\x18'a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[4a\x18jWa\x18fa\x18Ua\x18O6`\x04a\x06.V[\x90a8\x1BV[a\x18]a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[4a\x18\x9FWa\x18\x9Ba\x18\x8Aa\x18\x856`\x04a\x05\x03V[a81V[a\x18\x92a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[4a\x18\xD4Wa\x18\xB46`\x04a\x05YV[a\x18\xD0a\x18\xBFa8FV[a\x18\xC7a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[a\x18\xE2\x81a\x08\xF1V[\x03a\x18\xE9WV[_\x80\xFD[\x90P5\x90a\x18\xFA\x82a\x18\xD9V[V[\x90\x91`\xC0\x82\x84\x03\x12a\x19[Wa\x19\x14\x83_\x84\x01a\x04\xF4V[\x92a\x19\"\x81` \x85\x01a\x06\x1FV[\x92a\x190\x82`@\x83\x01a\x06\x1FV[\x92a\x19Xa\x19A\x84``\x85\x01a\x18\xEDV[\x93a\x19O\x81`\x80\x86\x01a\x07\xA3V[\x93`\xA0\x01a\x07\xA3V[\x90V[a\x04\x1CV[4a\x19\x95Wa\x19\x7Fa\x19s6`\x04a\x18\xFCV[\x94\x93\x90\x93\x92\x91\x92a8\xC6V[a\x19\x87a\x04\x12V[\x80a\x19\x91\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[a\x19\xA3\x90a\x04mV[\x90RV[\x90`\xC0\x80a\x1A#\x93a\x19\xBF_\x82\x01Q_\x86\x01\x90a\x12\x07V[a\x19\xD1` \x82\x01Q` \x86\x01\x90a\x12\x07V[a\x19\xE3`@\x82\x01Q`@\x86\x01\x90a\x12\x07V[a\x19\xF5``\x82\x01Q``\x86\x01\x90a\x12\x07V[a\x1A\x07`\x80\x82\x01Q`\x80\x86\x01\x90a\x12\x07V[a\x1A\x19`\xA0\x82\x01Q`\xA0\x86\x01\x90a\x12\x07V[\x01Q\x91\x01\x90a\x19\x9AV[V[\x91\x90a\x1A8\x90_`\xE0\x85\x01\x94\x01\x90a\x19\xA7V[V[4a\x1AjWa\x1Afa\x1AUa\x1AP6`\x04a\x05\x03V[a9\xEDV[a\x1A]a\x04\x12V[\x91\x82\x91\x82a\x1A%V[\x03\x90\xF3[a\x04\x18V[a\x1Ax\x81a\x04mV[\x03a\x1A\x7FWV[_\x80\xFD[\x90P5\x90a\x1A\x90\x82a\x1AoV[V[\x91\x90`@\x83\x82\x03\x12a\x1A\xBAW\x80a\x1A\xAEa\x1A\xB7\x92_\x86\x01a\x04\xF4V[\x93` \x01a\x1A\x83V[\x90V[a\x04\x1CV[4a\x1A\xEEWa\x1A\xD8a\x1A\xD26`\x04a\x1A\x92V[\x90a;\0V[a\x1A\xE0a\x04\x12V[\x80a\x1A\xEA\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[`\xE0\x81\x83\x03\x12a\x1B^Wa\x1B\t\x82_\x83\x01a\x04\xF4V[\x92a\x1B\x17\x83` \x84\x01a\x04\xF4V[\x92a\x1B%\x81`@\x85\x01a\x06\x1FV[\x92a\x1B3\x82``\x83\x01a\x06\x1FV[\x92a\x1B[a\x1BD\x84`\x80\x85\x01a\x18\xEDV[\x93a\x1BR\x81`\xA0\x86\x01a\x07\xA3V[\x93`\xC0\x01a\x07\xA3V[\x90V[a\x04\x1CV[4a\x1B\x98Wa\x1B\x82a\x1Bv6`\x04a\x1A\xF3V[\x95\x94\x90\x94\x93\x91\x93a;\xAEV[a\x1B\x8Aa\x04\x12V[\x80a\x1B\x94\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[4a\x1B\xCCWa\x1B\xB6a\x1B\xB06`\x04a\x08[V[\x90a<\xCCV[a\x1B\xBEa\x04\x12V[\x80a\x1B\xC8\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[\x91\x90`@\x83\x82\x03\x12a\x1B\xF9W\x80a\x1B\xEDa\x1B\xF6\x92_\x86\x01a\x04\xF4V[\x93` \x01a\x04\xF4V[\x90V[a\x04\x1CV[4a\x1C/Wa\x1C+a\x1C\x1Aa\x1C\x146`\x04a\x1B\xD1V[\x90a<\xEEV[a\x1C\"a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[a\x1C=\x81a\x0E\xE1V[\x03a\x1CDWV[_\x80\xFD[\x90P5\x90a\x1CU\x82a\x1C4V[V[\x91\x90`@\x83\x82\x03\x12a\x1C\x7FW\x80a\x1Csa\x1C|\x92_\x86\x01a\x04\xF4V[\x93` \x01a\x1CHV[\x90V[a\x04\x1CV[a\x1C\x8D\x90a\x14\xD6V[\x90RV[`\x01\x80`\xD0\x1B\x03\x16\x90V[a\x1C\xA5\x90a\x1C\x91V[\x90RV[\x90` \x80a\x1C\xCB\x93a\x1C\xC1_\x82\x01Q_\x86\x01\x90a\x1C\x84V[\x01Q\x91\x01\x90a\x1C\x9CV[V[\x91\x90a\x1C\xE0\x90_`@\x85\x01\x94\x01\x90a\x1C\xA9V[V[4a\x1D\x13Wa\x1D\x0Fa\x1C\xFEa\x1C\xF86`\x04a\x1CWV[\x90a=\\V[a\x1D\x06a\x04\x12V[\x91\x82\x91\x82a\x1C\xCDV[\x03\x90\xF3[a\x04\x18V[\x7F\xCC\xE2\x96\xB0@3*\x08\x0Em\xF15\x15\xA3\xEC(i\xE2\x1C\xD2\x0FsD\xAF\t\x87\xDD\xB98\xD8\xBD!\x90V[a\x1DDa\x1D\x18V[\x90V[4a\x1DwWa\x1DW6`\x04a\x05YV[a\x1Dsa\x1Dba\x1D<V[a\x1Dja\x04\x12V[\x91\x82\x91\x82a\x07\xDDV[\x03\x90\xF3[a\x04\x18V[_\x80\xFD[_\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\x1D\xA4a\x1D\xAA\x91a\x1C\x91V[\x91a\x1C\x91V[\x01\x90`\x01\x80`\xD0\x1B\x03\x82\x11a\x1D\xBBWV[a\x1D\x84V[\x90a\x1D\xD3\x91a\x1D\xCDa\x1D\x80V[Pa\x1D\x98V[\x90V[a\x1D\xE2a\x1D\xE8\x91a\x1C\x91V[\x91a\x1C\x91V[\x90\x03\x90`\x01\x80`\xD0\x1B\x03\x82\x11a\x1D\xFAWV[a\x1D\x84V[\x90a\x1E\x12\x91a\x1E\x0Ca\x1D\x80V[Pa\x1D\xD6V[\x90V[_\x90V[a\x1E!a\x1E\x15V[P\x80a\x1E<a\x1E6c\x0C\xCC\xC6e`\xE2\x1Ba\x04 V[\x91a\x04 V[\x14\x80\x15a\x1E`W[\x90\x81\x15a\x1EPW[P\x90V[a\x1EZ\x91Pa=rV[_a\x1ELV[P\x80a\x1E{a\x1Euc\xB2u*\xC9`\xE0\x1Ba\x04 V[\x91a\x04 V[\x14a\x1EDV[a\x1E\x9A\x90a\x1E\x95a\x1E\x90a\x1D\x18V[a=\xB2V[a![V[V[a\x1E\xB0a\x1E\xABa\x1E\xB5\x92a\x16NV[a\n!V[a\x04\xC9V[\x90V[a\x1E\xC1\x90a\x1E\x9CV[\x90V[\x1B\x90V[\x91\x90`\x08a\x1E\xE3\x91\x02\x91a\x1E\xDD_\x19\x84a\x1E\xC4V[\x92a\x1E\xC4V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x1F\x01a\x1E\xFCa\x1F\x06\x92a\x06\x08V[a\n!V[a\x06\x08V[\x90V[\x90V[\x91\x90a\x1F\"a\x1F\x1Da\x1F*\x93a\x1E\xEDV[a\x1F\tV[\x90\x83Ta\x1E\xC8V[\x90UV[_\x90V[a\x1FD\x91a\x1F>a\x1F.V[\x91a\x1F\x0CV[V[`\x06_\x91a\x1FV\x83\x80\x83\x01a\x1F2V[a\x1Fc\x83`\x01\x83\x01a\x1F2V[a\x1Fp\x83`\x02\x83\x01a\x1F2V[a\x1F}\x83`\x03\x83\x01a\x1F2V[a\x1F\x8A\x83`\x04\x83\x01a\x1F2V[a\x1F\x97\x83`\x05\x83\x01a\x1F2V[\x01UV[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[\x90_\x03a\x1F\xC0Wa\x1F\xBE\x90a\x1FFV[V[a\x1F\x9BV[\x90a\x1F\xD1`\xFF\x91a\x16QV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x1F\xE4\x90a\x04mV[\x90V[\x90V[\x90a\x1F\xFFa\x1F\xFAa \x06\x92a\x1F\xDBV[a\x1F\xE7V[\x82Ta\x1F\xC5V[\x90UV[a \x1Ea \x19a #\x92a\x16NV[a\n!V[a\x06\x08V[\x90V[`\x01a 2\x91\x01a\x06\x08V[\x90V[\x90V[a La Ga Q\x92a 5V[a\n!V[a\x06\x08V[\x90V[a ca i\x91\x93\x92\x93a\x06\x08V[\x92a\x06\x08V[\x82\x03\x91\x82\x11a tWV[a\x1D\x84V[\x91\x90`\x08a \x99\x91\x02\x91a \x93`\x01\x80`\xA0\x1B\x03\x84a\x1E\xC4V[\x92a\x1E\xC4V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90V[\x91\x90a \xBCa \xB7a \xC4\x93a\nLV[a \xA3V[\x90\x83Ta yV[\x90UV[\x90V[cNH{q`\xE0\x1B_R`1`\x04R`$_\xFD[T\x90V[_R` _ \x90V[a \xF5\x81a \xDFV[\x82\x10\x15a!\x0FWa!\x07`\x01\x91a \xE3V[\x91\x02\x01\x90_\x90V[a\x16\xBEV[_\x90V[a!*\x91a!$a!\x14V[\x91a \xA6V[V[a!5\x81a \xDFV[\x80\x15a!VW`\x01\x90\x03\x90a!Sa!M\x83\x83a \xECV[\x90a!\x18V[UV[a \xCBV[\x80a!va!pa!k_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14a\"\xECWa!\x98a!\x92a!\x8D`\x0F\x84\x90a\x0ESV[a\n\xB1V[\x15a\x04mV[a\"\xCDWa!\xB1_a!\xAC`\r\x84\x90a\nXV[a\x1F\xAEV[a!\xC6_a!\xC1`\x0F\x84\x90a\x0ESV[a\x1F\xEAV[a!\xCF_a \nV[[\x80a!\xECa!\xE6a!\xE1`\x0Ea\x16\xD2V[a\x06\x08V[\x91a\x06\x08V[\x10\x15a\"\xC7Wa\"\x07a\"\x01`\x0E\x83\x90a\x16\xDFV[\x90a\x17*V[a\"\x19a\"\x13\x84a\x04\xD4V[\x91a\x04\xD4V[\x14a\",Wa\"'\x90a &V[a!\xD0V[a\"r\x90a\"la\"da\"^`\x0Ea\"Xa\"H`\x0Ea\x16\xD2V[a\"R`\x01a 8V[\x90a TV[\x90a\x16\xDFV[\x90a\x17*V[\x91`\x0Ea\x16\xDFV[\x90a \xA6V[a\"\x84a\"\x7F`\x0Ea \xC8V[a!,V[[a\"\xAF\x7F]\x9DP4el\xB3\xEB\xFB\x06U\x05|\xD7\xF9\xB4\x07z\x9BB\xFFB\xCE\"<\xBA\xC5\xBCXm!&\x91a\nLV[\x90a\"\xB8a\x04\x12V[\x80a\"\xC2\x81a\x05!V[\x03\x90\xA2V[Pa\"\x85V[a\"\xE8\x90_\x91\x82\x91ce\x85\xB6\r`\xE0\x1B\x83R`\x04\x83\x01a\x0C\xFEV[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a#\x04`\x04\x82\x01a\x05!V[\x03\x90\xFD[a#\x11\x90a\x1E\x81V[V[``\x90V[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a#LW[` \x83\x10\x14a#GWV[a#\x18V[\x91`\x7F\x16\x91a#<V[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a#\x82a#{\x83a#,V[\x80\x94a#VV[\x91`\x01\x81\x16\x90\x81_\x14a#\xD9WP`\x01\x14a#\x9DW[PPPV[a#\xAA\x91\x92\x93\x94Pa#_V[\x91_\x92[\x81\x84\x10a#\xC1WPP\x01\x90_\x80\x80a#\x98V[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a#\xAEV[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a#\x98V[\x90a#\xFE\x91a#hV[\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a$\x1F\x90a\x05\x80V[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a$9W`@RV[a$\x01V[\x90a$^a$W\x92a$Na\x04\x12V[\x93\x84\x80\x92a#\xF4V[\x03\x83a$\x15V[V[a$i\x90a$>V[\x90V[a$ta#\x13V[Pa$\x7F`\x03a$`V[\x90V[a$\x9F\x91a$\x8Ea\x1E\x15V[Pa$\x97a=\xC6V[\x91\x90\x91a=\xD3V[`\x01\x90V[a$\xACa\x1F.V[Pa$\xB7`\x02a\n\x8AV[\x90V[\x80a$\xD5a$\xCFa$\xCA_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14a%sW\x81a$\xEDa$\xE7_a \nV[\x91a\x06\x08V[\x14a%WWa$\xFD3\x83\x90a>\x18V[a%\x08\x81\x83\x90a?oV[3\x90a%Ra%@a%:\x7F\xDE\"\xBA\xFF\x03\x8E:>\x08@|\xBD\xF6\x17\xDE\xEDt\xE8i\xA7\xBAQ}\xF6\x11\xE311\xC6\xE6\xEA\x04\x93a\nLV[\x93a\nLV[\x93a%Ia\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xA3V[_c\x1F* \x05`\xE0\x1B\x81R\x80a%o`\x04\x82\x01a\x05!V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a%\x8B`\x04\x82\x01a\x05!V[\x03\x90\xFD[\x91a%\xB9\x92a%\x9Ca\x1E\x15V[Pa%\xB1a%\xA8a=\xC6V[\x82\x90\x84\x91a?\xDBV[\x91\x90\x91a@gV[`\x01\x90V[_\x90V[a%\xCB\x90a\x07\x8CV[\x90V[\x90a%\xD8\x90a%\xC2V[_R` R`@_ \x90V[\x90V[a%\xF3a%\xF8\x91a\nnV[a%\xE4V[\x90V[a&\x05\x90Ta%\xE7V[\x90V[`\x01a&!a&'\x92a&\x19a%\xBEV[P`\x05a%\xCEV[\x01a%\xFBV[\x90V[\x80a&Ea&?a&:_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14a'5W\x81a&]a&W_a \nV[\x91a\x06\x08V[\x14a'\x19Wa&m3\x83\x90aA\x04V[3a&\x80a&z\x83a\x04\xD4V[\x91a\x04\xD4V[\x03a&\xE0W[a&\x91\x81\x83\x90aB\\V[3\x90a&\xDBa&\xC9a&\xC3\x7F\xB9\x07\x95\xA6fP\x15Y\x83\xE2B\xCA\xC3\xE1\xAC\x1AM\xC2o\x8E\xD2\x98\x7F<\xE4\x16\xA3N\0\x11\x1F\xD4\x93a\nLV[\x93a\nLV[\x93a&\xD2a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xA3V[a&\xEB\x813\x90a<\xEEV[a&\xFDa&\xF7_a \nV[\x91a\x06\x08V[\x03a'\x08W[a&\x86V[a'\x14\x813\x84\x91a?\xDBV[a'\x03V[_c\x1F* \x05`\xE0\x1B\x81R\x80a'1`\x04\x82\x01a\x05!V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a'M`\x04\x82\x01a\x05!V[\x03\x90\xFD[\x90a'l\x91a'ga'b\x82a&\x08V[a=\xB2V[a'nV[V[\x90a'x\x91aB\xBBV[PV[\x90a'\x85\x91a'QV[V[\x90a'\x91\x90a\x06\x08V[\x90RV[\x90a'\x9F\x90a\x04mV[\x90RV[\x90a'\xB6a'\xAFa\x04\x12V[\x92\x83a$\x15V[V[a'\xC2`\xE0a'\xA3V[\x90V[\x90a(ta(k`\x06a'\xD6a'\xB8V[\x94a'\xEDa'\xE5_\x83\x01a\n\x8AV[_\x88\x01a'\x87V[a(\x05a'\xFC`\x01\x83\x01a\n\x8AV[` \x88\x01a'\x87V[a(\x1Da(\x14`\x02\x83\x01a\n\x8AV[`@\x88\x01a'\x87V[a(5a(,`\x03\x83\x01a\n\x8AV[``\x88\x01a'\x87V[a(Ma(D`\x04\x83\x01a\n\x8AV[`\x80\x88\x01a'\x87V[a(ea(\\`\x05\x83\x01a\n\x8AV[`\xA0\x88\x01a'\x87V[\x01a\n\xB1V[`\xC0\x84\x01a'\x95V[V[a(\x7F\x90a'\xC5V[\x90V[a(\x8C\x90Qa\x06\x08V[\x90V[\x90V[a(\xA6a(\xA1a(\xAB\x92a(\x8FV[a\n!V[a\x06\x08V[\x90V[a(\xBDa(\xC3\x91\x93\x92\x93a\x06\x08V[\x92a\x06\x08V[\x82\x01\x80\x92\x11a(\xCEWV[a\x1D\x84V[a(\xEAa(\xEF\x91a(\xE2a\x1F.V[P`\ra\nXV[a(vV[Ba)\"a)\x1Ca)\x17a)\x05``\x86\x01a(\x82V[a)\x11b\x01Q\x80a(\x92V[\x90a(\xAEV[a\x06\x08V[\x91a\x06\x08V[\x10\x15a)MW\x80a)D`\xA0a)=` a)J\x95\x01a(\x82V[\x92\x01a(\x82V[\x90a TV[\x90V[` a)Y\x91\x01a(\x82V[\x90V[_\x90V[\x90V[a)wa)ra)|\x92a)`V[a\n!V[a\x08\xF1V[\x90V[a)\x87a)\\V[Pa)\x92`\x12a)cV[\x90V[a)\x9Da%\xBEV[Pa)\xA6aCgV[\x90V[\x90\x80a)\xC4a)\xBEa)\xB9a=\xC6V[a\x04\xD4V[\x91a\x04\xD4V[\x03a)\xD5Wa)\xD2\x91aD!V[PV[_c3K\xD9\x19`\xE1\x1B\x81R\x80a)\xED`\x04\x82\x01a\x05!V[\x03\x90\xFD[\x90a)\xFB\x90a\nLV[_R` R`@_ \x90V[\x90V[a*\x1Ea*\x19a*#\x92a\x1C\x91V[a\n!V[a\x06\x08V[\x90V[a*]\x91a*Ra*La*Ga*X\x94a*?a\x1F.V[P`\na)\xF1V[a*\x07V[\x91aE\x02V[\x90aE\xF8V[a*\nV[\x90V[\x90a*z\x91a*ua*pa\x13\x90V[a=\xB2V[a*|V[V[\x90\x81a*\x98a*\x92a*\x8D_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14a+(W\x80a*\xB0a*\xAA_a \nV[\x91a\x06\x08V[\x14a+\x0CWa*\xC7a*\xC0a$\xA4V[\x82\x90a(\xAEV[a*\xE0a*\xDAa*\xD5a\x14HV[a\x06\x08V[\x91a\x06\x08V[\x11a*\xF0Wa*\xEE\x91a?oV[V[_c\x17~?\xC3`\xE0\x1B\x81R\x80a+\x08`\x04\x82\x01a\x05!V[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a+$`\x04\x82\x01a\x05!V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a+@`\x04\x82\x01a\x05!V[\x03\x90\xFD[\x90a+N\x91a*`V[V[\x80a+ca+]_a \nV[\x91a\x06\x08V[\x14a+tWa+r\x903aB\\V[V[_c\x1F* \x05`\xE0\x1B\x81R\x80a+\x8C`\x04\x82\x01a\x05!V[\x03\x90\xFD[a+\x98a\x1F.V[Pa+\xB2a+\xA4a\x14HV[a+\xACa$\xA4V[\x90a TV[\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a+\xD3Wa+\xCF` \x91a\x05\x80V[\x01\x90V[a$\x01V[\x90a+\xEAa+\xE5\x83a+\xB5V[a'\xA3V[\x91\x82RV[_\x7Fmode=blocknumber&from=default\0\0\0\x91\x01RV[a, `\x1Da+\xD8V[\x90a,-` \x83\x01a+\xEFV[V[a,7a,\x16V[\x90V[a,Ba#\x13V[Pa,Ka7\x19V[a,da,^a,YaG\x1FV[a\x14\xD6V[\x91a\x14\xD6V[\x03a,tWa,qa,/V[\x90V[_c\x01\xBF\xC1\xC5`\xE6\x1B\x81R\x80a,\x8C`\x04\x82\x01a\x05!V[\x03\x90\xFD[\x90a,\x9A\x90a\nLV[_R` R`@_ \x90V[a,\xB2a,\xB7\x91a\nnV[a\x17\x07V[\x90V[a,\xC4\x90Ta,\xA6V[\x90V[a,\xDEa,\xE3\x91a,\xD6a!\x14V[P`\ta,\x90V[a,\xBAV[\x90V[` \x7Fout of bounds\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7FSyndicateTokenCrosschain: index _\x82\x01R\x01RV[a-@`-`@\x92a\x05lV[a-I\x81a,\xE6V[\x01\x90V[a-b\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra-3V[\x90V[\x15a-lWV[a-ta\x04\x12V[bF\x1B\xCD`\xE5\x1B\x81R\x80a-\x8A`\x04\x82\x01a-MV[\x03\x90\xFD[a-\xCAa-\xD0\x91a-\x9Da!\x14V[Pa-\xC3\x81a-\xBDa-\xB7a-\xB2`\x0Ea\x16\xD2V[a\x06\x08V[\x91a\x06\x08V[\x10a-eV[`\x0Ea\x16\xDFV[\x90a\x17*V[\x90V[a-\xE4\x90a-\xDFa=\xC6V[aGoV[V[\x90a.\x01\x92\x91a-\xFCa-\xF7a\x1D\x18V[a=\xB2V[a/gV[V[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15a.3W\x82a.+\x91`\x01a.1\x95\x01\x81Ua \xECV[\x90a \xA6V[V[a$\x01V[\x91` a.Y\x92\x94\x93a.R`@\x82\x01\x96_\x83\x01\x90a\x06\x91V[\x01\x90a\x06\x91V[V[a.e`\xE0a'\xA3V[\x90V[\x90a.t_\x19\x91a\x16QV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a.\x93a.\x8Ea.\x9A\x92a\x1E\xEDV[a\x1F\tV[\x82Ta.hV[\x90UV[a.\xA8\x90Qa\x04mV[\x90V[\x90a/S`\xC0`\x06a/Y\x94a.\xCE_\x82\x01a.\xC8_\x88\x01a(\x82V[\x90a.~V[a.\xE7`\x01\x82\x01a.\xE1` \x88\x01a(\x82V[\x90a.~V[a/\0`\x02\x82\x01a.\xFA`@\x88\x01a(\x82V[\x90a.~V[a/\x19`\x03\x82\x01a/\x13``\x88\x01a(\x82V[\x90a.~V[a/2`\x04\x82\x01a/,`\x80\x88\x01a(\x82V[\x90a.~V[a/K`\x05\x82\x01a/E`\xA0\x88\x01a(\x82V[\x90a.~V[\x01\x92\x01a.\x9EV[\x90a\x1F\xEAV[V[\x90a/e\x91a.\xABV[V[\x80a/\x82a/|a/w_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14a1\x02Wa/\xA4a/\x9Ea/\x99`\x0F\x84\x90a\x0ESV[a\n\xB1V[\x15a\x04mV[a0\x8DW[\x81\x83BB_\x90_\x92`\x01\x94a/\xBCa.[V[\x96_\x88\x01\x90a/\xCA\x91a'\x87V[` \x87\x01\x90a/\xD8\x91a'\x87V[`@\x86\x01\x90a/\xE6\x91a'\x87V[``\x85\x01\x90a/\xF4\x91a'\x87V[a/\xFD\x90a \nV[`\x80\x84\x01\x90a0\x0B\x91a'\x87V[a0\x14\x90a \nV[`\xA0\x83\x01\x90a0\"\x91a'\x87V[`\xC0\x82\x01\x90a00\x91a'\x95V[`\r\x82a0<\x91a\nXV[\x90a0F\x91a/[V[\x90\x7F\xAA\x80}\n\xBF0\xD9\x19h\xC7G\x8Cf\xB6\xD8%!\xA1\x06\xAF\x13\xED\xA06\xE2\x03m\xA9\xAF\x16\x89X\x91a0r\x90a\nLV[\x92a0{a\x04\x12V[\x91\x82\x91a0\x88\x91\x83a.8V[\x03\x90\xA2V[a0\xA1a0\x9A`\x0Ea \xC8V[\x82\x90a.\x03V[a0\xB7`\x01a0\xB2`\x0F\x84\x90a\x0ESV[a\x1F\xEAV[\x80\x82\x90\x84a0\xE5\x7F\xDB\x03\xF9}\xC5\x84\nq\xE6\x9B\xE7G\x0EGa\xAF\x10\xA1#ys\xE8\x1C\x12\xD0\xDC(\x13\x89Ze&\x92a\nLV[\x92a0\xFAa0\xF1a\x04\x12V[\x92\x83\x92\x83a.8V[\x03\x90\xA2a/\xA9V[_c\xD9.#=`\xE0\x1B\x81R\x80a1\x1A`\x04\x82\x01a\x05!V[\x03\x90\xFD[\x90a1)\x92\x91a-\xE6V[V[a13a\x1F.V[Pa1>`\x0Ea\x16\xD2V[\x90V[_\x90V[a1W\x90a1Qa1AV[PaG\xFAV[\x90V[\x90a1d\x90a\nLV[_R` R`@_ \x90V[a1\x86a1\x8B\x91a1\x7Fa\x1F.V[P_a1ZV[a\n\x8AV[\x90V[``\x90V[` \x91\x81R\x01\x90V[a1\xA6\x90Ta,\xA6V[\x90V[`\x01\x01\x90V[\x90a1\xCCa1\xC6a1\xBF\x84a\x16\xD2V[\x80\x93a1\x93V[\x92a\x16\xD6V[\x90_[\x81\x81\x10a1\xDCWPPP\x90V[\x90\x91\x92a1\xFCa1\xF6`\x01\x92a1\xF1\x87a1\x9CV[a\x0F\x96V[\x94a1\xA9V[\x91\x01\x91\x90\x91a1\xCFV[\x90a2\x10\x91a1\xAFV[\x90V[\x90a23a2,\x92a2#a\x04\x12V[\x93\x84\x80\x92a2\x06V[\x03\x83a$\x15V[V[a2>\x90a2\x13V[\x90V[a2Ia1\x8EV[Pa2T`\x0Ea25V[\x90V[a2_a\x1E\x15V[Pa2\x87a2\x82a2za2u`\r\x85\x90a\nXV[a(vV[\x92`\x0Fa\x0ESV[a\n\xB1V[\x90\x81a2\x92W[P\x90V[a2\x9F\x91P`\xC0\x01a.\x9EV[_a2\x8EV[\x90a2\xBF\x91a2\xBAa2\xB5a\x13,V[a=\xB2V[a2\xC1V[V[\x80a2\xDCa2\xD6a2\xD1_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14a3\xA0W\x81a2\xF4a2\xEE_a \nV[\x91a\x06\x08V[\x14a3\x84Wa3\na3\x04a4UV[\x15a\x04mV[a3hWa3\x19\x81\x83\x90aB\\V[3\x90a3ca3Qa3K\x7F\xBE\xF4\xF8\x1C\x18\x14\xC6A\xED\xE8^\xBA\xAC\xF1\x9D\x04\x8B,[U\x98\n\xDF\xA6\xEF\x0F\x95le\x135\xA2\x93a\nLV[\x93a\nLV[\x93a3Za\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xA3V[_c\xB8\xB5\xCA-`\xE0\x1B\x81R\x80a3\x80`\x04\x82\x01a\x05!V[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a3\x9C`\x04\x82\x01a\x05!V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a3\xB8`\x04\x82\x01a\x05!V[\x03\x90\xFD[\x90a3\xC6\x91a2\xA5V[V[a3\xD0a\x1F.V[Pa3\xDB`\x0Ca\n\x8AV[a3\xEDa3\xE7_a \nV[\x91a\x06\x08V[\x14\x80\x15a4\x1CW[a4\x10Wa4\ra4\x06`\x0Ca\n\x8AV[B\x90a TV[\x90V[a4\x19_a \nV[\x90V[PBa49a43a4.`\x0Ca\n\x8AV[a\x06\x08V[\x91a\x06\x08V[\x10\x15a3\xF5V[a4R\x90a4La\x1F.V[PaH)V[\x90V[a4]a\x1E\x15V[Pa4h`\x0Ca\n\x8AV[a4za4t_a \nV[\x91a\x06\x08V[\x14\x15\x80a4\x85W[\x90V[PBa4\xA2a4\x9Ca4\x97`\x0Ca\n\x8AV[a\x06\x08V[\x91a\x06\x08V[\x10a4\x82V[a4\xC1\x90a4\xBCa4\xB7a\x16rV[a=\xB2V[a4\xC3V[V[\x80a4\xD6a4\xD0Ba\x06\x08V[\x91a\x06\x08V[\x11\x15a5\x8CW\x80a5\x0Fa5\t\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x06\x08V[\x91a\x06\x08V[\x11a5pWa5\x1E`\x0Ca\n\x8AV[a5)\x82`\x0Ca.~V[\x903\x90a5V\x7F\xDDh\x96\xDC\xF1\xD4\xB3\x11\xCC\xA8}\xD1\x9B\xBB\xA2\xEA\x9C\xE2\xF8g\xC1V\x88x\xA0C\x8Af\xA1\xAF\xEE\xEC\x92a\nLV[\x92a5ka5ba\x04\x12V[\x92\x83\x92\x83a.8V[\x03\x90\xA2V[_c\xEFi\xAFe`\xE0\x1B\x81R\x80a5\x88`\x04\x82\x01a\x05!V[\x03\x90\xFD[_c\xA5e\x83S`\xE0\x1B\x81R\x80a5\xA4`\x04\x82\x01a\x05!V[\x03\x90\xFD[a5\xB1\x90a4\xA8V[V[_\x90V[``\x90V[a5\xC5\x90a\n@V[\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a5\xE0W` \x80\x91\x02\x01\x90V[a$\x01V[\x90a5\xF7a5\xF2\x83a5\xC8V[a'\xA3V[\x91\x82RV[6\x907V[\x90a6&a6\x0E\x83a5\xE5V[\x92` \x80a6\x1C\x86\x93a5\xC8V[\x92\x01\x91\x03\x90a5\xFCV[V[`\x0F`\xF8\x1B\x90V[a68a5\xB3V[Pa6Aa#\x13V[Pa6Ja#\x13V[Pa6Sa\x1F.V[Pa6\\a!\x14V[Pa6ea%\xBEV[Pa6na5\xB7V[Pa6waHAV[\x90a6\x80aH\x81V[\x90F\x90a6\x8C0a5\xBCV[\x90a6\x96_a\x16VV[\x90a6\xA8a6\xA3_a \nV[a6\x01V[\x90a6\xB1a6(V[\x96\x95\x94\x93\x92\x91\x90V[a6\xE3a6\xE8\x91a6\xC9a\x1F.V[Pa6\xDDa6\xD7`\x0Ba*\x07V[\x91aE\x02V[\x90aE\xF8V[a*\nV[\x90V[a7\x12\x91_a7\x07a7\r\x93a6\xFFa\x1E\x15V[P`\x05a%\xCEV[\x01a\x0ESV[a\n\xB1V[\x90V[_\x90V[a7!a7\x15V[Pa7*aG\x1FV[\x90V[a7Da7I\x91a7<a\x1F.V[P`\ra\nXV[a(vV[Ba7|a7va7qa7_`@\x86\x01a(\x82V[a7kb\x01Q\x80a(\x92V[\x90a(\xAEV[a\x06\x08V[\x91a\x06\x08V[\x10\x15a7\xA6W\x80a7\x9D`\x80a7\x96_a7\xA3\x95\x01a(\x82V[\x92\x01a(\x82V[\x90a TV[\x90V[_a7\xB1\x91\x01a(\x82V[\x90V[a7\xBCa#\x13V[Pa7\xC7`\x04a$`V[\x90V[a7\xF1a7\xECa7\xE7a7\xF6\x93a7\xDFa\x1F.V[P`\na)\xF1V[a*\x07V[aH\xC1V[a*\nV[\x90V[a8\x16\x91a8\x05a\x1E\x15V[Pa8\x0Ea=\xC6V[\x91\x90\x91a@gV[`\x01\x90V[\x90a8.\x91a8(a\x1F.V[Pa*&V[\x90V[a8C\x90a8=a\x1F.V[Pa7\xCAV[\x90V[a8Na\x1F.V[Pa8Wa$\xA4V[\x90V[\x7F\xE4\x83)\x05{\xFD\x03\xD5^I\xB5G\x13.9\xCF\xFD\x9C\x18 \xAD{\x9DLS\x07i\x14%\xD1Z\xDF\x90V[a8\xB3a8\xBA\x94a8\xA9``\x94\x98\x97\x95a8\x9F`\x80\x86\x01\x9A_\x87\x01\x90a\x07\xD0V[` \x85\x01\x90a\x0C\xF1V[`@\x83\x01\x90a\x06\x91V[\x01\x90a\x06\x91V[V[` \x01\x90V[Q\x90V[\x93\x95\x94\x90\x92\x91\x95Ba8\xE0a8\xDA\x89a\x06\x08V[\x91a\x06\x08V[\x11a9YW\x91a9K\x91a9R\x93a9Ba9W\x98\x99a9*a9\x01a8ZV[a9\x1B\x8B\x93\x8Ba9\x0Fa\x04\x12V[\x95\x86\x94` \x86\x01a8~V[` \x82\x01\x81\x03\x82R\x03\x82a$\x15V[a9<a96\x82a8\xC2V[\x91a8\xBCV[ aI6V[\x92\x90\x91\x92aISV[\x91\x82aI\x9DV[aGoV[V[a9t\x87_\x91\x82\x91c#A\xD7\x87`\xE1\x1B\x83R`\x04\x83\x01a\x06\x9EV[\x03\x90\xFD[_\x90V[_\x90V[a9\x88a'\xB8V[\x90` \x80\x80\x80\x80\x80\x80\x88a9\x9Aa9xV[\x81R\x01a9\xA5a9xV[\x81R\x01a9\xB0a9xV[\x81R\x01a9\xBBa9xV[\x81R\x01a9\xC6a9xV[\x81R\x01a9\xD1a9xV[\x81R\x01a9\xDCa9|V[\x81RPPV[a9\xEAa9\x80V[\x90V[a:\x04a:\t\x91a9\xFCa9\xE2V[P`\ra\nXV[a(vV[\x90V[\x90a:&\x91a:!a:\x1Ca\x1D\x18V[a=\xB2V[a:(V[V[\x80a:Ca:=a:8_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14a:\xE4Wa:ea:_a:Z`\x0F\x84\x90a\x0ESV[a\n\xB1V[\x15a\x04mV[a:\xC5Wa:\x81\x82`\x06a:{`\r\x85\x90a\nXV[\x01a\x1F\xEAV[a:\xC0a:\xAE\x7F\x9C\x86h\xDB2HE\x06]+\x9A*\x18;\xD3\x14\x1Fc\x01\x8FT\x82\x82\xDA\xF1\x8D\xA4\x9C\xCB\xF8\x8C3\x92a\nLV[\x92a:\xB7a\x04\x12V[\x91\x82\x91\x82a\x04\x7FV[\x03\x90\xA2V[a:\xE0\x90_\x91\x82\x91ce\x85\xB6\r`\xE0\x1B\x83R`\x04\x83\x01a\x0C\xFEV[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a:\xFC`\x04\x82\x01a\x05!V[\x03\x90\xFD[\x90a;\n\x91a:\x0CV[V[\x7Fnq\xED\xAE\x12\xB1\xB9\x7FM\x1F`7\x0F\xEF\x10\x10_\xA2\xFA\xAE\x01&\x11J\x16\x9Cd\x84]a&\xC9\x90V[\x91\x94a;xa;\x82\x92\x98\x97\x95a;n`\xA0\x96a;da;\x89\x9Aa;Z`\xC0\x8A\x01\x9E_\x8B\x01\x90a\x07\xD0V[` \x89\x01\x90a\x0C\xF1V[`@\x87\x01\x90a\x0C\xF1V[``\x85\x01\x90a\x06\x91V[`\x80\x83\x01\x90a\x06\x91V[\x01\x90a\x06\x91V[V[\x91` a;\xAC\x92\x94\x93a;\xA5`@\x82\x01\x96_\x83\x01\x90a\x0C\xF1V[\x01\x90a\x0C\xF1V[V[\x96\x95\x91\x93\x92\x94\x90\x94Ba;\xC9a;\xC3\x83a\x06\x08V[\x91a\x06\x08V[\x11a<\x83W\x90a<2a<;\x94\x93\x92a<\x1Aa;\xE3a;\x0CV[a<\x0B\x8C\x80\x94\x8C\x91a;\xF5\x8D\x91aI\xE0V[\x91\x92a;\xFFa\x04\x12V[\x97\x88\x96` \x88\x01a;0V[` \x82\x01\x81\x03\x82R\x03\x82a$\x15V[a<,a<&\x82a8\xC2V[\x91a8\xBCV[ aI6V[\x92\x90\x91\x92aISV[\x80a<Na<H\x87a\x04\xD4V[\x91a\x04\xD4V[\x03a<cWPa<a\x92\x93\x91\x90\x91a=\xD3V[V[\x84\x90a<\x7F_\x92\x83\x92c%\xC0\x07#`\xE1\x1B\x84R`\x04\x84\x01a;\x8BV[\x03\x90\xFD[a<\x9E\x90_\x91\x82\x91c1<\x89\x81`\xE1\x1B\x83R`\x04\x83\x01a\x06\x9EV[\x03\x90\xFD[\x90a<\xBD\x91a<\xB8a<\xB3\x82a&\x08V[a=\xB2V[a<\xBFV[V[\x90a<\xC9\x91aD!V[PV[\x90a<\xD6\x91a<\xA2V[V[\x90a<\xE2\x90a\nLV[_R` R`@_ \x90V[a=\x13\x91a=\ta=\x0E\x92a=\x01a\x1F.V[P`\x01a<\xD8V[a1ZV[a\n\x8AV[\x90V[a= `@a'\xA3V[\x90V[_\x90V[_\x90V[a=3a=\x16V[\x90` \x80\x83a=@a=#V[\x81R\x01a=Ka='V[\x81RPPV[a=Ya=+V[\x90V[\x90a=o\x91a=ia=QV[PaJ\x13V[\x90V[a=za\x1E\x15V[P\x80a=\x95a=\x8Fcye\xDB\x0B`\xE0\x1Ba\x04 V[\x91a\x04 V[\x14\x90\x81\x15a=\xA2W[P\x90V[a=\xAC\x91PaJ;V[_a=\x9EV[a=\xC4\x90a=\xBEa=\xC6V[\x90aJ\x84V[V[a=\xCEa!\x14V[P3\x90V[\x91a=\xE1\x92\x91`\x01\x92aJ\xBFV[V[\x90V[`@\x90a>\x0Fa>\x16\x94\x96\x95\x93\x96a>\x05``\x84\x01\x98_\x85\x01\x90a\x0C\xF1V[` \x83\x01\x90a\x06\x91V[\x01\x90a\x06\x91V[V[\x90a>-a>(`\r\x84\x90a\nXV[a=\xE3V[\x91a>Ka>Ea>@`\x0F\x84\x90a\x0ESV[a\n\xB1V[\x15a\x04mV[\x80\x15a?TW[a?5WBa>\x89a>\x83a>~a>l`\x02\x88\x01a\n\x8AV[a>xb\x01Q\x80a(\x92V[\x90a(\xAEV[a\x06\x08V[\x91a\x06\x08V[\x10\x15a?\x0EW[a>\xB0a>\x9E_\x85\x01a\n\x8AV[a>\xAA`\x04\x86\x01a\n\x8AV[\x90a TV[\x90\x82a>\xC4a>\xBE\x84a\x06\x08V[\x91a\x06\x08V[\x11a>\xEEWPP\x90a>\xE6`\x04a>\xEC\x93\x92\x01\x91a>\xE1\x83a\n\x8AV[a(\xAEV[\x90a.~V[V[a?\n\x83\x92_\x93\x84\x93c@\xED6{`\xE0\x1B\x85R`\x04\x85\x01a=\xE6V[\x03\x90\xFD[a?#a?\x1A_a \nV[`\x04\x85\x01a.~V[a?0B`\x02\x85\x01a.~V[a>\x90V[a?P\x90_\x91\x82\x91ce\x85\xB6\r`\xE0\x1B\x83R`\x04\x83\x01a\x0C\xFEV[\x03\x90\xFD[Pa?ja?d`\x06\x85\x01a\n\xB1V[\x15a\x04mV[a>RV[\x80a?\x8Aa?\x84a?\x7F_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14a?\xA6Wa?\xA4\x91a?\x9C_a\x1E\xB8V[\x91\x90\x91aK\xCEV[V[a?\xC9a?\xB2_a\x1E\xB8V[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x0C\xFEV[\x03\x90\xFD[\x90a?\xD8\x91\x03a\x06\x08V[\x90V[\x92\x91\x92a?\xE9\x81\x83\x90a<\xEEV[\x90\x81a?\xFEa?\xF8_\x19a\x06\x08V[\x91a\x06\x08V[\x10a@\x0BW[PPP\x90PV[\x81a@\x1Ea@\x18\x87a\x06\x08V[\x91a\x06\x08V[\x10a@DWa@;\x93\x94a@3\x91\x93\x92a?\xCDV[\x90_\x92aJ\xBFV[\x80_\x80\x80a@\x04V[Pa@c\x84\x92\x91\x92_\x93\x84\x93c}\xC7\xA0\xD9`\xE1\x1B\x85R`\x04\x85\x01a=\xE6V[\x03\x90\xFD[\x91\x82a@\x83a@}a@x_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14a@\xDDW\x81a@\xA3a@\x9Da@\x98_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14a@\xB6Wa@\xB4\x92\x91\x90\x91aK\xCEV[V[a@\xD9a@\xC2_a\x1E\xB8V[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x0C\xFEV[\x03\x90\xFD[aA\0a@\xE9_a\x1E\xB8V[_\x91\x82\x91cKc~\x8F`\xE1\x1B\x83R`\x04\x83\x01a\x0C\xFEV[\x03\x90\xFD[\x90aA\x19aA\x14`\r\x84\x90a\nXV[a=\xE3V[\x91aA7aA1aA,`\x0F\x84\x90a\x0ESV[a\n\xB1V[\x15a\x04mV[\x80\x15aBAW[aB\"WBaAuaAoaAjaAX`\x03\x88\x01a\n\x8AV[aAdb\x01Q\x80a(\x92V[\x90a(\xAEV[a\x06\x08V[\x91a\x06\x08V[\x10\x15aA\xFBW[aA\x9DaA\x8B`\x01\x85\x01a\n\x8AV[aA\x97`\x05\x86\x01a\n\x8AV[\x90a TV[\x90\x82aA\xB1aA\xAB\x84a\x06\x08V[\x91a\x06\x08V[\x11aA\xDBWPP\x90aA\xD3`\x05aA\xD9\x93\x92\x01\x91aA\xCE\x83a\n\x8AV[a(\xAEV[\x90a.~V[V[aA\xF7\x83\x92_\x93\x84\x93cr\xFFK\xD1`\xE1\x1B\x85R`\x04\x85\x01a=\xE6V[\x03\x90\xFD[aB\x10aB\x07_a \nV[`\x05\x85\x01a.~V[aB\x1DB`\x03\x85\x01a.~V[aA|V[aB=\x90_\x91\x82\x91ce\x85\xB6\r`\xE0\x1B\x83R`\x04\x83\x01a\x0C\xFEV[\x03\x90\xFD[PaBWaBQ`\x06\x85\x01a\n\xB1V[\x15a\x04mV[aA>V[\x90\x81aBxaBraBm_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14aB\x94WaB\x92\x91\x90aB\x8B_a\x1E\xB8V[\x90\x91aK\xCEV[V[aB\xB7aB\xA0_a\x1E\xB8V[_\x91\x82\x91cKc~\x8F`\xE1\x1B\x83R`\x04\x83\x01a\x0C\xFEV[\x03\x90\xFD[aB\xC3a\x1E\x15V[PaB\xD8aB\xD2\x82\x84\x90a6\xEBV[\x15a\x04mV[_\x14aCaWaC\0`\x01aB\xFB_aB\xF3`\x05\x86\x90a%\xCEV[\x01\x85\x90a\x0ESV[a\x1F\xEAV[\x90aC\ta=\xC6V[\x90aCFaC@aC:\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a%\xC2V[\x92a\nLV[\x92a\nLV[\x92aCOa\x04\x12V[\x80aCY\x81a\x05!V[\x03\x90\xA4`\x01\x90V[PP_\x90V[aCoa%\xBEV[PaCy0a5\xBCV[aC\xABaC\xA5\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04\xD4V[\x91a\x04\xD4V[\x14\x80aC\xE7W[_\x14aC\xDCW\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[aC\xE4aL\xE9V[\x90V[PFaD\x1BaD\x15\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x06\x08V[\x91a\x06\x08V[\x14aC\xB2V[aD)a\x1E\x15V[PaD5\x81\x83\x90a6\xEBV[_\x14aD\xBDWaD\\_aDW_aDO`\x05\x86\x90a%\xCEV[\x01\x85\x90a\x0ESV[a\x1F\xEAV[\x90aDea=\xC6V[\x90aD\xA2aD\x9CaD\x96\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x95a%\xC2V[\x92a\nLV[\x92a\nLV[\x92aD\xABa\x04\x12V[\x80aD\xB5\x81a\x05!V[\x03\x90\xA4`\x01\x90V[PP_\x90V[aD\xD7aD\xD2aD\xDC\x92a\x14\xD6V[a\n!V[a\x06\x08V[\x90V[\x91` aE\0\x92\x94\x93aD\xF9`@\x82\x01\x96_\x83\x01\x90a\x06\x91V[\x01\x90a\x14\xE1V[V[aE\na7\x15V[PaE\x13a7\x19V[\x81aE&aE \x83aD\xC3V[\x91a\x06\x08V[\x10\x15aE9WPaE6\x90aM\xF2V[\x90V[\x90aET_\x92\x83\x92cvi\xFC\x0F`\xE1\x1B\x84R`\x04\x84\x01aD\xDFV[\x03\x90\xFD[T\x90V[\x90V[aEsaEnaEx\x92aE\\V[a\n!V[a\x06\x08V[\x90V[\x90V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[aE\x95aE\x9A\x91a\nnV[aE~V[\x90V[aE\xA7\x90TaE\x89V[\x90V[`0\x1C\x90V[`\x01\x80`\xD0\x1B\x03\x16\x90V[aE\xC7aE\xCC\x91aE\xAAV[aE\xB0V[\x90V[aE\xD9\x90TaE\xBBV[\x90V[aE\xF0aE\xEBaE\xF5\x92a\x16NV[a\n!V[a\x1C\x91V[\x90V[\x90aFL\x90aF\x05a\x1D\x80V[PaF\x11_\x84\x01aEXV[aF\x1A_a \nV[\x90\x80\x80aF0aF*`\x05aE_V[\x91a\x06\x08V[\x11aF\xADW[P\x90aFG_\x86\x01\x93\x91\x92\x93aE{V[aTAV[\x80aF_aFY_a \nV[\x91a\x06\x08V[\x14_\x14aFuWPPaFq_aE\xDCV[[\x90V[aF\xA2_\x91aF\x9DaF\x97\x84aF\xA8\x96\x01\x92aF\x91`\x01a 8V[\x90a TV[\x91aE{V[aT7V[\x01aE\xCFV[aFrV[\x80aF\xBBaF\xC1\x92\x91aP\xCCV[\x90a TV[\x90\x83aF\xF3aF\xEDaF\xE8_aF\xE2\x81\x8C\x01aF\xDD\x89\x91aE{V[aT7V[\x01aE\x9DV[a\x14\xD6V[\x91a\x14\xD6V[\x10_\x14aG\x04WP\x90[\x90_aF6V[\x91PaG\x1A\x90aG\x14`\x01a 8V[\x90a(\xAEV[aF\xFDV[aG'a7\x15V[PaG1CaM\xF2V[\x90V[\x90aGE`\x01\x80`\xA0\x1B\x03\x91a\x16QV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90aGdaG_aGk\x92a\nLV[a \xA3V[\x82TaG4V[\x90UV[\x90aG\xF8\x91aG\xF2aG\x80\x82a,\xC7V[aG\x95\x84aG\x90`\t\x86\x90a,\x90V[aGOV[\x82\x81\x85\x90aG\xD5aG\xCFaG\xC9\x7F14\xE8\xA2\xE6\xD9~\x92\x9A~T\x01\x1E\xA5H]}\x19m\xD5\xF0\xBAMN\xF9X\x03\xE8\xE3\xFC%\x7F\x95a\nLV[\x92a\nLV[\x92a\nLV[\x92aG\xDEa\x04\x12V[\x80aG\xE8\x81a\x05!V[\x03\x90\xA4\x92\x91aT\xD0V[\x91aT\xE8V[V[aH!aH\x1CaH\x17aH&\x93aH\x0Fa1AV[P`\na)\xF1V[a*\x07V[aV\x96V[aW\x15V[\x90V[aH;\x90aH5a\x1F.V[PaWfV[\x90V[\x90V[aHIa#\x13V[PaH~\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0aHx`\x06aH>V[\x90aX\x81V[\x90V[aH\x89a#\x13V[PaH\xBE\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0aH\xB8`\x07aH>V[\x90aX\x81V[\x90V[aH\xC9a\x1D\x80V[PaH\xD5_\x82\x01aEXV[\x80aH\xE8aH\xE2_a \nV[\x91a\x06\x08V[\x14_\x14aH\xFEWPPaH\xFA_aE\xDCV[[\x90V[aI+_\x91aI&aI \x84aI1\x96\x01\x92aI\x1A`\x01a 8V[\x90a TV[\x91aE{V[aT7V[\x01aE\xCFV[aH\xFBV[aIP\x90aIBa%\xBEV[PaIKaCgV[aX\xCFV[\x90V[\x92aIn\x92aIw\x94aIda!\x14V[P\x92\x90\x91\x92aY\x95V[\x90\x92\x91\x92aZ\xC0V[\x90V[\x91` aI\x9B\x92\x94\x93aI\x94`@\x82\x01\x96_\x83\x01\x90a\x0C\xF1V[\x01\x90a\x06\x91V[V[aI\xA6\x81aI\xE0V[\x91aI\xB9aI\xB3\x84a\x06\x08V[\x91a\x06\x08V[\x03aI\xC2WPPV[aI\xDC_\x92\x83\x92c\x01\xD4\xB6#`\xE6\x1B\x84R`\x04\x84\x01aIzV[\x03\x90\xFD[aI\xF4\x90aI\xECa\x1F.V[P`\x08a1ZV[aJ\x10aJ\0\x82a\n\x8AV[\x91aJ\n\x83a &V[\x90a.~V[\x90V[\x90aJ3aJ.aJ8\x93aJ&a=QV[P`\na)\xF1V[a*\x07V[a\\\"V[\x90V[aJCa\x1E\x15V[PaJ]aJWc\x01\xFF\xC9\xA7`\xE0\x1Ba\x04 V[\x91a\x04 V[\x14\x90V[\x91` aJ\x82\x92\x94\x93aJ{`@\x82\x01\x96_\x83\x01\x90a\x0C\xF1V[\x01\x90a\x07\xD0V[V[\x90aJ\x99aJ\x93\x83\x83\x90a6\xEBV[\x15a\x04mV[aJ\xA1WPPV[aJ\xBB_\x92\x83\x92c\xE2Q}?`\xE0\x1B\x84R`\x04\x84\x01aJaV[\x03\x90\xFD[\x90\x92\x81aJ\xDCaJ\xD6aJ\xD1_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14aK\xA7W\x83aJ\xFCaJ\xF6aJ\xF1_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14aK\x80WaK \x83aK\x1BaK\x14`\x01\x86\x90a<\xD8V[\x87\x90a1ZV[a.~V[aK*W[PPPV[\x91\x90\x91aKuaKcaK]\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%\x93a\nLV[\x93a\nLV[\x93aKla\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xA3_\x80\x80aK%V[aK\xA3aK\x8C_a\x1E\xB8V[_\x91\x82\x91cJ\x14\x06\xB1`\xE1\x1B\x83R`\x04\x83\x01a\x0C\xFEV[\x03\x90\xFD[aK\xCAaK\xB3_a\x1E\xB8V[_\x91\x82\x91c\xE6\x02\xDF\x05`\xE0\x1B\x83R`\x04\x83\x01a\x0C\xFEV[\x03\x90\xFD[\x91\x82aK\xEAaK\xE4aK\xDF_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14\x15\x80aLUW[aL\x05W[aL\x03\x92\x91\x90\x91a\\CV[V[aL\ra4UV[\x80aL4W[\x15aK\xF7W_c6\xE2x\xFD`\xE2\x1B\x81R\x80aL0`\x04\x82\x01a\x05!V[\x03\x90\xFD[PaLPaLJaLCa\x13,V[3\x90a6\xEBV[\x15a\x04mV[aL\x13V[P\x81aLqaLkaLf_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14\x15aK\xF2V[\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x90V[\x90\x95\x94\x92aL\xE7\x94aL\xD6aL\xE0\x92aL\xCC`\x80\x96aL\xC2`\xA0\x88\x01\x9C_\x89\x01\x90a\x07\xD0V[` \x87\x01\x90a\x07\xD0V[`@\x85\x01\x90a\x07\xD0V[``\x83\x01\x90a\x06\x91V[\x01\x90a\x0C\xF1V[V[aL\xF1a%\xBEV[PaL\xFAaLxV[aMq\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91aMb\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0FaMM0a5\xBCV[\x91aMVa\x04\x12V[\x96\x87\x95` \x87\x01aL\x9CV[` \x82\x01\x81\x03\x82R\x03\x82a$\x15V[aM\x83aM}\x82a8\xC2V[\x91a8\xBCV[ \x90V[\x90V[aM\x9EaM\x99aM\xA3\x92aM\x87V[a\n!V[a\x08\xF1V[\x90V[aM\xAF\x90aM\x8AV[\x90RV[\x91` aM\xD4\x92\x94\x93aM\xCD`@\x82\x01\x96_\x83\x01\x90aM\xA6V[\x01\x90a\x06\x91V[V[aM\xEAaM\xE5aM\xEF\x92a\x06\x08V[a\n!V[a\x14\xD6V[\x90V[aM\xFAa7\x15V[P\x80aN\x14aN\x0Ee\xFF\xFF\xFF\xFF\xFF\xFFaD\xC3V[\x91a\x06\x08V[\x11aN%WaN\"\x90aM\xD6V[\x90V[`0aNA_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01aM\xB3V[\x03\x90\xFD[\x90V[aN\\aNWaNa\x92aNEV[a\n!V[a\x06\x08V[\x90V[\x90V[aN{aNvaN\x80\x92aNdV[a\n!V[a\x08\xF1V[\x90V[aN\xA2\x90aN\x9CaN\x96aN\xA7\x94a\x08\xF1V[\x91a\x06\x08V[\x90a\x0EiV[a\x06\x08V[\x90V[\x90V[aN\xC1aN\xBCaN\xC6\x92aN\xAAV[a\n!V[a\x08\xF1V[\x90V[aN\xE8\x90aN\xE2aN\xDCaN\xED\x94a\x08\xF1V[\x91a\x06\x08V[\x90a\x1E\xC4V[a\x06\x08V[\x90V[\x90V[aO\x07aO\x02aO\x0C\x92aN\xF0V[a\n!V[a\x06\x08V[\x90V[\x90V[aO&aO!aO+\x92aO\x0FV[a\n!V[a\x08\xF1V[\x90V[\x90V[aOEaO@aOJ\x92aO.V[a\n!V[a\x06\x08V[\x90V[\x90V[aOdaO_aOi\x92aOMV[a\n!V[a\x08\xF1V[\x90V[\x90V[aO\x83aO~aO\x88\x92aOlV[a\n!V[a\x06\x08V[\x90V[\x90V[aO\xA2aO\x9DaO\xA7\x92aO\x8BV[a\n!V[a\x08\xF1V[\x90V[\x90V[aO\xC1aO\xBCaO\xC6\x92aO\xAAV[a\n!V[a\x06\x08V[\x90V[\x90V[aO\xE0aO\xDBaO\xE5\x92aO\xC9V[a\n!V[a\x08\xF1V[\x90V[aO\xFCaO\xF7aP\x01\x92aOMV[a\n!V[a\x06\x08V[\x90V[\x90V[aP\x1BaP\x16aP \x92aP\x04V[a\n!V[a\x08\xF1V[\x90V[aP7aP2aP<\x92aO\xC9V[a\n!V[a\x06\x08V[\x90V[aPSaPNaPX\x92a 5V[a\n!V[a\x08\xF1V[\x90V[\x90V[aPraPmaPw\x92aP[V[a\n!V[a\x06\x08V[\x90V[\x90aP\x85\x91\x02a\x06\x08V[\x90V[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[aP\xA8aP\xAE\x91a\x06\x08V[\x91a\x06\x08V[\x90\x81\x15aP\xB9W\x04\x90V[aP\x88V[\x90aP\xC9\x91\x01a\x06\x08V[\x90V[aP\xD4a\x1F.V[P\x80aP\xE9aP\xE3`\x01a 8V[\x91a\x06\x08V[\x11\x15aT4W\x80aR\xFEaR\xDBaR\xCBaR\xBBaR\xABaR\x9BaR\x8BaR{aRkaR[aRK\x8BaREaR>aS\x04\x9FaR\x1EaR\x0EaR.\x92aQ0`\x01a 8V[\x90\x80aQHaQB`\x01`\x80\x1BaNHV[\x91a\x06\x08V[\x10\x15aT\x06W[\x80aQkaQeh\x01\0\0\0\0\0\0\0\0aN\xF3V[\x91a\x06\x08V[\x10\x15aS\xD8W[\x80aQ\x8AaQ\x84d\x01\0\0\0\0aO1V[\x91a\x06\x08V[\x10\x15aS\xAAW[\x80aQ\xA7aQ\xA1b\x01\0\0aOoV[\x91a\x06\x08V[\x10\x15aS|W[\x80aQ\xC3aQ\xBDa\x01\0aO\xADV[\x91a\x06\x08V[\x10\x15aSNW[\x80aQ\xDEaQ\xD8`\x10aO\xE8V[\x91a\x06\x08V[\x10\x15aS W[aQ\xF8aQ\xF2`\x04aP#V[\x91a\x06\x08V[\x10\x15aS\x07W[aR\t`\x03aP^V[aPzV[aR\x18`\x01aP?V[\x90aN\x83V[aR(\x81\x86aP\x9CV[\x90aP\xBEV[aR8`\x01aP?V[\x90aN\x83V[\x80\x92aP\x9CV[\x90aP\xBEV[aRU`\x01aP?V[\x90aN\x83V[aRe\x81\x8CaP\x9CV[\x90aP\xBEV[aRu`\x01aP?V[\x90aN\x83V[aR\x85\x81\x8AaP\x9CV[\x90aP\xBEV[aR\x95`\x01aP?V[\x90aN\x83V[aR\xA5\x81\x88aP\x9CV[\x90aP\xBEV[aR\xB5`\x01aP?V[\x90aN\x83V[aR\xC5\x81\x86aP\x9CV[\x90aP\xBEV[aR\xD5`\x01aP?V[\x90aN\x83V[\x91aR\xF8aR\xF2aR\xED\x85\x80\x94aP\x9CV[a\x06\x08V[\x91a\x06\x08V[\x11a\\\xD3V[\x90a?\xCDV[\x90V[aS\x1B\x90aS\x15`\x01aP?V[\x90aN\xC9V[aQ\xFFV[aS7aSH\x91aS1`\x04aO\xCCV[\x90aN\x83V[\x91aSB`\x02aP\x07V[\x90aN\xC9V[\x90aQ\xE5V[aSeaSv\x91aS_`\x08aO\x8EV[\x90aN\x83V[\x91aSp`\x04aO\xCCV[\x90aN\xC9V[\x90aQ\xCAV[aS\x93aS\xA4\x91aS\x8D`\x10aOPV[\x90aN\x83V[\x91aS\x9E`\x08aO\x8EV[\x90aN\xC9V[\x90aQ\xAEV[aS\xC1aS\xD2\x91aS\xBB` aO\x12V[\x90aN\x83V[\x91aS\xCC`\x10aOPV[\x90aN\xC9V[\x90aQ\x91V[aS\xEFaT\0\x91aS\xE9`@aN\xADV[\x90aN\x83V[\x91aS\xFA` aO\x12V[\x90aN\xC9V[\x90aQrV[aT\x1DaT.\x91aT\x17`\x80aNgV[\x90aN\x83V[\x91aT(`@aN\xADV[\x90aN\xC9V[\x90aQOV[\x90V[_R` _ \x01\x90V[\x93\x91\x90\x92aTMa\x1F.V[P[\x81aTbaT\\\x83a\x06\x08V[\x91a\x06\x08V[\x10\x15aT\xC8WaTs\x82\x82\x90a]\x1FV[\x90aT\x89_aT\x83\x88\x85\x90aT7V[\x01aE\x9DV[aT\x9BaT\x95\x87a\x14\xD6V[\x91a\x14\xD6V[\x11_\x14aT\xABWP\x91[\x91aTOV[\x92\x91PaT\xC2\x90aT\xBC`\x01a 8V[\x90a(\xAEV[\x90aT\xA5V[\x92PP\x91P\x90V[aT\xE2\x90aT\xDCa\x1F.V[Pa1pV[\x90V[\x90V[\x91\x90\x91\x80aT\xFEaT\xF8\x85a\x04\xD4V[\x91a\x04\xD4V[\x14\x15\x80aV|W[aU\x10W[PPPV[\x80aU+aU%aU _a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x03aU\xECW[P\x81aUMaUGaUB_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x03aUYW[\x80aU\x0BV[aU\xA0aU\x93aU\x9A\x92aUo`\n\x86\x90a)\xF1V[\x90aU\x8DaU\x87aU\x81`\x01\x93a]\xB8V[\x93a*\x07V[\x91aT\xE5V[\x90a^\x0BV[\x92\x90a*\nV[\x91a*\nV[\x91\x90\x91aU\xCD\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\nLV[\x92aU\xE2aU\xD9a\x04\x12V[\x92\x83\x92\x83a.8V[\x03\x90\xA2_\x80aUSV[aV+aV1aV$aV\x01`\n\x85\x90a)\xF1V[`\x02aV\x1EaV\x18aV\x12\x89a]\xB8V[\x93a*\x07V[\x91aT\xE5V[\x90a^\x0BV[\x92\x90a*\nV[\x91a*\nV[\x91\x90\x91aV^\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\nLV[\x92aVsaVja\x04\x12V[\x92\x83\x92\x83a.8V[\x03\x90\xA2_aU1V[P\x81aV\x90aV\x8A_a \nV[\x91a\x06\x08V[\x11aU\x06V[_aV\xAA\x91aV\xA3a\x1F.V[P\x01aEXV[\x90V[aV\xC1aV\xBCaV\xC6\x92a\x0E\xE1V[a\n!V[a\x06\x08V[\x90V[aV\xD2\x90aO\x12V[\x90RV[\x91` aV\xF7\x92\x94\x93aV\xF0`@\x82\x01\x96_\x83\x01\x90aV\xC9V[\x01\x90a\x06\x91V[V[aW\raW\x08aW\x12\x92a\x06\x08V[a\n!V[a\x0E\xE1V[\x90V[aW\x1Da1AV[P\x80aW5aW/c\xFF\xFF\xFF\xFFaV\xADV[\x91a\x06\x08V[\x11aWFWaWC\x90aV\xF9V[\x90V[` aWb_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01aV\xD6V[\x03\x90\xFD[aW}aW\x82\x91aWua\x1F.V[P`\x08a1ZV[a\n\x8AV[\x90V[\x90V[aW\x9CaW\x97aW\xA1\x92aW\x85V[a\x16QV[a\x07\x8CV[\x90V[aW\xAE`\xFFaW\x88V[\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90aW\xD4aW\xCD\x83a#,V[\x80\x94a#VV[\x91`\x01\x81\x16\x90\x81_\x14aX+WP`\x01\x14aW\xEFW[PPPV[aW\xFC\x91\x92\x93\x94PaW\xB1V[\x91_\x92[\x81\x84\x10aX\x13WPP\x01\x90_\x80\x80aW\xEAV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90aX\0V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80aW\xEAV[\x90aXP\x91aW\xBAV[\x90V[\x90aXsaXl\x92aXca\x04\x12V[\x93\x84\x80\x92aXFV[\x03\x83a$\x15V[V[aX~\x90aXSV[\x90V[\x90aX\x8Aa#\x13V[PaX\x94\x82a%\xC2V[aX\xADaX\xA7aX\xA2aW\xA4V[a\x07\x8CV[\x91a\x07\x8CV[\x14\x15_\x14aX\xC2WPaX\xBF\x90a^\x95V[\x90V[aX\xCC\x91PaXuV[\x90V[`B\x91aX\xDAa%\xBEV[P`@Q\x91\x7F\x19\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83R`\x02\x83\x01R`\"\x82\x01R \x90V[_\x90V[aY aY%\x91a\nnV[a\x1E\xEDV[\x90V[\x90V[aY?aY:aYD\x92aY(V[a\n!V[a\x06\x08V[\x90V[aY|aY\x83\x94aYr``\x94\x98\x97\x95aYh`\x80\x86\x01\x9A_\x87\x01\x90a\x07\xD0V[` \x85\x01\x90a\x08\xF7V[`@\x83\x01\x90a\x07\xD0V[\x01\x90a\x07\xD0V[V[aY\x8Da\x04\x12V[=_\x82>=\x90\xFD[\x93\x92\x93aY\xA0a!\x14V[PaY\xA9aY\x10V[PaY\xB2a%\xBEV[PaY\xBC\x85aY\x14V[aY\xEEaY\xE8\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0aY+V[\x91a\x06\x08V[\x11aZ{W\x90aZ\x11` \x94\x95_\x94\x93\x92\x93aZ\x08a\x04\x12V[\x94\x85\x94\x85aYGV[\x83\x80R\x03\x90`\x01Z\xFA\x15aZvWaZ)_Qa\x16QV[\x80aZDaZ>aZ9_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14aZZW_\x91aZT_a\x16VV[\x91\x92\x91\x90V[PaZd_a\x1E\xB8V[`\x01\x91aZp_a\x16VV[\x91\x92\x91\x90V[aY\x85V[PPPaZ\x87_a\x1E\xB8V[\x90`\x03\x92\x91\x92\x91\x90V[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x04\x11\x15aZ\xAFWV[aZ\x91V[\x90aZ\xBE\x82aZ\xA5V[V[\x80aZ\xD3aZ\xCD_aZ\xB4V[\x91aZ\xB4V[\x14_\x14aZ\xDEWPPV[\x80aZ\xF2aZ\xEC`\x01aZ\xB4V[\x91aZ\xB4V[\x14_\x14a[\x15W_c\xF6E\xEE\xDF`\xE0\x1B\x81R\x80a[\x11`\x04\x82\x01a\x05!V[\x03\x90\xFD[\x80a[)a[#`\x02aZ\xB4V[\x91aZ\xB4V[\x14_\x14a[WWa[Sa[<\x83aY\x14V[_\x91\x82\x91c\xFC\xE6\x98\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x06\x9EV[\x03\x90\xFD[a[ja[d`\x03aZ\xB4V[\x91aZ\xB4V[\x14a[rWPV[a[\x8D\x90_\x91\x82\x91c5\xE2\xF3\x83`\xE2\x1B\x83R`\x04\x83\x01a\x07\xDDV[\x03\x90\xFD[_R` _ \x90V[a[\xA3\x81aEXV[\x82\x10\x15a[\xBDWa[\xB5`\x01\x91a[\x91V[\x91\x02\x01\x90_\x90V[a\x16\xBEV[\x90a[\xCC\x90a\x14\xD6V[\x90RV[\x90a[\xDA\x90a\x1C\x91V[\x90RV[\x90a\\\x14a\\\x0B_a[\xEEa=\x16V[\x94a\\\x05a[\xFD\x83\x83\x01aE\x9DV[\x83\x88\x01a[\xC2V[\x01aE\xCFV[` \x84\x01a[\xD0V[V[a\\\x1F\x90a[\xDEV[\x90V[a\\@\x91_a\\:\x92a\\3a=QV[P\x01a[\x9AV[Pa\\\x16V[\x90V[\x92\x91a\\Q\x84\x83\x83\x91a^\xC5V[\x83a\\la\\fa\\a_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14a\\\x81W[a\\\x7F\x92\x93\x91\x90\x91a`OV[V[a\\\x89a$\xA4V[\x93a\\\x92a`4V[\x94\x80a\\\xA6a\\\xA0\x88a\x06\x08V[\x91a\x06\x08V[\x11a\\\xB3WP\x93Pa\\rV[\x85\x90a\\\xCF_\x92\x83\x92c\x0EX\xAE\x93`\xE1\x1B\x84R`\x04\x84\x01a.8V[\x03\x90\xFD[a\\\xDBa\x1F.V[P\x15\x15\x90V[a\\\xF5a\\\xF0a\\\xFA\x92aP\x04V[a\n!V[a\x06\x08V[\x90V[a]\ta]\x0F\x91a\x06\x08V[\x91a\x06\x08V[\x90\x81\x15a]\x1AW\x04\x90V[aP\x88V[a]Da]J\x92a].a\x1F.V[P\x82\x81\x16\x92\x18a]>`\x02a\\\xE1V[\x90a\\\xFDV[\x90a(\xAEV[\x90V[\x90V[a]da]_a]i\x92a]MV[a\n!V[a\x08\xF1V[\x90V[a]u\x90a]PV[\x90RV[\x91` a]\x9A\x92\x94\x93a]\x93`@\x82\x01\x96_\x83\x01\x90a]lV[\x01\x90a\x06\x91V[V[a]\xB0a]\xABa]\xB5\x92a\x06\x08V[a\n!V[a\x1C\x91V[\x90V[a]\xC0a\x1D\x80V[P\x80a]\xDAa]\xD4`\x01\x80`\xD0\x1B\x03a*\nV[\x91a\x06\x08V[\x11a]\xEBWa]\xE8\x90a]\x9CV[\x90V[`\xD0a^\x07_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01a]yV[\x03\x90\xFD[\x90a^Aa^G\x93\x92a^\x1Ca\x1D\x80V[Pa^%a\x1D\x80V[P\x80\x93a^:a^3a7\x19V[\x94\x92aH\xC1V[\x90\x91ad\xB7V[\x91aa\x0EV[\x91\x90\x91\x90V[a^aa^\\a^f\x92aO\x0FV[a\n!V[a\x06\x08V[\x90V[6\x907V[\x90a^\x93a^{\x83a+\xD8V[\x92` \x80a^\x89\x86\x93a+\xB5V[\x92\x01\x91\x03\x90a^iV[V[a^\x9Da#\x13V[Pa^\xA7\x81aaxV[\x90a^\xBAa^\xB5` a^MV[a^nV[\x91\x82R` \x82\x01R\x90V[\x91\x90\x91\x80a^\xE3a^\xDDa^\xD8_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14_\x14a_\xC4Wa_\x07a_\0\x83a^\xFB`\x02a\n\x8AV[a(\xAEV[`\x02a.~V[[\x82a_#a_\x1Da_\x18_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14_\x14a_\x98Wa_Ga_@\x83a_;`\x02a\n\x8AV[a?\xCDV[`\x02a.~V[[\x91\x90\x91a_\x93a_\x81a_{\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x93a\nLV[\x93a\nLV[\x93a_\x8Aa\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xA3V[a_\xBF\x82a_\xB9a_\xAA_\x87\x90a1ZV[\x91a_\xB4\x83a\n\x8AV[aP\xBEV[\x90a.~V[a_HV[a_\xD7a_\xD2_\x83\x90a1ZV[a\n\x8AV[\x80a_\xEAa_\xE4\x85a\x06\x08V[\x91a\x06\x08V[\x10a`\x12Wa_\xFDa`\r\x91\x84\x90a?\xCDV[a`\x08_\x84\x90a1ZV[a.~V[a_\x08V[\x90a`0\x90\x91\x92_\x93\x84\x93c9\x144\xE3`\xE2\x1B\x85R`\x04\x85\x01a=\xE6V[\x03\x90\xFD[a`<a\x1F.V[Pa`L`\x01\x80`\xD0\x1B\x03a*\nV[\x90V[\x91a`\xA7a`\xA1a`\xAE\x94\x80a`ua`oa`j_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14a`\xDFW[\x84a`\x96a`\x90a`\x8B_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14a`\xB0W[a,\xC7V[\x92a,\xC7V[\x90\x91aT\xE8V[V[a`\xD8`\x0B`\x02a`\xD2a`\xCCa`\xC6\x89a]\xB8V[\x93a*\x07V[\x91aT\xE5V[\x90a^\x0BV[PPa`\x9CV[aa\x07`\x0B`\x01aa\x01a`\xFBa`\xF5\x89a]\xB8V[\x93a*\x07V[\x91aT\xE5V[\x90a^\x0BV[PPa`{V[\x91aa2_aa7\x94aa\x1Fa\x1D\x80V[Paa(a\x1D\x80V[P\x01\x92\x91\x92aE{V[aciV[\x91\x90\x91\x90V[aaQaaLaaV\x92aW\x85V[a\n!V[a\x06\x08V[\x90V[\x90V[aapaakaau\x92aaYV[a\n!V[a\x06\x08V[\x90V[aa\x8Daa\x92\x91aa\x87a\x1F.V[Pa%\xC2V[aY\x14V[aa\x9C`\xFFaa=V[\x16\x80aa\xB1aa\xAB`\x1Faa\\V[\x91a\x06\x08V[\x11aa\xB9W\x90V[_c,\xD4J\xC3`\xE2\x1B\x81R\x80aa\xD1`\x04\x82\x01a\x05!V[\x03\x90\xFD[T\x90V[aa\xE3`@a'\xA3V[\x90V[_R` _ \x90V[aa\xF8\x81aa\xD5V[\x82\x10\x15ab\x12Wab\n`\x01\x91aa\xE6V[\x91\x02\x01\x90_\x90V[a\x16\xBEV[ab!\x90Qa\x14\xD6V[\x90V[\x90ab5e\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x16QV[\x91\x81\x19\x16\x91\x16\x17\x90V[abSabNabX\x92a\x14\xD6V[a\n!V[a\x14\xD6V[\x90V[\x90V[\x90absabnabz\x92ab?V[ab[V[\x82Tab$V[\x90UV[ab\x88\x90Qa\x1C\x91V[\x90V[`0\x1B\x90V[\x90ab\xA3e\xFF\xFF\xFF\xFF\xFF\xFF\x19\x91ab\x8BV[\x91\x81\x19\x16\x91\x16\x17\x90V[ab\xC1ab\xBCab\xC6\x92a\x1C\x91V[a\n!V[a\x1C\x91V[\x90V[\x90V[\x90ab\xE1ab\xDCab\xE8\x92ab\xADV[ab\xC9V[\x82Tab\x91V[\x90UV[\x90ac\x16` _ac\x1C\x94ac\x0E\x82\x82\x01ac\x08\x84\x88\x01ab\x17V[\x90ab^V[\x01\x92\x01ab~V[\x90ab\xCCV[V[\x91\x90ac/Wac-\x91ab\xECV[V[a\x1F\x9BV[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15acdW\x82ac\\\x91`\x01acb\x95\x01\x81Uaa\xEFV[\x90ac\x1EV[V[a$\x01V[\x90\x92\x91\x92acua\x1D\x80V[Pac~a\x1D\x80V[Pac\x88\x82aa\xD5V[\x80ac\x9Bac\x95_a \nV[\x91a\x06\x08V[\x11_\x14adkWac\xC1\x90ac\xBB\x84\x91ac\xB5`\x01a 8V[\x90a TV[\x90aT7V[\x90ac\xCD_\x83\x01aE\x9DV[\x92ac\xD9_\x84\x01aE\xCFV[\x93\x80ac\xEDac\xE7\x85a\x14\xD6V[\x91a\x14\xD6V[\x11adOWad\x04ac\xFE\x84a\x14\xD6V[\x91a\x14\xD6V[\x14_\x14ad\x1FWPPad\x1A\x90_\x85\x91\x01ab\xCCV[[\x91\x90V[adJ\x92PadE\x86ad<ad3aa\xD9V[\x94_\x86\x01a[\xC2V[` \x84\x01a[\xD0V[ac4V[ad\x1BV[_c% `\x1D`\xE0\x1B\x81R\x80adg`\x04\x82\x01a\x05!V[\x03\x90\xFD[Pad\x96\x91ad\x91\x85ad\x88ad\x7Faa\xD9V[\x94_\x86\x01a[\xC2V[` \x84\x01a[\xD0V[ac4V[ad\x9F_aE\xDCV[\x91\x90V[cNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[\x91\x90\x91\x80`\x01\x14ad\xD6W`\x02\x03ad\xA3Wad\xD2\x91a\x1D\xFFV[\x90[V[Pad\xE0\x91a\x1D\xC0V[\x90ad\xD4V",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361015610013575b611d7c565b61001d5f3561040c565b806301ffc9a71461040757806304df017d1461040257806306fdde03146103fd578063095ea7b3146103f857806318160ddd146103f357806318bf5077146103ee57806323b872dd146103e9578063248a9ca3146103e45780632b8c49e3146103df5780632f2ff15d146103da57806330d3e8eb146103d5578063313ce567146103d05780633644e515146103cb57806336568abe146103c65780633a46b1a8146103c157806340c10f19146103bc578063427ac0ca146103b757806342966c68146103b25780634bdd36ce146103ad5780634bf5d7e9146103a85780634f1bfc9e146103a3578063587cde1e1461039e5780635a5db1bb146103995780635c19a95c1461039457806363a0daac1461038f578063651455341461038a5780636a96e3ed146103855780636fcfff451461038057806370a082311461037b57806372cbdcc81461037657806378fb7fd21461037157806379cc67901461036c5780637a8cd156146103675780637ecebe001461036257806383f1211b1461035d5780638426adf214610358578063844c90261461035357806384b0196e1461034e5780638a542521146103495780638d3343d6146103445780638e539e8c1461033f578063902d55a51461033a57806391d148541461033557806391ddadf41461033057806394aa22f21461032b57806395d89b41146103265780639ab24eb0146103215780639b7ef64b1461031c578063a217fddf14610317578063a3c4470514610312578063a9059cbb1461030d578063aa082a9d14610308578063b0ca253e14610303578063bb4d4436146102fe578063c02ae754146102f9578063c3cda520146102f4578063c4fc45a8146102ef578063c9ab0006146102ea578063d505accf146102e5578063d547741f146102e0578063dd62ed3e146102db578063f1127ed8146102d65763f75e85120361000e57611d47565b611ce2565b611bfe565b611b9d565b611b63565b611abf565b611a3a565b611960565b6118a4565b61186f565b611839565b611804565b611799565b611764565b611689565b611619565b6115a2565b61156d565b611538565b611503565b6114a0565b61146b565b6113f4565b6113bf565b61135b565b6112f0565b6111ab565b611176565b61111d565b6110e8565b6110b3565b61107f565b61104a565b611015565b610f41565b610f0c565b610eac565b610e1e565b610dea565b610d7d565b610d48565b610d13565b610cbc565b610c4e565b610c19565b610be6565b610b8c565b6109ed565b6109b7565b610983565b61094e565b610919565b6108bc565b610888565b610827565b6107f2565b610756565b6106e8565b6106b3565b61065b565b6105d3565b610526565b610494565b60e01c90565b60405190565b5f80fd5b5f80fd5b63ffffffff60e01b1690565b61043581610420565b0361043c57565b5f80fd5b9050359061044d8261042c565b565b9060208282031261046857610465915f01610440565b90565b61041c565b151590565b61047b9061046d565b9052565b9190610492905f60208501940190610472565b565b346104c4576104c06104af6104aa36600461044f565b611e19565b6104b7610412565b9182918261047f565b0390f35b610418565b60018060a01b031690565b6104dd906104c9565b90565b6104e9816104d4565b036104f057565b5f80fd5b90503590610501826104e0565b565b9060208282031261051c57610519915f016104f4565b90565b61041c565b5f0190565b346105545761053e610539366004610503565b612308565b610546610412565b8061055081610521565b0390f35b610418565b5f91031261056357565b61041c565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b6105a96105b26020936105b7936105a081610568565b9384809361056c565b95869101610575565b610580565b0190565b6105d09160208201915f81840391015261058a565b90565b34610603576105e3366004610559565b6105ff6105ee61246c565b6105f6610412565b918291826105bb565b0390f35b610418565b90565b61061481610608565b0361061b57565b5f80fd5b9050359061062c8261060b565b565b9190604083820312610656578061064a610653925f86016104f4565b9360200161061f565b90565b61041c565b3461068c5761068861067761067136600461062e565b90612482565b61067f610412565b9182918261047f565b0390f35b610418565b61069a90610608565b9052565b91906106b1905f60208501940190610691565b565b346106e3576106c3366004610559565b6106df6106ce6124a4565b6106d6610412565b9182918261069e565b0390f35b610418565b34610717576107016106fb36600461062e565b906124ba565b610709610412565b8061071381610521565b0390f35b610418565b90916060828403126107515761074e610737845f85016104f4565b9361074581602086016104f4565b9360400161061f565b90565b61041c565b346107875761078361077261076c36600461071c565b9161258f565b61077a610412565b9182918261047f565b0390f35b610418565b90565b6107988161078c565b0361079f57565b5f80fd5b905035906107b08261078f565b565b906020828203126107cb576107c8915f016107a3565b90565b61041c565b6107d99061078c565b9052565b91906107f0905f602085019401906107d0565b565b346108225761081e61080d6108083660046107b2565b612608565b610815610412565b918291826107dd565b0390f35b610418565b346108565761084061083a36600461062e565b9061262a565b610848610412565b8061085281610521565b0390f35b610418565b91906040838203126108835780610877610880925f86016107a3565b936020016104f4565b90565b61041c565b346108b7576108a161089b36600461085b565b9061277b565b6108a9610412565b806108b381610521565b0390f35b610418565b346108ec576108e86108d76108d2366004610503565b6128d3565b6108df610412565b9182918261069e565b0390f35b610418565b60ff1690565b610900906108f1565b9052565b9190610917905f602085019401906108f7565b565b3461094957610929366004610559565b61094561093461297f565b61093c610412565b91829182610904565b0390f35b610418565b3461097e5761095e366004610559565b61097a610969612995565b610971610412565b918291826107dd565b0390f35b610418565b346109b25761099c61099636600461085b565b906129a9565b6109a4610412565b806109ae81610521565b0390f35b610418565b346109e8576109e46109d36109cd36600461062e565b90612a26565b6109db610412565b9182918261069e565b0390f35b610418565b34610a1c57610a06610a0036600461062e565b90612b44565b610a0e610412565b80610a1881610521565b0390f35b610418565b90565b610a38610a33610a3d926104c9565b610a21565b6104c9565b90565b610a4990610a24565b90565b610a5590610a40565b90565b90610a6290610a4c565b5f5260205260405f2090565b5f1c90565b90565b610a82610a8791610a6e565b610a73565b90565b610a949054610a76565b90565b60ff1690565b610aa9610aae91610a6e565b610a97565b90565b610abb9054610a9d565b90565b610ac990600d610a58565b610ad45f8201610a8a565b91610ae160018301610a8a565b91610aee60028201610a8a565b91610afb60038301610a8a565b91610b0860048201610a8a565b91610b216006610b1a60058501610a8a565b9301610ab1565b90565b949290979695939160e08601985f8701610b3d91610691565b60208601610b4a91610691565b60408501610b5791610691565b60608401610b6491610691565b60808301610b7191610691565b60a08201610b7e91610691565b60c001610b8a91610472565b565b34610bc357610bbf610ba7610ba2366004610503565b610abe565b93610bb6979597939193610412565b97889788610b24565b0390f35b610418565b90602082820312610be157610bde915f0161061f565b90565b61041c565b34610c1457610bfe610bf9366004610bc8565b612b50565b610c06610412565b80610c1081610521565b0390f35b610418565b34610c4957610c29366004610559565b610c45610c34612b90565b610c3c610412565b9182918261069e565b0390f35b610418565b34610c7e57610c5e366004610559565b610c7a610c69612c3a565b610c71610412565b918291826105bb565b0390f35b610418565b90565b610c9a610c95610c9f92610c83565b610a21565b610608565b90565b610cae6276a700610c86565b90565b610cb9610ca2565b90565b34610cec57610ccc366004610559565b610ce8610cd7610cb1565b610cdf610412565b9182918261069e565b0390f35b610418565b610cfa906104d4565b9052565b9190610d11905f60208501940190610cf1565b565b34610d4357610d3f610d2e610d29366004610503565b612cc7565b610d36610412565b91829182610cfe565b0390f35b610418565b34610d7857610d74610d63610d5e366004610bc8565b612d8e565b610d6b610412565b91829182610cfe565b0390f35b610418565b34610dab57610d95610d90366004610503565b612dd3565b610d9d610412565b80610da781610521565b0390f35b610418565b9091606082840312610de557610de2610dcb845f85016104f4565b93610dd9816020860161061f565b9360400161061f565b90565b61041c565b34610e1957610e03610dfd366004610db0565b9161311e565b610e0b610412565b80610e1581610521565b0390f35b610418565b34610e4e57610e2e366004610559565b610e4a610e3961312b565b610e41610412565b9182918261069e565b0390f35b610418565b90610e5d90610a4c565b5f5260205260405f2090565b1c90565b610e7d906008610e829302610e69565b610a97565b90565b90610e909154610e6d565b90565b610ea990610ea4600f915f92610e53565b610e85565b90565b34610edc57610ed8610ec7610ec2366004610503565b610e93565b610ecf610412565b9182918261047f565b0390f35b610418565b63ffffffff1690565b610ef390610ee1565b9052565b9190610f0a905f60208501940190610eea565b565b34610f3c57610f38610f27610f22366004610503565b613145565b610f2f610412565b91829182610ef7565b0390f35b610418565b34610f7157610f6d610f5c610f57366004610503565b613170565b610f64610412565b9182918261069e565b0390f35b610418565b5190565b60209181520190565b60200190565b610f92906104d4565b9052565b90610fa381602093610f89565b0190565b60200190565b90610fca610fc4610fbd84610f76565b8093610f7a565b92610f83565b905f5b818110610fda5750505090565b909192610ff3610fed6001928651610f96565b94610fa7565b9101919091610fcd565b6110129160208201915f818403910152610fad565b90565b3461104557611025366004610559565b611041611030613241565b611038610412565b91829182610ffd565b0390f35b610418565b3461107a57611076611065611060366004610503565b613257565b61106d610412565b9182918261047f565b0390f35b610418565b346110ae5761109861109236600461062e565b906133bc565b6110a0610412565b806110aa81610521565b0390f35b610418565b346110e3576110c3366004610559565b6110df6110ce6133c8565b6110d6610412565b9182918261069e565b0390f35b610418565b34611118576111146111036110fe366004610503565b613440565b61110b610412565b9182918261069e565b0390f35b610418565b3461114d5761112d366004610559565b611149611138613455565b611140610412565b9182918261047f565b0390f35b610418565b7f000000000000000000000000000000000000000000000000000000000000000090565b346111a657611186366004610559565b6111a2611191611152565b611199610412565b9182918261069e565b0390f35b610418565b346111d9576111c36111be366004610bc8565b6135a8565b6111cb610412565b806111d581610521565b0390f35b610418565b60ff60f81b1690565b6111f0906111de565b9052565b5190565b60209181520190565b60200190565b61121090610608565b9052565b9061122181602093611207565b0190565b60200190565b9061124861124261123b846111f4565b80936111f8565b92611201565b905f5b8181106112585750505090565b90919261127161126b6001928651611214565b94611225565b910191909161124b565b939591946112cc6112c16112e0956112b36112d6956112ed9c9a6112a660e08c01925f8d01906111e7565b8a820360208c015261058a565b9088820360408a015261058a565b976060870190610691565b6080850190610cf1565b60a08301906107d0565b60c081840391015261122b565b90565b3461132757611300366004610559565b61132361130b613630565b9361131a979597939193610412565b9788978861127b565b0390f35b610418565b7f84fe74c71a28b69aa960486ca0e8c1418c86e9ea2cd6b5849b95e2c8f407a67490565b61135861132c565b90565b3461138b5761136b366004610559565b611387611376611350565b61137e610412565b918291826107dd565b0390f35b610418565b7f9b12e0c5707e494915e58b0564f18aaad9b74ac69bfc815a1edadc8e4bd032eb90565b6113bc611390565b90565b346113ef576113cf366004610559565b6113eb6113da6113b4565b6113e2610412565b918291826107dd565b0390f35b610418565b346114245761142061140f61140a366004610bc8565b6136ba565b611417610412565b9182918261069e565b0390f35b610418565b90565b61144061143b61144592611429565b610a21565b610608565b90565b61145d6b033b2e3c9fd0803ce800000061142c565b90565b611468611448565b90565b3461149b5761147b366004610559565b611497611486611460565b61148e610412565b9182918261069e565b0390f35b610418565b346114d1576114cd6114bc6114b636600461085b565b906136eb565b6114c4610412565b9182918261047f565b0390f35b610418565b65ffffffffffff1690565b6114ea906114d6565b9052565b9190611501905f602085019401906114e1565b565b3461153357611513366004610559565b61152f61151e613719565b611526610412565b918291826114ee565b0390f35b610418565b346115685761156461155361154e366004610503565b61372d565b61155b610412565b9182918261069e565b0390f35b610418565b3461159d5761157d366004610559565b6115996115886137b4565b611590610412565b918291826105bb565b0390f35b610418565b346115d2576115ce6115bd6115b8366004610503565b6137ca565b6115c5610412565b9182918261069e565b0390f35b610418565b90565b6115ee6115e96115f3926115d7565b610a21565b610608565b90565b61160b6b02e87669c308736a040000006115da565b90565b6116166115f6565b90565b3461164957611629366004610559565b61164561163461160e565b61163c610412565b9182918261069e565b0390f35b610418565b90565b5f1b90565b61166a61166561166f9261164e565b611651565b61078c565b90565b61167b5f611656565b90565b611686611672565b90565b346116b957611699366004610559565b6116b56116a461167e565b6116ac610412565b918291826107dd565b0390f35b610418565b634e487b7160e01b5f52603260045260245ffd5b5490565b5f5260205f2090565b6116e8816116d2565b821015611702576116fa6001916116d6565b910201905f90565b6116be565b60018060a01b031690565b6117229060086117279302610e69565b611707565b90565b906117359154611712565b90565b600e611743816116d2565b8210156117605761175d91611757916116df565b9061172a565b90565b5f80fd5b346117945761179061177f61177a366004610bc8565b611738565b611787610412565b91829182610cfe565b0390f35b610418565b346117ca576117c66117b56117af36600461062e565b906137f9565b6117bd610412565b9182918261047f565b0390f35b610418565b6117df9060086117e49302610e69565b610a73565b90565b906117f291546117cf565b90565b611801600c5f906117e7565b90565b3461183457611814366004610559565b61183061181f6117f5565b611827610412565b9182918261069e565b0390f35b610418565b3461186a5761186661185561184f36600461062e565b9061381b565b61185d610412565b9182918261069e565b0390f35b610418565b3461189f5761189b61188a611885366004610503565b613831565b611892610412565b9182918261069e565b0390f35b610418565b346118d4576118b4366004610559565b6118d06118bf613846565b6118c7610412565b9182918261069e565b0390f35b610418565b6118e2816108f1565b036118e957565b5f80fd5b905035906118fa826118d9565b565b909160c08284031261195b57611914835f84016104f4565b92611922816020850161061f565b92611930826040830161061f565b9261195861194184606085016118ed565b9361194f81608086016107a3565b9360a0016107a3565b90565b61041c565b346119955761197f6119733660046118fc565b949390939291926138c6565b611987610412565b8061199181610521565b0390f35b610418565b6119a39061046d565b9052565b9060c080611a23936119bf5f8201515f860190611207565b6119d160208201516020860190611207565b6119e360408201516040860190611207565b6119f560608201516060860190611207565b611a0760808201516080860190611207565b611a1960a082015160a0860190611207565b015191019061199a565b565b9190611a38905f60e085019401906119a7565b565b34611a6a57611a66611a55611a50366004610503565b6139ed565b611a5d610412565b91829182611a25565b0390f35b610418565b611a788161046d565b03611a7f57565b5f80fd5b90503590611a9082611a6f565b565b9190604083820312611aba5780611aae611ab7925f86016104f4565b93602001611a83565b90565b61041c565b34611aee57611ad8611ad2366004611a92565b90613b00565b611ae0610412565b80611aea81610521565b0390f35b610418565b60e081830312611b5e57611b09825f83016104f4565b92611b1783602084016104f4565b92611b25816040850161061f565b92611b33826060830161061f565b92611b5b611b4484608085016118ed565b93611b528160a086016107a3565b9360c0016107a3565b90565b61041c565b34611b9857611b82611b76366004611af3565b95949094939193613bae565b611b8a610412565b80611b9481610521565b0390f35b610418565b34611bcc57611bb6611bb036600461085b565b90613ccc565b611bbe610412565b80611bc881610521565b0390f35b610418565b9190604083820312611bf95780611bed611bf6925f86016104f4565b936020016104f4565b90565b61041c565b34611c2f57611c2b611c1a611c14366004611bd1565b90613cee565b611c22610412565b9182918261069e565b0390f35b610418565b611c3d81610ee1565b03611c4457565b5f80fd5b90503590611c5582611c34565b565b9190604083820312611c7f5780611c73611c7c925f86016104f4565b93602001611c48565b90565b61041c565b611c8d906114d6565b9052565b60018060d01b031690565b611ca590611c91565b9052565b90602080611ccb93611cc15f8201515f860190611c84565b0151910190611c9c565b565b9190611ce0905f60408501940190611ca9565b565b34611d1357611d0f611cfe611cf8366004611c57565b90613d5c565b611d06610412565b91829182611ccd565b0390f35b610418565b7fcce296b040332a080e6df13515a3ec2869e21cd20f7344af0987ddb938d8bd2190565b611d44611d18565b90565b34611d7757611d57366004610559565b611d73611d62611d3c565b611d6a610412565b918291826107dd565b0390f35b610418565b5f80fd5b5f90565b634e487b7160e01b5f52601160045260245ffd5b611da4611daa91611c91565b91611c91565b019060018060d01b038211611dbb57565b611d84565b90611dd391611dcd611d80565b50611d98565b90565b611de2611de891611c91565b91611c91565b90039060018060d01b038211611dfa57565b611d84565b90611e1291611e0c611d80565b50611dd6565b90565b5f90565b611e21611e15565b5080611e3c611e36630cccc66560e21b610420565b91610420565b148015611e60575b908115611e50575b5090565b611e5a9150613d72565b5f611e4c565b5080611e7b611e7563b2752ac960e01b610420565b91610420565b14611e44565b611e9a90611e95611e90611d18565b613db2565b61215b565b565b611eb0611eab611eb59261164e565b610a21565b6104c9565b90565b611ec190611e9c565b90565b1b90565b91906008611ee3910291611edd5f1984611ec4565b92611ec4565b9181191691161790565b611f01611efc611f0692610608565b610a21565b610608565b90565b90565b9190611f22611f1d611f2a93611eed565b611f09565b908354611ec8565b9055565b5f90565b611f4491611f3e611f2e565b91611f0c565b565b60065f91611f5683808301611f32565b611f638360018301611f32565b611f708360028301611f32565b611f7d8360038301611f32565b611f8a8360048301611f32565b611f978360058301611f32565b0155565b634e487b7160e01b5f525f60045260245ffd5b905f03611fc057611fbe90611f46565b565b611f9b565b90611fd160ff91611651565b9181191691161790565b611fe49061046d565b90565b90565b90611fff611ffa61200692611fdb565b611fe7565b8254611fc5565b9055565b61201e6120196120239261164e565b610a21565b610608565b90565b60016120329101610608565b90565b90565b61204c61204761205192612035565b610a21565b610608565b90565b61206361206991939293610608565b92610608565b820391821161207457565b611d84565b9190600861209991029161209360018060a01b0384611ec4565b92611ec4565b9181191691161790565b90565b91906120bc6120b76120c493610a4c565b6120a3565b908354612079565b9055565b90565b634e487b7160e01b5f52603160045260245ffd5b5490565b5f5260205f2090565b6120f5816120df565b82101561210f576121076001916120e3565b910201905f90565b6116be565b5f90565b61212a91612124612114565b916120a6565b565b612135816120df565b801561215657600190039061215361214d83836120ec565b90612118565b55565b6120cb565b8061217661217061216b5f611eb8565b6104d4565b916104d4565b146122ec5761219861219261218d600f8490610e53565b610ab1565b1561046d565b6122cd576121b15f6121ac600d8490610a58565b611fae565b6121c65f6121c1600f8490610e53565b611fea565b6121cf5f61200a565b5b806121ec6121e66121e1600e6116d2565b610608565b91610608565b10156122c757612207612201600e83906116df565b9061172a565b612219612213846104d4565b916104d4565b1461222c5761222790612026565b6121d0565b6122729061226c61226461225e600e612258612248600e6116d2565b6122526001612038565b90612054565b906116df565b9061172a565b91600e6116df565b906120a6565b61228461227f600e6120c8565b61212c565b5b6122af7f5d9d5034656cb3ebfb0655057cd7f9b4077a9b42ff42ce223cbac5bc586d212691610a4c565b906122b8610412565b806122c281610521565b0390a2565b50612285565b6122e8905f918291636585b60d60e01b835260048301610cfe565b0390fd5b5f63d92e233d60e01b81528061230460048201610521565b0390fd5b61231190611e81565b565b606090565b634e487b7160e01b5f52602260045260245ffd5b906001600283049216801561234c575b602083101461234757565b612318565b91607f169161233c565b60209181520190565b5f5260205f2090565b905f929180549061238261237b8361232c565b8094612356565b916001811690815f146123d9575060011461239d575b505050565b6123aa919293945061235f565b915f925b8184106123c157505001905f8080612398565b600181602092959395548486015201910192906123ae565b92949550505060ff19168252151560200201905f8080612398565b906123fe91612368565b90565b634e487b7160e01b5f52604160045260245ffd5b9061241f90610580565b810190811067ffffffffffffffff82111761243957604052565b612401565b9061245e6124579261244e610412565b938480926123f4565b0383612415565b565b6124699061243e565b90565b612474612313565b5061247f6003612460565b90565b61249f9161248e611e15565b50612497613dc6565b919091613dd3565b600190565b6124ac611f2e565b506124b76002610a8a565b90565b806124d56124cf6124ca5f611eb8565b6104d4565b916104d4565b1461257357816124ed6124e75f61200a565b91610608565b14612557576124fd338390613e18565b612508818390613f6f565b339061255261254061253a7fde22baff038e3a3e08407cbdf617deed74e869a7ba517df611e33131c6e6ea0493610a4c565b93610a4c565b93612549610412565b9182918261069e565b0390a3565b5f631f2a200560e01b81528061256f60048201610521565b0390fd5b5f63d92e233d60e01b81528061258b60048201610521565b0390fd5b916125b99261259c611e15565b506125b16125a8613dc6565b82908491613fdb565b919091614067565b600190565b5f90565b6125cb9061078c565b90565b906125d8906125c2565b5f5260205260405f2090565b90565b6125f36125f891610a6e565b6125e4565b90565b61260590546125e7565b90565b6001612621612627926126196125be565b5060056125ce565b016125fb565b90565b8061264561263f61263a5f611eb8565b6104d4565b916104d4565b14612735578161265d6126575f61200a565b91610608565b146127195761266d338390614104565b3361268061267a836104d4565b916104d4565b036126e0575b61269181839061425c565b33906126db6126c96126c37fb90795a66650155983e242cac3e1ac1a4dc26f8ed2987f3ce416a34e00111fd493610a4c565b93610a4c565b936126d2610412565b9182918261069e565b0390a3565b6126eb813390613cee565b6126fd6126f75f61200a565b91610608565b03612708575b612686565b61271481338491613fdb565b612703565b5f631f2a200560e01b81528061273160048201610521565b0390fd5b5f63d92e233d60e01b81528061274d60048201610521565b0390fd5b9061276c9161276761276282612608565b613db2565b61276e565b565b90612778916142bb565b50565b9061278591612751565b565b9061279190610608565b9052565b9061279f9061046d565b9052565b906127b66127af610412565b9283612415565b565b6127c260e06127a3565b90565b9061287461286b60066127d66127b8565b946127ed6127e55f8301610a8a565b5f8801612787565b6128056127fc60018301610a8a565b60208801612787565b61281d61281460028301610a8a565b60408801612787565b61283561282c60038301610a8a565b60608801612787565b61284d61284460048301610a8a565b60808801612787565b61286561285c60058301610a8a565b60a08801612787565b01610ab1565b60c08401612795565b565b61287f906127c5565b90565b61288c9051610608565b90565b90565b6128a66128a16128ab9261288f565b610a21565b610608565b90565b6128bd6128c391939293610608565b92610608565b82018092116128ce57565b611d84565b6128ea6128ef916128e2611f2e565b50600d610a58565b612876565b4261292261291c61291761290560608601612882565b61291162015180612892565b906128ae565b610608565b91610608565b101561294d578061294460a061293d602061294a9501612882565b9201612882565b90612054565b90565b60206129599101612882565b90565b5f90565b90565b61297761297261297c92612960565b610a21565b6108f1565b90565b61298761295c565b506129926012612963565b90565b61299d6125be565b506129a6614367565b90565b90806129c46129be6129b9613dc6565b6104d4565b916104d4565b036129d5576129d291614421565b50565b5f63334bd91960e11b8152806129ed60048201610521565b0390fd5b906129fb90610a4c565b5f5260205260405f2090565b90565b612a1e612a19612a2392611c91565b610a21565b610608565b90565b612a5d91612a52612a4c612a47612a5894612a3f611f2e565b50600a6129f1565b612a07565b91614502565b906145f8565b612a0a565b90565b90612a7a91612a75612a70611390565b613db2565b612a7c565b565b9081612a98612a92612a8d5f611eb8565b6104d4565b916104d4565b14612b285780612ab0612aaa5f61200a565b91610608565b14612b0c57612ac7612ac06124a4565b82906128ae565b612ae0612ada612ad5611448565b610608565b91610608565b11612af057612aee91613f6f565b565b5f63177e3fc360e01b815280612b0860048201610521565b0390fd5b5f631f2a200560e01b815280612b2460048201610521565b0390fd5b5f63d92e233d60e01b815280612b4060048201610521565b0390fd5b90612b4e91612a60565b565b80612b63612b5d5f61200a565b91610608565b14612b7457612b72903361425c565b565b5f631f2a200560e01b815280612b8c60048201610521565b0390fd5b612b98611f2e565b50612bb2612ba4611448565b612bac6124a4565b90612054565b90565b67ffffffffffffffff8111612bd357612bcf602091610580565b0190565b612401565b90612bea612be583612bb5565b6127a3565b918252565b5f7f6d6f64653d626c6f636b6e756d6265722666726f6d3d64656661756c74000000910152565b612c20601d612bd8565b90612c2d60208301612bef565b565b612c37612c16565b90565b612c42612313565b50612c4b613719565b612c64612c5e612c5961471f565b6114d6565b916114d6565b03612c7457612c71612c2f565b90565b5f6301bfc1c560e61b815280612c8c60048201610521565b0390fd5b90612c9a90610a4c565b5f5260205260405f2090565b612cb2612cb791610a6e565b611707565b90565b612cc49054612ca6565b90565b612cde612ce391612cd6612114565b506009612c90565b612cba565b90565b60207f6f7574206f6620626f756e647300000000000000000000000000000000000000917f53796e646963617465546f6b656e43726f7373636861696e3a20696e646578205f8201520152565b612d40602d60409261056c565b612d4981612ce6565b0190565b612d629060208101905f818303910152612d33565b90565b15612d6c57565b612d74610412565b62461bcd60e51b815280612d8a60048201612d4d565b0390fd5b612dca612dd091612d9d612114565b50612dc381612dbd612db7612db2600e6116d2565b610608565b91610608565b10612d65565b600e6116df565b9061172a565b90565b612de490612ddf613dc6565b61476f565b565b90612e019291612dfc612df7611d18565b613db2565b612f67565b565b9081549168010000000000000000831015612e335782612e2b916001612e31950181556120ec565b906120a6565b565b612401565b916020612e59929493612e5260408201965f830190610691565b0190610691565b565b612e6560e06127a3565b90565b90612e745f1991611651565b9181191691161790565b90612e93612e8e612e9a92611eed565b611f09565b8254612e68565b9055565b612ea8905161046d565b90565b90612f5360c06006612f5994612ece5f8201612ec85f8801612882565b90612e7e565b612ee760018201612ee160208801612882565b90612e7e565b612f0060028201612efa60408801612882565b90612e7e565b612f1960038201612f1360608801612882565b90612e7e565b612f3260048201612f2c60808801612882565b90612e7e565b612f4b60058201612f4560a08801612882565b90612e7e565b019201612e9e565b90611fea565b565b90612f6591612eab565b565b80612f82612f7c612f775f611eb8565b6104d4565b916104d4565b1461310257612fa4612f9e612f99600f8490610e53565b610ab1565b1561046d565b61308d575b818342425f905f92600194612fbc612e5b565b965f880190612fca91612787565b6020870190612fd891612787565b6040860190612fe691612787565b6060850190612ff491612787565b612ffd9061200a565b608084019061300b91612787565b6130149061200a565b60a083019061302291612787565b60c082019061303091612795565b600d8261303c91610a58565b9061304691612f5b565b907faa807d0abf30d91968c7478c66b6d82521a106af13eda036e2036da9af1689589161307290610a4c565b9261307b610412565b9182916130889183612e38565b0390a2565b6130a161309a600e6120c8565b8290612e03565b6130b760016130b2600f8490610e53565b611fea565b808290846130e57fdb03f97dc5840a71e69be7470e4761af10a1237973e81c12d0dc2813895a652692610a4c565b926130fa6130f1610412565b92839283612e38565b0390a2612fa9565b5f63d92e233d60e01b81528061311a60048201610521565b0390fd5b906131299291612de6565b565b613133611f2e565b5061313e600e6116d2565b90565b5f90565b61315790613151613141565b506147fa565b90565b9061316490610a4c565b5f5260205260405f2090565b61318661318b9161317f611f2e565b505f61315a565b610a8a565b90565b606090565b60209181520190565b6131a69054612ca6565b90565b60010190565b906131cc6131c66131bf846116d2565b8093613193565b926116d6565b905f5b8181106131dc5750505090565b9091926131fc6131f66001926131f18761319c565b610f96565b946131a9565b91019190916131cf565b90613210916131af565b90565b9061323361322c92613223610412565b93848092613206565b0383612415565b565b61323e90613213565b90565b61324961318e565b50613254600e613235565b90565b61325f611e15565b5061328761328261327a613275600d8590610a58565b612876565b92600f610e53565b610ab1565b9081613292575b5090565b61329f915060c001612e9e565b5f61328e565b906132bf916132ba6132b561132c565b613db2565b6132c1565b565b806132dc6132d66132d15f611eb8565b6104d4565b916104d4565b146133a057816132f46132ee5f61200a565b91610608565b146133845761330a613304613455565b1561046d565b6133685761331981839061425c565b339061336361335161334b7fbef4f81c1814c641ede85ebaacf19d048b2c5b55980adfa6ef0f956c651335a293610a4c565b93610a4c565b9361335a610412565b9182918261069e565b0390a3565b5f63b8b5ca2d60e01b81528061338060048201610521565b0390fd5b5f631f2a200560e01b81528061339c60048201610521565b0390fd5b5f63d92e233d60e01b8152806133b860048201610521565b0390fd5b906133c6916132a5565b565b6133d0611f2e565b506133db600c610a8a565b6133ed6133e75f61200a565b91610608565b14801561341c575b6134105761340d613406600c610a8a565b4290612054565b90565b6134195f61200a565b90565b504261343961343361342e600c610a8a565b610608565b91610608565b10156133f5565b6134529061344c611f2e565b50614829565b90565b61345d611e15565b50613468600c610a8a565b61347a6134745f61200a565b91610608565b141580613485575b90565b50426134a261349c613497600c610a8a565b610608565b91610608565b10613482565b6134c1906134bc6134b7611672565b613db2565b6134c3565b565b806134d66134d042610608565b91610608565b111561358c578061350f6135097f0000000000000000000000000000000000000000000000000000000000000000610608565b91610608565b116135705761351e600c610a8a565b61352982600c612e7e565b9033906135567fdd6896dcf1d4b311cca87dd19bbba2ea9ce2f867c1568878a0438a66a1afeeec92610a4c565b9261356b613562610412565b92839283612e38565b0390a2565b5f63ef69af6560e01b81528061358860048201610521565b0390fd5b5f63a565835360e01b8152806135a460048201610521565b0390fd5b6135b1906134a8565b565b5f90565b606090565b6135c590610a40565b90565b67ffffffffffffffff81116135e05760208091020190565b612401565b906135f76135f2836135c8565b6127a3565b918252565b369037565b9061362661360e836135e5565b9260208061361c86936135c8565b92019103906135fc565b565b600f60f81b90565b6136386135b3565b50613641612313565b5061364a612313565b50613653611f2e565b5061365c612114565b506136656125be565b5061366e6135b7565b50613677614841565b90613680614881565b90469061368c306135bc565b906136965f611656565b906136a86136a35f61200a565b613601565b906136b1613628565b96959493929190565b6136e36136e8916136c9611f2e565b506136dd6136d7600b612a07565b91614502565b906145f8565b612a0a565b90565b613712915f61370761370d936136ff611e15565b5060056125ce565b01610e53565b610ab1565b90565b5f90565b613721613715565b5061372a61471f565b90565b6137446137499161373c611f2e565b50600d610a58565b612876565b4261377c61377661377161375f60408601612882565b61376b62015180612892565b906128ae565b610608565b91610608565b10156137a6578061379d60806137965f6137a39501612882565b9201612882565b90612054565b90565b5f6137b19101612882565b90565b6137bc612313565b506137c76004612460565b90565b6137f16137ec6137e76137f6936137df611f2e565b50600a6129f1565b612a07565b6148c1565b612a0a565b90565b61381691613805611e15565b5061380e613dc6565b919091614067565b600190565b9061382e91613828611f2e565b50612a26565b90565b6138439061383d611f2e565b506137ca565b90565b61384e611f2e565b506138576124a4565b90565b7fe48329057bfd03d55e49b547132e39cffd9c1820ad7b9d4c5307691425d15adf90565b6138b36138ba946138a960609498979561389f608086019a5f8701906107d0565b6020850190610cf1565b6040830190610691565b0190610691565b565b60200190565b5190565b93959490929195426138e06138da89610608565b91610608565b11613959579161394b9161395293613942613957989961392a61390161385a565b61391b8b938b61390f610412565b9586946020860161387e565b60208201810382520382612415565b61393c613936826138c2565b916138bc565b20614936565b92909192614953565b918261499d565b61476f565b565b613974875f918291632341d78760e11b83526004830161069e565b0390fd5b5f90565b5f90565b6139886127b8565b9060208080808080808861399a613978565b8152016139a5613978565b8152016139b0613978565b8152016139bb613978565b8152016139c6613978565b8152016139d1613978565b8152016139dc61397c565b81525050565b6139ea613980565b90565b613a04613a09916139fc6139e2565b50600d610a58565b612876565b90565b90613a2691613a21613a1c611d18565b613db2565b613a28565b565b80613a43613a3d613a385f611eb8565b6104d4565b916104d4565b14613ae457613a65613a5f613a5a600f8490610e53565b610ab1565b1561046d565b613ac557613a81826006613a7b600d8590610a58565b01611fea565b613ac0613aae7f9c8668db324845065d2b9a2a183bd3141f63018f548282daf18da49ccbf88c3392610a4c565b92613ab7610412565b9182918261047f565b0390a2565b613ae0905f918291636585b60d60e01b835260048301610cfe565b0390fd5b5f63d92e233d60e01b815280613afc60048201610521565b0390fd5b90613b0a91613a0c565b565b7f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c990565b9194613b78613b8292989795613b6e60a096613b64613b899a613b5a60c08a019e5f8b01906107d0565b6020890190610cf1565b6040870190610cf1565b6060850190610691565b6080830190610691565b0190610691565b565b916020613bac929493613ba560408201965f830190610cf1565b0190610cf1565b565b969591939294909442613bc9613bc383610608565b91610608565b11613c835790613c32613c3b949392613c1a613be3613b0c565b613c0b8c80948c91613bf58d916149e0565b9192613bff610412565b97889660208801613b30565b60208201810382520382612415565b613c2c613c26826138c2565b916138bc565b20614936565b92909192614953565b80613c4e613c48876104d4565b916104d4565b03613c635750613c619293919091613dd3565b565b8490613c7f5f9283926325c0072360e11b845260048401613b8b565b0390fd5b613c9e905f91829163313c898160e11b83526004830161069e565b0390fd5b90613cbd91613cb8613cb382612608565b613db2565b613cbf565b565b90613cc991614421565b50565b90613cd691613ca2565b565b90613ce290610a4c565b5f5260205260405f2090565b613d1391613d09613d0e92613d01611f2e565b506001613cd8565b61315a565b610a8a565b90565b613d2060406127a3565b90565b5f90565b5f90565b613d33613d16565b9060208083613d40613d23565b815201613d4b613d27565b81525050565b613d59613d2b565b90565b90613d6f91613d69613d51565b50614a13565b90565b613d7a611e15565b5080613d95613d8f637965db0b60e01b610420565b91610420565b14908115613da2575b5090565b613dac9150614a3b565b5f613d9e565b613dc490613dbe613dc6565b90614a84565b565b613dce612114565b503390565b91613de19291600192614abf565b565b90565b604090613e0f613e169496959396613e0560608401985f850190610cf1565b6020830190610691565b0190610691565b565b90613e2d613e28600d8490610a58565b613de3565b91613e4b613e45613e40600f8490610e53565b610ab1565b1561046d565b8015613f54575b613f355742613e89613e83613e7e613e6c60028801610a8a565b613e7862015180612892565b906128ae565b610608565b91610608565b1015613f0e575b613eb0613e9e5f8501610a8a565b613eaa60048601610a8a565b90612054565b9082613ec4613ebe84610608565b91610608565b11613eee57505090613ee66004613eec93920191613ee183610a8a565b6128ae565b90612e7e565b565b613f0a83925f9384936340ed367b60e01b855260048501613de6565b0390fd5b613f23613f1a5f61200a565b60048501612e7e565b613f304260028501612e7e565b613e90565b613f50905f918291636585b60d60e01b835260048301610cfe565b0390fd5b50613f6a613f6460068501610ab1565b1561046d565b613e52565b80613f8a613f84613f7f5f611eb8565b6104d4565b916104d4565b14613fa657613fa491613f9c5f611eb8565b919091614bce565b565b613fc9613fb25f611eb8565b5f91829163ec442f0560e01b835260048301610cfe565b0390fd5b90613fd89103610608565b90565b929192613fe9818390613cee565b9081613ffe613ff85f19610608565b91610608565b1061400b575b5050509050565b8161401e61401887610608565b91610608565b106140445761403b9394614033919392613fcd565b905f92614abf565b805f8080614004565b50614063849291925f938493637dc7a0d960e11b855260048501613de6565b0390fd5b918261408361407d6140785f611eb8565b6104d4565b916104d4565b146140dd57816140a361409d6140985f611eb8565b6104d4565b916104d4565b146140b6576140b492919091614bce565b565b6140d96140c25f611eb8565b5f91829163ec442f0560e01b835260048301610cfe565b0390fd5b6141006140e95f611eb8565b5f918291634b637e8f60e11b835260048301610cfe565b0390fd5b90614119614114600d8490610a58565b613de3565b9161413761413161412c600f8490610e53565b610ab1565b1561046d565b8015614241575b614222574261417561416f61416a61415860038801610a8a565b61416462015180612892565b906128ae565b610608565b91610608565b10156141fb575b61419d61418b60018501610a8a565b61419760058601610a8a565b90612054565b90826141b16141ab84610608565b91610608565b116141db575050906141d360056141d9939201916141ce83610a8a565b6128ae565b90612e7e565b565b6141f783925f9384936372ff4bd160e11b855260048501613de6565b0390fd5b6142106142075f61200a565b60058501612e7e565b61421d4260038501612e7e565b61417c565b61423d905f918291636585b60d60e01b835260048301610cfe565b0390fd5b5061425761425160068501610ab1565b1561046d565b61413e565b908161427861427261426d5f611eb8565b6104d4565b916104d4565b1461429457614292919061428b5f611eb8565b9091614bce565b565b6142b76142a05f611eb8565b5f918291634b637e8f60e11b835260048301610cfe565b0390fd5b6142c3611e15565b506142d86142d28284906136eb565b1561046d565b5f146143615761430060016142fb5f6142f3600586906125ce565b018590610e53565b611fea565b90614309613dc6565b9061434661434061433a7f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d956125c2565b92610a4c565b92610a4c565b9261434f610412565b8061435981610521565b0390a4600190565b50505f90565b61436f6125be565b50614379306135bc565b6143ab6143a57f00000000000000000000000000000000000000000000000000000000000000006104d4565b916104d4565b14806143e7575b5f146143dc577f000000000000000000000000000000000000000000000000000000000000000090565b6143e4614ce9565b90565b504661441b6144157f0000000000000000000000000000000000000000000000000000000000000000610608565b91610608565b146143b2565b614429611e15565b506144358183906136eb565b5f146144bd5761445c5f6144575f61444f600586906125ce565b018590610e53565b611fea565b90614465613dc6565b906144a261449c6144967ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b956125c2565b92610a4c565b92610a4c565b926144ab610412565b806144b581610521565b0390a4600190565b50505f90565b6144d76144d26144dc926114d6565b610a21565b610608565b90565b9160206145009294936144f960408201965f830190610691565b01906114e1565b565b61450a613715565b50614513613719565b81614526614520836144c3565b91610608565b1015614539575061453690614df2565b90565b906145545f928392637669fc0f60e11b8452600484016144df565b0390fd5b5490565b90565b61457361456e6145789261455c565b610a21565b610608565b90565b90565b65ffffffffffff1690565b61459561459a91610a6e565b61457e565b90565b6145a79054614589565b90565b60301c90565b60018060d01b031690565b6145c76145cc916145aa565b6145b0565b90565b6145d990546145bb565b90565b6145f06145eb6145f59261164e565b610a21565b611c91565b90565b9061464c90614605611d80565b506146115f8401614558565b61461a5f61200a565b90808061463061462a600561455f565b91610608565b116146ad575b50906146475f86019391929361457b565b615441565b8061465f6146595f61200a565b91610608565b145f146146755750506146715f6145dc565b5b90565b6146a25f9161469d614697846146a89601926146916001612038565b90612054565b9161457b565b615437565b016145cf565b614672565b806146bb6146c192916150cc565b90612054565b90836146f36146ed6146e85f6146e2818c016146dd899161457b565b615437565b0161459d565b6114d6565b916114d6565b105f146147045750905b905f614636565b915061471a906147146001612038565b906128ae565b6146fd565b614727613715565b5061473143614df2565b90565b9061474560018060a01b0391611651565b9181191691161790565b9061476461475f61476b92610a4c565b6120a3565b8254614734565b9055565b906147f8916147f261478082612cc7565b6147958461479060098690612c90565b61474f565b828185906147d56147cf6147c97f3134e8a2e6d97e929a7e54011ea5485d7d196dd5f0ba4d4ef95803e8e3fc257f95610a4c565b92610a4c565b92610a4c565b926147de610412565b806147e881610521565b0390a492916154d0565b916154e8565b565b61482161481c6148176148269361480f613141565b50600a6129f1565b612a07565b615696565b615715565b90565b61483b90614835611f2e565b50615766565b90565b90565b614849612313565b5061487e7f0000000000000000000000000000000000000000000000000000000000000000614878600661483e565b90615881565b90565b614889612313565b506148be7f00000000000000000000000000000000000000000000000000000000000000006148b8600761483e565b90615881565b90565b6148c9611d80565b506148d55f8201614558565b806148e86148e25f61200a565b91610608565b145f146148fe5750506148fa5f6145dc565b5b90565b61492b5f916149266149208461493196019261491a6001612038565b90612054565b9161457b565b615437565b016145cf565b6148fb565b614950906149426125be565b5061494b614367565b6158cf565b90565b9261496e9261497794614964612114565b5092909192615995565b90929192615ac0565b90565b91602061499b92949361499460408201965f830190610cf1565b0190610691565b565b6149a6816149e0565b916149b96149b384610608565b91610608565b036149c2575050565b6149dc5f9283926301d4b62360e61b84526004840161497a565b0390fd5b6149f4906149ec611f2e565b50600861315a565b614a10614a0082610a8a565b91614a0a83612026565b90612e7e565b90565b90614a33614a2e614a3893614a26613d51565b50600a6129f1565b612a07565b615c22565b90565b614a43611e15565b50614a5d614a576301ffc9a760e01b610420565b91610420565b1490565b916020614a82929493614a7b60408201965f830190610cf1565b01906107d0565b565b90614a99614a938383906136eb565b1561046d565b614aa1575050565b614abb5f92839263e2517d3f60e01b845260048401614a61565b0390fd5b909281614adc614ad6614ad15f611eb8565b6104d4565b916104d4565b14614ba75783614afc614af6614af15f611eb8565b6104d4565b916104d4565b14614b8057614b2083614b1b614b1460018690613cd8565b879061315a565b612e7e565b614b2a575b505050565b919091614b75614b63614b5d7f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92593610a4c565b93610a4c565b93614b6c610412565b9182918261069e565b0390a35f8080614b25565b614ba3614b8c5f611eb8565b5f918291634a1406b160e11b835260048301610cfe565b0390fd5b614bca614bb35f611eb8565b5f91829163e602df0560e01b835260048301610cfe565b0390fd5b9182614bea614be4614bdf5f611eb8565b6104d4565b916104d4565b141580614c55575b614c05575b614c0392919091615c43565b565b614c0d613455565b80614c34575b15614bf7575f6336e278fd60e21b815280614c3060048201610521565b0390fd5b50614c50614c4a614c4361132c565b33906136eb565b1561046d565b614c13565b5081614c71614c6b614c665f611eb8565b6104d4565b916104d4565b1415614bf2565b7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f90565b90959492614ce794614cd6614ce092614ccc608096614cc260a088019c5f8901906107d0565b60208701906107d0565b60408501906107d0565b6060830190610691565b0190610cf1565b565b614cf16125be565b50614cfa614c78565b614d717f000000000000000000000000000000000000000000000000000000000000000091614d627f000000000000000000000000000000000000000000000000000000000000000046614d4d306135bc565b91614d56610412565b96879560208701614c9c565b60208201810382520382612415565b614d83614d7d826138c2565b916138bc565b2090565b90565b614d9e614d99614da392614d87565b610a21565b6108f1565b90565b614daf90614d8a565b9052565b916020614dd4929493614dcd60408201965f830190614da6565b0190610691565b565b614dea614de5614def92610608565b610a21565b6114d6565b90565b614dfa613715565b5080614e14614e0e65ffffffffffff6144c3565b91610608565b11614e2557614e2290614dd6565b90565b6030614e415f9283926306dfcc6560e41b845260048401614db3565b0390fd5b90565b614e5c614e57614e6192614e45565b610a21565b610608565b90565b90565b614e7b614e76614e8092614e64565b610a21565b6108f1565b90565b614ea290614e9c614e96614ea7946108f1565b91610608565b90610e69565b610608565b90565b90565b614ec1614ebc614ec692614eaa565b610a21565b6108f1565b90565b614ee890614ee2614edc614eed946108f1565b91610608565b90611ec4565b610608565b90565b90565b614f07614f02614f0c92614ef0565b610a21565b610608565b90565b90565b614f26614f21614f2b92614f0f565b610a21565b6108f1565b90565b90565b614f45614f40614f4a92614f2e565b610a21565b610608565b90565b90565b614f64614f5f614f6992614f4d565b610a21565b6108f1565b90565b90565b614f83614f7e614f8892614f6c565b610a21565b610608565b90565b90565b614fa2614f9d614fa792614f8b565b610a21565b6108f1565b90565b90565b614fc1614fbc614fc692614faa565b610a21565b610608565b90565b90565b614fe0614fdb614fe592614fc9565b610a21565b6108f1565b90565b614ffc614ff761500192614f4d565b610a21565b610608565b90565b90565b61501b61501661502092615004565b610a21565b6108f1565b90565b61503761503261503c92614fc9565b610a21565b610608565b90565b61505361504e61505892612035565b610a21565b6108f1565b90565b90565b61507261506d6150779261505b565b610a21565b610608565b90565b906150859102610608565b90565b634e487b7160e01b5f52601260045260245ffd5b6150a86150ae91610608565b91610608565b9081156150b9570490565b615088565b906150c99101610608565b90565b6150d4611f2e565b50806150e96150e36001612038565b91610608565b111561543457806152fe6152db6152cb6152bb6152ab61529b61528b61527b61526b61525b61524b8b61524561523e6153049f61521e61520e61522e926151306001612038565b9080615148615142600160801b614e48565b91610608565b1015615406575b8061516b61516568010000000000000000614ef3565b91610608565b10156153d8575b8061518a615184640100000000614f31565b91610608565b10156153aa575b806151a76151a162010000614f6f565b91610608565b101561537c575b806151c36151bd610100614fad565b91610608565b101561534e575b806151de6151d86010614fe8565b91610608565b1015615320575b6151f86151f26004615023565b91610608565b1015615307575b615209600361505e565b61507a565b615218600161503f565b90614e83565b615228818661509c565b906150be565b615238600161503f565b90614e83565b809261509c565b906150be565b615255600161503f565b90614e83565b615265818c61509c565b906150be565b615275600161503f565b90614e83565b615285818a61509c565b906150be565b615295600161503f565b90614e83565b6152a5818861509c565b906150be565b6152b5600161503f565b90614e83565b6152c5818661509c565b906150be565b6152d5600161503f565b90614e83565b916152f86152f26152ed85809461509c565b610608565b91610608565b11615cd3565b90613fcd565b90565b61531b90615315600161503f565b90614ec9565b6151ff565b615337615348916153316004614fcc565b90614e83565b916153426002615007565b90614ec9565b906151e5565b6153656153769161535f6008614f8e565b90614e83565b916153706004614fcc565b90614ec9565b906151ca565b6153936153a49161538d6010614f50565b90614e83565b9161539e6008614f8e565b90614ec9565b906151ae565b6153c16153d2916153bb6020614f12565b90614e83565b916153cc6010614f50565b90614ec9565b90615191565b6153ef615400916153e96040614ead565b90614e83565b916153fa6020614f12565b90614ec9565b90615172565b61541d61542e916154176080614e67565b90614e83565b916154286040614ead565b90614ec9565b9061514f565b90565b5f5260205f200190565b9391909261544d611f2e565b505b8161546261545c83610608565b91610608565b10156154c857615473828290615d1f565b906154895f615483888590615437565b0161459d565b61549b615495876114d6565b916114d6565b115f146154ab5750915b9161544f565b9291506154c2906154bc6001612038565b906128ae565b906154a5565b925050915090565b6154e2906154dc611f2e565b50613170565b90565b90565b919091806154fe6154f8856104d4565b916104d4565b14158061567c575b615510575b505050565b8061552b6155256155205f611eb8565b6104d4565b916104d4565b036155ec575b508161554d6155476155425f611eb8565b6104d4565b916104d4565b03615559575b8061550b565b6155a061559361559a9261556f600a86906129f1565b9061558d615587615581600193615db8565b93612a07565b916154e5565b90615e0b565b9290612a0a565b91612a0a565b9190916155cd7fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a72492610a4c565b926155e26155d9610412565b92839283612e38565b0390a25f80615553565b61562b615631615624615601600a85906129f1565b600261561e61561861561289615db8565b93612a07565b916154e5565b90615e0b565b9290612a0a565b91612a0a565b91909161565e7fdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a72492610a4c565b9261567361566a610412565b92839283612e38565b0390a25f615531565b508161569061568a5f61200a565b91610608565b11615506565b5f6156aa916156a3611f2e565b5001614558565b90565b6156c16156bc6156c692610ee1565b610a21565b610608565b90565b6156d290614f12565b9052565b9160206156f79294936156f060408201965f8301906156c9565b0190610691565b565b61570d61570861571292610608565b610a21565b610ee1565b90565b61571d613141565b508061573561572f63ffffffff6156ad565b91610608565b1161574657615743906156f9565b90565b60206157625f9283926306dfcc6560e41b8452600484016156d6565b0390fd5b61577d61578291615775611f2e565b50600861315a565b610a8a565b90565b90565b61579c6157976157a192615785565b611651565b61078c565b90565b6157ae60ff615788565b90565b5f5260205f2090565b905f92918054906157d46157cd8361232c565b8094612356565b916001811690815f1461582b57506001146157ef575b505050565b6157fc91929394506157b1565b915f925b81841061581357505001905f80806157ea565b60018160209295939554848601520191019290615800565b92949550505060ff19168252151560200201905f80806157ea565b90615850916157ba565b90565b9061587361586c92615863610412565b93848092615846565b0383612415565b565b61587e90615853565b90565b9061588a612313565b50615894826125c2565b6158ad6158a76158a26157a4565b61078c565b9161078c565b14155f146158c257506158bf90615e95565b90565b6158cc9150615875565b90565b6042916158da6125be565b50604051917f19010000000000000000000000000000000000000000000000000000000000008352600283015260228201522090565b5f90565b61592061592591610a6e565b611eed565b90565b90565b61593f61593a61594492615928565b610a21565b610608565b90565b61597c61598394615972606094989795615968608086019a5f8701906107d0565b60208501906108f7565b60408301906107d0565b01906107d0565b565b61598d610412565b3d5f823e3d90fd5b9392936159a0612114565b506159a9615910565b506159b26125be565b506159bc85615914565b6159ee6159e87f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a061592b565b91610608565b11615a7b5790615a11602094955f94939293615a08610412565b94859485615947565b838052039060015afa15615a7657615a295f51611651565b80615a44615a3e615a395f611eb8565b6104d4565b916104d4565b14615a5a575f91615a545f611656565b91929190565b50615a645f611eb8565b600191615a705f611656565b91929190565b615985565b505050615a875f611eb8565b9060039291929190565b634e487b7160e01b5f52602160045260245ffd5b60041115615aaf57565b615a91565b90615abe82615aa5565b565b80615ad3615acd5f615ab4565b91615ab4565b145f14615ade575050565b80615af2615aec6001615ab4565b91615ab4565b145f14615b15575f63f645eedf60e01b815280615b1160048201610521565b0390fd5b80615b29615b236002615ab4565b91615ab4565b145f14615b5757615b53615b3c83615914565b5f91829163fce698f760e01b83526004830161069e565b0390fd5b615b6a615b646003615ab4565b91615ab4565b14615b725750565b615b8d905f9182916335e2f38360e21b8352600483016107dd565b0390fd5b5f5260205f2090565b615ba381614558565b821015615bbd57615bb5600191615b91565b910201905f90565b6116be565b90615bcc906114d6565b9052565b90615bda90611c91565b9052565b90615c14615c0b5f615bee613d16565b94615c05615bfd83830161459d565b838801615bc2565b016145cf565b60208401615bd0565b565b615c1f90615bde565b90565b615c40915f615c3a92615c33613d51565b5001615b9a565b50615c16565b90565b9291615c5184838391615ec5565b83615c6c615c66615c615f611eb8565b6104d4565b916104d4565b14615c81575b615c7f929391909161604f565b565b615c896124a4565b93615c92616034565b9480615ca6615ca088610608565b91610608565b11615cb357509350615c72565b8590615ccf5f928392630e58ae9360e11b845260048401612e38565b0390fd5b615cdb611f2e565b50151590565b615cf5615cf0615cfa92615004565b610a21565b610608565b90565b615d09615d0f91610608565b91610608565b908115615d1a570490565b615088565b615d44615d4a92615d2e611f2e565b508281169218615d3e6002615ce1565b90615cfd565b906128ae565b90565b90565b615d64615d5f615d6992615d4d565b610a21565b6108f1565b90565b615d7590615d50565b9052565b916020615d9a929493615d9360408201965f830190615d6c565b0190610691565b565b615db0615dab615db592610608565b610a21565b611c91565b90565b615dc0611d80565b5080615dda615dd460018060d01b03612a0a565b91610608565b11615deb57615de890615d9c565b90565b60d0615e075f9283926306dfcc6560e41b845260048401615d79565b0390fd5b90615e41615e479392615e1c611d80565b50615e25611d80565b508093615e3a615e33613719565b94926148c1565b90916164b7565b9161610e565b91909190565b615e61615e5c615e6692614f0f565b610a21565b610608565b90565b369037565b90615e93615e7b83612bd8565b92602080615e898693612bb5565b9201910390615e69565b565b615e9d612313565b50615ea781616178565b90615eba615eb56020615e4d565b615e6e565b918252602082015290565b91909180615ee3615edd615ed85f611eb8565b6104d4565b916104d4565b145f14615fc457615f07615f0083615efb6002610a8a565b6128ae565b6002612e7e565b5b82615f23615f1d615f185f611eb8565b6104d4565b916104d4565b145f14615f9857615f47615f4083615f3b6002610a8a565b613fcd565b6002612e7e565b5b919091615f93615f81615f7b7fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef93610a4c565b93610a4c565b93615f8a610412565b9182918261069e565b0390a3565b615fbf82615fb9615faa5f879061315a565b91615fb483610a8a565b6150be565b90612e7e565b615f48565b615fd7615fd25f839061315a565b610a8a565b80615fea615fe485610608565b91610608565b1061601257615ffd61600d918490613fcd565b6160085f849061315a565b612e7e565b615f08565b906160309091925f93849363391434e360e21b855260048501613de6565b0390fd5b61603c611f2e565b5061604c60018060d01b03612a0a565b90565b916160a76160a16160ae948061607561606f61606a5f611eb8565b6104d4565b916104d4565b146160df575b8461609661609061608b5f611eb8565b6104d4565b916104d4565b146160b0575b612cc7565b92612cc7565b90916154e8565b565b6160d8600b60026160d26160cc6160c689615db8565b93612a07565b916154e5565b90615e0b565b505061609c565b616107600b60016161016160fb6160f589615db8565b93612a07565b916154e5565b90615e0b565b505061607b565b916161325f6161379461611f611d80565b50616128611d80565b500192919261457b565b616369565b91909190565b61615161614c61615692615785565b610a21565b610608565b90565b90565b61617061616b61617592616159565b610a21565b610608565b90565b61618d61619291616187611f2e565b506125c2565b615914565b61619c60ff61613d565b16806161b16161ab601f61615c565b91610608565b116161b95790565b5f632cd44ac360e21b8152806161d160048201610521565b0390fd5b5490565b6161e360406127a3565b90565b5f5260205f2090565b6161f8816161d5565b8210156162125761620a6001916161e6565b910201905f90565b6116be565b61622190516114d6565b90565b9061623565ffffffffffff91611651565b9181191691161790565b61625361624e616258926114d6565b610a21565b6114d6565b90565b90565b9061627361626e61627a9261623f565b61625b565b8254616224565b9055565b6162889051611c91565b90565b60301b90565b906162a365ffffffffffff199161628b565b9181191691161790565b6162c16162bc6162c692611c91565b610a21565b611c91565b90565b90565b906162e16162dc6162e8926162ad565b6162c9565b8254616291565b9055565b9061631660205f61631c9461630e828201616308848801616217565b9061625e565b01920161627e565b906162cc565b565b919061632f5761632d916162ec565b565b611f9b565b9081549168010000000000000000831015616364578261635c916001616362950181556161ef565b9061631e565b565b612401565b90929192616375611d80565b5061637e611d80565b50616388826161d5565b8061639b6163955f61200a565b91610608565b115f1461646b576163c1906163bb84916163b56001612038565b90612054565b90615437565b906163cd5f830161459d565b926163d95f84016145cf565b93806163ed6163e7856114d6565b916114d6565b1161644f576164046163fe846114d6565b916114d6565b145f1461641f57505061641a905f8591016162cc565b5b9190565b61644a92506164458661643c6164336161d9565b945f8601615bc2565b60208401615bd0565b616334565b61641b565b5f632520601d60e01b81528061646760048201610521565b0390fd5b50616496916164918561648861647f6161d9565b945f8601615bc2565b60208401615bd0565b616334565b61649f5f6145dc565b9190565b634e487b7160e01b5f52605160045260245ffd5b919091806001146164d6576002036164a3576164d291611dff565b905b565b506164e091611dc0565b906164d456
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x13W[a\x1D|V[a\0\x1D_5a\x04\x0CV[\x80c\x01\xFF\xC9\xA7\x14a\x04\x07W\x80c\x04\xDF\x01}\x14a\x04\x02W\x80c\x06\xFD\xDE\x03\x14a\x03\xFDW\x80c\t^\xA7\xB3\x14a\x03\xF8W\x80c\x18\x16\r\xDD\x14a\x03\xF3W\x80c\x18\xBFPw\x14a\x03\xEEW\x80c#\xB8r\xDD\x14a\x03\xE9W\x80c$\x8A\x9C\xA3\x14a\x03\xE4W\x80c+\x8CI\xE3\x14a\x03\xDFW\x80c//\xF1]\x14a\x03\xDAW\x80c0\xD3\xE8\xEB\x14a\x03\xD5W\x80c1<\xE5g\x14a\x03\xD0W\x80c6D\xE5\x15\x14a\x03\xCBW\x80c6V\x8A\xBE\x14a\x03\xC6W\x80c:F\xB1\xA8\x14a\x03\xC1W\x80c@\xC1\x0F\x19\x14a\x03\xBCW\x80cBz\xC0\xCA\x14a\x03\xB7W\x80cB\x96lh\x14a\x03\xB2W\x80cK\xDD6\xCE\x14a\x03\xADW\x80cK\xF5\xD7\xE9\x14a\x03\xA8W\x80cO\x1B\xFC\x9E\x14a\x03\xA3W\x80cX|\xDE\x1E\x14a\x03\x9EW\x80cZ]\xB1\xBB\x14a\x03\x99W\x80c\\\x19\xA9\\\x14a\x03\x94W\x80cc\xA0\xDA\xAC\x14a\x03\x8FW\x80ce\x14U4\x14a\x03\x8AW\x80cj\x96\xE3\xED\x14a\x03\x85W\x80co\xCF\xFFE\x14a\x03\x80W\x80cp\xA0\x821\x14a\x03{W\x80cr\xCB\xDC\xC8\x14a\x03vW\x80cx\xFB\x7F\xD2\x14a\x03qW\x80cy\xCCg\x90\x14a\x03lW\x80cz\x8C\xD1V\x14a\x03gW\x80c~\xCE\xBE\0\x14a\x03bW\x80c\x83\xF1!\x1B\x14a\x03]W\x80c\x84&\xAD\xF2\x14a\x03XW\x80c\x84L\x90&\x14a\x03SW\x80c\x84\xB0\x19n\x14a\x03NW\x80c\x8AT%!\x14a\x03IW\x80c\x8D3C\xD6\x14a\x03DW\x80c\x8ES\x9E\x8C\x14a\x03?W\x80c\x90-U\xA5\x14a\x03:W\x80c\x91\xD1HT\x14a\x035W\x80c\x91\xDD\xAD\xF4\x14a\x030W\x80c\x94\xAA\"\xF2\x14a\x03+W\x80c\x95\xD8\x9BA\x14a\x03&W\x80c\x9A\xB2N\xB0\x14a\x03!W\x80c\x9B~\xF6K\x14a\x03\x1CW\x80c\xA2\x17\xFD\xDF\x14a\x03\x17W\x80c\xA3\xC4G\x05\x14a\x03\x12W\x80c\xA9\x05\x9C\xBB\x14a\x03\rW\x80c\xAA\x08*\x9D\x14a\x03\x08W\x80c\xB0\xCA%>\x14a\x03\x03W\x80c\xBBMD6\x14a\x02\xFEW\x80c\xC0*\xE7T\x14a\x02\xF9W\x80c\xC3\xCD\xA5 \x14a\x02\xF4W\x80c\xC4\xFCE\xA8\x14a\x02\xEFW\x80c\xC9\xAB\0\x06\x14a\x02\xEAW\x80c\xD5\x05\xAC\xCF\x14a\x02\xE5W\x80c\xD5Gt\x1F\x14a\x02\xE0W\x80c\xDDb\xED>\x14a\x02\xDBW\x80c\xF1\x12~\xD8\x14a\x02\xD6Wc\xF7^\x85\x12\x03a\0\x0EWa\x1DGV[a\x1C\xE2V[a\x1B\xFEV[a\x1B\x9DV[a\x1BcV[a\x1A\xBFV[a\x1A:V[a\x19`V[a\x18\xA4V[a\x18oV[a\x189V[a\x18\x04V[a\x17\x99V[a\x17dV[a\x16\x89V[a\x16\x19V[a\x15\xA2V[a\x15mV[a\x158V[a\x15\x03V[a\x14\xA0V[a\x14kV[a\x13\xF4V[a\x13\xBFV[a\x13[V[a\x12\xF0V[a\x11\xABV[a\x11vV[a\x11\x1DV[a\x10\xE8V[a\x10\xB3V[a\x10\x7FV[a\x10JV[a\x10\x15V[a\x0FAV[a\x0F\x0CV[a\x0E\xACV[a\x0E\x1EV[a\r\xEAV[a\r}V[a\rHV[a\r\x13V[a\x0C\xBCV[a\x0CNV[a\x0C\x19V[a\x0B\xE6V[a\x0B\x8CV[a\t\xEDV[a\t\xB7V[a\t\x83V[a\tNV[a\t\x19V[a\x08\xBCV[a\x08\x88V[a\x08'V[a\x07\xF2V[a\x07VV[a\x06\xE8V[a\x06\xB3V[a\x06[V[a\x05\xD3V[a\x05&V[a\x04\x94V[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[c\xFF\xFF\xFF\xFF`\xE0\x1B\x16\x90V[a\x045\x81a\x04 V[\x03a\x04<WV[_\x80\xFD[\x90P5\x90a\x04M\x82a\x04,V[V[\x90` \x82\x82\x03\x12a\x04hWa\x04e\x91_\x01a\x04@V[\x90V[a\x04\x1CV[\x15\x15\x90V[a\x04{\x90a\x04mV[\x90RV[\x91\x90a\x04\x92\x90_` \x85\x01\x94\x01\x90a\x04rV[V[4a\x04\xC4Wa\x04\xC0a\x04\xAFa\x04\xAA6`\x04a\x04OV[a\x1E\x19V[a\x04\xB7a\x04\x12V[\x91\x82\x91\x82a\x04\x7FV[\x03\x90\xF3[a\x04\x18V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x04\xDD\x90a\x04\xC9V[\x90V[a\x04\xE9\x81a\x04\xD4V[\x03a\x04\xF0WV[_\x80\xFD[\x90P5\x90a\x05\x01\x82a\x04\xE0V[V[\x90` \x82\x82\x03\x12a\x05\x1CWa\x05\x19\x91_\x01a\x04\xF4V[\x90V[a\x04\x1CV[_\x01\x90V[4a\x05TWa\x05>a\x0596`\x04a\x05\x03V[a#\x08V[a\x05Fa\x04\x12V[\x80a\x05P\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[_\x91\x03\x12a\x05cWV[a\x04\x1CV[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[`\x1F\x80\x19\x91\x01\x16\x90V[a\x05\xA9a\x05\xB2` \x93a\x05\xB7\x93a\x05\xA0\x81a\x05hV[\x93\x84\x80\x93a\x05lV[\x95\x86\x91\x01a\x05uV[a\x05\x80V[\x01\x90V[a\x05\xD0\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x05\x8AV[\x90V[4a\x06\x03Wa\x05\xE36`\x04a\x05YV[a\x05\xFFa\x05\xEEa$lV[a\x05\xF6a\x04\x12V[\x91\x82\x91\x82a\x05\xBBV[\x03\x90\xF3[a\x04\x18V[\x90V[a\x06\x14\x81a\x06\x08V[\x03a\x06\x1BWV[_\x80\xFD[\x90P5\x90a\x06,\x82a\x06\x0BV[V[\x91\x90`@\x83\x82\x03\x12a\x06VW\x80a\x06Ja\x06S\x92_\x86\x01a\x04\xF4V[\x93` \x01a\x06\x1FV[\x90V[a\x04\x1CV[4a\x06\x8CWa\x06\x88a\x06wa\x06q6`\x04a\x06.V[\x90a$\x82V[a\x06\x7Fa\x04\x12V[\x91\x82\x91\x82a\x04\x7FV[\x03\x90\xF3[a\x04\x18V[a\x06\x9A\x90a\x06\x08V[\x90RV[\x91\x90a\x06\xB1\x90_` \x85\x01\x94\x01\x90a\x06\x91V[V[4a\x06\xE3Wa\x06\xC36`\x04a\x05YV[a\x06\xDFa\x06\xCEa$\xA4V[a\x06\xD6a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[4a\x07\x17Wa\x07\x01a\x06\xFB6`\x04a\x06.V[\x90a$\xBAV[a\x07\ta\x04\x12V[\x80a\x07\x13\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[\x90\x91``\x82\x84\x03\x12a\x07QWa\x07Na\x077\x84_\x85\x01a\x04\xF4V[\x93a\x07E\x81` \x86\x01a\x04\xF4V[\x93`@\x01a\x06\x1FV[\x90V[a\x04\x1CV[4a\x07\x87Wa\x07\x83a\x07ra\x07l6`\x04a\x07\x1CV[\x91a%\x8FV[a\x07za\x04\x12V[\x91\x82\x91\x82a\x04\x7FV[\x03\x90\xF3[a\x04\x18V[\x90V[a\x07\x98\x81a\x07\x8CV[\x03a\x07\x9FWV[_\x80\xFD[\x90P5\x90a\x07\xB0\x82a\x07\x8FV[V[\x90` \x82\x82\x03\x12a\x07\xCBWa\x07\xC8\x91_\x01a\x07\xA3V[\x90V[a\x04\x1CV[a\x07\xD9\x90a\x07\x8CV[\x90RV[\x91\x90a\x07\xF0\x90_` \x85\x01\x94\x01\x90a\x07\xD0V[V[4a\x08\"Wa\x08\x1Ea\x08\ra\x08\x086`\x04a\x07\xB2V[a&\x08V[a\x08\x15a\x04\x12V[\x91\x82\x91\x82a\x07\xDDV[\x03\x90\xF3[a\x04\x18V[4a\x08VWa\x08@a\x08:6`\x04a\x06.V[\x90a&*V[a\x08Ha\x04\x12V[\x80a\x08R\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[\x91\x90`@\x83\x82\x03\x12a\x08\x83W\x80a\x08wa\x08\x80\x92_\x86\x01a\x07\xA3V[\x93` \x01a\x04\xF4V[\x90V[a\x04\x1CV[4a\x08\xB7Wa\x08\xA1a\x08\x9B6`\x04a\x08[V[\x90a'{V[a\x08\xA9a\x04\x12V[\x80a\x08\xB3\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[4a\x08\xECWa\x08\xE8a\x08\xD7a\x08\xD26`\x04a\x05\x03V[a(\xD3V[a\x08\xDFa\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[`\xFF\x16\x90V[a\t\0\x90a\x08\xF1V[\x90RV[\x91\x90a\t\x17\x90_` \x85\x01\x94\x01\x90a\x08\xF7V[V[4a\tIWa\t)6`\x04a\x05YV[a\tEa\t4a)\x7FV[a\t<a\x04\x12V[\x91\x82\x91\x82a\t\x04V[\x03\x90\xF3[a\x04\x18V[4a\t~Wa\t^6`\x04a\x05YV[a\tza\tia)\x95V[a\tqa\x04\x12V[\x91\x82\x91\x82a\x07\xDDV[\x03\x90\xF3[a\x04\x18V[4a\t\xB2Wa\t\x9Ca\t\x966`\x04a\x08[V[\x90a)\xA9V[a\t\xA4a\x04\x12V[\x80a\t\xAE\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[4a\t\xE8Wa\t\xE4a\t\xD3a\t\xCD6`\x04a\x06.V[\x90a*&V[a\t\xDBa\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[4a\n\x1CWa\n\x06a\n\x006`\x04a\x06.V[\x90a+DV[a\n\x0Ea\x04\x12V[\x80a\n\x18\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[\x90V[a\n8a\n3a\n=\x92a\x04\xC9V[a\n!V[a\x04\xC9V[\x90V[a\nI\x90a\n$V[\x90V[a\nU\x90a\n@V[\x90V[\x90a\nb\x90a\nLV[_R` R`@_ \x90V[_\x1C\x90V[\x90V[a\n\x82a\n\x87\x91a\nnV[a\nsV[\x90V[a\n\x94\x90Ta\nvV[\x90V[`\xFF\x16\x90V[a\n\xA9a\n\xAE\x91a\nnV[a\n\x97V[\x90V[a\n\xBB\x90Ta\n\x9DV[\x90V[a\n\xC9\x90`\ra\nXV[a\n\xD4_\x82\x01a\n\x8AV[\x91a\n\xE1`\x01\x83\x01a\n\x8AV[\x91a\n\xEE`\x02\x82\x01a\n\x8AV[\x91a\n\xFB`\x03\x83\x01a\n\x8AV[\x91a\x0B\x08`\x04\x82\x01a\n\x8AV[\x91a\x0B!`\x06a\x0B\x1A`\x05\x85\x01a\n\x8AV[\x93\x01a\n\xB1V[\x90V[\x94\x92\x90\x97\x96\x95\x93\x91`\xE0\x86\x01\x98_\x87\x01a\x0B=\x91a\x06\x91V[` \x86\x01a\x0BJ\x91a\x06\x91V[`@\x85\x01a\x0BW\x91a\x06\x91V[``\x84\x01a\x0Bd\x91a\x06\x91V[`\x80\x83\x01a\x0Bq\x91a\x06\x91V[`\xA0\x82\x01a\x0B~\x91a\x06\x91V[`\xC0\x01a\x0B\x8A\x91a\x04rV[V[4a\x0B\xC3Wa\x0B\xBFa\x0B\xA7a\x0B\xA26`\x04a\x05\x03V[a\n\xBEV[\x93a\x0B\xB6\x97\x95\x97\x93\x91\x93a\x04\x12V[\x97\x88\x97\x88a\x0B$V[\x03\x90\xF3[a\x04\x18V[\x90` \x82\x82\x03\x12a\x0B\xE1Wa\x0B\xDE\x91_\x01a\x06\x1FV[\x90V[a\x04\x1CV[4a\x0C\x14Wa\x0B\xFEa\x0B\xF96`\x04a\x0B\xC8V[a+PV[a\x0C\x06a\x04\x12V[\x80a\x0C\x10\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[4a\x0CIWa\x0C)6`\x04a\x05YV[a\x0CEa\x0C4a+\x90V[a\x0C<a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[4a\x0C~Wa\x0C^6`\x04a\x05YV[a\x0Cza\x0Cia,:V[a\x0Cqa\x04\x12V[\x91\x82\x91\x82a\x05\xBBV[\x03\x90\xF3[a\x04\x18V[\x90V[a\x0C\x9Aa\x0C\x95a\x0C\x9F\x92a\x0C\x83V[a\n!V[a\x06\x08V[\x90V[a\x0C\xAEbv\xA7\0a\x0C\x86V[\x90V[a\x0C\xB9a\x0C\xA2V[\x90V[4a\x0C\xECWa\x0C\xCC6`\x04a\x05YV[a\x0C\xE8a\x0C\xD7a\x0C\xB1V[a\x0C\xDFa\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[a\x0C\xFA\x90a\x04\xD4V[\x90RV[\x91\x90a\r\x11\x90_` \x85\x01\x94\x01\x90a\x0C\xF1V[V[4a\rCWa\r?a\r.a\r)6`\x04a\x05\x03V[a,\xC7V[a\r6a\x04\x12V[\x91\x82\x91\x82a\x0C\xFEV[\x03\x90\xF3[a\x04\x18V[4a\rxWa\rta\rca\r^6`\x04a\x0B\xC8V[a-\x8EV[a\rka\x04\x12V[\x91\x82\x91\x82a\x0C\xFEV[\x03\x90\xF3[a\x04\x18V[4a\r\xABWa\r\x95a\r\x906`\x04a\x05\x03V[a-\xD3V[a\r\x9Da\x04\x12V[\x80a\r\xA7\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[\x90\x91``\x82\x84\x03\x12a\r\xE5Wa\r\xE2a\r\xCB\x84_\x85\x01a\x04\xF4V[\x93a\r\xD9\x81` \x86\x01a\x06\x1FV[\x93`@\x01a\x06\x1FV[\x90V[a\x04\x1CV[4a\x0E\x19Wa\x0E\x03a\r\xFD6`\x04a\r\xB0V[\x91a1\x1EV[a\x0E\x0Ba\x04\x12V[\x80a\x0E\x15\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[4a\x0ENWa\x0E.6`\x04a\x05YV[a\x0EJa\x0E9a1+V[a\x0EAa\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[\x90a\x0E]\x90a\nLV[_R` R`@_ \x90V[\x1C\x90V[a\x0E}\x90`\x08a\x0E\x82\x93\x02a\x0EiV[a\n\x97V[\x90V[\x90a\x0E\x90\x91Ta\x0EmV[\x90V[a\x0E\xA9\x90a\x0E\xA4`\x0F\x91_\x92a\x0ESV[a\x0E\x85V[\x90V[4a\x0E\xDCWa\x0E\xD8a\x0E\xC7a\x0E\xC26`\x04a\x05\x03V[a\x0E\x93V[a\x0E\xCFa\x04\x12V[\x91\x82\x91\x82a\x04\x7FV[\x03\x90\xF3[a\x04\x18V[c\xFF\xFF\xFF\xFF\x16\x90V[a\x0E\xF3\x90a\x0E\xE1V[\x90RV[\x91\x90a\x0F\n\x90_` \x85\x01\x94\x01\x90a\x0E\xEAV[V[4a\x0F<Wa\x0F8a\x0F'a\x0F\"6`\x04a\x05\x03V[a1EV[a\x0F/a\x04\x12V[\x91\x82\x91\x82a\x0E\xF7V[\x03\x90\xF3[a\x04\x18V[4a\x0FqWa\x0Fma\x0F\\a\x0FW6`\x04a\x05\x03V[a1pV[a\x0Fda\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[Q\x90V[` \x91\x81R\x01\x90V[` \x01\x90V[a\x0F\x92\x90a\x04\xD4V[\x90RV[\x90a\x0F\xA3\x81` \x93a\x0F\x89V[\x01\x90V[` \x01\x90V[\x90a\x0F\xCAa\x0F\xC4a\x0F\xBD\x84a\x0FvV[\x80\x93a\x0FzV[\x92a\x0F\x83V[\x90_[\x81\x81\x10a\x0F\xDAWPPP\x90V[\x90\x91\x92a\x0F\xF3a\x0F\xED`\x01\x92\x86Qa\x0F\x96V[\x94a\x0F\xA7V[\x91\x01\x91\x90\x91a\x0F\xCDV[a\x10\x12\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x0F\xADV[\x90V[4a\x10EWa\x10%6`\x04a\x05YV[a\x10Aa\x100a2AV[a\x108a\x04\x12V[\x91\x82\x91\x82a\x0F\xFDV[\x03\x90\xF3[a\x04\x18V[4a\x10zWa\x10va\x10ea\x10`6`\x04a\x05\x03V[a2WV[a\x10ma\x04\x12V[\x91\x82\x91\x82a\x04\x7FV[\x03\x90\xF3[a\x04\x18V[4a\x10\xAEWa\x10\x98a\x10\x926`\x04a\x06.V[\x90a3\xBCV[a\x10\xA0a\x04\x12V[\x80a\x10\xAA\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[4a\x10\xE3Wa\x10\xC36`\x04a\x05YV[a\x10\xDFa\x10\xCEa3\xC8V[a\x10\xD6a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[4a\x11\x18Wa\x11\x14a\x11\x03a\x10\xFE6`\x04a\x05\x03V[a4@V[a\x11\x0Ba\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[4a\x11MWa\x11-6`\x04a\x05YV[a\x11Ia\x118a4UV[a\x11@a\x04\x12V[\x91\x82\x91\x82a\x04\x7FV[\x03\x90\xF3[a\x04\x18V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[4a\x11\xA6Wa\x11\x866`\x04a\x05YV[a\x11\xA2a\x11\x91a\x11RV[a\x11\x99a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[4a\x11\xD9Wa\x11\xC3a\x11\xBE6`\x04a\x0B\xC8V[a5\xA8V[a\x11\xCBa\x04\x12V[\x80a\x11\xD5\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[`\xFF`\xF8\x1B\x16\x90V[a\x11\xF0\x90a\x11\xDEV[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[` \x01\x90V[a\x12\x10\x90a\x06\x08V[\x90RV[\x90a\x12!\x81` \x93a\x12\x07V[\x01\x90V[` \x01\x90V[\x90a\x12Ha\x12Ba\x12;\x84a\x11\xF4V[\x80\x93a\x11\xF8V[\x92a\x12\x01V[\x90_[\x81\x81\x10a\x12XWPPP\x90V[\x90\x91\x92a\x12qa\x12k`\x01\x92\x86Qa\x12\x14V[\x94a\x12%V[\x91\x01\x91\x90\x91a\x12KV[\x93\x95\x91\x94a\x12\xCCa\x12\xC1a\x12\xE0\x95a\x12\xB3a\x12\xD6\x95a\x12\xED\x9C\x9Aa\x12\xA6`\xE0\x8C\x01\x92_\x8D\x01\x90a\x11\xE7V[\x8A\x82\x03` \x8C\x01Ra\x05\x8AV[\x90\x88\x82\x03`@\x8A\x01Ra\x05\x8AV[\x97``\x87\x01\x90a\x06\x91V[`\x80\x85\x01\x90a\x0C\xF1V[`\xA0\x83\x01\x90a\x07\xD0V[`\xC0\x81\x84\x03\x91\x01Ra\x12+V[\x90V[4a\x13'Wa\x13\x006`\x04a\x05YV[a\x13#a\x13\x0Ba60V[\x93a\x13\x1A\x97\x95\x97\x93\x91\x93a\x04\x12V[\x97\x88\x97\x88a\x12{V[\x03\x90\xF3[a\x04\x18V[\x7F\x84\xFEt\xC7\x1A(\xB6\x9A\xA9`Hl\xA0\xE8\xC1A\x8C\x86\xE9\xEA,\xD6\xB5\x84\x9B\x95\xE2\xC8\xF4\x07\xA6t\x90V[a\x13Xa\x13,V[\x90V[4a\x13\x8BWa\x13k6`\x04a\x05YV[a\x13\x87a\x13va\x13PV[a\x13~a\x04\x12V[\x91\x82\x91\x82a\x07\xDDV[\x03\x90\xF3[a\x04\x18V[\x7F\x9B\x12\xE0\xC5p~II\x15\xE5\x8B\x05d\xF1\x8A\xAA\xD9\xB7J\xC6\x9B\xFC\x81Z\x1E\xDA\xDC\x8EK\xD02\xEB\x90V[a\x13\xBCa\x13\x90V[\x90V[4a\x13\xEFWa\x13\xCF6`\x04a\x05YV[a\x13\xEBa\x13\xDAa\x13\xB4V[a\x13\xE2a\x04\x12V[\x91\x82\x91\x82a\x07\xDDV[\x03\x90\xF3[a\x04\x18V[4a\x14$Wa\x14 a\x14\x0Fa\x14\n6`\x04a\x0B\xC8V[a6\xBAV[a\x14\x17a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[\x90V[a\x14@a\x14;a\x14E\x92a\x14)V[a\n!V[a\x06\x08V[\x90V[a\x14]k\x03;.<\x9F\xD0\x80<\xE8\0\0\0a\x14,V[\x90V[a\x14ha\x14HV[\x90V[4a\x14\x9BWa\x14{6`\x04a\x05YV[a\x14\x97a\x14\x86a\x14`V[a\x14\x8Ea\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[4a\x14\xD1Wa\x14\xCDa\x14\xBCa\x14\xB66`\x04a\x08[V[\x90a6\xEBV[a\x14\xC4a\x04\x12V[\x91\x82\x91\x82a\x04\x7FV[\x03\x90\xF3[a\x04\x18V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[a\x14\xEA\x90a\x14\xD6V[\x90RV[\x91\x90a\x15\x01\x90_` \x85\x01\x94\x01\x90a\x14\xE1V[V[4a\x153Wa\x15\x136`\x04a\x05YV[a\x15/a\x15\x1Ea7\x19V[a\x15&a\x04\x12V[\x91\x82\x91\x82a\x14\xEEV[\x03\x90\xF3[a\x04\x18V[4a\x15hWa\x15da\x15Sa\x15N6`\x04a\x05\x03V[a7-V[a\x15[a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[4a\x15\x9DWa\x15}6`\x04a\x05YV[a\x15\x99a\x15\x88a7\xB4V[a\x15\x90a\x04\x12V[\x91\x82\x91\x82a\x05\xBBV[\x03\x90\xF3[a\x04\x18V[4a\x15\xD2Wa\x15\xCEa\x15\xBDa\x15\xB86`\x04a\x05\x03V[a7\xCAV[a\x15\xC5a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[\x90V[a\x15\xEEa\x15\xE9a\x15\xF3\x92a\x15\xD7V[a\n!V[a\x06\x08V[\x90V[a\x16\x0Bk\x02\xE8vi\xC3\x08sj\x04\0\0\0a\x15\xDAV[\x90V[a\x16\x16a\x15\xF6V[\x90V[4a\x16IWa\x16)6`\x04a\x05YV[a\x16Ea\x164a\x16\x0EV[a\x16<a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[\x90V[_\x1B\x90V[a\x16ja\x16ea\x16o\x92a\x16NV[a\x16QV[a\x07\x8CV[\x90V[a\x16{_a\x16VV[\x90V[a\x16\x86a\x16rV[\x90V[4a\x16\xB9Wa\x16\x996`\x04a\x05YV[a\x16\xB5a\x16\xA4a\x16~V[a\x16\xACa\x04\x12V[\x91\x82\x91\x82a\x07\xDDV[\x03\x90\xF3[a\x04\x18V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[T\x90V[_R` _ \x90V[a\x16\xE8\x81a\x16\xD2V[\x82\x10\x15a\x17\x02Wa\x16\xFA`\x01\x91a\x16\xD6V[\x91\x02\x01\x90_\x90V[a\x16\xBEV[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x17\"\x90`\x08a\x17'\x93\x02a\x0EiV[a\x17\x07V[\x90V[\x90a\x175\x91Ta\x17\x12V[\x90V[`\x0Ea\x17C\x81a\x16\xD2V[\x82\x10\x15a\x17`Wa\x17]\x91a\x17W\x91a\x16\xDFV[\x90a\x17*V[\x90V[_\x80\xFD[4a\x17\x94Wa\x17\x90a\x17\x7Fa\x17z6`\x04a\x0B\xC8V[a\x178V[a\x17\x87a\x04\x12V[\x91\x82\x91\x82a\x0C\xFEV[\x03\x90\xF3[a\x04\x18V[4a\x17\xCAWa\x17\xC6a\x17\xB5a\x17\xAF6`\x04a\x06.V[\x90a7\xF9V[a\x17\xBDa\x04\x12V[\x91\x82\x91\x82a\x04\x7FV[\x03\x90\xF3[a\x04\x18V[a\x17\xDF\x90`\x08a\x17\xE4\x93\x02a\x0EiV[a\nsV[\x90V[\x90a\x17\xF2\x91Ta\x17\xCFV[\x90V[a\x18\x01`\x0C_\x90a\x17\xE7V[\x90V[4a\x184Wa\x18\x146`\x04a\x05YV[a\x180a\x18\x1Fa\x17\xF5V[a\x18'a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[4a\x18jWa\x18fa\x18Ua\x18O6`\x04a\x06.V[\x90a8\x1BV[a\x18]a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[4a\x18\x9FWa\x18\x9Ba\x18\x8Aa\x18\x856`\x04a\x05\x03V[a81V[a\x18\x92a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[4a\x18\xD4Wa\x18\xB46`\x04a\x05YV[a\x18\xD0a\x18\xBFa8FV[a\x18\xC7a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[a\x18\xE2\x81a\x08\xF1V[\x03a\x18\xE9WV[_\x80\xFD[\x90P5\x90a\x18\xFA\x82a\x18\xD9V[V[\x90\x91`\xC0\x82\x84\x03\x12a\x19[Wa\x19\x14\x83_\x84\x01a\x04\xF4V[\x92a\x19\"\x81` \x85\x01a\x06\x1FV[\x92a\x190\x82`@\x83\x01a\x06\x1FV[\x92a\x19Xa\x19A\x84``\x85\x01a\x18\xEDV[\x93a\x19O\x81`\x80\x86\x01a\x07\xA3V[\x93`\xA0\x01a\x07\xA3V[\x90V[a\x04\x1CV[4a\x19\x95Wa\x19\x7Fa\x19s6`\x04a\x18\xFCV[\x94\x93\x90\x93\x92\x91\x92a8\xC6V[a\x19\x87a\x04\x12V[\x80a\x19\x91\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[a\x19\xA3\x90a\x04mV[\x90RV[\x90`\xC0\x80a\x1A#\x93a\x19\xBF_\x82\x01Q_\x86\x01\x90a\x12\x07V[a\x19\xD1` \x82\x01Q` \x86\x01\x90a\x12\x07V[a\x19\xE3`@\x82\x01Q`@\x86\x01\x90a\x12\x07V[a\x19\xF5``\x82\x01Q``\x86\x01\x90a\x12\x07V[a\x1A\x07`\x80\x82\x01Q`\x80\x86\x01\x90a\x12\x07V[a\x1A\x19`\xA0\x82\x01Q`\xA0\x86\x01\x90a\x12\x07V[\x01Q\x91\x01\x90a\x19\x9AV[V[\x91\x90a\x1A8\x90_`\xE0\x85\x01\x94\x01\x90a\x19\xA7V[V[4a\x1AjWa\x1Afa\x1AUa\x1AP6`\x04a\x05\x03V[a9\xEDV[a\x1A]a\x04\x12V[\x91\x82\x91\x82a\x1A%V[\x03\x90\xF3[a\x04\x18V[a\x1Ax\x81a\x04mV[\x03a\x1A\x7FWV[_\x80\xFD[\x90P5\x90a\x1A\x90\x82a\x1AoV[V[\x91\x90`@\x83\x82\x03\x12a\x1A\xBAW\x80a\x1A\xAEa\x1A\xB7\x92_\x86\x01a\x04\xF4V[\x93` \x01a\x1A\x83V[\x90V[a\x04\x1CV[4a\x1A\xEEWa\x1A\xD8a\x1A\xD26`\x04a\x1A\x92V[\x90a;\0V[a\x1A\xE0a\x04\x12V[\x80a\x1A\xEA\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[`\xE0\x81\x83\x03\x12a\x1B^Wa\x1B\t\x82_\x83\x01a\x04\xF4V[\x92a\x1B\x17\x83` \x84\x01a\x04\xF4V[\x92a\x1B%\x81`@\x85\x01a\x06\x1FV[\x92a\x1B3\x82``\x83\x01a\x06\x1FV[\x92a\x1B[a\x1BD\x84`\x80\x85\x01a\x18\xEDV[\x93a\x1BR\x81`\xA0\x86\x01a\x07\xA3V[\x93`\xC0\x01a\x07\xA3V[\x90V[a\x04\x1CV[4a\x1B\x98Wa\x1B\x82a\x1Bv6`\x04a\x1A\xF3V[\x95\x94\x90\x94\x93\x91\x93a;\xAEV[a\x1B\x8Aa\x04\x12V[\x80a\x1B\x94\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[4a\x1B\xCCWa\x1B\xB6a\x1B\xB06`\x04a\x08[V[\x90a<\xCCV[a\x1B\xBEa\x04\x12V[\x80a\x1B\xC8\x81a\x05!V[\x03\x90\xF3[a\x04\x18V[\x91\x90`@\x83\x82\x03\x12a\x1B\xF9W\x80a\x1B\xEDa\x1B\xF6\x92_\x86\x01a\x04\xF4V[\x93` \x01a\x04\xF4V[\x90V[a\x04\x1CV[4a\x1C/Wa\x1C+a\x1C\x1Aa\x1C\x146`\x04a\x1B\xD1V[\x90a<\xEEV[a\x1C\"a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xF3[a\x04\x18V[a\x1C=\x81a\x0E\xE1V[\x03a\x1CDWV[_\x80\xFD[\x90P5\x90a\x1CU\x82a\x1C4V[V[\x91\x90`@\x83\x82\x03\x12a\x1C\x7FW\x80a\x1Csa\x1C|\x92_\x86\x01a\x04\xF4V[\x93` \x01a\x1CHV[\x90V[a\x04\x1CV[a\x1C\x8D\x90a\x14\xD6V[\x90RV[`\x01\x80`\xD0\x1B\x03\x16\x90V[a\x1C\xA5\x90a\x1C\x91V[\x90RV[\x90` \x80a\x1C\xCB\x93a\x1C\xC1_\x82\x01Q_\x86\x01\x90a\x1C\x84V[\x01Q\x91\x01\x90a\x1C\x9CV[V[\x91\x90a\x1C\xE0\x90_`@\x85\x01\x94\x01\x90a\x1C\xA9V[V[4a\x1D\x13Wa\x1D\x0Fa\x1C\xFEa\x1C\xF86`\x04a\x1CWV[\x90a=\\V[a\x1D\x06a\x04\x12V[\x91\x82\x91\x82a\x1C\xCDV[\x03\x90\xF3[a\x04\x18V[\x7F\xCC\xE2\x96\xB0@3*\x08\x0Em\xF15\x15\xA3\xEC(i\xE2\x1C\xD2\x0FsD\xAF\t\x87\xDD\xB98\xD8\xBD!\x90V[a\x1DDa\x1D\x18V[\x90V[4a\x1DwWa\x1DW6`\x04a\x05YV[a\x1Dsa\x1Dba\x1D<V[a\x1Dja\x04\x12V[\x91\x82\x91\x82a\x07\xDDV[\x03\x90\xF3[a\x04\x18V[_\x80\xFD[_\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\x1D\xA4a\x1D\xAA\x91a\x1C\x91V[\x91a\x1C\x91V[\x01\x90`\x01\x80`\xD0\x1B\x03\x82\x11a\x1D\xBBWV[a\x1D\x84V[\x90a\x1D\xD3\x91a\x1D\xCDa\x1D\x80V[Pa\x1D\x98V[\x90V[a\x1D\xE2a\x1D\xE8\x91a\x1C\x91V[\x91a\x1C\x91V[\x90\x03\x90`\x01\x80`\xD0\x1B\x03\x82\x11a\x1D\xFAWV[a\x1D\x84V[\x90a\x1E\x12\x91a\x1E\x0Ca\x1D\x80V[Pa\x1D\xD6V[\x90V[_\x90V[a\x1E!a\x1E\x15V[P\x80a\x1E<a\x1E6c\x0C\xCC\xC6e`\xE2\x1Ba\x04 V[\x91a\x04 V[\x14\x80\x15a\x1E`W[\x90\x81\x15a\x1EPW[P\x90V[a\x1EZ\x91Pa=rV[_a\x1ELV[P\x80a\x1E{a\x1Euc\xB2u*\xC9`\xE0\x1Ba\x04 V[\x91a\x04 V[\x14a\x1EDV[a\x1E\x9A\x90a\x1E\x95a\x1E\x90a\x1D\x18V[a=\xB2V[a![V[V[a\x1E\xB0a\x1E\xABa\x1E\xB5\x92a\x16NV[a\n!V[a\x04\xC9V[\x90V[a\x1E\xC1\x90a\x1E\x9CV[\x90V[\x1B\x90V[\x91\x90`\x08a\x1E\xE3\x91\x02\x91a\x1E\xDD_\x19\x84a\x1E\xC4V[\x92a\x1E\xC4V[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x1F\x01a\x1E\xFCa\x1F\x06\x92a\x06\x08V[a\n!V[a\x06\x08V[\x90V[\x90V[\x91\x90a\x1F\"a\x1F\x1Da\x1F*\x93a\x1E\xEDV[a\x1F\tV[\x90\x83Ta\x1E\xC8V[\x90UV[_\x90V[a\x1FD\x91a\x1F>a\x1F.V[\x91a\x1F\x0CV[V[`\x06_\x91a\x1FV\x83\x80\x83\x01a\x1F2V[a\x1Fc\x83`\x01\x83\x01a\x1F2V[a\x1Fp\x83`\x02\x83\x01a\x1F2V[a\x1F}\x83`\x03\x83\x01a\x1F2V[a\x1F\x8A\x83`\x04\x83\x01a\x1F2V[a\x1F\x97\x83`\x05\x83\x01a\x1F2V[\x01UV[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[\x90_\x03a\x1F\xC0Wa\x1F\xBE\x90a\x1FFV[V[a\x1F\x9BV[\x90a\x1F\xD1`\xFF\x91a\x16QV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x1F\xE4\x90a\x04mV[\x90V[\x90V[\x90a\x1F\xFFa\x1F\xFAa \x06\x92a\x1F\xDBV[a\x1F\xE7V[\x82Ta\x1F\xC5V[\x90UV[a \x1Ea \x19a #\x92a\x16NV[a\n!V[a\x06\x08V[\x90V[`\x01a 2\x91\x01a\x06\x08V[\x90V[\x90V[a La Ga Q\x92a 5V[a\n!V[a\x06\x08V[\x90V[a ca i\x91\x93\x92\x93a\x06\x08V[\x92a\x06\x08V[\x82\x03\x91\x82\x11a tWV[a\x1D\x84V[\x91\x90`\x08a \x99\x91\x02\x91a \x93`\x01\x80`\xA0\x1B\x03\x84a\x1E\xC4V[\x92a\x1E\xC4V[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90V[\x91\x90a \xBCa \xB7a \xC4\x93a\nLV[a \xA3V[\x90\x83Ta yV[\x90UV[\x90V[cNH{q`\xE0\x1B_R`1`\x04R`$_\xFD[T\x90V[_R` _ \x90V[a \xF5\x81a \xDFV[\x82\x10\x15a!\x0FWa!\x07`\x01\x91a \xE3V[\x91\x02\x01\x90_\x90V[a\x16\xBEV[_\x90V[a!*\x91a!$a!\x14V[\x91a \xA6V[V[a!5\x81a \xDFV[\x80\x15a!VW`\x01\x90\x03\x90a!Sa!M\x83\x83a \xECV[\x90a!\x18V[UV[a \xCBV[\x80a!va!pa!k_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14a\"\xECWa!\x98a!\x92a!\x8D`\x0F\x84\x90a\x0ESV[a\n\xB1V[\x15a\x04mV[a\"\xCDWa!\xB1_a!\xAC`\r\x84\x90a\nXV[a\x1F\xAEV[a!\xC6_a!\xC1`\x0F\x84\x90a\x0ESV[a\x1F\xEAV[a!\xCF_a \nV[[\x80a!\xECa!\xE6a!\xE1`\x0Ea\x16\xD2V[a\x06\x08V[\x91a\x06\x08V[\x10\x15a\"\xC7Wa\"\x07a\"\x01`\x0E\x83\x90a\x16\xDFV[\x90a\x17*V[a\"\x19a\"\x13\x84a\x04\xD4V[\x91a\x04\xD4V[\x14a\",Wa\"'\x90a &V[a!\xD0V[a\"r\x90a\"la\"da\"^`\x0Ea\"Xa\"H`\x0Ea\x16\xD2V[a\"R`\x01a 8V[\x90a TV[\x90a\x16\xDFV[\x90a\x17*V[\x91`\x0Ea\x16\xDFV[\x90a \xA6V[a\"\x84a\"\x7F`\x0Ea \xC8V[a!,V[[a\"\xAF\x7F]\x9DP4el\xB3\xEB\xFB\x06U\x05|\xD7\xF9\xB4\x07z\x9BB\xFFB\xCE\"<\xBA\xC5\xBCXm!&\x91a\nLV[\x90a\"\xB8a\x04\x12V[\x80a\"\xC2\x81a\x05!V[\x03\x90\xA2V[Pa\"\x85V[a\"\xE8\x90_\x91\x82\x91ce\x85\xB6\r`\xE0\x1B\x83R`\x04\x83\x01a\x0C\xFEV[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a#\x04`\x04\x82\x01a\x05!V[\x03\x90\xFD[a#\x11\x90a\x1E\x81V[V[``\x90V[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a#LW[` \x83\x10\x14a#GWV[a#\x18V[\x91`\x7F\x16\x91a#<V[` \x91\x81R\x01\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90a#\x82a#{\x83a#,V[\x80\x94a#VV[\x91`\x01\x81\x16\x90\x81_\x14a#\xD9WP`\x01\x14a#\x9DW[PPPV[a#\xAA\x91\x92\x93\x94Pa#_V[\x91_\x92[\x81\x84\x10a#\xC1WPP\x01\x90_\x80\x80a#\x98V[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a#\xAEV[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a#\x98V[\x90a#\xFE\x91a#hV[\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a$\x1F\x90a\x05\x80V[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a$9W`@RV[a$\x01V[\x90a$^a$W\x92a$Na\x04\x12V[\x93\x84\x80\x92a#\xF4V[\x03\x83a$\x15V[V[a$i\x90a$>V[\x90V[a$ta#\x13V[Pa$\x7F`\x03a$`V[\x90V[a$\x9F\x91a$\x8Ea\x1E\x15V[Pa$\x97a=\xC6V[\x91\x90\x91a=\xD3V[`\x01\x90V[a$\xACa\x1F.V[Pa$\xB7`\x02a\n\x8AV[\x90V[\x80a$\xD5a$\xCFa$\xCA_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14a%sW\x81a$\xEDa$\xE7_a \nV[\x91a\x06\x08V[\x14a%WWa$\xFD3\x83\x90a>\x18V[a%\x08\x81\x83\x90a?oV[3\x90a%Ra%@a%:\x7F\xDE\"\xBA\xFF\x03\x8E:>\x08@|\xBD\xF6\x17\xDE\xEDt\xE8i\xA7\xBAQ}\xF6\x11\xE311\xC6\xE6\xEA\x04\x93a\nLV[\x93a\nLV[\x93a%Ia\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xA3V[_c\x1F* \x05`\xE0\x1B\x81R\x80a%o`\x04\x82\x01a\x05!V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a%\x8B`\x04\x82\x01a\x05!V[\x03\x90\xFD[\x91a%\xB9\x92a%\x9Ca\x1E\x15V[Pa%\xB1a%\xA8a=\xC6V[\x82\x90\x84\x91a?\xDBV[\x91\x90\x91a@gV[`\x01\x90V[_\x90V[a%\xCB\x90a\x07\x8CV[\x90V[\x90a%\xD8\x90a%\xC2V[_R` R`@_ \x90V[\x90V[a%\xF3a%\xF8\x91a\nnV[a%\xE4V[\x90V[a&\x05\x90Ta%\xE7V[\x90V[`\x01a&!a&'\x92a&\x19a%\xBEV[P`\x05a%\xCEV[\x01a%\xFBV[\x90V[\x80a&Ea&?a&:_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14a'5W\x81a&]a&W_a \nV[\x91a\x06\x08V[\x14a'\x19Wa&m3\x83\x90aA\x04V[3a&\x80a&z\x83a\x04\xD4V[\x91a\x04\xD4V[\x03a&\xE0W[a&\x91\x81\x83\x90aB\\V[3\x90a&\xDBa&\xC9a&\xC3\x7F\xB9\x07\x95\xA6fP\x15Y\x83\xE2B\xCA\xC3\xE1\xAC\x1AM\xC2o\x8E\xD2\x98\x7F<\xE4\x16\xA3N\0\x11\x1F\xD4\x93a\nLV[\x93a\nLV[\x93a&\xD2a\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xA3V[a&\xEB\x813\x90a<\xEEV[a&\xFDa&\xF7_a \nV[\x91a\x06\x08V[\x03a'\x08W[a&\x86V[a'\x14\x813\x84\x91a?\xDBV[a'\x03V[_c\x1F* \x05`\xE0\x1B\x81R\x80a'1`\x04\x82\x01a\x05!V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a'M`\x04\x82\x01a\x05!V[\x03\x90\xFD[\x90a'l\x91a'ga'b\x82a&\x08V[a=\xB2V[a'nV[V[\x90a'x\x91aB\xBBV[PV[\x90a'\x85\x91a'QV[V[\x90a'\x91\x90a\x06\x08V[\x90RV[\x90a'\x9F\x90a\x04mV[\x90RV[\x90a'\xB6a'\xAFa\x04\x12V[\x92\x83a$\x15V[V[a'\xC2`\xE0a'\xA3V[\x90V[\x90a(ta(k`\x06a'\xD6a'\xB8V[\x94a'\xEDa'\xE5_\x83\x01a\n\x8AV[_\x88\x01a'\x87V[a(\x05a'\xFC`\x01\x83\x01a\n\x8AV[` \x88\x01a'\x87V[a(\x1Da(\x14`\x02\x83\x01a\n\x8AV[`@\x88\x01a'\x87V[a(5a(,`\x03\x83\x01a\n\x8AV[``\x88\x01a'\x87V[a(Ma(D`\x04\x83\x01a\n\x8AV[`\x80\x88\x01a'\x87V[a(ea(\\`\x05\x83\x01a\n\x8AV[`\xA0\x88\x01a'\x87V[\x01a\n\xB1V[`\xC0\x84\x01a'\x95V[V[a(\x7F\x90a'\xC5V[\x90V[a(\x8C\x90Qa\x06\x08V[\x90V[\x90V[a(\xA6a(\xA1a(\xAB\x92a(\x8FV[a\n!V[a\x06\x08V[\x90V[a(\xBDa(\xC3\x91\x93\x92\x93a\x06\x08V[\x92a\x06\x08V[\x82\x01\x80\x92\x11a(\xCEWV[a\x1D\x84V[a(\xEAa(\xEF\x91a(\xE2a\x1F.V[P`\ra\nXV[a(vV[Ba)\"a)\x1Ca)\x17a)\x05``\x86\x01a(\x82V[a)\x11b\x01Q\x80a(\x92V[\x90a(\xAEV[a\x06\x08V[\x91a\x06\x08V[\x10\x15a)MW\x80a)D`\xA0a)=` a)J\x95\x01a(\x82V[\x92\x01a(\x82V[\x90a TV[\x90V[` a)Y\x91\x01a(\x82V[\x90V[_\x90V[\x90V[a)wa)ra)|\x92a)`V[a\n!V[a\x08\xF1V[\x90V[a)\x87a)\\V[Pa)\x92`\x12a)cV[\x90V[a)\x9Da%\xBEV[Pa)\xA6aCgV[\x90V[\x90\x80a)\xC4a)\xBEa)\xB9a=\xC6V[a\x04\xD4V[\x91a\x04\xD4V[\x03a)\xD5Wa)\xD2\x91aD!V[PV[_c3K\xD9\x19`\xE1\x1B\x81R\x80a)\xED`\x04\x82\x01a\x05!V[\x03\x90\xFD[\x90a)\xFB\x90a\nLV[_R` R`@_ \x90V[\x90V[a*\x1Ea*\x19a*#\x92a\x1C\x91V[a\n!V[a\x06\x08V[\x90V[a*]\x91a*Ra*La*Ga*X\x94a*?a\x1F.V[P`\na)\xF1V[a*\x07V[\x91aE\x02V[\x90aE\xF8V[a*\nV[\x90V[\x90a*z\x91a*ua*pa\x13\x90V[a=\xB2V[a*|V[V[\x90\x81a*\x98a*\x92a*\x8D_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14a+(W\x80a*\xB0a*\xAA_a \nV[\x91a\x06\x08V[\x14a+\x0CWa*\xC7a*\xC0a$\xA4V[\x82\x90a(\xAEV[a*\xE0a*\xDAa*\xD5a\x14HV[a\x06\x08V[\x91a\x06\x08V[\x11a*\xF0Wa*\xEE\x91a?oV[V[_c\x17~?\xC3`\xE0\x1B\x81R\x80a+\x08`\x04\x82\x01a\x05!V[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a+$`\x04\x82\x01a\x05!V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a+@`\x04\x82\x01a\x05!V[\x03\x90\xFD[\x90a+N\x91a*`V[V[\x80a+ca+]_a \nV[\x91a\x06\x08V[\x14a+tWa+r\x903aB\\V[V[_c\x1F* \x05`\xE0\x1B\x81R\x80a+\x8C`\x04\x82\x01a\x05!V[\x03\x90\xFD[a+\x98a\x1F.V[Pa+\xB2a+\xA4a\x14HV[a+\xACa$\xA4V[\x90a TV[\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a+\xD3Wa+\xCF` \x91a\x05\x80V[\x01\x90V[a$\x01V[\x90a+\xEAa+\xE5\x83a+\xB5V[a'\xA3V[\x91\x82RV[_\x7Fmode=blocknumber&from=default\0\0\0\x91\x01RV[a, `\x1Da+\xD8V[\x90a,-` \x83\x01a+\xEFV[V[a,7a,\x16V[\x90V[a,Ba#\x13V[Pa,Ka7\x19V[a,da,^a,YaG\x1FV[a\x14\xD6V[\x91a\x14\xD6V[\x03a,tWa,qa,/V[\x90V[_c\x01\xBF\xC1\xC5`\xE6\x1B\x81R\x80a,\x8C`\x04\x82\x01a\x05!V[\x03\x90\xFD[\x90a,\x9A\x90a\nLV[_R` R`@_ \x90V[a,\xB2a,\xB7\x91a\nnV[a\x17\x07V[\x90V[a,\xC4\x90Ta,\xA6V[\x90V[a,\xDEa,\xE3\x91a,\xD6a!\x14V[P`\ta,\x90V[a,\xBAV[\x90V[` \x7Fout of bounds\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x7FSyndicateTokenCrosschain: index _\x82\x01R\x01RV[a-@`-`@\x92a\x05lV[a-I\x81a,\xE6V[\x01\x90V[a-b\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra-3V[\x90V[\x15a-lWV[a-ta\x04\x12V[bF\x1B\xCD`\xE5\x1B\x81R\x80a-\x8A`\x04\x82\x01a-MV[\x03\x90\xFD[a-\xCAa-\xD0\x91a-\x9Da!\x14V[Pa-\xC3\x81a-\xBDa-\xB7a-\xB2`\x0Ea\x16\xD2V[a\x06\x08V[\x91a\x06\x08V[\x10a-eV[`\x0Ea\x16\xDFV[\x90a\x17*V[\x90V[a-\xE4\x90a-\xDFa=\xC6V[aGoV[V[\x90a.\x01\x92\x91a-\xFCa-\xF7a\x1D\x18V[a=\xB2V[a/gV[V[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15a.3W\x82a.+\x91`\x01a.1\x95\x01\x81Ua \xECV[\x90a \xA6V[V[a$\x01V[\x91` a.Y\x92\x94\x93a.R`@\x82\x01\x96_\x83\x01\x90a\x06\x91V[\x01\x90a\x06\x91V[V[a.e`\xE0a'\xA3V[\x90V[\x90a.t_\x19\x91a\x16QV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90a.\x93a.\x8Ea.\x9A\x92a\x1E\xEDV[a\x1F\tV[\x82Ta.hV[\x90UV[a.\xA8\x90Qa\x04mV[\x90V[\x90a/S`\xC0`\x06a/Y\x94a.\xCE_\x82\x01a.\xC8_\x88\x01a(\x82V[\x90a.~V[a.\xE7`\x01\x82\x01a.\xE1` \x88\x01a(\x82V[\x90a.~V[a/\0`\x02\x82\x01a.\xFA`@\x88\x01a(\x82V[\x90a.~V[a/\x19`\x03\x82\x01a/\x13``\x88\x01a(\x82V[\x90a.~V[a/2`\x04\x82\x01a/,`\x80\x88\x01a(\x82V[\x90a.~V[a/K`\x05\x82\x01a/E`\xA0\x88\x01a(\x82V[\x90a.~V[\x01\x92\x01a.\x9EV[\x90a\x1F\xEAV[V[\x90a/e\x91a.\xABV[V[\x80a/\x82a/|a/w_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14a1\x02Wa/\xA4a/\x9Ea/\x99`\x0F\x84\x90a\x0ESV[a\n\xB1V[\x15a\x04mV[a0\x8DW[\x81\x83BB_\x90_\x92`\x01\x94a/\xBCa.[V[\x96_\x88\x01\x90a/\xCA\x91a'\x87V[` \x87\x01\x90a/\xD8\x91a'\x87V[`@\x86\x01\x90a/\xE6\x91a'\x87V[``\x85\x01\x90a/\xF4\x91a'\x87V[a/\xFD\x90a \nV[`\x80\x84\x01\x90a0\x0B\x91a'\x87V[a0\x14\x90a \nV[`\xA0\x83\x01\x90a0\"\x91a'\x87V[`\xC0\x82\x01\x90a00\x91a'\x95V[`\r\x82a0<\x91a\nXV[\x90a0F\x91a/[V[\x90\x7F\xAA\x80}\n\xBF0\xD9\x19h\xC7G\x8Cf\xB6\xD8%!\xA1\x06\xAF\x13\xED\xA06\xE2\x03m\xA9\xAF\x16\x89X\x91a0r\x90a\nLV[\x92a0{a\x04\x12V[\x91\x82\x91a0\x88\x91\x83a.8V[\x03\x90\xA2V[a0\xA1a0\x9A`\x0Ea \xC8V[\x82\x90a.\x03V[a0\xB7`\x01a0\xB2`\x0F\x84\x90a\x0ESV[a\x1F\xEAV[\x80\x82\x90\x84a0\xE5\x7F\xDB\x03\xF9}\xC5\x84\nq\xE6\x9B\xE7G\x0EGa\xAF\x10\xA1#ys\xE8\x1C\x12\xD0\xDC(\x13\x89Ze&\x92a\nLV[\x92a0\xFAa0\xF1a\x04\x12V[\x92\x83\x92\x83a.8V[\x03\x90\xA2a/\xA9V[_c\xD9.#=`\xE0\x1B\x81R\x80a1\x1A`\x04\x82\x01a\x05!V[\x03\x90\xFD[\x90a1)\x92\x91a-\xE6V[V[a13a\x1F.V[Pa1>`\x0Ea\x16\xD2V[\x90V[_\x90V[a1W\x90a1Qa1AV[PaG\xFAV[\x90V[\x90a1d\x90a\nLV[_R` R`@_ \x90V[a1\x86a1\x8B\x91a1\x7Fa\x1F.V[P_a1ZV[a\n\x8AV[\x90V[``\x90V[` \x91\x81R\x01\x90V[a1\xA6\x90Ta,\xA6V[\x90V[`\x01\x01\x90V[\x90a1\xCCa1\xC6a1\xBF\x84a\x16\xD2V[\x80\x93a1\x93V[\x92a\x16\xD6V[\x90_[\x81\x81\x10a1\xDCWPPP\x90V[\x90\x91\x92a1\xFCa1\xF6`\x01\x92a1\xF1\x87a1\x9CV[a\x0F\x96V[\x94a1\xA9V[\x91\x01\x91\x90\x91a1\xCFV[\x90a2\x10\x91a1\xAFV[\x90V[\x90a23a2,\x92a2#a\x04\x12V[\x93\x84\x80\x92a2\x06V[\x03\x83a$\x15V[V[a2>\x90a2\x13V[\x90V[a2Ia1\x8EV[Pa2T`\x0Ea25V[\x90V[a2_a\x1E\x15V[Pa2\x87a2\x82a2za2u`\r\x85\x90a\nXV[a(vV[\x92`\x0Fa\x0ESV[a\n\xB1V[\x90\x81a2\x92W[P\x90V[a2\x9F\x91P`\xC0\x01a.\x9EV[_a2\x8EV[\x90a2\xBF\x91a2\xBAa2\xB5a\x13,V[a=\xB2V[a2\xC1V[V[\x80a2\xDCa2\xD6a2\xD1_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14a3\xA0W\x81a2\xF4a2\xEE_a \nV[\x91a\x06\x08V[\x14a3\x84Wa3\na3\x04a4UV[\x15a\x04mV[a3hWa3\x19\x81\x83\x90aB\\V[3\x90a3ca3Qa3K\x7F\xBE\xF4\xF8\x1C\x18\x14\xC6A\xED\xE8^\xBA\xAC\xF1\x9D\x04\x8B,[U\x98\n\xDF\xA6\xEF\x0F\x95le\x135\xA2\x93a\nLV[\x93a\nLV[\x93a3Za\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xA3V[_c\xB8\xB5\xCA-`\xE0\x1B\x81R\x80a3\x80`\x04\x82\x01a\x05!V[\x03\x90\xFD[_c\x1F* \x05`\xE0\x1B\x81R\x80a3\x9C`\x04\x82\x01a\x05!V[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a3\xB8`\x04\x82\x01a\x05!V[\x03\x90\xFD[\x90a3\xC6\x91a2\xA5V[V[a3\xD0a\x1F.V[Pa3\xDB`\x0Ca\n\x8AV[a3\xEDa3\xE7_a \nV[\x91a\x06\x08V[\x14\x80\x15a4\x1CW[a4\x10Wa4\ra4\x06`\x0Ca\n\x8AV[B\x90a TV[\x90V[a4\x19_a \nV[\x90V[PBa49a43a4.`\x0Ca\n\x8AV[a\x06\x08V[\x91a\x06\x08V[\x10\x15a3\xF5V[a4R\x90a4La\x1F.V[PaH)V[\x90V[a4]a\x1E\x15V[Pa4h`\x0Ca\n\x8AV[a4za4t_a \nV[\x91a\x06\x08V[\x14\x15\x80a4\x85W[\x90V[PBa4\xA2a4\x9Ca4\x97`\x0Ca\n\x8AV[a\x06\x08V[\x91a\x06\x08V[\x10a4\x82V[a4\xC1\x90a4\xBCa4\xB7a\x16rV[a=\xB2V[a4\xC3V[V[\x80a4\xD6a4\xD0Ba\x06\x08V[\x91a\x06\x08V[\x11\x15a5\x8CW\x80a5\x0Fa5\t\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x06\x08V[\x91a\x06\x08V[\x11a5pWa5\x1E`\x0Ca\n\x8AV[a5)\x82`\x0Ca.~V[\x903\x90a5V\x7F\xDDh\x96\xDC\xF1\xD4\xB3\x11\xCC\xA8}\xD1\x9B\xBB\xA2\xEA\x9C\xE2\xF8g\xC1V\x88x\xA0C\x8Af\xA1\xAF\xEE\xEC\x92a\nLV[\x92a5ka5ba\x04\x12V[\x92\x83\x92\x83a.8V[\x03\x90\xA2V[_c\xEFi\xAFe`\xE0\x1B\x81R\x80a5\x88`\x04\x82\x01a\x05!V[\x03\x90\xFD[_c\xA5e\x83S`\xE0\x1B\x81R\x80a5\xA4`\x04\x82\x01a\x05!V[\x03\x90\xFD[a5\xB1\x90a4\xA8V[V[_\x90V[``\x90V[a5\xC5\x90a\n@V[\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a5\xE0W` \x80\x91\x02\x01\x90V[a$\x01V[\x90a5\xF7a5\xF2\x83a5\xC8V[a'\xA3V[\x91\x82RV[6\x907V[\x90a6&a6\x0E\x83a5\xE5V[\x92` \x80a6\x1C\x86\x93a5\xC8V[\x92\x01\x91\x03\x90a5\xFCV[V[`\x0F`\xF8\x1B\x90V[a68a5\xB3V[Pa6Aa#\x13V[Pa6Ja#\x13V[Pa6Sa\x1F.V[Pa6\\a!\x14V[Pa6ea%\xBEV[Pa6na5\xB7V[Pa6waHAV[\x90a6\x80aH\x81V[\x90F\x90a6\x8C0a5\xBCV[\x90a6\x96_a\x16VV[\x90a6\xA8a6\xA3_a \nV[a6\x01V[\x90a6\xB1a6(V[\x96\x95\x94\x93\x92\x91\x90V[a6\xE3a6\xE8\x91a6\xC9a\x1F.V[Pa6\xDDa6\xD7`\x0Ba*\x07V[\x91aE\x02V[\x90aE\xF8V[a*\nV[\x90V[a7\x12\x91_a7\x07a7\r\x93a6\xFFa\x1E\x15V[P`\x05a%\xCEV[\x01a\x0ESV[a\n\xB1V[\x90V[_\x90V[a7!a7\x15V[Pa7*aG\x1FV[\x90V[a7Da7I\x91a7<a\x1F.V[P`\ra\nXV[a(vV[Ba7|a7va7qa7_`@\x86\x01a(\x82V[a7kb\x01Q\x80a(\x92V[\x90a(\xAEV[a\x06\x08V[\x91a\x06\x08V[\x10\x15a7\xA6W\x80a7\x9D`\x80a7\x96_a7\xA3\x95\x01a(\x82V[\x92\x01a(\x82V[\x90a TV[\x90V[_a7\xB1\x91\x01a(\x82V[\x90V[a7\xBCa#\x13V[Pa7\xC7`\x04a$`V[\x90V[a7\xF1a7\xECa7\xE7a7\xF6\x93a7\xDFa\x1F.V[P`\na)\xF1V[a*\x07V[aH\xC1V[a*\nV[\x90V[a8\x16\x91a8\x05a\x1E\x15V[Pa8\x0Ea=\xC6V[\x91\x90\x91a@gV[`\x01\x90V[\x90a8.\x91a8(a\x1F.V[Pa*&V[\x90V[a8C\x90a8=a\x1F.V[Pa7\xCAV[\x90V[a8Na\x1F.V[Pa8Wa$\xA4V[\x90V[\x7F\xE4\x83)\x05{\xFD\x03\xD5^I\xB5G\x13.9\xCF\xFD\x9C\x18 \xAD{\x9DLS\x07i\x14%\xD1Z\xDF\x90V[a8\xB3a8\xBA\x94a8\xA9``\x94\x98\x97\x95a8\x9F`\x80\x86\x01\x9A_\x87\x01\x90a\x07\xD0V[` \x85\x01\x90a\x0C\xF1V[`@\x83\x01\x90a\x06\x91V[\x01\x90a\x06\x91V[V[` \x01\x90V[Q\x90V[\x93\x95\x94\x90\x92\x91\x95Ba8\xE0a8\xDA\x89a\x06\x08V[\x91a\x06\x08V[\x11a9YW\x91a9K\x91a9R\x93a9Ba9W\x98\x99a9*a9\x01a8ZV[a9\x1B\x8B\x93\x8Ba9\x0Fa\x04\x12V[\x95\x86\x94` \x86\x01a8~V[` \x82\x01\x81\x03\x82R\x03\x82a$\x15V[a9<a96\x82a8\xC2V[\x91a8\xBCV[ aI6V[\x92\x90\x91\x92aISV[\x91\x82aI\x9DV[aGoV[V[a9t\x87_\x91\x82\x91c#A\xD7\x87`\xE1\x1B\x83R`\x04\x83\x01a\x06\x9EV[\x03\x90\xFD[_\x90V[_\x90V[a9\x88a'\xB8V[\x90` \x80\x80\x80\x80\x80\x80\x88a9\x9Aa9xV[\x81R\x01a9\xA5a9xV[\x81R\x01a9\xB0a9xV[\x81R\x01a9\xBBa9xV[\x81R\x01a9\xC6a9xV[\x81R\x01a9\xD1a9xV[\x81R\x01a9\xDCa9|V[\x81RPPV[a9\xEAa9\x80V[\x90V[a:\x04a:\t\x91a9\xFCa9\xE2V[P`\ra\nXV[a(vV[\x90V[\x90a:&\x91a:!a:\x1Ca\x1D\x18V[a=\xB2V[a:(V[V[\x80a:Ca:=a:8_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14a:\xE4Wa:ea:_a:Z`\x0F\x84\x90a\x0ESV[a\n\xB1V[\x15a\x04mV[a:\xC5Wa:\x81\x82`\x06a:{`\r\x85\x90a\nXV[\x01a\x1F\xEAV[a:\xC0a:\xAE\x7F\x9C\x86h\xDB2HE\x06]+\x9A*\x18;\xD3\x14\x1Fc\x01\x8FT\x82\x82\xDA\xF1\x8D\xA4\x9C\xCB\xF8\x8C3\x92a\nLV[\x92a:\xB7a\x04\x12V[\x91\x82\x91\x82a\x04\x7FV[\x03\x90\xA2V[a:\xE0\x90_\x91\x82\x91ce\x85\xB6\r`\xE0\x1B\x83R`\x04\x83\x01a\x0C\xFEV[\x03\x90\xFD[_c\xD9.#=`\xE0\x1B\x81R\x80a:\xFC`\x04\x82\x01a\x05!V[\x03\x90\xFD[\x90a;\n\x91a:\x0CV[V[\x7Fnq\xED\xAE\x12\xB1\xB9\x7FM\x1F`7\x0F\xEF\x10\x10_\xA2\xFA\xAE\x01&\x11J\x16\x9Cd\x84]a&\xC9\x90V[\x91\x94a;xa;\x82\x92\x98\x97\x95a;n`\xA0\x96a;da;\x89\x9Aa;Z`\xC0\x8A\x01\x9E_\x8B\x01\x90a\x07\xD0V[` \x89\x01\x90a\x0C\xF1V[`@\x87\x01\x90a\x0C\xF1V[``\x85\x01\x90a\x06\x91V[`\x80\x83\x01\x90a\x06\x91V[\x01\x90a\x06\x91V[V[\x91` a;\xAC\x92\x94\x93a;\xA5`@\x82\x01\x96_\x83\x01\x90a\x0C\xF1V[\x01\x90a\x0C\xF1V[V[\x96\x95\x91\x93\x92\x94\x90\x94Ba;\xC9a;\xC3\x83a\x06\x08V[\x91a\x06\x08V[\x11a<\x83W\x90a<2a<;\x94\x93\x92a<\x1Aa;\xE3a;\x0CV[a<\x0B\x8C\x80\x94\x8C\x91a;\xF5\x8D\x91aI\xE0V[\x91\x92a;\xFFa\x04\x12V[\x97\x88\x96` \x88\x01a;0V[` \x82\x01\x81\x03\x82R\x03\x82a$\x15V[a<,a<&\x82a8\xC2V[\x91a8\xBCV[ aI6V[\x92\x90\x91\x92aISV[\x80a<Na<H\x87a\x04\xD4V[\x91a\x04\xD4V[\x03a<cWPa<a\x92\x93\x91\x90\x91a=\xD3V[V[\x84\x90a<\x7F_\x92\x83\x92c%\xC0\x07#`\xE1\x1B\x84R`\x04\x84\x01a;\x8BV[\x03\x90\xFD[a<\x9E\x90_\x91\x82\x91c1<\x89\x81`\xE1\x1B\x83R`\x04\x83\x01a\x06\x9EV[\x03\x90\xFD[\x90a<\xBD\x91a<\xB8a<\xB3\x82a&\x08V[a=\xB2V[a<\xBFV[V[\x90a<\xC9\x91aD!V[PV[\x90a<\xD6\x91a<\xA2V[V[\x90a<\xE2\x90a\nLV[_R` R`@_ \x90V[a=\x13\x91a=\ta=\x0E\x92a=\x01a\x1F.V[P`\x01a<\xD8V[a1ZV[a\n\x8AV[\x90V[a= `@a'\xA3V[\x90V[_\x90V[_\x90V[a=3a=\x16V[\x90` \x80\x83a=@a=#V[\x81R\x01a=Ka='V[\x81RPPV[a=Ya=+V[\x90V[\x90a=o\x91a=ia=QV[PaJ\x13V[\x90V[a=za\x1E\x15V[P\x80a=\x95a=\x8Fcye\xDB\x0B`\xE0\x1Ba\x04 V[\x91a\x04 V[\x14\x90\x81\x15a=\xA2W[P\x90V[a=\xAC\x91PaJ;V[_a=\x9EV[a=\xC4\x90a=\xBEa=\xC6V[\x90aJ\x84V[V[a=\xCEa!\x14V[P3\x90V[\x91a=\xE1\x92\x91`\x01\x92aJ\xBFV[V[\x90V[`@\x90a>\x0Fa>\x16\x94\x96\x95\x93\x96a>\x05``\x84\x01\x98_\x85\x01\x90a\x0C\xF1V[` \x83\x01\x90a\x06\x91V[\x01\x90a\x06\x91V[V[\x90a>-a>(`\r\x84\x90a\nXV[a=\xE3V[\x91a>Ka>Ea>@`\x0F\x84\x90a\x0ESV[a\n\xB1V[\x15a\x04mV[\x80\x15a?TW[a?5WBa>\x89a>\x83a>~a>l`\x02\x88\x01a\n\x8AV[a>xb\x01Q\x80a(\x92V[\x90a(\xAEV[a\x06\x08V[\x91a\x06\x08V[\x10\x15a?\x0EW[a>\xB0a>\x9E_\x85\x01a\n\x8AV[a>\xAA`\x04\x86\x01a\n\x8AV[\x90a TV[\x90\x82a>\xC4a>\xBE\x84a\x06\x08V[\x91a\x06\x08V[\x11a>\xEEWPP\x90a>\xE6`\x04a>\xEC\x93\x92\x01\x91a>\xE1\x83a\n\x8AV[a(\xAEV[\x90a.~V[V[a?\n\x83\x92_\x93\x84\x93c@\xED6{`\xE0\x1B\x85R`\x04\x85\x01a=\xE6V[\x03\x90\xFD[a?#a?\x1A_a \nV[`\x04\x85\x01a.~V[a?0B`\x02\x85\x01a.~V[a>\x90V[a?P\x90_\x91\x82\x91ce\x85\xB6\r`\xE0\x1B\x83R`\x04\x83\x01a\x0C\xFEV[\x03\x90\xFD[Pa?ja?d`\x06\x85\x01a\n\xB1V[\x15a\x04mV[a>RV[\x80a?\x8Aa?\x84a?\x7F_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14a?\xA6Wa?\xA4\x91a?\x9C_a\x1E\xB8V[\x91\x90\x91aK\xCEV[V[a?\xC9a?\xB2_a\x1E\xB8V[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x0C\xFEV[\x03\x90\xFD[\x90a?\xD8\x91\x03a\x06\x08V[\x90V[\x92\x91\x92a?\xE9\x81\x83\x90a<\xEEV[\x90\x81a?\xFEa?\xF8_\x19a\x06\x08V[\x91a\x06\x08V[\x10a@\x0BW[PPP\x90PV[\x81a@\x1Ea@\x18\x87a\x06\x08V[\x91a\x06\x08V[\x10a@DWa@;\x93\x94a@3\x91\x93\x92a?\xCDV[\x90_\x92aJ\xBFV[\x80_\x80\x80a@\x04V[Pa@c\x84\x92\x91\x92_\x93\x84\x93c}\xC7\xA0\xD9`\xE1\x1B\x85R`\x04\x85\x01a=\xE6V[\x03\x90\xFD[\x91\x82a@\x83a@}a@x_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14a@\xDDW\x81a@\xA3a@\x9Da@\x98_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14a@\xB6Wa@\xB4\x92\x91\x90\x91aK\xCEV[V[a@\xD9a@\xC2_a\x1E\xB8V[_\x91\x82\x91c\xECD/\x05`\xE0\x1B\x83R`\x04\x83\x01a\x0C\xFEV[\x03\x90\xFD[aA\0a@\xE9_a\x1E\xB8V[_\x91\x82\x91cKc~\x8F`\xE1\x1B\x83R`\x04\x83\x01a\x0C\xFEV[\x03\x90\xFD[\x90aA\x19aA\x14`\r\x84\x90a\nXV[a=\xE3V[\x91aA7aA1aA,`\x0F\x84\x90a\x0ESV[a\n\xB1V[\x15a\x04mV[\x80\x15aBAW[aB\"WBaAuaAoaAjaAX`\x03\x88\x01a\n\x8AV[aAdb\x01Q\x80a(\x92V[\x90a(\xAEV[a\x06\x08V[\x91a\x06\x08V[\x10\x15aA\xFBW[aA\x9DaA\x8B`\x01\x85\x01a\n\x8AV[aA\x97`\x05\x86\x01a\n\x8AV[\x90a TV[\x90\x82aA\xB1aA\xAB\x84a\x06\x08V[\x91a\x06\x08V[\x11aA\xDBWPP\x90aA\xD3`\x05aA\xD9\x93\x92\x01\x91aA\xCE\x83a\n\x8AV[a(\xAEV[\x90a.~V[V[aA\xF7\x83\x92_\x93\x84\x93cr\xFFK\xD1`\xE1\x1B\x85R`\x04\x85\x01a=\xE6V[\x03\x90\xFD[aB\x10aB\x07_a \nV[`\x05\x85\x01a.~V[aB\x1DB`\x03\x85\x01a.~V[aA|V[aB=\x90_\x91\x82\x91ce\x85\xB6\r`\xE0\x1B\x83R`\x04\x83\x01a\x0C\xFEV[\x03\x90\xFD[PaBWaBQ`\x06\x85\x01a\n\xB1V[\x15a\x04mV[aA>V[\x90\x81aBxaBraBm_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14aB\x94WaB\x92\x91\x90aB\x8B_a\x1E\xB8V[\x90\x91aK\xCEV[V[aB\xB7aB\xA0_a\x1E\xB8V[_\x91\x82\x91cKc~\x8F`\xE1\x1B\x83R`\x04\x83\x01a\x0C\xFEV[\x03\x90\xFD[aB\xC3a\x1E\x15V[PaB\xD8aB\xD2\x82\x84\x90a6\xEBV[\x15a\x04mV[_\x14aCaWaC\0`\x01aB\xFB_aB\xF3`\x05\x86\x90a%\xCEV[\x01\x85\x90a\x0ESV[a\x1F\xEAV[\x90aC\ta=\xC6V[\x90aCFaC@aC:\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r\x95a%\xC2V[\x92a\nLV[\x92a\nLV[\x92aCOa\x04\x12V[\x80aCY\x81a\x05!V[\x03\x90\xA4`\x01\x90V[PP_\x90V[aCoa%\xBEV[PaCy0a5\xBCV[aC\xABaC\xA5\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x04\xD4V[\x91a\x04\xD4V[\x14\x80aC\xE7W[_\x14aC\xDCW\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[aC\xE4aL\xE9V[\x90V[PFaD\x1BaD\x15\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x06\x08V[\x91a\x06\x08V[\x14aC\xB2V[aD)a\x1E\x15V[PaD5\x81\x83\x90a6\xEBV[_\x14aD\xBDWaD\\_aDW_aDO`\x05\x86\x90a%\xCEV[\x01\x85\x90a\x0ESV[a\x1F\xEAV[\x90aDea=\xC6V[\x90aD\xA2aD\x9CaD\x96\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x95a%\xC2V[\x92a\nLV[\x92a\nLV[\x92aD\xABa\x04\x12V[\x80aD\xB5\x81a\x05!V[\x03\x90\xA4`\x01\x90V[PP_\x90V[aD\xD7aD\xD2aD\xDC\x92a\x14\xD6V[a\n!V[a\x06\x08V[\x90V[\x91` aE\0\x92\x94\x93aD\xF9`@\x82\x01\x96_\x83\x01\x90a\x06\x91V[\x01\x90a\x14\xE1V[V[aE\na7\x15V[PaE\x13a7\x19V[\x81aE&aE \x83aD\xC3V[\x91a\x06\x08V[\x10\x15aE9WPaE6\x90aM\xF2V[\x90V[\x90aET_\x92\x83\x92cvi\xFC\x0F`\xE1\x1B\x84R`\x04\x84\x01aD\xDFV[\x03\x90\xFD[T\x90V[\x90V[aEsaEnaEx\x92aE\\V[a\n!V[a\x06\x08V[\x90V[\x90V[e\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90V[aE\x95aE\x9A\x91a\nnV[aE~V[\x90V[aE\xA7\x90TaE\x89V[\x90V[`0\x1C\x90V[`\x01\x80`\xD0\x1B\x03\x16\x90V[aE\xC7aE\xCC\x91aE\xAAV[aE\xB0V[\x90V[aE\xD9\x90TaE\xBBV[\x90V[aE\xF0aE\xEBaE\xF5\x92a\x16NV[a\n!V[a\x1C\x91V[\x90V[\x90aFL\x90aF\x05a\x1D\x80V[PaF\x11_\x84\x01aEXV[aF\x1A_a \nV[\x90\x80\x80aF0aF*`\x05aE_V[\x91a\x06\x08V[\x11aF\xADW[P\x90aFG_\x86\x01\x93\x91\x92\x93aE{V[aTAV[\x80aF_aFY_a \nV[\x91a\x06\x08V[\x14_\x14aFuWPPaFq_aE\xDCV[[\x90V[aF\xA2_\x91aF\x9DaF\x97\x84aF\xA8\x96\x01\x92aF\x91`\x01a 8V[\x90a TV[\x91aE{V[aT7V[\x01aE\xCFV[aFrV[\x80aF\xBBaF\xC1\x92\x91aP\xCCV[\x90a TV[\x90\x83aF\xF3aF\xEDaF\xE8_aF\xE2\x81\x8C\x01aF\xDD\x89\x91aE{V[aT7V[\x01aE\x9DV[a\x14\xD6V[\x91a\x14\xD6V[\x10_\x14aG\x04WP\x90[\x90_aF6V[\x91PaG\x1A\x90aG\x14`\x01a 8V[\x90a(\xAEV[aF\xFDV[aG'a7\x15V[PaG1CaM\xF2V[\x90V[\x90aGE`\x01\x80`\xA0\x1B\x03\x91a\x16QV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x90aGdaG_aGk\x92a\nLV[a \xA3V[\x82TaG4V[\x90UV[\x90aG\xF8\x91aG\xF2aG\x80\x82a,\xC7V[aG\x95\x84aG\x90`\t\x86\x90a,\x90V[aGOV[\x82\x81\x85\x90aG\xD5aG\xCFaG\xC9\x7F14\xE8\xA2\xE6\xD9~\x92\x9A~T\x01\x1E\xA5H]}\x19m\xD5\xF0\xBAMN\xF9X\x03\xE8\xE3\xFC%\x7F\x95a\nLV[\x92a\nLV[\x92a\nLV[\x92aG\xDEa\x04\x12V[\x80aG\xE8\x81a\x05!V[\x03\x90\xA4\x92\x91aT\xD0V[\x91aT\xE8V[V[aH!aH\x1CaH\x17aH&\x93aH\x0Fa1AV[P`\na)\xF1V[a*\x07V[aV\x96V[aW\x15V[\x90V[aH;\x90aH5a\x1F.V[PaWfV[\x90V[\x90V[aHIa#\x13V[PaH~\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0aHx`\x06aH>V[\x90aX\x81V[\x90V[aH\x89a#\x13V[PaH\xBE\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0aH\xB8`\x07aH>V[\x90aX\x81V[\x90V[aH\xC9a\x1D\x80V[PaH\xD5_\x82\x01aEXV[\x80aH\xE8aH\xE2_a \nV[\x91a\x06\x08V[\x14_\x14aH\xFEWPPaH\xFA_aE\xDCV[[\x90V[aI+_\x91aI&aI \x84aI1\x96\x01\x92aI\x1A`\x01a 8V[\x90a TV[\x91aE{V[aT7V[\x01aE\xCFV[aH\xFBV[aIP\x90aIBa%\xBEV[PaIKaCgV[aX\xCFV[\x90V[\x92aIn\x92aIw\x94aIda!\x14V[P\x92\x90\x91\x92aY\x95V[\x90\x92\x91\x92aZ\xC0V[\x90V[\x91` aI\x9B\x92\x94\x93aI\x94`@\x82\x01\x96_\x83\x01\x90a\x0C\xF1V[\x01\x90a\x06\x91V[V[aI\xA6\x81aI\xE0V[\x91aI\xB9aI\xB3\x84a\x06\x08V[\x91a\x06\x08V[\x03aI\xC2WPPV[aI\xDC_\x92\x83\x92c\x01\xD4\xB6#`\xE6\x1B\x84R`\x04\x84\x01aIzV[\x03\x90\xFD[aI\xF4\x90aI\xECa\x1F.V[P`\x08a1ZV[aJ\x10aJ\0\x82a\n\x8AV[\x91aJ\n\x83a &V[\x90a.~V[\x90V[\x90aJ3aJ.aJ8\x93aJ&a=QV[P`\na)\xF1V[a*\x07V[a\\\"V[\x90V[aJCa\x1E\x15V[PaJ]aJWc\x01\xFF\xC9\xA7`\xE0\x1Ba\x04 V[\x91a\x04 V[\x14\x90V[\x91` aJ\x82\x92\x94\x93aJ{`@\x82\x01\x96_\x83\x01\x90a\x0C\xF1V[\x01\x90a\x07\xD0V[V[\x90aJ\x99aJ\x93\x83\x83\x90a6\xEBV[\x15a\x04mV[aJ\xA1WPPV[aJ\xBB_\x92\x83\x92c\xE2Q}?`\xE0\x1B\x84R`\x04\x84\x01aJaV[\x03\x90\xFD[\x90\x92\x81aJ\xDCaJ\xD6aJ\xD1_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14aK\xA7W\x83aJ\xFCaJ\xF6aJ\xF1_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14aK\x80WaK \x83aK\x1BaK\x14`\x01\x86\x90a<\xD8V[\x87\x90a1ZV[a.~V[aK*W[PPPV[\x91\x90\x91aKuaKcaK]\x7F\x8C[\xE1\xE5\xEB\xEC}[\xD1OqB}\x1E\x84\xF3\xDD\x03\x14\xC0\xF7\xB2)\x1E[ \n\xC8\xC7\xC3\xB9%\x93a\nLV[\x93a\nLV[\x93aKla\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xA3_\x80\x80aK%V[aK\xA3aK\x8C_a\x1E\xB8V[_\x91\x82\x91cJ\x14\x06\xB1`\xE1\x1B\x83R`\x04\x83\x01a\x0C\xFEV[\x03\x90\xFD[aK\xCAaK\xB3_a\x1E\xB8V[_\x91\x82\x91c\xE6\x02\xDF\x05`\xE0\x1B\x83R`\x04\x83\x01a\x0C\xFEV[\x03\x90\xFD[\x91\x82aK\xEAaK\xE4aK\xDF_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14\x15\x80aLUW[aL\x05W[aL\x03\x92\x91\x90\x91a\\CV[V[aL\ra4UV[\x80aL4W[\x15aK\xF7W_c6\xE2x\xFD`\xE2\x1B\x81R\x80aL0`\x04\x82\x01a\x05!V[\x03\x90\xFD[PaLPaLJaLCa\x13,V[3\x90a6\xEBV[\x15a\x04mV[aL\x13V[P\x81aLqaLkaLf_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14\x15aK\xF2V[\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x90V[\x90\x95\x94\x92aL\xE7\x94aL\xD6aL\xE0\x92aL\xCC`\x80\x96aL\xC2`\xA0\x88\x01\x9C_\x89\x01\x90a\x07\xD0V[` \x87\x01\x90a\x07\xD0V[`@\x85\x01\x90a\x07\xD0V[``\x83\x01\x90a\x06\x91V[\x01\x90a\x0C\xF1V[V[aL\xF1a%\xBEV[PaL\xFAaLxV[aMq\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91aMb\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0FaMM0a5\xBCV[\x91aMVa\x04\x12V[\x96\x87\x95` \x87\x01aL\x9CV[` \x82\x01\x81\x03\x82R\x03\x82a$\x15V[aM\x83aM}\x82a8\xC2V[\x91a8\xBCV[ \x90V[\x90V[aM\x9EaM\x99aM\xA3\x92aM\x87V[a\n!V[a\x08\xF1V[\x90V[aM\xAF\x90aM\x8AV[\x90RV[\x91` aM\xD4\x92\x94\x93aM\xCD`@\x82\x01\x96_\x83\x01\x90aM\xA6V[\x01\x90a\x06\x91V[V[aM\xEAaM\xE5aM\xEF\x92a\x06\x08V[a\n!V[a\x14\xD6V[\x90V[aM\xFAa7\x15V[P\x80aN\x14aN\x0Ee\xFF\xFF\xFF\xFF\xFF\xFFaD\xC3V[\x91a\x06\x08V[\x11aN%WaN\"\x90aM\xD6V[\x90V[`0aNA_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01aM\xB3V[\x03\x90\xFD[\x90V[aN\\aNWaNa\x92aNEV[a\n!V[a\x06\x08V[\x90V[\x90V[aN{aNvaN\x80\x92aNdV[a\n!V[a\x08\xF1V[\x90V[aN\xA2\x90aN\x9CaN\x96aN\xA7\x94a\x08\xF1V[\x91a\x06\x08V[\x90a\x0EiV[a\x06\x08V[\x90V[\x90V[aN\xC1aN\xBCaN\xC6\x92aN\xAAV[a\n!V[a\x08\xF1V[\x90V[aN\xE8\x90aN\xE2aN\xDCaN\xED\x94a\x08\xF1V[\x91a\x06\x08V[\x90a\x1E\xC4V[a\x06\x08V[\x90V[\x90V[aO\x07aO\x02aO\x0C\x92aN\xF0V[a\n!V[a\x06\x08V[\x90V[\x90V[aO&aO!aO+\x92aO\x0FV[a\n!V[a\x08\xF1V[\x90V[\x90V[aOEaO@aOJ\x92aO.V[a\n!V[a\x06\x08V[\x90V[\x90V[aOdaO_aOi\x92aOMV[a\n!V[a\x08\xF1V[\x90V[\x90V[aO\x83aO~aO\x88\x92aOlV[a\n!V[a\x06\x08V[\x90V[\x90V[aO\xA2aO\x9DaO\xA7\x92aO\x8BV[a\n!V[a\x08\xF1V[\x90V[\x90V[aO\xC1aO\xBCaO\xC6\x92aO\xAAV[a\n!V[a\x06\x08V[\x90V[\x90V[aO\xE0aO\xDBaO\xE5\x92aO\xC9V[a\n!V[a\x08\xF1V[\x90V[aO\xFCaO\xF7aP\x01\x92aOMV[a\n!V[a\x06\x08V[\x90V[\x90V[aP\x1BaP\x16aP \x92aP\x04V[a\n!V[a\x08\xF1V[\x90V[aP7aP2aP<\x92aO\xC9V[a\n!V[a\x06\x08V[\x90V[aPSaPNaPX\x92a 5V[a\n!V[a\x08\xF1V[\x90V[\x90V[aPraPmaPw\x92aP[V[a\n!V[a\x06\x08V[\x90V[\x90aP\x85\x91\x02a\x06\x08V[\x90V[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[aP\xA8aP\xAE\x91a\x06\x08V[\x91a\x06\x08V[\x90\x81\x15aP\xB9W\x04\x90V[aP\x88V[\x90aP\xC9\x91\x01a\x06\x08V[\x90V[aP\xD4a\x1F.V[P\x80aP\xE9aP\xE3`\x01a 8V[\x91a\x06\x08V[\x11\x15aT4W\x80aR\xFEaR\xDBaR\xCBaR\xBBaR\xABaR\x9BaR\x8BaR{aRkaR[aRK\x8BaREaR>aS\x04\x9FaR\x1EaR\x0EaR.\x92aQ0`\x01a 8V[\x90\x80aQHaQB`\x01`\x80\x1BaNHV[\x91a\x06\x08V[\x10\x15aT\x06W[\x80aQkaQeh\x01\0\0\0\0\0\0\0\0aN\xF3V[\x91a\x06\x08V[\x10\x15aS\xD8W[\x80aQ\x8AaQ\x84d\x01\0\0\0\0aO1V[\x91a\x06\x08V[\x10\x15aS\xAAW[\x80aQ\xA7aQ\xA1b\x01\0\0aOoV[\x91a\x06\x08V[\x10\x15aS|W[\x80aQ\xC3aQ\xBDa\x01\0aO\xADV[\x91a\x06\x08V[\x10\x15aSNW[\x80aQ\xDEaQ\xD8`\x10aO\xE8V[\x91a\x06\x08V[\x10\x15aS W[aQ\xF8aQ\xF2`\x04aP#V[\x91a\x06\x08V[\x10\x15aS\x07W[aR\t`\x03aP^V[aPzV[aR\x18`\x01aP?V[\x90aN\x83V[aR(\x81\x86aP\x9CV[\x90aP\xBEV[aR8`\x01aP?V[\x90aN\x83V[\x80\x92aP\x9CV[\x90aP\xBEV[aRU`\x01aP?V[\x90aN\x83V[aRe\x81\x8CaP\x9CV[\x90aP\xBEV[aRu`\x01aP?V[\x90aN\x83V[aR\x85\x81\x8AaP\x9CV[\x90aP\xBEV[aR\x95`\x01aP?V[\x90aN\x83V[aR\xA5\x81\x88aP\x9CV[\x90aP\xBEV[aR\xB5`\x01aP?V[\x90aN\x83V[aR\xC5\x81\x86aP\x9CV[\x90aP\xBEV[aR\xD5`\x01aP?V[\x90aN\x83V[\x91aR\xF8aR\xF2aR\xED\x85\x80\x94aP\x9CV[a\x06\x08V[\x91a\x06\x08V[\x11a\\\xD3V[\x90a?\xCDV[\x90V[aS\x1B\x90aS\x15`\x01aP?V[\x90aN\xC9V[aQ\xFFV[aS7aSH\x91aS1`\x04aO\xCCV[\x90aN\x83V[\x91aSB`\x02aP\x07V[\x90aN\xC9V[\x90aQ\xE5V[aSeaSv\x91aS_`\x08aO\x8EV[\x90aN\x83V[\x91aSp`\x04aO\xCCV[\x90aN\xC9V[\x90aQ\xCAV[aS\x93aS\xA4\x91aS\x8D`\x10aOPV[\x90aN\x83V[\x91aS\x9E`\x08aO\x8EV[\x90aN\xC9V[\x90aQ\xAEV[aS\xC1aS\xD2\x91aS\xBB` aO\x12V[\x90aN\x83V[\x91aS\xCC`\x10aOPV[\x90aN\xC9V[\x90aQ\x91V[aS\xEFaT\0\x91aS\xE9`@aN\xADV[\x90aN\x83V[\x91aS\xFA` aO\x12V[\x90aN\xC9V[\x90aQrV[aT\x1DaT.\x91aT\x17`\x80aNgV[\x90aN\x83V[\x91aT(`@aN\xADV[\x90aN\xC9V[\x90aQOV[\x90V[_R` _ \x01\x90V[\x93\x91\x90\x92aTMa\x1F.V[P[\x81aTbaT\\\x83a\x06\x08V[\x91a\x06\x08V[\x10\x15aT\xC8WaTs\x82\x82\x90a]\x1FV[\x90aT\x89_aT\x83\x88\x85\x90aT7V[\x01aE\x9DV[aT\x9BaT\x95\x87a\x14\xD6V[\x91a\x14\xD6V[\x11_\x14aT\xABWP\x91[\x91aTOV[\x92\x91PaT\xC2\x90aT\xBC`\x01a 8V[\x90a(\xAEV[\x90aT\xA5V[\x92PP\x91P\x90V[aT\xE2\x90aT\xDCa\x1F.V[Pa1pV[\x90V[\x90V[\x91\x90\x91\x80aT\xFEaT\xF8\x85a\x04\xD4V[\x91a\x04\xD4V[\x14\x15\x80aV|W[aU\x10W[PPPV[\x80aU+aU%aU _a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x03aU\xECW[P\x81aUMaUGaUB_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x03aUYW[\x80aU\x0BV[aU\xA0aU\x93aU\x9A\x92aUo`\n\x86\x90a)\xF1V[\x90aU\x8DaU\x87aU\x81`\x01\x93a]\xB8V[\x93a*\x07V[\x91aT\xE5V[\x90a^\x0BV[\x92\x90a*\nV[\x91a*\nV[\x91\x90\x91aU\xCD\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\nLV[\x92aU\xE2aU\xD9a\x04\x12V[\x92\x83\x92\x83a.8V[\x03\x90\xA2_\x80aUSV[aV+aV1aV$aV\x01`\n\x85\x90a)\xF1V[`\x02aV\x1EaV\x18aV\x12\x89a]\xB8V[\x93a*\x07V[\x91aT\xE5V[\x90a^\x0BV[\x92\x90a*\nV[\x91a*\nV[\x91\x90\x91aV^\x7F\xDE\xC2\xBA\xCD\xD2\xF0[Y\xDE4\xDA\x9BR=\xFF\x8B\xE4.^8\xE8\x18\xC8/\xDB\x0B\xAEwC\x87\xA7$\x92a\nLV[\x92aVsaVja\x04\x12V[\x92\x83\x92\x83a.8V[\x03\x90\xA2_aU1V[P\x81aV\x90aV\x8A_a \nV[\x91a\x06\x08V[\x11aU\x06V[_aV\xAA\x91aV\xA3a\x1F.V[P\x01aEXV[\x90V[aV\xC1aV\xBCaV\xC6\x92a\x0E\xE1V[a\n!V[a\x06\x08V[\x90V[aV\xD2\x90aO\x12V[\x90RV[\x91` aV\xF7\x92\x94\x93aV\xF0`@\x82\x01\x96_\x83\x01\x90aV\xC9V[\x01\x90a\x06\x91V[V[aW\raW\x08aW\x12\x92a\x06\x08V[a\n!V[a\x0E\xE1V[\x90V[aW\x1Da1AV[P\x80aW5aW/c\xFF\xFF\xFF\xFFaV\xADV[\x91a\x06\x08V[\x11aWFWaWC\x90aV\xF9V[\x90V[` aWb_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01aV\xD6V[\x03\x90\xFD[aW}aW\x82\x91aWua\x1F.V[P`\x08a1ZV[a\n\x8AV[\x90V[\x90V[aW\x9CaW\x97aW\xA1\x92aW\x85V[a\x16QV[a\x07\x8CV[\x90V[aW\xAE`\xFFaW\x88V[\x90V[_R` _ \x90V[\x90_\x92\x91\x80T\x90aW\xD4aW\xCD\x83a#,V[\x80\x94a#VV[\x91`\x01\x81\x16\x90\x81_\x14aX+WP`\x01\x14aW\xEFW[PPPV[aW\xFC\x91\x92\x93\x94PaW\xB1V[\x91_\x92[\x81\x84\x10aX\x13WPP\x01\x90_\x80\x80aW\xEAV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90aX\0V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80aW\xEAV[\x90aXP\x91aW\xBAV[\x90V[\x90aXsaXl\x92aXca\x04\x12V[\x93\x84\x80\x92aXFV[\x03\x83a$\x15V[V[aX~\x90aXSV[\x90V[\x90aX\x8Aa#\x13V[PaX\x94\x82a%\xC2V[aX\xADaX\xA7aX\xA2aW\xA4V[a\x07\x8CV[\x91a\x07\x8CV[\x14\x15_\x14aX\xC2WPaX\xBF\x90a^\x95V[\x90V[aX\xCC\x91PaXuV[\x90V[`B\x91aX\xDAa%\xBEV[P`@Q\x91\x7F\x19\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83R`\x02\x83\x01R`\"\x82\x01R \x90V[_\x90V[aY aY%\x91a\nnV[a\x1E\xEDV[\x90V[\x90V[aY?aY:aYD\x92aY(V[a\n!V[a\x06\x08V[\x90V[aY|aY\x83\x94aYr``\x94\x98\x97\x95aYh`\x80\x86\x01\x9A_\x87\x01\x90a\x07\xD0V[` \x85\x01\x90a\x08\xF7V[`@\x83\x01\x90a\x07\xD0V[\x01\x90a\x07\xD0V[V[aY\x8Da\x04\x12V[=_\x82>=\x90\xFD[\x93\x92\x93aY\xA0a!\x14V[PaY\xA9aY\x10V[PaY\xB2a%\xBEV[PaY\xBC\x85aY\x14V[aY\xEEaY\xE8\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0aY+V[\x91a\x06\x08V[\x11aZ{W\x90aZ\x11` \x94\x95_\x94\x93\x92\x93aZ\x08a\x04\x12V[\x94\x85\x94\x85aYGV[\x83\x80R\x03\x90`\x01Z\xFA\x15aZvWaZ)_Qa\x16QV[\x80aZDaZ>aZ9_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14aZZW_\x91aZT_a\x16VV[\x91\x92\x91\x90V[PaZd_a\x1E\xB8V[`\x01\x91aZp_a\x16VV[\x91\x92\x91\x90V[aY\x85V[PPPaZ\x87_a\x1E\xB8V[\x90`\x03\x92\x91\x92\x91\x90V[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x04\x11\x15aZ\xAFWV[aZ\x91V[\x90aZ\xBE\x82aZ\xA5V[V[\x80aZ\xD3aZ\xCD_aZ\xB4V[\x91aZ\xB4V[\x14_\x14aZ\xDEWPPV[\x80aZ\xF2aZ\xEC`\x01aZ\xB4V[\x91aZ\xB4V[\x14_\x14a[\x15W_c\xF6E\xEE\xDF`\xE0\x1B\x81R\x80a[\x11`\x04\x82\x01a\x05!V[\x03\x90\xFD[\x80a[)a[#`\x02aZ\xB4V[\x91aZ\xB4V[\x14_\x14a[WWa[Sa[<\x83aY\x14V[_\x91\x82\x91c\xFC\xE6\x98\xF7`\xE0\x1B\x83R`\x04\x83\x01a\x06\x9EV[\x03\x90\xFD[a[ja[d`\x03aZ\xB4V[\x91aZ\xB4V[\x14a[rWPV[a[\x8D\x90_\x91\x82\x91c5\xE2\xF3\x83`\xE2\x1B\x83R`\x04\x83\x01a\x07\xDDV[\x03\x90\xFD[_R` _ \x90V[a[\xA3\x81aEXV[\x82\x10\x15a[\xBDWa[\xB5`\x01\x91a[\x91V[\x91\x02\x01\x90_\x90V[a\x16\xBEV[\x90a[\xCC\x90a\x14\xD6V[\x90RV[\x90a[\xDA\x90a\x1C\x91V[\x90RV[\x90a\\\x14a\\\x0B_a[\xEEa=\x16V[\x94a\\\x05a[\xFD\x83\x83\x01aE\x9DV[\x83\x88\x01a[\xC2V[\x01aE\xCFV[` \x84\x01a[\xD0V[V[a\\\x1F\x90a[\xDEV[\x90V[a\\@\x91_a\\:\x92a\\3a=QV[P\x01a[\x9AV[Pa\\\x16V[\x90V[\x92\x91a\\Q\x84\x83\x83\x91a^\xC5V[\x83a\\la\\fa\\a_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14a\\\x81W[a\\\x7F\x92\x93\x91\x90\x91a`OV[V[a\\\x89a$\xA4V[\x93a\\\x92a`4V[\x94\x80a\\\xA6a\\\xA0\x88a\x06\x08V[\x91a\x06\x08V[\x11a\\\xB3WP\x93Pa\\rV[\x85\x90a\\\xCF_\x92\x83\x92c\x0EX\xAE\x93`\xE1\x1B\x84R`\x04\x84\x01a.8V[\x03\x90\xFD[a\\\xDBa\x1F.V[P\x15\x15\x90V[a\\\xF5a\\\xF0a\\\xFA\x92aP\x04V[a\n!V[a\x06\x08V[\x90V[a]\ta]\x0F\x91a\x06\x08V[\x91a\x06\x08V[\x90\x81\x15a]\x1AW\x04\x90V[aP\x88V[a]Da]J\x92a].a\x1F.V[P\x82\x81\x16\x92\x18a]>`\x02a\\\xE1V[\x90a\\\xFDV[\x90a(\xAEV[\x90V[\x90V[a]da]_a]i\x92a]MV[a\n!V[a\x08\xF1V[\x90V[a]u\x90a]PV[\x90RV[\x91` a]\x9A\x92\x94\x93a]\x93`@\x82\x01\x96_\x83\x01\x90a]lV[\x01\x90a\x06\x91V[V[a]\xB0a]\xABa]\xB5\x92a\x06\x08V[a\n!V[a\x1C\x91V[\x90V[a]\xC0a\x1D\x80V[P\x80a]\xDAa]\xD4`\x01\x80`\xD0\x1B\x03a*\nV[\x91a\x06\x08V[\x11a]\xEBWa]\xE8\x90a]\x9CV[\x90V[`\xD0a^\x07_\x92\x83\x92c\x06\xDF\xCCe`\xE4\x1B\x84R`\x04\x84\x01a]yV[\x03\x90\xFD[\x90a^Aa^G\x93\x92a^\x1Ca\x1D\x80V[Pa^%a\x1D\x80V[P\x80\x93a^:a^3a7\x19V[\x94\x92aH\xC1V[\x90\x91ad\xB7V[\x91aa\x0EV[\x91\x90\x91\x90V[a^aa^\\a^f\x92aO\x0FV[a\n!V[a\x06\x08V[\x90V[6\x907V[\x90a^\x93a^{\x83a+\xD8V[\x92` \x80a^\x89\x86\x93a+\xB5V[\x92\x01\x91\x03\x90a^iV[V[a^\x9Da#\x13V[Pa^\xA7\x81aaxV[\x90a^\xBAa^\xB5` a^MV[a^nV[\x91\x82R` \x82\x01R\x90V[\x91\x90\x91\x80a^\xE3a^\xDDa^\xD8_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14_\x14a_\xC4Wa_\x07a_\0\x83a^\xFB`\x02a\n\x8AV[a(\xAEV[`\x02a.~V[[\x82a_#a_\x1Da_\x18_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14_\x14a_\x98Wa_Ga_@\x83a_;`\x02a\n\x8AV[a?\xCDV[`\x02a.~V[[\x91\x90\x91a_\x93a_\x81a_{\x7F\xDD\xF2R\xAD\x1B\xE2\xC8\x9Bi\xC2\xB0h\xFC7\x8D\xAA\x95+\xA7\xF1c\xC4\xA1\x16(\xF5ZM\xF5#\xB3\xEF\x93a\nLV[\x93a\nLV[\x93a_\x8Aa\x04\x12V[\x91\x82\x91\x82a\x06\x9EV[\x03\x90\xA3V[a_\xBF\x82a_\xB9a_\xAA_\x87\x90a1ZV[\x91a_\xB4\x83a\n\x8AV[aP\xBEV[\x90a.~V[a_HV[a_\xD7a_\xD2_\x83\x90a1ZV[a\n\x8AV[\x80a_\xEAa_\xE4\x85a\x06\x08V[\x91a\x06\x08V[\x10a`\x12Wa_\xFDa`\r\x91\x84\x90a?\xCDV[a`\x08_\x84\x90a1ZV[a.~V[a_\x08V[\x90a`0\x90\x91\x92_\x93\x84\x93c9\x144\xE3`\xE2\x1B\x85R`\x04\x85\x01a=\xE6V[\x03\x90\xFD[a`<a\x1F.V[Pa`L`\x01\x80`\xD0\x1B\x03a*\nV[\x90V[\x91a`\xA7a`\xA1a`\xAE\x94\x80a`ua`oa`j_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14a`\xDFW[\x84a`\x96a`\x90a`\x8B_a\x1E\xB8V[a\x04\xD4V[\x91a\x04\xD4V[\x14a`\xB0W[a,\xC7V[\x92a,\xC7V[\x90\x91aT\xE8V[V[a`\xD8`\x0B`\x02a`\xD2a`\xCCa`\xC6\x89a]\xB8V[\x93a*\x07V[\x91aT\xE5V[\x90a^\x0BV[PPa`\x9CV[aa\x07`\x0B`\x01aa\x01a`\xFBa`\xF5\x89a]\xB8V[\x93a*\x07V[\x91aT\xE5V[\x90a^\x0BV[PPa`{V[\x91aa2_aa7\x94aa\x1Fa\x1D\x80V[Paa(a\x1D\x80V[P\x01\x92\x91\x92aE{V[aciV[\x91\x90\x91\x90V[aaQaaLaaV\x92aW\x85V[a\n!V[a\x06\x08V[\x90V[\x90V[aapaakaau\x92aaYV[a\n!V[a\x06\x08V[\x90V[aa\x8Daa\x92\x91aa\x87a\x1F.V[Pa%\xC2V[aY\x14V[aa\x9C`\xFFaa=V[\x16\x80aa\xB1aa\xAB`\x1Faa\\V[\x91a\x06\x08V[\x11aa\xB9W\x90V[_c,\xD4J\xC3`\xE2\x1B\x81R\x80aa\xD1`\x04\x82\x01a\x05!V[\x03\x90\xFD[T\x90V[aa\xE3`@a'\xA3V[\x90V[_R` _ \x90V[aa\xF8\x81aa\xD5V[\x82\x10\x15ab\x12Wab\n`\x01\x91aa\xE6V[\x91\x02\x01\x90_\x90V[a\x16\xBEV[ab!\x90Qa\x14\xD6V[\x90V[\x90ab5e\xFF\xFF\xFF\xFF\xFF\xFF\x91a\x16QV[\x91\x81\x19\x16\x91\x16\x17\x90V[abSabNabX\x92a\x14\xD6V[a\n!V[a\x14\xD6V[\x90V[\x90V[\x90absabnabz\x92ab?V[ab[V[\x82Tab$V[\x90UV[ab\x88\x90Qa\x1C\x91V[\x90V[`0\x1B\x90V[\x90ab\xA3e\xFF\xFF\xFF\xFF\xFF\xFF\x19\x91ab\x8BV[\x91\x81\x19\x16\x91\x16\x17\x90V[ab\xC1ab\xBCab\xC6\x92a\x1C\x91V[a\n!V[a\x1C\x91V[\x90V[\x90V[\x90ab\xE1ab\xDCab\xE8\x92ab\xADV[ab\xC9V[\x82Tab\x91V[\x90UV[\x90ac\x16` _ac\x1C\x94ac\x0E\x82\x82\x01ac\x08\x84\x88\x01ab\x17V[\x90ab^V[\x01\x92\x01ab~V[\x90ab\xCCV[V[\x91\x90ac/Wac-\x91ab\xECV[V[a\x1F\x9BV[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15acdW\x82ac\\\x91`\x01acb\x95\x01\x81Uaa\xEFV[\x90ac\x1EV[V[a$\x01V[\x90\x92\x91\x92acua\x1D\x80V[Pac~a\x1D\x80V[Pac\x88\x82aa\xD5V[\x80ac\x9Bac\x95_a \nV[\x91a\x06\x08V[\x11_\x14adkWac\xC1\x90ac\xBB\x84\x91ac\xB5`\x01a 8V[\x90a TV[\x90aT7V[\x90ac\xCD_\x83\x01aE\x9DV[\x92ac\xD9_\x84\x01aE\xCFV[\x93\x80ac\xEDac\xE7\x85a\x14\xD6V[\x91a\x14\xD6V[\x11adOWad\x04ac\xFE\x84a\x14\xD6V[\x91a\x14\xD6V[\x14_\x14ad\x1FWPPad\x1A\x90_\x85\x91\x01ab\xCCV[[\x91\x90V[adJ\x92PadE\x86ad<ad3aa\xD9V[\x94_\x86\x01a[\xC2V[` \x84\x01a[\xD0V[ac4V[ad\x1BV[_c% `\x1D`\xE0\x1B\x81R\x80adg`\x04\x82\x01a\x05!V[\x03\x90\xFD[Pad\x96\x91ad\x91\x85ad\x88ad\x7Faa\xD9V[\x94_\x86\x01a[\xC2V[` \x84\x01a[\xD0V[ac4V[ad\x9F_aE\xDCV[\x91\x90V[cNH{q`\xE0\x1B_R`Q`\x04R`$_\xFD[\x91\x90\x91\x80`\x01\x14ad\xD6W`\x02\x03ad\xA3Wad\xD2\x91a\x1D\xFFV[\x90[V[Pad\xE0\x91a\x1D\xC0V[\x90ad\xD4V",
    );
    /**Custom error with signature `AccessControlBadConfirmation()` and selector `0x6697b232`.
```solidity
error AccessControlBadConfirmation();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlBadConfirmation {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlBadConfirmation>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlBadConfirmation) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlBadConfirmation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlBadConfirmation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlBadConfirmation()";
            const SELECTOR: [u8; 4] = [102u8, 151u8, 178u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `AccessControlUnauthorizedAccount(address,bytes32)` and selector `0xe2517d3f`.
```solidity
error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub neededRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlUnauthorizedAccount) -> Self {
                (value.account, value.neededRole)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    neededRole: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlUnauthorizedAccount(address,bytes32)";
            const SELECTOR: [u8; 4] = [226u8, 81u8, 125u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.neededRole),
                )
            }
        }
    };
    /**Custom error with signature `BridgeNotActive(address)` and selector `0xefda0e06`.
```solidity
error BridgeNotActive(address bridge);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BridgeNotActive {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BridgeNotActive> for UnderlyingRustTuple<'_> {
            fn from(value: BridgeNotActive) -> Self {
                (value.bridge,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BridgeNotActive {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { bridge: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BridgeNotActive {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BridgeNotActive(address)";
            const SELECTOR: [u8; 4] = [239u8, 218u8, 14u8, 6u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `BurnOnlyDuringLockPeriod()` and selector `0xb8b5ca2d`.
```solidity
error BurnOnlyDuringLockPeriod();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BurnOnlyDuringLockPeriod {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BurnOnlyDuringLockPeriod>
        for UnderlyingRustTuple<'_> {
            fn from(value: BurnOnlyDuringLockPeriod) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for BurnOnlyDuringLockPeriod {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BurnOnlyDuringLockPeriod {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BurnOnlyDuringLockPeriod()";
            const SELECTOR: [u8; 4] = [184u8, 181u8, 202u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `CheckpointUnorderedInsertion()` and selector `0x2520601d`.
```solidity
error CheckpointUnorderedInsertion();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CheckpointUnorderedInsertion {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CheckpointUnorderedInsertion>
        for UnderlyingRustTuple<'_> {
            fn from(value: CheckpointUnorderedInsertion) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for CheckpointUnorderedInsertion {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CheckpointUnorderedInsertion {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CheckpointUnorderedInsertion()";
            const SELECTOR: [u8; 4] = [37u8, 32u8, 96u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignature()` and selector `0xf645eedf`.
```solidity
error ECDSAInvalidSignature();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignature {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignature> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignature) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignature()";
            const SELECTOR: [u8; 4] = [246u8, 69u8, 238u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureLength(uint256)` and selector `0xfce698f7`.
```solidity
error ECDSAInvalidSignatureLength(uint256 length);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureLength {
        #[allow(missing_docs)]
        pub length: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureLength>
        for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureLength) -> Self {
                (value.length,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ECDSAInvalidSignatureLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { length: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureLength(uint256)";
            const SELECTOR: [u8; 4] = [252u8, 230u8, 152u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.length),
                )
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureS(bytes32)` and selector `0xd78bce0c`.
```solidity
error ECDSAInvalidSignatureS(bytes32 s);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureS {
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureS> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureS) -> Self {
                (value.s,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignatureS {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { s: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureS {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureS(bytes32)";
            const SELECTOR: [u8; 4] = [215u8, 139u8, 206u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
        }
    };
    /**Custom error with signature `ERC20ExceededSafeSupply(uint256,uint256)` and selector `0x1cb15d26`.
```solidity
error ERC20ExceededSafeSupply(uint256 increasedSupply, uint256 cap);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20ExceededSafeSupply {
        #[allow(missing_docs)]
        pub increasedSupply: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub cap: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20ExceededSafeSupply> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20ExceededSafeSupply) -> Self {
                (value.increasedSupply, value.cap)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20ExceededSafeSupply {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    increasedSupply: tuple.0,
                    cap: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20ExceededSafeSupply {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20ExceededSafeSupply(uint256,uint256)";
            const SELECTOR: [u8; 4] = [28u8, 177u8, 93u8, 38u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.increasedSupply),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.cap),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InsufficientAllowance(address,uint256,uint256)` and selector `0xfb8f41b2`.
```solidity
error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InsufficientAllowance {
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub allowance: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub needed: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InsufficientAllowance>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InsufficientAllowance) -> Self {
                (value.spender, value.allowance, value.needed)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC20InsufficientAllowance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    spender: tuple.0,
                    allowance: tuple.1,
                    needed: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InsufficientAllowance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InsufficientAllowance(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [251u8, 143u8, 65u8, 178u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.allowance),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.needed),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InsufficientBalance(address,uint256,uint256)` and selector `0xe450d38c`.
```solidity
error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InsufficientBalance {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub balance: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub needed: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InsufficientBalance>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InsufficientBalance) -> Self {
                (value.sender, value.balance, value.needed)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC20InsufficientBalance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    sender: tuple.0,
                    balance: tuple.1,
                    needed: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InsufficientBalance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InsufficientBalance(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [228u8, 80u8, 211u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.balance),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.needed),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidApprover(address)` and selector `0xe602df05`.
```solidity
error ERC20InvalidApprover(address approver);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidApprover {
        #[allow(missing_docs)]
        pub approver: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidApprover> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidApprover) -> Self {
                (value.approver,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidApprover {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { approver: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidApprover {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidApprover(address)";
            const SELECTOR: [u8; 4] = [230u8, 2u8, 223u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.approver,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidReceiver(address)` and selector `0xec442f05`.
```solidity
error ERC20InvalidReceiver(address receiver);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidReceiver {
        #[allow(missing_docs)]
        pub receiver: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidReceiver> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidReceiver) -> Self {
                (value.receiver,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidReceiver {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { receiver: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidReceiver {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidReceiver(address)";
            const SELECTOR: [u8; 4] = [236u8, 68u8, 47u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.receiver,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidSender(address)` and selector `0x96c6fd1e`.
```solidity
error ERC20InvalidSender(address sender);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidSender {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidSender> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidSender) -> Self {
                (value.sender,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidSender {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { sender: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidSender {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidSender(address)";
            const SELECTOR: [u8; 4] = [150u8, 198u8, 253u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC20InvalidSpender(address)` and selector `0x94280d62`.
```solidity
error ERC20InvalidSpender(address spender);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC20InvalidSpender {
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC20InvalidSpender> for UnderlyingRustTuple<'_> {
            fn from(value: ERC20InvalidSpender) -> Self {
                (value.spender,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC20InvalidSpender {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { spender: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC20InvalidSpender {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC20InvalidSpender(address)";
            const SELECTOR: [u8; 4] = [148u8, 40u8, 13u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC2612ExpiredSignature(uint256)` and selector `0x62791302`.
```solidity
error ERC2612ExpiredSignature(uint256 deadline);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC2612ExpiredSignature {
        #[allow(missing_docs)]
        pub deadline: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC2612ExpiredSignature> for UnderlyingRustTuple<'_> {
            fn from(value: ERC2612ExpiredSignature) -> Self {
                (value.deadline,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC2612ExpiredSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { deadline: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC2612ExpiredSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC2612ExpiredSignature(uint256)";
            const SELECTOR: [u8; 4] = [98u8, 121u8, 19u8, 2u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.deadline),
                )
            }
        }
    };
    /**Custom error with signature `ERC2612InvalidSigner(address,address)` and selector `0x4b800e46`.
```solidity
error ERC2612InvalidSigner(address signer, address owner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC2612InvalidSigner {
        #[allow(missing_docs)]
        pub signer: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC2612InvalidSigner> for UnderlyingRustTuple<'_> {
            fn from(value: ERC2612InvalidSigner) -> Self {
                (value.signer, value.owner)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC2612InvalidSigner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    signer: tuple.0,
                    owner: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC2612InvalidSigner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC2612InvalidSigner(address,address)";
            const SELECTOR: [u8; 4] = [75u8, 128u8, 14u8, 70u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signer,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC5805FutureLookup(uint256,uint48)` and selector `0xecd3f81e`.
```solidity
error ERC5805FutureLookup(uint256 timepoint, uint48 clock);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC5805FutureLookup {
        #[allow(missing_docs)]
        pub timepoint: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub clock: alloy::sol_types::private::primitives::aliases::U48,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<48>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U48,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC5805FutureLookup> for UnderlyingRustTuple<'_> {
            fn from(value: ERC5805FutureLookup) -> Self {
                (value.timepoint, value.clock)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC5805FutureLookup {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    timepoint: tuple.0,
                    clock: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC5805FutureLookup {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC5805FutureLookup(uint256,uint48)";
            const SELECTOR: [u8; 4] = [236u8, 211u8, 248u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.timepoint),
                    <alloy::sol_types::sol_data::Uint<
                        48,
                    > as alloy_sol_types::SolType>::tokenize(&self.clock),
                )
            }
        }
    };
    /**Custom error with signature `ERC6372InconsistentClock()` and selector `0x6ff07140`.
```solidity
error ERC6372InconsistentClock();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC6372InconsistentClock {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC6372InconsistentClock>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC6372InconsistentClock) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC6372InconsistentClock {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC6372InconsistentClock {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC6372InconsistentClock()";
            const SELECTOR: [u8; 4] = [111u8, 240u8, 113u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ExceedsTotalSupply()` and selector `0x177e3fc3`.
```solidity
error ExceedsTotalSupply();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExceedsTotalSupply {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExceedsTotalSupply> for UnderlyingRustTuple<'_> {
            fn from(value: ExceedsTotalSupply) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ExceedsTotalSupply {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ExceedsTotalSupply {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ExceedsTotalSupply()";
            const SELECTOR: [u8; 4] = [23u8, 126u8, 63u8, 195u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InsufficientBurnLimit(address,uint256,uint256)` and selector `0xe5fe97a2`.
```solidity
error InsufficientBurnLimit(address bridge, uint256 requested, uint256 available);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientBurnLimit {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub requested: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub available: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientBurnLimit> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientBurnLimit) -> Self {
                (value.bridge, value.requested, value.available)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientBurnLimit {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    bridge: tuple.0,
                    requested: tuple.1,
                    available: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientBurnLimit {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientBurnLimit(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [229u8, 254u8, 151u8, 162u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.requested),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.available),
                )
            }
        }
    };
    /**Custom error with signature `InsufficientMintLimit(address,uint256,uint256)` and selector `0x40ed367b`.
```solidity
error InsufficientMintLimit(address bridge, uint256 requested, uint256 available);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientMintLimit {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub requested: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub available: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientMintLimit> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientMintLimit) -> Self {
                (value.bridge, value.requested, value.available)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientMintLimit {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    bridge: tuple.0,
                    requested: tuple.1,
                    available: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientMintLimit {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientMintLimit(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [64u8, 237u8, 54u8, 123u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.requested),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.available),
                )
            }
        }
    };
    /**Custom error with signature `InvalidAccountNonce(address,uint256)` and selector `0x752d88c0`.
```solidity
error InvalidAccountNonce(address account, uint256 currentNonce);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidAccountNonce {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub currentNonce: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidAccountNonce> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidAccountNonce) -> Self {
                (value.account, value.currentNonce)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidAccountNonce {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    currentNonce: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidAccountNonce {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidAccountNonce(address,uint256)";
            const SELECTOR: [u8; 4] = [117u8, 45u8, 136u8, 192u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.currentNonce),
                )
            }
        }
    };
    /**Custom error with signature `InvalidShortString()` and selector `0xb3512b0c`.
```solidity
error InvalidShortString();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidShortString {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidShortString> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidShortString) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidShortString {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidShortString {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidShortString()";
            const SELECTOR: [u8; 4] = [179u8, 81u8, 43u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `SafeCastOverflowedUintDowncast(uint8,uint256)` and selector `0x6dfcc650`.
```solidity
error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SafeCastOverflowedUintDowncast {
        #[allow(missing_docs)]
        pub bits: u8,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            u8,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SafeCastOverflowedUintDowncast>
        for UnderlyingRustTuple<'_> {
            fn from(value: SafeCastOverflowedUintDowncast) -> Self {
                (value.bits, value.value)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SafeCastOverflowedUintDowncast {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    bits: tuple.0,
                    value: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SafeCastOverflowedUintDowncast {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SafeCastOverflowedUintDowncast(uint8,uint256)";
            const SELECTOR: [u8; 4] = [109u8, 252u8, 198u8, 80u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.bits),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
        }
    };
    /**Custom error with signature `StringTooLong(string)` and selector `0x305a27a9`.
```solidity
error StringTooLong(string str);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct StringTooLong {
        #[allow(missing_docs)]
        pub str: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<StringTooLong> for UnderlyingRustTuple<'_> {
            fn from(value: StringTooLong) -> Self {
                (value.str,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for StringTooLong {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { str: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for StringTooLong {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "StringTooLong(string)";
            const SELECTOR: [u8; 4] = [48u8, 90u8, 39u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.str,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `TransfersLocked()` and selector `0xdb89e3f4`.
```solidity
error TransfersLocked();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TransfersLocked {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TransfersLocked> for UnderlyingRustTuple<'_> {
            fn from(value: TransfersLocked) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TransfersLocked {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TransfersLocked {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TransfersLocked()";
            const SELECTOR: [u8; 4] = [219u8, 137u8, 227u8, 244u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `UnauthorizedBridge(address)` and selector `0x6585b60d`.
```solidity
error UnauthorizedBridge(address bridge);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UnauthorizedBridge {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnauthorizedBridge> for UnderlyingRustTuple<'_> {
            fn from(value: UnauthorizedBridge) -> Self {
                (value.bridge,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for UnauthorizedBridge {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { bridge: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UnauthorizedBridge {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UnauthorizedBridge(address)";
            const SELECTOR: [u8; 4] = [101u8, 133u8, 182u8, 13u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `UnlockTimestampInPast()` and selector `0xa5658353`.
```solidity
error UnlockTimestampInPast();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UnlockTimestampInPast {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnlockTimestampInPast> for UnderlyingRustTuple<'_> {
            fn from(value: UnlockTimestampInPast) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for UnlockTimestampInPast {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UnlockTimestampInPast {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UnlockTimestampInPast()";
            const SELECTOR: [u8; 4] = [165u8, 101u8, 131u8, 83u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `UnlockTimestampTooLate()` and selector `0xef69af65`.
```solidity
error UnlockTimestampTooLate();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UnlockTimestampTooLate {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnlockTimestampTooLate> for UnderlyingRustTuple<'_> {
            fn from(value: UnlockTimestampTooLate) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for UnlockTimestampTooLate {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UnlockTimestampTooLate {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UnlockTimestampTooLate()";
            const SELECTOR: [u8; 4] = [239u8, 105u8, 175u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `VotesExpiredSignature(uint256)` and selector `0x4683af0e`.
```solidity
error VotesExpiredSignature(uint256 expiry);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct VotesExpiredSignature {
        #[allow(missing_docs)]
        pub expiry: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<VotesExpiredSignature> for UnderlyingRustTuple<'_> {
            fn from(value: VotesExpiredSignature) -> Self {
                (value.expiry,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for VotesExpiredSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { expiry: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for VotesExpiredSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "VotesExpiredSignature(uint256)";
            const SELECTOR: [u8; 4] = [70u8, 131u8, 175u8, 14u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expiry),
                )
            }
        }
    };
    /**Custom error with signature `ZeroAddress()` and selector `0xd92e233d`.
```solidity
error ZeroAddress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAddress {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAddress> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAddress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAddress()";
            const SELECTOR: [u8; 4] = [217u8, 46u8, 35u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ZeroAmount()` and selector `0x1f2a2005`.
```solidity
error ZeroAmount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAmount {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAmount> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAmount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAmount()";
            const SELECTOR: [u8; 4] = [31u8, 42u8, 32u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Event with signature `Approval(address,address,uint256)` and selector `0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925`.
```solidity
event Approval(address indexed owner, address indexed spender, uint256 value);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Approval {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Approval {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Approval(address,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                140u8,
                91u8,
                225u8,
                229u8,
                235u8,
                236u8,
                125u8,
                91u8,
                209u8,
                79u8,
                113u8,
                66u8,
                125u8,
                30u8,
                132u8,
                243u8,
                221u8,
                3u8,
                20u8,
                192u8,
                247u8,
                178u8,
                41u8,
                30u8,
                91u8,
                32u8,
                10u8,
                200u8,
                199u8,
                195u8,
                185u8,
                37u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    owner: topics.1,
                    spender: topics.2,
                    value: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.owner.clone(), self.spender.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.owner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.spender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Approval {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Approval> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Approval) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeActiveStatusChanged(address,bool)` and selector `0x9c8668db324845065d2b9a2a183bd3141f63018f548282daf18da49ccbf88c33`.
```solidity
event BridgeActiveStatusChanged(address indexed bridge, bool isActive);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeActiveStatusChanged {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub isActive: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeActiveStatusChanged {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeActiveStatusChanged(address,bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                156u8,
                134u8,
                104u8,
                219u8,
                50u8,
                72u8,
                69u8,
                6u8,
                93u8,
                43u8,
                154u8,
                42u8,
                24u8,
                59u8,
                211u8,
                20u8,
                31u8,
                99u8,
                1u8,
                143u8,
                84u8,
                130u8,
                130u8,
                218u8,
                241u8,
                141u8,
                164u8,
                156u8,
                203u8,
                248u8,
                140u8,
                51u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    bridge: topics.1,
                    isActive: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.isActive,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.bridge.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridge,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeActiveStatusChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeActiveStatusChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &BridgeActiveStatusChanged,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeAdded(address,uint256,uint256)` and selector `0xdb03f97dc5840a71e69be7470e4761af10a1237973e81c12d0dc2813895a6526`.
```solidity
event BridgeAdded(address indexed bridge, uint256 dailyMintLimit, uint256 dailyBurnLimit);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeAdded {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub dailyMintLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub dailyBurnLimit: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeAdded {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeAdded(address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                219u8,
                3u8,
                249u8,
                125u8,
                197u8,
                132u8,
                10u8,
                113u8,
                230u8,
                155u8,
                231u8,
                71u8,
                14u8,
                71u8,
                97u8,
                175u8,
                16u8,
                161u8,
                35u8,
                121u8,
                115u8,
                232u8,
                28u8,
                18u8,
                208u8,
                220u8,
                40u8,
                19u8,
                137u8,
                90u8,
                101u8,
                38u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    bridge: topics.1,
                    dailyMintLimit: data.0,
                    dailyBurnLimit: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.dailyMintLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.dailyBurnLimit),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.bridge.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridge,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeAdded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeAdded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeAdded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeLimitsSet(address,uint256,uint256)` and selector `0xaa807d0abf30d91968c7478c66b6d82521a106af13eda036e2036da9af168958`.
```solidity
event BridgeLimitsSet(address indexed bridge, uint256 dailyMintLimit, uint256 dailyBurnLimit);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeLimitsSet {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub dailyMintLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub dailyBurnLimit: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeLimitsSet {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeLimitsSet(address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                170u8,
                128u8,
                125u8,
                10u8,
                191u8,
                48u8,
                217u8,
                25u8,
                104u8,
                199u8,
                71u8,
                140u8,
                102u8,
                182u8,
                216u8,
                37u8,
                33u8,
                161u8,
                6u8,
                175u8,
                19u8,
                237u8,
                160u8,
                54u8,
                226u8,
                3u8,
                109u8,
                169u8,
                175u8,
                22u8,
                137u8,
                88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    bridge: topics.1,
                    dailyMintLimit: data.0,
                    dailyBurnLimit: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.dailyMintLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.dailyBurnLimit),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.bridge.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridge,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeLimitsSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeLimitsSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeLimitsSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BridgeRemoved(address)` and selector `0x5d9d5034656cb3ebfb0655057cd7f9b4077a9b42ff42ce223cbac5bc586d2126`.
```solidity
event BridgeRemoved(address indexed bridge);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeRemoved {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeRemoved {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeRemoved(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                93u8,
                157u8,
                80u8,
                52u8,
                101u8,
                108u8,
                179u8,
                235u8,
                251u8,
                6u8,
                85u8,
                5u8,
                124u8,
                215u8,
                249u8,
                180u8,
                7u8,
                122u8,
                155u8,
                66u8,
                255u8,
                66u8,
                206u8,
                34u8,
                60u8,
                186u8,
                197u8,
                188u8,
                88u8,
                109u8,
                33u8,
                38u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { bridge: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.bridge.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridge,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeRemoved {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeRemoved> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeRemoved) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `CrosschainBurn(address,uint256,address)` and selector `0xb90795a66650155983e242cac3e1ac1a4dc26f8ed2987f3ce416a34e00111fd4`.
```solidity
event CrosschainBurn(address indexed from, uint256 amount, address indexed bridge);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct CrosschainBurn {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for CrosschainBurn {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "CrosschainBurn(address,uint256,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                185u8,
                7u8,
                149u8,
                166u8,
                102u8,
                80u8,
                21u8,
                89u8,
                131u8,
                226u8,
                66u8,
                202u8,
                195u8,
                225u8,
                172u8,
                26u8,
                77u8,
                194u8,
                111u8,
                142u8,
                210u8,
                152u8,
                127u8,
                60u8,
                228u8,
                22u8,
                163u8,
                78u8,
                0u8,
                17u8,
                31u8,
                212u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    from: topics.1,
                    amount: data.0,
                    bridge: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.from.clone(), self.bridge.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.from,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridge,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for CrosschainBurn {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&CrosschainBurn> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &CrosschainBurn) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `CrosschainMint(address,uint256,address)` and selector `0xde22baff038e3a3e08407cbdf617deed74e869a7ba517df611e33131c6e6ea04`.
```solidity
event CrosschainMint(address indexed to, uint256 amount, address indexed bridge);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct CrosschainMint {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for CrosschainMint {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "CrosschainMint(address,uint256,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                222u8,
                34u8,
                186u8,
                255u8,
                3u8,
                142u8,
                58u8,
                62u8,
                8u8,
                64u8,
                124u8,
                189u8,
                246u8,
                23u8,
                222u8,
                237u8,
                116u8,
                232u8,
                105u8,
                167u8,
                186u8,
                81u8,
                125u8,
                246u8,
                17u8,
                227u8,
                49u8,
                49u8,
                198u8,
                230u8,
                234u8,
                4u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    to: topics.1,
                    amount: data.0,
                    bridge: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.to.clone(), self.bridge.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.to,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridge,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for CrosschainMint {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&CrosschainMint> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &CrosschainMint) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `DelegateChanged(address,address,address)` and selector `0x3134e8a2e6d97e929a7e54011ea5485d7d196dd5f0ba4d4ef95803e8e3fc257f`.
```solidity
event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DelegateChanged {
        #[allow(missing_docs)]
        pub delegator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub fromDelegate: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub toDelegate: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DelegateChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "DelegateChanged(address,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                49u8,
                52u8,
                232u8,
                162u8,
                230u8,
                217u8,
                126u8,
                146u8,
                154u8,
                126u8,
                84u8,
                1u8,
                30u8,
                165u8,
                72u8,
                93u8,
                125u8,
                25u8,
                109u8,
                213u8,
                240u8,
                186u8,
                77u8,
                78u8,
                249u8,
                88u8,
                3u8,
                232u8,
                227u8,
                252u8,
                37u8,
                127u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    delegator: topics.1,
                    fromDelegate: topics.2,
                    toDelegate: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.delegator.clone(),
                    self.fromDelegate.clone(),
                    self.toDelegate.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.delegator,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.fromDelegate,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.toDelegate,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DelegateChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DelegateChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &DelegateChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `DelegateVotesChanged(address,uint256,uint256)` and selector `0xdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a724`.
```solidity
event DelegateVotesChanged(address indexed delegate, uint256 previousVotes, uint256 newVotes);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DelegateVotesChanged {
        #[allow(missing_docs)]
        pub delegate: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub previousVotes: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub newVotes: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DelegateVotesChanged {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "DelegateVotesChanged(address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                222u8,
                194u8,
                186u8,
                205u8,
                210u8,
                240u8,
                91u8,
                89u8,
                222u8,
                52u8,
                218u8,
                155u8,
                82u8,
                61u8,
                255u8,
                139u8,
                228u8,
                46u8,
                94u8,
                56u8,
                232u8,
                24u8,
                200u8,
                47u8,
                219u8,
                11u8,
                174u8,
                119u8,
                67u8,
                135u8,
                167u8,
                36u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    delegate: topics.1,
                    previousVotes: data.0,
                    newVotes: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.previousVotes),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newVotes),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.delegate.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.delegate,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DelegateVotesChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DelegateVotesChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &DelegateVotesChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EIP712DomainChanged()` and selector `0x0a6387c9ea3628b88a633bb4f3b151770f70085117a15f9bf3787cda53f13d31`.
```solidity
event EIP712DomainChanged();
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EIP712DomainChanged {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EIP712DomainChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "EIP712DomainChanged()";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                10u8,
                99u8,
                135u8,
                201u8,
                234u8,
                54u8,
                40u8,
                184u8,
                138u8,
                99u8,
                59u8,
                180u8,
                243u8,
                177u8,
                81u8,
                119u8,
                15u8,
                112u8,
                8u8,
                81u8,
                23u8,
                161u8,
                95u8,
                155u8,
                243u8,
                120u8,
                124u8,
                218u8,
                83u8,
                241u8,
                61u8,
                49u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {}
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EIP712DomainChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EIP712DomainChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EIP712DomainChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleAdminChanged(bytes32,bytes32,bytes32)` and selector `0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff`.
```solidity
event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleAdminChanged {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub previousAdminRole: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newAdminRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleAdminChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "RoleAdminChanged(bytes32,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    previousAdminRole: topics.2,
                    newAdminRole: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.previousAdminRole.clone(),
                    self.newAdminRole.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.previousAdminRole);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newAdminRole);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleAdminChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleAdminChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleAdminChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleGranted(bytes32,address,address)` and selector `0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d`.
```solidity
event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleGranted {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleGranted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleGranted(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleGranted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleGranted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleGranted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleRevoked(bytes32,address,address)` and selector `0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b`.
```solidity
event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleRevoked {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleRevoked(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TokensBurnedByManager(address,uint256,address)` and selector `0xbef4f81c1814c641ede85ebaacf19d048b2c5b55980adfa6ef0f956c651335a2`.
```solidity
event TokensBurnedByManager(address indexed from, uint256 amount, address indexed burner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TokensBurnedByManager {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub burner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TokensBurnedByManager {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "TokensBurnedByManager(address,uint256,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                190u8,
                244u8,
                248u8,
                28u8,
                24u8,
                20u8,
                198u8,
                65u8,
                237u8,
                232u8,
                94u8,
                186u8,
                172u8,
                241u8,
                157u8,
                4u8,
                139u8,
                44u8,
                91u8,
                85u8,
                152u8,
                10u8,
                223u8,
                166u8,
                239u8,
                15u8,
                149u8,
                108u8,
                101u8,
                19u8,
                53u8,
                162u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    from: topics.1,
                    amount: data.0,
                    burner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.from.clone(), self.burner.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.from,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.burner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TokensBurnedByManager {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TokensBurnedByManager> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TokensBurnedByManager) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Transfer(address,address,uint256)` and selector `0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef`.
```solidity
event Transfer(address indexed from, address indexed to, uint256 value);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Transfer {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Transfer {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Transfer(address,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                221u8,
                242u8,
                82u8,
                173u8,
                27u8,
                226u8,
                200u8,
                155u8,
                105u8,
                194u8,
                176u8,
                104u8,
                252u8,
                55u8,
                141u8,
                170u8,
                149u8,
                43u8,
                167u8,
                241u8,
                99u8,
                196u8,
                161u8,
                22u8,
                40u8,
                245u8,
                90u8,
                77u8,
                245u8,
                35u8,
                179u8,
                239u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    from: topics.1,
                    to: topics.2,
                    value: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.from.clone(), self.to.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.from,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.to,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Transfer {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Transfer> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Transfer) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `UnlockTimestampUpdated(uint256,uint256,address)` and selector `0xdd6896dcf1d4b311cca87dd19bbba2ea9ce2f867c1568878a0438a66a1afeeec`.
```solidity
event UnlockTimestampUpdated(uint256 oldTimestamp, uint256 newTimestamp, address indexed updatedBy);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct UnlockTimestampUpdated {
        #[allow(missing_docs)]
        pub oldTimestamp: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub newTimestamp: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub updatedBy: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for UnlockTimestampUpdated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "UnlockTimestampUpdated(uint256,uint256,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                221u8,
                104u8,
                150u8,
                220u8,
                241u8,
                212u8,
                179u8,
                17u8,
                204u8,
                168u8,
                125u8,
                209u8,
                155u8,
                187u8,
                162u8,
                234u8,
                156u8,
                226u8,
                248u8,
                103u8,
                193u8,
                86u8,
                136u8,
                120u8,
                160u8,
                67u8,
                138u8,
                102u8,
                161u8,
                175u8,
                238u8,
                236u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldTimestamp: data.0,
                    newTimestamp: data.1,
                    updatedBy: topics.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.oldTimestamp),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newTimestamp),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.updatedBy.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.updatedBy,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for UnlockTimestampUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&UnlockTimestampUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &UnlockTimestampUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address defaultAdmin, address syndTreasuryAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub defaultAdmin: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub syndTreasuryAddress: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value.defaultAdmin, value.syndTreasuryAddress)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        defaultAdmin: tuple.0,
                        syndTreasuryAddress: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.defaultAdmin,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.syndTreasuryAddress,
                    ),
                )
            }
        }
    };
    /**Function with signature `AIRDROP_MANAGER_ROLE()` and selector `0x8a542521`.
```solidity
function AIRDROP_MANAGER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AIRDROP_MANAGER_ROLECall {}
    ///Container type for the return parameters of the [`AIRDROP_MANAGER_ROLE()`](AIRDROP_MANAGER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AIRDROP_MANAGER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<AIRDROP_MANAGER_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: AIRDROP_MANAGER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for AIRDROP_MANAGER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<AIRDROP_MANAGER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: AIRDROP_MANAGER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for AIRDROP_MANAGER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for AIRDROP_MANAGER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = AIRDROP_MANAGER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AIRDROP_MANAGER_ROLE()";
            const SELECTOR: [u8; 4] = [138u8, 84u8, 37u8, 33u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `BRIDGE_MANAGER_ROLE()` and selector `0xf75e8512`.
```solidity
function BRIDGE_MANAGER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_MANAGER_ROLECall {}
    ///Container type for the return parameters of the [`BRIDGE_MANAGER_ROLE()`](BRIDGE_MANAGER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BRIDGE_MANAGER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_MANAGER_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_MANAGER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_MANAGER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BRIDGE_MANAGER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: BRIDGE_MANAGER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BRIDGE_MANAGER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for BRIDGE_MANAGER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = BRIDGE_MANAGER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BRIDGE_MANAGER_ROLE()";
            const SELECTOR: [u8; 4] = [247u8, 94u8, 133u8, 18u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `CLOCK_MODE()` and selector `0x4bf5d7e9`.
```solidity
function CLOCK_MODE() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CLOCK_MODECall {}
    ///Container type for the return parameters of the [`CLOCK_MODE()`](CLOCK_MODECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CLOCK_MODEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CLOCK_MODECall> for UnderlyingRustTuple<'_> {
                fn from(value: CLOCK_MODECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for CLOCK_MODECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CLOCK_MODEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: CLOCK_MODEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for CLOCK_MODEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for CLOCK_MODECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = CLOCK_MODEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CLOCK_MODE()";
            const SELECTOR: [u8; 4] = [75u8, 245u8, 215u8, 233u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `DEFAULT_ADMIN_ROLE()` and selector `0xa217fddf`.
```solidity
function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLECall {}
    ///Container type for the return parameters of the [`DEFAULT_ADMIN_ROLE()`](DEFAULT_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEFAULT_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DEFAULT_ADMIN_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEFAULT_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [162u8, 23u8, 253u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `DOMAIN_SEPARATOR()` and selector `0x3644e515`.
```solidity
function DOMAIN_SEPARATOR() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DOMAIN_SEPARATORCall {}
    ///Container type for the return parameters of the [`DOMAIN_SEPARATOR()`](DOMAIN_SEPARATORCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DOMAIN_SEPARATORReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DOMAIN_SEPARATORCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DOMAIN_SEPARATORCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DOMAIN_SEPARATORCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DOMAIN_SEPARATORReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DOMAIN_SEPARATORReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DOMAIN_SEPARATORReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DOMAIN_SEPARATORCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DOMAIN_SEPARATORReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DOMAIN_SEPARATOR()";
            const SELECTOR: [u8; 4] = [54u8, 68u8, 229u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `EMISSION_MINTER_ROLE()` and selector `0x8d3343d6`.
```solidity
function EMISSION_MINTER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_MINTER_ROLECall {}
    ///Container type for the return parameters of the [`EMISSION_MINTER_ROLE()`](EMISSION_MINTER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EMISSION_MINTER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_MINTER_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_MINTER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_MINTER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<EMISSION_MINTER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: EMISSION_MINTER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for EMISSION_MINTER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for EMISSION_MINTER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = EMISSION_MINTER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EMISSION_MINTER_ROLE()";
            const SELECTOR: [u8; 4] = [141u8, 51u8, 67u8, 214u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `INITIAL_MINT_SUPPLY()` and selector `0x9b7ef64b`.
```solidity
function INITIAL_MINT_SUPPLY() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct INITIAL_MINT_SUPPLYCall {}
    ///Container type for the return parameters of the [`INITIAL_MINT_SUPPLY()`](INITIAL_MINT_SUPPLYCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct INITIAL_MINT_SUPPLYReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<INITIAL_MINT_SUPPLYCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: INITIAL_MINT_SUPPLYCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for INITIAL_MINT_SUPPLYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<INITIAL_MINT_SUPPLYReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: INITIAL_MINT_SUPPLYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for INITIAL_MINT_SUPPLYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for INITIAL_MINT_SUPPLYCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = INITIAL_MINT_SUPPLYReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "INITIAL_MINT_SUPPLY()";
            const SELECTOR: [u8; 4] = [155u8, 126u8, 246u8, 75u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `MAX_LOCK_DURATION()` and selector `0x4f1bfc9e`.
```solidity
function MAX_LOCK_DURATION() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MAX_LOCK_DURATIONCall {}
    ///Container type for the return parameters of the [`MAX_LOCK_DURATION()`](MAX_LOCK_DURATIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MAX_LOCK_DURATIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MAX_LOCK_DURATIONCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: MAX_LOCK_DURATIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MAX_LOCK_DURATIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MAX_LOCK_DURATIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: MAX_LOCK_DURATIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MAX_LOCK_DURATIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for MAX_LOCK_DURATIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = MAX_LOCK_DURATIONReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MAX_LOCK_DURATION()";
            const SELECTOR: [u8; 4] = [79u8, 27u8, 252u8, 158u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `TOTAL_SUPPLY()` and selector `0x902d55a5`.
```solidity
function TOTAL_SUPPLY() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_SUPPLYCall {}
    ///Container type for the return parameters of the [`TOTAL_SUPPLY()`](TOTAL_SUPPLYCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TOTAL_SUPPLYReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_SUPPLYCall> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_SUPPLYCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_SUPPLYCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TOTAL_SUPPLYReturn> for UnderlyingRustTuple<'_> {
                fn from(value: TOTAL_SUPPLYReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TOTAL_SUPPLYReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for TOTAL_SUPPLYCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = TOTAL_SUPPLYReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TOTAL_SUPPLY()";
            const SELECTOR: [u8; 4] = [144u8, 45u8, 85u8, 165u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `allowance(address,address)` and selector `0xdd62ed3e`.
```solidity
function allowance(address owner, address spender) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allowanceCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`allowance(address,address)`](allowanceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allowanceReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowanceCall> for UnderlyingRustTuple<'_> {
                fn from(value: allowanceCall) -> Self {
                    (value.owner, value.spender)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for allowanceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        spender: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowanceReturn> for UnderlyingRustTuple<'_> {
                fn from(value: allowanceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for allowanceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for allowanceCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = allowanceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "allowance(address,address)";
            const SELECTOR: [u8; 4] = [221u8, 98u8, 237u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `approve(address,uint256)` and selector `0x095ea7b3`.
```solidity
function approve(address spender, uint256 value) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveCall {
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`approve(address,uint256)`](approveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveCall> for UnderlyingRustTuple<'_> {
                fn from(value: approveCall) -> Self {
                    (value.spender, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        spender: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveReturn> for UnderlyingRustTuple<'_> {
                fn from(value: approveReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for approveCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = approveReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "approve(address,uint256)";
            const SELECTOR: [u8; 4] = [9u8, 94u8, 167u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `balanceOf(address)` and selector `0x70a08231`.
```solidity
function balanceOf(address account) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`balanceOf(address)`](balanceOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfCall> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfReturn> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for balanceOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = balanceOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "balanceOf(address)";
            const SELECTOR: [u8; 4] = [112u8, 160u8, 130u8, 49u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeConfigs(address)` and selector `0x427ac0ca`.
```solidity
function bridgeConfigs(address) external view returns (uint256 dailyMintLimit, uint256 dailyBurnLimit, uint256 lastMintTimestamp, uint256 lastBurnTimestamp, uint256 currentMintUsed, uint256 currentBurnUsed, bool isActive);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeConfigsCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`bridgeConfigs(address)`](bridgeConfigsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeConfigsReturn {
        #[allow(missing_docs)]
        pub dailyMintLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub dailyBurnLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub lastMintTimestamp: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub lastBurnTimestamp: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub currentMintUsed: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub currentBurnUsed: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub isActive: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeConfigsCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeConfigsCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeConfigsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                bool,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeConfigsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeConfigsReturn) -> Self {
                    (
                        value.dailyMintLimit,
                        value.dailyBurnLimit,
                        value.lastMintTimestamp,
                        value.lastBurnTimestamp,
                        value.currentMintUsed,
                        value.currentBurnUsed,
                        value.isActive,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeConfigsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        dailyMintLimit: tuple.0,
                        dailyBurnLimit: tuple.1,
                        lastMintTimestamp: tuple.2,
                        lastBurnTimestamp: tuple.3,
                        currentMintUsed: tuple.4,
                        currentBurnUsed: tuple.5,
                        isActive: tuple.6,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeConfigsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeConfigsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bool,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeConfigs(address)";
            const SELECTOR: [u8; 4] = [66u8, 122u8, 192u8, 202u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridges(uint256)` and selector `0xa3c44705`.
```solidity
function bridges(uint256) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgesCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`bridges(uint256)`](bridgesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgesCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgesCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridges(uint256)";
            const SELECTOR: [u8; 4] = [163u8, 196u8, 71u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `burn(uint256)` and selector `0x42966c68`.
```solidity
function burn(uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burnCall {
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`burn(uint256)`](burnCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burnReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burnCall> for UnderlyingRustTuple<'_> {
                fn from(value: burnCall) -> Self {
                    (value.amount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for burnCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { amount: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burnReturn> for UnderlyingRustTuple<'_> {
                fn from(value: burnReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for burnReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for burnCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = burnReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "burn(uint256)";
            const SELECTOR: [u8; 4] = [66u8, 150u8, 108u8, 104u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `burnFrom(address,uint256)` and selector `0x79cc6790`.
```solidity
function burnFrom(address from, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burnFromCall {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`burnFrom(address,uint256)`](burnFromCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct burnFromReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burnFromCall> for UnderlyingRustTuple<'_> {
                fn from(value: burnFromCall) -> Self {
                    (value.from, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for burnFromCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        from: tuple.0,
                        amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<burnFromReturn> for UnderlyingRustTuple<'_> {
                fn from(value: burnFromReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for burnFromReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for burnFromCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = burnFromReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "burnFrom(address,uint256)";
            const SELECTOR: [u8; 4] = [121u8, 204u8, 103u8, 144u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `checkpoints(address,uint32)` and selector `0xf1127ed8`.
```solidity
function checkpoints(address account, uint32 pos) external view returns (Checkpoints.Checkpoint208 memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkpointsCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub pos: u32,
    }
    ///Container type for the return parameters of the [`checkpoints(address,uint32)`](checkpointsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct checkpointsReturn {
        #[allow(missing_docs)]
        pub _0: <Checkpoints::Checkpoint208 as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, u32);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkpointsCall> for UnderlyingRustTuple<'_> {
                fn from(value: checkpointsCall) -> Self {
                    (value.account, value.pos)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for checkpointsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        account: tuple.0,
                        pos: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Checkpoints::Checkpoint208,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Checkpoints::Checkpoint208 as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkpointsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: checkpointsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for checkpointsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkpointsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkpointsReturn;
            type ReturnTuple<'a> = (Checkpoints::Checkpoint208,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkpoints(address,uint32)";
            const SELECTOR: [u8; 4] = [241u8, 18u8, 126u8, 216u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.pos),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `clock()` and selector `0x91ddadf4`.
```solidity
function clock() external view returns (uint48);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct clockCall {}
    ///Container type for the return parameters of the [`clock()`](clockCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct clockReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U48,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<clockCall> for UnderlyingRustTuple<'_> {
                fn from(value: clockCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for clockCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U48,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<clockReturn> for UnderlyingRustTuple<'_> {
                fn from(value: clockReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for clockReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for clockCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = clockReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<48>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "clock()";
            const SELECTOR: [u8; 4] = [145u8, 221u8, 173u8, 244u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `crosschainBurn(address,uint256)` and selector `0x2b8c49e3`.
```solidity
function crosschainBurn(address from, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct crosschainBurnCall {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`crosschainBurn(address,uint256)`](crosschainBurnCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct crosschainBurnReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<crosschainBurnCall> for UnderlyingRustTuple<'_> {
                fn from(value: crosschainBurnCall) -> Self {
                    (value.from, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for crosschainBurnCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        from: tuple.0,
                        amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<crosschainBurnReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: crosschainBurnReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for crosschainBurnReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for crosschainBurnCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = crosschainBurnReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "crosschainBurn(address,uint256)";
            const SELECTOR: [u8; 4] = [43u8, 140u8, 73u8, 227u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `crosschainMint(address,uint256)` and selector `0x18bf5077`.
```solidity
function crosschainMint(address to, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct crosschainMintCall {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`crosschainMint(address,uint256)`](crosschainMintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct crosschainMintReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<crosschainMintCall> for UnderlyingRustTuple<'_> {
                fn from(value: crosschainMintCall) -> Self {
                    (value.to, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for crosschainMintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<crosschainMintReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: crosschainMintReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for crosschainMintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for crosschainMintCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = crosschainMintReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "crosschainMint(address,uint256)";
            const SELECTOR: [u8; 4] = [24u8, 191u8, 80u8, 119u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `decimals()` and selector `0x313ce567`.
```solidity
function decimals() external view returns (uint8);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decimalsCall {}
    ///Container type for the return parameters of the [`decimals()`](decimalsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decimalsReturn {
        #[allow(missing_docs)]
        pub _0: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decimalsCall> for UnderlyingRustTuple<'_> {
                fn from(value: decimalsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for decimalsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decimalsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: decimalsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for decimalsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for decimalsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = decimalsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "decimals()";
            const SELECTOR: [u8; 4] = [49u8, 60u8, 229u8, 103u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `delegate(address)` and selector `0x5c19a95c`.
```solidity
function delegate(address delegatee) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateCall {
        #[allow(missing_docs)]
        pub delegatee: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`delegate(address)`](delegateCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateCall> for UnderlyingRustTuple<'_> {
                fn from(value: delegateCall) -> Self {
                    (value.delegatee,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegateCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { delegatee: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateReturn> for UnderlyingRustTuple<'_> {
                fn from(value: delegateReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegateReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for delegateCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = delegateReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "delegate(address)";
            const SELECTOR: [u8; 4] = [92u8, 25u8, 169u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.delegatee,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)` and selector `0xc3cda520`.
```solidity
function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateBySigCall {
        #[allow(missing_docs)]
        pub delegatee: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub expiry: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub v: u8,
        #[allow(missing_docs)]
        pub r: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)`](delegateBySigCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateBySigReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                u8,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateBySigCall> for UnderlyingRustTuple<'_> {
                fn from(value: delegateBySigCall) -> Self {
                    (
                        value.delegatee,
                        value.nonce,
                        value.expiry,
                        value.v,
                        value.r,
                        value.s,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegateBySigCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        delegatee: tuple.0,
                        nonce: tuple.1,
                        expiry: tuple.2,
                        v: tuple.3,
                        r: tuple.4,
                        s: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateBySigReturn> for UnderlyingRustTuple<'_> {
                fn from(value: delegateBySigReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegateBySigReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for delegateBySigCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = delegateBySigReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [195u8, 205u8, 165u8, 32u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.delegatee,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expiry),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.v),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.r),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `delegates(address)` and selector `0x587cde1e`.
```solidity
function delegates(address account) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegatesCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`delegates(address)`](delegatesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegatesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegatesCall> for UnderlyingRustTuple<'_> {
                fn from(value: delegatesCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegatesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegatesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: delegatesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegatesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for delegatesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = delegatesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "delegates(address)";
            const SELECTOR: [u8; 4] = [88u8, 124u8, 222u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `eip712Domain()` and selector `0x84b0196e`.
```solidity
function eip712Domain() external view returns (bytes1 fields, string memory name, string memory version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] memory extensions);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eip712DomainCall {}
    ///Container type for the return parameters of the [`eip712Domain()`](eip712DomainCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eip712DomainReturn {
        #[allow(missing_docs)]
        pub fields: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub name: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub version: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub verifyingContract: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub salt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub extensions: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eip712DomainCall> for UnderlyingRustTuple<'_> {
                fn from(value: eip712DomainCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eip712DomainCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eip712DomainReturn> for UnderlyingRustTuple<'_> {
                fn from(value: eip712DomainReturn) -> Self {
                    (
                        value.fields,
                        value.name,
                        value.version,
                        value.chainId,
                        value.verifyingContract,
                        value.salt,
                        value.extensions,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eip712DomainReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        fields: tuple.0,
                        name: tuple.1,
                        version: tuple.2,
                        chainId: tuple.3,
                        verifyingContract: tuple.4,
                        salt: tuple.5,
                        extensions: tuple.6,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for eip712DomainCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = eip712DomainReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "eip712Domain()";
            const SELECTOR: [u8; 4] = [132u8, 176u8, 25u8, 110u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getAllBridges()` and selector `0x72cbdcc8`.
```solidity
function getAllBridges() external view returns (address[] memory allBridges);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAllBridgesCall {}
    ///Container type for the return parameters of the [`getAllBridges()`](getAllBridgesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAllBridgesReturn {
        #[allow(missing_docs)]
        pub allBridges: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAllBridgesCall> for UnderlyingRustTuple<'_> {
                fn from(value: getAllBridgesCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getAllBridgesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAllBridgesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getAllBridgesReturn) -> Self {
                    (value.allBridges,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getAllBridgesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { allBridges: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAllBridgesCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getAllBridgesReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAllBridges()";
            const SELECTOR: [u8; 4] = [114u8, 203u8, 220u8, 200u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getAvailableBurnLimit(address)` and selector `0x30d3e8eb`.
```solidity
function getAvailableBurnLimit(address bridge) external view returns (uint256 available);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAvailableBurnLimitCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getAvailableBurnLimit(address)`](getAvailableBurnLimitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAvailableBurnLimitReturn {
        #[allow(missing_docs)]
        pub available: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAvailableBurnLimitCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAvailableBurnLimitCall) -> Self {
                    (value.bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAvailableBurnLimitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAvailableBurnLimitReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAvailableBurnLimitReturn) -> Self {
                    (value.available,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAvailableBurnLimitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { available: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAvailableBurnLimitCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getAvailableBurnLimitReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAvailableBurnLimit(address)";
            const SELECTOR: [u8; 4] = [48u8, 211u8, 232u8, 235u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getAvailableMintLimit(address)` and selector `0x94aa22f2`.
```solidity
function getAvailableMintLimit(address bridge) external view returns (uint256 available);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAvailableMintLimitCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getAvailableMintLimit(address)`](getAvailableMintLimitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAvailableMintLimitReturn {
        #[allow(missing_docs)]
        pub available: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAvailableMintLimitCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAvailableMintLimitCall) -> Self {
                    (value.bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAvailableMintLimitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAvailableMintLimitReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAvailableMintLimitReturn) -> Self {
                    (value.available,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAvailableMintLimitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { available: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAvailableMintLimitCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getAvailableMintLimitReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAvailableMintLimit(address)";
            const SELECTOR: [u8; 4] = [148u8, 170u8, 34u8, 242u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBridgeAtIndex(uint256)` and selector `0x5a5db1bb`.
```solidity
function getBridgeAtIndex(uint256 index) external view returns (address bridge);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeAtIndexCall {
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getBridgeAtIndex(uint256)`](getBridgeAtIndexCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeAtIndexReturn {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeAtIndexCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeAtIndexCall) -> Self {
                    (value.index,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeAtIndexCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { index: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeAtIndexReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeAtIndexReturn) -> Self {
                    (value.bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeAtIndexReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bridge: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBridgeAtIndexCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBridgeAtIndexReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBridgeAtIndex(uint256)";
            const SELECTOR: [u8; 4] = [90u8, 93u8, 177u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBridgeConfig(address)` and selector `0xc4fc45a8`.
```solidity
function getBridgeConfig(address bridge) external view returns (IBridgeRateLimiter.BridgeConfig memory config);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeConfigCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getBridgeConfig(address)`](getBridgeConfigCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeConfigReturn {
        #[allow(missing_docs)]
        pub config: <IBridgeRateLimiter::BridgeConfig as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeConfigCall> for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeConfigCall) -> Self {
                    (value.bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBridgeConfigCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (IBridgeRateLimiter::BridgeConfig,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <IBridgeRateLimiter::BridgeConfig as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeConfigReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeConfigReturn) -> Self {
                    (value.config,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeConfigReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { config: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBridgeConfigCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBridgeConfigReturn;
            type ReturnTuple<'a> = (IBridgeRateLimiter::BridgeConfig,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBridgeConfig(address)";
            const SELECTOR: [u8; 4] = [196u8, 252u8, 69u8, 168u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBridgeCount()` and selector `0x65145534`.
```solidity
function getBridgeCount() external view returns (uint256 count);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeCountCall {}
    ///Container type for the return parameters of the [`getBridgeCount()`](getBridgeCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeCountReturn {
        #[allow(missing_docs)]
        pub count: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeCountCall> for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeCountCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBridgeCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeCountReturn) -> Self {
                    (value.count,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { count: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBridgeCountCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBridgeCountReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBridgeCount()";
            const SELECTOR: [u8; 4] = [101u8, 20u8, 85u8, 52u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getCurrentTotalSupply()` and selector `0xc02ae754`.
```solidity
function getCurrentTotalSupply() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentTotalSupplyCall {}
    ///Container type for the return parameters of the [`getCurrentTotalSupply()`](getCurrentTotalSupplyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentTotalSupplyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentTotalSupplyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentTotalSupplyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentTotalSupplyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentTotalSupplyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentTotalSupplyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentTotalSupplyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCurrentTotalSupplyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getCurrentTotalSupplyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCurrentTotalSupply()";
            const SELECTOR: [u8; 4] = [192u8, 42u8, 231u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getPastTotalSupply(uint256)` and selector `0x8e539e8c`.
```solidity
function getPastTotalSupply(uint256 timepoint) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastTotalSupplyCall {
        #[allow(missing_docs)]
        pub timepoint: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getPastTotalSupply(uint256)`](getPastTotalSupplyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastTotalSupplyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastTotalSupplyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPastTotalSupplyCall) -> Self {
                    (value.timepoint,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPastTotalSupplyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { timepoint: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastTotalSupplyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPastTotalSupplyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPastTotalSupplyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPastTotalSupplyCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPastTotalSupplyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPastTotalSupply(uint256)";
            const SELECTOR: [u8; 4] = [142u8, 83u8, 158u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.timepoint),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getPastVotes(address,uint256)` and selector `0x3a46b1a8`.
```solidity
function getPastVotes(address account, uint256 timepoint) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastVotesCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub timepoint: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getPastVotes(address,uint256)`](getPastVotesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastVotesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastVotesCall> for UnderlyingRustTuple<'_> {
                fn from(value: getPastVotesCall) -> Self {
                    (value.account, value.timepoint)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getPastVotesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        account: tuple.0,
                        timepoint: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastVotesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getPastVotesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getPastVotesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPastVotesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPastVotesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPastVotes(address,uint256)";
            const SELECTOR: [u8; 4] = [58u8, 70u8, 177u8, 168u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.timepoint),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getPastVotingPower(address,uint256)` and selector `0xb0ca253e`.
```solidity
function getPastVotingPower(address account, uint256 blockNumber) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastVotingPowerCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub blockNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getPastVotingPower(address,uint256)`](getPastVotingPowerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPastVotingPowerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastVotingPowerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPastVotingPowerCall) -> Self {
                    (value.account, value.blockNumber)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPastVotingPowerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        account: tuple.0,
                        blockNumber: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPastVotingPowerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPastVotingPowerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPastVotingPowerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPastVotingPowerCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPastVotingPowerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPastVotingPower(address,uint256)";
            const SELECTOR: [u8; 4] = [176u8, 202u8, 37u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNumber),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRemainingEmissions()` and selector `0x4bdd36ce`.
```solidity
function getRemainingEmissions() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRemainingEmissionsCall {}
    ///Container type for the return parameters of the [`getRemainingEmissions()`](getRemainingEmissionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRemainingEmissionsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRemainingEmissionsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRemainingEmissionsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRemainingEmissionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRemainingEmissionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRemainingEmissionsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRemainingEmissionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRemainingEmissionsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRemainingEmissionsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRemainingEmissions()";
            const SELECTOR: [u8; 4] = [75u8, 221u8, 54u8, 206u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRemainingLockTime()` and selector `0x7a8cd156`.
```solidity
function getRemainingLockTime() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRemainingLockTimeCall {}
    ///Container type for the return parameters of the [`getRemainingLockTime()`](getRemainingLockTimeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRemainingLockTimeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRemainingLockTimeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRemainingLockTimeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRemainingLockTimeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRemainingLockTimeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRemainingLockTimeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRemainingLockTimeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRemainingLockTimeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRemainingLockTimeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRemainingLockTime()";
            const SELECTOR: [u8; 4] = [122u8, 140u8, 209u8, 86u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRoleAdmin(bytes32)` and selector `0x248a9ca3`.
```solidity
function getRoleAdmin(bytes32 role) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getRoleAdmin(bytes32)`](getRoleAdminCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleAdminCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRoleAdminReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleAdmin(bytes32)";
            const SELECTOR: [u8; 4] = [36u8, 138u8, 156u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getVotes(address)` and selector `0x9ab24eb0`.
```solidity
function getVotes(address account) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVotesCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getVotes(address)`](getVotesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVotesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVotesCall> for UnderlyingRustTuple<'_> {
                fn from(value: getVotesCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVotesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVotesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getVotesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVotesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getVotesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getVotesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getVotes(address)";
            const SELECTOR: [u8; 4] = [154u8, 178u8, 78u8, 176u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getVotingPower(address)` and selector `0xbb4d4436`.
```solidity
function getVotingPower(address account) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVotingPowerCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getVotingPower(address)`](getVotingPowerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getVotingPowerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVotingPowerCall> for UnderlyingRustTuple<'_> {
                fn from(value: getVotingPowerCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getVotingPowerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getVotingPowerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getVotingPowerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getVotingPowerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getVotingPowerCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getVotingPowerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getVotingPower(address)";
            const SELECTOR: [u8; 4] = [187u8, 77u8, 68u8, 54u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `grantRole(bytes32,address)` and selector `0x2f2ff15d`.
```solidity
function grantRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`grantRole(bytes32,address)`](grantRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for grantRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = grantRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "grantRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [47u8, 47u8, 241u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `hasRole(bytes32,address)` and selector `0x91d14854`.
```solidity
function hasRole(bytes32 role, address account) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`hasRole(bytes32,address)`](hasRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = hasRoleReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [145u8, 209u8, 72u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isBridgeAdded(address)` and selector `0x6a96e3ed`.
```solidity
function isBridgeAdded(address) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isBridgeAddedCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`isBridgeAdded(address)`](isBridgeAddedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isBridgeAddedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isBridgeAddedCall> for UnderlyingRustTuple<'_> {
                fn from(value: isBridgeAddedCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isBridgeAddedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isBridgeAddedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isBridgeAddedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isBridgeAddedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isBridgeAddedCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isBridgeAddedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isBridgeAdded(address)";
            const SELECTOR: [u8; 4] = [106u8, 150u8, 227u8, 237u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isBridgeAuthorized(address)` and selector `0x78fb7fd2`.
```solidity
function isBridgeAuthorized(address bridge) external view returns (bool authorized);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isBridgeAuthorizedCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`isBridgeAuthorized(address)`](isBridgeAuthorizedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isBridgeAuthorizedReturn {
        #[allow(missing_docs)]
        pub authorized: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isBridgeAuthorizedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isBridgeAuthorizedCall) -> Self {
                    (value.bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isBridgeAuthorizedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isBridgeAuthorizedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isBridgeAuthorizedReturn) -> Self {
                    (value.authorized,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isBridgeAuthorizedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { authorized: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isBridgeAuthorizedCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isBridgeAuthorizedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isBridgeAuthorized(address)";
            const SELECTOR: [u8; 4] = [120u8, 251u8, 127u8, 210u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `maxLockTimestamp()` and selector `0x8426adf2`.
```solidity
function maxLockTimestamp() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct maxLockTimestampCall {}
    ///Container type for the return parameters of the [`maxLockTimestamp()`](maxLockTimestampCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct maxLockTimestampReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<maxLockTimestampCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: maxLockTimestampCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for maxLockTimestampCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<maxLockTimestampReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: maxLockTimestampReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for maxLockTimestampReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for maxLockTimestampCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = maxLockTimestampReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "maxLockTimestamp()";
            const SELECTOR: [u8; 4] = [132u8, 38u8, 173u8, 242u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `mint(address,uint256)` and selector `0x40c10f19`.
```solidity
function mint(address to, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintCall {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`mint(address,uint256)`](mintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mintReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintCall> for UnderlyingRustTuple<'_> {
                fn from(value: mintCall) -> Self {
                    (value.to, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mintReturn> for UnderlyingRustTuple<'_> {
                fn from(value: mintReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mintCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mintReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mint(address,uint256)";
            const SELECTOR: [u8; 4] = [64u8, 193u8, 15u8, 25u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `name()` and selector `0x06fdde03`.
```solidity
function name() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nameCall {}
    ///Container type for the return parameters of the [`name()`](nameCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nameReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nameCall> for UnderlyingRustTuple<'_> {
                fn from(value: nameCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nameCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nameReturn> for UnderlyingRustTuple<'_> {
                fn from(value: nameReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nameReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for nameCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = nameReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "name()";
            const SELECTOR: [u8; 4] = [6u8, 253u8, 222u8, 3u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `nonces(address)` and selector `0x7ecebe00`.
```solidity
function nonces(address owner) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct noncesCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`nonces(address)`](noncesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct noncesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<noncesCall> for UnderlyingRustTuple<'_> {
                fn from(value: noncesCall) -> Self {
                    (value.owner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for noncesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { owner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<noncesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: noncesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for noncesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for noncesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = noncesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "nonces(address)";
            const SELECTOR: [u8; 4] = [126u8, 206u8, 190u8, 0u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `numCheckpoints(address)` and selector `0x6fcfff45`.
```solidity
function numCheckpoints(address account) external view returns (uint32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct numCheckpointsCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`numCheckpoints(address)`](numCheckpointsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct numCheckpointsReturn {
        #[allow(missing_docs)]
        pub _0: u32,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<numCheckpointsCall> for UnderlyingRustTuple<'_> {
                fn from(value: numCheckpointsCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for numCheckpointsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<numCheckpointsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: numCheckpointsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for numCheckpointsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for numCheckpointsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = numCheckpointsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "numCheckpoints(address)";
            const SELECTOR: [u8; 4] = [111u8, 207u8, 255u8, 69u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `permit(address,address,uint256,uint256,uint8,bytes32,bytes32)` and selector `0xd505accf`.
```solidity
function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct permitCall {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub spender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub deadline: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub v: u8,
        #[allow(missing_docs)]
        pub r: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`permit(address,address,uint256,uint256,uint8,bytes32,bytes32)`](permitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct permitReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                u8,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<permitCall> for UnderlyingRustTuple<'_> {
                fn from(value: permitCall) -> Self {
                    (
                        value.owner,
                        value.spender,
                        value.value,
                        value.deadline,
                        value.v,
                        value.r,
                        value.s,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for permitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        owner: tuple.0,
                        spender: tuple.1,
                        value: tuple.2,
                        deadline: tuple.3,
                        v: tuple.4,
                        r: tuple.5,
                        s: tuple.6,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<permitReturn> for UnderlyingRustTuple<'_> {
                fn from(value: permitReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for permitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for permitCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = permitReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [213u8, 5u8, 172u8, 207u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.spender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.deadline),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.v),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.r),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `removeBridge(address)` and selector `0x04df017d`.
```solidity
function removeBridge(address bridge) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeBridgeCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`removeBridge(address)`](removeBridgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeBridgeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeBridgeCall> for UnderlyingRustTuple<'_> {
                fn from(value: removeBridgeCall) -> Self {
                    (value.bridge,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeBridgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bridge: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeBridgeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: removeBridgeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeBridgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeBridgeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeBridgeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeBridge(address)";
            const SELECTOR: [u8; 4] = [4u8, 223u8, 1u8, 125u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `renounceRole(bytes32,address)` and selector `0x36568abe`.
```solidity
function renounceRole(bytes32 role, address callerConfirmation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub callerConfirmation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`renounceRole(bytes32,address)`](renounceRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleCall) -> Self {
                    (value.role, value.callerConfirmation)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        callerConfirmation: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [54u8, 86u8, 138u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callerConfirmation,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `revokeRole(bytes32,address)` and selector `0xd547741f`.
```solidity
function revokeRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeRole(bytes32,address)`](revokeRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [213u8, 71u8, 116u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBridgeActive(address,bool)` and selector `0xc9ab0006`.
```solidity
function setBridgeActive(address bridge, bool isActive) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeActiveCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub isActive: bool,
    }
    ///Container type for the return parameters of the [`setBridgeActive(address,bool)`](setBridgeActiveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeActiveReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, bool);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeActiveCall> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeActiveCall) -> Self {
                    (value.bridge, value.isActive)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgeActiveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        bridge: tuple.0,
                        isActive: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeActiveReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeActiveReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setBridgeActiveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBridgeActiveCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBridgeActiveReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBridgeActive(address,bool)";
            const SELECTOR: [u8; 4] = [201u8, 171u8, 0u8, 6u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.isActive,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBridgeLimits(address,uint256,uint256)` and selector `0x63a0daac`.
```solidity
function setBridgeLimits(address bridge, uint256 dailyMintLimit, uint256 dailyBurnLimit) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeLimitsCall {
        #[allow(missing_docs)]
        pub bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub dailyMintLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub dailyBurnLimit: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setBridgeLimits(address,uint256,uint256)`](setBridgeLimitsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgeLimitsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeLimitsCall> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeLimitsCall) -> Self {
                    (value.bridge, value.dailyMintLimit, value.dailyBurnLimit)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgeLimitsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        bridge: tuple.0,
                        dailyMintLimit: tuple.1,
                        dailyBurnLimit: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgeLimitsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setBridgeLimitsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setBridgeLimitsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBridgeLimitsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBridgeLimitsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBridgeLimits(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [99u8, 160u8, 218u8, 172u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridge,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.dailyMintLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.dailyBurnLimit),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setUnlockTimestamp(uint256)` and selector `0x844c9026`.
```solidity
function setUnlockTimestamp(uint256 newUnlockTimestamp) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setUnlockTimestampCall {
        #[allow(missing_docs)]
        pub newUnlockTimestamp: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setUnlockTimestamp(uint256)`](setUnlockTimestampCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setUnlockTimestampReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setUnlockTimestampCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setUnlockTimestampCall) -> Self {
                    (value.newUnlockTimestamp,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setUnlockTimestampCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newUnlockTimestamp: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setUnlockTimestampReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setUnlockTimestampReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setUnlockTimestampReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setUnlockTimestampCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setUnlockTimestampReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setUnlockTimestamp(uint256)";
            const SELECTOR: [u8; 4] = [132u8, 76u8, 144u8, 38u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newUnlockTimestamp),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
```solidity
function supportsInterface(bytes4 interfaceId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceCall {
        #[allow(missing_docs)]
        pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
    }
    ///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceCall) -> Self {
                    (value.interfaceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { interfaceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportsInterfaceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = supportsInterfaceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportsInterface(bytes4)";
            const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.interfaceId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `symbol()` and selector `0x95d89b41`.
```solidity
function symbol() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct symbolCall {}
    ///Container type for the return parameters of the [`symbol()`](symbolCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct symbolReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<symbolCall> for UnderlyingRustTuple<'_> {
                fn from(value: symbolCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for symbolCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<symbolReturn> for UnderlyingRustTuple<'_> {
                fn from(value: symbolReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for symbolReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for symbolCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = symbolReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "symbol()";
            const SELECTOR: [u8; 4] = [149u8, 216u8, 155u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `totalSupply()` and selector `0x18160ddd`.
```solidity
function totalSupply() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalSupplyCall {}
    ///Container type for the return parameters of the [`totalSupply()`](totalSupplyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct totalSupplyReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalSupplyCall> for UnderlyingRustTuple<'_> {
                fn from(value: totalSupplyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalSupplyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<totalSupplyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: totalSupplyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for totalSupplyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for totalSupplyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = totalSupplyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "totalSupply()";
            const SELECTOR: [u8; 4] = [24u8, 22u8, 13u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transfer(address,uint256)` and selector `0xa9059cbb`.
```solidity
function transfer(address to, uint256 value) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferCall {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`transfer(address,uint256)`](transferCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferCall> for UnderlyingRustTuple<'_> {
                fn from(value: transferCall) -> Self {
                    (value.to, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        value: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferReturn> for UnderlyingRustTuple<'_> {
                fn from(value: transferReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transfer(address,uint256)";
            const SELECTOR: [u8; 4] = [169u8, 5u8, 156u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transferFrom(address,address,uint256)` and selector `0x23b872dd`.
```solidity
function transferFrom(address from, address to, uint256 value) external returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferFromCall {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`transferFrom(address,address,uint256)`](transferFromCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferFromReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferFromCall> for UnderlyingRustTuple<'_> {
                fn from(value: transferFromCall) -> Self {
                    (value.from, value.to, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        from: tuple.0,
                        to: tuple.1,
                        value: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferFromReturn> for UnderlyingRustTuple<'_> {
                fn from(value: transferFromReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferFromReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferFromCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferFromReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferFrom(address,address,uint256)";
            const SELECTOR: [u8; 4] = [35u8, 184u8, 114u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transfersLocked()` and selector `0x83f1211b`.
```solidity
function transfersLocked() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transfersLockedCall {}
    ///Container type for the return parameters of the [`transfersLocked()`](transfersLockedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transfersLockedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transfersLockedCall> for UnderlyingRustTuple<'_> {
                fn from(value: transfersLockedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transfersLockedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transfersLockedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transfersLockedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transfersLockedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transfersLockedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transfersLockedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transfersLocked()";
            const SELECTOR: [u8; 4] = [131u8, 241u8, 33u8, 27u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `unlockTimestamp()` and selector `0xaa082a9d`.
```solidity
function unlockTimestamp() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unlockTimestampCall {}
    ///Container type for the return parameters of the [`unlockTimestamp()`](unlockTimestampCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unlockTimestampReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unlockTimestampCall> for UnderlyingRustTuple<'_> {
                fn from(value: unlockTimestampCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unlockTimestampCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unlockTimestampReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: unlockTimestampReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for unlockTimestampReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unlockTimestampCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = unlockTimestampReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unlockTimestamp()";
            const SELECTOR: [u8; 4] = [170u8, 8u8, 42u8, 157u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`SyndicateTokenCrosschain`](self) function calls.
    pub enum SyndicateTokenCrosschainCalls {
        #[allow(missing_docs)]
        AIRDROP_MANAGER_ROLE(AIRDROP_MANAGER_ROLECall),
        #[allow(missing_docs)]
        BRIDGE_MANAGER_ROLE(BRIDGE_MANAGER_ROLECall),
        #[allow(missing_docs)]
        CLOCK_MODE(CLOCK_MODECall),
        #[allow(missing_docs)]
        DEFAULT_ADMIN_ROLE(DEFAULT_ADMIN_ROLECall),
        #[allow(missing_docs)]
        DOMAIN_SEPARATOR(DOMAIN_SEPARATORCall),
        #[allow(missing_docs)]
        EMISSION_MINTER_ROLE(EMISSION_MINTER_ROLECall),
        #[allow(missing_docs)]
        INITIAL_MINT_SUPPLY(INITIAL_MINT_SUPPLYCall),
        #[allow(missing_docs)]
        MAX_LOCK_DURATION(MAX_LOCK_DURATIONCall),
        #[allow(missing_docs)]
        TOTAL_SUPPLY(TOTAL_SUPPLYCall),
        #[allow(missing_docs)]
        allowance(allowanceCall),
        #[allow(missing_docs)]
        approve(approveCall),
        #[allow(missing_docs)]
        balanceOf(balanceOfCall),
        #[allow(missing_docs)]
        bridgeConfigs(bridgeConfigsCall),
        #[allow(missing_docs)]
        bridges(bridgesCall),
        #[allow(missing_docs)]
        burn(burnCall),
        #[allow(missing_docs)]
        burnFrom(burnFromCall),
        #[allow(missing_docs)]
        checkpoints(checkpointsCall),
        #[allow(missing_docs)]
        clock(clockCall),
        #[allow(missing_docs)]
        crosschainBurn(crosschainBurnCall),
        #[allow(missing_docs)]
        crosschainMint(crosschainMintCall),
        #[allow(missing_docs)]
        decimals(decimalsCall),
        #[allow(missing_docs)]
        delegate(delegateCall),
        #[allow(missing_docs)]
        delegateBySig(delegateBySigCall),
        #[allow(missing_docs)]
        delegates(delegatesCall),
        #[allow(missing_docs)]
        eip712Domain(eip712DomainCall),
        #[allow(missing_docs)]
        getAllBridges(getAllBridgesCall),
        #[allow(missing_docs)]
        getAvailableBurnLimit(getAvailableBurnLimitCall),
        #[allow(missing_docs)]
        getAvailableMintLimit(getAvailableMintLimitCall),
        #[allow(missing_docs)]
        getBridgeAtIndex(getBridgeAtIndexCall),
        #[allow(missing_docs)]
        getBridgeConfig(getBridgeConfigCall),
        #[allow(missing_docs)]
        getBridgeCount(getBridgeCountCall),
        #[allow(missing_docs)]
        getCurrentTotalSupply(getCurrentTotalSupplyCall),
        #[allow(missing_docs)]
        getPastTotalSupply(getPastTotalSupplyCall),
        #[allow(missing_docs)]
        getPastVotes(getPastVotesCall),
        #[allow(missing_docs)]
        getPastVotingPower(getPastVotingPowerCall),
        #[allow(missing_docs)]
        getRemainingEmissions(getRemainingEmissionsCall),
        #[allow(missing_docs)]
        getRemainingLockTime(getRemainingLockTimeCall),
        #[allow(missing_docs)]
        getRoleAdmin(getRoleAdminCall),
        #[allow(missing_docs)]
        getVotes(getVotesCall),
        #[allow(missing_docs)]
        getVotingPower(getVotingPowerCall),
        #[allow(missing_docs)]
        grantRole(grantRoleCall),
        #[allow(missing_docs)]
        hasRole(hasRoleCall),
        #[allow(missing_docs)]
        isBridgeAdded(isBridgeAddedCall),
        #[allow(missing_docs)]
        isBridgeAuthorized(isBridgeAuthorizedCall),
        #[allow(missing_docs)]
        maxLockTimestamp(maxLockTimestampCall),
        #[allow(missing_docs)]
        mint(mintCall),
        #[allow(missing_docs)]
        name(nameCall),
        #[allow(missing_docs)]
        nonces(noncesCall),
        #[allow(missing_docs)]
        numCheckpoints(numCheckpointsCall),
        #[allow(missing_docs)]
        permit(permitCall),
        #[allow(missing_docs)]
        removeBridge(removeBridgeCall),
        #[allow(missing_docs)]
        renounceRole(renounceRoleCall),
        #[allow(missing_docs)]
        revokeRole(revokeRoleCall),
        #[allow(missing_docs)]
        setBridgeActive(setBridgeActiveCall),
        #[allow(missing_docs)]
        setBridgeLimits(setBridgeLimitsCall),
        #[allow(missing_docs)]
        setUnlockTimestamp(setUnlockTimestampCall),
        #[allow(missing_docs)]
        supportsInterface(supportsInterfaceCall),
        #[allow(missing_docs)]
        symbol(symbolCall),
        #[allow(missing_docs)]
        totalSupply(totalSupplyCall),
        #[allow(missing_docs)]
        transfer(transferCall),
        #[allow(missing_docs)]
        transferFrom(transferFromCall),
        #[allow(missing_docs)]
        transfersLocked(transfersLockedCall),
        #[allow(missing_docs)]
        unlockTimestamp(unlockTimestampCall),
    }
    #[automatically_derived]
    impl SyndicateTokenCrosschainCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 255u8, 201u8, 167u8],
            [4u8, 223u8, 1u8, 125u8],
            [6u8, 253u8, 222u8, 3u8],
            [9u8, 94u8, 167u8, 179u8],
            [24u8, 22u8, 13u8, 221u8],
            [24u8, 191u8, 80u8, 119u8],
            [35u8, 184u8, 114u8, 221u8],
            [36u8, 138u8, 156u8, 163u8],
            [43u8, 140u8, 73u8, 227u8],
            [47u8, 47u8, 241u8, 93u8],
            [48u8, 211u8, 232u8, 235u8],
            [49u8, 60u8, 229u8, 103u8],
            [54u8, 68u8, 229u8, 21u8],
            [54u8, 86u8, 138u8, 190u8],
            [58u8, 70u8, 177u8, 168u8],
            [64u8, 193u8, 15u8, 25u8],
            [66u8, 122u8, 192u8, 202u8],
            [66u8, 150u8, 108u8, 104u8],
            [75u8, 221u8, 54u8, 206u8],
            [75u8, 245u8, 215u8, 233u8],
            [79u8, 27u8, 252u8, 158u8],
            [88u8, 124u8, 222u8, 30u8],
            [90u8, 93u8, 177u8, 187u8],
            [92u8, 25u8, 169u8, 92u8],
            [99u8, 160u8, 218u8, 172u8],
            [101u8, 20u8, 85u8, 52u8],
            [106u8, 150u8, 227u8, 237u8],
            [111u8, 207u8, 255u8, 69u8],
            [112u8, 160u8, 130u8, 49u8],
            [114u8, 203u8, 220u8, 200u8],
            [120u8, 251u8, 127u8, 210u8],
            [121u8, 204u8, 103u8, 144u8],
            [122u8, 140u8, 209u8, 86u8],
            [126u8, 206u8, 190u8, 0u8],
            [131u8, 241u8, 33u8, 27u8],
            [132u8, 38u8, 173u8, 242u8],
            [132u8, 76u8, 144u8, 38u8],
            [132u8, 176u8, 25u8, 110u8],
            [138u8, 84u8, 37u8, 33u8],
            [141u8, 51u8, 67u8, 214u8],
            [142u8, 83u8, 158u8, 140u8],
            [144u8, 45u8, 85u8, 165u8],
            [145u8, 209u8, 72u8, 84u8],
            [145u8, 221u8, 173u8, 244u8],
            [148u8, 170u8, 34u8, 242u8],
            [149u8, 216u8, 155u8, 65u8],
            [154u8, 178u8, 78u8, 176u8],
            [155u8, 126u8, 246u8, 75u8],
            [162u8, 23u8, 253u8, 223u8],
            [163u8, 196u8, 71u8, 5u8],
            [169u8, 5u8, 156u8, 187u8],
            [170u8, 8u8, 42u8, 157u8],
            [176u8, 202u8, 37u8, 62u8],
            [187u8, 77u8, 68u8, 54u8],
            [192u8, 42u8, 231u8, 84u8],
            [195u8, 205u8, 165u8, 32u8],
            [196u8, 252u8, 69u8, 168u8],
            [201u8, 171u8, 0u8, 6u8],
            [213u8, 5u8, 172u8, 207u8],
            [213u8, 71u8, 116u8, 31u8],
            [221u8, 98u8, 237u8, 62u8],
            [241u8, 18u8, 126u8, 216u8],
            [247u8, 94u8, 133u8, 18u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndicateTokenCrosschainCalls {
        const NAME: &'static str = "SyndicateTokenCrosschainCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 63usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AIRDROP_MANAGER_ROLE(_) => {
                    <AIRDROP_MANAGER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::BRIDGE_MANAGER_ROLE(_) => {
                    <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::CLOCK_MODE(_) => {
                    <CLOCK_MODECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DEFAULT_ADMIN_ROLE(_) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DOMAIN_SEPARATOR(_) => {
                    <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::EMISSION_MINTER_ROLE(_) => {
                    <EMISSION_MINTER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::INITIAL_MINT_SUPPLY(_) => {
                    <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::MAX_LOCK_DURATION(_) => {
                    <MAX_LOCK_DURATIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::TOTAL_SUPPLY(_) => {
                    <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::allowance(_) => {
                    <allowanceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::approve(_) => <approveCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::balanceOf(_) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeConfigs(_) => {
                    <bridgeConfigsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridges(_) => <bridgesCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::burn(_) => <burnCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::burnFrom(_) => <burnFromCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::checkpoints(_) => {
                    <checkpointsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::clock(_) => <clockCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::crosschainBurn(_) => {
                    <crosschainBurnCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::crosschainMint(_) => {
                    <crosschainMintCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::decimals(_) => <decimalsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::delegate(_) => <delegateCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::delegateBySig(_) => {
                    <delegateBySigCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::delegates(_) => {
                    <delegatesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::eip712Domain(_) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAllBridges(_) => {
                    <getAllBridgesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAvailableBurnLimit(_) => {
                    <getAvailableBurnLimitCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAvailableMintLimit(_) => {
                    <getAvailableMintLimitCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBridgeAtIndex(_) => {
                    <getBridgeAtIndexCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBridgeConfig(_) => {
                    <getBridgeConfigCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBridgeCount(_) => {
                    <getBridgeCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCurrentTotalSupply(_) => {
                    <getCurrentTotalSupplyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPastTotalSupply(_) => {
                    <getPastTotalSupplyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPastVotes(_) => {
                    <getPastVotesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPastVotingPower(_) => {
                    <getPastVotingPowerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRemainingEmissions(_) => {
                    <getRemainingEmissionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRemainingLockTime(_) => {
                    <getRemainingLockTimeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleAdmin(_) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getVotes(_) => <getVotesCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getVotingPower(_) => {
                    <getVotingPowerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::grantRole(_) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasRole(_) => <hasRoleCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::isBridgeAdded(_) => {
                    <isBridgeAddedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isBridgeAuthorized(_) => {
                    <isBridgeAuthorizedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::maxLockTimestamp(_) => {
                    <maxLockTimestampCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::mint(_) => <mintCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::name(_) => <nameCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::nonces(_) => <noncesCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::numCheckpoints(_) => {
                    <numCheckpointsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::permit(_) => <permitCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::removeBridge(_) => {
                    <removeBridgeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceRole(_) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeRole(_) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBridgeActive(_) => {
                    <setBridgeActiveCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBridgeLimits(_) => {
                    <setBridgeLimitsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setUnlockTimestamp(_) => {
                    <setUnlockTimestampCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::supportsInterface(_) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::symbol(_) => <symbolCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::totalSupply(_) => {
                    <totalSupplyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transfer(_) => <transferCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::transferFrom(_) => {
                    <transferFromCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transfersLocked(_) => {
                    <transfersLockedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::unlockTimestamp(_) => {
                    <unlockTimestampCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls>] = &[
                {
                    fn supportsInterface(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn removeBridge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <removeBridgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::removeBridge)
                    }
                    removeBridge
                },
                {
                    fn name(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <nameCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::name)
                    }
                    name
                },
                {
                    fn approve(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <approveCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::approve)
                    }
                    approve
                },
                {
                    fn totalSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <totalSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::totalSupply)
                    }
                    totalSupply
                },
                {
                    fn crosschainMint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <crosschainMintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::crosschainMint)
                    }
                    crosschainMint
                },
                {
                    fn transferFrom(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <transferFromCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::transferFrom)
                    }
                    transferFrom
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn crosschainBurn(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <crosschainBurnCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::crosschainBurn)
                    }
                    crosschainBurn
                },
                {
                    fn grantRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn getAvailableBurnLimit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getAvailableBurnLimitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getAvailableBurnLimit)
                    }
                    getAvailableBurnLimit
                },
                {
                    fn decimals(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <decimalsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::decimals)
                    }
                    decimals
                },
                {
                    fn DOMAIN_SEPARATOR(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::DOMAIN_SEPARATOR)
                    }
                    DOMAIN_SEPARATOR
                },
                {
                    fn renounceRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn getPastVotes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getPastVotesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getPastVotes)
                    }
                    getPastVotes
                },
                {
                    fn mint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <mintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::mint)
                    }
                    mint
                },
                {
                    fn bridgeConfigs(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <bridgeConfigsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::bridgeConfigs)
                    }
                    bridgeConfigs
                },
                {
                    fn burn(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <burnCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::burn)
                    }
                    burn
                },
                {
                    fn getRemainingEmissions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getRemainingEmissionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getRemainingEmissions)
                    }
                    getRemainingEmissions
                },
                {
                    fn CLOCK_MODE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <CLOCK_MODECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::CLOCK_MODE)
                    }
                    CLOCK_MODE
                },
                {
                    fn MAX_LOCK_DURATION(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <MAX_LOCK_DURATIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::MAX_LOCK_DURATION)
                    }
                    MAX_LOCK_DURATION
                },
                {
                    fn delegates(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <delegatesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::delegates)
                    }
                    delegates
                },
                {
                    fn getBridgeAtIndex(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getBridgeAtIndexCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getBridgeAtIndex)
                    }
                    getBridgeAtIndex
                },
                {
                    fn delegate(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <delegateCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::delegate)
                    }
                    delegate
                },
                {
                    fn setBridgeLimits(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <setBridgeLimitsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::setBridgeLimits)
                    }
                    setBridgeLimits
                },
                {
                    fn getBridgeCount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getBridgeCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getBridgeCount)
                    }
                    getBridgeCount
                },
                {
                    fn isBridgeAdded(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <isBridgeAddedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::isBridgeAdded)
                    }
                    isBridgeAdded
                },
                {
                    fn numCheckpoints(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <numCheckpointsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::numCheckpoints)
                    }
                    numCheckpoints
                },
                {
                    fn balanceOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <balanceOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::balanceOf)
                    }
                    balanceOf
                },
                {
                    fn getAllBridges(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getAllBridgesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getAllBridges)
                    }
                    getAllBridges
                },
                {
                    fn isBridgeAuthorized(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <isBridgeAuthorizedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::isBridgeAuthorized)
                    }
                    isBridgeAuthorized
                },
                {
                    fn burnFrom(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <burnFromCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::burnFrom)
                    }
                    burnFrom
                },
                {
                    fn getRemainingLockTime(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getRemainingLockTimeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getRemainingLockTime)
                    }
                    getRemainingLockTime
                },
                {
                    fn nonces(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <noncesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::nonces)
                    }
                    nonces
                },
                {
                    fn transfersLocked(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <transfersLockedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::transfersLocked)
                    }
                    transfersLocked
                },
                {
                    fn maxLockTimestamp(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <maxLockTimestampCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::maxLockTimestamp)
                    }
                    maxLockTimestamp
                },
                {
                    fn setUnlockTimestamp(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <setUnlockTimestampCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::setUnlockTimestamp)
                    }
                    setUnlockTimestamp
                },
                {
                    fn eip712Domain(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <eip712DomainCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::eip712Domain)
                    }
                    eip712Domain
                },
                {
                    fn AIRDROP_MANAGER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <AIRDROP_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::AIRDROP_MANAGER_ROLE)
                    }
                    AIRDROP_MANAGER_ROLE
                },
                {
                    fn EMISSION_MINTER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <EMISSION_MINTER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::EMISSION_MINTER_ROLE)
                    }
                    EMISSION_MINTER_ROLE
                },
                {
                    fn getPastTotalSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getPastTotalSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getPastTotalSupply)
                    }
                    getPastTotalSupply
                },
                {
                    fn TOTAL_SUPPLY(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::TOTAL_SUPPLY)
                    }
                    TOTAL_SUPPLY
                },
                {
                    fn hasRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn clock(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <clockCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::clock)
                    }
                    clock
                },
                {
                    fn getAvailableMintLimit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getAvailableMintLimitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getAvailableMintLimit)
                    }
                    getAvailableMintLimit
                },
                {
                    fn symbol(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <symbolCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::symbol)
                    }
                    symbol
                },
                {
                    fn getVotes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getVotesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getVotes)
                    }
                    getVotes
                },
                {
                    fn INITIAL_MINT_SUPPLY(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::INITIAL_MINT_SUPPLY)
                    }
                    INITIAL_MINT_SUPPLY
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn bridges(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <bridgesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::bridges)
                    }
                    bridges
                },
                {
                    fn transfer(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <transferCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::transfer)
                    }
                    transfer
                },
                {
                    fn unlockTimestamp(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <unlockTimestampCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::unlockTimestamp)
                    }
                    unlockTimestamp
                },
                {
                    fn getPastVotingPower(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getPastVotingPowerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getPastVotingPower)
                    }
                    getPastVotingPower
                },
                {
                    fn getVotingPower(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getVotingPowerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getVotingPower)
                    }
                    getVotingPower
                },
                {
                    fn getCurrentTotalSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getCurrentTotalSupplyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getCurrentTotalSupply)
                    }
                    getCurrentTotalSupply
                },
                {
                    fn delegateBySig(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <delegateBySigCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::delegateBySig)
                    }
                    delegateBySig
                },
                {
                    fn getBridgeConfig(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <getBridgeConfigCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::getBridgeConfig)
                    }
                    getBridgeConfig
                },
                {
                    fn setBridgeActive(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <setBridgeActiveCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::setBridgeActive)
                    }
                    setBridgeActive
                },
                {
                    fn permit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <permitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::permit)
                    }
                    permit
                },
                {
                    fn revokeRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn allowance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <allowanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::allowance)
                    }
                    allowance
                },
                {
                    fn checkpoints(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <checkpointsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::checkpoints)
                    }
                    checkpoints
                },
                {
                    fn BRIDGE_MANAGER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainCalls> {
                        <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainCalls::BRIDGE_MANAGER_ROLE)
                    }
                    BRIDGE_MANAGER_ROLE
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AIRDROP_MANAGER_ROLE(inner) => {
                    <AIRDROP_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BRIDGE_MANAGER_ROLE(inner) => {
                    <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CLOCK_MODE(inner) => {
                    <CLOCK_MODECall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DOMAIN_SEPARATOR(inner) => {
                    <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EMISSION_MINTER_ROLE(inner) => {
                    <EMISSION_MINTER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::INITIAL_MINT_SUPPLY(inner) => {
                    <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MAX_LOCK_DURATION(inner) => {
                    <MAX_LOCK_DURATIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TOTAL_SUPPLY(inner) => {
                    <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::allowance(inner) => {
                    <allowanceCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::approve(inner) => {
                    <approveCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::bridgeConfigs(inner) => {
                    <bridgeConfigsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bridges(inner) => {
                    <bridgesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::burn(inner) => {
                    <burnCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::burnFrom(inner) => {
                    <burnFromCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::checkpoints(inner) => {
                    <checkpointsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::clock(inner) => {
                    <clockCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::crosschainBurn(inner) => {
                    <crosschainBurnCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::crosschainMint(inner) => {
                    <crosschainMintCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::decimals(inner) => {
                    <decimalsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::delegate(inner) => {
                    <delegateCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::delegateBySig(inner) => {
                    <delegateBySigCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::delegates(inner) => {
                    <delegatesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::eip712Domain(inner) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAllBridges(inner) => {
                    <getAllBridgesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAvailableBurnLimit(inner) => {
                    <getAvailableBurnLimitCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAvailableMintLimit(inner) => {
                    <getAvailableMintLimitCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBridgeAtIndex(inner) => {
                    <getBridgeAtIndexCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBridgeConfig(inner) => {
                    <getBridgeConfigCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBridgeCount(inner) => {
                    <getBridgeCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getCurrentTotalSupply(inner) => {
                    <getCurrentTotalSupplyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPastTotalSupply(inner) => {
                    <getPastTotalSupplyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPastVotes(inner) => {
                    <getPastVotesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPastVotingPower(inner) => {
                    <getPastVotingPowerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRemainingEmissions(inner) => {
                    <getRemainingEmissionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRemainingLockTime(inner) => {
                    <getRemainingLockTimeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getVotes(inner) => {
                    <getVotesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getVotingPower(inner) => {
                    <getVotingPowerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isBridgeAdded(inner) => {
                    <isBridgeAddedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isBridgeAuthorized(inner) => {
                    <isBridgeAuthorizedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::maxLockTimestamp(inner) => {
                    <maxLockTimestampCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::mint(inner) => {
                    <mintCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::name(inner) => {
                    <nameCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::nonces(inner) => {
                    <noncesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::numCheckpoints(inner) => {
                    <numCheckpointsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::permit(inner) => {
                    <permitCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::removeBridge(inner) => {
                    <removeBridgeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setBridgeActive(inner) => {
                    <setBridgeActiveCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setBridgeLimits(inner) => {
                    <setBridgeLimitsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setUnlockTimestamp(inner) => {
                    <setUnlockTimestampCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::symbol(inner) => {
                    <symbolCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::totalSupply(inner) => {
                    <totalSupplyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transfer(inner) => {
                    <transferCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::transferFrom(inner) => {
                    <transferFromCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transfersLocked(inner) => {
                    <transfersLockedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::unlockTimestamp(inner) => {
                    <unlockTimestampCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AIRDROP_MANAGER_ROLE(inner) => {
                    <AIRDROP_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BRIDGE_MANAGER_ROLE(inner) => {
                    <BRIDGE_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CLOCK_MODE(inner) => {
                    <CLOCK_MODECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DOMAIN_SEPARATOR(inner) => {
                    <DOMAIN_SEPARATORCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EMISSION_MINTER_ROLE(inner) => {
                    <EMISSION_MINTER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::INITIAL_MINT_SUPPLY(inner) => {
                    <INITIAL_MINT_SUPPLYCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MAX_LOCK_DURATION(inner) => {
                    <MAX_LOCK_DURATIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TOTAL_SUPPLY(inner) => {
                    <TOTAL_SUPPLYCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::allowance(inner) => {
                    <allowanceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::approve(inner) => {
                    <approveCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeConfigs(inner) => {
                    <bridgeConfigsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridges(inner) => {
                    <bridgesCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::burn(inner) => {
                    <burnCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::burnFrom(inner) => {
                    <burnFromCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::checkpoints(inner) => {
                    <checkpointsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::clock(inner) => {
                    <clockCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::crosschainBurn(inner) => {
                    <crosschainBurnCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::crosschainMint(inner) => {
                    <crosschainMintCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::decimals(inner) => {
                    <decimalsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::delegate(inner) => {
                    <delegateCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::delegateBySig(inner) => {
                    <delegateBySigCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::delegates(inner) => {
                    <delegatesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::eip712Domain(inner) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAllBridges(inner) => {
                    <getAllBridgesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAvailableBurnLimit(inner) => {
                    <getAvailableBurnLimitCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAvailableMintLimit(inner) => {
                    <getAvailableMintLimitCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBridgeAtIndex(inner) => {
                    <getBridgeAtIndexCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBridgeConfig(inner) => {
                    <getBridgeConfigCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBridgeCount(inner) => {
                    <getBridgeCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getCurrentTotalSupply(inner) => {
                    <getCurrentTotalSupplyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPastTotalSupply(inner) => {
                    <getPastTotalSupplyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPastVotes(inner) => {
                    <getPastVotesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPastVotingPower(inner) => {
                    <getPastVotingPowerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRemainingEmissions(inner) => {
                    <getRemainingEmissionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRemainingLockTime(inner) => {
                    <getRemainingLockTimeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getVotes(inner) => {
                    <getVotesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getVotingPower(inner) => {
                    <getVotingPowerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::isBridgeAdded(inner) => {
                    <isBridgeAddedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isBridgeAuthorized(inner) => {
                    <isBridgeAuthorizedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::maxLockTimestamp(inner) => {
                    <maxLockTimestampCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::mint(inner) => {
                    <mintCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::name(inner) => {
                    <nameCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::nonces(inner) => {
                    <noncesCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::numCheckpoints(inner) => {
                    <numCheckpointsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::permit(inner) => {
                    <permitCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::removeBridge(inner) => {
                    <removeBridgeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBridgeActive(inner) => {
                    <setBridgeActiveCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBridgeLimits(inner) => {
                    <setBridgeLimitsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setUnlockTimestamp(inner) => {
                    <setUnlockTimestampCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::symbol(inner) => {
                    <symbolCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::totalSupply(inner) => {
                    <totalSupplyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transfer(inner) => {
                    <transferCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferFrom(inner) => {
                    <transferFromCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transfersLocked(inner) => {
                    <transfersLockedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::unlockTimestamp(inner) => {
                    <unlockTimestampCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`SyndicateTokenCrosschain`](self) custom errors.
    pub enum SyndicateTokenCrosschainErrors {
        #[allow(missing_docs)]
        AccessControlBadConfirmation(AccessControlBadConfirmation),
        #[allow(missing_docs)]
        AccessControlUnauthorizedAccount(AccessControlUnauthorizedAccount),
        #[allow(missing_docs)]
        BridgeNotActive(BridgeNotActive),
        #[allow(missing_docs)]
        BurnOnlyDuringLockPeriod(BurnOnlyDuringLockPeriod),
        #[allow(missing_docs)]
        CheckpointUnorderedInsertion(CheckpointUnorderedInsertion),
        #[allow(missing_docs)]
        ECDSAInvalidSignature(ECDSAInvalidSignature),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureLength(ECDSAInvalidSignatureLength),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureS(ECDSAInvalidSignatureS),
        #[allow(missing_docs)]
        ERC20ExceededSafeSupply(ERC20ExceededSafeSupply),
        #[allow(missing_docs)]
        ERC20InsufficientAllowance(ERC20InsufficientAllowance),
        #[allow(missing_docs)]
        ERC20InsufficientBalance(ERC20InsufficientBalance),
        #[allow(missing_docs)]
        ERC20InvalidApprover(ERC20InvalidApprover),
        #[allow(missing_docs)]
        ERC20InvalidReceiver(ERC20InvalidReceiver),
        #[allow(missing_docs)]
        ERC20InvalidSender(ERC20InvalidSender),
        #[allow(missing_docs)]
        ERC20InvalidSpender(ERC20InvalidSpender),
        #[allow(missing_docs)]
        ERC2612ExpiredSignature(ERC2612ExpiredSignature),
        #[allow(missing_docs)]
        ERC2612InvalidSigner(ERC2612InvalidSigner),
        #[allow(missing_docs)]
        ERC5805FutureLookup(ERC5805FutureLookup),
        #[allow(missing_docs)]
        ERC6372InconsistentClock(ERC6372InconsistentClock),
        #[allow(missing_docs)]
        ExceedsTotalSupply(ExceedsTotalSupply),
        #[allow(missing_docs)]
        InsufficientBurnLimit(InsufficientBurnLimit),
        #[allow(missing_docs)]
        InsufficientMintLimit(InsufficientMintLimit),
        #[allow(missing_docs)]
        InvalidAccountNonce(InvalidAccountNonce),
        #[allow(missing_docs)]
        InvalidShortString(InvalidShortString),
        #[allow(missing_docs)]
        SafeCastOverflowedUintDowncast(SafeCastOverflowedUintDowncast),
        #[allow(missing_docs)]
        StringTooLong(StringTooLong),
        #[allow(missing_docs)]
        TransfersLocked(TransfersLocked),
        #[allow(missing_docs)]
        UnauthorizedBridge(UnauthorizedBridge),
        #[allow(missing_docs)]
        UnlockTimestampInPast(UnlockTimestampInPast),
        #[allow(missing_docs)]
        UnlockTimestampTooLate(UnlockTimestampTooLate),
        #[allow(missing_docs)]
        VotesExpiredSignature(VotesExpiredSignature),
        #[allow(missing_docs)]
        ZeroAddress(ZeroAddress),
        #[allow(missing_docs)]
        ZeroAmount(ZeroAmount),
    }
    #[automatically_derived]
    impl SyndicateTokenCrosschainErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [23u8, 126u8, 63u8, 195u8],
            [28u8, 177u8, 93u8, 38u8],
            [31u8, 42u8, 32u8, 5u8],
            [37u8, 32u8, 96u8, 29u8],
            [48u8, 90u8, 39u8, 169u8],
            [64u8, 237u8, 54u8, 123u8],
            [70u8, 131u8, 175u8, 14u8],
            [75u8, 128u8, 14u8, 70u8],
            [98u8, 121u8, 19u8, 2u8],
            [101u8, 133u8, 182u8, 13u8],
            [102u8, 151u8, 178u8, 50u8],
            [109u8, 252u8, 198u8, 80u8],
            [111u8, 240u8, 113u8, 64u8],
            [117u8, 45u8, 136u8, 192u8],
            [148u8, 40u8, 13u8, 98u8],
            [150u8, 198u8, 253u8, 30u8],
            [165u8, 101u8, 131u8, 83u8],
            [179u8, 81u8, 43u8, 12u8],
            [184u8, 181u8, 202u8, 45u8],
            [215u8, 139u8, 206u8, 12u8],
            [217u8, 46u8, 35u8, 61u8],
            [219u8, 137u8, 227u8, 244u8],
            [226u8, 81u8, 125u8, 63u8],
            [228u8, 80u8, 211u8, 140u8],
            [229u8, 254u8, 151u8, 162u8],
            [230u8, 2u8, 223u8, 5u8],
            [236u8, 68u8, 47u8, 5u8],
            [236u8, 211u8, 248u8, 30u8],
            [239u8, 105u8, 175u8, 101u8],
            [239u8, 218u8, 14u8, 6u8],
            [246u8, 69u8, 238u8, 223u8],
            [251u8, 143u8, 65u8, 178u8],
            [252u8, 230u8, 152u8, 247u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for SyndicateTokenCrosschainErrors {
        const NAME: &'static str = "SyndicateTokenCrosschainErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 33usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AccessControlBadConfirmation(_) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AccessControlUnauthorizedAccount(_) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BridgeNotActive(_) => {
                    <BridgeNotActive as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BurnOnlyDuringLockPeriod(_) => {
                    <BurnOnlyDuringLockPeriod as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CheckpointUnorderedInsertion(_) => {
                    <CheckpointUnorderedInsertion as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignature(_) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureLength(_) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureS(_) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20ExceededSafeSupply(_) => {
                    <ERC20ExceededSafeSupply as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InsufficientAllowance(_) => {
                    <ERC20InsufficientAllowance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InsufficientBalance(_) => {
                    <ERC20InsufficientBalance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidApprover(_) => {
                    <ERC20InvalidApprover as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidReceiver(_) => {
                    <ERC20InvalidReceiver as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidSender(_) => {
                    <ERC20InvalidSender as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC20InvalidSpender(_) => {
                    <ERC20InvalidSpender as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC2612ExpiredSignature(_) => {
                    <ERC2612ExpiredSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC2612InvalidSigner(_) => {
                    <ERC2612InvalidSigner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC5805FutureLookup(_) => {
                    <ERC5805FutureLookup as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC6372InconsistentClock(_) => {
                    <ERC6372InconsistentClock as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ExceedsTotalSupply(_) => {
                    <ExceedsTotalSupply as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientBurnLimit(_) => {
                    <InsufficientBurnLimit as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientMintLimit(_) => {
                    <InsufficientMintLimit as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidAccountNonce(_) => {
                    <InvalidAccountNonce as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidShortString(_) => {
                    <InvalidShortString as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SafeCastOverflowedUintDowncast(_) => {
                    <SafeCastOverflowedUintDowncast as alloy_sol_types::SolError>::SELECTOR
                }
                Self::StringTooLong(_) => {
                    <StringTooLong as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TransfersLocked(_) => {
                    <TransfersLocked as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UnauthorizedBridge(_) => {
                    <UnauthorizedBridge as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UnlockTimestampInPast(_) => {
                    <UnlockTimestampInPast as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UnlockTimestampTooLate(_) => {
                    <UnlockTimestampTooLate as alloy_sol_types::SolError>::SELECTOR
                }
                Self::VotesExpiredSignature(_) => {
                    <VotesExpiredSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAddress(_) => {
                    <ZeroAddress as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAmount(_) => {
                    <ZeroAmount as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors>] = &[
                {
                    fn ExceedsTotalSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ExceedsTotalSupply as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::ExceedsTotalSupply)
                    }
                    ExceedsTotalSupply
                },
                {
                    fn ERC20ExceededSafeSupply(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ERC20ExceededSafeSupply as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::ERC20ExceededSafeSupply)
                    }
                    ERC20ExceededSafeSupply
                },
                {
                    fn ZeroAmount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ZeroAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::ZeroAmount)
                    }
                    ZeroAmount
                },
                {
                    fn CheckpointUnorderedInsertion(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <CheckpointUnorderedInsertion as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenCrosschainErrors::CheckpointUnorderedInsertion,
                            )
                    }
                    CheckpointUnorderedInsertion
                },
                {
                    fn StringTooLong(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <StringTooLong as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::StringTooLong)
                    }
                    StringTooLong
                },
                {
                    fn InsufficientMintLimit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <InsufficientMintLimit as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::InsufficientMintLimit)
                    }
                    InsufficientMintLimit
                },
                {
                    fn VotesExpiredSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <VotesExpiredSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::VotesExpiredSignature)
                    }
                    VotesExpiredSignature
                },
                {
                    fn ERC2612InvalidSigner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ERC2612InvalidSigner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::ERC2612InvalidSigner)
                    }
                    ERC2612InvalidSigner
                },
                {
                    fn ERC2612ExpiredSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ERC2612ExpiredSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::ERC2612ExpiredSignature)
                    }
                    ERC2612ExpiredSignature
                },
                {
                    fn UnauthorizedBridge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <UnauthorizedBridge as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::UnauthorizedBridge)
                    }
                    UnauthorizedBridge
                },
                {
                    fn AccessControlBadConfirmation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenCrosschainErrors::AccessControlBadConfirmation,
                            )
                    }
                    AccessControlBadConfirmation
                },
                {
                    fn SafeCastOverflowedUintDowncast(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <SafeCastOverflowedUintDowncast as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenCrosschainErrors::SafeCastOverflowedUintDowncast,
                            )
                    }
                    SafeCastOverflowedUintDowncast
                },
                {
                    fn ERC6372InconsistentClock(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ERC6372InconsistentClock as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenCrosschainErrors::ERC6372InconsistentClock,
                            )
                    }
                    ERC6372InconsistentClock
                },
                {
                    fn InvalidAccountNonce(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <InvalidAccountNonce as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::InvalidAccountNonce)
                    }
                    InvalidAccountNonce
                },
                {
                    fn ERC20InvalidSpender(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ERC20InvalidSpender as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::ERC20InvalidSpender)
                    }
                    ERC20InvalidSpender
                },
                {
                    fn ERC20InvalidSender(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ERC20InvalidSender as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::ERC20InvalidSender)
                    }
                    ERC20InvalidSender
                },
                {
                    fn UnlockTimestampInPast(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <UnlockTimestampInPast as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::UnlockTimestampInPast)
                    }
                    UnlockTimestampInPast
                },
                {
                    fn InvalidShortString(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <InvalidShortString as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::InvalidShortString)
                    }
                    InvalidShortString
                },
                {
                    fn BurnOnlyDuringLockPeriod(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <BurnOnlyDuringLockPeriod as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenCrosschainErrors::BurnOnlyDuringLockPeriod,
                            )
                    }
                    BurnOnlyDuringLockPeriod
                },
                {
                    fn ECDSAInvalidSignatureS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::ECDSAInvalidSignatureS)
                    }
                    ECDSAInvalidSignatureS
                },
                {
                    fn ZeroAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ZeroAddress as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::ZeroAddress)
                    }
                    ZeroAddress
                },
                {
                    fn TransfersLocked(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <TransfersLocked as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::TransfersLocked)
                    }
                    TransfersLocked
                },
                {
                    fn AccessControlUnauthorizedAccount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenCrosschainErrors::AccessControlUnauthorizedAccount,
                            )
                    }
                    AccessControlUnauthorizedAccount
                },
                {
                    fn ERC20InsufficientBalance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ERC20InsufficientBalance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenCrosschainErrors::ERC20InsufficientBalance,
                            )
                    }
                    ERC20InsufficientBalance
                },
                {
                    fn InsufficientBurnLimit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <InsufficientBurnLimit as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::InsufficientBurnLimit)
                    }
                    InsufficientBurnLimit
                },
                {
                    fn ERC20InvalidApprover(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ERC20InvalidApprover as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::ERC20InvalidApprover)
                    }
                    ERC20InvalidApprover
                },
                {
                    fn ERC20InvalidReceiver(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ERC20InvalidReceiver as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::ERC20InvalidReceiver)
                    }
                    ERC20InvalidReceiver
                },
                {
                    fn ERC5805FutureLookup(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ERC5805FutureLookup as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::ERC5805FutureLookup)
                    }
                    ERC5805FutureLookup
                },
                {
                    fn UnlockTimestampTooLate(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <UnlockTimestampTooLate as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::UnlockTimestampTooLate)
                    }
                    UnlockTimestampTooLate
                },
                {
                    fn BridgeNotActive(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <BridgeNotActive as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::BridgeNotActive)
                    }
                    BridgeNotActive
                },
                {
                    fn ECDSAInvalidSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(SyndicateTokenCrosschainErrors::ECDSAInvalidSignature)
                    }
                    ECDSAInvalidSignature
                },
                {
                    fn ERC20InsufficientAllowance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ERC20InsufficientAllowance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenCrosschainErrors::ERC20InsufficientAllowance,
                            )
                    }
                    ERC20InsufficientAllowance
                },
                {
                    fn ECDSAInvalidSignatureLength(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<SyndicateTokenCrosschainErrors> {
                        <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                SyndicateTokenCrosschainErrors::ECDSAInvalidSignatureLength,
                            )
                    }
                    ECDSAInvalidSignatureLength
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BridgeNotActive(inner) => {
                    <BridgeNotActive as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BurnOnlyDuringLockPeriod(inner) => {
                    <BurnOnlyDuringLockPeriod as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CheckpointUnorderedInsertion(inner) => {
                    <CheckpointUnorderedInsertion as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20ExceededSafeSupply(inner) => {
                    <ERC20ExceededSafeSupply as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InsufficientAllowance(inner) => {
                    <ERC20InsufficientAllowance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InsufficientBalance(inner) => {
                    <ERC20InsufficientBalance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidApprover(inner) => {
                    <ERC20InvalidApprover as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidReceiver(inner) => {
                    <ERC20InvalidReceiver as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidSender(inner) => {
                    <ERC20InvalidSender as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC20InvalidSpender(inner) => {
                    <ERC20InvalidSpender as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC2612ExpiredSignature(inner) => {
                    <ERC2612ExpiredSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC2612InvalidSigner(inner) => {
                    <ERC2612InvalidSigner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC5805FutureLookup(inner) => {
                    <ERC5805FutureLookup as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC6372InconsistentClock(inner) => {
                    <ERC6372InconsistentClock as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ExceedsTotalSupply(inner) => {
                    <ExceedsTotalSupply as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientBurnLimit(inner) => {
                    <InsufficientBurnLimit as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientMintLimit(inner) => {
                    <InsufficientMintLimit as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidAccountNonce(inner) => {
                    <InvalidAccountNonce as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidShortString(inner) => {
                    <InvalidShortString as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SafeCastOverflowedUintDowncast(inner) => {
                    <SafeCastOverflowedUintDowncast as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::StringTooLong(inner) => {
                    <StringTooLong as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::TransfersLocked(inner) => {
                    <TransfersLocked as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UnauthorizedBridge(inner) => {
                    <UnauthorizedBridge as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UnlockTimestampInPast(inner) => {
                    <UnlockTimestampInPast as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UnlockTimestampTooLate(inner) => {
                    <UnlockTimestampTooLate as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::VotesExpiredSignature(inner) => {
                    <VotesExpiredSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ZeroAmount(inner) => {
                    <ZeroAmount as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BridgeNotActive(inner) => {
                    <BridgeNotActive as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BurnOnlyDuringLockPeriod(inner) => {
                    <BurnOnlyDuringLockPeriod as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CheckpointUnorderedInsertion(inner) => {
                    <CheckpointUnorderedInsertion as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20ExceededSafeSupply(inner) => {
                    <ERC20ExceededSafeSupply as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InsufficientAllowance(inner) => {
                    <ERC20InsufficientAllowance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InsufficientBalance(inner) => {
                    <ERC20InsufficientBalance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidApprover(inner) => {
                    <ERC20InvalidApprover as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidReceiver(inner) => {
                    <ERC20InvalidReceiver as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidSender(inner) => {
                    <ERC20InvalidSender as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC20InvalidSpender(inner) => {
                    <ERC20InvalidSpender as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC2612ExpiredSignature(inner) => {
                    <ERC2612ExpiredSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC2612InvalidSigner(inner) => {
                    <ERC2612InvalidSigner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC5805FutureLookup(inner) => {
                    <ERC5805FutureLookup as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC6372InconsistentClock(inner) => {
                    <ERC6372InconsistentClock as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ExceedsTotalSupply(inner) => {
                    <ExceedsTotalSupply as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientBurnLimit(inner) => {
                    <InsufficientBurnLimit as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientMintLimit(inner) => {
                    <InsufficientMintLimit as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidAccountNonce(inner) => {
                    <InvalidAccountNonce as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidShortString(inner) => {
                    <InvalidShortString as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SafeCastOverflowedUintDowncast(inner) => {
                    <SafeCastOverflowedUintDowncast as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::StringTooLong(inner) => {
                    <StringTooLong as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TransfersLocked(inner) => {
                    <TransfersLocked as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UnauthorizedBridge(inner) => {
                    <UnauthorizedBridge as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UnlockTimestampInPast(inner) => {
                    <UnlockTimestampInPast as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UnlockTimestampTooLate(inner) => {
                    <UnlockTimestampTooLate as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::VotesExpiredSignature(inner) => {
                    <VotesExpiredSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAmount(inner) => {
                    <ZeroAmount as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
            }
        }
    }
    ///Container for all the [`SyndicateTokenCrosschain`](self) events.
    pub enum SyndicateTokenCrosschainEvents {
        #[allow(missing_docs)]
        Approval(Approval),
        #[allow(missing_docs)]
        BridgeActiveStatusChanged(BridgeActiveStatusChanged),
        #[allow(missing_docs)]
        BridgeAdded(BridgeAdded),
        #[allow(missing_docs)]
        BridgeLimitsSet(BridgeLimitsSet),
        #[allow(missing_docs)]
        BridgeRemoved(BridgeRemoved),
        #[allow(missing_docs)]
        CrosschainBurn(CrosschainBurn),
        #[allow(missing_docs)]
        CrosschainMint(CrosschainMint),
        #[allow(missing_docs)]
        DelegateChanged(DelegateChanged),
        #[allow(missing_docs)]
        DelegateVotesChanged(DelegateVotesChanged),
        #[allow(missing_docs)]
        EIP712DomainChanged(EIP712DomainChanged),
        #[allow(missing_docs)]
        RoleAdminChanged(RoleAdminChanged),
        #[allow(missing_docs)]
        RoleGranted(RoleGranted),
        #[allow(missing_docs)]
        RoleRevoked(RoleRevoked),
        #[allow(missing_docs)]
        TokensBurnedByManager(TokensBurnedByManager),
        #[allow(missing_docs)]
        Transfer(Transfer),
        #[allow(missing_docs)]
        UnlockTimestampUpdated(UnlockTimestampUpdated),
    }
    #[automatically_derived]
    impl SyndicateTokenCrosschainEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                10u8,
                99u8,
                135u8,
                201u8,
                234u8,
                54u8,
                40u8,
                184u8,
                138u8,
                99u8,
                59u8,
                180u8,
                243u8,
                177u8,
                81u8,
                119u8,
                15u8,
                112u8,
                8u8,
                81u8,
                23u8,
                161u8,
                95u8,
                155u8,
                243u8,
                120u8,
                124u8,
                218u8,
                83u8,
                241u8,
                61u8,
                49u8,
            ],
            [
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ],
            [
                49u8,
                52u8,
                232u8,
                162u8,
                230u8,
                217u8,
                126u8,
                146u8,
                154u8,
                126u8,
                84u8,
                1u8,
                30u8,
                165u8,
                72u8,
                93u8,
                125u8,
                25u8,
                109u8,
                213u8,
                240u8,
                186u8,
                77u8,
                78u8,
                249u8,
                88u8,
                3u8,
                232u8,
                227u8,
                252u8,
                37u8,
                127u8,
            ],
            [
                93u8,
                157u8,
                80u8,
                52u8,
                101u8,
                108u8,
                179u8,
                235u8,
                251u8,
                6u8,
                85u8,
                5u8,
                124u8,
                215u8,
                249u8,
                180u8,
                7u8,
                122u8,
                155u8,
                66u8,
                255u8,
                66u8,
                206u8,
                34u8,
                60u8,
                186u8,
                197u8,
                188u8,
                88u8,
                109u8,
                33u8,
                38u8,
            ],
            [
                140u8,
                91u8,
                225u8,
                229u8,
                235u8,
                236u8,
                125u8,
                91u8,
                209u8,
                79u8,
                113u8,
                66u8,
                125u8,
                30u8,
                132u8,
                243u8,
                221u8,
                3u8,
                20u8,
                192u8,
                247u8,
                178u8,
                41u8,
                30u8,
                91u8,
                32u8,
                10u8,
                200u8,
                199u8,
                195u8,
                185u8,
                37u8,
            ],
            [
                156u8,
                134u8,
                104u8,
                219u8,
                50u8,
                72u8,
                69u8,
                6u8,
                93u8,
                43u8,
                154u8,
                42u8,
                24u8,
                59u8,
                211u8,
                20u8,
                31u8,
                99u8,
                1u8,
                143u8,
                84u8,
                130u8,
                130u8,
                218u8,
                241u8,
                141u8,
                164u8,
                156u8,
                203u8,
                248u8,
                140u8,
                51u8,
            ],
            [
                170u8,
                128u8,
                125u8,
                10u8,
                191u8,
                48u8,
                217u8,
                25u8,
                104u8,
                199u8,
                71u8,
                140u8,
                102u8,
                182u8,
                216u8,
                37u8,
                33u8,
                161u8,
                6u8,
                175u8,
                19u8,
                237u8,
                160u8,
                54u8,
                226u8,
                3u8,
                109u8,
                169u8,
                175u8,
                22u8,
                137u8,
                88u8,
            ],
            [
                185u8,
                7u8,
                149u8,
                166u8,
                102u8,
                80u8,
                21u8,
                89u8,
                131u8,
                226u8,
                66u8,
                202u8,
                195u8,
                225u8,
                172u8,
                26u8,
                77u8,
                194u8,
                111u8,
                142u8,
                210u8,
                152u8,
                127u8,
                60u8,
                228u8,
                22u8,
                163u8,
                78u8,
                0u8,
                17u8,
                31u8,
                212u8,
            ],
            [
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ],
            [
                190u8,
                244u8,
                248u8,
                28u8,
                24u8,
                20u8,
                198u8,
                65u8,
                237u8,
                232u8,
                94u8,
                186u8,
                172u8,
                241u8,
                157u8,
                4u8,
                139u8,
                44u8,
                91u8,
                85u8,
                152u8,
                10u8,
                223u8,
                166u8,
                239u8,
                15u8,
                149u8,
                108u8,
                101u8,
                19u8,
                53u8,
                162u8,
            ],
            [
                219u8,
                3u8,
                249u8,
                125u8,
                197u8,
                132u8,
                10u8,
                113u8,
                230u8,
                155u8,
                231u8,
                71u8,
                14u8,
                71u8,
                97u8,
                175u8,
                16u8,
                161u8,
                35u8,
                121u8,
                115u8,
                232u8,
                28u8,
                18u8,
                208u8,
                220u8,
                40u8,
                19u8,
                137u8,
                90u8,
                101u8,
                38u8,
            ],
            [
                221u8,
                104u8,
                150u8,
                220u8,
                241u8,
                212u8,
                179u8,
                17u8,
                204u8,
                168u8,
                125u8,
                209u8,
                155u8,
                187u8,
                162u8,
                234u8,
                156u8,
                226u8,
                248u8,
                103u8,
                193u8,
                86u8,
                136u8,
                120u8,
                160u8,
                67u8,
                138u8,
                102u8,
                161u8,
                175u8,
                238u8,
                236u8,
            ],
            [
                221u8,
                242u8,
                82u8,
                173u8,
                27u8,
                226u8,
                200u8,
                155u8,
                105u8,
                194u8,
                176u8,
                104u8,
                252u8,
                55u8,
                141u8,
                170u8,
                149u8,
                43u8,
                167u8,
                241u8,
                99u8,
                196u8,
                161u8,
                22u8,
                40u8,
                245u8,
                90u8,
                77u8,
                245u8,
                35u8,
                179u8,
                239u8,
            ],
            [
                222u8,
                34u8,
                186u8,
                255u8,
                3u8,
                142u8,
                58u8,
                62u8,
                8u8,
                64u8,
                124u8,
                189u8,
                246u8,
                23u8,
                222u8,
                237u8,
                116u8,
                232u8,
                105u8,
                167u8,
                186u8,
                81u8,
                125u8,
                246u8,
                17u8,
                227u8,
                49u8,
                49u8,
                198u8,
                230u8,
                234u8,
                4u8,
            ],
            [
                222u8,
                194u8,
                186u8,
                205u8,
                210u8,
                240u8,
                91u8,
                89u8,
                222u8,
                52u8,
                218u8,
                155u8,
                82u8,
                61u8,
                255u8,
                139u8,
                228u8,
                46u8,
                94u8,
                56u8,
                232u8,
                24u8,
                200u8,
                47u8,
                219u8,
                11u8,
                174u8,
                119u8,
                67u8,
                135u8,
                167u8,
                36u8,
            ],
            [
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for SyndicateTokenCrosschainEvents {
        const NAME: &'static str = "SyndicateTokenCrosschainEvents";
        const COUNT: usize = 16usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<Approval as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Approval as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Approval)
                }
                Some(
                    <BridgeActiveStatusChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BridgeActiveStatusChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeActiveStatusChanged)
                }
                Some(<BridgeAdded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <BridgeAdded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeAdded)
                }
                Some(<BridgeLimitsSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <BridgeLimitsSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeLimitsSet)
                }
                Some(<BridgeRemoved as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <BridgeRemoved as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BridgeRemoved)
                }
                Some(<CrosschainBurn as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <CrosschainBurn as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::CrosschainBurn)
                }
                Some(<CrosschainMint as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <CrosschainMint as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::CrosschainMint)
                }
                Some(<DelegateChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <DelegateChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::DelegateChanged)
                }
                Some(
                    <DelegateVotesChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <DelegateVotesChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::DelegateVotesChanged)
                }
                Some(
                    <EIP712DomainChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <EIP712DomainChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EIP712DomainChanged)
                }
                Some(<RoleAdminChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleAdminChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleAdminChanged)
                }
                Some(<RoleGranted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleGranted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleGranted)
                }
                Some(<RoleRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleRevoked)
                }
                Some(
                    <TokensBurnedByManager as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <TokensBurnedByManager as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::TokensBurnedByManager)
                }
                Some(<Transfer as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Transfer as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Transfer)
                }
                Some(
                    <UnlockTimestampUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <UnlockTimestampUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::UnlockTimestampUpdated)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for SyndicateTokenCrosschainEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Approval(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeActiveStatusChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeLimitsSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgeRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::CrosschainBurn(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::CrosschainMint(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DelegateChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DelegateVotesChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EIP712DomainChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TokensBurnedByManager(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Transfer(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::UnlockTimestampUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Approval(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeActiveStatusChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeLimitsSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgeRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::CrosschainBurn(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::CrosschainMint(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DelegateChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DelegateVotesChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EIP712DomainChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TokensBurnedByManager(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Transfer(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::UnlockTimestampUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`SyndicateTokenCrosschain`](self) contract instance.

See the [wrapper's documentation](`SyndicateTokenCrosschainInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> SyndicateTokenCrosschainInstance<T, P, N> {
        SyndicateTokenCrosschainInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        defaultAdmin: alloy::sol_types::private::Address,
        syndTreasuryAddress: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<SyndicateTokenCrosschainInstance<T, P, N>>,
    > {
        SyndicateTokenCrosschainInstance::<
            T,
            P,
            N,
        >::deploy(provider, defaultAdmin, syndTreasuryAddress)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        defaultAdmin: alloy::sol_types::private::Address,
        syndTreasuryAddress: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        SyndicateTokenCrosschainInstance::<
            T,
            P,
            N,
        >::deploy_builder(provider, defaultAdmin, syndTreasuryAddress)
    }
    /**A [`SyndicateTokenCrosschain`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`SyndicateTokenCrosschain`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct SyndicateTokenCrosschainInstance<
        T,
        P,
        N = alloy_contract::private::Ethereum,
    > {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for SyndicateTokenCrosschainInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("SyndicateTokenCrosschainInstance")
                .field(&self.address)
                .finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyndicateTokenCrosschainInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`SyndicateTokenCrosschain`](self) contract instance.

See the [wrapper's documentation](`SyndicateTokenCrosschainInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            defaultAdmin: alloy::sol_types::private::Address,
            syndTreasuryAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<SyndicateTokenCrosschainInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(
                provider,
                defaultAdmin,
                syndTreasuryAddress,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            defaultAdmin: alloy::sol_types::private::Address,
            syndTreasuryAddress: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            defaultAdmin,
                            syndTreasuryAddress,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> SyndicateTokenCrosschainInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> SyndicateTokenCrosschainInstance<T, P, N> {
            SyndicateTokenCrosschainInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyndicateTokenCrosschainInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`AIRDROP_MANAGER_ROLE`] function.
        pub fn AIRDROP_MANAGER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, AIRDROP_MANAGER_ROLECall, N> {
            self.call_builder(&AIRDROP_MANAGER_ROLECall {})
        }
        ///Creates a new call builder for the [`BRIDGE_MANAGER_ROLE`] function.
        pub fn BRIDGE_MANAGER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, BRIDGE_MANAGER_ROLECall, N> {
            self.call_builder(&BRIDGE_MANAGER_ROLECall {})
        }
        ///Creates a new call builder for the [`CLOCK_MODE`] function.
        pub fn CLOCK_MODE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, CLOCK_MODECall, N> {
            self.call_builder(&CLOCK_MODECall {})
        }
        ///Creates a new call builder for the [`DEFAULT_ADMIN_ROLE`] function.
        pub fn DEFAULT_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, DEFAULT_ADMIN_ROLECall, N> {
            self.call_builder(&DEFAULT_ADMIN_ROLECall {})
        }
        ///Creates a new call builder for the [`DOMAIN_SEPARATOR`] function.
        pub fn DOMAIN_SEPARATOR(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, DOMAIN_SEPARATORCall, N> {
            self.call_builder(&DOMAIN_SEPARATORCall {})
        }
        ///Creates a new call builder for the [`EMISSION_MINTER_ROLE`] function.
        pub fn EMISSION_MINTER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, EMISSION_MINTER_ROLECall, N> {
            self.call_builder(&EMISSION_MINTER_ROLECall {})
        }
        ///Creates a new call builder for the [`INITIAL_MINT_SUPPLY`] function.
        pub fn INITIAL_MINT_SUPPLY(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, INITIAL_MINT_SUPPLYCall, N> {
            self.call_builder(&INITIAL_MINT_SUPPLYCall {})
        }
        ///Creates a new call builder for the [`MAX_LOCK_DURATION`] function.
        pub fn MAX_LOCK_DURATION(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, MAX_LOCK_DURATIONCall, N> {
            self.call_builder(&MAX_LOCK_DURATIONCall {})
        }
        ///Creates a new call builder for the [`TOTAL_SUPPLY`] function.
        pub fn TOTAL_SUPPLY(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, TOTAL_SUPPLYCall, N> {
            self.call_builder(&TOTAL_SUPPLYCall {})
        }
        ///Creates a new call builder for the [`allowance`] function.
        pub fn allowance(
            &self,
            owner: alloy::sol_types::private::Address,
            spender: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, allowanceCall, N> {
            self.call_builder(&allowanceCall { owner, spender })
        }
        ///Creates a new call builder for the [`approve`] function.
        pub fn approve(
            &self,
            spender: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, approveCall, N> {
            self.call_builder(&approveCall { spender, value })
        }
        ///Creates a new call builder for the [`balanceOf`] function.
        pub fn balanceOf(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, balanceOfCall, N> {
            self.call_builder(&balanceOfCall { account })
        }
        ///Creates a new call builder for the [`bridgeConfigs`] function.
        pub fn bridgeConfigs(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeConfigsCall, N> {
            self.call_builder(&bridgeConfigsCall { _0 })
        }
        ///Creates a new call builder for the [`bridges`] function.
        pub fn bridges(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgesCall, N> {
            self.call_builder(&bridgesCall { _0 })
        }
        ///Creates a new call builder for the [`burn`] function.
        pub fn burn(
            &self,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, burnCall, N> {
            self.call_builder(&burnCall { amount })
        }
        ///Creates a new call builder for the [`burnFrom`] function.
        pub fn burnFrom(
            &self,
            from: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, burnFromCall, N> {
            self.call_builder(&burnFromCall { from, amount })
        }
        ///Creates a new call builder for the [`checkpoints`] function.
        pub fn checkpoints(
            &self,
            account: alloy::sol_types::private::Address,
            pos: u32,
        ) -> alloy_contract::SolCallBuilder<T, &P, checkpointsCall, N> {
            self.call_builder(&checkpointsCall { account, pos })
        }
        ///Creates a new call builder for the [`clock`] function.
        pub fn clock(&self) -> alloy_contract::SolCallBuilder<T, &P, clockCall, N> {
            self.call_builder(&clockCall {})
        }
        ///Creates a new call builder for the [`crosschainBurn`] function.
        pub fn crosschainBurn(
            &self,
            from: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, crosschainBurnCall, N> {
            self.call_builder(&crosschainBurnCall { from, amount })
        }
        ///Creates a new call builder for the [`crosschainMint`] function.
        pub fn crosschainMint(
            &self,
            to: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, crosschainMintCall, N> {
            self.call_builder(&crosschainMintCall { to, amount })
        }
        ///Creates a new call builder for the [`decimals`] function.
        pub fn decimals(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, decimalsCall, N> {
            self.call_builder(&decimalsCall {})
        }
        ///Creates a new call builder for the [`delegate`] function.
        pub fn delegate(
            &self,
            delegatee: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, delegateCall, N> {
            self.call_builder(&delegateCall { delegatee })
        }
        ///Creates a new call builder for the [`delegateBySig`] function.
        pub fn delegateBySig(
            &self,
            delegatee: alloy::sol_types::private::Address,
            nonce: alloy::sol_types::private::primitives::aliases::U256,
            expiry: alloy::sol_types::private::primitives::aliases::U256,
            v: u8,
            r: alloy::sol_types::private::FixedBytes<32>,
            s: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, delegateBySigCall, N> {
            self.call_builder(
                &delegateBySigCall {
                    delegatee,
                    nonce,
                    expiry,
                    v,
                    r,
                    s,
                },
            )
        }
        ///Creates a new call builder for the [`delegates`] function.
        pub fn delegates(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, delegatesCall, N> {
            self.call_builder(&delegatesCall { account })
        }
        ///Creates a new call builder for the [`eip712Domain`] function.
        pub fn eip712Domain(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, eip712DomainCall, N> {
            self.call_builder(&eip712DomainCall {})
        }
        ///Creates a new call builder for the [`getAllBridges`] function.
        pub fn getAllBridges(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getAllBridgesCall, N> {
            self.call_builder(&getAllBridgesCall {})
        }
        ///Creates a new call builder for the [`getAvailableBurnLimit`] function.
        pub fn getAvailableBurnLimit(
            &self,
            bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getAvailableBurnLimitCall, N> {
            self.call_builder(
                &getAvailableBurnLimitCall {
                    bridge,
                },
            )
        }
        ///Creates a new call builder for the [`getAvailableMintLimit`] function.
        pub fn getAvailableMintLimit(
            &self,
            bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getAvailableMintLimitCall, N> {
            self.call_builder(
                &getAvailableMintLimitCall {
                    bridge,
                },
            )
        }
        ///Creates a new call builder for the [`getBridgeAtIndex`] function.
        pub fn getBridgeAtIndex(
            &self,
            index: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBridgeAtIndexCall, N> {
            self.call_builder(&getBridgeAtIndexCall { index })
        }
        ///Creates a new call builder for the [`getBridgeConfig`] function.
        pub fn getBridgeConfig(
            &self,
            bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBridgeConfigCall, N> {
            self.call_builder(&getBridgeConfigCall { bridge })
        }
        ///Creates a new call builder for the [`getBridgeCount`] function.
        pub fn getBridgeCount(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBridgeCountCall, N> {
            self.call_builder(&getBridgeCountCall {})
        }
        ///Creates a new call builder for the [`getCurrentTotalSupply`] function.
        pub fn getCurrentTotalSupply(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getCurrentTotalSupplyCall, N> {
            self.call_builder(&getCurrentTotalSupplyCall {})
        }
        ///Creates a new call builder for the [`getPastTotalSupply`] function.
        pub fn getPastTotalSupply(
            &self,
            timepoint: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getPastTotalSupplyCall, N> {
            self.call_builder(
                &getPastTotalSupplyCall {
                    timepoint,
                },
            )
        }
        ///Creates a new call builder for the [`getPastVotes`] function.
        pub fn getPastVotes(
            &self,
            account: alloy::sol_types::private::Address,
            timepoint: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getPastVotesCall, N> {
            self.call_builder(
                &getPastVotesCall {
                    account,
                    timepoint,
                },
            )
        }
        ///Creates a new call builder for the [`getPastVotingPower`] function.
        pub fn getPastVotingPower(
            &self,
            account: alloy::sol_types::private::Address,
            blockNumber: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getPastVotingPowerCall, N> {
            self.call_builder(
                &getPastVotingPowerCall {
                    account,
                    blockNumber,
                },
            )
        }
        ///Creates a new call builder for the [`getRemainingEmissions`] function.
        pub fn getRemainingEmissions(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRemainingEmissionsCall, N> {
            self.call_builder(&getRemainingEmissionsCall {})
        }
        ///Creates a new call builder for the [`getRemainingLockTime`] function.
        pub fn getRemainingLockTime(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRemainingLockTimeCall, N> {
            self.call_builder(&getRemainingLockTimeCall {})
        }
        ///Creates a new call builder for the [`getRoleAdmin`] function.
        pub fn getRoleAdmin(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRoleAdminCall, N> {
            self.call_builder(&getRoleAdminCall { role })
        }
        ///Creates a new call builder for the [`getVotes`] function.
        pub fn getVotes(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getVotesCall, N> {
            self.call_builder(&getVotesCall { account })
        }
        ///Creates a new call builder for the [`getVotingPower`] function.
        pub fn getVotingPower(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getVotingPowerCall, N> {
            self.call_builder(&getVotingPowerCall { account })
        }
        ///Creates a new call builder for the [`grantRole`] function.
        pub fn grantRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, grantRoleCall, N> {
            self.call_builder(&grantRoleCall { role, account })
        }
        ///Creates a new call builder for the [`hasRole`] function.
        pub fn hasRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, hasRoleCall, N> {
            self.call_builder(&hasRoleCall { role, account })
        }
        ///Creates a new call builder for the [`isBridgeAdded`] function.
        pub fn isBridgeAdded(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, isBridgeAddedCall, N> {
            self.call_builder(&isBridgeAddedCall { _0 })
        }
        ///Creates a new call builder for the [`isBridgeAuthorized`] function.
        pub fn isBridgeAuthorized(
            &self,
            bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, isBridgeAuthorizedCall, N> {
            self.call_builder(&isBridgeAuthorizedCall { bridge })
        }
        ///Creates a new call builder for the [`maxLockTimestamp`] function.
        pub fn maxLockTimestamp(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, maxLockTimestampCall, N> {
            self.call_builder(&maxLockTimestampCall {})
        }
        ///Creates a new call builder for the [`mint`] function.
        pub fn mint(
            &self,
            to: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, mintCall, N> {
            self.call_builder(&mintCall { to, amount })
        }
        ///Creates a new call builder for the [`name`] function.
        pub fn name(&self) -> alloy_contract::SolCallBuilder<T, &P, nameCall, N> {
            self.call_builder(&nameCall {})
        }
        ///Creates a new call builder for the [`nonces`] function.
        pub fn nonces(
            &self,
            owner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, noncesCall, N> {
            self.call_builder(&noncesCall { owner })
        }
        ///Creates a new call builder for the [`numCheckpoints`] function.
        pub fn numCheckpoints(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, numCheckpointsCall, N> {
            self.call_builder(&numCheckpointsCall { account })
        }
        ///Creates a new call builder for the [`permit`] function.
        pub fn permit(
            &self,
            owner: alloy::sol_types::private::Address,
            spender: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
            deadline: alloy::sol_types::private::primitives::aliases::U256,
            v: u8,
            r: alloy::sol_types::private::FixedBytes<32>,
            s: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, permitCall, N> {
            self.call_builder(
                &permitCall {
                    owner,
                    spender,
                    value,
                    deadline,
                    v,
                    r,
                    s,
                },
            )
        }
        ///Creates a new call builder for the [`removeBridge`] function.
        pub fn removeBridge(
            &self,
            bridge: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, removeBridgeCall, N> {
            self.call_builder(&removeBridgeCall { bridge })
        }
        ///Creates a new call builder for the [`renounceRole`] function.
        pub fn renounceRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            callerConfirmation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceRoleCall, N> {
            self.call_builder(
                &renounceRoleCall {
                    role,
                    callerConfirmation,
                },
            )
        }
        ///Creates a new call builder for the [`revokeRole`] function.
        pub fn revokeRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, revokeRoleCall, N> {
            self.call_builder(&revokeRoleCall { role, account })
        }
        ///Creates a new call builder for the [`setBridgeActive`] function.
        pub fn setBridgeActive(
            &self,
            bridge: alloy::sol_types::private::Address,
            isActive: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBridgeActiveCall, N> {
            self.call_builder(
                &setBridgeActiveCall {
                    bridge,
                    isActive,
                },
            )
        }
        ///Creates a new call builder for the [`setBridgeLimits`] function.
        pub fn setBridgeLimits(
            &self,
            bridge: alloy::sol_types::private::Address,
            dailyMintLimit: alloy::sol_types::private::primitives::aliases::U256,
            dailyBurnLimit: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBridgeLimitsCall, N> {
            self.call_builder(
                &setBridgeLimitsCall {
                    bridge,
                    dailyMintLimit,
                    dailyBurnLimit,
                },
            )
        }
        ///Creates a new call builder for the [`setUnlockTimestamp`] function.
        pub fn setUnlockTimestamp(
            &self,
            newUnlockTimestamp: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, setUnlockTimestampCall, N> {
            self.call_builder(
                &setUnlockTimestampCall {
                    newUnlockTimestamp,
                },
            )
        }
        ///Creates a new call builder for the [`supportsInterface`] function.
        pub fn supportsInterface(
            &self,
            interfaceId: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<T, &P, supportsInterfaceCall, N> {
            self.call_builder(
                &supportsInterfaceCall {
                    interfaceId,
                },
            )
        }
        ///Creates a new call builder for the [`symbol`] function.
        pub fn symbol(&self) -> alloy_contract::SolCallBuilder<T, &P, symbolCall, N> {
            self.call_builder(&symbolCall {})
        }
        ///Creates a new call builder for the [`totalSupply`] function.
        pub fn totalSupply(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, totalSupplyCall, N> {
            self.call_builder(&totalSupplyCall {})
        }
        ///Creates a new call builder for the [`transfer`] function.
        pub fn transfer(
            &self,
            to: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferCall, N> {
            self.call_builder(&transferCall { to, value })
        }
        ///Creates a new call builder for the [`transferFrom`] function.
        pub fn transferFrom(
            &self,
            from: alloy::sol_types::private::Address,
            to: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferFromCall, N> {
            self.call_builder(
                &transferFromCall {
                    from,
                    to,
                    value,
                },
            )
        }
        ///Creates a new call builder for the [`transfersLocked`] function.
        pub fn transfersLocked(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, transfersLockedCall, N> {
            self.call_builder(&transfersLockedCall {})
        }
        ///Creates a new call builder for the [`unlockTimestamp`] function.
        pub fn unlockTimestamp(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, unlockTimestampCall, N> {
            self.call_builder(&unlockTimestampCall {})
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SyndicateTokenCrosschainInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`Approval`] event.
        pub fn Approval_filter(&self) -> alloy_contract::Event<T, &P, Approval, N> {
            self.event_filter::<Approval>()
        }
        ///Creates a new event filter for the [`BridgeActiveStatusChanged`] event.
        pub fn BridgeActiveStatusChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeActiveStatusChanged, N> {
            self.event_filter::<BridgeActiveStatusChanged>()
        }
        ///Creates a new event filter for the [`BridgeAdded`] event.
        pub fn BridgeAdded_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeAdded, N> {
            self.event_filter::<BridgeAdded>()
        }
        ///Creates a new event filter for the [`BridgeLimitsSet`] event.
        pub fn BridgeLimitsSet_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeLimitsSet, N> {
            self.event_filter::<BridgeLimitsSet>()
        }
        ///Creates a new event filter for the [`BridgeRemoved`] event.
        pub fn BridgeRemoved_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BridgeRemoved, N> {
            self.event_filter::<BridgeRemoved>()
        }
        ///Creates a new event filter for the [`CrosschainBurn`] event.
        pub fn CrosschainBurn_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, CrosschainBurn, N> {
            self.event_filter::<CrosschainBurn>()
        }
        ///Creates a new event filter for the [`CrosschainMint`] event.
        pub fn CrosschainMint_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, CrosschainMint, N> {
            self.event_filter::<CrosschainMint>()
        }
        ///Creates a new event filter for the [`DelegateChanged`] event.
        pub fn DelegateChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, DelegateChanged, N> {
            self.event_filter::<DelegateChanged>()
        }
        ///Creates a new event filter for the [`DelegateVotesChanged`] event.
        pub fn DelegateVotesChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, DelegateVotesChanged, N> {
            self.event_filter::<DelegateVotesChanged>()
        }
        ///Creates a new event filter for the [`EIP712DomainChanged`] event.
        pub fn EIP712DomainChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EIP712DomainChanged, N> {
            self.event_filter::<EIP712DomainChanged>()
        }
        ///Creates a new event filter for the [`RoleAdminChanged`] event.
        pub fn RoleAdminChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleAdminChanged, N> {
            self.event_filter::<RoleAdminChanged>()
        }
        ///Creates a new event filter for the [`RoleGranted`] event.
        pub fn RoleGranted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleGranted, N> {
            self.event_filter::<RoleGranted>()
        }
        ///Creates a new event filter for the [`RoleRevoked`] event.
        pub fn RoleRevoked_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleRevoked, N> {
            self.event_filter::<RoleRevoked>()
        }
        ///Creates a new event filter for the [`TokensBurnedByManager`] event.
        pub fn TokensBurnedByManager_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TokensBurnedByManager, N> {
            self.event_filter::<TokensBurnedByManager>()
        }
        ///Creates a new event filter for the [`Transfer`] event.
        pub fn Transfer_filter(&self) -> alloy_contract::Event<T, &P, Transfer, N> {
            self.event_filter::<Transfer>()
        }
        ///Creates a new event filter for the [`UnlockTimestampUpdated`] event.
        pub fn UnlockTimestampUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, UnlockTimestampUpdated, N> {
            self.event_filter::<UnlockTimestampUpdated>()
        }
    }
}
