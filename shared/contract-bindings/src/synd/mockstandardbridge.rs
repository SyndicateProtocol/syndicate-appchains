/**

Generated by the following Solidity interface...
```solidity
interface MockStandardBridge {
    struct BridgeCall {
        address localToken;
        address remoteToken;
        address to;
        uint256 amount;
        uint32 minGasLimit;
        bytes extraData;
    }

    function bridgeCalls(uint256) external view returns (address localToken, address remoteToken, address to, uint256 amount, uint32 minGasLimit, bytes memory extraData);
    function bridgeERC20To(address _localToken, address _remoteToken, address _to, uint256 _amount, uint32 _minGasLimit, bytes memory _extraData) external;
    function getBridgeCallCount() external view returns (uint256);
    function getLastBridgeCall() external view returns (BridgeCall memory);
    function setShouldRevert(bool _shouldRevert) external;
    function shouldRevert() external view returns (bool);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "function",
    "name": "bridgeCalls",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "localToken",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "remoteToken",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "minGasLimit",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "extraData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgeERC20To",
    "inputs": [
      {
        "name": "_localToken",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_remoteToken",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_amount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "_minGasLimit",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "_extraData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getBridgeCallCount",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getLastBridgeCall",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct MockStandardBridge.BridgeCall",
        "components": [
          {
            "name": "localToken",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "remoteToken",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "to",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "minGasLimit",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "extraData",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setShouldRevert",
    "inputs": [
      {
        "name": "_shouldRevert",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "shouldRevert",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod MockStandardBridge {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x608060405234601c57600e6020565b61116f61002b823961116f90f35b6026565b60405190565b5f80fdfe60806040526004361015610013575b6108b4565b61001d5f3561007c565b8063246ce2c6146100775780633ae0d32114610072578063540abf731461006d5780636813d78714610068578063d3072d82146100635763d71f00a10361000e57610878565b610538565b6104a4565b610424565b610221565b6101ca565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f91031261009a57565b61008c565b60018060a01b031690565b6100b39061009f565b90565b6100bf906100aa565b9052565b90565b6100cf906100c3565b9052565b63ffffffff1690565b6100e5906100d3565b9052565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b61012a61013360209361013893610121816100e9565b938480936100ed565b958691016100f6565b610101565b0190565b6101af9160a060c08201926101575f8201515f8501906100b6565b610169602082015160208501906100b6565b61017b604082015160408501906100b6565b61018d606082015160608501906100c6565b61019f608082015160808501906100dc565b01519060a081840391015261010b565b90565b6101c79160208201915f81840391015261013c565b90565b346101fa576101da366004610090565b6101f66101e5610b0e565b6101ed610082565b918291826101b2565b0390f35b610088565b610208906100c3565b9052565b919061021f905f602085019401906101ff565b565b3461025157610231366004610090565b61024d61023c610b71565b610244610082565b9182918261020c565b0390f35b610088565b5f80fd5b610263816100aa565b0361026a57565b5f80fd5b9050359061027b8261025a565b565b610286816100c3565b0361028d57565b5f80fd5b9050359061029e8261027d565b565b6102a9816100d3565b036102b057565b5f80fd5b905035906102c1826102a0565b565b5f80fd5b5f80fd5b634e487b7160e01b5f52604160045260245ffd5b906102e990610101565b810190811067ffffffffffffffff82111761030357604052565b6102cb565b9061031b610314610082565b92836102df565b565b67ffffffffffffffff811161033b57610337602091610101565b0190565b6102cb565b90825f939282370152565b9092919261036061035b8261031d565b610308565b9381855260208501908284011161037c5761037a92610340565b565b6102c7565b9080601f8301121561039f5781602061039c9335910161034b565b90565b6102c3565b9160c08383031261041a576103bb825f850161026e565b926103c9836020830161026e565b926103d7816040840161026e565b926103e58260608501610291565b926103f383608083016102b4565b9260a082013567ffffffffffffffff8111610415576104129201610381565b90565b610256565b61008c565b5f0190565b34610459576104436104373660046103a4565b94939093929192611093565b61044b610082565b806104558161041f565b0390f35b610088565b151590565b61046c8161045e565b0361047357565b5f80fd5b9050359061048482610463565b565b9060208282031261049f5761049c915f01610477565b90565b61008c565b346104d2576104bc6104b7366004610486565b611162565b6104c4610082565b806104ce8161041f565b0390f35b610088565b1c90565b60ff1690565b6104f19060086104f693026104d7565b6104db565b90565b9061050491546104e1565b90565b61051360015f906104f9565b90565b61051f9061045e565b9052565b9190610536905f60208501940190610516565b565b3461056857610548366004610090565b610564610553610507565b61055b610082565b91829182610523565b0390f35b610088565b9060208282031261058657610583915f01610291565b90565b61008c565b634e487b7160e01b5f52603260045260245ffd5b5490565b5f5260205f2090565b6105b58161059f565b8210156105cf576105c76006916105a3565b910201905f90565b61058b565b5f1c90565b60018060a01b031690565b6105f06105f5916105d4565b6105d9565b90565b61060290546105e4565b90565b90565b610614610619916105d4565b610605565b90565b6106269054610608565b90565b63ffffffff1690565b61063e610643916105d4565b610629565b90565b6106509054610632565b90565b634e487b7160e01b5f52602260045260245ffd5b9060016002830492168015610687575b602083101461068257565b610653565b91607f1691610677565b5f5260205f2090565b905f92918054906106b46106ad83610667565b80946100ed565b916001811690815f1461070b57506001146106cf575b505050565b6106dc9192939450610691565b915f925b8184106106f357505001905f80806106ca565b600181602092959395548486015201910192906106e0565b92949550505060ff19168252151560200201905f80806106ca565b906107309161069a565b90565b9061075361074c92610743610082565b93848092610726565b03836102df565b565b5f906107608261059f565b8110156107c057610770916105ac565b509061077d5f83016105f8565b9161078a600182016105f8565b91610797600283016105f8565b916107a46003820161061c565b916107bd60056107b660048501610646565b9301610733565b90565b5f80fd5b6107cd906100aa565b9052565b6107da906100d3565b9052565b60209181520190565b61080661080f602093610814936107fd816100e9565b938480936107de565b958691016100f6565b610101565b0190565b92610875969461085461085e9261084a6108689699959961084060c08a019b5f8b01906107c4565b60208901906107c4565b60408701906107c4565b60608501906101ff565b60808301906107d1565b60a08184039101526107e7565b90565b346108af576108ab61089361088e36600461056d565b610755565b926108a2969496929192610082565b96879687610818565b0390f35b610088565b5f80fd5b6108c260c0610308565b90565b5f90565b5f90565b5f90565b606090565b6108de6108b8565b9060208080808080876108ef6108c5565b8152016108fa6108c5565b8152016109056108c5565b8152016109106108c9565b81520161091b6108cd565b8152016109266108d1565b81525050565b6109346108d6565b90565b90565b90565b61095161094c61095692610937565b61093a565b6100c3565b90565b60209181520190565b5f7f4e6f206272696467652063616c6c730000000000000000000000000000000000910152565b610996600f602092610959565b61099f81610962565b0190565b6109b89060208101905f818303910152610989565b90565b156109c257565b6109ca610082565b62461bcd60e51b8152806109e0600482016109a3565b0390fd5b90565b6109fb6109f6610a00926109e4565b61093a565b6100c3565b90565b634e487b7160e01b5f52601160045260245ffd5b610a26610a2c919392936100c3565b926100c3565b8203918211610a3757565b610a03565b90610a46906100aa565b9052565b90610a54906100c3565b9052565b90610a62906100d3565b9052565b52565b90610b00610af76005610a7a6108b8565b94610a91610a895f83016105f8565b5f8801610a3c565b610aa9610aa0600183016105f8565b60208801610a3c565b610ac1610ab8600283016105f8565b60408801610a3c565b610ad9610ad06003830161061c565b60608801610a4a565b610af1610ae860048301610646565b60808801610a58565b01610733565b60a08401610a66565b565b610b0b90610a69565b90565b610b1661092c565b50610b3b610b235f61059f565b610b35610b2f5f61093d565b916100c3565b116109bb565b610b6a610b645f610b5e610b4e5f61059f565b610b5860016109e7565b90610a17565b906105ac565b50610b02565b90565b5f90565b610b79610b6d565b50610b835f61059f565b90565b610b92610b97916105d4565b6104db565b90565b610ba49054610b86565b90565b5f7f4272696467652072657665727465640000000000000000000000000000000000910152565b610bdb600f602092610959565b610be481610ba7565b0190565b610bfd9060208101905f818303910152610bce565b90565b15610c0757565b610c0f610082565b62461bcd60e51b815280610c2560048201610be8565b0390fd5b90565b610c3660c0610308565b90565b5f5260205f2090565b5490565b610c4f81610c42565b821015610c6957610c61600691610c39565b910201905f90565b61058b565b634e487b7160e01b5f525f60045260245ffd5b610c8b90516100aa565b90565b5f1b90565b90610ca460018060a01b0391610c8e565b9181191691161790565b610cc2610cbd610cc79261009f565b61093a565b61009f565b90565b610cd390610cae565b90565b610cdf90610cca565b90565b90565b90610cfa610cf5610d0192610cd6565b610ce2565b8254610c93565b9055565b610d0f90516100c3565b90565b90610d1e5f1991610c8e565b9181191691161790565b610d3c610d37610d41926100c3565b61093a565b6100c3565b90565b90565b90610d5c610d57610d6392610d28565b610d44565b8254610d12565b9055565b610d7190516100d3565b90565b90610d8363ffffffff91610c8e565b9181191691161790565b610da1610d9c610da6926100d3565b61093a565b6100d3565b90565b90565b90610dc1610dbc610dc892610d8d565b610da9565b8254610d74565b9055565b5190565b601f602091010490565b1b90565b91906008610df9910291610df35f1984610dda565b92610dda565b9181191691161790565b9190610e19610e14610e2193610d28565b610d44565b908354610dde565b9055565b610e3791610e31610b6d565b91610e03565b565b5b818110610e45575050565b80610e525f600193610e25565b01610e3a565b9190601f8111610e68575b505050565b610e74610e9993610691565b906020610e8084610dd0565b83019310610ea1575b610e9290610dd0565b0190610e39565b5f8080610e63565b9150610e9281929050610e89565b90610ebf905f19906008026104d7565b191690565b81610ece91610eaf565b906002021790565b90610ee0816100e9565b9067ffffffffffffffff8211610fa057610f0482610efe8554610667565b85610e58565b602090601f8311600114610f3857918091610f27935f92610f2c575b5050610ec4565b90555b565b90915001515f80610f20565b601f19831691610f4785610691565b925f5b818110610f8857509160029391856001969410610f6e575b50505002019055610f2a565b610f7e910151601f841690610eaf565b90555f8080610f62565b91936020600181928787015181550195019201610f4a565b6102cb565b90610faf91610ed6565b565b9061104060a0600561104694610fd45f8201610fce5f8801610c81565b90610ce5565b610fed60018201610fe760208801610c81565b90610ce5565b6110066002820161100060408801610c81565b90610ce5565b61101f6003820161101960608801610d05565b90610d47565b6110386004820161103260808801610d67565b90610dac565b019201610dcc565b90610fa5565b565b91906110595761105791610fb1565b565b610c6e565b908154916801000000000000000083101561108e578261108691600161108c95018155610c46565b90611048565b565b6102cb565b9261111b956111045f966110fb61110d946110f2611116986110c66110c16110bb6001610b9a565b1561045e565b610c00565b6110e96110d28d610c29565b9b9991939597996110e1610c2c565b9d8e01610a3c565b60208c01610a3c565b60408a01610a3c565b60608801610a4a565b60808601610a58565b60a08401610a66565b61105e565b565b9061112960ff91610c8e565b9181191691161790565b61113c9061045e565b90565b90565b9061115761115261115e92611133565b61113f565b825461111d565b9055565b61116d906001611142565b56
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4`\x1CW`\x0E` V[a\x11oa\0+\x829a\x11o\x90\xF3[`&V[`@Q\x90V[_\x80\xFD\xFE`\x80`@R`\x046\x10\x15a\0\x13W[a\x08\xB4V[a\0\x1D_5a\0|V[\x80c$l\xE2\xC6\x14a\0wW\x80c:\xE0\xD3!\x14a\0rW\x80cT\n\xBFs\x14a\0mW\x80ch\x13\xD7\x87\x14a\0hW\x80c\xD3\x07-\x82\x14a\0cWc\xD7\x1F\0\xA1\x03a\0\x0EWa\x08xV[a\x058V[a\x04\xA4V[a\x04$V[a\x02!V[a\x01\xCAV[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x91\x03\x12a\0\x9AWV[a\0\x8CV[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\0\xB3\x90a\0\x9FV[\x90V[a\0\xBF\x90a\0\xAAV[\x90RV[\x90V[a\0\xCF\x90a\0\xC3V[\x90RV[c\xFF\xFF\xFF\xFF\x16\x90V[a\0\xE5\x90a\0\xD3V[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[`\x1F\x80\x19\x91\x01\x16\x90V[a\x01*a\x013` \x93a\x018\x93a\x01!\x81a\0\xE9V[\x93\x84\x80\x93a\0\xEDV[\x95\x86\x91\x01a\0\xF6V[a\x01\x01V[\x01\x90V[a\x01\xAF\x91`\xA0`\xC0\x82\x01\x92a\x01W_\x82\x01Q_\x85\x01\x90a\0\xB6V[a\x01i` \x82\x01Q` \x85\x01\x90a\0\xB6V[a\x01{`@\x82\x01Q`@\x85\x01\x90a\0\xB6V[a\x01\x8D``\x82\x01Q``\x85\x01\x90a\0\xC6V[a\x01\x9F`\x80\x82\x01Q`\x80\x85\x01\x90a\0\xDCV[\x01Q\x90`\xA0\x81\x84\x03\x91\x01Ra\x01\x0BV[\x90V[a\x01\xC7\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x01<V[\x90V[4a\x01\xFAWa\x01\xDA6`\x04a\0\x90V[a\x01\xF6a\x01\xE5a\x0B\x0EV[a\x01\xEDa\0\x82V[\x91\x82\x91\x82a\x01\xB2V[\x03\x90\xF3[a\0\x88V[a\x02\x08\x90a\0\xC3V[\x90RV[\x91\x90a\x02\x1F\x90_` \x85\x01\x94\x01\x90a\x01\xFFV[V[4a\x02QWa\x0216`\x04a\0\x90V[a\x02Ma\x02<a\x0BqV[a\x02Da\0\x82V[\x91\x82\x91\x82a\x02\x0CV[\x03\x90\xF3[a\0\x88V[_\x80\xFD[a\x02c\x81a\0\xAAV[\x03a\x02jWV[_\x80\xFD[\x90P5\x90a\x02{\x82a\x02ZV[V[a\x02\x86\x81a\0\xC3V[\x03a\x02\x8DWV[_\x80\xFD[\x90P5\x90a\x02\x9E\x82a\x02}V[V[a\x02\xA9\x81a\0\xD3V[\x03a\x02\xB0WV[_\x80\xFD[\x90P5\x90a\x02\xC1\x82a\x02\xA0V[V[_\x80\xFD[_\x80\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x02\xE9\x90a\x01\x01V[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x03\x03W`@RV[a\x02\xCBV[\x90a\x03\x1Ba\x03\x14a\0\x82V[\x92\x83a\x02\xDFV[V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x03;Wa\x037` \x91a\x01\x01V[\x01\x90V[a\x02\xCBV[\x90\x82_\x93\x92\x827\x01RV[\x90\x92\x91\x92a\x03`a\x03[\x82a\x03\x1DV[a\x03\x08V[\x93\x81\x85R` \x85\x01\x90\x82\x84\x01\x11a\x03|Wa\x03z\x92a\x03@V[V[a\x02\xC7V[\x90\x80`\x1F\x83\x01\x12\x15a\x03\x9FW\x81` a\x03\x9C\x935\x91\x01a\x03KV[\x90V[a\x02\xC3V[\x91`\xC0\x83\x83\x03\x12a\x04\x1AWa\x03\xBB\x82_\x85\x01a\x02nV[\x92a\x03\xC9\x83` \x83\x01a\x02nV[\x92a\x03\xD7\x81`@\x84\x01a\x02nV[\x92a\x03\xE5\x82``\x85\x01a\x02\x91V[\x92a\x03\xF3\x83`\x80\x83\x01a\x02\xB4V[\x92`\xA0\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04\x15Wa\x04\x12\x92\x01a\x03\x81V[\x90V[a\x02VV[a\0\x8CV[_\x01\x90V[4a\x04YWa\x04Ca\x0476`\x04a\x03\xA4V[\x94\x93\x90\x93\x92\x91\x92a\x10\x93V[a\x04Ka\0\x82V[\x80a\x04U\x81a\x04\x1FV[\x03\x90\xF3[a\0\x88V[\x15\x15\x90V[a\x04l\x81a\x04^V[\x03a\x04sWV[_\x80\xFD[\x90P5\x90a\x04\x84\x82a\x04cV[V[\x90` \x82\x82\x03\x12a\x04\x9FWa\x04\x9C\x91_\x01a\x04wV[\x90V[a\0\x8CV[4a\x04\xD2Wa\x04\xBCa\x04\xB76`\x04a\x04\x86V[a\x11bV[a\x04\xC4a\0\x82V[\x80a\x04\xCE\x81a\x04\x1FV[\x03\x90\xF3[a\0\x88V[\x1C\x90V[`\xFF\x16\x90V[a\x04\xF1\x90`\x08a\x04\xF6\x93\x02a\x04\xD7V[a\x04\xDBV[\x90V[\x90a\x05\x04\x91Ta\x04\xE1V[\x90V[a\x05\x13`\x01_\x90a\x04\xF9V[\x90V[a\x05\x1F\x90a\x04^V[\x90RV[\x91\x90a\x056\x90_` \x85\x01\x94\x01\x90a\x05\x16V[V[4a\x05hWa\x05H6`\x04a\0\x90V[a\x05da\x05Sa\x05\x07V[a\x05[a\0\x82V[\x91\x82\x91\x82a\x05#V[\x03\x90\xF3[a\0\x88V[\x90` \x82\x82\x03\x12a\x05\x86Wa\x05\x83\x91_\x01a\x02\x91V[\x90V[a\0\x8CV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[T\x90V[_R` _ \x90V[a\x05\xB5\x81a\x05\x9FV[\x82\x10\x15a\x05\xCFWa\x05\xC7`\x06\x91a\x05\xA3V[\x91\x02\x01\x90_\x90V[a\x05\x8BV[_\x1C\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x05\xF0a\x05\xF5\x91a\x05\xD4V[a\x05\xD9V[\x90V[a\x06\x02\x90Ta\x05\xE4V[\x90V[\x90V[a\x06\x14a\x06\x19\x91a\x05\xD4V[a\x06\x05V[\x90V[a\x06&\x90Ta\x06\x08V[\x90V[c\xFF\xFF\xFF\xFF\x16\x90V[a\x06>a\x06C\x91a\x05\xD4V[a\x06)V[\x90V[a\x06P\x90Ta\x062V[\x90V[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x06\x87W[` \x83\x10\x14a\x06\x82WV[a\x06SV[\x91`\x7F\x16\x91a\x06wV[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x06\xB4a\x06\xAD\x83a\x06gV[\x80\x94a\0\xEDV[\x91`\x01\x81\x16\x90\x81_\x14a\x07\x0BWP`\x01\x14a\x06\xCFW[PPPV[a\x06\xDC\x91\x92\x93\x94Pa\x06\x91V[\x91_\x92[\x81\x84\x10a\x06\xF3WPP\x01\x90_\x80\x80a\x06\xCAV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x06\xE0V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x06\xCAV[\x90a\x070\x91a\x06\x9AV[\x90V[\x90a\x07Sa\x07L\x92a\x07Ca\0\x82V[\x93\x84\x80\x92a\x07&V[\x03\x83a\x02\xDFV[V[_\x90a\x07`\x82a\x05\x9FV[\x81\x10\x15a\x07\xC0Wa\x07p\x91a\x05\xACV[P\x90a\x07}_\x83\x01a\x05\xF8V[\x91a\x07\x8A`\x01\x82\x01a\x05\xF8V[\x91a\x07\x97`\x02\x83\x01a\x05\xF8V[\x91a\x07\xA4`\x03\x82\x01a\x06\x1CV[\x91a\x07\xBD`\x05a\x07\xB6`\x04\x85\x01a\x06FV[\x93\x01a\x073V[\x90V[_\x80\xFD[a\x07\xCD\x90a\0\xAAV[\x90RV[a\x07\xDA\x90a\0\xD3V[\x90RV[` \x91\x81R\x01\x90V[a\x08\x06a\x08\x0F` \x93a\x08\x14\x93a\x07\xFD\x81a\0\xE9V[\x93\x84\x80\x93a\x07\xDEV[\x95\x86\x91\x01a\0\xF6V[a\x01\x01V[\x01\x90V[\x92a\x08u\x96\x94a\x08Ta\x08^\x92a\x08Ja\x08h\x96\x99\x95\x99a\x08@`\xC0\x8A\x01\x9B_\x8B\x01\x90a\x07\xC4V[` \x89\x01\x90a\x07\xC4V[`@\x87\x01\x90a\x07\xC4V[``\x85\x01\x90a\x01\xFFV[`\x80\x83\x01\x90a\x07\xD1V[`\xA0\x81\x84\x03\x91\x01Ra\x07\xE7V[\x90V[4a\x08\xAFWa\x08\xABa\x08\x93a\x08\x8E6`\x04a\x05mV[a\x07UV[\x92a\x08\xA2\x96\x94\x96\x92\x91\x92a\0\x82V[\x96\x87\x96\x87a\x08\x18V[\x03\x90\xF3[a\0\x88V[_\x80\xFD[a\x08\xC2`\xC0a\x03\x08V[\x90V[_\x90V[_\x90V[_\x90V[``\x90V[a\x08\xDEa\x08\xB8V[\x90` \x80\x80\x80\x80\x80\x87a\x08\xEFa\x08\xC5V[\x81R\x01a\x08\xFAa\x08\xC5V[\x81R\x01a\t\x05a\x08\xC5V[\x81R\x01a\t\x10a\x08\xC9V[\x81R\x01a\t\x1Ba\x08\xCDV[\x81R\x01a\t&a\x08\xD1V[\x81RPPV[a\t4a\x08\xD6V[\x90V[\x90V[\x90V[a\tQa\tLa\tV\x92a\t7V[a\t:V[a\0\xC3V[\x90V[` \x91\x81R\x01\x90V[_\x7FNo bridge calls\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\t\x96`\x0F` \x92a\tYV[a\t\x9F\x81a\tbV[\x01\x90V[a\t\xB8\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\t\x89V[\x90V[\x15a\t\xC2WV[a\t\xCAa\0\x82V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\t\xE0`\x04\x82\x01a\t\xA3V[\x03\x90\xFD[\x90V[a\t\xFBa\t\xF6a\n\0\x92a\t\xE4V[a\t:V[a\0\xC3V[\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\n&a\n,\x91\x93\x92\x93a\0\xC3V[\x92a\0\xC3V[\x82\x03\x91\x82\x11a\n7WV[a\n\x03V[\x90a\nF\x90a\0\xAAV[\x90RV[\x90a\nT\x90a\0\xC3V[\x90RV[\x90a\nb\x90a\0\xD3V[\x90RV[RV[\x90a\x0B\0a\n\xF7`\x05a\nza\x08\xB8V[\x94a\n\x91a\n\x89_\x83\x01a\x05\xF8V[_\x88\x01a\n<V[a\n\xA9a\n\xA0`\x01\x83\x01a\x05\xF8V[` \x88\x01a\n<V[a\n\xC1a\n\xB8`\x02\x83\x01a\x05\xF8V[`@\x88\x01a\n<V[a\n\xD9a\n\xD0`\x03\x83\x01a\x06\x1CV[``\x88\x01a\nJV[a\n\xF1a\n\xE8`\x04\x83\x01a\x06FV[`\x80\x88\x01a\nXV[\x01a\x073V[`\xA0\x84\x01a\nfV[V[a\x0B\x0B\x90a\niV[\x90V[a\x0B\x16a\t,V[Pa\x0B;a\x0B#_a\x05\x9FV[a\x0B5a\x0B/_a\t=V[\x91a\0\xC3V[\x11a\t\xBBV[a\x0Bja\x0Bd_a\x0B^a\x0BN_a\x05\x9FV[a\x0BX`\x01a\t\xE7V[\x90a\n\x17V[\x90a\x05\xACV[Pa\x0B\x02V[\x90V[_\x90V[a\x0Bya\x0BmV[Pa\x0B\x83_a\x05\x9FV[\x90V[a\x0B\x92a\x0B\x97\x91a\x05\xD4V[a\x04\xDBV[\x90V[a\x0B\xA4\x90Ta\x0B\x86V[\x90V[_\x7FBridge reverted\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x0B\xDB`\x0F` \x92a\tYV[a\x0B\xE4\x81a\x0B\xA7V[\x01\x90V[a\x0B\xFD\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x0B\xCEV[\x90V[\x15a\x0C\x07WV[a\x0C\x0Fa\0\x82V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x0C%`\x04\x82\x01a\x0B\xE8V[\x03\x90\xFD[\x90V[a\x0C6`\xC0a\x03\x08V[\x90V[_R` _ \x90V[T\x90V[a\x0CO\x81a\x0CBV[\x82\x10\x15a\x0CiWa\x0Ca`\x06\x91a\x0C9V[\x91\x02\x01\x90_\x90V[a\x05\x8BV[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[a\x0C\x8B\x90Qa\0\xAAV[\x90V[_\x1B\x90V[\x90a\x0C\xA4`\x01\x80`\xA0\x1B\x03\x91a\x0C\x8EV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x0C\xC2a\x0C\xBDa\x0C\xC7\x92a\0\x9FV[a\t:V[a\0\x9FV[\x90V[a\x0C\xD3\x90a\x0C\xAEV[\x90V[a\x0C\xDF\x90a\x0C\xCAV[\x90V[\x90V[\x90a\x0C\xFAa\x0C\xF5a\r\x01\x92a\x0C\xD6V[a\x0C\xE2V[\x82Ta\x0C\x93V[\x90UV[a\r\x0F\x90Qa\0\xC3V[\x90V[\x90a\r\x1E_\x19\x91a\x0C\x8EV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\r<a\r7a\rA\x92a\0\xC3V[a\t:V[a\0\xC3V[\x90V[\x90V[\x90a\r\\a\rWa\rc\x92a\r(V[a\rDV[\x82Ta\r\x12V[\x90UV[a\rq\x90Qa\0\xD3V[\x90V[\x90a\r\x83c\xFF\xFF\xFF\xFF\x91a\x0C\x8EV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\r\xA1a\r\x9Ca\r\xA6\x92a\0\xD3V[a\t:V[a\0\xD3V[\x90V[\x90V[\x90a\r\xC1a\r\xBCa\r\xC8\x92a\r\x8DV[a\r\xA9V[\x82Ta\rtV[\x90UV[Q\x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a\r\xF9\x91\x02\x91a\r\xF3_\x19\x84a\r\xDAV[\x92a\r\xDAV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x91\x90a\x0E\x19a\x0E\x14a\x0E!\x93a\r(V[a\rDV[\x90\x83Ta\r\xDEV[\x90UV[a\x0E7\x91a\x0E1a\x0BmV[\x91a\x0E\x03V[V[[\x81\x81\x10a\x0EEWPPV[\x80a\x0ER_`\x01\x93a\x0E%V[\x01a\x0E:V[\x91\x90`\x1F\x81\x11a\x0EhW[PPPV[a\x0Eta\x0E\x99\x93a\x06\x91V[\x90` a\x0E\x80\x84a\r\xD0V[\x83\x01\x93\x10a\x0E\xA1W[a\x0E\x92\x90a\r\xD0V[\x01\x90a\x0E9V[_\x80\x80a\x0EcV[\x91Pa\x0E\x92\x81\x92\x90Pa\x0E\x89V[\x90a\x0E\xBF\x90_\x19\x90`\x08\x02a\x04\xD7V[\x19\x16\x90V[\x81a\x0E\xCE\x91a\x0E\xAFV[\x90`\x02\x02\x17\x90V[\x90a\x0E\xE0\x81a\0\xE9V[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x0F\xA0Wa\x0F\x04\x82a\x0E\xFE\x85Ta\x06gV[\x85a\x0EXV[` \x90`\x1F\x83\x11`\x01\x14a\x0F8W\x91\x80\x91a\x0F'\x93_\x92a\x0F,W[PPa\x0E\xC4V[\x90U[V[\x90\x91P\x01Q_\x80a\x0F V[`\x1F\x19\x83\x16\x91a\x0FG\x85a\x06\x91V[\x92_[\x81\x81\x10a\x0F\x88WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\x0FnW[PPP\x02\x01\x90Ua\x0F*V[a\x0F~\x91\x01Q`\x1F\x84\x16\x90a\x0E\xAFV[\x90U_\x80\x80a\x0FbV[\x91\x93` `\x01\x81\x92\x87\x87\x01Q\x81U\x01\x95\x01\x92\x01a\x0FJV[a\x02\xCBV[\x90a\x0F\xAF\x91a\x0E\xD6V[V[\x90a\x10@`\xA0`\x05a\x10F\x94a\x0F\xD4_\x82\x01a\x0F\xCE_\x88\x01a\x0C\x81V[\x90a\x0C\xE5V[a\x0F\xED`\x01\x82\x01a\x0F\xE7` \x88\x01a\x0C\x81V[\x90a\x0C\xE5V[a\x10\x06`\x02\x82\x01a\x10\0`@\x88\x01a\x0C\x81V[\x90a\x0C\xE5V[a\x10\x1F`\x03\x82\x01a\x10\x19``\x88\x01a\r\x05V[\x90a\rGV[a\x108`\x04\x82\x01a\x102`\x80\x88\x01a\rgV[\x90a\r\xACV[\x01\x92\x01a\r\xCCV[\x90a\x0F\xA5V[V[\x91\x90a\x10YWa\x10W\x91a\x0F\xB1V[V[a\x0CnV[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15a\x10\x8EW\x82a\x10\x86\x91`\x01a\x10\x8C\x95\x01\x81Ua\x0CFV[\x90a\x10HV[V[a\x02\xCBV[\x92a\x11\x1B\x95a\x11\x04_\x96a\x10\xFBa\x11\r\x94a\x10\xF2a\x11\x16\x98a\x10\xC6a\x10\xC1a\x10\xBB`\x01a\x0B\x9AV[\x15a\x04^V[a\x0C\0V[a\x10\xE9a\x10\xD2\x8Da\x0C)V[\x9B\x99\x91\x93\x95\x97\x99a\x10\xE1a\x0C,V[\x9D\x8E\x01a\n<V[` \x8C\x01a\n<V[`@\x8A\x01a\n<V[``\x88\x01a\nJV[`\x80\x86\x01a\nXV[`\xA0\x84\x01a\nfV[a\x10^V[V[\x90a\x11)`\xFF\x91a\x0C\x8EV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x11<\x90a\x04^V[\x90V[\x90V[\x90a\x11Wa\x11Ra\x11^\x92a\x113V[a\x11?V[\x82Ta\x11\x1DV[\x90UV[a\x11m\x90`\x01a\x11BV[V",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x60806040526004361015610013575b6108b4565b61001d5f3561007c565b8063246ce2c6146100775780633ae0d32114610072578063540abf731461006d5780636813d78714610068578063d3072d82146100635763d71f00a10361000e57610878565b610538565b6104a4565b610424565b610221565b6101ca565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f91031261009a57565b61008c565b60018060a01b031690565b6100b39061009f565b90565b6100bf906100aa565b9052565b90565b6100cf906100c3565b9052565b63ffffffff1690565b6100e5906100d3565b9052565b5190565b60209181520190565b90825f9392825e0152565b601f801991011690565b61012a61013360209361013893610121816100e9565b938480936100ed565b958691016100f6565b610101565b0190565b6101af9160a060c08201926101575f8201515f8501906100b6565b610169602082015160208501906100b6565b61017b604082015160408501906100b6565b61018d606082015160608501906100c6565b61019f608082015160808501906100dc565b01519060a081840391015261010b565b90565b6101c79160208201915f81840391015261013c565b90565b346101fa576101da366004610090565b6101f66101e5610b0e565b6101ed610082565b918291826101b2565b0390f35b610088565b610208906100c3565b9052565b919061021f905f602085019401906101ff565b565b3461025157610231366004610090565b61024d61023c610b71565b610244610082565b9182918261020c565b0390f35b610088565b5f80fd5b610263816100aa565b0361026a57565b5f80fd5b9050359061027b8261025a565b565b610286816100c3565b0361028d57565b5f80fd5b9050359061029e8261027d565b565b6102a9816100d3565b036102b057565b5f80fd5b905035906102c1826102a0565b565b5f80fd5b5f80fd5b634e487b7160e01b5f52604160045260245ffd5b906102e990610101565b810190811067ffffffffffffffff82111761030357604052565b6102cb565b9061031b610314610082565b92836102df565b565b67ffffffffffffffff811161033b57610337602091610101565b0190565b6102cb565b90825f939282370152565b9092919261036061035b8261031d565b610308565b9381855260208501908284011161037c5761037a92610340565b565b6102c7565b9080601f8301121561039f5781602061039c9335910161034b565b90565b6102c3565b9160c08383031261041a576103bb825f850161026e565b926103c9836020830161026e565b926103d7816040840161026e565b926103e58260608501610291565b926103f383608083016102b4565b9260a082013567ffffffffffffffff8111610415576104129201610381565b90565b610256565b61008c565b5f0190565b34610459576104436104373660046103a4565b94939093929192611093565b61044b610082565b806104558161041f565b0390f35b610088565b151590565b61046c8161045e565b0361047357565b5f80fd5b9050359061048482610463565b565b9060208282031261049f5761049c915f01610477565b90565b61008c565b346104d2576104bc6104b7366004610486565b611162565b6104c4610082565b806104ce8161041f565b0390f35b610088565b1c90565b60ff1690565b6104f19060086104f693026104d7565b6104db565b90565b9061050491546104e1565b90565b61051360015f906104f9565b90565b61051f9061045e565b9052565b9190610536905f60208501940190610516565b565b3461056857610548366004610090565b610564610553610507565b61055b610082565b91829182610523565b0390f35b610088565b9060208282031261058657610583915f01610291565b90565b61008c565b634e487b7160e01b5f52603260045260245ffd5b5490565b5f5260205f2090565b6105b58161059f565b8210156105cf576105c76006916105a3565b910201905f90565b61058b565b5f1c90565b60018060a01b031690565b6105f06105f5916105d4565b6105d9565b90565b61060290546105e4565b90565b90565b610614610619916105d4565b610605565b90565b6106269054610608565b90565b63ffffffff1690565b61063e610643916105d4565b610629565b90565b6106509054610632565b90565b634e487b7160e01b5f52602260045260245ffd5b9060016002830492168015610687575b602083101461068257565b610653565b91607f1691610677565b5f5260205f2090565b905f92918054906106b46106ad83610667565b80946100ed565b916001811690815f1461070b57506001146106cf575b505050565b6106dc9192939450610691565b915f925b8184106106f357505001905f80806106ca565b600181602092959395548486015201910192906106e0565b92949550505060ff19168252151560200201905f80806106ca565b906107309161069a565b90565b9061075361074c92610743610082565b93848092610726565b03836102df565b565b5f906107608261059f565b8110156107c057610770916105ac565b509061077d5f83016105f8565b9161078a600182016105f8565b91610797600283016105f8565b916107a46003820161061c565b916107bd60056107b660048501610646565b9301610733565b90565b5f80fd5b6107cd906100aa565b9052565b6107da906100d3565b9052565b60209181520190565b61080661080f602093610814936107fd816100e9565b938480936107de565b958691016100f6565b610101565b0190565b92610875969461085461085e9261084a6108689699959961084060c08a019b5f8b01906107c4565b60208901906107c4565b60408701906107c4565b60608501906101ff565b60808301906107d1565b60a08184039101526107e7565b90565b346108af576108ab61089361088e36600461056d565b610755565b926108a2969496929192610082565b96879687610818565b0390f35b610088565b5f80fd5b6108c260c0610308565b90565b5f90565b5f90565b5f90565b606090565b6108de6108b8565b9060208080808080876108ef6108c5565b8152016108fa6108c5565b8152016109056108c5565b8152016109106108c9565b81520161091b6108cd565b8152016109266108d1565b81525050565b6109346108d6565b90565b90565b90565b61095161094c61095692610937565b61093a565b6100c3565b90565b60209181520190565b5f7f4e6f206272696467652063616c6c730000000000000000000000000000000000910152565b610996600f602092610959565b61099f81610962565b0190565b6109b89060208101905f818303910152610989565b90565b156109c257565b6109ca610082565b62461bcd60e51b8152806109e0600482016109a3565b0390fd5b90565b6109fb6109f6610a00926109e4565b61093a565b6100c3565b90565b634e487b7160e01b5f52601160045260245ffd5b610a26610a2c919392936100c3565b926100c3565b8203918211610a3757565b610a03565b90610a46906100aa565b9052565b90610a54906100c3565b9052565b90610a62906100d3565b9052565b52565b90610b00610af76005610a7a6108b8565b94610a91610a895f83016105f8565b5f8801610a3c565b610aa9610aa0600183016105f8565b60208801610a3c565b610ac1610ab8600283016105f8565b60408801610a3c565b610ad9610ad06003830161061c565b60608801610a4a565b610af1610ae860048301610646565b60808801610a58565b01610733565b60a08401610a66565b565b610b0b90610a69565b90565b610b1661092c565b50610b3b610b235f61059f565b610b35610b2f5f61093d565b916100c3565b116109bb565b610b6a610b645f610b5e610b4e5f61059f565b610b5860016109e7565b90610a17565b906105ac565b50610b02565b90565b5f90565b610b79610b6d565b50610b835f61059f565b90565b610b92610b97916105d4565b6104db565b90565b610ba49054610b86565b90565b5f7f4272696467652072657665727465640000000000000000000000000000000000910152565b610bdb600f602092610959565b610be481610ba7565b0190565b610bfd9060208101905f818303910152610bce565b90565b15610c0757565b610c0f610082565b62461bcd60e51b815280610c2560048201610be8565b0390fd5b90565b610c3660c0610308565b90565b5f5260205f2090565b5490565b610c4f81610c42565b821015610c6957610c61600691610c39565b910201905f90565b61058b565b634e487b7160e01b5f525f60045260245ffd5b610c8b90516100aa565b90565b5f1b90565b90610ca460018060a01b0391610c8e565b9181191691161790565b610cc2610cbd610cc79261009f565b61093a565b61009f565b90565b610cd390610cae565b90565b610cdf90610cca565b90565b90565b90610cfa610cf5610d0192610cd6565b610ce2565b8254610c93565b9055565b610d0f90516100c3565b90565b90610d1e5f1991610c8e565b9181191691161790565b610d3c610d37610d41926100c3565b61093a565b6100c3565b90565b90565b90610d5c610d57610d6392610d28565b610d44565b8254610d12565b9055565b610d7190516100d3565b90565b90610d8363ffffffff91610c8e565b9181191691161790565b610da1610d9c610da6926100d3565b61093a565b6100d3565b90565b90565b90610dc1610dbc610dc892610d8d565b610da9565b8254610d74565b9055565b5190565b601f602091010490565b1b90565b91906008610df9910291610df35f1984610dda565b92610dda565b9181191691161790565b9190610e19610e14610e2193610d28565b610d44565b908354610dde565b9055565b610e3791610e31610b6d565b91610e03565b565b5b818110610e45575050565b80610e525f600193610e25565b01610e3a565b9190601f8111610e68575b505050565b610e74610e9993610691565b906020610e8084610dd0565b83019310610ea1575b610e9290610dd0565b0190610e39565b5f8080610e63565b9150610e9281929050610e89565b90610ebf905f19906008026104d7565b191690565b81610ece91610eaf565b906002021790565b90610ee0816100e9565b9067ffffffffffffffff8211610fa057610f0482610efe8554610667565b85610e58565b602090601f8311600114610f3857918091610f27935f92610f2c575b5050610ec4565b90555b565b90915001515f80610f20565b601f19831691610f4785610691565b925f5b818110610f8857509160029391856001969410610f6e575b50505002019055610f2a565b610f7e910151601f841690610eaf565b90555f8080610f62565b91936020600181928787015181550195019201610f4a565b6102cb565b90610faf91610ed6565b565b9061104060a0600561104694610fd45f8201610fce5f8801610c81565b90610ce5565b610fed60018201610fe760208801610c81565b90610ce5565b6110066002820161100060408801610c81565b90610ce5565b61101f6003820161101960608801610d05565b90610d47565b6110386004820161103260808801610d67565b90610dac565b019201610dcc565b90610fa5565b565b91906110595761105791610fb1565b565b610c6e565b908154916801000000000000000083101561108e578261108691600161108c95018155610c46565b90611048565b565b6102cb565b9261111b956111045f966110fb61110d946110f2611116986110c66110c16110bb6001610b9a565b1561045e565b610c00565b6110e96110d28d610c29565b9b9991939597996110e1610c2c565b9d8e01610a3c565b60208c01610a3c565b60408a01610a3c565b60608801610a4a565b60808601610a58565b60a08401610a66565b61105e565b565b9061112960ff91610c8e565b9181191691161790565b61113c9061045e565b90565b90565b9061115761115261115e92611133565b61113f565b825461111d565b9055565b61116d906001611142565b56
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x13W[a\x08\xB4V[a\0\x1D_5a\0|V[\x80c$l\xE2\xC6\x14a\0wW\x80c:\xE0\xD3!\x14a\0rW\x80cT\n\xBFs\x14a\0mW\x80ch\x13\xD7\x87\x14a\0hW\x80c\xD3\x07-\x82\x14a\0cWc\xD7\x1F\0\xA1\x03a\0\x0EWa\x08xV[a\x058V[a\x04\xA4V[a\x04$V[a\x02!V[a\x01\xCAV[`\xE0\x1C\x90V[`@Q\x90V[_\x80\xFD[_\x80\xFD[_\x91\x03\x12a\0\x9AWV[a\0\x8CV[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\0\xB3\x90a\0\x9FV[\x90V[a\0\xBF\x90a\0\xAAV[\x90RV[\x90V[a\0\xCF\x90a\0\xC3V[\x90RV[c\xFF\xFF\xFF\xFF\x16\x90V[a\0\xE5\x90a\0\xD3V[\x90RV[Q\x90V[` \x91\x81R\x01\x90V[\x90\x82_\x93\x92\x82^\x01RV[`\x1F\x80\x19\x91\x01\x16\x90V[a\x01*a\x013` \x93a\x018\x93a\x01!\x81a\0\xE9V[\x93\x84\x80\x93a\0\xEDV[\x95\x86\x91\x01a\0\xF6V[a\x01\x01V[\x01\x90V[a\x01\xAF\x91`\xA0`\xC0\x82\x01\x92a\x01W_\x82\x01Q_\x85\x01\x90a\0\xB6V[a\x01i` \x82\x01Q` \x85\x01\x90a\0\xB6V[a\x01{`@\x82\x01Q`@\x85\x01\x90a\0\xB6V[a\x01\x8D``\x82\x01Q``\x85\x01\x90a\0\xC6V[a\x01\x9F`\x80\x82\x01Q`\x80\x85\x01\x90a\0\xDCV[\x01Q\x90`\xA0\x81\x84\x03\x91\x01Ra\x01\x0BV[\x90V[a\x01\xC7\x91` \x82\x01\x91_\x81\x84\x03\x91\x01Ra\x01<V[\x90V[4a\x01\xFAWa\x01\xDA6`\x04a\0\x90V[a\x01\xF6a\x01\xE5a\x0B\x0EV[a\x01\xEDa\0\x82V[\x91\x82\x91\x82a\x01\xB2V[\x03\x90\xF3[a\0\x88V[a\x02\x08\x90a\0\xC3V[\x90RV[\x91\x90a\x02\x1F\x90_` \x85\x01\x94\x01\x90a\x01\xFFV[V[4a\x02QWa\x0216`\x04a\0\x90V[a\x02Ma\x02<a\x0BqV[a\x02Da\0\x82V[\x91\x82\x91\x82a\x02\x0CV[\x03\x90\xF3[a\0\x88V[_\x80\xFD[a\x02c\x81a\0\xAAV[\x03a\x02jWV[_\x80\xFD[\x90P5\x90a\x02{\x82a\x02ZV[V[a\x02\x86\x81a\0\xC3V[\x03a\x02\x8DWV[_\x80\xFD[\x90P5\x90a\x02\x9E\x82a\x02}V[V[a\x02\xA9\x81a\0\xD3V[\x03a\x02\xB0WV[_\x80\xFD[\x90P5\x90a\x02\xC1\x82a\x02\xA0V[V[_\x80\xFD[_\x80\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90a\x02\xE9\x90a\x01\x01V[\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x03\x03W`@RV[a\x02\xCBV[\x90a\x03\x1Ba\x03\x14a\0\x82V[\x92\x83a\x02\xDFV[V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x03;Wa\x037` \x91a\x01\x01V[\x01\x90V[a\x02\xCBV[\x90\x82_\x93\x92\x827\x01RV[\x90\x92\x91\x92a\x03`a\x03[\x82a\x03\x1DV[a\x03\x08V[\x93\x81\x85R` \x85\x01\x90\x82\x84\x01\x11a\x03|Wa\x03z\x92a\x03@V[V[a\x02\xC7V[\x90\x80`\x1F\x83\x01\x12\x15a\x03\x9FW\x81` a\x03\x9C\x935\x91\x01a\x03KV[\x90V[a\x02\xC3V[\x91`\xC0\x83\x83\x03\x12a\x04\x1AWa\x03\xBB\x82_\x85\x01a\x02nV[\x92a\x03\xC9\x83` \x83\x01a\x02nV[\x92a\x03\xD7\x81`@\x84\x01a\x02nV[\x92a\x03\xE5\x82``\x85\x01a\x02\x91V[\x92a\x03\xF3\x83`\x80\x83\x01a\x02\xB4V[\x92`\xA0\x82\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x04\x15Wa\x04\x12\x92\x01a\x03\x81V[\x90V[a\x02VV[a\0\x8CV[_\x01\x90V[4a\x04YWa\x04Ca\x0476`\x04a\x03\xA4V[\x94\x93\x90\x93\x92\x91\x92a\x10\x93V[a\x04Ka\0\x82V[\x80a\x04U\x81a\x04\x1FV[\x03\x90\xF3[a\0\x88V[\x15\x15\x90V[a\x04l\x81a\x04^V[\x03a\x04sWV[_\x80\xFD[\x90P5\x90a\x04\x84\x82a\x04cV[V[\x90` \x82\x82\x03\x12a\x04\x9FWa\x04\x9C\x91_\x01a\x04wV[\x90V[a\0\x8CV[4a\x04\xD2Wa\x04\xBCa\x04\xB76`\x04a\x04\x86V[a\x11bV[a\x04\xC4a\0\x82V[\x80a\x04\xCE\x81a\x04\x1FV[\x03\x90\xF3[a\0\x88V[\x1C\x90V[`\xFF\x16\x90V[a\x04\xF1\x90`\x08a\x04\xF6\x93\x02a\x04\xD7V[a\x04\xDBV[\x90V[\x90a\x05\x04\x91Ta\x04\xE1V[\x90V[a\x05\x13`\x01_\x90a\x04\xF9V[\x90V[a\x05\x1F\x90a\x04^V[\x90RV[\x91\x90a\x056\x90_` \x85\x01\x94\x01\x90a\x05\x16V[V[4a\x05hWa\x05H6`\x04a\0\x90V[a\x05da\x05Sa\x05\x07V[a\x05[a\0\x82V[\x91\x82\x91\x82a\x05#V[\x03\x90\xF3[a\0\x88V[\x90` \x82\x82\x03\x12a\x05\x86Wa\x05\x83\x91_\x01a\x02\x91V[\x90V[a\0\x8CV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[T\x90V[_R` _ \x90V[a\x05\xB5\x81a\x05\x9FV[\x82\x10\x15a\x05\xCFWa\x05\xC7`\x06\x91a\x05\xA3V[\x91\x02\x01\x90_\x90V[a\x05\x8BV[_\x1C\x90V[`\x01\x80`\xA0\x1B\x03\x16\x90V[a\x05\xF0a\x05\xF5\x91a\x05\xD4V[a\x05\xD9V[\x90V[a\x06\x02\x90Ta\x05\xE4V[\x90V[\x90V[a\x06\x14a\x06\x19\x91a\x05\xD4V[a\x06\x05V[\x90V[a\x06&\x90Ta\x06\x08V[\x90V[c\xFF\xFF\xFF\xFF\x16\x90V[a\x06>a\x06C\x91a\x05\xD4V[a\x06)V[\x90V[a\x06P\x90Ta\x062V[\x90V[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x90`\x01`\x02\x83\x04\x92\x16\x80\x15a\x06\x87W[` \x83\x10\x14a\x06\x82WV[a\x06SV[\x91`\x7F\x16\x91a\x06wV[_R` _ \x90V[\x90_\x92\x91\x80T\x90a\x06\xB4a\x06\xAD\x83a\x06gV[\x80\x94a\0\xEDV[\x91`\x01\x81\x16\x90\x81_\x14a\x07\x0BWP`\x01\x14a\x06\xCFW[PPPV[a\x06\xDC\x91\x92\x93\x94Pa\x06\x91V[\x91_\x92[\x81\x84\x10a\x06\xF3WPP\x01\x90_\x80\x80a\x06\xCAV[`\x01\x81` \x92\x95\x93\x95T\x84\x86\x01R\x01\x91\x01\x92\x90a\x06\xE0V[\x92\x94\x95PPP`\xFF\x19\x16\x82R\x15\x15` \x02\x01\x90_\x80\x80a\x06\xCAV[\x90a\x070\x91a\x06\x9AV[\x90V[\x90a\x07Sa\x07L\x92a\x07Ca\0\x82V[\x93\x84\x80\x92a\x07&V[\x03\x83a\x02\xDFV[V[_\x90a\x07`\x82a\x05\x9FV[\x81\x10\x15a\x07\xC0Wa\x07p\x91a\x05\xACV[P\x90a\x07}_\x83\x01a\x05\xF8V[\x91a\x07\x8A`\x01\x82\x01a\x05\xF8V[\x91a\x07\x97`\x02\x83\x01a\x05\xF8V[\x91a\x07\xA4`\x03\x82\x01a\x06\x1CV[\x91a\x07\xBD`\x05a\x07\xB6`\x04\x85\x01a\x06FV[\x93\x01a\x073V[\x90V[_\x80\xFD[a\x07\xCD\x90a\0\xAAV[\x90RV[a\x07\xDA\x90a\0\xD3V[\x90RV[` \x91\x81R\x01\x90V[a\x08\x06a\x08\x0F` \x93a\x08\x14\x93a\x07\xFD\x81a\0\xE9V[\x93\x84\x80\x93a\x07\xDEV[\x95\x86\x91\x01a\0\xF6V[a\x01\x01V[\x01\x90V[\x92a\x08u\x96\x94a\x08Ta\x08^\x92a\x08Ja\x08h\x96\x99\x95\x99a\x08@`\xC0\x8A\x01\x9B_\x8B\x01\x90a\x07\xC4V[` \x89\x01\x90a\x07\xC4V[`@\x87\x01\x90a\x07\xC4V[``\x85\x01\x90a\x01\xFFV[`\x80\x83\x01\x90a\x07\xD1V[`\xA0\x81\x84\x03\x91\x01Ra\x07\xE7V[\x90V[4a\x08\xAFWa\x08\xABa\x08\x93a\x08\x8E6`\x04a\x05mV[a\x07UV[\x92a\x08\xA2\x96\x94\x96\x92\x91\x92a\0\x82V[\x96\x87\x96\x87a\x08\x18V[\x03\x90\xF3[a\0\x88V[_\x80\xFD[a\x08\xC2`\xC0a\x03\x08V[\x90V[_\x90V[_\x90V[_\x90V[``\x90V[a\x08\xDEa\x08\xB8V[\x90` \x80\x80\x80\x80\x80\x87a\x08\xEFa\x08\xC5V[\x81R\x01a\x08\xFAa\x08\xC5V[\x81R\x01a\t\x05a\x08\xC5V[\x81R\x01a\t\x10a\x08\xC9V[\x81R\x01a\t\x1Ba\x08\xCDV[\x81R\x01a\t&a\x08\xD1V[\x81RPPV[a\t4a\x08\xD6V[\x90V[\x90V[\x90V[a\tQa\tLa\tV\x92a\t7V[a\t:V[a\0\xC3V[\x90V[` \x91\x81R\x01\x90V[_\x7FNo bridge calls\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\t\x96`\x0F` \x92a\tYV[a\t\x9F\x81a\tbV[\x01\x90V[a\t\xB8\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\t\x89V[\x90V[\x15a\t\xC2WV[a\t\xCAa\0\x82V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\t\xE0`\x04\x82\x01a\t\xA3V[\x03\x90\xFD[\x90V[a\t\xFBa\t\xF6a\n\0\x92a\t\xE4V[a\t:V[a\0\xC3V[\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[a\n&a\n,\x91\x93\x92\x93a\0\xC3V[\x92a\0\xC3V[\x82\x03\x91\x82\x11a\n7WV[a\n\x03V[\x90a\nF\x90a\0\xAAV[\x90RV[\x90a\nT\x90a\0\xC3V[\x90RV[\x90a\nb\x90a\0\xD3V[\x90RV[RV[\x90a\x0B\0a\n\xF7`\x05a\nza\x08\xB8V[\x94a\n\x91a\n\x89_\x83\x01a\x05\xF8V[_\x88\x01a\n<V[a\n\xA9a\n\xA0`\x01\x83\x01a\x05\xF8V[` \x88\x01a\n<V[a\n\xC1a\n\xB8`\x02\x83\x01a\x05\xF8V[`@\x88\x01a\n<V[a\n\xD9a\n\xD0`\x03\x83\x01a\x06\x1CV[``\x88\x01a\nJV[a\n\xF1a\n\xE8`\x04\x83\x01a\x06FV[`\x80\x88\x01a\nXV[\x01a\x073V[`\xA0\x84\x01a\nfV[V[a\x0B\x0B\x90a\niV[\x90V[a\x0B\x16a\t,V[Pa\x0B;a\x0B#_a\x05\x9FV[a\x0B5a\x0B/_a\t=V[\x91a\0\xC3V[\x11a\t\xBBV[a\x0Bja\x0Bd_a\x0B^a\x0BN_a\x05\x9FV[a\x0BX`\x01a\t\xE7V[\x90a\n\x17V[\x90a\x05\xACV[Pa\x0B\x02V[\x90V[_\x90V[a\x0Bya\x0BmV[Pa\x0B\x83_a\x05\x9FV[\x90V[a\x0B\x92a\x0B\x97\x91a\x05\xD4V[a\x04\xDBV[\x90V[a\x0B\xA4\x90Ta\x0B\x86V[\x90V[_\x7FBridge reverted\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01RV[a\x0B\xDB`\x0F` \x92a\tYV[a\x0B\xE4\x81a\x0B\xA7V[\x01\x90V[a\x0B\xFD\x90` \x81\x01\x90_\x81\x83\x03\x91\x01Ra\x0B\xCEV[\x90V[\x15a\x0C\x07WV[a\x0C\x0Fa\0\x82V[bF\x1B\xCD`\xE5\x1B\x81R\x80a\x0C%`\x04\x82\x01a\x0B\xE8V[\x03\x90\xFD[\x90V[a\x0C6`\xC0a\x03\x08V[\x90V[_R` _ \x90V[T\x90V[a\x0CO\x81a\x0CBV[\x82\x10\x15a\x0CiWa\x0Ca`\x06\x91a\x0C9V[\x91\x02\x01\x90_\x90V[a\x05\x8BV[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[a\x0C\x8B\x90Qa\0\xAAV[\x90V[_\x1B\x90V[\x90a\x0C\xA4`\x01\x80`\xA0\x1B\x03\x91a\x0C\x8EV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x0C\xC2a\x0C\xBDa\x0C\xC7\x92a\0\x9FV[a\t:V[a\0\x9FV[\x90V[a\x0C\xD3\x90a\x0C\xAEV[\x90V[a\x0C\xDF\x90a\x0C\xCAV[\x90V[\x90V[\x90a\x0C\xFAa\x0C\xF5a\r\x01\x92a\x0C\xD6V[a\x0C\xE2V[\x82Ta\x0C\x93V[\x90UV[a\r\x0F\x90Qa\0\xC3V[\x90V[\x90a\r\x1E_\x19\x91a\x0C\x8EV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\r<a\r7a\rA\x92a\0\xC3V[a\t:V[a\0\xC3V[\x90V[\x90V[\x90a\r\\a\rWa\rc\x92a\r(V[a\rDV[\x82Ta\r\x12V[\x90UV[a\rq\x90Qa\0\xD3V[\x90V[\x90a\r\x83c\xFF\xFF\xFF\xFF\x91a\x0C\x8EV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\r\xA1a\r\x9Ca\r\xA6\x92a\0\xD3V[a\t:V[a\0\xD3V[\x90V[\x90V[\x90a\r\xC1a\r\xBCa\r\xC8\x92a\r\x8DV[a\r\xA9V[\x82Ta\rtV[\x90UV[Q\x90V[`\x1F` \x91\x01\x04\x90V[\x1B\x90V[\x91\x90`\x08a\r\xF9\x91\x02\x91a\r\xF3_\x19\x84a\r\xDAV[\x92a\r\xDAV[\x91\x81\x19\x16\x91\x16\x17\x90V[\x91\x90a\x0E\x19a\x0E\x14a\x0E!\x93a\r(V[a\rDV[\x90\x83Ta\r\xDEV[\x90UV[a\x0E7\x91a\x0E1a\x0BmV[\x91a\x0E\x03V[V[[\x81\x81\x10a\x0EEWPPV[\x80a\x0ER_`\x01\x93a\x0E%V[\x01a\x0E:V[\x91\x90`\x1F\x81\x11a\x0EhW[PPPV[a\x0Eta\x0E\x99\x93a\x06\x91V[\x90` a\x0E\x80\x84a\r\xD0V[\x83\x01\x93\x10a\x0E\xA1W[a\x0E\x92\x90a\r\xD0V[\x01\x90a\x0E9V[_\x80\x80a\x0EcV[\x91Pa\x0E\x92\x81\x92\x90Pa\x0E\x89V[\x90a\x0E\xBF\x90_\x19\x90`\x08\x02a\x04\xD7V[\x19\x16\x90V[\x81a\x0E\xCE\x91a\x0E\xAFV[\x90`\x02\x02\x17\x90V[\x90a\x0E\xE0\x81a\0\xE9V[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x0F\xA0Wa\x0F\x04\x82a\x0E\xFE\x85Ta\x06gV[\x85a\x0EXV[` \x90`\x1F\x83\x11`\x01\x14a\x0F8W\x91\x80\x91a\x0F'\x93_\x92a\x0F,W[PPa\x0E\xC4V[\x90U[V[\x90\x91P\x01Q_\x80a\x0F V[`\x1F\x19\x83\x16\x91a\x0FG\x85a\x06\x91V[\x92_[\x81\x81\x10a\x0F\x88WP\x91`\x02\x93\x91\x85`\x01\x96\x94\x10a\x0FnW[PPP\x02\x01\x90Ua\x0F*V[a\x0F~\x91\x01Q`\x1F\x84\x16\x90a\x0E\xAFV[\x90U_\x80\x80a\x0FbV[\x91\x93` `\x01\x81\x92\x87\x87\x01Q\x81U\x01\x95\x01\x92\x01a\x0FJV[a\x02\xCBV[\x90a\x0F\xAF\x91a\x0E\xD6V[V[\x90a\x10@`\xA0`\x05a\x10F\x94a\x0F\xD4_\x82\x01a\x0F\xCE_\x88\x01a\x0C\x81V[\x90a\x0C\xE5V[a\x0F\xED`\x01\x82\x01a\x0F\xE7` \x88\x01a\x0C\x81V[\x90a\x0C\xE5V[a\x10\x06`\x02\x82\x01a\x10\0`@\x88\x01a\x0C\x81V[\x90a\x0C\xE5V[a\x10\x1F`\x03\x82\x01a\x10\x19``\x88\x01a\r\x05V[\x90a\rGV[a\x108`\x04\x82\x01a\x102`\x80\x88\x01a\rgV[\x90a\r\xACV[\x01\x92\x01a\r\xCCV[\x90a\x0F\xA5V[V[\x91\x90a\x10YWa\x10W\x91a\x0F\xB1V[V[a\x0CnV[\x90\x81T\x91h\x01\0\0\0\0\0\0\0\0\x83\x10\x15a\x10\x8EW\x82a\x10\x86\x91`\x01a\x10\x8C\x95\x01\x81Ua\x0CFV[\x90a\x10HV[V[a\x02\xCBV[\x92a\x11\x1B\x95a\x11\x04_\x96a\x10\xFBa\x11\r\x94a\x10\xF2a\x11\x16\x98a\x10\xC6a\x10\xC1a\x10\xBB`\x01a\x0B\x9AV[\x15a\x04^V[a\x0C\0V[a\x10\xE9a\x10\xD2\x8Da\x0C)V[\x9B\x99\x91\x93\x95\x97\x99a\x10\xE1a\x0C,V[\x9D\x8E\x01a\n<V[` \x8C\x01a\n<V[`@\x8A\x01a\n<V[``\x88\x01a\nJV[`\x80\x86\x01a\nXV[`\xA0\x84\x01a\nfV[a\x10^V[V[\x90a\x11)`\xFF\x91a\x0C\x8EV[\x91\x81\x19\x16\x91\x16\x17\x90V[a\x11<\x90a\x04^V[\x90V[\x90V[\x90a\x11Wa\x11Ra\x11^\x92a\x113V[a\x11?V[\x82Ta\x11\x1DV[\x90UV[a\x11m\x90`\x01a\x11BV[V",
    );
    /**```solidity
struct BridgeCall { address localToken; address remoteToken; address to; uint256 amount; uint32 minGasLimit; bytes extraData; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BridgeCall {
        #[allow(missing_docs)]
        pub localToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub remoteToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub minGasLimit: u32,
        #[allow(missing_docs)]
        pub extraData: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<32>,
            alloy::sol_types::sol_data::Bytes,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            u32,
            alloy::sol_types::private::Bytes,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BridgeCall> for UnderlyingRustTuple<'_> {
            fn from(value: BridgeCall) -> Self {
                (
                    value.localToken,
                    value.remoteToken,
                    value.to,
                    value.amount,
                    value.minGasLimit,
                    value.extraData,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BridgeCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    localToken: tuple.0,
                    remoteToken: tuple.1,
                    to: tuple.2,
                    amount: tuple.3,
                    minGasLimit: tuple.4,
                    extraData: tuple.5,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for BridgeCall {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for BridgeCall {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.localToken,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.remoteToken,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.minGasLimit),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.extraData,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BridgeCall {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for BridgeCall {
            const NAME: &'static str = "BridgeCall";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "BridgeCall(address localToken,address remoteToken,address to,uint256 amount,uint32 minGasLimit,bytes extraData)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.localToken,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.remoteToken,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.to,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.minGasLimit)
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.extraData,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BridgeCall {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.localToken,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.remoteToken,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.to,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.minGasLimit,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.extraData,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.localToken,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.remoteToken,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.to,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.minGasLimit,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.extraData,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Function with signature `bridgeCalls(uint256)` and selector `0xd71f00a1`.
```solidity
function bridgeCalls(uint256) external view returns (address localToken, address remoteToken, address to, uint256 amount, uint32 minGasLimit, bytes memory extraData);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeCallsCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`bridgeCalls(uint256)`](bridgeCallsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeCallsReturn {
        #[allow(missing_docs)]
        pub localToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub remoteToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub minGasLimit: u32,
        #[allow(missing_docs)]
        pub extraData: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeCallsCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeCallsCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeCallsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                u32,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeCallsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeCallsReturn) -> Self {
                    (
                        value.localToken,
                        value.remoteToken,
                        value.to,
                        value.amount,
                        value.minGasLimit,
                        value.extraData,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeCallsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        localToken: tuple.0,
                        remoteToken: tuple.1,
                        to: tuple.2,
                        amount: tuple.3,
                        minGasLimit: tuple.4,
                        extraData: tuple.5,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeCallsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeCallsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeCalls(uint256)";
            const SELECTOR: [u8; 4] = [215u8, 31u8, 0u8, 161u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridgeERC20To(address,address,address,uint256,uint32,bytes)` and selector `0x540abf73`.
```solidity
function bridgeERC20To(address _localToken, address _remoteToken, address _to, uint256 _amount, uint32 _minGasLimit, bytes memory _extraData) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeERC20ToCall {
        #[allow(missing_docs)]
        pub _localToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _remoteToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _minGasLimit: u32,
        #[allow(missing_docs)]
        pub _extraData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`bridgeERC20To(address,address,address,uint256,uint32,bytes)`](bridgeERC20ToCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeERC20ToReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                u32,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeERC20ToCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeERC20ToCall) -> Self {
                    (
                        value._localToken,
                        value._remoteToken,
                        value._to,
                        value._amount,
                        value._minGasLimit,
                        value._extraData,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeERC20ToCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _localToken: tuple.0,
                        _remoteToken: tuple.1,
                        _to: tuple.2,
                        _amount: tuple.3,
                        _minGasLimit: tuple.4,
                        _extraData: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeERC20ToReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeERC20ToReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeERC20ToReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeERC20ToCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeERC20ToReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgeERC20To(address,address,address,uint256,uint32,bytes)";
            const SELECTOR: [u8; 4] = [84u8, 10u8, 191u8, 115u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._localToken,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._remoteToken,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._amount),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._minGasLimit),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self._extraData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBridgeCallCount()` and selector `0x3ae0d321`.
```solidity
function getBridgeCallCount() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeCallCountCall {}
    ///Container type for the return parameters of the [`getBridgeCallCount()`](getBridgeCallCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBridgeCallCountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeCallCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeCallCountCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeCallCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBridgeCallCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBridgeCallCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBridgeCallCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBridgeCallCountCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBridgeCallCountReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBridgeCallCount()";
            const SELECTOR: [u8; 4] = [58u8, 224u8, 211u8, 33u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getLastBridgeCall()` and selector `0x246ce2c6`.
```solidity
function getLastBridgeCall() external view returns (BridgeCall memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getLastBridgeCallCall {}
    ///Container type for the return parameters of the [`getLastBridgeCall()`](getLastBridgeCallCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getLastBridgeCallReturn {
        #[allow(missing_docs)]
        pub _0: <BridgeCall as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLastBridgeCallCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getLastBridgeCallCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getLastBridgeCallCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BridgeCall,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <BridgeCall as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLastBridgeCallReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getLastBridgeCallReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getLastBridgeCallReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getLastBridgeCallCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getLastBridgeCallReturn;
            type ReturnTuple<'a> = (BridgeCall,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getLastBridgeCall()";
            const SELECTOR: [u8; 4] = [36u8, 108u8, 226u8, 198u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setShouldRevert(bool)` and selector `0x6813d787`.
```solidity
function setShouldRevert(bool _shouldRevert) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setShouldRevertCall {
        #[allow(missing_docs)]
        pub _shouldRevert: bool,
    }
    ///Container type for the return parameters of the [`setShouldRevert(bool)`](setShouldRevertCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setShouldRevertReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setShouldRevertCall> for UnderlyingRustTuple<'_> {
                fn from(value: setShouldRevertCall) -> Self {
                    (value._shouldRevert,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setShouldRevertCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _shouldRevert: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setShouldRevertReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setShouldRevertReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setShouldRevertReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setShouldRevertCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bool,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setShouldRevertReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setShouldRevert(bool)";
            const SELECTOR: [u8; 4] = [104u8, 19u8, 215u8, 135u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self._shouldRevert,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `shouldRevert()` and selector `0xd3072d82`.
```solidity
function shouldRevert() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct shouldRevertCall {}
    ///Container type for the return parameters of the [`shouldRevert()`](shouldRevertCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct shouldRevertReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<shouldRevertCall> for UnderlyingRustTuple<'_> {
                fn from(value: shouldRevertCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for shouldRevertCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<shouldRevertReturn> for UnderlyingRustTuple<'_> {
                fn from(value: shouldRevertReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for shouldRevertReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for shouldRevertCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = shouldRevertReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "shouldRevert()";
            const SELECTOR: [u8; 4] = [211u8, 7u8, 45u8, 130u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`MockStandardBridge`](self) function calls.
    pub enum MockStandardBridgeCalls {
        #[allow(missing_docs)]
        bridgeCalls(bridgeCallsCall),
        #[allow(missing_docs)]
        bridgeERC20To(bridgeERC20ToCall),
        #[allow(missing_docs)]
        getBridgeCallCount(getBridgeCallCountCall),
        #[allow(missing_docs)]
        getLastBridgeCall(getLastBridgeCallCall),
        #[allow(missing_docs)]
        setShouldRevert(setShouldRevertCall),
        #[allow(missing_docs)]
        shouldRevert(shouldRevertCall),
    }
    #[automatically_derived]
    impl MockStandardBridgeCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [36u8, 108u8, 226u8, 198u8],
            [58u8, 224u8, 211u8, 33u8],
            [84u8, 10u8, 191u8, 115u8],
            [104u8, 19u8, 215u8, 135u8],
            [211u8, 7u8, 45u8, 130u8],
            [215u8, 31u8, 0u8, 161u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for MockStandardBridgeCalls {
        const NAME: &'static str = "MockStandardBridgeCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 6usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::bridgeCalls(_) => {
                    <bridgeCallsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgeERC20To(_) => {
                    <bridgeERC20ToCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBridgeCallCount(_) => {
                    <getBridgeCallCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getLastBridgeCall(_) => {
                    <getLastBridgeCallCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setShouldRevert(_) => {
                    <setShouldRevertCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::shouldRevert(_) => {
                    <shouldRevertCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<MockStandardBridgeCalls>] = &[
                {
                    fn getLastBridgeCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockStandardBridgeCalls> {
                        <getLastBridgeCallCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockStandardBridgeCalls::getLastBridgeCall)
                    }
                    getLastBridgeCall
                },
                {
                    fn getBridgeCallCount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockStandardBridgeCalls> {
                        <getBridgeCallCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockStandardBridgeCalls::getBridgeCallCount)
                    }
                    getBridgeCallCount
                },
                {
                    fn bridgeERC20To(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockStandardBridgeCalls> {
                        <bridgeERC20ToCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockStandardBridgeCalls::bridgeERC20To)
                    }
                    bridgeERC20To
                },
                {
                    fn setShouldRevert(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockStandardBridgeCalls> {
                        <setShouldRevertCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockStandardBridgeCalls::setShouldRevert)
                    }
                    setShouldRevert
                },
                {
                    fn shouldRevert(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockStandardBridgeCalls> {
                        <shouldRevertCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockStandardBridgeCalls::shouldRevert)
                    }
                    shouldRevert
                },
                {
                    fn bridgeCalls(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MockStandardBridgeCalls> {
                        <bridgeCallsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MockStandardBridgeCalls::bridgeCalls)
                    }
                    bridgeCalls
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::bridgeCalls(inner) => {
                    <bridgeCallsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bridgeERC20To(inner) => {
                    <bridgeERC20ToCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBridgeCallCount(inner) => {
                    <getBridgeCallCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getLastBridgeCall(inner) => {
                    <getLastBridgeCallCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setShouldRevert(inner) => {
                    <setShouldRevertCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::shouldRevert(inner) => {
                    <shouldRevertCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::bridgeCalls(inner) => {
                    <bridgeCallsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgeERC20To(inner) => {
                    <bridgeERC20ToCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBridgeCallCount(inner) => {
                    <getBridgeCallCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getLastBridgeCall(inner) => {
                    <getLastBridgeCallCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setShouldRevert(inner) => {
                    <setShouldRevertCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::shouldRevert(inner) => {
                    <shouldRevertCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`MockStandardBridge`](self) contract instance.

See the [wrapper's documentation](`MockStandardBridgeInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> MockStandardBridgeInstance<T, P, N> {
        MockStandardBridgeInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<MockStandardBridgeInstance<T, P, N>>,
    > {
        MockStandardBridgeInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        MockStandardBridgeInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`MockStandardBridge`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`MockStandardBridge`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct MockStandardBridgeInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for MockStandardBridgeInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("MockStandardBridgeInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MockStandardBridgeInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`MockStandardBridge`](self) contract instance.

See the [wrapper's documentation](`MockStandardBridgeInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<MockStandardBridgeInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> MockStandardBridgeInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> MockStandardBridgeInstance<T, P, N> {
            MockStandardBridgeInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MockStandardBridgeInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`bridgeCalls`] function.
        pub fn bridgeCalls(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeCallsCall, N> {
            self.call_builder(&bridgeCallsCall { _0 })
        }
        ///Creates a new call builder for the [`bridgeERC20To`] function.
        pub fn bridgeERC20To(
            &self,
            _localToken: alloy::sol_types::private::Address,
            _remoteToken: alloy::sol_types::private::Address,
            _to: alloy::sol_types::private::Address,
            _amount: alloy::sol_types::private::primitives::aliases::U256,
            _minGasLimit: u32,
            _extraData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, bridgeERC20ToCall, N> {
            self.call_builder(
                &bridgeERC20ToCall {
                    _localToken,
                    _remoteToken,
                    _to,
                    _amount,
                    _minGasLimit,
                    _extraData,
                },
            )
        }
        ///Creates a new call builder for the [`getBridgeCallCount`] function.
        pub fn getBridgeCallCount(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBridgeCallCountCall, N> {
            self.call_builder(&getBridgeCallCountCall {})
        }
        ///Creates a new call builder for the [`getLastBridgeCall`] function.
        pub fn getLastBridgeCall(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getLastBridgeCallCall, N> {
            self.call_builder(&getLastBridgeCallCall {})
        }
        ///Creates a new call builder for the [`setShouldRevert`] function.
        pub fn setShouldRevert(
            &self,
            _shouldRevert: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, setShouldRevertCall, N> {
            self.call_builder(
                &setShouldRevertCall {
                    _shouldRevert,
                },
            )
        }
        ///Creates a new call builder for the [`shouldRevert`] function.
        pub fn shouldRevert(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, shouldRevertCall, N> {
            self.call_builder(&shouldRevertCall {})
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MockStandardBridgeInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
