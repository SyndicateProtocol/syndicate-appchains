/**

Generated by the following Solidity interface...
```solidity
interface ExpressLaneAuction {
    struct Bid {
        address expressLaneController;
        uint256 amount;
        bytes signature;
    }
    struct ELCRound {
        address expressLaneController;
        uint64 round;
    }
    struct InitArgs {
        address _auctioneer;
        address _biddingToken;
        address _beneficiary;
        RoundTimingInfo _roundTimingInfo;
        uint256 _minReservePrice;
        address _auctioneerAdmin;
        address _minReservePriceSetter;
        address _reservePriceSetter;
        address _reservePriceSetterAdmin;
        address _beneficiarySetter;
        address _roundTimingSetter;
        address _masterAdmin;
    }
    struct RoundTimingInfo {
        int64 offsetTimestamp;
        uint64 roundDurationSeconds;
        uint64 auctionClosingSeconds;
        uint64 reserveSubmissionSeconds;
    }
    struct Transferor {
        address addr;
        uint64 fixedUntilRound;
    }

    error AuctionNotClosed();
    error BidsWrongOrder();
    error FixedTransferor(uint64 fixedUntilRound);
    error InsufficientBalance(uint256 amountRequested, uint256 balance);
    error InsufficientBalanceAcc(address account, uint256 amountRequested, uint256 balance);
    error InvalidNewRound(uint64 currentRound, uint64 newRound);
    error InvalidNewStart(uint64 currentStart, uint64 newStart);
    error NegativeOffset();
    error NegativeRoundStart(int64 roundStart);
    error NotExpressLaneController(uint64 round, address controller, address sender);
    error NotTransferor(uint64 round, address expectedTransferor, address msgSender);
    error NothingToWithdraw();
    error ReserveBlackout();
    error ReservePriceNotMet(uint256 bidAmount, uint256 reservePrice);
    error ReservePriceTooLow(uint256 reservePrice, uint256 minReservePrice);
    error RoundAlreadyResolved(uint64 round);
    error RoundDurationTooShort();
    error RoundNotResolved(uint64 round);
    error RoundTooLong(uint64 roundDurationSeconds);
    error RoundTooOld(uint64 round, uint64 currentRound);
    error SameBidder();
    error TieBidsWrongOrder();
    error WithdrawalInProgress();
    error WithdrawalMaxRound();
    error ZeroAmount();
    error ZeroAuctionClosingSeconds();
    error ZeroBiddingToken();

    event AuctionResolved(bool indexed isMultiBidAuction, uint64 round, address indexed firstPriceBidder, address indexed firstPriceExpressLaneController, uint256 firstPriceAmount, uint256 price, uint64 roundStartTimestamp, uint64 roundEndTimestamp);
    event Deposit(address indexed account, uint256 amount);
    event Initialized(uint8 version);
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
    event SetBeneficiary(address oldBeneficiary, address newBeneficiary);
    event SetExpressLaneController(uint64 round, address indexed previousExpressLaneController, address indexed newExpressLaneController, address indexed transferor, uint64 startTimestamp, uint64 endTimestamp);
    event SetMinReservePrice(uint256 oldPrice, uint256 newPrice);
    event SetReservePrice(uint256 oldReservePrice, uint256 newReservePrice);
    event SetRoundTimingInfo(uint64 currentRound, int64 offsetTimestamp, uint64 roundDurationSeconds, uint64 auctionClosingSeconds, uint64 reserveSubmissionSeconds);
    event SetTransferor(address indexed expressLaneController, address indexed transferor, uint64 fixedUntilRound);
    event WithdrawalFinalized(address indexed account, uint256 withdrawalAmount);
    event WithdrawalInitiated(address indexed account, uint256 withdrawalAmount, uint256 roundWithdrawable);

    function AUCTIONEER_ADMIN_ROLE() external view returns (bytes32);
    function AUCTIONEER_ROLE() external view returns (bytes32);
    function BENEFICIARY_SETTER_ROLE() external view returns (bytes32);
    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
    function MIN_RESERVE_SETTER_ROLE() external view returns (bytes32);
    function RESERVE_SETTER_ADMIN_ROLE() external view returns (bytes32);
    function RESERVE_SETTER_ROLE() external view returns (bytes32);
    function ROUND_TIMING_SETTER_ROLE() external view returns (bytes32);
    function balanceOf(address account) external view returns (uint256);
    function balanceOfAtRound(address account, uint64 round) external view returns (uint256);
    function beneficiary() external view returns (address);
    function beneficiaryBalance() external view returns (uint256);
    function biddingToken() external view returns (address);
    function currentRound() external view returns (uint64);
    function deposit(uint256 amount) external;
    function domainSeparator() external view returns (bytes32);
    function finalizeWithdrawal() external;
    function flushBeneficiaryBalance() external;
    function getBidHash(uint64 round, address expressLaneController, uint256 amount) external view returns (bytes32);
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function getRoleMember(bytes32 role, uint256 index) external view returns (address);
    function getRoleMemberCount(bytes32 role) external view returns (uint256);
    function grantRole(bytes32 role, address account) external;
    function hasRole(bytes32 role, address account) external view returns (bool);
    function initialize(InitArgs memory args) external;
    function initiateWithdrawal() external;
    function isAuctionRoundClosed() external view returns (bool);
    function isReserveBlackout() external view returns (bool);
    function minReservePrice() external view returns (uint256);
    function renounceRole(bytes32 role, address account) external;
    function reservePrice() external view returns (uint256);
    function resolveMultiBidAuction(Bid memory firstPriceBid, Bid memory secondPriceBid) external;
    function resolveSingleBidAuction(Bid memory firstPriceBid) external;
    function resolvedRounds() external view returns (ELCRound memory, ELCRound memory);
    function revokeRole(bytes32 role, address account) external;
    function roundTimestamps(uint64 round) external view returns (uint64, uint64);
    function roundTimingInfo() external view returns (int64 offsetTimestamp, uint64 roundDurationSeconds, uint64 auctionClosingSeconds, uint64 reserveSubmissionSeconds);
    function setBeneficiary(address newBeneficiary) external;
    function setMinReservePrice(uint256 newMinReservePrice) external;
    function setReservePrice(uint256 newReservePrice) external;
    function setRoundTimingInfo(RoundTimingInfo memory newRoundTimingInfo) external;
    function setTransferor(Transferor memory transferor) external;
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
    function transferExpressLaneController(uint64 round, address newExpressLaneController) external;
    function transferorOf(address) external view returns (address addr, uint64 fixedUntilRound);
    function withdrawableBalance(address account) external view returns (uint256);
    function withdrawableBalanceAtRound(address account, uint64 round) external view returns (uint256);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "function",
    "name": "AUCTIONEER_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "AUCTIONEER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "BENEFICIARY_SETTER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DEFAULT_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "MIN_RESERVE_SETTER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "RESERVE_SETTER_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "RESERVE_SETTER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "ROUND_TIMING_SETTER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "balanceOf",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "balanceOfAtRound",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "round",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "beneficiary",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "beneficiaryBalance",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "biddingToken",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IERC20"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "currentRound",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "deposit",
    "inputs": [
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "domainSeparator",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "finalizeWithdrawal",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "flushBeneficiaryBalance",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getBidHash",
    "inputs": [
      {
        "name": "round",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "expressLaneController",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleAdmin",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleMember",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleMemberCount",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "grantRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "hasRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "initialize",
    "inputs": [
      {
        "name": "args",
        "type": "tuple",
        "internalType": "struct InitArgs",
        "components": [
          {
            "name": "_auctioneer",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "_biddingToken",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "_beneficiary",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "_roundTimingInfo",
            "type": "tuple",
            "internalType": "struct RoundTimingInfo",
            "components": [
              {
                "name": "offsetTimestamp",
                "type": "int64",
                "internalType": "int64"
              },
              {
                "name": "roundDurationSeconds",
                "type": "uint64",
                "internalType": "uint64"
              },
              {
                "name": "auctionClosingSeconds",
                "type": "uint64",
                "internalType": "uint64"
              },
              {
                "name": "reserveSubmissionSeconds",
                "type": "uint64",
                "internalType": "uint64"
              }
            ]
          },
          {
            "name": "_minReservePrice",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "_auctioneerAdmin",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "_minReservePriceSetter",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "_reservePriceSetter",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "_reservePriceSetterAdmin",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "_beneficiarySetter",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "_roundTimingSetter",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "_masterAdmin",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "initiateWithdrawal",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "isAuctionRoundClosed",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isReserveBlackout",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "minReservePrice",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "renounceRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "reservePrice",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "resolveMultiBidAuction",
    "inputs": [
      {
        "name": "firstPriceBid",
        "type": "tuple",
        "internalType": "struct Bid",
        "components": [
          {
            "name": "expressLaneController",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "signature",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      },
      {
        "name": "secondPriceBid",
        "type": "tuple",
        "internalType": "struct Bid",
        "components": [
          {
            "name": "expressLaneController",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "signature",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "resolveSingleBidAuction",
    "inputs": [
      {
        "name": "firstPriceBid",
        "type": "tuple",
        "internalType": "struct Bid",
        "components": [
          {
            "name": "expressLaneController",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "signature",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "resolvedRounds",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct ELCRound",
        "components": [
          {
            "name": "expressLaneController",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "round",
            "type": "uint64",
            "internalType": "uint64"
          }
        ]
      },
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct ELCRound",
        "components": [
          {
            "name": "expressLaneController",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "round",
            "type": "uint64",
            "internalType": "uint64"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "revokeRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "roundTimestamps",
    "inputs": [
      {
        "name": "round",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "roundTimingInfo",
    "inputs": [],
    "outputs": [
      {
        "name": "offsetTimestamp",
        "type": "int64",
        "internalType": "int64"
      },
      {
        "name": "roundDurationSeconds",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "auctionClosingSeconds",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "reserveSubmissionSeconds",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setBeneficiary",
    "inputs": [
      {
        "name": "newBeneficiary",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setMinReservePrice",
    "inputs": [
      {
        "name": "newMinReservePrice",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setReservePrice",
    "inputs": [
      {
        "name": "newReservePrice",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setRoundTimingInfo",
    "inputs": [
      {
        "name": "newRoundTimingInfo",
        "type": "tuple",
        "internalType": "struct RoundTimingInfo",
        "components": [
          {
            "name": "offsetTimestamp",
            "type": "int64",
            "internalType": "int64"
          },
          {
            "name": "roundDurationSeconds",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "auctionClosingSeconds",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "reserveSubmissionSeconds",
            "type": "uint64",
            "internalType": "uint64"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setTransferor",
    "inputs": [
      {
        "name": "transferor",
        "type": "tuple",
        "internalType": "struct Transferor",
        "components": [
          {
            "name": "addr",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "fixedUntilRound",
            "type": "uint64",
            "internalType": "uint64"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "transferExpressLaneController",
    "inputs": [
      {
        "name": "round",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "newExpressLaneController",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferorOf",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "addr",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "fixedUntilRound",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "withdrawableBalance",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "withdrawableBalanceAtRound",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "round",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "event",
    "name": "AuctionResolved",
    "inputs": [
      {
        "name": "isMultiBidAuction",
        "type": "bool",
        "indexed": true,
        "internalType": "bool"
      },
      {
        "name": "round",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      },
      {
        "name": "firstPriceBidder",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "firstPriceExpressLaneController",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "firstPriceAmount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "price",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "roundStartTimestamp",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      },
      {
        "name": "roundEndTimestamp",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Deposit",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialized",
    "inputs": [
      {
        "name": "version",
        "type": "uint8",
        "indexed": false,
        "internalType": "uint8"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleAdminChanged",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "previousAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleGranted",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleRevoked",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SetBeneficiary",
    "inputs": [
      {
        "name": "oldBeneficiary",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "newBeneficiary",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SetExpressLaneController",
    "inputs": [
      {
        "name": "round",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      },
      {
        "name": "previousExpressLaneController",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newExpressLaneController",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "transferor",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "startTimestamp",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      },
      {
        "name": "endTimestamp",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SetMinReservePrice",
    "inputs": [
      {
        "name": "oldPrice",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "newPrice",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SetReservePrice",
    "inputs": [
      {
        "name": "oldReservePrice",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "newReservePrice",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SetRoundTimingInfo",
    "inputs": [
      {
        "name": "currentRound",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      },
      {
        "name": "offsetTimestamp",
        "type": "int64",
        "indexed": false,
        "internalType": "int64"
      },
      {
        "name": "roundDurationSeconds",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      },
      {
        "name": "auctionClosingSeconds",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      },
      {
        "name": "reserveSubmissionSeconds",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SetTransferor",
    "inputs": [
      {
        "name": "expressLaneController",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "transferor",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "fixedUntilRound",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "WithdrawalFinalized",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "withdrawalAmount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "WithdrawalInitiated",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "withdrawalAmount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "roundWithdrawable",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AuctionNotClosed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "BidsWrongOrder",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FixedTransferor",
    "inputs": [
      {
        "name": "fixedUntilRound",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientBalance",
    "inputs": [
      {
        "name": "amountRequested",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "balance",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientBalanceAcc",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amountRequested",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "balance",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidNewRound",
    "inputs": [
      {
        "name": "currentRound",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "newRound",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidNewStart",
    "inputs": [
      {
        "name": "currentStart",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "newStart",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "NegativeOffset",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NegativeRoundStart",
    "inputs": [
      {
        "name": "roundStart",
        "type": "int64",
        "internalType": "int64"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotExpressLaneController",
    "inputs": [
      {
        "name": "round",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "controller",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotTransferor",
    "inputs": [
      {
        "name": "round",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "expectedTransferor",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "msgSender",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NothingToWithdraw",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ReserveBlackout",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ReservePriceNotMet",
    "inputs": [
      {
        "name": "bidAmount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "reservePrice",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ReservePriceTooLow",
    "inputs": [
      {
        "name": "reservePrice",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "minReservePrice",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "RoundAlreadyResolved",
    "inputs": [
      {
        "name": "round",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "RoundDurationTooShort",
    "inputs": []
  },
  {
    "type": "error",
    "name": "RoundNotResolved",
    "inputs": [
      {
        "name": "round",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "RoundTooLong",
    "inputs": [
      {
        "name": "roundDurationSeconds",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "RoundTooOld",
    "inputs": [
      {
        "name": "round",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "currentRound",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "SameBidder",
    "inputs": []
  },
  {
    "type": "error",
    "name": "TieBidsWrongOrder",
    "inputs": []
  },
  {
    "type": "error",
    "name": "WithdrawalInProgress",
    "inputs": []
  },
  {
    "type": "error",
    "name": "WithdrawalMaxRound",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroAmount",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroAuctionClosingSeconds",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroBiddingToken",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod ExpressLaneAuction {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a0604052306080523480156012575f80fd5b5060805161469561002b5f395f6116fb01526146955ff3fe608060405234801561000f575f80fd5b5060043610610303575f3560e01c80637b617f941161019d578063c5b6aa2f116100e8578063e2fc6f6811610093578063e4d20c1d1161006e578063e4d20c1d146107c8578063f698da25146107db578063fed87be8146107e3575f80fd5b8063e2fc6f681461078f578063e3f7bb5514610799578063e460d2c5146107c0575f80fd5b8063cfe9232b116100c3578063cfe9232b1461074b578063d547741f14610772578063db2e1eed14610785575f80fd5b8063c5b6aa2f1461071d578063ca15c87314610725578063ce9c7c0d14610738575f80fd5b80639a1fadd311610148578063b51d1d4f11610123578063b51d1d4f146106ef578063b6b55f25146106f7578063bef0ec741461070a575f80fd5b80639a1fadd3146106ae578063a217fddf146106c1578063b3ee252f146106c8575f80fd5b80638a19c8bc116101785780638a19c8bc146106425780639010d07c1461066357806391d1485414610676575f80fd5b80637b617f94146105dd57806383af0a1f146106115780638948cc4e1461061b575f80fd5b80632f2ff15d1161025d578063639d7566116102085780636dc4fc4e116101e35780636dc4fc4e146105a45780636e8cace5146105b757806370a08231146105ca575f80fd5b8063639d7566146105245780636a514beb146105385780636ad725171461059c575f80fd5b806338af3eed1161023857806338af3eed146104d2578063447a709e146104fe5780635633c33714610511575f80fd5b80632f2ff15d14610485578063336a5b5e1461049857806336568abe146104bf575f80fd5b80630d253fbe116102bd5780631c31f710116102985780631c31f71014610448578063248a9ca31461045b5780632d668ce71461047d575f80fd5b80630d253fbe146103e457806314d96316146103fa5780631682e50b14610421575f80fd5b806301ffc9a7116102ed57806301ffc9a71461038d57806302b62938146103b057806304c584ad146103d1575f80fd5b80627be2fe146103075780630152682d1461031c575b5f80fd5b61031a610315366004613dcc565b6107f6565b005b6101045461035390600781900b9067ffffffffffffffff600160401b8204811691600160801b8104821691600160c01b9091041684565b6040805160079590950b855267ffffffffffffffff9384166020860152918316918401919091521660608201526080015b60405180910390f35b6103a061039b366004613e03565b610a98565b6040519015158152602001610384565b6103c36103be366004613e2a565b610adb565b604051908152602001610384565b6103c36103df366004613e45565b610b52565b6103ec610bd2565b604051610384929190613e83565b6103c37f3fb9f0655b78e8eabe9e0f51d65db56c7690d4329012c3faf1fbd6d43f65826181565b6103c37f6d8dad7188c7ed005c55bf77fbf589583d8668b0dad30a9b9dd016321a5c256f81565b61031a610456366004613e2a565b610c90565b6103c3610469366004613ed1565b5f9081526065602052604090206001015490565b6103a0610d33565b61031a610493366004613ee8565b610d8e565b6103c37fc1b97c934675624ef2089089ac12ae8922988c11dc8a578dfbac10d9eecf476181565b61031a6104cd366004613ee8565b610db7565b610100546104e6906001600160a01b031681565b6040516001600160a01b039091168152602001610384565b61031a61050c366004613f21565b610e43565b6103c361051f366004613f81565b61111c565b610101546104e6906001600160a01b031681565b610574610546366004613e2a565b6101066020525f90815260409020546001600160a01b03811690600160a01b900467ffffffffffffffff1682565b604080516001600160a01b03909316835267ffffffffffffffff909116602083015201610384565b61031a61124a565b61031a6105b2366004613fad565b611296565b6103c36105c5366004613f81565b6113f9565b6103c36105d8366004613e2a565b6114e1565b6105f06105eb366004613fe7565b611558565b6040805167ffffffffffffffff938416815292909116602083015201610384565b6103c36101035481565b6103c37fb07567e7223e21f7dce4c0a89131ce9c32d0d3484085f3f331dea8caef56d14181565b61064a6115ba565b60405167ffffffffffffffff9091168152602001610384565b6104e6610671366004614002565b611610565b6103a0610684366004613ee8565b5f9182526065602090815260408084206001600160a01b0393909316845291905290205460ff1690565b61031a6106bc366004614022565b611627565b6103c35f81565b6103c37f19e6f23df7275b48d1c33822c6ad041a743378552246ac819f578ae1d6709cf981565b61031a611be6565b61031a610705366004613ed1565b611cac565b61031a610718366004614033565b611d16565b61031a611e7a565b6103c3610733366004613ed1565b611f35565b61031a610746366004613ed1565b611f4b565b6103c37f1d693f62a755e2b3c6494da41af454605b9006057cb3c79b6adda1378f2a50a781565b61031a610780366004613ee8565b612022565b6103c36101025481565b6103c36101055481565b6103c37fa8131bb4589277d6866d942849029b416b39e61eb3969a32787130bbdd292a9681565b6103a0612046565b61031a6107d6366004613ed1565b6120ba565b6103c361213b565b61031a6107f1366004614043565b612144565b6040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b900490911660608201525f61084b826122f3565b90508067ffffffffffffffff168467ffffffffffffffff1610156108b4576040517f395f4fd600000000000000000000000000000000000000000000000000000000815267ffffffffffffffff8086166004830152821660248201526044015b60405180910390fd5b5f6108c060fe86612327565b80546001600160a01b039081165f81815261010660205260409020549293509116801561094f576001600160a01b038116331461094a576040517f7621d94a00000000000000000000000000000000000000000000000000000000815267ffffffffffffffff881660048201526001600160a01b03821660248201523360448201526064016108ab565b6109b2565b6001600160a01b03821633146109b2576040517f660af6d200000000000000000000000000000000000000000000000000000000815267ffffffffffffffff881660048201526001600160a01b03831660248201523360448201526064016108ab565b825473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0387161783555f806109e4878a6123c4565b90925090506001600160a01b0383166109fd57836109ff565b825b6001600160a01b0316886001600160a01b0316856001600160a01b03167fb59adc820ca642dad493a0a6e0bdf979dcae037dea114b70d5c66b1c0b791c4b8c4267ffffffffffffffff168767ffffffffffffffff1610610a5f5786610a61565b425b6040805167ffffffffffffffff938416815291831660208301529187168183015290519081900360600190a4505050505050505050565b5f6001600160e01b031982167f5a05180f000000000000000000000000000000000000000000000000000000001480610ad55750610ad582612458565b92915050565b6040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b900490911660608201525f90610ad590610b35906122f3565b6001600160a01b0384165f90815260fd60205260409020906124be565b604080517f0358b2b705d5c5ef47651be44f418326852a390f3b4c933661a5f4f0d8fa1ee3602082015267ffffffffffffffff8516918101919091526001600160a01b0383166060820152608081018290525f90610bc89060a001604051602081830303815290604052805190602001206124e6565b90505b9392505050565b604080518082019091525f8082526020820152604080518082019091525f808252602082015260fe60010154600160a01b900467ffffffffffffffff1660fe5f0154600160a01b900467ffffffffffffffff1611610c335760ff60fe610c38565b60fe60ff5b60408051808201825292546001600160a01b03808216855267ffffffffffffffff600160a01b928390048116602080880191909152845180860190955294549182168452919004169181019190915290939092509050565b7fc1b97c934675624ef2089089ac12ae8922988c11dc8a578dfbac10d9eecf4761610cba8161254d565b61010054604080516001600160a01b03928316815291841660208301527f8a0149b2f3ddf2c9ee85738165131d82babbb938f749321d59f75750afa7f4e6910160405180910390a150610100805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0392909216919091179055565b6040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b900490911660608201525f90610d8990612557565b905090565b5f82815260656020526040902060010154610da88161254d565b610db283836125be565b505050565b6001600160a01b0381163314610e355760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201527f20726f6c657320666f722073656c66000000000000000000000000000000000060648201526084016108ab565b610e3f82826125df565b5050565b7f1d693f62a755e2b3c6494da41af454605b9006057cb3c79b6adda1378f2a50a7610e6d8161254d565b6040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b90049091166060820152610ec181612557565b610ef7576040517fb9adeefd00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b826020013584602001351015610f39576040517fa234cb1900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6101025483602001351015610f8c57610102546040517f56f9b75a0000000000000000000000000000000000000000000000000000000081526020850135600482015260248101919091526044016108ab565b5f610f96826122f3565b90505f610fa482600161407b565b90505f80610fba610fb48961410a565b84612600565b915091505f80610fd389610fcd9061410a565b86612600565b91509150816001600160a01b0316846001600160a01b031603611022576040517ff4a3e48500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b88602001358a602001351480156110b357506040516bffffffffffffffffffffffff19606084901b1660208201526034810182905260540160408051808303601f190181529082905280516020918201206bffffffffffffffffffffffff19606088901b16918301919091526034820185905290605401604051602081830303815290604052805190602001205f1c105b156110ea576040517f9185a0ae00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f806110f689886123c4565b9150915061110e60018d888e602001358c87876126f0565b505050505050505050505050565b6040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b900490911660608201525f90611172906122f3565b67ffffffffffffffff168267ffffffffffffffff161015611229576040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b9004909116606082015282906111e3906122f3565b6040517f395f4fd600000000000000000000000000000000000000000000000000000000815267ffffffffffffffff9283166004820152911660248201526044016108ab565b6001600160a01b0383165f90815260fd60205260409020610bcb9083612843565b610105545f81900361126f57604051631f2a200560e01b815260040160405180910390fd5b5f610105556101005461010154611293916001600160a01b0391821691168361285a565b50565b7f1d693f62a755e2b3c6494da41af454605b9006057cb3c79b6adda1378f2a50a76112c08161254d565b6040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b9004909116606082015261131481612557565b61134a576040517fb9adeefd00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610102548360200135101561139d57610102546040517f56f9b75a0000000000000000000000000000000000000000000000000000000081526020850135600482015260248101919091526044016108ab565b5f6113a7826122f3565b90505f6113b582600161407b565b90505f6113ca6113c48761410a565b83612600565b5090505f806113d986856123c4565b915091506113ef5f8985610102548987876126f0565b5050505050505050565b6040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b900490911660608201525f9061144f906122f3565b67ffffffffffffffff168267ffffffffffffffff1610156114c0576040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b9004909116606082015282906111e3906122f3565b6001600160a01b0383165f90815260fd60205260409020610bcb90836124be565b6040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b900490911660608201525f90610ad59061153b906122f3565b6001600160a01b0384165f90815260fd6020526040902090612843565b6040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b900490911660608201525f9081906115b190846123c4565b91509150915091565b6040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b900490911660608201525f90610d89906122f3565b5f828152609760205260408120610bcb90836128eb565b5f54610100900460ff161580801561164557505f54600160ff909116105b8061165e5750303b15801561165e57505f5460ff166001145b6116d05760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a656400000000000000000000000000000000000060648201526084016108ab565b5f805460ff1916600117905580156116f1575f805461ff0019166101001790555b6001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016300361178f5760405162461bcd60e51b815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f64656c656761746563616c6c000000000000000000000000000000000000000060648201526084016108ab565b6117976128f6565b61180b6040518060400160405280601281526020017f457870726573734c616e6541756374696f6e00000000000000000000000000008152506040518060400160405280600181526020017f3100000000000000000000000000000000000000000000000000000000000000815250612974565b5f61181c6040840160208501613e2a565b6001600160a01b03160361185c576040517f3fb3c7af00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61186c6040830160208401613e2a565b610101805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b03929092169190911790556118aa6060830160408401613e2a565b610100805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b03929092169190911790557f8a0149b2f3ddf2c9ee85738165131d82babbb938f749321d59f75750afa7f4e65f61190a6060850160408601613e2a565b604080516001600160a01b0393841681529290911660208301520160405180910390a160e0820135610103819055604080515f815260208101929092527f5848068f11aa3ba9fe3fc33c5f9f2a3cd1aed67986b85b5e0cedc67dbe96f0f0910160405180910390a160e0820135610102819055604080515f815260208101929092527f9725e37e079c5bda6009a8f54d86265849f30acf61c630f9e1ac91e67de98794910160405180910390a15f6119c860808401606085016141cb565b60070b1215611a03576040517f16f46dfe00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b611a0f826060016129fa565b611a2a5f611a256101e085016101c08601613e2a565b6125be565b611a607fb07567e7223e21f7dce4c0a89131ce9c32d0d3484085f3f331dea8caef56d141611a2561014085016101208601613e2a565b611a967fc1b97c934675624ef2089089ac12ae8922988c11dc8a578dfbac10d9eecf4761611a256101a085016101808601613e2a565b611aff7f1d693f62a755e2b3c6494da41af454605b9006057cb3c79b6adda1378f2a50a7611ac76020850185613e2a565b7f3fb9f0655b78e8eabe9e0f51d65db56c7690d4329012c3faf1fbd6d43f658261611afa61012087016101008801613e2a565b612c08565b611b687f19e6f23df7275b48d1c33822c6ad041a743378552246ac819f578ae1d6709cf9611b3561016085016101408601613e2a565b7fa8131bb4589277d6866d942849029b416b39e61eb3969a32787130bbdd292a96611afa61018087016101608801613e2a565b611b9e7f6d8dad7188c7ed005c55bf77fbf589583d8668b0dad30a9b9dd016321a5c256f611a256101c085016101a08601613e2a565b8015610e3f575f805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15050565b6040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b900490911660608201525f90611c3c906122f3565b611c4790600261407b565b335f90815260fd602052604090208054919250611c649083612c2c565b6040805182815267ffffffffffffffff8416602082015233917f31f69201fab7912e3ec9850e3ab705964bf46d9d4276bdcbb6d05e965e5f5401910160405180910390a25050565b335f90815260fd60205260409020611cc49082612d08565b61010154611cdd906001600160a01b0316333084612d77565b60405181815233907fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c906020015b60405180910390a250565b335f9081526101066020526040902080546001600160a01b031615801590611da857506040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b90049091166060820152611d8d906122f3565b815467ffffffffffffffff918216600160a01b909104909116115b15611df45780546040517f75d899f2000000000000000000000000000000000000000000000000000000008152600160a01b90910467ffffffffffffffff1660048201526024016108ab565b335f908152610106602052604090208290611e0f82826141e6565b50611e1f90506020830183613e2a565b6001600160a01b0316337ff6d28df235d9fa45a42d45dbb7c4f4ac76edb51e528f09f25a0650d32b8b33c0611e5a6040860160208701613fe7565b60405167ffffffffffffffff909116815260200160405180910390a35050565b6040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b900490911660608201525f90611ee890611ed4906122f3565b335f90815260fd6020526040902090612dc8565b61010154909150611f03906001600160a01b0316338361285a565b60405181815233907f9e5c4f9f4e46b8629d3dda85f43a69194f50254404a72dc62b9e932d9c94eda890602001611d0b565b5f818152609760205260408120610ad590612e66565b7f19e6f23df7275b48d1c33822c6ad041a743378552246ac819f578ae1d6709cf9611f758161254d565b5f611f8060fe612e6f565b5080546040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b900482166060820152929350611fe29291600160a01b900416612eb1565b15612019576040517f4f00697800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610db283612f63565b5f8281526065602052604090206001015461203c8161254d565b610db283836125df565b5f8061205260fe612e6f565b5080546040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b9004821660608201529293506120b49291600160a01b900416612eb1565b91505090565b7fb07567e7223e21f7dce4c0a89131ce9c32d0d3484085f3f331dea8caef56d1416120e48161254d565b6101035460408051918252602082018490527f5848068f11aa3ba9fe3fc33c5f9f2a3cd1aed67986b85b5e0cedc67dbe96f0f0910160405180910390a161010382905561010254821115610e3f57610e3f82612f63565b5f610d89612ff2565b7f6d8dad7188c7ed005c55bf77fbf589583d8668b0dad30a9b9dd016321a5c256f61216e8161254d565b6040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b900490911660608201525f6121c3826122f3565b90505f6121dd6121d836879003870187614262565b6122f3565b90508067ffffffffffffffff168267ffffffffffffffff1614612240576040517f68c18ca900000000000000000000000000000000000000000000000000000000815267ffffffffffffffff8084166004830152821660248201526044016108ab565b5f61225661224f84600161407b565b85906123c4565b5090505f61227d61226884600161407b565b612277368a90038a018a614262565b906123c4565b5090508067ffffffffffffffff168267ffffffffffffffff16146122e1576040517fa0e269d800000000000000000000000000000000000000000000000000000000815267ffffffffffffffff8084166004830152821660248201526044016108ab565b6122ea876129fa565b50505050505050565b80515f90600790810b4290910b121561230d57505f919050565b6020820151825161231d9061306b565b610ad591906142f9565b5f67ffffffffffffffff821683820154600160a01b900467ffffffffffffffff160361235857825f5b019050610ad5565b67ffffffffffffffff82168360010154600160a01b900467ffffffffffffffff160361238657826001612350565b6040517ffbb052d800000000000000000000000000000000000000000000000000000000815267ffffffffffffffff831660048201526024016108ab565b5f805f8385602001516123d7919061431f565b85516123e3919061434b565b90505f8160070b1215612428576040517ff160ad79000000000000000000000000000000000000000000000000000000008152600782900b60048201526024016108ab565b602085015181905f9060019061243e908461407b565b612448919061437a565b91945090925050505b9250929050565b5f6001600160e01b031982167f7965db0b000000000000000000000000000000000000000000000000000000001480610ad557507f01ffc9a7000000000000000000000000000000000000000000000000000000006001600160e01b0319831614610ad5565b60018201545f9067ffffffffffffffff90811690831610156124e0575f610bcb565b50505490565b5f610ad56124f2612ff2565b836040517f1901000000000000000000000000000000000000000000000000000000000000602082015260228101839052604281018290525f9060620160405160208183030381529060405280519060200120905092915050565b6112938133613076565b80515f90600790810b4290910b121561257157505f919050565b5f61257e835f015161306b565b90505f836020015182612591919061439b565b9050836040015184602001516125a7919061437a565b67ffffffffffffffff908116911610159392505050565b6125c882826130f5565b5f828152609760205260409020610db29082613195565b6125e982826131a9565b5f828152609760205260409020610db2908261322a565b5f805f61261584865f01518760200151610b52565b90505f61262f86604001518361323e90919063ffffffff16565b90505f61263d60018761437a565b6020808901516001600160a01b0385165f90815260fd9092526040909120919250906126699083612843565b10156126e5576020808801516001600160a01b0384165f90815260fd909252604090912083919061269a9084612843565b6040517f36b24c140000000000000000000000000000000000000000000000000000000081526001600160a01b039093166004840152602483019190915260448201526064016108ab565b509590945092505050565b5f6126fc84600161407b565b90506127188161270f60208a018a613e2a565b60fe9190613260565b6001600160a01b0386165f90815260fd6020526040902061273a90868661334f565b846101055f82825461274c91906143c1565b909155505f90506127606020890189613e2a565b6040805167ffffffffffffffff8581168252878116602083015286168183015290516001600160a01b0392909216915f917fb59adc820ca642dad493a0a6e0bdf979dcae037dea114b70d5c66b1c0b791c4b919081900360600190a46127c96020880188613e2a565b6040805167ffffffffffffffff848116825260208b8101359083015281830189905286811660608301528516608082015290516001600160a01b03928316928916918b1515917f7f5bdabbd27a8fc572781b177055488d7c6729a2bade4f57da9d200f31c15d479181900360a00190a45050505050505050565b5f61284e83836124be565b8354610bcb91906143d4565b6040516001600160a01b038316602482015260448101829052610db29084907fa9059cbb00000000000000000000000000000000000000000000000000000000906064015b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff166001600160e01b0319909316929092179091526133c6565b5f610bcb83836134aa565b5f54610100900460ff166129725760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e6700000000000000000000000000000000000000000060648201526084016108ab565b565b5f54610100900460ff166129f05760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e6700000000000000000000000000000000000000000060648201526084016108ab565b610e3f82826134d0565b612a0a6060820160408301613fe7565b67ffffffffffffffff165f03612a4c576040517f047bad5200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b62015180612a606040830160208401613fe7565b67ffffffffffffffff161115612abf57612a806040820160208301613fe7565b6040517fc34a76cf00000000000000000000000000000000000000000000000000000000815267ffffffffffffffff90911660048201526024016108ab565b612acf6040820160208301613fe7565b67ffffffffffffffff16612ae96060830160408401613fe7565b612af96080840160608501613fe7565b612b03919061407b565b67ffffffffffffffff161115612b45576040517f326de36000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80610104612b5382826143e7565b507f982cfb73783b8c64455c76cdeb1351467c4f1e6b3615fec07df232c1b46ffd479050612b896121d836849003840184614262565b612b9660208401846141cb565b612ba66040850160208601613fe7565b612bb66060860160408701613fe7565b612bc66080870160608801613fe7565b6040805167ffffffffffffffff968716815260079590950b6020860152928516848401529084166060840152909216608082015290519081900360a00190a150565b612c1284846125be565b612c1c82826125be565b612c268483613566565b50505050565b81545f03612c4d57604051631f2a200560e01b815260040160405180910390fd5b67fffffffffffffffe1967ffffffffffffffff821601612c99576040517f3d89ddde00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600182015467ffffffffffffffff90811614612ce1576040517f04eb6b3f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600191909101805467ffffffffffffffff191667ffffffffffffffff909216919091179055565b805f03612d2857604051631f2a200560e01b815260040160405180910390fd5b600182015467ffffffffffffffff90811614612d5c5760018201805467ffffffffffffffff191667ffffffffffffffff1790555b80825f015f828254612d6e91906143c1565b90915550505050565b6040516001600160a01b0380851660248301528316604482015260648101829052612c269085907f23b872dd000000000000000000000000000000000000000000000000000000009060840161289f565b5f67fffffffffffffffe1967ffffffffffffffff831601612e15576040517f3d89ddde00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f612e2084846124be565b9050805f03612e5b576040517fd0d04f6000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f8455905092915050565b5f610ad5825490565b5f808083810190505f8460010154825467ffffffffffffffff600160a01b92839004811692909104161015612ea75750506001808401905b9094909350915050565b81515f90600790810b4290910b1215612ecb57505f610ad5565b5f612ed5846122f3565b9050612ee281600161407b565b67ffffffffffffffff168367ffffffffffffffff1610612f05575f915050610ad5565b5f612f12855f015161306b565b90505f856020015182612f25919061439b565b9050856060015186604001518760200151612f40919061437a565b612f4a919061437a565b67ffffffffffffffff9081169116101595945050505050565b61010354811015612faf57610103546040517fda4f272e0000000000000000000000000000000000000000000000000000000081526108ab918391600401918252602082015260400190565b6101025460408051918252602082018390527f9725e37e079c5bda6009a8f54d86265849f30acf61c630f9e1ac91e67de98794910160405180910390a161010255565b5f610d897f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f61302060c95490565b60ca546040805160208101859052908101839052606081018290524660808201523060a08201525f9060c0016040516020818303038152906040528051906020012090509392505050565b5f610ad582426144dd565b5f8281526065602090815260408083206001600160a01b038516845290915290205460ff16610e3f576130b3816001600160a01b031660146135b0565b6130be8360206135b0565b6040516020016130cf929190614523565b60408051601f198184030181529082905262461bcd60e51b82526108ab9160040161458d565b5f8281526065602090815260408083206001600160a01b038516845290915290205460ff16610e3f575f8281526065602090815260408083206001600160a01b03851684529091529020805460ff191660011790556131513390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b5f610bcb836001600160a01b0384166137d3565b5f8281526065602090815260408083206001600160a01b038516845290915290205460ff1615610e3f575f8281526065602090815260408083206001600160a01b0385168085529252808320805460ff1916905551339285917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45050565b5f610bcb836001600160a01b03841661381f565b5f805f61324b8585613909565b9150915061325881613948565b509392505050565b5f8061326b85612e6f565b8154919350915067ffffffffffffffff808616600160a01b90920416106132ca576040517f451f873400000000000000000000000000000000000000000000000000000000815267ffffffffffffffff851660048201526024016108ab565b604080518082019091526001600160a01b038416815267ffffffffffffffff8516602082015260018218908660ff83166002811061330a5761330a614053565b82519101805460209093015167ffffffffffffffff16600160a01b026001600160e01b03199093166001600160a01b0390921691909117919091179055505050505050565b5f61335a8483612843565b905080158061336857508281105b156133a9576040517fcf47918100000000000000000000000000000000000000000000000000000000815260048101849052602481018290526044016108ab565b82845f015f8282546133bb91906143d4565b909155505050505050565b5f61341a826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316613b339092919063ffffffff16565b805190915015610db2578080602001905181019061343891906145c2565b610db25760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f7420737563636565640000000000000000000000000000000000000000000060648201526084016108ab565b5f825f0182815481106134bf576134bf614053565b905f5260205f200154905092915050565b5f54610100900460ff1661354c5760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e6700000000000000000000000000000000000000000060648201526084016108ab565b81516020928301208151919092012060c99190915560ca55565b5f82815260656020526040808220600101805490849055905190918391839186917fbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff9190a4505050565b60605f6135be8360026145e1565b6135c99060026143c1565b67ffffffffffffffff8111156135e1576135e161409c565b6040519080825280601f01601f19166020018201604052801561360b576020820181803683370190505b5090507f3000000000000000000000000000000000000000000000000000000000000000815f8151811061364157613641614053565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053507f7800000000000000000000000000000000000000000000000000000000000000816001815181106136a3576136a3614053565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053505f6136dd8460026145e1565b6136e89060016143c1565b90505b6001811115613784577f303132333435363738396162636465660000000000000000000000000000000085600f166010811061372957613729614053565b1a60f81b82828151811061373f5761373f614053565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a90535060049490941c9361377d816145f8565b90506136eb565b508315610bcb5760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e7460448201526064016108ab565b5f81815260018301602052604081205461381857508154600181810184555f848152602080822090930184905584548482528286019093526040902091909155610ad5565b505f610ad5565b5f81815260018301602052604081205480156138f9575f6138416001836143d4565b85549091505f90613854906001906143d4565b90508181146138b3575f865f01828154811061387257613872614053565b905f5260205f200154905080875f01848154811061389257613892614053565b5f918252602080832090910192909255918252600188019052604090208390555b85548690806138c4576138c461462c565b600190038181905f5260205f20015f90559055856001015f8681526020019081526020015f205f905560019350505050610ad5565b5f915050610ad5565b5092915050565b5f80825160410361393d576020830151604084015160608501515f1a61393187828585613b41565b94509450505050612451565b505f90506002612451565b5f81600481111561395b5761395b614640565b036139635750565b600181600481111561397757613977614640565b036139c45760405162461bcd60e51b815260206004820152601860248201527f45434453413a20696e76616c6964207369676e6174757265000000000000000060448201526064016108ab565b60028160048111156139d8576139d8614640565b03613a255760405162461bcd60e51b815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e6774680060448201526064016108ab565b6003816004811115613a3957613a39614640565b03613aac5760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c60448201527f756500000000000000000000000000000000000000000000000000000000000060648201526084016108ab565b6004816004811115613ac057613ac0614640565b036112935760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202776272076616c60448201527f756500000000000000000000000000000000000000000000000000000000000060648201526084016108ab565b6060610bc884845f85613c26565b5f807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0831115613b7657505f90506003613c1d565b8460ff16601b14158015613b8e57508460ff16601c14155b15613b9e57505f90506004613c1d565b604080515f8082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa158015613bef573d5f803e3d5ffd5b5050604051601f1901519150506001600160a01b038116613c17575f60019250925050613c1d565b91505f90505b94509492505050565b606082471015613c9e5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c000000000000000000000000000000000000000000000000000060648201526084016108ab565b6001600160a01b0385163b613cf55760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016108ab565b5f80866001600160a01b03168587604051613d109190614654565b5f6040518083038185875af1925050503d805f8114613d4a576040519150601f19603f3d011682016040523d82523d5f602084013e613d4f565b606091505b5091509150613d5f828286613d6a565b979650505050505050565b60608315613d79575081610bcb565b825115613d895782518084602001fd5b8160405162461bcd60e51b81526004016108ab919061458d565b67ffffffffffffffff81168114611293575f80fd5b6001600160a01b0381168114611293575f80fd5b5f8060408385031215613ddd575f80fd5b8235613de881613da3565b91506020830135613df881613db8565b809150509250929050565b5f60208284031215613e13575f80fd5b81356001600160e01b031981168114610bcb575f80fd5b5f60208284031215613e3a575f80fd5b8135610bcb81613db8565b5f805f60608486031215613e57575f80fd5b8335613e6281613da3565b92506020840135613e7281613db8565b929592945050506040919091013590565b82516001600160a01b0316815260208084015167ffffffffffffffff16908201526080810182516001600160a01b03166040830152602083015167ffffffffffffffff166060830152610bcb565b5f60208284031215613ee1575f80fd5b5035919050565b5f8060408385031215613ef9575f80fd5b823591506020830135613df881613db8565b5f60608284031215613f1b575f80fd5b50919050565b5f8060408385031215613f32575f80fd5b823567ffffffffffffffff80821115613f49575f80fd5b613f5586838701613f0b565b93506020850135915080821115613f6a575f80fd5b50613f7785828601613f0b565b9150509250929050565b5f8060408385031215613f92575f80fd5b8235613f9d81613db8565b91506020830135613df881613da3565b5f60208284031215613fbd575f80fd5b813567ffffffffffffffff811115613fd3575f80fd5b613fdf84828501613f0b565b949350505050565b5f60208284031215613ff7575f80fd5b8135610bcb81613da3565b5f8060408385031215614013575f80fd5b50508035926020909101359150565b5f6101e08284031215613f1b575f80fd5b5f60408284031215613f1b575f80fd5b5f60808284031215613f1b575f80fd5b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b67ffffffffffffffff81811683821601908082111561390257613902614067565b634e487b7160e01b5f52604160045260245ffd5b6040516060810167ffffffffffffffff811182821017156140d3576140d361409c565b60405290565b604051601f8201601f1916810167ffffffffffffffff811182821017156141025761410261409c565b604052919050565b5f6060823603121561411a575f80fd5b6141226140b0565b823561412d81613db8565b815260208381013581830152604084013567ffffffffffffffff80821115614153575f80fd5b9085019036601f830112614165575f80fd5b8135818111156141775761417761409c565b61418984601f19601f840116016140d9565b9150808252368482850101111561419e575f80fd5b80848401858401375f9082019093019290925250604082015292915050565b8060070b8114611293575f80fd5b5f602082840312156141db575f80fd5b8135610bcb816141bd565b81356141f181613db8565b6001600160a01b038116905081548173ffffffffffffffffffffffffffffffffffffffff198216178355602084013561422981613da3565b7bffffffffffffffff00000000000000000000000000000000000000008160a01b16836001600160e01b03198416171784555050505050565b5f60808284031215614272575f80fd5b6040516080810181811067ffffffffffffffff821117156142955761429561409c565b60405282356142a3816141bd565b815260208301356142b381613da3565b602082015260408301356142c681613da3565b604082015260608301356142d981613da3565b60608201529392505050565b634e487b7160e01b5f52601260045260245ffd5b5f67ffffffffffffffff80841680614313576143136142e5565b92169190910492915050565b67ffffffffffffffff81811683821602808216919082811461434357614343614067565b505092915050565b600781810b9083900b01677fffffffffffffff8113677fffffffffffffff1982121715610ad557610ad5614067565b67ffffffffffffffff82811682821603908082111561390257613902614067565b5f67ffffffffffffffff808416806143b5576143b56142e5565b92169190910692915050565b80820180821115610ad557610ad5614067565b81810381811115610ad557610ad5614067565b81356143f2816141bd565b815467ffffffffffffffff82811667ffffffffffffffff198316178455602085013561441d81613da3565b6fffffffffffffffff0000000000000000604091821b16919093167fffffffffffffffffffffffffffffffff000000000000000000000000000000008316811782178555928501359061446f82613da3565b77ffffffffffffffff000000000000000000000000000000008260801b1691507fffffffffffffffff0000000000000000000000000000000000000000000000008285828616178317178655606087013593506144cb84613da3565b93171760c09190911b90911617905550565b600782810b9082900b03677fffffffffffffff198112677fffffffffffffff82131715610ad557610ad5614067565b5f81518060208401855e5f93019283525090919050565b7f416363657373436f6e74726f6c3a206163636f756e742000000000000000000081525f614554601783018561450c565b7f206973206d697373696e6720726f6c65200000000000000000000000000000008152614584601182018561450c565b95945050505050565b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f83011684010191505092915050565b5f602082840312156145d2575f80fd5b81518015158114610bcb575f80fd5b8082028115828204841417610ad557610ad5614067565b5f8161460657614606614067565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0190565b634e487b7160e01b5f52603160045260245ffd5b634e487b7160e01b5f52602160045260245ffd5b5f610bcb828461450c56fea264697066735822122027004b4d9636da7cc518f548aa36ae81f38e90957760b4ad93d5db055e9ba0a364736f6c63430008190033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0`@R0`\x80R4\x80\x15`\x12W_\x80\xFD[P`\x80QaF\x95a\0+_9_a\x16\xFB\x01RaF\x95_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW_\x80\xFD[P`\x046\x10a\x03\x03W_5`\xE0\x1C\x80c{a\x7F\x94\x11a\x01\x9DW\x80c\xC5\xB6\xAA/\x11a\0\xE8W\x80c\xE2\xFCoh\x11a\0\x93W\x80c\xE4\xD2\x0C\x1D\x11a\0nW\x80c\xE4\xD2\x0C\x1D\x14a\x07\xC8W\x80c\xF6\x98\xDA%\x14a\x07\xDBW\x80c\xFE\xD8{\xE8\x14a\x07\xE3W_\x80\xFD[\x80c\xE2\xFCoh\x14a\x07\x8FW\x80c\xE3\xF7\xBBU\x14a\x07\x99W\x80c\xE4`\xD2\xC5\x14a\x07\xC0W_\x80\xFD[\x80c\xCF\xE9#+\x11a\0\xC3W\x80c\xCF\xE9#+\x14a\x07KW\x80c\xD5Gt\x1F\x14a\x07rW\x80c\xDB.\x1E\xED\x14a\x07\x85W_\x80\xFD[\x80c\xC5\xB6\xAA/\x14a\x07\x1DW\x80c\xCA\x15\xC8s\x14a\x07%W\x80c\xCE\x9C|\r\x14a\x078W_\x80\xFD[\x80c\x9A\x1F\xAD\xD3\x11a\x01HW\x80c\xB5\x1D\x1DO\x11a\x01#W\x80c\xB5\x1D\x1DO\x14a\x06\xEFW\x80c\xB6\xB5_%\x14a\x06\xF7W\x80c\xBE\xF0\xECt\x14a\x07\nW_\x80\xFD[\x80c\x9A\x1F\xAD\xD3\x14a\x06\xAEW\x80c\xA2\x17\xFD\xDF\x14a\x06\xC1W\x80c\xB3\xEE%/\x14a\x06\xC8W_\x80\xFD[\x80c\x8A\x19\xC8\xBC\x11a\x01xW\x80c\x8A\x19\xC8\xBC\x14a\x06BW\x80c\x90\x10\xD0|\x14a\x06cW\x80c\x91\xD1HT\x14a\x06vW_\x80\xFD[\x80c{a\x7F\x94\x14a\x05\xDDW\x80c\x83\xAF\n\x1F\x14a\x06\x11W\x80c\x89H\xCCN\x14a\x06\x1BW_\x80\xFD[\x80c//\xF1]\x11a\x02]W\x80cc\x9Duf\x11a\x02\x08W\x80cm\xC4\xFCN\x11a\x01\xE3W\x80cm\xC4\xFCN\x14a\x05\xA4W\x80cn\x8C\xAC\xE5\x14a\x05\xB7W\x80cp\xA0\x821\x14a\x05\xCAW_\x80\xFD[\x80cc\x9Duf\x14a\x05$W\x80cjQK\xEB\x14a\x058W\x80cj\xD7%\x17\x14a\x05\x9CW_\x80\xFD[\x80c8\xAF>\xED\x11a\x028W\x80c8\xAF>\xED\x14a\x04\xD2W\x80cDzp\x9E\x14a\x04\xFEW\x80cV3\xC37\x14a\x05\x11W_\x80\xFD[\x80c//\xF1]\x14a\x04\x85W\x80c3j[^\x14a\x04\x98W\x80c6V\x8A\xBE\x14a\x04\xBFW_\x80\xFD[\x80c\r%?\xBE\x11a\x02\xBDW\x80c\x1C1\xF7\x10\x11a\x02\x98W\x80c\x1C1\xF7\x10\x14a\x04HW\x80c$\x8A\x9C\xA3\x14a\x04[W\x80c-f\x8C\xE7\x14a\x04}W_\x80\xFD[\x80c\r%?\xBE\x14a\x03\xE4W\x80c\x14\xD9c\x16\x14a\x03\xFAW\x80c\x16\x82\xE5\x0B\x14a\x04!W_\x80\xFD[\x80c\x01\xFF\xC9\xA7\x11a\x02\xEDW\x80c\x01\xFF\xC9\xA7\x14a\x03\x8DW\x80c\x02\xB6)8\x14a\x03\xB0W\x80c\x04\xC5\x84\xAD\x14a\x03\xD1W_\x80\xFD[\x80b{\xE2\xFE\x14a\x03\x07W\x80c\x01Rh-\x14a\x03\x1CW[_\x80\xFD[a\x03\x1Aa\x03\x156`\x04a=\xCCV[a\x07\xF6V[\0[a\x01\x04Ta\x03S\x90`\x07\x81\x90\x0B\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16\x91`\x01`\x80\x1B\x81\x04\x82\x16\x91`\x01`\xC0\x1B\x90\x91\x04\x16\x84V[`@\x80Q`\x07\x95\x90\x95\x0B\x85Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x93\x84\x16` \x86\x01R\x91\x83\x16\x91\x84\x01\x91\x90\x91R\x16``\x82\x01R`\x80\x01[`@Q\x80\x91\x03\x90\xF3[a\x03\xA0a\x03\x9B6`\x04a>\x03V[a\n\x98V[`@Q\x90\x15\x15\x81R` \x01a\x03\x84V[a\x03\xC3a\x03\xBE6`\x04a>*V[a\n\xDBV[`@Q\x90\x81R` \x01a\x03\x84V[a\x03\xC3a\x03\xDF6`\x04a>EV[a\x0BRV[a\x03\xECa\x0B\xD2V[`@Qa\x03\x84\x92\x91\x90a>\x83V[a\x03\xC3\x7F?\xB9\xF0e[x\xE8\xEA\xBE\x9E\x0FQ\xD6]\xB5lv\x90\xD42\x90\x12\xC3\xFA\xF1\xFB\xD6\xD4?e\x82a\x81V[a\x03\xC3\x7Fm\x8D\xADq\x88\xC7\xED\0\\U\xBFw\xFB\xF5\x89X=\x86h\xB0\xDA\xD3\n\x9B\x9D\xD0\x162\x1A\\%o\x81V[a\x03\x1Aa\x04V6`\x04a>*V[a\x0C\x90V[a\x03\xC3a\x04i6`\x04a>\xD1V[_\x90\x81R`e` R`@\x90 `\x01\x01T\x90V[a\x03\xA0a\r3V[a\x03\x1Aa\x04\x936`\x04a>\xE8V[a\r\x8EV[a\x03\xC3\x7F\xC1\xB9|\x93FubN\xF2\x08\x90\x89\xAC\x12\xAE\x89\"\x98\x8C\x11\xDC\x8AW\x8D\xFB\xAC\x10\xD9\xEE\xCFGa\x81V[a\x03\x1Aa\x04\xCD6`\x04a>\xE8V[a\r\xB7V[a\x01\0Ta\x04\xE6\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x03\x84V[a\x03\x1Aa\x05\x0C6`\x04a?!V[a\x0ECV[a\x03\xC3a\x05\x1F6`\x04a?\x81V[a\x11\x1CV[a\x01\x01Ta\x04\xE6\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[a\x05ta\x05F6`\x04a>*V[a\x01\x06` R_\x90\x81R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x81\x16\x90`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x90\x93\x16\x83Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16` \x83\x01R\x01a\x03\x84V[a\x03\x1Aa\x12JV[a\x03\x1Aa\x05\xB26`\x04a?\xADV[a\x12\x96V[a\x03\xC3a\x05\xC56`\x04a?\x81V[a\x13\xF9V[a\x03\xC3a\x05\xD86`\x04a>*V[a\x14\xE1V[a\x05\xF0a\x05\xEB6`\x04a?\xE7V[a\x15XV[`@\x80Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x93\x84\x16\x81R\x92\x90\x91\x16` \x83\x01R\x01a\x03\x84V[a\x03\xC3a\x01\x03T\x81V[a\x03\xC3\x7F\xB0ug\xE7\">!\xF7\xDC\xE4\xC0\xA8\x911\xCE\x9C2\xD0\xD3H@\x85\xF3\xF31\xDE\xA8\xCA\xEFV\xD1A\x81V[a\x06Ja\x15\xBAV[`@Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x03\x84V[a\x04\xE6a\x06q6`\x04a@\x02V[a\x16\x10V[a\x03\xA0a\x06\x846`\x04a>\xE8V[_\x91\x82R`e` \x90\x81R`@\x80\x84 `\x01`\x01`\xA0\x1B\x03\x93\x90\x93\x16\x84R\x91\x90R\x90 T`\xFF\x16\x90V[a\x03\x1Aa\x06\xBC6`\x04a@\"V[a\x16'V[a\x03\xC3_\x81V[a\x03\xC3\x7F\x19\xE6\xF2=\xF7'[H\xD1\xC38\"\xC6\xAD\x04\x1At3xU\"F\xAC\x81\x9FW\x8A\xE1\xD6p\x9C\xF9\x81V[a\x03\x1Aa\x1B\xE6V[a\x03\x1Aa\x07\x056`\x04a>\xD1V[a\x1C\xACV[a\x03\x1Aa\x07\x186`\x04a@3V[a\x1D\x16V[a\x03\x1Aa\x1EzV[a\x03\xC3a\x0736`\x04a>\xD1V[a\x1F5V[a\x03\x1Aa\x07F6`\x04a>\xD1V[a\x1FKV[a\x03\xC3\x7F\x1Di?b\xA7U\xE2\xB3\xC6IM\xA4\x1A\xF4T`[\x90\x06\x05|\xB3\xC7\x9Bj\xDD\xA17\x8F*P\xA7\x81V[a\x03\x1Aa\x07\x806`\x04a>\xE8V[a \"V[a\x03\xC3a\x01\x02T\x81V[a\x03\xC3a\x01\x05T\x81V[a\x03\xC3\x7F\xA8\x13\x1B\xB4X\x92w\xD6\x86m\x94(I\x02\x9BAk9\xE6\x1E\xB3\x96\x9A2xq0\xBB\xDD)*\x96\x81V[a\x03\xA0a FV[a\x03\x1Aa\x07\xD66`\x04a>\xD1V[a \xBAV[a\x03\xC3a!;V[a\x03\x1Aa\x07\xF16`\x04a@CV[a!DV[`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01R_a\x08K\x82a\"\xF3V[\x90P\x80g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15a\x08\xB4W`@Q\x7F9_O\xD6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x86\x16`\x04\x83\x01R\x82\x16`$\x82\x01R`D\x01[`@Q\x80\x91\x03\x90\xFD[_a\x08\xC0`\xFE\x86a#'V[\x80T`\x01`\x01`\xA0\x1B\x03\x90\x81\x16_\x81\x81Ra\x01\x06` R`@\x90 T\x92\x93P\x91\x16\x80\x15a\tOW`\x01`\x01`\xA0\x1B\x03\x81\x163\x14a\tJW`@Q\x7Fv!\xD9J\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x88\x16`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x82\x16`$\x82\x01R3`D\x82\x01R`d\x01a\x08\xABV[a\t\xB2V[`\x01`\x01`\xA0\x1B\x03\x82\x163\x14a\t\xB2W`@Q\x7Ff\n\xF6\xD2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x88\x16`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x83\x16`$\x82\x01R3`D\x82\x01R`d\x01a\x08\xABV[\x82Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`\xA0\x1B\x03\x87\x16\x17\x83U_\x80a\t\xE4\x87\x8Aa#\xC4V[\x90\x92P\x90P`\x01`\x01`\xA0\x1B\x03\x83\x16a\t\xFDW\x83a\t\xFFV[\x82[`\x01`\x01`\xA0\x1B\x03\x16\x88`\x01`\x01`\xA0\x1B\x03\x16\x85`\x01`\x01`\xA0\x1B\x03\x16\x7F\xB5\x9A\xDC\x82\x0C\xA6B\xDA\xD4\x93\xA0\xA6\xE0\xBD\xF9y\xDC\xAE\x03}\xEA\x11Kp\xD5\xC6k\x1C\x0By\x1CK\x8CBg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x87g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10a\n_W\x86a\naV[B[`@\x80Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x93\x84\x16\x81R\x91\x83\x16` \x83\x01R\x91\x87\x16\x81\x83\x01R\x90Q\x90\x81\x90\x03``\x01\x90\xA4PPPPPPPPPV[_`\x01`\x01`\xE0\x1B\x03\x19\x82\x16\x7FZ\x05\x18\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x14\x80a\n\xD5WPa\n\xD5\x82a$XV[\x92\x91PPV[`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01R_\x90a\n\xD5\x90a\x0B5\x90a\"\xF3V[`\x01`\x01`\xA0\x1B\x03\x84\x16_\x90\x81R`\xFD` R`@\x90 \x90a$\xBEV[`@\x80Q\x7F\x03X\xB2\xB7\x05\xD5\xC5\xEFGe\x1B\xE4OA\x83&\x85*9\x0F;L\x936a\xA5\xF4\xF0\xD8\xFA\x1E\xE3` \x82\x01Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x16\x91\x81\x01\x91\x90\x91R`\x01`\x01`\xA0\x1B\x03\x83\x16``\x82\x01R`\x80\x81\x01\x82\x90R_\x90a\x0B\xC8\x90`\xA0\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 a$\xE6V[\x90P[\x93\x92PPPV[`@\x80Q\x80\x82\x01\x90\x91R_\x80\x82R` \x82\x01R`@\x80Q\x80\x82\x01\x90\x91R_\x80\x82R` \x82\x01R`\xFE`\x01\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\xFE_\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11a\x0C3W`\xFF`\xFEa\x0C8V[`\xFE`\xFF[`@\x80Q\x80\x82\x01\x82R\x92T`\x01`\x01`\xA0\x1B\x03\x80\x82\x16\x85Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`\xA0\x1B\x92\x83\x90\x04\x81\x16` \x80\x88\x01\x91\x90\x91R\x84Q\x80\x86\x01\x90\x95R\x94T\x91\x82\x16\x84R\x91\x90\x04\x16\x91\x81\x01\x91\x90\x91R\x90\x93\x90\x92P\x90PV[\x7F\xC1\xB9|\x93FubN\xF2\x08\x90\x89\xAC\x12\xAE\x89\"\x98\x8C\x11\xDC\x8AW\x8D\xFB\xAC\x10\xD9\xEE\xCFGaa\x0C\xBA\x81a%MV[a\x01\0T`@\x80Q`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x81R\x91\x84\x16` \x83\x01R\x7F\x8A\x01I\xB2\xF3\xDD\xF2\xC9\xEE\x85s\x81e\x13\x1D\x82\xBA\xBB\xB98\xF7I2\x1DY\xF7WP\xAF\xA7\xF4\xE6\x91\x01`@Q\x80\x91\x03\x90\xA1Pa\x01\0\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90UV[`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01R_\x90a\r\x89\x90a%WV[\x90P\x90V[_\x82\x81R`e` R`@\x90 `\x01\x01Ta\r\xA8\x81a%MV[a\r\xB2\x83\x83a%\xBEV[PPPV[`\x01`\x01`\xA0\x1B\x03\x81\x163\x14a\x0E5W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`/`$\x82\x01R\x7FAccessControl: can only renounce`D\x82\x01R\x7F roles for self\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08\xABV[a\x0E?\x82\x82a%\xDFV[PPV[\x7F\x1Di?b\xA7U\xE2\xB3\xC6IM\xA4\x1A\xF4T`[\x90\x06\x05|\xB3\xC7\x9Bj\xDD\xA17\x8F*P\xA7a\x0Em\x81a%MV[`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01Ra\x0E\xC1\x81a%WV[a\x0E\xF7W`@Q\x7F\xB9\xAD\xEE\xFD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x82` \x015\x84` \x015\x10\x15a\x0F9W`@Q\x7F\xA24\xCB\x19\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x01\x02T\x83` \x015\x10\x15a\x0F\x8CWa\x01\x02T`@Q\x7FV\xF9\xB7Z\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x85\x015`\x04\x82\x01R`$\x81\x01\x91\x90\x91R`D\x01a\x08\xABV[_a\x0F\x96\x82a\"\xF3V[\x90P_a\x0F\xA4\x82`\x01a@{V[\x90P_\x80a\x0F\xBAa\x0F\xB4\x89aA\nV[\x84a&\0V[\x91P\x91P_\x80a\x0F\xD3\x89a\x0F\xCD\x90aA\nV[\x86a&\0V[\x91P\x91P\x81`\x01`\x01`\xA0\x1B\x03\x16\x84`\x01`\x01`\xA0\x1B\x03\x16\x03a\x10\"W`@Q\x7F\xF4\xA3\xE4\x85\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x88` \x015\x8A` \x015\x14\x80\x15a\x10\xB3WP`@Qk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19``\x84\x90\x1B\x16` \x82\x01R`4\x81\x01\x82\x90R`T\x01`@\x80Q\x80\x83\x03`\x1F\x19\x01\x81R\x90\x82\x90R\x80Q` \x91\x82\x01 k\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19``\x88\x90\x1B\x16\x91\x83\x01\x91\x90\x91R`4\x82\x01\x85\x90R\x90`T\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 _\x1C\x10[\x15a\x10\xEAW`@Q\x7F\x91\x85\xA0\xAE\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80a\x10\xF6\x89\x88a#\xC4V[\x91P\x91Pa\x11\x0E`\x01\x8D\x88\x8E` \x015\x8C\x87\x87a&\xF0V[PPPPPPPPPPPPV[`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01R_\x90a\x11r\x90a\"\xF3V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15a\x12)W`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01R\x82\x90a\x11\xE3\x90a\"\xF3V[`@Q\x7F9_O\xD6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92\x83\x16`\x04\x82\x01R\x91\x16`$\x82\x01R`D\x01a\x08\xABV[`\x01`\x01`\xA0\x1B\x03\x83\x16_\x90\x81R`\xFD` R`@\x90 a\x0B\xCB\x90\x83a(CV[a\x01\x05T_\x81\x90\x03a\x12oW`@Qc\x1F* \x05`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a\x01\x05Ua\x01\0Ta\x01\x01Ta\x12\x93\x91`\x01`\x01`\xA0\x1B\x03\x91\x82\x16\x91\x16\x83a(ZV[PV[\x7F\x1Di?b\xA7U\xE2\xB3\xC6IM\xA4\x1A\xF4T`[\x90\x06\x05|\xB3\xC7\x9Bj\xDD\xA17\x8F*P\xA7a\x12\xC0\x81a%MV[`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01Ra\x13\x14\x81a%WV[a\x13JW`@Q\x7F\xB9\xAD\xEE\xFD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x01\x02T\x83` \x015\x10\x15a\x13\x9DWa\x01\x02T`@Q\x7FV\xF9\xB7Z\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x85\x015`\x04\x82\x01R`$\x81\x01\x91\x90\x91R`D\x01a\x08\xABV[_a\x13\xA7\x82a\"\xF3V[\x90P_a\x13\xB5\x82`\x01a@{V[\x90P_a\x13\xCAa\x13\xC4\x87aA\nV[\x83a&\0V[P\x90P_\x80a\x13\xD9\x86\x85a#\xC4V[\x91P\x91Pa\x13\xEF_\x89\x85a\x01\x02T\x89\x87\x87a&\xF0V[PPPPPPPPV[`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01R_\x90a\x14O\x90a\"\xF3V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15a\x14\xC0W`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01R\x82\x90a\x11\xE3\x90a\"\xF3V[`\x01`\x01`\xA0\x1B\x03\x83\x16_\x90\x81R`\xFD` R`@\x90 a\x0B\xCB\x90\x83a$\xBEV[`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01R_\x90a\n\xD5\x90a\x15;\x90a\"\xF3V[`\x01`\x01`\xA0\x1B\x03\x84\x16_\x90\x81R`\xFD` R`@\x90 \x90a(CV[`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01R_\x90\x81\x90a\x15\xB1\x90\x84a#\xC4V[\x91P\x91P\x91P\x91V[`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01R_\x90a\r\x89\x90a\"\xF3V[_\x82\x81R`\x97` R`@\x81 a\x0B\xCB\x90\x83a(\xEBV[_Ta\x01\0\x90\x04`\xFF\x16\x15\x80\x80\x15a\x16EWP_T`\x01`\xFF\x90\x91\x16\x10[\x80a\x16^WP0;\x15\x80\x15a\x16^WP_T`\xFF\x16`\x01\x14[a\x16\xD0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`.`$\x82\x01R\x7FInitializable: contract is alrea`D\x82\x01R\x7Fdy initialized\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08\xABV[_\x80T`\xFF\x19\x16`\x01\x17\x90U\x80\x15a\x16\xF1W_\x80Ta\xFF\0\x19\x16a\x01\0\x17\x90U[`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x160\x03a\x17\x8FW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`,`$\x82\x01R\x7FFunction must be called through `D\x82\x01R\x7Fdelegatecall\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08\xABV[a\x17\x97a(\xF6V[a\x18\x0B`@Q\x80`@\x01`@R\x80`\x12\x81R` \x01\x7FExpressLaneAuction\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP`@Q\x80`@\x01`@R\x80`\x01\x81R` \x01\x7F1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPa)tV[_a\x18\x1C`@\x84\x01` \x85\x01a>*V[`\x01`\x01`\xA0\x1B\x03\x16\x03a\x18\\W`@Q\x7F?\xB3\xC7\xAF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x18l`@\x83\x01` \x84\x01a>*V[a\x01\x01\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90Ua\x18\xAA``\x83\x01`@\x84\x01a>*V[a\x01\0\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90U\x7F\x8A\x01I\xB2\xF3\xDD\xF2\xC9\xEE\x85s\x81e\x13\x1D\x82\xBA\xBB\xB98\xF7I2\x1DY\xF7WP\xAF\xA7\xF4\xE6_a\x19\n``\x85\x01`@\x86\x01a>*V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x93\x84\x16\x81R\x92\x90\x91\x16` \x83\x01R\x01`@Q\x80\x91\x03\x90\xA1`\xE0\x82\x015a\x01\x03\x81\x90U`@\x80Q_\x81R` \x81\x01\x92\x90\x92R\x7FXH\x06\x8F\x11\xAA;\xA9\xFE?\xC3<_\x9F*<\xD1\xAE\xD6y\x86\xB8[^\x0C\xED\xC6}\xBE\x96\xF0\xF0\x91\x01`@Q\x80\x91\x03\x90\xA1`\xE0\x82\x015a\x01\x02\x81\x90U`@\x80Q_\x81R` \x81\x01\x92\x90\x92R\x7F\x97%\xE3~\x07\x9C[\xDA`\t\xA8\xF5M\x86&XI\xF3\n\xCFa\xC60\xF9\xE1\xAC\x91\xE6}\xE9\x87\x94\x91\x01`@Q\x80\x91\x03\x90\xA1_a\x19\xC8`\x80\x84\x01``\x85\x01aA\xCBV[`\x07\x0B\x12\x15a\x1A\x03W`@Q\x7F\x16\xF4m\xFE\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x1A\x0F\x82``\x01a)\xFAV[a\x1A*_a\x1A%a\x01\xE0\x85\x01a\x01\xC0\x86\x01a>*V[a%\xBEV[a\x1A`\x7F\xB0ug\xE7\">!\xF7\xDC\xE4\xC0\xA8\x911\xCE\x9C2\xD0\xD3H@\x85\xF3\xF31\xDE\xA8\xCA\xEFV\xD1Aa\x1A%a\x01@\x85\x01a\x01 \x86\x01a>*V[a\x1A\x96\x7F\xC1\xB9|\x93FubN\xF2\x08\x90\x89\xAC\x12\xAE\x89\"\x98\x8C\x11\xDC\x8AW\x8D\xFB\xAC\x10\xD9\xEE\xCFGaa\x1A%a\x01\xA0\x85\x01a\x01\x80\x86\x01a>*V[a\x1A\xFF\x7F\x1Di?b\xA7U\xE2\xB3\xC6IM\xA4\x1A\xF4T`[\x90\x06\x05|\xB3\xC7\x9Bj\xDD\xA17\x8F*P\xA7a\x1A\xC7` \x85\x01\x85a>*V[\x7F?\xB9\xF0e[x\xE8\xEA\xBE\x9E\x0FQ\xD6]\xB5lv\x90\xD42\x90\x12\xC3\xFA\xF1\xFB\xD6\xD4?e\x82aa\x1A\xFAa\x01 \x87\x01a\x01\0\x88\x01a>*V[a,\x08V[a\x1Bh\x7F\x19\xE6\xF2=\xF7'[H\xD1\xC38\"\xC6\xAD\x04\x1At3xU\"F\xAC\x81\x9FW\x8A\xE1\xD6p\x9C\xF9a\x1B5a\x01`\x85\x01a\x01@\x86\x01a>*V[\x7F\xA8\x13\x1B\xB4X\x92w\xD6\x86m\x94(I\x02\x9BAk9\xE6\x1E\xB3\x96\x9A2xq0\xBB\xDD)*\x96a\x1A\xFAa\x01\x80\x87\x01a\x01`\x88\x01a>*V[a\x1B\x9E\x7Fm\x8D\xADq\x88\xC7\xED\0\\U\xBFw\xFB\xF5\x89X=\x86h\xB0\xDA\xD3\n\x9B\x9D\xD0\x162\x1A\\%oa\x1A%a\x01\xC0\x85\x01a\x01\xA0\x86\x01a>*V[\x80\x15a\x0E?W_\x80Ta\xFF\0\x19\x16\x90U`@Q`\x01\x81R\x7F\x7F&\xB8?\xF9n\x1F+jh/\x138R\xF6y\x8A\t\xC4e\xDA\x95\x92\x14`\xCE\xFB8G@$\x98\x90` \x01`@Q\x80\x91\x03\x90\xA1PPV[`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01R_\x90a\x1C<\x90a\"\xF3V[a\x1CG\x90`\x02a@{V[3_\x90\x81R`\xFD` R`@\x90 \x80T\x91\x92Pa\x1Cd\x90\x83a,,V[`@\x80Q\x82\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16` \x82\x01R3\x91\x7F1\xF6\x92\x01\xFA\xB7\x91.>\xC9\x85\x0E:\xB7\x05\x96K\xF4m\x9DBv\xBD\xCB\xB6\xD0^\x96^_T\x01\x91\x01`@Q\x80\x91\x03\x90\xA2PPV[3_\x90\x81R`\xFD` R`@\x90 a\x1C\xC4\x90\x82a-\x08V[a\x01\x01Ta\x1C\xDD\x90`\x01`\x01`\xA0\x1B\x03\x1630\x84a-wV[`@Q\x81\x81R3\x90\x7F\xE1\xFF\xFC\xC4\x92=\x04\xB5Y\xF4\xD2\x9A\x8B\xFCl\xDA\x04\xEB[\r<F\x07Q\xC2@,\\\\\xC9\x10\x9C\x90` \x01[`@Q\x80\x91\x03\x90\xA2PV[3_\x90\x81Ra\x01\x06` R`@\x90 \x80T`\x01`\x01`\xA0\x1B\x03\x16\x15\x80\x15\x90a\x1D\xA8WP`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01Ra\x1D\x8D\x90a\"\xF3V[\x81Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91\x82\x16`\x01`\xA0\x1B\x90\x91\x04\x90\x91\x16\x11[\x15a\x1D\xF4W\x80T`@Q\x7Fu\xD8\x99\xF2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\xA0\x1B\x90\x91\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x04\x82\x01R`$\x01a\x08\xABV[3_\x90\x81Ra\x01\x06` R`@\x90 \x82\x90a\x1E\x0F\x82\x82aA\xE6V[Pa\x1E\x1F\x90P` \x83\x01\x83a>*V[`\x01`\x01`\xA0\x1B\x03\x163\x7F\xF6\xD2\x8D\xF25\xD9\xFAE\xA4-E\xDB\xB7\xC4\xF4\xACv\xED\xB5\x1ER\x8F\t\xF2Z\x06P\xD3+\x8B3\xC0a\x1EZ`@\x86\x01` \x87\x01a?\xE7V[`@Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01`@Q\x80\x91\x03\x90\xA3PPV[`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01R_\x90a\x1E\xE8\x90a\x1E\xD4\x90a\"\xF3V[3_\x90\x81R`\xFD` R`@\x90 \x90a-\xC8V[a\x01\x01T\x90\x91Pa\x1F\x03\x90`\x01`\x01`\xA0\x1B\x03\x163\x83a(ZV[`@Q\x81\x81R3\x90\x7F\x9E\\O\x9FNF\xB8b\x9D=\xDA\x85\xF4:i\x19OP%D\x04\xA7-\xC6+\x9E\x93-\x9C\x94\xED\xA8\x90` \x01a\x1D\x0BV[_\x81\x81R`\x97` R`@\x81 a\n\xD5\x90a.fV[\x7F\x19\xE6\xF2=\xF7'[H\xD1\xC38\"\xC6\xAD\x04\x1At3xU\"F\xAC\x81\x9FW\x8A\xE1\xD6p\x9C\xF9a\x1Fu\x81a%MV[_a\x1F\x80`\xFEa.oV[P\x80T`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x82\x16``\x82\x01R\x92\x93Pa\x1F\xE2\x92\x91`\x01`\xA0\x1B\x90\x04\x16a.\xB1V[\x15a \x19W`@Q\x7FO\0ix\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\r\xB2\x83a/cV[_\x82\x81R`e` R`@\x90 `\x01\x01Ta <\x81a%MV[a\r\xB2\x83\x83a%\xDFV[_\x80a R`\xFEa.oV[P\x80T`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x82\x16``\x82\x01R\x92\x93Pa \xB4\x92\x91`\x01`\xA0\x1B\x90\x04\x16a.\xB1V[\x91PP\x90V[\x7F\xB0ug\xE7\">!\xF7\xDC\xE4\xC0\xA8\x911\xCE\x9C2\xD0\xD3H@\x85\xF3\xF31\xDE\xA8\xCA\xEFV\xD1Aa \xE4\x81a%MV[a\x01\x03T`@\x80Q\x91\x82R` \x82\x01\x84\x90R\x7FXH\x06\x8F\x11\xAA;\xA9\xFE?\xC3<_\x9F*<\xD1\xAE\xD6y\x86\xB8[^\x0C\xED\xC6}\xBE\x96\xF0\xF0\x91\x01`@Q\x80\x91\x03\x90\xA1a\x01\x03\x82\x90Ua\x01\x02T\x82\x11\x15a\x0E?Wa\x0E?\x82a/cV[_a\r\x89a/\xF2V[\x7Fm\x8D\xADq\x88\xC7\xED\0\\U\xBFw\xFB\xF5\x89X=\x86h\xB0\xDA\xD3\n\x9B\x9D\xD0\x162\x1A\\%oa!n\x81a%MV[`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01R_a!\xC3\x82a\"\xF3V[\x90P_a!\xDDa!\xD86\x87\x90\x03\x87\x01\x87aBbV[a\"\xF3V[\x90P\x80g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\"@W`@Q\x7Fh\xC1\x8C\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x84\x16`\x04\x83\x01R\x82\x16`$\x82\x01R`D\x01a\x08\xABV[_a\"Va\"O\x84`\x01a@{V[\x85\x90a#\xC4V[P\x90P_a\"}a\"h\x84`\x01a@{V[a\"w6\x8A\x90\x03\x8A\x01\x8AaBbV[\x90a#\xC4V[P\x90P\x80g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\"\xE1W`@Q\x7F\xA0\xE2i\xD8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x84\x16`\x04\x83\x01R\x82\x16`$\x82\x01R`D\x01a\x08\xABV[a\"\xEA\x87a)\xFAV[PPPPPPPV[\x80Q_\x90`\x07\x90\x81\x0BB\x90\x91\x0B\x12\x15a#\rWP_\x91\x90PV[` \x82\x01Q\x82Qa#\x1D\x90a0kV[a\n\xD5\x91\x90aB\xF9V[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x83\x82\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a#XW\x82_[\x01\x90Pa\n\xD5V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x83`\x01\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a#\x86W\x82`\x01a#PV[`@Q\x7F\xFB\xB0R\xD8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16`\x04\x82\x01R`$\x01a\x08\xABV[_\x80_\x83\x85` \x01Qa#\xD7\x91\x90aC\x1FV[\x85Qa#\xE3\x91\x90aCKV[\x90P_\x81`\x07\x0B\x12\x15a$(W`@Q\x7F\xF1`\xADy\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x07\x82\x90\x0B`\x04\x82\x01R`$\x01a\x08\xABV[` \x85\x01Q\x81\x90_\x90`\x01\x90a$>\x90\x84a@{V[a$H\x91\x90aCzV[\x91\x94P\x90\x92PPP[\x92P\x92\x90PV[_`\x01`\x01`\xE0\x1B\x03\x19\x82\x16\x7Fye\xDB\x0B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x14\x80a\n\xD5WP\x7F\x01\xFF\xC9\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xE0\x1B\x03\x19\x83\x16\x14a\n\xD5V[`\x01\x82\x01T_\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16\x90\x83\x16\x10\x15a$\xE0W_a\x0B\xCBV[PPT\x90V[_a\n\xD5a$\xF2a/\xF2V[\x83`@Q\x7F\x19\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01R`\"\x81\x01\x83\x90R`B\x81\x01\x82\x90R_\x90`b\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x92\x91PPV[a\x12\x93\x813a0vV[\x80Q_\x90`\x07\x90\x81\x0BB\x90\x91\x0B\x12\x15a%qWP_\x91\x90PV[_a%~\x83_\x01Qa0kV[\x90P_\x83` \x01Q\x82a%\x91\x91\x90aC\x9BV[\x90P\x83`@\x01Q\x84` \x01Qa%\xA7\x91\x90aCzV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16\x91\x16\x10\x15\x93\x92PPPV[a%\xC8\x82\x82a0\xF5V[_\x82\x81R`\x97` R`@\x90 a\r\xB2\x90\x82a1\x95V[a%\xE9\x82\x82a1\xA9V[_\x82\x81R`\x97` R`@\x90 a\r\xB2\x90\x82a2*V[_\x80_a&\x15\x84\x86_\x01Q\x87` \x01Qa\x0BRV[\x90P_a&/\x86`@\x01Q\x83a2>\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x90P_a&=`\x01\x87aCzV[` \x80\x89\x01Q`\x01`\x01`\xA0\x1B\x03\x85\x16_\x90\x81R`\xFD\x90\x92R`@\x90\x91 \x91\x92P\x90a&i\x90\x83a(CV[\x10\x15a&\xE5W` \x80\x88\x01Q`\x01`\x01`\xA0\x1B\x03\x84\x16_\x90\x81R`\xFD\x90\x92R`@\x90\x91 \x83\x91\x90a&\x9A\x90\x84a(CV[`@Q\x7F6\xB2L\x14\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x90\x93\x16`\x04\x84\x01R`$\x83\x01\x91\x90\x91R`D\x82\x01R`d\x01a\x08\xABV[P\x95\x90\x94P\x92PPPV[_a&\xFC\x84`\x01a@{V[\x90Pa'\x18\x81a'\x0F` \x8A\x01\x8Aa>*V[`\xFE\x91\x90a2`V[`\x01`\x01`\xA0\x1B\x03\x86\x16_\x90\x81R`\xFD` R`@\x90 a':\x90\x86\x86a3OV[\x84a\x01\x05_\x82\x82Ta'L\x91\x90aC\xC1V[\x90\x91UP_\x90Pa'`` \x89\x01\x89a>*V[`@\x80Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x81\x16\x82R\x87\x81\x16` \x83\x01R\x86\x16\x81\x83\x01R\x90Q`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91_\x91\x7F\xB5\x9A\xDC\x82\x0C\xA6B\xDA\xD4\x93\xA0\xA6\xE0\xBD\xF9y\xDC\xAE\x03}\xEA\x11Kp\xD5\xC6k\x1C\x0By\x1CK\x91\x90\x81\x90\x03``\x01\x90\xA4a'\xC9` \x88\x01\x88a>*V[`@\x80Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x81\x16\x82R` \x8B\x81\x015\x90\x83\x01R\x81\x83\x01\x89\x90R\x86\x81\x16``\x83\x01R\x85\x16`\x80\x82\x01R\x90Q`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x92\x89\x16\x91\x8B\x15\x15\x91\x7F\x7F[\xDA\xBB\xD2z\x8F\xC5rx\x1B\x17pUH\x8D|g)\xA2\xBA\xDEOW\xDA\x9D \x0F1\xC1]G\x91\x81\x90\x03`\xA0\x01\x90\xA4PPPPPPPPV[_a(N\x83\x83a$\xBEV[\x83Ta\x0B\xCB\x91\x90aC\xD4V[`@Q`\x01`\x01`\xA0\x1B\x03\x83\x16`$\x82\x01R`D\x81\x01\x82\x90Ra\r\xB2\x90\x84\x90\x7F\xA9\x05\x9C\xBB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90`d\x01[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x01`\x01`\xE0\x1B\x03\x19\x90\x93\x16\x92\x90\x92\x17\x90\x91Ra3\xC6V[_a\x0B\xCB\x83\x83a4\xAAV[_Ta\x01\0\x90\x04`\xFF\x16a)rW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7FInitializable: contract is not i`D\x82\x01R\x7Fnitializing\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08\xABV[V[_Ta\x01\0\x90\x04`\xFF\x16a)\xF0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7FInitializable: contract is not i`D\x82\x01R\x7Fnitializing\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08\xABV[a\x0E?\x82\x82a4\xD0V[a*\n``\x82\x01`@\x83\x01a?\xE7V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_\x03a*LW`@Q\x7F\x04{\xADR\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[b\x01Q\x80a*``@\x83\x01` \x84\x01a?\xE7V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11\x15a*\xBFWa*\x80`@\x82\x01` \x83\x01a?\xE7V[`@Q\x7F\xC3Jv\xCF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16`\x04\x82\x01R`$\x01a\x08\xABV[a*\xCF`@\x82\x01` \x83\x01a?\xE7V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a*\xE9``\x83\x01`@\x84\x01a?\xE7V[a*\xF9`\x80\x84\x01``\x85\x01a?\xE7V[a+\x03\x91\x90a@{V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11\x15a+EW`@Q\x7F2m\xE3`\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x80a\x01\x04a+S\x82\x82aC\xE7V[P\x7F\x98,\xFBsx;\x8CdE\\v\xCD\xEB\x13QF|O\x1Ek6\x15\xFE\xC0}\xF22\xC1\xB4o\xFDG\x90Pa+\x89a!\xD86\x84\x90\x03\x84\x01\x84aBbV[a+\x96` \x84\x01\x84aA\xCBV[a+\xA6`@\x85\x01` \x86\x01a?\xE7V[a+\xB6``\x86\x01`@\x87\x01a?\xE7V[a+\xC6`\x80\x87\x01``\x88\x01a?\xE7V[`@\x80Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x96\x87\x16\x81R`\x07\x95\x90\x95\x0B` \x86\x01R\x92\x85\x16\x84\x84\x01R\x90\x84\x16``\x84\x01R\x90\x92\x16`\x80\x82\x01R\x90Q\x90\x81\x90\x03`\xA0\x01\x90\xA1PV[a,\x12\x84\x84a%\xBEV[a,\x1C\x82\x82a%\xBEV[a,&\x84\x83a5fV[PPPPV[\x81T_\x03a,MW`@Qc\x1F* \x05`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE\x19g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x01a,\x99W`@Q\x7F=\x89\xDD\xDE\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01\x82\x01Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16\x14a,\xE1W`@Q\x7F\x04\xEBk?\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01\x91\x90\x91\x01\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x92\x16\x91\x90\x91\x17\x90UV[\x80_\x03a-(W`@Qc\x1F* \x05`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01\x82\x01Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16\x14a-\\W`\x01\x82\x01\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x17\x90U[\x80\x82_\x01_\x82\x82Ta-n\x91\x90aC\xC1V[\x90\x91UPPPPV[`@Q`\x01`\x01`\xA0\x1B\x03\x80\x85\x16`$\x83\x01R\x83\x16`D\x82\x01R`d\x81\x01\x82\x90Ra,&\x90\x85\x90\x7F#\xB8r\xDD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90`\x84\x01a(\x9FV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE\x19g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16\x01a.\x15W`@Q\x7F=\x89\xDD\xDE\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a. \x84\x84a$\xBEV[\x90P\x80_\x03a.[W`@Q\x7F\xD0\xD0O`\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x84U\x90P\x92\x91PPV[_a\n\xD5\x82T\x90V[_\x80\x80\x83\x81\x01\x90P_\x84`\x01\x01T\x82Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`\xA0\x1B\x92\x83\x90\x04\x81\x16\x92\x90\x91\x04\x16\x10\x15a.\xA7WPP`\x01\x80\x84\x01\x90[\x90\x94\x90\x93P\x91PPV[\x81Q_\x90`\x07\x90\x81\x0BB\x90\x91\x0B\x12\x15a.\xCBWP_a\n\xD5V[_a.\xD5\x84a\"\xF3V[\x90Pa.\xE2\x81`\x01a@{V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10a/\x05W_\x91PPa\n\xD5V[_a/\x12\x85_\x01Qa0kV[\x90P_\x85` \x01Q\x82a/%\x91\x90aC\x9BV[\x90P\x85``\x01Q\x86`@\x01Q\x87` \x01Qa/@\x91\x90aCzV[a/J\x91\x90aCzV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16\x91\x16\x10\x15\x95\x94PPPPPV[a\x01\x03T\x81\x10\x15a/\xAFWa\x01\x03T`@Q\x7F\xDAO'.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Ra\x08\xAB\x91\x83\x91`\x04\x01\x91\x82R` \x82\x01R`@\x01\x90V[a\x01\x02T`@\x80Q\x91\x82R` \x82\x01\x83\x90R\x7F\x97%\xE3~\x07\x9C[\xDA`\t\xA8\xF5M\x86&XI\xF3\n\xCFa\xC60\xF9\xE1\xAC\x91\xE6}\xE9\x87\x94\x91\x01`@Q\x80\x91\x03\x90\xA1a\x01\x02UV[_a\r\x89\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0Fa0 `\xC9T\x90V[`\xCAT`@\x80Q` \x81\x01\x85\x90R\x90\x81\x01\x83\x90R``\x81\x01\x82\x90RF`\x80\x82\x01R0`\xA0\x82\x01R_\x90`\xC0\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x93\x92PPPV[_a\n\xD5\x82BaD\xDDV[_\x82\x81R`e` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x84R\x90\x91R\x90 T`\xFF\x16a\x0E?Wa0\xB3\x81`\x01`\x01`\xA0\x1B\x03\x16`\x14a5\xB0V[a0\xBE\x83` a5\xB0V[`@Q` \x01a0\xCF\x92\x91\x90aE#V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90RbF\x1B\xCD`\xE5\x1B\x82Ra\x08\xAB\x91`\x04\x01aE\x8DV[_\x82\x81R`e` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x84R\x90\x91R\x90 T`\xFF\x16a\x0E?W_\x82\x81R`e` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x84R\x90\x91R\x90 \x80T`\xFF\x19\x16`\x01\x17\x90Ua1Q3\x90V[`\x01`\x01`\xA0\x1B\x03\x16\x81`\x01`\x01`\xA0\x1B\x03\x16\x83\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r`@Q`@Q\x80\x91\x03\x90\xA4PPV[_a\x0B\xCB\x83`\x01`\x01`\xA0\x1B\x03\x84\x16a7\xD3V[_\x82\x81R`e` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x84R\x90\x91R\x90 T`\xFF\x16\x15a\x0E?W_\x82\x81R`e` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x80\x85R\x92R\x80\x83 \x80T`\xFF\x19\x16\x90UQ3\x92\x85\x91\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x91\x90\xA4PPV[_a\x0B\xCB\x83`\x01`\x01`\xA0\x1B\x03\x84\x16a8\x1FV[_\x80_a2K\x85\x85a9\tV[\x91P\x91Pa2X\x81a9HV[P\x93\x92PPPV[_\x80a2k\x85a.oV[\x81T\x91\x93P\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x86\x16`\x01`\xA0\x1B\x90\x92\x04\x16\x10a2\xCAW`@Q\x7FE\x1F\x874\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x16`\x04\x82\x01R`$\x01a\x08\xABV[`@\x80Q\x80\x82\x01\x90\x91R`\x01`\x01`\xA0\x1B\x03\x84\x16\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x16` \x82\x01R`\x01\x82\x18\x90\x86`\xFF\x83\x16`\x02\x81\x10a3\nWa3\na@SV[\x82Q\x91\x01\x80T` \x90\x93\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x01`\xA0\x1B\x02`\x01`\x01`\xE0\x1B\x03\x19\x90\x93\x16`\x01`\x01`\xA0\x1B\x03\x90\x92\x16\x91\x90\x91\x17\x91\x90\x91\x17\x90UPPPPPPV[_a3Z\x84\x83a(CV[\x90P\x80\x15\x80a3hWP\x82\x81\x10[\x15a3\xA9W`@Q\x7F\xCFG\x91\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x84\x90R`$\x81\x01\x82\x90R`D\x01a\x08\xABV[\x82\x84_\x01_\x82\x82Ta3\xBB\x91\x90aC\xD4V[\x90\x91UPPPPPPV[_a4\x1A\x82`@Q\x80`@\x01`@R\x80` \x81R` \x01\x7FSafeERC20: low-level call failed\x81RP\x85`\x01`\x01`\xA0\x1B\x03\x16a;3\x90\x92\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x80Q\x90\x91P\x15a\r\xB2W\x80\x80` \x01\x90Q\x81\x01\x90a48\x91\x90aE\xC2V[a\r\xB2W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`*`$\x82\x01R\x7FSafeERC20: ERC20 operation did n`D\x82\x01R\x7Fot succeed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08\xABV[_\x82_\x01\x82\x81T\x81\x10a4\xBFWa4\xBFa@SV[\x90_R` _ \x01T\x90P\x92\x91PPV[_Ta\x01\0\x90\x04`\xFF\x16a5LW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7FInitializable: contract is not i`D\x82\x01R\x7Fnitializing\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08\xABV[\x81Q` \x92\x83\x01 \x81Q\x91\x90\x92\x01 `\xC9\x91\x90\x91U`\xCAUV[_\x82\x81R`e` R`@\x80\x82 `\x01\x01\x80T\x90\x84\x90U\x90Q\x90\x91\x83\x91\x83\x91\x86\x91\x7F\xBDy\xB8o\xFE\n\xB8\xE8waQQB\x17\xCD|\xAC\xD5,\x90\x9FfG\\:\xF4N\x12\x9F\x0B\0\xFF\x91\x90\xA4PPPV[``_a5\xBE\x83`\x02aE\xE1V[a5\xC9\x90`\x02aC\xC1V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a5\xE1Wa5\xE1a@\x9CV[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a6\x0BW` \x82\x01\x81\x806\x837\x01\x90P[P\x90P\x7F0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81_\x81Q\x81\x10a6AWa6Aa@SV[` \x01\x01\x90~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x90\x81_\x1A\x90SP\x7Fx\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81`\x01\x81Q\x81\x10a6\xA3Wa6\xA3a@SV[` \x01\x01\x90~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x90\x81_\x1A\x90SP_a6\xDD\x84`\x02aE\xE1V[a6\xE8\x90`\x01aC\xC1V[\x90P[`\x01\x81\x11\x15a7\x84W\x7F0123456789abcdef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85`\x0F\x16`\x10\x81\x10a7)Wa7)a@SV[\x1A`\xF8\x1B\x82\x82\x81Q\x81\x10a7?Wa7?a@SV[` \x01\x01\x90~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x90\x81_\x1A\x90SP`\x04\x94\x90\x94\x1C\x93a7}\x81aE\xF8V[\x90Pa6\xEBV[P\x83\x15a\x0B\xCBW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FStrings: hex length insufficient`D\x82\x01R`d\x01a\x08\xABV[_\x81\x81R`\x01\x83\x01` R`@\x81 Ta8\x18WP\x81T`\x01\x81\x81\x01\x84U_\x84\x81R` \x80\x82 \x90\x93\x01\x84\x90U\x84T\x84\x82R\x82\x86\x01\x90\x93R`@\x90 \x91\x90\x91Ua\n\xD5V[P_a\n\xD5V[_\x81\x81R`\x01\x83\x01` R`@\x81 T\x80\x15a8\xF9W_a8A`\x01\x83aC\xD4V[\x85T\x90\x91P_\x90a8T\x90`\x01\x90aC\xD4V[\x90P\x81\x81\x14a8\xB3W_\x86_\x01\x82\x81T\x81\x10a8rWa8ra@SV[\x90_R` _ \x01T\x90P\x80\x87_\x01\x84\x81T\x81\x10a8\x92Wa8\x92a@SV[_\x91\x82R` \x80\x83 \x90\x91\x01\x92\x90\x92U\x91\x82R`\x01\x88\x01\x90R`@\x90 \x83\x90U[\x85T\x86\x90\x80a8\xC4Wa8\xC4aF,V[`\x01\x90\x03\x81\x81\x90_R` _ \x01_\x90U\x90U\x85`\x01\x01_\x86\x81R` \x01\x90\x81R` \x01_ _\x90U`\x01\x93PPPPa\n\xD5V[_\x91PPa\n\xD5V[P\x92\x91PPV[_\x80\x82Q`A\x03a9=W` \x83\x01Q`@\x84\x01Q``\x85\x01Q_\x1Aa91\x87\x82\x85\x85a;AV[\x94P\x94PPPPa$QV[P_\x90P`\x02a$QV[_\x81`\x04\x81\x11\x15a9[Wa9[aF@V[\x03a9cWPV[`\x01\x81`\x04\x81\x11\x15a9wWa9waF@V[\x03a9\xC4W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x18`$\x82\x01R\x7FECDSA: invalid signature\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x08\xABV[`\x02\x81`\x04\x81\x11\x15a9\xD8Wa9\xD8aF@V[\x03a:%W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1F`$\x82\x01R\x7FECDSA: invalid signature length\0`D\x82\x01R`d\x01a\x08\xABV[`\x03\x81`\x04\x81\x11\x15a:9Wa:9aF@V[\x03a:\xACW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7FECDSA: invalid signature 's' val`D\x82\x01R\x7Fue\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08\xABV[`\x04\x81`\x04\x81\x11\x15a:\xC0Wa:\xC0aF@V[\x03a\x12\x93W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7FECDSA: invalid signature 'v' val`D\x82\x01R\x7Fue\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08\xABV[``a\x0B\xC8\x84\x84_\x85a<&V[_\x80\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0\x83\x11\x15a;vWP_\x90P`\x03a<\x1DV[\x84`\xFF\x16`\x1B\x14\x15\x80\x15a;\x8EWP\x84`\xFF\x16`\x1C\x14\x15[\x15a;\x9EWP_\x90P`\x04a<\x1DV[`@\x80Q_\x80\x82R` \x82\x01\x80\x84R\x89\x90R`\xFF\x88\x16\x92\x82\x01\x92\x90\x92R``\x81\x01\x86\x90R`\x80\x81\x01\x85\x90R`\x01\x90`\xA0\x01` `@Q` \x81\x03\x90\x80\x84\x03\x90\x85Z\xFA\x15\x80\x15a;\xEFW=_\x80>=_\xFD[PP`@Q`\x1F\x19\x01Q\x91PP`\x01`\x01`\xA0\x1B\x03\x81\x16a<\x17W_`\x01\x92P\x92PPa<\x1DV[\x91P_\x90P[\x94P\x94\x92PPPV[``\x82G\x10\x15a<\x9EW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FAddress: insufficient balance fo`D\x82\x01R\x7Fr call\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08\xABV[`\x01`\x01`\xA0\x1B\x03\x85\x16;a<\xF5W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FAddress: call to non-contract\0\0\0`D\x82\x01R`d\x01a\x08\xABV[_\x80\x86`\x01`\x01`\xA0\x1B\x03\x16\x85\x87`@Qa=\x10\x91\x90aFTV[_`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80_\x81\x14a=JW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a=OV[``\x91P[P\x91P\x91Pa=_\x82\x82\x86a=jV[\x97\x96PPPPPPPV[``\x83\x15a=yWP\x81a\x0B\xCBV[\x82Q\x15a=\x89W\x82Q\x80\x84` \x01\xFD[\x81`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x08\xAB\x91\x90aE\x8DV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x12\x93W_\x80\xFD[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x12\x93W_\x80\xFD[_\x80`@\x83\x85\x03\x12\x15a=\xDDW_\x80\xFD[\x825a=\xE8\x81a=\xA3V[\x91P` \x83\x015a=\xF8\x81a=\xB8V[\x80\x91PP\x92P\x92\x90PV[_` \x82\x84\x03\x12\x15a>\x13W_\x80\xFD[\x815`\x01`\x01`\xE0\x1B\x03\x19\x81\x16\x81\x14a\x0B\xCBW_\x80\xFD[_` \x82\x84\x03\x12\x15a>:W_\x80\xFD[\x815a\x0B\xCB\x81a=\xB8V[_\x80_``\x84\x86\x03\x12\x15a>WW_\x80\xFD[\x835a>b\x81a=\xA3V[\x92P` \x84\x015a>r\x81a=\xB8V[\x92\x95\x92\x94PPP`@\x91\x90\x91\x015\x90V[\x82Q`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x80\x84\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x82\x01R`\x80\x81\x01\x82Q`\x01`\x01`\xA0\x1B\x03\x16`@\x83\x01R` \x83\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16``\x83\x01Ra\x0B\xCBV[_` \x82\x84\x03\x12\x15a>\xE1W_\x80\xFD[P5\x91\x90PV[_\x80`@\x83\x85\x03\x12\x15a>\xF9W_\x80\xFD[\x825\x91P` \x83\x015a=\xF8\x81a=\xB8V[_``\x82\x84\x03\x12\x15a?\x1BW_\x80\xFD[P\x91\x90PV[_\x80`@\x83\x85\x03\x12\x15a?2W_\x80\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a?IW_\x80\xFD[a?U\x86\x83\x87\x01a?\x0BV[\x93P` \x85\x015\x91P\x80\x82\x11\x15a?jW_\x80\xFD[Pa?w\x85\x82\x86\x01a?\x0BV[\x91PP\x92P\x92\x90PV[_\x80`@\x83\x85\x03\x12\x15a?\x92W_\x80\xFD[\x825a?\x9D\x81a=\xB8V[\x91P` \x83\x015a=\xF8\x81a=\xA3V[_` \x82\x84\x03\x12\x15a?\xBDW_\x80\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a?\xD3W_\x80\xFD[a?\xDF\x84\x82\x85\x01a?\x0BV[\x94\x93PPPPV[_` \x82\x84\x03\x12\x15a?\xF7W_\x80\xFD[\x815a\x0B\xCB\x81a=\xA3V[_\x80`@\x83\x85\x03\x12\x15a@\x13W_\x80\xFD[PP\x805\x92` \x90\x91\x015\x91PV[_a\x01\xE0\x82\x84\x03\x12\x15a?\x1BW_\x80\xFD[_`@\x82\x84\x03\x12\x15a?\x1BW_\x80\xFD[_`\x80\x82\x84\x03\x12\x15a?\x1BW_\x80\xFD[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x81\x16\x83\x82\x16\x01\x90\x80\x82\x11\x15a9\x02Wa9\x02a@gV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Q``\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a@\xD3Wa@\xD3a@\x9CV[`@R\x90V[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15aA\x02WaA\x02a@\x9CV[`@R\x91\x90PV[_``\x826\x03\x12\x15aA\x1AW_\x80\xFD[aA\"a@\xB0V[\x825aA-\x81a=\xB8V[\x81R` \x83\x81\x015\x81\x83\x01R`@\x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15aASW_\x80\xFD[\x90\x85\x01\x906`\x1F\x83\x01\x12aAeW_\x80\xFD[\x815\x81\x81\x11\x15aAwWaAwa@\x9CV[aA\x89\x84`\x1F\x19`\x1F\x84\x01\x16\x01a@\xD9V[\x91P\x80\x82R6\x84\x82\x85\x01\x01\x11\x15aA\x9EW_\x80\xFD[\x80\x84\x84\x01\x85\x84\x017_\x90\x82\x01\x90\x93\x01\x92\x90\x92RP`@\x82\x01R\x92\x91PPV[\x80`\x07\x0B\x81\x14a\x12\x93W_\x80\xFD[_` \x82\x84\x03\x12\x15aA\xDBW_\x80\xFD[\x815a\x0B\xCB\x81aA\xBDV[\x815aA\xF1\x81a=\xB8V[`\x01`\x01`\xA0\x1B\x03\x81\x16\x90P\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x82\x16\x17\x83U` \x84\x015aB)\x81a=\xA3V[{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81`\xA0\x1B\x16\x83`\x01`\x01`\xE0\x1B\x03\x19\x84\x16\x17\x17\x84UPPPPPV[_`\x80\x82\x84\x03\x12\x15aBrW_\x80\xFD[`@Q`\x80\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15aB\x95WaB\x95a@\x9CV[`@R\x825aB\xA3\x81aA\xBDV[\x81R` \x83\x015aB\xB3\x81a=\xA3V[` \x82\x01R`@\x83\x015aB\xC6\x81a=\xA3V[`@\x82\x01R``\x83\x015aB\xD9\x81a=\xA3V[``\x82\x01R\x93\x92PPPV[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x84\x16\x80aC\x13WaC\x13aB\xE5V[\x92\x16\x91\x90\x91\x04\x92\x91PPV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x81\x16\x83\x82\x16\x02\x80\x82\x16\x91\x90\x82\x81\x14aCCWaCCa@gV[PP\x92\x91PPV[`\x07\x81\x81\x0B\x90\x83\x90\x0B\x01g\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x13g\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x82\x12\x17\x15a\n\xD5Wa\n\xD5a@gV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x81\x16\x82\x82\x16\x03\x90\x80\x82\x11\x15a9\x02Wa9\x02a@gV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x84\x16\x80aC\xB5WaC\xB5aB\xE5V[\x92\x16\x91\x90\x91\x06\x92\x91PPV[\x80\x82\x01\x80\x82\x11\x15a\n\xD5Wa\n\xD5a@gV[\x81\x81\x03\x81\x81\x11\x15a\n\xD5Wa\n\xD5a@gV[\x815aC\xF2\x81aA\xBDV[\x81Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x81\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x83\x16\x17\x84U` \x85\x015aD\x1D\x81a=\xA3V[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0`@\x91\x82\x1B\x16\x91\x90\x93\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83\x16\x81\x17\x82\x17\x85U\x92\x85\x015\x90aDo\x82a=\xA3V[w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82`\x80\x1B\x16\x91P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x85\x82\x86\x16\x17\x83\x17\x17\x86U``\x87\x015\x93PaD\xCB\x84a=\xA3V[\x93\x17\x17`\xC0\x91\x90\x91\x1B\x90\x91\x16\x17\x90UPV[`\x07\x82\x81\x0B\x90\x82\x90\x0B\x03g\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x81\x12g\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x13\x17\x15a\n\xD5Wa\n\xD5a@gV[_\x81Q\x80` \x84\x01\x85^_\x93\x01\x92\x83RP\x90\x91\x90PV[\x7FAccessControl: account \0\0\0\0\0\0\0\0\0\x81R_aET`\x17\x83\x01\x85aE\x0CV[\x7F is missing role \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RaE\x84`\x11\x82\x01\x85aE\x0CV[\x95\x94PPPPPV[` \x81R_\x82Q\x80` \x84\x01R\x80` \x85\x01`@\x85\x01^_`@\x82\x85\x01\x01R`@`\x1F\x19`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x92\x91PPV[_` \x82\x84\x03\x12\x15aE\xD2W_\x80\xFD[\x81Q\x80\x15\x15\x81\x14a\x0B\xCBW_\x80\xFD[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\n\xD5Wa\n\xD5a@gV[_\x81aF\x06WaF\x06a@gV[P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x01\x90V[cNH{q`\xE0\x1B_R`1`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[_a\x0B\xCB\x82\x84aE\x0CV\xFE\xA2dipfsX\"\x12 '\0KM\x966\xDA|\xC5\x18\xF5H\xAA6\xAE\x81\xF3\x8E\x90\x95w`\xB4\xAD\x93\xD5\xDB\x05^\x9B\xA0\xA3dsolcC\0\x08\x19\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f80fd5b5060043610610303575f3560e01c80637b617f941161019d578063c5b6aa2f116100e8578063e2fc6f6811610093578063e4d20c1d1161006e578063e4d20c1d146107c8578063f698da25146107db578063fed87be8146107e3575f80fd5b8063e2fc6f681461078f578063e3f7bb5514610799578063e460d2c5146107c0575f80fd5b8063cfe9232b116100c3578063cfe9232b1461074b578063d547741f14610772578063db2e1eed14610785575f80fd5b8063c5b6aa2f1461071d578063ca15c87314610725578063ce9c7c0d14610738575f80fd5b80639a1fadd311610148578063b51d1d4f11610123578063b51d1d4f146106ef578063b6b55f25146106f7578063bef0ec741461070a575f80fd5b80639a1fadd3146106ae578063a217fddf146106c1578063b3ee252f146106c8575f80fd5b80638a19c8bc116101785780638a19c8bc146106425780639010d07c1461066357806391d1485414610676575f80fd5b80637b617f94146105dd57806383af0a1f146106115780638948cc4e1461061b575f80fd5b80632f2ff15d1161025d578063639d7566116102085780636dc4fc4e116101e35780636dc4fc4e146105a45780636e8cace5146105b757806370a08231146105ca575f80fd5b8063639d7566146105245780636a514beb146105385780636ad725171461059c575f80fd5b806338af3eed1161023857806338af3eed146104d2578063447a709e146104fe5780635633c33714610511575f80fd5b80632f2ff15d14610485578063336a5b5e1461049857806336568abe146104bf575f80fd5b80630d253fbe116102bd5780631c31f710116102985780631c31f71014610448578063248a9ca31461045b5780632d668ce71461047d575f80fd5b80630d253fbe146103e457806314d96316146103fa5780631682e50b14610421575f80fd5b806301ffc9a7116102ed57806301ffc9a71461038d57806302b62938146103b057806304c584ad146103d1575f80fd5b80627be2fe146103075780630152682d1461031c575b5f80fd5b61031a610315366004613dcc565b6107f6565b005b6101045461035390600781900b9067ffffffffffffffff600160401b8204811691600160801b8104821691600160c01b9091041684565b6040805160079590950b855267ffffffffffffffff9384166020860152918316918401919091521660608201526080015b60405180910390f35b6103a061039b366004613e03565b610a98565b6040519015158152602001610384565b6103c36103be366004613e2a565b610adb565b604051908152602001610384565b6103c36103df366004613e45565b610b52565b6103ec610bd2565b604051610384929190613e83565b6103c37f3fb9f0655b78e8eabe9e0f51d65db56c7690d4329012c3faf1fbd6d43f65826181565b6103c37f6d8dad7188c7ed005c55bf77fbf589583d8668b0dad30a9b9dd016321a5c256f81565b61031a610456366004613e2a565b610c90565b6103c3610469366004613ed1565b5f9081526065602052604090206001015490565b6103a0610d33565b61031a610493366004613ee8565b610d8e565b6103c37fc1b97c934675624ef2089089ac12ae8922988c11dc8a578dfbac10d9eecf476181565b61031a6104cd366004613ee8565b610db7565b610100546104e6906001600160a01b031681565b6040516001600160a01b039091168152602001610384565b61031a61050c366004613f21565b610e43565b6103c361051f366004613f81565b61111c565b610101546104e6906001600160a01b031681565b610574610546366004613e2a565b6101066020525f90815260409020546001600160a01b03811690600160a01b900467ffffffffffffffff1682565b604080516001600160a01b03909316835267ffffffffffffffff909116602083015201610384565b61031a61124a565b61031a6105b2366004613fad565b611296565b6103c36105c5366004613f81565b6113f9565b6103c36105d8366004613e2a565b6114e1565b6105f06105eb366004613fe7565b611558565b6040805167ffffffffffffffff938416815292909116602083015201610384565b6103c36101035481565b6103c37fb07567e7223e21f7dce4c0a89131ce9c32d0d3484085f3f331dea8caef56d14181565b61064a6115ba565b60405167ffffffffffffffff9091168152602001610384565b6104e6610671366004614002565b611610565b6103a0610684366004613ee8565b5f9182526065602090815260408084206001600160a01b0393909316845291905290205460ff1690565b61031a6106bc366004614022565b611627565b6103c35f81565b6103c37f19e6f23df7275b48d1c33822c6ad041a743378552246ac819f578ae1d6709cf981565b61031a611be6565b61031a610705366004613ed1565b611cac565b61031a610718366004614033565b611d16565b61031a611e7a565b6103c3610733366004613ed1565b611f35565b61031a610746366004613ed1565b611f4b565b6103c37f1d693f62a755e2b3c6494da41af454605b9006057cb3c79b6adda1378f2a50a781565b61031a610780366004613ee8565b612022565b6103c36101025481565b6103c36101055481565b6103c37fa8131bb4589277d6866d942849029b416b39e61eb3969a32787130bbdd292a9681565b6103a0612046565b61031a6107d6366004613ed1565b6120ba565b6103c361213b565b61031a6107f1366004614043565b612144565b6040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b900490911660608201525f61084b826122f3565b90508067ffffffffffffffff168467ffffffffffffffff1610156108b4576040517f395f4fd600000000000000000000000000000000000000000000000000000000815267ffffffffffffffff8086166004830152821660248201526044015b60405180910390fd5b5f6108c060fe86612327565b80546001600160a01b039081165f81815261010660205260409020549293509116801561094f576001600160a01b038116331461094a576040517f7621d94a00000000000000000000000000000000000000000000000000000000815267ffffffffffffffff881660048201526001600160a01b03821660248201523360448201526064016108ab565b6109b2565b6001600160a01b03821633146109b2576040517f660af6d200000000000000000000000000000000000000000000000000000000815267ffffffffffffffff881660048201526001600160a01b03831660248201523360448201526064016108ab565b825473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0387161783555f806109e4878a6123c4565b90925090506001600160a01b0383166109fd57836109ff565b825b6001600160a01b0316886001600160a01b0316856001600160a01b03167fb59adc820ca642dad493a0a6e0bdf979dcae037dea114b70d5c66b1c0b791c4b8c4267ffffffffffffffff168767ffffffffffffffff1610610a5f5786610a61565b425b6040805167ffffffffffffffff938416815291831660208301529187168183015290519081900360600190a4505050505050505050565b5f6001600160e01b031982167f5a05180f000000000000000000000000000000000000000000000000000000001480610ad55750610ad582612458565b92915050565b6040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b900490911660608201525f90610ad590610b35906122f3565b6001600160a01b0384165f90815260fd60205260409020906124be565b604080517f0358b2b705d5c5ef47651be44f418326852a390f3b4c933661a5f4f0d8fa1ee3602082015267ffffffffffffffff8516918101919091526001600160a01b0383166060820152608081018290525f90610bc89060a001604051602081830303815290604052805190602001206124e6565b90505b9392505050565b604080518082019091525f8082526020820152604080518082019091525f808252602082015260fe60010154600160a01b900467ffffffffffffffff1660fe5f0154600160a01b900467ffffffffffffffff1611610c335760ff60fe610c38565b60fe60ff5b60408051808201825292546001600160a01b03808216855267ffffffffffffffff600160a01b928390048116602080880191909152845180860190955294549182168452919004169181019190915290939092509050565b7fc1b97c934675624ef2089089ac12ae8922988c11dc8a578dfbac10d9eecf4761610cba8161254d565b61010054604080516001600160a01b03928316815291841660208301527f8a0149b2f3ddf2c9ee85738165131d82babbb938f749321d59f75750afa7f4e6910160405180910390a150610100805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0392909216919091179055565b6040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b900490911660608201525f90610d8990612557565b905090565b5f82815260656020526040902060010154610da88161254d565b610db283836125be565b505050565b6001600160a01b0381163314610e355760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201527f20726f6c657320666f722073656c66000000000000000000000000000000000060648201526084016108ab565b610e3f82826125df565b5050565b7f1d693f62a755e2b3c6494da41af454605b9006057cb3c79b6adda1378f2a50a7610e6d8161254d565b6040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b90049091166060820152610ec181612557565b610ef7576040517fb9adeefd00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b826020013584602001351015610f39576040517fa234cb1900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6101025483602001351015610f8c57610102546040517f56f9b75a0000000000000000000000000000000000000000000000000000000081526020850135600482015260248101919091526044016108ab565b5f610f96826122f3565b90505f610fa482600161407b565b90505f80610fba610fb48961410a565b84612600565b915091505f80610fd389610fcd9061410a565b86612600565b91509150816001600160a01b0316846001600160a01b031603611022576040517ff4a3e48500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b88602001358a602001351480156110b357506040516bffffffffffffffffffffffff19606084901b1660208201526034810182905260540160408051808303601f190181529082905280516020918201206bffffffffffffffffffffffff19606088901b16918301919091526034820185905290605401604051602081830303815290604052805190602001205f1c105b156110ea576040517f9185a0ae00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f806110f689886123c4565b9150915061110e60018d888e602001358c87876126f0565b505050505050505050505050565b6040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b900490911660608201525f90611172906122f3565b67ffffffffffffffff168267ffffffffffffffff161015611229576040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b9004909116606082015282906111e3906122f3565b6040517f395f4fd600000000000000000000000000000000000000000000000000000000815267ffffffffffffffff9283166004820152911660248201526044016108ab565b6001600160a01b0383165f90815260fd60205260409020610bcb9083612843565b610105545f81900361126f57604051631f2a200560e01b815260040160405180910390fd5b5f610105556101005461010154611293916001600160a01b0391821691168361285a565b50565b7f1d693f62a755e2b3c6494da41af454605b9006057cb3c79b6adda1378f2a50a76112c08161254d565b6040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b9004909116606082015261131481612557565b61134a576040517fb9adeefd00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610102548360200135101561139d57610102546040517f56f9b75a0000000000000000000000000000000000000000000000000000000081526020850135600482015260248101919091526044016108ab565b5f6113a7826122f3565b90505f6113b582600161407b565b90505f6113ca6113c48761410a565b83612600565b5090505f806113d986856123c4565b915091506113ef5f8985610102548987876126f0565b5050505050505050565b6040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b900490911660608201525f9061144f906122f3565b67ffffffffffffffff168267ffffffffffffffff1610156114c0576040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b9004909116606082015282906111e3906122f3565b6001600160a01b0383165f90815260fd60205260409020610bcb90836124be565b6040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b900490911660608201525f90610ad59061153b906122f3565b6001600160a01b0384165f90815260fd6020526040902090612843565b6040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b900490911660608201525f9081906115b190846123c4565b91509150915091565b6040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b900490911660608201525f90610d89906122f3565b5f828152609760205260408120610bcb90836128eb565b5f54610100900460ff161580801561164557505f54600160ff909116105b8061165e5750303b15801561165e57505f5460ff166001145b6116d05760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a656400000000000000000000000000000000000060648201526084016108ab565b5f805460ff1916600117905580156116f1575f805461ff0019166101001790555b6001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016300361178f5760405162461bcd60e51b815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f64656c656761746563616c6c000000000000000000000000000000000000000060648201526084016108ab565b6117976128f6565b61180b6040518060400160405280601281526020017f457870726573734c616e6541756374696f6e00000000000000000000000000008152506040518060400160405280600181526020017f3100000000000000000000000000000000000000000000000000000000000000815250612974565b5f61181c6040840160208501613e2a565b6001600160a01b03160361185c576040517f3fb3c7af00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61186c6040830160208401613e2a565b610101805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b03929092169190911790556118aa6060830160408401613e2a565b610100805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b03929092169190911790557f8a0149b2f3ddf2c9ee85738165131d82babbb938f749321d59f75750afa7f4e65f61190a6060850160408601613e2a565b604080516001600160a01b0393841681529290911660208301520160405180910390a160e0820135610103819055604080515f815260208101929092527f5848068f11aa3ba9fe3fc33c5f9f2a3cd1aed67986b85b5e0cedc67dbe96f0f0910160405180910390a160e0820135610102819055604080515f815260208101929092527f9725e37e079c5bda6009a8f54d86265849f30acf61c630f9e1ac91e67de98794910160405180910390a15f6119c860808401606085016141cb565b60070b1215611a03576040517f16f46dfe00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b611a0f826060016129fa565b611a2a5f611a256101e085016101c08601613e2a565b6125be565b611a607fb07567e7223e21f7dce4c0a89131ce9c32d0d3484085f3f331dea8caef56d141611a2561014085016101208601613e2a565b611a967fc1b97c934675624ef2089089ac12ae8922988c11dc8a578dfbac10d9eecf4761611a256101a085016101808601613e2a565b611aff7f1d693f62a755e2b3c6494da41af454605b9006057cb3c79b6adda1378f2a50a7611ac76020850185613e2a565b7f3fb9f0655b78e8eabe9e0f51d65db56c7690d4329012c3faf1fbd6d43f658261611afa61012087016101008801613e2a565b612c08565b611b687f19e6f23df7275b48d1c33822c6ad041a743378552246ac819f578ae1d6709cf9611b3561016085016101408601613e2a565b7fa8131bb4589277d6866d942849029b416b39e61eb3969a32787130bbdd292a96611afa61018087016101608801613e2a565b611b9e7f6d8dad7188c7ed005c55bf77fbf589583d8668b0dad30a9b9dd016321a5c256f611a256101c085016101a08601613e2a565b8015610e3f575f805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15050565b6040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b900490911660608201525f90611c3c906122f3565b611c4790600261407b565b335f90815260fd602052604090208054919250611c649083612c2c565b6040805182815267ffffffffffffffff8416602082015233917f31f69201fab7912e3ec9850e3ab705964bf46d9d4276bdcbb6d05e965e5f5401910160405180910390a25050565b335f90815260fd60205260409020611cc49082612d08565b61010154611cdd906001600160a01b0316333084612d77565b60405181815233907fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c906020015b60405180910390a250565b335f9081526101066020526040902080546001600160a01b031615801590611da857506040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b90049091166060820152611d8d906122f3565b815467ffffffffffffffff918216600160a01b909104909116115b15611df45780546040517f75d899f2000000000000000000000000000000000000000000000000000000008152600160a01b90910467ffffffffffffffff1660048201526024016108ab565b335f908152610106602052604090208290611e0f82826141e6565b50611e1f90506020830183613e2a565b6001600160a01b0316337ff6d28df235d9fa45a42d45dbb7c4f4ac76edb51e528f09f25a0650d32b8b33c0611e5a6040860160208701613fe7565b60405167ffffffffffffffff909116815260200160405180910390a35050565b6040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b900490911660608201525f90611ee890611ed4906122f3565b335f90815260fd6020526040902090612dc8565b61010154909150611f03906001600160a01b0316338361285a565b60405181815233907f9e5c4f9f4e46b8629d3dda85f43a69194f50254404a72dc62b9e932d9c94eda890602001611d0b565b5f818152609760205260408120610ad590612e66565b7f19e6f23df7275b48d1c33822c6ad041a743378552246ac819f578ae1d6709cf9611f758161254d565b5f611f8060fe612e6f565b5080546040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b900482166060820152929350611fe29291600160a01b900416612eb1565b15612019576040517f4f00697800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610db283612f63565b5f8281526065602052604090206001015461203c8161254d565b610db283836125df565b5f8061205260fe612e6f565b5080546040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b9004821660608201529293506120b49291600160a01b900416612eb1565b91505090565b7fb07567e7223e21f7dce4c0a89131ce9c32d0d3484085f3f331dea8caef56d1416120e48161254d565b6101035460408051918252602082018490527f5848068f11aa3ba9fe3fc33c5f9f2a3cd1aed67986b85b5e0cedc67dbe96f0f0910160405180910390a161010382905561010254821115610e3f57610e3f82612f63565b5f610d89612ff2565b7f6d8dad7188c7ed005c55bf77fbf589583d8668b0dad30a9b9dd016321a5c256f61216e8161254d565b6040805160808101825261010454600781900b825267ffffffffffffffff600160401b820481166020840152600160801b8204811693830193909352600160c01b900490911660608201525f6121c3826122f3565b90505f6121dd6121d836879003870187614262565b6122f3565b90508067ffffffffffffffff168267ffffffffffffffff1614612240576040517f68c18ca900000000000000000000000000000000000000000000000000000000815267ffffffffffffffff8084166004830152821660248201526044016108ab565b5f61225661224f84600161407b565b85906123c4565b5090505f61227d61226884600161407b565b612277368a90038a018a614262565b906123c4565b5090508067ffffffffffffffff168267ffffffffffffffff16146122e1576040517fa0e269d800000000000000000000000000000000000000000000000000000000815267ffffffffffffffff8084166004830152821660248201526044016108ab565b6122ea876129fa565b50505050505050565b80515f90600790810b4290910b121561230d57505f919050565b6020820151825161231d9061306b565b610ad591906142f9565b5f67ffffffffffffffff821683820154600160a01b900467ffffffffffffffff160361235857825f5b019050610ad5565b67ffffffffffffffff82168360010154600160a01b900467ffffffffffffffff160361238657826001612350565b6040517ffbb052d800000000000000000000000000000000000000000000000000000000815267ffffffffffffffff831660048201526024016108ab565b5f805f8385602001516123d7919061431f565b85516123e3919061434b565b90505f8160070b1215612428576040517ff160ad79000000000000000000000000000000000000000000000000000000008152600782900b60048201526024016108ab565b602085015181905f9060019061243e908461407b565b612448919061437a565b91945090925050505b9250929050565b5f6001600160e01b031982167f7965db0b000000000000000000000000000000000000000000000000000000001480610ad557507f01ffc9a7000000000000000000000000000000000000000000000000000000006001600160e01b0319831614610ad5565b60018201545f9067ffffffffffffffff90811690831610156124e0575f610bcb565b50505490565b5f610ad56124f2612ff2565b836040517f1901000000000000000000000000000000000000000000000000000000000000602082015260228101839052604281018290525f9060620160405160208183030381529060405280519060200120905092915050565b6112938133613076565b80515f90600790810b4290910b121561257157505f919050565b5f61257e835f015161306b565b90505f836020015182612591919061439b565b9050836040015184602001516125a7919061437a565b67ffffffffffffffff908116911610159392505050565b6125c882826130f5565b5f828152609760205260409020610db29082613195565b6125e982826131a9565b5f828152609760205260409020610db2908261322a565b5f805f61261584865f01518760200151610b52565b90505f61262f86604001518361323e90919063ffffffff16565b90505f61263d60018761437a565b6020808901516001600160a01b0385165f90815260fd9092526040909120919250906126699083612843565b10156126e5576020808801516001600160a01b0384165f90815260fd909252604090912083919061269a9084612843565b6040517f36b24c140000000000000000000000000000000000000000000000000000000081526001600160a01b039093166004840152602483019190915260448201526064016108ab565b509590945092505050565b5f6126fc84600161407b565b90506127188161270f60208a018a613e2a565b60fe9190613260565b6001600160a01b0386165f90815260fd6020526040902061273a90868661334f565b846101055f82825461274c91906143c1565b909155505f90506127606020890189613e2a565b6040805167ffffffffffffffff8581168252878116602083015286168183015290516001600160a01b0392909216915f917fb59adc820ca642dad493a0a6e0bdf979dcae037dea114b70d5c66b1c0b791c4b919081900360600190a46127c96020880188613e2a565b6040805167ffffffffffffffff848116825260208b8101359083015281830189905286811660608301528516608082015290516001600160a01b03928316928916918b1515917f7f5bdabbd27a8fc572781b177055488d7c6729a2bade4f57da9d200f31c15d479181900360a00190a45050505050505050565b5f61284e83836124be565b8354610bcb91906143d4565b6040516001600160a01b038316602482015260448101829052610db29084907fa9059cbb00000000000000000000000000000000000000000000000000000000906064015b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff166001600160e01b0319909316929092179091526133c6565b5f610bcb83836134aa565b5f54610100900460ff166129725760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e6700000000000000000000000000000000000000000060648201526084016108ab565b565b5f54610100900460ff166129f05760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e6700000000000000000000000000000000000000000060648201526084016108ab565b610e3f82826134d0565b612a0a6060820160408301613fe7565b67ffffffffffffffff165f03612a4c576040517f047bad5200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b62015180612a606040830160208401613fe7565b67ffffffffffffffff161115612abf57612a806040820160208301613fe7565b6040517fc34a76cf00000000000000000000000000000000000000000000000000000000815267ffffffffffffffff90911660048201526024016108ab565b612acf6040820160208301613fe7565b67ffffffffffffffff16612ae96060830160408401613fe7565b612af96080840160608501613fe7565b612b03919061407b565b67ffffffffffffffff161115612b45576040517f326de36000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80610104612b5382826143e7565b507f982cfb73783b8c64455c76cdeb1351467c4f1e6b3615fec07df232c1b46ffd479050612b896121d836849003840184614262565b612b9660208401846141cb565b612ba66040850160208601613fe7565b612bb66060860160408701613fe7565b612bc66080870160608801613fe7565b6040805167ffffffffffffffff968716815260079590950b6020860152928516848401529084166060840152909216608082015290519081900360a00190a150565b612c1284846125be565b612c1c82826125be565b612c268483613566565b50505050565b81545f03612c4d57604051631f2a200560e01b815260040160405180910390fd5b67fffffffffffffffe1967ffffffffffffffff821601612c99576040517f3d89ddde00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600182015467ffffffffffffffff90811614612ce1576040517f04eb6b3f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600191909101805467ffffffffffffffff191667ffffffffffffffff909216919091179055565b805f03612d2857604051631f2a200560e01b815260040160405180910390fd5b600182015467ffffffffffffffff90811614612d5c5760018201805467ffffffffffffffff191667ffffffffffffffff1790555b80825f015f828254612d6e91906143c1565b90915550505050565b6040516001600160a01b0380851660248301528316604482015260648101829052612c269085907f23b872dd000000000000000000000000000000000000000000000000000000009060840161289f565b5f67fffffffffffffffe1967ffffffffffffffff831601612e15576040517f3d89ddde00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f612e2084846124be565b9050805f03612e5b576040517fd0d04f6000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f8455905092915050565b5f610ad5825490565b5f808083810190505f8460010154825467ffffffffffffffff600160a01b92839004811692909104161015612ea75750506001808401905b9094909350915050565b81515f90600790810b4290910b1215612ecb57505f610ad5565b5f612ed5846122f3565b9050612ee281600161407b565b67ffffffffffffffff168367ffffffffffffffff1610612f05575f915050610ad5565b5f612f12855f015161306b565b90505f856020015182612f25919061439b565b9050856060015186604001518760200151612f40919061437a565b612f4a919061437a565b67ffffffffffffffff9081169116101595945050505050565b61010354811015612faf57610103546040517fda4f272e0000000000000000000000000000000000000000000000000000000081526108ab918391600401918252602082015260400190565b6101025460408051918252602082018390527f9725e37e079c5bda6009a8f54d86265849f30acf61c630f9e1ac91e67de98794910160405180910390a161010255565b5f610d897f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f61302060c95490565b60ca546040805160208101859052908101839052606081018290524660808201523060a08201525f9060c0016040516020818303038152906040528051906020012090509392505050565b5f610ad582426144dd565b5f8281526065602090815260408083206001600160a01b038516845290915290205460ff16610e3f576130b3816001600160a01b031660146135b0565b6130be8360206135b0565b6040516020016130cf929190614523565b60408051601f198184030181529082905262461bcd60e51b82526108ab9160040161458d565b5f8281526065602090815260408083206001600160a01b038516845290915290205460ff16610e3f575f8281526065602090815260408083206001600160a01b03851684529091529020805460ff191660011790556131513390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b5f610bcb836001600160a01b0384166137d3565b5f8281526065602090815260408083206001600160a01b038516845290915290205460ff1615610e3f575f8281526065602090815260408083206001600160a01b0385168085529252808320805460ff1916905551339285917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45050565b5f610bcb836001600160a01b03841661381f565b5f805f61324b8585613909565b9150915061325881613948565b509392505050565b5f8061326b85612e6f565b8154919350915067ffffffffffffffff808616600160a01b90920416106132ca576040517f451f873400000000000000000000000000000000000000000000000000000000815267ffffffffffffffff851660048201526024016108ab565b604080518082019091526001600160a01b038416815267ffffffffffffffff8516602082015260018218908660ff83166002811061330a5761330a614053565b82519101805460209093015167ffffffffffffffff16600160a01b026001600160e01b03199093166001600160a01b0390921691909117919091179055505050505050565b5f61335a8483612843565b905080158061336857508281105b156133a9576040517fcf47918100000000000000000000000000000000000000000000000000000000815260048101849052602481018290526044016108ab565b82845f015f8282546133bb91906143d4565b909155505050505050565b5f61341a826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316613b339092919063ffffffff16565b805190915015610db2578080602001905181019061343891906145c2565b610db25760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f7420737563636565640000000000000000000000000000000000000000000060648201526084016108ab565b5f825f0182815481106134bf576134bf614053565b905f5260205f200154905092915050565b5f54610100900460ff1661354c5760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e6700000000000000000000000000000000000000000060648201526084016108ab565b81516020928301208151919092012060c99190915560ca55565b5f82815260656020526040808220600101805490849055905190918391839186917fbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff9190a4505050565b60605f6135be8360026145e1565b6135c99060026143c1565b67ffffffffffffffff8111156135e1576135e161409c565b6040519080825280601f01601f19166020018201604052801561360b576020820181803683370190505b5090507f3000000000000000000000000000000000000000000000000000000000000000815f8151811061364157613641614053565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053507f7800000000000000000000000000000000000000000000000000000000000000816001815181106136a3576136a3614053565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053505f6136dd8460026145e1565b6136e89060016143c1565b90505b6001811115613784577f303132333435363738396162636465660000000000000000000000000000000085600f166010811061372957613729614053565b1a60f81b82828151811061373f5761373f614053565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a90535060049490941c9361377d816145f8565b90506136eb565b508315610bcb5760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e7460448201526064016108ab565b5f81815260018301602052604081205461381857508154600181810184555f848152602080822090930184905584548482528286019093526040902091909155610ad5565b505f610ad5565b5f81815260018301602052604081205480156138f9575f6138416001836143d4565b85549091505f90613854906001906143d4565b90508181146138b3575f865f01828154811061387257613872614053565b905f5260205f200154905080875f01848154811061389257613892614053565b5f918252602080832090910192909255918252600188019052604090208390555b85548690806138c4576138c461462c565b600190038181905f5260205f20015f90559055856001015f8681526020019081526020015f205f905560019350505050610ad5565b5f915050610ad5565b5092915050565b5f80825160410361393d576020830151604084015160608501515f1a61393187828585613b41565b94509450505050612451565b505f90506002612451565b5f81600481111561395b5761395b614640565b036139635750565b600181600481111561397757613977614640565b036139c45760405162461bcd60e51b815260206004820152601860248201527f45434453413a20696e76616c6964207369676e6174757265000000000000000060448201526064016108ab565b60028160048111156139d8576139d8614640565b03613a255760405162461bcd60e51b815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e6774680060448201526064016108ab565b6003816004811115613a3957613a39614640565b03613aac5760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c60448201527f756500000000000000000000000000000000000000000000000000000000000060648201526084016108ab565b6004816004811115613ac057613ac0614640565b036112935760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202776272076616c60448201527f756500000000000000000000000000000000000000000000000000000000000060648201526084016108ab565b6060610bc884845f85613c26565b5f807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0831115613b7657505f90506003613c1d565b8460ff16601b14158015613b8e57508460ff16601c14155b15613b9e57505f90506004613c1d565b604080515f8082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa158015613bef573d5f803e3d5ffd5b5050604051601f1901519150506001600160a01b038116613c17575f60019250925050613c1d565b91505f90505b94509492505050565b606082471015613c9e5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c000000000000000000000000000000000000000000000000000060648201526084016108ab565b6001600160a01b0385163b613cf55760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016108ab565b5f80866001600160a01b03168587604051613d109190614654565b5f6040518083038185875af1925050503d805f8114613d4a576040519150601f19603f3d011682016040523d82523d5f602084013e613d4f565b606091505b5091509150613d5f828286613d6a565b979650505050505050565b60608315613d79575081610bcb565b825115613d895782518084602001fd5b8160405162461bcd60e51b81526004016108ab919061458d565b67ffffffffffffffff81168114611293575f80fd5b6001600160a01b0381168114611293575f80fd5b5f8060408385031215613ddd575f80fd5b8235613de881613da3565b91506020830135613df881613db8565b809150509250929050565b5f60208284031215613e13575f80fd5b81356001600160e01b031981168114610bcb575f80fd5b5f60208284031215613e3a575f80fd5b8135610bcb81613db8565b5f805f60608486031215613e57575f80fd5b8335613e6281613da3565b92506020840135613e7281613db8565b929592945050506040919091013590565b82516001600160a01b0316815260208084015167ffffffffffffffff16908201526080810182516001600160a01b03166040830152602083015167ffffffffffffffff166060830152610bcb565b5f60208284031215613ee1575f80fd5b5035919050565b5f8060408385031215613ef9575f80fd5b823591506020830135613df881613db8565b5f60608284031215613f1b575f80fd5b50919050565b5f8060408385031215613f32575f80fd5b823567ffffffffffffffff80821115613f49575f80fd5b613f5586838701613f0b565b93506020850135915080821115613f6a575f80fd5b50613f7785828601613f0b565b9150509250929050565b5f8060408385031215613f92575f80fd5b8235613f9d81613db8565b91506020830135613df881613da3565b5f60208284031215613fbd575f80fd5b813567ffffffffffffffff811115613fd3575f80fd5b613fdf84828501613f0b565b949350505050565b5f60208284031215613ff7575f80fd5b8135610bcb81613da3565b5f8060408385031215614013575f80fd5b50508035926020909101359150565b5f6101e08284031215613f1b575f80fd5b5f60408284031215613f1b575f80fd5b5f60808284031215613f1b575f80fd5b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b67ffffffffffffffff81811683821601908082111561390257613902614067565b634e487b7160e01b5f52604160045260245ffd5b6040516060810167ffffffffffffffff811182821017156140d3576140d361409c565b60405290565b604051601f8201601f1916810167ffffffffffffffff811182821017156141025761410261409c565b604052919050565b5f6060823603121561411a575f80fd5b6141226140b0565b823561412d81613db8565b815260208381013581830152604084013567ffffffffffffffff80821115614153575f80fd5b9085019036601f830112614165575f80fd5b8135818111156141775761417761409c565b61418984601f19601f840116016140d9565b9150808252368482850101111561419e575f80fd5b80848401858401375f9082019093019290925250604082015292915050565b8060070b8114611293575f80fd5b5f602082840312156141db575f80fd5b8135610bcb816141bd565b81356141f181613db8565b6001600160a01b038116905081548173ffffffffffffffffffffffffffffffffffffffff198216178355602084013561422981613da3565b7bffffffffffffffff00000000000000000000000000000000000000008160a01b16836001600160e01b03198416171784555050505050565b5f60808284031215614272575f80fd5b6040516080810181811067ffffffffffffffff821117156142955761429561409c565b60405282356142a3816141bd565b815260208301356142b381613da3565b602082015260408301356142c681613da3565b604082015260608301356142d981613da3565b60608201529392505050565b634e487b7160e01b5f52601260045260245ffd5b5f67ffffffffffffffff80841680614313576143136142e5565b92169190910492915050565b67ffffffffffffffff81811683821602808216919082811461434357614343614067565b505092915050565b600781810b9083900b01677fffffffffffffff8113677fffffffffffffff1982121715610ad557610ad5614067565b67ffffffffffffffff82811682821603908082111561390257613902614067565b5f67ffffffffffffffff808416806143b5576143b56142e5565b92169190910692915050565b80820180821115610ad557610ad5614067565b81810381811115610ad557610ad5614067565b81356143f2816141bd565b815467ffffffffffffffff82811667ffffffffffffffff198316178455602085013561441d81613da3565b6fffffffffffffffff0000000000000000604091821b16919093167fffffffffffffffffffffffffffffffff000000000000000000000000000000008316811782178555928501359061446f82613da3565b77ffffffffffffffff000000000000000000000000000000008260801b1691507fffffffffffffffff0000000000000000000000000000000000000000000000008285828616178317178655606087013593506144cb84613da3565b93171760c09190911b90911617905550565b600782810b9082900b03677fffffffffffffff198112677fffffffffffffff82131715610ad557610ad5614067565b5f81518060208401855e5f93019283525090919050565b7f416363657373436f6e74726f6c3a206163636f756e742000000000000000000081525f614554601783018561450c565b7f206973206d697373696e6720726f6c65200000000000000000000000000000008152614584601182018561450c565b95945050505050565b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f83011684010191505092915050565b5f602082840312156145d2575f80fd5b81518015158114610bcb575f80fd5b8082028115828204841417610ad557610ad5614067565b5f8161460657614606614067565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0190565b634e487b7160e01b5f52603160045260245ffd5b634e487b7160e01b5f52602160045260245ffd5b5f610bcb828461450c56fea264697066735822122027004b4d9636da7cc518f548aa36ae81f38e90957760b4ad93d5db055e9ba0a364736f6c63430008190033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW_\x80\xFD[P`\x046\x10a\x03\x03W_5`\xE0\x1C\x80c{a\x7F\x94\x11a\x01\x9DW\x80c\xC5\xB6\xAA/\x11a\0\xE8W\x80c\xE2\xFCoh\x11a\0\x93W\x80c\xE4\xD2\x0C\x1D\x11a\0nW\x80c\xE4\xD2\x0C\x1D\x14a\x07\xC8W\x80c\xF6\x98\xDA%\x14a\x07\xDBW\x80c\xFE\xD8{\xE8\x14a\x07\xE3W_\x80\xFD[\x80c\xE2\xFCoh\x14a\x07\x8FW\x80c\xE3\xF7\xBBU\x14a\x07\x99W\x80c\xE4`\xD2\xC5\x14a\x07\xC0W_\x80\xFD[\x80c\xCF\xE9#+\x11a\0\xC3W\x80c\xCF\xE9#+\x14a\x07KW\x80c\xD5Gt\x1F\x14a\x07rW\x80c\xDB.\x1E\xED\x14a\x07\x85W_\x80\xFD[\x80c\xC5\xB6\xAA/\x14a\x07\x1DW\x80c\xCA\x15\xC8s\x14a\x07%W\x80c\xCE\x9C|\r\x14a\x078W_\x80\xFD[\x80c\x9A\x1F\xAD\xD3\x11a\x01HW\x80c\xB5\x1D\x1DO\x11a\x01#W\x80c\xB5\x1D\x1DO\x14a\x06\xEFW\x80c\xB6\xB5_%\x14a\x06\xF7W\x80c\xBE\xF0\xECt\x14a\x07\nW_\x80\xFD[\x80c\x9A\x1F\xAD\xD3\x14a\x06\xAEW\x80c\xA2\x17\xFD\xDF\x14a\x06\xC1W\x80c\xB3\xEE%/\x14a\x06\xC8W_\x80\xFD[\x80c\x8A\x19\xC8\xBC\x11a\x01xW\x80c\x8A\x19\xC8\xBC\x14a\x06BW\x80c\x90\x10\xD0|\x14a\x06cW\x80c\x91\xD1HT\x14a\x06vW_\x80\xFD[\x80c{a\x7F\x94\x14a\x05\xDDW\x80c\x83\xAF\n\x1F\x14a\x06\x11W\x80c\x89H\xCCN\x14a\x06\x1BW_\x80\xFD[\x80c//\xF1]\x11a\x02]W\x80cc\x9Duf\x11a\x02\x08W\x80cm\xC4\xFCN\x11a\x01\xE3W\x80cm\xC4\xFCN\x14a\x05\xA4W\x80cn\x8C\xAC\xE5\x14a\x05\xB7W\x80cp\xA0\x821\x14a\x05\xCAW_\x80\xFD[\x80cc\x9Duf\x14a\x05$W\x80cjQK\xEB\x14a\x058W\x80cj\xD7%\x17\x14a\x05\x9CW_\x80\xFD[\x80c8\xAF>\xED\x11a\x028W\x80c8\xAF>\xED\x14a\x04\xD2W\x80cDzp\x9E\x14a\x04\xFEW\x80cV3\xC37\x14a\x05\x11W_\x80\xFD[\x80c//\xF1]\x14a\x04\x85W\x80c3j[^\x14a\x04\x98W\x80c6V\x8A\xBE\x14a\x04\xBFW_\x80\xFD[\x80c\r%?\xBE\x11a\x02\xBDW\x80c\x1C1\xF7\x10\x11a\x02\x98W\x80c\x1C1\xF7\x10\x14a\x04HW\x80c$\x8A\x9C\xA3\x14a\x04[W\x80c-f\x8C\xE7\x14a\x04}W_\x80\xFD[\x80c\r%?\xBE\x14a\x03\xE4W\x80c\x14\xD9c\x16\x14a\x03\xFAW\x80c\x16\x82\xE5\x0B\x14a\x04!W_\x80\xFD[\x80c\x01\xFF\xC9\xA7\x11a\x02\xEDW\x80c\x01\xFF\xC9\xA7\x14a\x03\x8DW\x80c\x02\xB6)8\x14a\x03\xB0W\x80c\x04\xC5\x84\xAD\x14a\x03\xD1W_\x80\xFD[\x80b{\xE2\xFE\x14a\x03\x07W\x80c\x01Rh-\x14a\x03\x1CW[_\x80\xFD[a\x03\x1Aa\x03\x156`\x04a=\xCCV[a\x07\xF6V[\0[a\x01\x04Ta\x03S\x90`\x07\x81\x90\x0B\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16\x91`\x01`\x80\x1B\x81\x04\x82\x16\x91`\x01`\xC0\x1B\x90\x91\x04\x16\x84V[`@\x80Q`\x07\x95\x90\x95\x0B\x85Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x93\x84\x16` \x86\x01R\x91\x83\x16\x91\x84\x01\x91\x90\x91R\x16``\x82\x01R`\x80\x01[`@Q\x80\x91\x03\x90\xF3[a\x03\xA0a\x03\x9B6`\x04a>\x03V[a\n\x98V[`@Q\x90\x15\x15\x81R` \x01a\x03\x84V[a\x03\xC3a\x03\xBE6`\x04a>*V[a\n\xDBV[`@Q\x90\x81R` \x01a\x03\x84V[a\x03\xC3a\x03\xDF6`\x04a>EV[a\x0BRV[a\x03\xECa\x0B\xD2V[`@Qa\x03\x84\x92\x91\x90a>\x83V[a\x03\xC3\x7F?\xB9\xF0e[x\xE8\xEA\xBE\x9E\x0FQ\xD6]\xB5lv\x90\xD42\x90\x12\xC3\xFA\xF1\xFB\xD6\xD4?e\x82a\x81V[a\x03\xC3\x7Fm\x8D\xADq\x88\xC7\xED\0\\U\xBFw\xFB\xF5\x89X=\x86h\xB0\xDA\xD3\n\x9B\x9D\xD0\x162\x1A\\%o\x81V[a\x03\x1Aa\x04V6`\x04a>*V[a\x0C\x90V[a\x03\xC3a\x04i6`\x04a>\xD1V[_\x90\x81R`e` R`@\x90 `\x01\x01T\x90V[a\x03\xA0a\r3V[a\x03\x1Aa\x04\x936`\x04a>\xE8V[a\r\x8EV[a\x03\xC3\x7F\xC1\xB9|\x93FubN\xF2\x08\x90\x89\xAC\x12\xAE\x89\"\x98\x8C\x11\xDC\x8AW\x8D\xFB\xAC\x10\xD9\xEE\xCFGa\x81V[a\x03\x1Aa\x04\xCD6`\x04a>\xE8V[a\r\xB7V[a\x01\0Ta\x04\xE6\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x03\x84V[a\x03\x1Aa\x05\x0C6`\x04a?!V[a\x0ECV[a\x03\xC3a\x05\x1F6`\x04a?\x81V[a\x11\x1CV[a\x01\x01Ta\x04\xE6\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[a\x05ta\x05F6`\x04a>*V[a\x01\x06` R_\x90\x81R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x81\x16\x90`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x90\x93\x16\x83Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16` \x83\x01R\x01a\x03\x84V[a\x03\x1Aa\x12JV[a\x03\x1Aa\x05\xB26`\x04a?\xADV[a\x12\x96V[a\x03\xC3a\x05\xC56`\x04a?\x81V[a\x13\xF9V[a\x03\xC3a\x05\xD86`\x04a>*V[a\x14\xE1V[a\x05\xF0a\x05\xEB6`\x04a?\xE7V[a\x15XV[`@\x80Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x93\x84\x16\x81R\x92\x90\x91\x16` \x83\x01R\x01a\x03\x84V[a\x03\xC3a\x01\x03T\x81V[a\x03\xC3\x7F\xB0ug\xE7\">!\xF7\xDC\xE4\xC0\xA8\x911\xCE\x9C2\xD0\xD3H@\x85\xF3\xF31\xDE\xA8\xCA\xEFV\xD1A\x81V[a\x06Ja\x15\xBAV[`@Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x03\x84V[a\x04\xE6a\x06q6`\x04a@\x02V[a\x16\x10V[a\x03\xA0a\x06\x846`\x04a>\xE8V[_\x91\x82R`e` \x90\x81R`@\x80\x84 `\x01`\x01`\xA0\x1B\x03\x93\x90\x93\x16\x84R\x91\x90R\x90 T`\xFF\x16\x90V[a\x03\x1Aa\x06\xBC6`\x04a@\"V[a\x16'V[a\x03\xC3_\x81V[a\x03\xC3\x7F\x19\xE6\xF2=\xF7'[H\xD1\xC38\"\xC6\xAD\x04\x1At3xU\"F\xAC\x81\x9FW\x8A\xE1\xD6p\x9C\xF9\x81V[a\x03\x1Aa\x1B\xE6V[a\x03\x1Aa\x07\x056`\x04a>\xD1V[a\x1C\xACV[a\x03\x1Aa\x07\x186`\x04a@3V[a\x1D\x16V[a\x03\x1Aa\x1EzV[a\x03\xC3a\x0736`\x04a>\xD1V[a\x1F5V[a\x03\x1Aa\x07F6`\x04a>\xD1V[a\x1FKV[a\x03\xC3\x7F\x1Di?b\xA7U\xE2\xB3\xC6IM\xA4\x1A\xF4T`[\x90\x06\x05|\xB3\xC7\x9Bj\xDD\xA17\x8F*P\xA7\x81V[a\x03\x1Aa\x07\x806`\x04a>\xE8V[a \"V[a\x03\xC3a\x01\x02T\x81V[a\x03\xC3a\x01\x05T\x81V[a\x03\xC3\x7F\xA8\x13\x1B\xB4X\x92w\xD6\x86m\x94(I\x02\x9BAk9\xE6\x1E\xB3\x96\x9A2xq0\xBB\xDD)*\x96\x81V[a\x03\xA0a FV[a\x03\x1Aa\x07\xD66`\x04a>\xD1V[a \xBAV[a\x03\xC3a!;V[a\x03\x1Aa\x07\xF16`\x04a@CV[a!DV[`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01R_a\x08K\x82a\"\xF3V[\x90P\x80g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x84g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15a\x08\xB4W`@Q\x7F9_O\xD6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x86\x16`\x04\x83\x01R\x82\x16`$\x82\x01R`D\x01[`@Q\x80\x91\x03\x90\xFD[_a\x08\xC0`\xFE\x86a#'V[\x80T`\x01`\x01`\xA0\x1B\x03\x90\x81\x16_\x81\x81Ra\x01\x06` R`@\x90 T\x92\x93P\x91\x16\x80\x15a\tOW`\x01`\x01`\xA0\x1B\x03\x81\x163\x14a\tJW`@Q\x7Fv!\xD9J\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x88\x16`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x82\x16`$\x82\x01R3`D\x82\x01R`d\x01a\x08\xABV[a\t\xB2V[`\x01`\x01`\xA0\x1B\x03\x82\x163\x14a\t\xB2W`@Q\x7Ff\n\xF6\xD2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x88\x16`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x83\x16`$\x82\x01R3`D\x82\x01R`d\x01a\x08\xABV[\x82Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`\xA0\x1B\x03\x87\x16\x17\x83U_\x80a\t\xE4\x87\x8Aa#\xC4V[\x90\x92P\x90P`\x01`\x01`\xA0\x1B\x03\x83\x16a\t\xFDW\x83a\t\xFFV[\x82[`\x01`\x01`\xA0\x1B\x03\x16\x88`\x01`\x01`\xA0\x1B\x03\x16\x85`\x01`\x01`\xA0\x1B\x03\x16\x7F\xB5\x9A\xDC\x82\x0C\xA6B\xDA\xD4\x93\xA0\xA6\xE0\xBD\xF9y\xDC\xAE\x03}\xEA\x11Kp\xD5\xC6k\x1C\x0By\x1CK\x8CBg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x87g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10a\n_W\x86a\naV[B[`@\x80Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x93\x84\x16\x81R\x91\x83\x16` \x83\x01R\x91\x87\x16\x81\x83\x01R\x90Q\x90\x81\x90\x03``\x01\x90\xA4PPPPPPPPPV[_`\x01`\x01`\xE0\x1B\x03\x19\x82\x16\x7FZ\x05\x18\x0F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x14\x80a\n\xD5WPa\n\xD5\x82a$XV[\x92\x91PPV[`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01R_\x90a\n\xD5\x90a\x0B5\x90a\"\xF3V[`\x01`\x01`\xA0\x1B\x03\x84\x16_\x90\x81R`\xFD` R`@\x90 \x90a$\xBEV[`@\x80Q\x7F\x03X\xB2\xB7\x05\xD5\xC5\xEFGe\x1B\xE4OA\x83&\x85*9\x0F;L\x936a\xA5\xF4\xF0\xD8\xFA\x1E\xE3` \x82\x01Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x16\x91\x81\x01\x91\x90\x91R`\x01`\x01`\xA0\x1B\x03\x83\x16``\x82\x01R`\x80\x81\x01\x82\x90R_\x90a\x0B\xC8\x90`\xA0\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 a$\xE6V[\x90P[\x93\x92PPPV[`@\x80Q\x80\x82\x01\x90\x91R_\x80\x82R` \x82\x01R`@\x80Q\x80\x82\x01\x90\x91R_\x80\x82R` \x82\x01R`\xFE`\x01\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\xFE_\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11a\x0C3W`\xFF`\xFEa\x0C8V[`\xFE`\xFF[`@\x80Q\x80\x82\x01\x82R\x92T`\x01`\x01`\xA0\x1B\x03\x80\x82\x16\x85Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`\xA0\x1B\x92\x83\x90\x04\x81\x16` \x80\x88\x01\x91\x90\x91R\x84Q\x80\x86\x01\x90\x95R\x94T\x91\x82\x16\x84R\x91\x90\x04\x16\x91\x81\x01\x91\x90\x91R\x90\x93\x90\x92P\x90PV[\x7F\xC1\xB9|\x93FubN\xF2\x08\x90\x89\xAC\x12\xAE\x89\"\x98\x8C\x11\xDC\x8AW\x8D\xFB\xAC\x10\xD9\xEE\xCFGaa\x0C\xBA\x81a%MV[a\x01\0T`@\x80Q`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x81R\x91\x84\x16` \x83\x01R\x7F\x8A\x01I\xB2\xF3\xDD\xF2\xC9\xEE\x85s\x81e\x13\x1D\x82\xBA\xBB\xB98\xF7I2\x1DY\xF7WP\xAF\xA7\xF4\xE6\x91\x01`@Q\x80\x91\x03\x90\xA1Pa\x01\0\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90UV[`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01R_\x90a\r\x89\x90a%WV[\x90P\x90V[_\x82\x81R`e` R`@\x90 `\x01\x01Ta\r\xA8\x81a%MV[a\r\xB2\x83\x83a%\xBEV[PPPV[`\x01`\x01`\xA0\x1B\x03\x81\x163\x14a\x0E5W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`/`$\x82\x01R\x7FAccessControl: can only renounce`D\x82\x01R\x7F roles for self\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08\xABV[a\x0E?\x82\x82a%\xDFV[PPV[\x7F\x1Di?b\xA7U\xE2\xB3\xC6IM\xA4\x1A\xF4T`[\x90\x06\x05|\xB3\xC7\x9Bj\xDD\xA17\x8F*P\xA7a\x0Em\x81a%MV[`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01Ra\x0E\xC1\x81a%WV[a\x0E\xF7W`@Q\x7F\xB9\xAD\xEE\xFD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x82` \x015\x84` \x015\x10\x15a\x0F9W`@Q\x7F\xA24\xCB\x19\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x01\x02T\x83` \x015\x10\x15a\x0F\x8CWa\x01\x02T`@Q\x7FV\xF9\xB7Z\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x85\x015`\x04\x82\x01R`$\x81\x01\x91\x90\x91R`D\x01a\x08\xABV[_a\x0F\x96\x82a\"\xF3V[\x90P_a\x0F\xA4\x82`\x01a@{V[\x90P_\x80a\x0F\xBAa\x0F\xB4\x89aA\nV[\x84a&\0V[\x91P\x91P_\x80a\x0F\xD3\x89a\x0F\xCD\x90aA\nV[\x86a&\0V[\x91P\x91P\x81`\x01`\x01`\xA0\x1B\x03\x16\x84`\x01`\x01`\xA0\x1B\x03\x16\x03a\x10\"W`@Q\x7F\xF4\xA3\xE4\x85\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x88` \x015\x8A` \x015\x14\x80\x15a\x10\xB3WP`@Qk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19``\x84\x90\x1B\x16` \x82\x01R`4\x81\x01\x82\x90R`T\x01`@\x80Q\x80\x83\x03`\x1F\x19\x01\x81R\x90\x82\x90R\x80Q` \x91\x82\x01 k\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19``\x88\x90\x1B\x16\x91\x83\x01\x91\x90\x91R`4\x82\x01\x85\x90R\x90`T\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 _\x1C\x10[\x15a\x10\xEAW`@Q\x7F\x91\x85\xA0\xAE\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80a\x10\xF6\x89\x88a#\xC4V[\x91P\x91Pa\x11\x0E`\x01\x8D\x88\x8E` \x015\x8C\x87\x87a&\xF0V[PPPPPPPPPPPPV[`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01R_\x90a\x11r\x90a\"\xF3V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15a\x12)W`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01R\x82\x90a\x11\xE3\x90a\"\xF3V[`@Q\x7F9_O\xD6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92\x83\x16`\x04\x82\x01R\x91\x16`$\x82\x01R`D\x01a\x08\xABV[`\x01`\x01`\xA0\x1B\x03\x83\x16_\x90\x81R`\xFD` R`@\x90 a\x0B\xCB\x90\x83a(CV[a\x01\x05T_\x81\x90\x03a\x12oW`@Qc\x1F* \x05`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a\x01\x05Ua\x01\0Ta\x01\x01Ta\x12\x93\x91`\x01`\x01`\xA0\x1B\x03\x91\x82\x16\x91\x16\x83a(ZV[PV[\x7F\x1Di?b\xA7U\xE2\xB3\xC6IM\xA4\x1A\xF4T`[\x90\x06\x05|\xB3\xC7\x9Bj\xDD\xA17\x8F*P\xA7a\x12\xC0\x81a%MV[`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01Ra\x13\x14\x81a%WV[a\x13JW`@Q\x7F\xB9\xAD\xEE\xFD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x01\x02T\x83` \x015\x10\x15a\x13\x9DWa\x01\x02T`@Q\x7FV\xF9\xB7Z\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` \x85\x015`\x04\x82\x01R`$\x81\x01\x91\x90\x91R`D\x01a\x08\xABV[_a\x13\xA7\x82a\"\xF3V[\x90P_a\x13\xB5\x82`\x01a@{V[\x90P_a\x13\xCAa\x13\xC4\x87aA\nV[\x83a&\0V[P\x90P_\x80a\x13\xD9\x86\x85a#\xC4V[\x91P\x91Pa\x13\xEF_\x89\x85a\x01\x02T\x89\x87\x87a&\xF0V[PPPPPPPPV[`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01R_\x90a\x14O\x90a\"\xF3V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10\x15a\x14\xC0W`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01R\x82\x90a\x11\xE3\x90a\"\xF3V[`\x01`\x01`\xA0\x1B\x03\x83\x16_\x90\x81R`\xFD` R`@\x90 a\x0B\xCB\x90\x83a$\xBEV[`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01R_\x90a\n\xD5\x90a\x15;\x90a\"\xF3V[`\x01`\x01`\xA0\x1B\x03\x84\x16_\x90\x81R`\xFD` R`@\x90 \x90a(CV[`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01R_\x90\x81\x90a\x15\xB1\x90\x84a#\xC4V[\x91P\x91P\x91P\x91V[`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01R_\x90a\r\x89\x90a\"\xF3V[_\x82\x81R`\x97` R`@\x81 a\x0B\xCB\x90\x83a(\xEBV[_Ta\x01\0\x90\x04`\xFF\x16\x15\x80\x80\x15a\x16EWP_T`\x01`\xFF\x90\x91\x16\x10[\x80a\x16^WP0;\x15\x80\x15a\x16^WP_T`\xFF\x16`\x01\x14[a\x16\xD0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`.`$\x82\x01R\x7FInitializable: contract is alrea`D\x82\x01R\x7Fdy initialized\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08\xABV[_\x80T`\xFF\x19\x16`\x01\x17\x90U\x80\x15a\x16\xF1W_\x80Ta\xFF\0\x19\x16a\x01\0\x17\x90U[`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x160\x03a\x17\x8FW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`,`$\x82\x01R\x7FFunction must be called through `D\x82\x01R\x7Fdelegatecall\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08\xABV[a\x17\x97a(\xF6V[a\x18\x0B`@Q\x80`@\x01`@R\x80`\x12\x81R` \x01\x7FExpressLaneAuction\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RP`@Q\x80`@\x01`@R\x80`\x01\x81R` \x01\x7F1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RPa)tV[_a\x18\x1C`@\x84\x01` \x85\x01a>*V[`\x01`\x01`\xA0\x1B\x03\x16\x03a\x18\\W`@Q\x7F?\xB3\xC7\xAF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x18l`@\x83\x01` \x84\x01a>*V[a\x01\x01\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90Ua\x18\xAA``\x83\x01`@\x84\x01a>*V[a\x01\0\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90U\x7F\x8A\x01I\xB2\xF3\xDD\xF2\xC9\xEE\x85s\x81e\x13\x1D\x82\xBA\xBB\xB98\xF7I2\x1DY\xF7WP\xAF\xA7\xF4\xE6_a\x19\n``\x85\x01`@\x86\x01a>*V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x93\x84\x16\x81R\x92\x90\x91\x16` \x83\x01R\x01`@Q\x80\x91\x03\x90\xA1`\xE0\x82\x015a\x01\x03\x81\x90U`@\x80Q_\x81R` \x81\x01\x92\x90\x92R\x7FXH\x06\x8F\x11\xAA;\xA9\xFE?\xC3<_\x9F*<\xD1\xAE\xD6y\x86\xB8[^\x0C\xED\xC6}\xBE\x96\xF0\xF0\x91\x01`@Q\x80\x91\x03\x90\xA1`\xE0\x82\x015a\x01\x02\x81\x90U`@\x80Q_\x81R` \x81\x01\x92\x90\x92R\x7F\x97%\xE3~\x07\x9C[\xDA`\t\xA8\xF5M\x86&XI\xF3\n\xCFa\xC60\xF9\xE1\xAC\x91\xE6}\xE9\x87\x94\x91\x01`@Q\x80\x91\x03\x90\xA1_a\x19\xC8`\x80\x84\x01``\x85\x01aA\xCBV[`\x07\x0B\x12\x15a\x1A\x03W`@Q\x7F\x16\xF4m\xFE\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x1A\x0F\x82``\x01a)\xFAV[a\x1A*_a\x1A%a\x01\xE0\x85\x01a\x01\xC0\x86\x01a>*V[a%\xBEV[a\x1A`\x7F\xB0ug\xE7\">!\xF7\xDC\xE4\xC0\xA8\x911\xCE\x9C2\xD0\xD3H@\x85\xF3\xF31\xDE\xA8\xCA\xEFV\xD1Aa\x1A%a\x01@\x85\x01a\x01 \x86\x01a>*V[a\x1A\x96\x7F\xC1\xB9|\x93FubN\xF2\x08\x90\x89\xAC\x12\xAE\x89\"\x98\x8C\x11\xDC\x8AW\x8D\xFB\xAC\x10\xD9\xEE\xCFGaa\x1A%a\x01\xA0\x85\x01a\x01\x80\x86\x01a>*V[a\x1A\xFF\x7F\x1Di?b\xA7U\xE2\xB3\xC6IM\xA4\x1A\xF4T`[\x90\x06\x05|\xB3\xC7\x9Bj\xDD\xA17\x8F*P\xA7a\x1A\xC7` \x85\x01\x85a>*V[\x7F?\xB9\xF0e[x\xE8\xEA\xBE\x9E\x0FQ\xD6]\xB5lv\x90\xD42\x90\x12\xC3\xFA\xF1\xFB\xD6\xD4?e\x82aa\x1A\xFAa\x01 \x87\x01a\x01\0\x88\x01a>*V[a,\x08V[a\x1Bh\x7F\x19\xE6\xF2=\xF7'[H\xD1\xC38\"\xC6\xAD\x04\x1At3xU\"F\xAC\x81\x9FW\x8A\xE1\xD6p\x9C\xF9a\x1B5a\x01`\x85\x01a\x01@\x86\x01a>*V[\x7F\xA8\x13\x1B\xB4X\x92w\xD6\x86m\x94(I\x02\x9BAk9\xE6\x1E\xB3\x96\x9A2xq0\xBB\xDD)*\x96a\x1A\xFAa\x01\x80\x87\x01a\x01`\x88\x01a>*V[a\x1B\x9E\x7Fm\x8D\xADq\x88\xC7\xED\0\\U\xBFw\xFB\xF5\x89X=\x86h\xB0\xDA\xD3\n\x9B\x9D\xD0\x162\x1A\\%oa\x1A%a\x01\xC0\x85\x01a\x01\xA0\x86\x01a>*V[\x80\x15a\x0E?W_\x80Ta\xFF\0\x19\x16\x90U`@Q`\x01\x81R\x7F\x7F&\xB8?\xF9n\x1F+jh/\x138R\xF6y\x8A\t\xC4e\xDA\x95\x92\x14`\xCE\xFB8G@$\x98\x90` \x01`@Q\x80\x91\x03\x90\xA1PPV[`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01R_\x90a\x1C<\x90a\"\xF3V[a\x1CG\x90`\x02a@{V[3_\x90\x81R`\xFD` R`@\x90 \x80T\x91\x92Pa\x1Cd\x90\x83a,,V[`@\x80Q\x82\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16` \x82\x01R3\x91\x7F1\xF6\x92\x01\xFA\xB7\x91.>\xC9\x85\x0E:\xB7\x05\x96K\xF4m\x9DBv\xBD\xCB\xB6\xD0^\x96^_T\x01\x91\x01`@Q\x80\x91\x03\x90\xA2PPV[3_\x90\x81R`\xFD` R`@\x90 a\x1C\xC4\x90\x82a-\x08V[a\x01\x01Ta\x1C\xDD\x90`\x01`\x01`\xA0\x1B\x03\x1630\x84a-wV[`@Q\x81\x81R3\x90\x7F\xE1\xFF\xFC\xC4\x92=\x04\xB5Y\xF4\xD2\x9A\x8B\xFCl\xDA\x04\xEB[\r<F\x07Q\xC2@,\\\\\xC9\x10\x9C\x90` \x01[`@Q\x80\x91\x03\x90\xA2PV[3_\x90\x81Ra\x01\x06` R`@\x90 \x80T`\x01`\x01`\xA0\x1B\x03\x16\x15\x80\x15\x90a\x1D\xA8WP`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01Ra\x1D\x8D\x90a\"\xF3V[\x81Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91\x82\x16`\x01`\xA0\x1B\x90\x91\x04\x90\x91\x16\x11[\x15a\x1D\xF4W\x80T`@Q\x7Fu\xD8\x99\xF2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\xA0\x1B\x90\x91\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x04\x82\x01R`$\x01a\x08\xABV[3_\x90\x81Ra\x01\x06` R`@\x90 \x82\x90a\x1E\x0F\x82\x82aA\xE6V[Pa\x1E\x1F\x90P` \x83\x01\x83a>*V[`\x01`\x01`\xA0\x1B\x03\x163\x7F\xF6\xD2\x8D\xF25\xD9\xFAE\xA4-E\xDB\xB7\xC4\xF4\xACv\xED\xB5\x1ER\x8F\t\xF2Z\x06P\xD3+\x8B3\xC0a\x1EZ`@\x86\x01` \x87\x01a?\xE7V[`@Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01`@Q\x80\x91\x03\x90\xA3PPV[`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01R_\x90a\x1E\xE8\x90a\x1E\xD4\x90a\"\xF3V[3_\x90\x81R`\xFD` R`@\x90 \x90a-\xC8V[a\x01\x01T\x90\x91Pa\x1F\x03\x90`\x01`\x01`\xA0\x1B\x03\x163\x83a(ZV[`@Q\x81\x81R3\x90\x7F\x9E\\O\x9FNF\xB8b\x9D=\xDA\x85\xF4:i\x19OP%D\x04\xA7-\xC6+\x9E\x93-\x9C\x94\xED\xA8\x90` \x01a\x1D\x0BV[_\x81\x81R`\x97` R`@\x81 a\n\xD5\x90a.fV[\x7F\x19\xE6\xF2=\xF7'[H\xD1\xC38\"\xC6\xAD\x04\x1At3xU\"F\xAC\x81\x9FW\x8A\xE1\xD6p\x9C\xF9a\x1Fu\x81a%MV[_a\x1F\x80`\xFEa.oV[P\x80T`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x82\x16``\x82\x01R\x92\x93Pa\x1F\xE2\x92\x91`\x01`\xA0\x1B\x90\x04\x16a.\xB1V[\x15a \x19W`@Q\x7FO\0ix\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\r\xB2\x83a/cV[_\x82\x81R`e` R`@\x90 `\x01\x01Ta <\x81a%MV[a\r\xB2\x83\x83a%\xDFV[_\x80a R`\xFEa.oV[P\x80T`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x82\x16``\x82\x01R\x92\x93Pa \xB4\x92\x91`\x01`\xA0\x1B\x90\x04\x16a.\xB1V[\x91PP\x90V[\x7F\xB0ug\xE7\">!\xF7\xDC\xE4\xC0\xA8\x911\xCE\x9C2\xD0\xD3H@\x85\xF3\xF31\xDE\xA8\xCA\xEFV\xD1Aa \xE4\x81a%MV[a\x01\x03T`@\x80Q\x91\x82R` \x82\x01\x84\x90R\x7FXH\x06\x8F\x11\xAA;\xA9\xFE?\xC3<_\x9F*<\xD1\xAE\xD6y\x86\xB8[^\x0C\xED\xC6}\xBE\x96\xF0\xF0\x91\x01`@Q\x80\x91\x03\x90\xA1a\x01\x03\x82\x90Ua\x01\x02T\x82\x11\x15a\x0E?Wa\x0E?\x82a/cV[_a\r\x89a/\xF2V[\x7Fm\x8D\xADq\x88\xC7\xED\0\\U\xBFw\xFB\xF5\x89X=\x86h\xB0\xDA\xD3\n\x9B\x9D\xD0\x162\x1A\\%oa!n\x81a%MV[`@\x80Q`\x80\x81\x01\x82Ra\x01\x04T`\x07\x81\x90\x0B\x82Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`@\x1B\x82\x04\x81\x16` \x84\x01R`\x01`\x80\x1B\x82\x04\x81\x16\x93\x83\x01\x93\x90\x93R`\x01`\xC0\x1B\x90\x04\x90\x91\x16``\x82\x01R_a!\xC3\x82a\"\xF3V[\x90P_a!\xDDa!\xD86\x87\x90\x03\x87\x01\x87aBbV[a\"\xF3V[\x90P\x80g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\"@W`@Q\x7Fh\xC1\x8C\xA9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x84\x16`\x04\x83\x01R\x82\x16`$\x82\x01R`D\x01a\x08\xABV[_a\"Va\"O\x84`\x01a@{V[\x85\x90a#\xC4V[P\x90P_a\"}a\"h\x84`\x01a@{V[a\"w6\x8A\x90\x03\x8A\x01\x8AaBbV[\x90a#\xC4V[P\x90P\x80g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x14a\"\xE1W`@Q\x7F\xA0\xE2i\xD8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x84\x16`\x04\x83\x01R\x82\x16`$\x82\x01R`D\x01a\x08\xABV[a\"\xEA\x87a)\xFAV[PPPPPPPV[\x80Q_\x90`\x07\x90\x81\x0BB\x90\x91\x0B\x12\x15a#\rWP_\x91\x90PV[` \x82\x01Q\x82Qa#\x1D\x90a0kV[a\n\xD5\x91\x90aB\xF9V[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x83\x82\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a#XW\x82_[\x01\x90Pa\n\xD5V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x83`\x01\x01T`\x01`\xA0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x03a#\x86W\x82`\x01a#PV[`@Q\x7F\xFB\xB0R\xD8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16`\x04\x82\x01R`$\x01a\x08\xABV[_\x80_\x83\x85` \x01Qa#\xD7\x91\x90aC\x1FV[\x85Qa#\xE3\x91\x90aCKV[\x90P_\x81`\x07\x0B\x12\x15a$(W`@Q\x7F\xF1`\xADy\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x07\x82\x90\x0B`\x04\x82\x01R`$\x01a\x08\xABV[` \x85\x01Q\x81\x90_\x90`\x01\x90a$>\x90\x84a@{V[a$H\x91\x90aCzV[\x91\x94P\x90\x92PPP[\x92P\x92\x90PV[_`\x01`\x01`\xE0\x1B\x03\x19\x82\x16\x7Fye\xDB\x0B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x14\x80a\n\xD5WP\x7F\x01\xFF\xC9\xA7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xE0\x1B\x03\x19\x83\x16\x14a\n\xD5V[`\x01\x82\x01T_\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16\x90\x83\x16\x10\x15a$\xE0W_a\x0B\xCBV[PPT\x90V[_a\n\xD5a$\xF2a/\xF2V[\x83`@Q\x7F\x19\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01R`\"\x81\x01\x83\x90R`B\x81\x01\x82\x90R_\x90`b\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x92\x91PPV[a\x12\x93\x813a0vV[\x80Q_\x90`\x07\x90\x81\x0BB\x90\x91\x0B\x12\x15a%qWP_\x91\x90PV[_a%~\x83_\x01Qa0kV[\x90P_\x83` \x01Q\x82a%\x91\x91\x90aC\x9BV[\x90P\x83`@\x01Q\x84` \x01Qa%\xA7\x91\x90aCzV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16\x91\x16\x10\x15\x93\x92PPPV[a%\xC8\x82\x82a0\xF5V[_\x82\x81R`\x97` R`@\x90 a\r\xB2\x90\x82a1\x95V[a%\xE9\x82\x82a1\xA9V[_\x82\x81R`\x97` R`@\x90 a\r\xB2\x90\x82a2*V[_\x80_a&\x15\x84\x86_\x01Q\x87` \x01Qa\x0BRV[\x90P_a&/\x86`@\x01Q\x83a2>\x90\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x90P_a&=`\x01\x87aCzV[` \x80\x89\x01Q`\x01`\x01`\xA0\x1B\x03\x85\x16_\x90\x81R`\xFD\x90\x92R`@\x90\x91 \x91\x92P\x90a&i\x90\x83a(CV[\x10\x15a&\xE5W` \x80\x88\x01Q`\x01`\x01`\xA0\x1B\x03\x84\x16_\x90\x81R`\xFD\x90\x92R`@\x90\x91 \x83\x91\x90a&\x9A\x90\x84a(CV[`@Q\x7F6\xB2L\x14\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x01`\x01`\xA0\x1B\x03\x90\x93\x16`\x04\x84\x01R`$\x83\x01\x91\x90\x91R`D\x82\x01R`d\x01a\x08\xABV[P\x95\x90\x94P\x92PPPV[_a&\xFC\x84`\x01a@{V[\x90Pa'\x18\x81a'\x0F` \x8A\x01\x8Aa>*V[`\xFE\x91\x90a2`V[`\x01`\x01`\xA0\x1B\x03\x86\x16_\x90\x81R`\xFD` R`@\x90 a':\x90\x86\x86a3OV[\x84a\x01\x05_\x82\x82Ta'L\x91\x90aC\xC1V[\x90\x91UP_\x90Pa'`` \x89\x01\x89a>*V[`@\x80Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x81\x16\x82R\x87\x81\x16` \x83\x01R\x86\x16\x81\x83\x01R\x90Q`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91_\x91\x7F\xB5\x9A\xDC\x82\x0C\xA6B\xDA\xD4\x93\xA0\xA6\xE0\xBD\xF9y\xDC\xAE\x03}\xEA\x11Kp\xD5\xC6k\x1C\x0By\x1CK\x91\x90\x81\x90\x03``\x01\x90\xA4a'\xC9` \x88\x01\x88a>*V[`@\x80Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x81\x16\x82R` \x8B\x81\x015\x90\x83\x01R\x81\x83\x01\x89\x90R\x86\x81\x16``\x83\x01R\x85\x16`\x80\x82\x01R\x90Q`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x92\x89\x16\x91\x8B\x15\x15\x91\x7F\x7F[\xDA\xBB\xD2z\x8F\xC5rx\x1B\x17pUH\x8D|g)\xA2\xBA\xDEOW\xDA\x9D \x0F1\xC1]G\x91\x81\x90\x03`\xA0\x01\x90\xA4PPPPPPPPV[_a(N\x83\x83a$\xBEV[\x83Ta\x0B\xCB\x91\x90aC\xD4V[`@Q`\x01`\x01`\xA0\x1B\x03\x83\x16`$\x82\x01R`D\x81\x01\x82\x90Ra\r\xB2\x90\x84\x90\x7F\xA9\x05\x9C\xBB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90`d\x01[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x01`\x01`\xE0\x1B\x03\x19\x90\x93\x16\x92\x90\x92\x17\x90\x91Ra3\xC6V[_a\x0B\xCB\x83\x83a4\xAAV[_Ta\x01\0\x90\x04`\xFF\x16a)rW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7FInitializable: contract is not i`D\x82\x01R\x7Fnitializing\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08\xABV[V[_Ta\x01\0\x90\x04`\xFF\x16a)\xF0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7FInitializable: contract is not i`D\x82\x01R\x7Fnitializing\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08\xABV[a\x0E?\x82\x82a4\xD0V[a*\n``\x82\x01`@\x83\x01a?\xE7V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_\x03a*LW`@Q\x7F\x04{\xADR\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[b\x01Q\x80a*``@\x83\x01` \x84\x01a?\xE7V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11\x15a*\xBFWa*\x80`@\x82\x01` \x83\x01a?\xE7V[`@Q\x7F\xC3Jv\xCF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16`\x04\x82\x01R`$\x01a\x08\xABV[a*\xCF`@\x82\x01` \x83\x01a?\xE7V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a*\xE9``\x83\x01`@\x84\x01a?\xE7V[a*\xF9`\x80\x84\x01``\x85\x01a?\xE7V[a+\x03\x91\x90a@{V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11\x15a+EW`@Q\x7F2m\xE3`\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x80a\x01\x04a+S\x82\x82aC\xE7V[P\x7F\x98,\xFBsx;\x8CdE\\v\xCD\xEB\x13QF|O\x1Ek6\x15\xFE\xC0}\xF22\xC1\xB4o\xFDG\x90Pa+\x89a!\xD86\x84\x90\x03\x84\x01\x84aBbV[a+\x96` \x84\x01\x84aA\xCBV[a+\xA6`@\x85\x01` \x86\x01a?\xE7V[a+\xB6``\x86\x01`@\x87\x01a?\xE7V[a+\xC6`\x80\x87\x01``\x88\x01a?\xE7V[`@\x80Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x96\x87\x16\x81R`\x07\x95\x90\x95\x0B` \x86\x01R\x92\x85\x16\x84\x84\x01R\x90\x84\x16``\x84\x01R\x90\x92\x16`\x80\x82\x01R\x90Q\x90\x81\x90\x03`\xA0\x01\x90\xA1PV[a,\x12\x84\x84a%\xBEV[a,\x1C\x82\x82a%\xBEV[a,&\x84\x83a5fV[PPPPV[\x81T_\x03a,MW`@Qc\x1F* \x05`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE\x19g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x16\x01a,\x99W`@Q\x7F=\x89\xDD\xDE\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01\x82\x01Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16\x14a,\xE1W`@Q\x7F\x04\xEBk?\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01\x91\x90\x91\x01\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x92\x16\x91\x90\x91\x17\x90UV[\x80_\x03a-(W`@Qc\x1F* \x05`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01\x82\x01Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16\x14a-\\W`\x01\x82\x01\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x17\x90U[\x80\x82_\x01_\x82\x82Ta-n\x91\x90aC\xC1V[\x90\x91UPPPPV[`@Q`\x01`\x01`\xA0\x1B\x03\x80\x85\x16`$\x83\x01R\x83\x16`D\x82\x01R`d\x81\x01\x82\x90Ra,&\x90\x85\x90\x7F#\xB8r\xDD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90`\x84\x01a(\x9FV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFE\x19g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x16\x01a.\x15W`@Q\x7F=\x89\xDD\xDE\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a. \x84\x84a$\xBEV[\x90P\x80_\x03a.[W`@Q\x7F\xD0\xD0O`\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x84U\x90P\x92\x91PPV[_a\n\xD5\x82T\x90V[_\x80\x80\x83\x81\x01\x90P_\x84`\x01\x01T\x82Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`\xA0\x1B\x92\x83\x90\x04\x81\x16\x92\x90\x91\x04\x16\x10\x15a.\xA7WPP`\x01\x80\x84\x01\x90[\x90\x94\x90\x93P\x91PPV[\x81Q_\x90`\x07\x90\x81\x0BB\x90\x91\x0B\x12\x15a.\xCBWP_a\n\xD5V[_a.\xD5\x84a\"\xF3V[\x90Pa.\xE2\x81`\x01a@{V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x83g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10a/\x05W_\x91PPa\n\xD5V[_a/\x12\x85_\x01Qa0kV[\x90P_\x85` \x01Q\x82a/%\x91\x90aC\x9BV[\x90P\x85``\x01Q\x86`@\x01Q\x87` \x01Qa/@\x91\x90aCzV[a/J\x91\x90aCzV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16\x91\x16\x10\x15\x95\x94PPPPPV[a\x01\x03T\x81\x10\x15a/\xAFWa\x01\x03T`@Q\x7F\xDAO'.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Ra\x08\xAB\x91\x83\x91`\x04\x01\x91\x82R` \x82\x01R`@\x01\x90V[a\x01\x02T`@\x80Q\x91\x82R` \x82\x01\x83\x90R\x7F\x97%\xE3~\x07\x9C[\xDA`\t\xA8\xF5M\x86&XI\xF3\n\xCFa\xC60\xF9\xE1\xAC\x91\xE6}\xE9\x87\x94\x91\x01`@Q\x80\x91\x03\x90\xA1a\x01\x02UV[_a\r\x89\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0Fa0 `\xC9T\x90V[`\xCAT`@\x80Q` \x81\x01\x85\x90R\x90\x81\x01\x83\x90R``\x81\x01\x82\x90RF`\x80\x82\x01R0`\xA0\x82\x01R_\x90`\xC0\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x93\x92PPPV[_a\n\xD5\x82BaD\xDDV[_\x82\x81R`e` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x84R\x90\x91R\x90 T`\xFF\x16a\x0E?Wa0\xB3\x81`\x01`\x01`\xA0\x1B\x03\x16`\x14a5\xB0V[a0\xBE\x83` a5\xB0V[`@Q` \x01a0\xCF\x92\x91\x90aE#V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90RbF\x1B\xCD`\xE5\x1B\x82Ra\x08\xAB\x91`\x04\x01aE\x8DV[_\x82\x81R`e` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x84R\x90\x91R\x90 T`\xFF\x16a\x0E?W_\x82\x81R`e` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x84R\x90\x91R\x90 \x80T`\xFF\x19\x16`\x01\x17\x90Ua1Q3\x90V[`\x01`\x01`\xA0\x1B\x03\x16\x81`\x01`\x01`\xA0\x1B\x03\x16\x83\x7F/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r`@Q`@Q\x80\x91\x03\x90\xA4PPV[_a\x0B\xCB\x83`\x01`\x01`\xA0\x1B\x03\x84\x16a7\xD3V[_\x82\x81R`e` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x84R\x90\x91R\x90 T`\xFF\x16\x15a\x0E?W_\x82\x81R`e` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x85\x16\x80\x85R\x92R\x80\x83 \x80T`\xFF\x19\x16\x90UQ3\x92\x85\x91\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x91\x90\xA4PPV[_a\x0B\xCB\x83`\x01`\x01`\xA0\x1B\x03\x84\x16a8\x1FV[_\x80_a2K\x85\x85a9\tV[\x91P\x91Pa2X\x81a9HV[P\x93\x92PPPV[_\x80a2k\x85a.oV[\x81T\x91\x93P\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x86\x16`\x01`\xA0\x1B\x90\x92\x04\x16\x10a2\xCAW`@Q\x7FE\x1F\x874\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x16`\x04\x82\x01R`$\x01a\x08\xABV[`@\x80Q\x80\x82\x01\x90\x91R`\x01`\x01`\xA0\x1B\x03\x84\x16\x81Rg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x85\x16` \x82\x01R`\x01\x82\x18\x90\x86`\xFF\x83\x16`\x02\x81\x10a3\nWa3\na@SV[\x82Q\x91\x01\x80T` \x90\x93\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x01`\xA0\x1B\x02`\x01`\x01`\xE0\x1B\x03\x19\x90\x93\x16`\x01`\x01`\xA0\x1B\x03\x90\x92\x16\x91\x90\x91\x17\x91\x90\x91\x17\x90UPPPPPPV[_a3Z\x84\x83a(CV[\x90P\x80\x15\x80a3hWP\x82\x81\x10[\x15a3\xA9W`@Q\x7F\xCFG\x91\x81\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x84\x90R`$\x81\x01\x82\x90R`D\x01a\x08\xABV[\x82\x84_\x01_\x82\x82Ta3\xBB\x91\x90aC\xD4V[\x90\x91UPPPPPPV[_a4\x1A\x82`@Q\x80`@\x01`@R\x80` \x81R` \x01\x7FSafeERC20: low-level call failed\x81RP\x85`\x01`\x01`\xA0\x1B\x03\x16a;3\x90\x92\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x80Q\x90\x91P\x15a\r\xB2W\x80\x80` \x01\x90Q\x81\x01\x90a48\x91\x90aE\xC2V[a\r\xB2W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`*`$\x82\x01R\x7FSafeERC20: ERC20 operation did n`D\x82\x01R\x7Fot succeed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08\xABV[_\x82_\x01\x82\x81T\x81\x10a4\xBFWa4\xBFa@SV[\x90_R` _ \x01T\x90P\x92\x91PPV[_Ta\x01\0\x90\x04`\xFF\x16a5LW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7FInitializable: contract is not i`D\x82\x01R\x7Fnitializing\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08\xABV[\x81Q` \x92\x83\x01 \x81Q\x91\x90\x92\x01 `\xC9\x91\x90\x91U`\xCAUV[_\x82\x81R`e` R`@\x80\x82 `\x01\x01\x80T\x90\x84\x90U\x90Q\x90\x91\x83\x91\x83\x91\x86\x91\x7F\xBDy\xB8o\xFE\n\xB8\xE8waQQB\x17\xCD|\xAC\xD5,\x90\x9FfG\\:\xF4N\x12\x9F\x0B\0\xFF\x91\x90\xA4PPPV[``_a5\xBE\x83`\x02aE\xE1V[a5\xC9\x90`\x02aC\xC1V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a5\xE1Wa5\xE1a@\x9CV[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a6\x0BW` \x82\x01\x81\x806\x837\x01\x90P[P\x90P\x7F0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81_\x81Q\x81\x10a6AWa6Aa@SV[` \x01\x01\x90~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x90\x81_\x1A\x90SP\x7Fx\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81`\x01\x81Q\x81\x10a6\xA3Wa6\xA3a@SV[` \x01\x01\x90~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x90\x81_\x1A\x90SP_a6\xDD\x84`\x02aE\xE1V[a6\xE8\x90`\x01aC\xC1V[\x90P[`\x01\x81\x11\x15a7\x84W\x7F0123456789abcdef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85`\x0F\x16`\x10\x81\x10a7)Wa7)a@SV[\x1A`\xF8\x1B\x82\x82\x81Q\x81\x10a7?Wa7?a@SV[` \x01\x01\x90~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x90\x81_\x1A\x90SP`\x04\x94\x90\x94\x1C\x93a7}\x81aE\xF8V[\x90Pa6\xEBV[P\x83\x15a\x0B\xCBW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FStrings: hex length insufficient`D\x82\x01R`d\x01a\x08\xABV[_\x81\x81R`\x01\x83\x01` R`@\x81 Ta8\x18WP\x81T`\x01\x81\x81\x01\x84U_\x84\x81R` \x80\x82 \x90\x93\x01\x84\x90U\x84T\x84\x82R\x82\x86\x01\x90\x93R`@\x90 \x91\x90\x91Ua\n\xD5V[P_a\n\xD5V[_\x81\x81R`\x01\x83\x01` R`@\x81 T\x80\x15a8\xF9W_a8A`\x01\x83aC\xD4V[\x85T\x90\x91P_\x90a8T\x90`\x01\x90aC\xD4V[\x90P\x81\x81\x14a8\xB3W_\x86_\x01\x82\x81T\x81\x10a8rWa8ra@SV[\x90_R` _ \x01T\x90P\x80\x87_\x01\x84\x81T\x81\x10a8\x92Wa8\x92a@SV[_\x91\x82R` \x80\x83 \x90\x91\x01\x92\x90\x92U\x91\x82R`\x01\x88\x01\x90R`@\x90 \x83\x90U[\x85T\x86\x90\x80a8\xC4Wa8\xC4aF,V[`\x01\x90\x03\x81\x81\x90_R` _ \x01_\x90U\x90U\x85`\x01\x01_\x86\x81R` \x01\x90\x81R` \x01_ _\x90U`\x01\x93PPPPa\n\xD5V[_\x91PPa\n\xD5V[P\x92\x91PPV[_\x80\x82Q`A\x03a9=W` \x83\x01Q`@\x84\x01Q``\x85\x01Q_\x1Aa91\x87\x82\x85\x85a;AV[\x94P\x94PPPPa$QV[P_\x90P`\x02a$QV[_\x81`\x04\x81\x11\x15a9[Wa9[aF@V[\x03a9cWPV[`\x01\x81`\x04\x81\x11\x15a9wWa9waF@V[\x03a9\xC4W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x18`$\x82\x01R\x7FECDSA: invalid signature\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x08\xABV[`\x02\x81`\x04\x81\x11\x15a9\xD8Wa9\xD8aF@V[\x03a:%W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1F`$\x82\x01R\x7FECDSA: invalid signature length\0`D\x82\x01R`d\x01a\x08\xABV[`\x03\x81`\x04\x81\x11\x15a:9Wa:9aF@V[\x03a:\xACW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7FECDSA: invalid signature 's' val`D\x82\x01R\x7Fue\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08\xABV[`\x04\x81`\x04\x81\x11\x15a:\xC0Wa:\xC0aF@V[\x03a\x12\x93W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7FECDSA: invalid signature 'v' val`D\x82\x01R\x7Fue\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08\xABV[``a\x0B\xC8\x84\x84_\x85a<&V[_\x80\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0\x83\x11\x15a;vWP_\x90P`\x03a<\x1DV[\x84`\xFF\x16`\x1B\x14\x15\x80\x15a;\x8EWP\x84`\xFF\x16`\x1C\x14\x15[\x15a;\x9EWP_\x90P`\x04a<\x1DV[`@\x80Q_\x80\x82R` \x82\x01\x80\x84R\x89\x90R`\xFF\x88\x16\x92\x82\x01\x92\x90\x92R``\x81\x01\x86\x90R`\x80\x81\x01\x85\x90R`\x01\x90`\xA0\x01` `@Q` \x81\x03\x90\x80\x84\x03\x90\x85Z\xFA\x15\x80\x15a;\xEFW=_\x80>=_\xFD[PP`@Q`\x1F\x19\x01Q\x91PP`\x01`\x01`\xA0\x1B\x03\x81\x16a<\x17W_`\x01\x92P\x92PPa<\x1DV[\x91P_\x90P[\x94P\x94\x92PPPV[``\x82G\x10\x15a<\x9EW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FAddress: insufficient balance fo`D\x82\x01R\x7Fr call\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08\xABV[`\x01`\x01`\xA0\x1B\x03\x85\x16;a<\xF5W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FAddress: call to non-contract\0\0\0`D\x82\x01R`d\x01a\x08\xABV[_\x80\x86`\x01`\x01`\xA0\x1B\x03\x16\x85\x87`@Qa=\x10\x91\x90aFTV[_`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80_\x81\x14a=JW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a=OV[``\x91P[P\x91P\x91Pa=_\x82\x82\x86a=jV[\x97\x96PPPPPPPV[``\x83\x15a=yWP\x81a\x0B\xCBV[\x82Q\x15a=\x89W\x82Q\x80\x84` \x01\xFD[\x81`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x08\xAB\x91\x90aE\x8DV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x12\x93W_\x80\xFD[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x12\x93W_\x80\xFD[_\x80`@\x83\x85\x03\x12\x15a=\xDDW_\x80\xFD[\x825a=\xE8\x81a=\xA3V[\x91P` \x83\x015a=\xF8\x81a=\xB8V[\x80\x91PP\x92P\x92\x90PV[_` \x82\x84\x03\x12\x15a>\x13W_\x80\xFD[\x815`\x01`\x01`\xE0\x1B\x03\x19\x81\x16\x81\x14a\x0B\xCBW_\x80\xFD[_` \x82\x84\x03\x12\x15a>:W_\x80\xFD[\x815a\x0B\xCB\x81a=\xB8V[_\x80_``\x84\x86\x03\x12\x15a>WW_\x80\xFD[\x835a>b\x81a=\xA3V[\x92P` \x84\x015a>r\x81a=\xB8V[\x92\x95\x92\x94PPP`@\x91\x90\x91\x015\x90V[\x82Q`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x80\x84\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x82\x01R`\x80\x81\x01\x82Q`\x01`\x01`\xA0\x1B\x03\x16`@\x83\x01R` \x83\x01Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16``\x83\x01Ra\x0B\xCBV[_` \x82\x84\x03\x12\x15a>\xE1W_\x80\xFD[P5\x91\x90PV[_\x80`@\x83\x85\x03\x12\x15a>\xF9W_\x80\xFD[\x825\x91P` \x83\x015a=\xF8\x81a=\xB8V[_``\x82\x84\x03\x12\x15a?\x1BW_\x80\xFD[P\x91\x90PV[_\x80`@\x83\x85\x03\x12\x15a?2W_\x80\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a?IW_\x80\xFD[a?U\x86\x83\x87\x01a?\x0BV[\x93P` \x85\x015\x91P\x80\x82\x11\x15a?jW_\x80\xFD[Pa?w\x85\x82\x86\x01a?\x0BV[\x91PP\x92P\x92\x90PV[_\x80`@\x83\x85\x03\x12\x15a?\x92W_\x80\xFD[\x825a?\x9D\x81a=\xB8V[\x91P` \x83\x015a=\xF8\x81a=\xA3V[_` \x82\x84\x03\x12\x15a?\xBDW_\x80\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a?\xD3W_\x80\xFD[a?\xDF\x84\x82\x85\x01a?\x0BV[\x94\x93PPPPV[_` \x82\x84\x03\x12\x15a?\xF7W_\x80\xFD[\x815a\x0B\xCB\x81a=\xA3V[_\x80`@\x83\x85\x03\x12\x15a@\x13W_\x80\xFD[PP\x805\x92` \x90\x91\x015\x91PV[_a\x01\xE0\x82\x84\x03\x12\x15a?\x1BW_\x80\xFD[_`@\x82\x84\x03\x12\x15a?\x1BW_\x80\xFD[_`\x80\x82\x84\x03\x12\x15a?\x1BW_\x80\xFD[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x81\x16\x83\x82\x16\x01\x90\x80\x82\x11\x15a9\x02Wa9\x02a@gV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Q``\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a@\xD3Wa@\xD3a@\x9CV[`@R\x90V[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15aA\x02WaA\x02a@\x9CV[`@R\x91\x90PV[_``\x826\x03\x12\x15aA\x1AW_\x80\xFD[aA\"a@\xB0V[\x825aA-\x81a=\xB8V[\x81R` \x83\x81\x015\x81\x83\x01R`@\x84\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15aASW_\x80\xFD[\x90\x85\x01\x906`\x1F\x83\x01\x12aAeW_\x80\xFD[\x815\x81\x81\x11\x15aAwWaAwa@\x9CV[aA\x89\x84`\x1F\x19`\x1F\x84\x01\x16\x01a@\xD9V[\x91P\x80\x82R6\x84\x82\x85\x01\x01\x11\x15aA\x9EW_\x80\xFD[\x80\x84\x84\x01\x85\x84\x017_\x90\x82\x01\x90\x93\x01\x92\x90\x92RP`@\x82\x01R\x92\x91PPV[\x80`\x07\x0B\x81\x14a\x12\x93W_\x80\xFD[_` \x82\x84\x03\x12\x15aA\xDBW_\x80\xFD[\x815a\x0B\xCB\x81aA\xBDV[\x815aA\xF1\x81a=\xB8V[`\x01`\x01`\xA0\x1B\x03\x81\x16\x90P\x81T\x81s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x82\x16\x17\x83U` \x84\x015aB)\x81a=\xA3V[{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81`\xA0\x1B\x16\x83`\x01`\x01`\xE0\x1B\x03\x19\x84\x16\x17\x17\x84UPPPPPV[_`\x80\x82\x84\x03\x12\x15aBrW_\x80\xFD[`@Q`\x80\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15aB\x95WaB\x95a@\x9CV[`@R\x825aB\xA3\x81aA\xBDV[\x81R` \x83\x015aB\xB3\x81a=\xA3V[` \x82\x01R`@\x83\x015aB\xC6\x81a=\xA3V[`@\x82\x01R``\x83\x015aB\xD9\x81a=\xA3V[``\x82\x01R\x93\x92PPPV[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x84\x16\x80aC\x13WaC\x13aB\xE5V[\x92\x16\x91\x90\x91\x04\x92\x91PPV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x81\x16\x83\x82\x16\x02\x80\x82\x16\x91\x90\x82\x81\x14aCCWaCCa@gV[PP\x92\x91PPV[`\x07\x81\x81\x0B\x90\x83\x90\x0B\x01g\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x13g\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x82\x12\x17\x15a\n\xD5Wa\n\xD5a@gV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x81\x16\x82\x82\x16\x03\x90\x80\x82\x11\x15a9\x02Wa9\x02a@gV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x84\x16\x80aC\xB5WaC\xB5aB\xE5V[\x92\x16\x91\x90\x91\x06\x92\x91PPV[\x80\x82\x01\x80\x82\x11\x15a\n\xD5Wa\n\xD5a@gV[\x81\x81\x03\x81\x81\x11\x15a\n\xD5Wa\n\xD5a@gV[\x815aC\xF2\x81aA\xBDV[\x81Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x81\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x83\x16\x17\x84U` \x85\x015aD\x1D\x81a=\xA3V[o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0`@\x91\x82\x1B\x16\x91\x90\x93\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83\x16\x81\x17\x82\x17\x85U\x92\x85\x015\x90aDo\x82a=\xA3V[w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82`\x80\x1B\x16\x91P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x85\x82\x86\x16\x17\x83\x17\x17\x86U``\x87\x015\x93PaD\xCB\x84a=\xA3V[\x93\x17\x17`\xC0\x91\x90\x91\x1B\x90\x91\x16\x17\x90UPV[`\x07\x82\x81\x0B\x90\x82\x90\x0B\x03g\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x81\x12g\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x13\x17\x15a\n\xD5Wa\n\xD5a@gV[_\x81Q\x80` \x84\x01\x85^_\x93\x01\x92\x83RP\x90\x91\x90PV[\x7FAccessControl: account \0\0\0\0\0\0\0\0\0\x81R_aET`\x17\x83\x01\x85aE\x0CV[\x7F is missing role \0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81RaE\x84`\x11\x82\x01\x85aE\x0CV[\x95\x94PPPPPV[` \x81R_\x82Q\x80` \x84\x01R\x80` \x85\x01`@\x85\x01^_`@\x82\x85\x01\x01R`@`\x1F\x19`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x92\x91PPV[_` \x82\x84\x03\x12\x15aE\xD2W_\x80\xFD[\x81Q\x80\x15\x15\x81\x14a\x0B\xCBW_\x80\xFD[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\n\xD5Wa\n\xD5a@gV[_\x81aF\x06WaF\x06a@gV[P\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x01\x90V[cNH{q`\xE0\x1B_R`1`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[_a\x0B\xCB\x82\x84aE\x0CV\xFE\xA2dipfsX\"\x12 '\0KM\x966\xDA|\xC5\x18\xF5H\xAA6\xAE\x81\xF3\x8E\x90\x95w`\xB4\xAD\x93\xD5\xDB\x05^\x9B\xA0\xA3dsolcC\0\x08\x19\x003",
    );
    /**```solidity
struct Bid { address expressLaneController; uint256 amount; bytes signature; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Bid {
        #[allow(missing_docs)]
        pub expressLaneController: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub signature: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Bytes,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Bytes,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Bid> for UnderlyingRustTuple<'_> {
            fn from(value: Bid) -> Self {
                (value.expressLaneController, value.amount, value.signature)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Bid {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    expressLaneController: tuple.0,
                    amount: tuple.1,
                    signature: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Bid {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Bid {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.expressLaneController,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.signature,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Bid {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Bid {
            const NAME: &'static str = "Bid";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Bid(address expressLaneController,uint256 amount,bytes signature)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.expressLaneController,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.signature,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Bid {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expressLaneController,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.signature,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expressLaneController,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.signature,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ELCRound { address expressLaneController; uint64 round; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ELCRound {
        #[allow(missing_docs)]
        pub expressLaneController: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub round: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, u64);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ELCRound> for UnderlyingRustTuple<'_> {
            fn from(value: ELCRound) -> Self {
                (value.expressLaneController, value.round)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ELCRound {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    expressLaneController: tuple.0,
                    round: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ELCRound {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ELCRound {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.expressLaneController,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.round),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ELCRound {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ELCRound {
            const NAME: &'static str = "ELCRound";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ELCRound(address expressLaneController,uint64 round)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.expressLaneController,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.round)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ELCRound {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expressLaneController,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.round)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expressLaneController,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.round,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct InitArgs { address _auctioneer; address _biddingToken; address _beneficiary; RoundTimingInfo _roundTimingInfo; uint256 _minReservePrice; address _auctioneerAdmin; address _minReservePriceSetter; address _reservePriceSetter; address _reservePriceSetterAdmin; address _beneficiarySetter; address _roundTimingSetter; address _masterAdmin; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InitArgs {
        #[allow(missing_docs)]
        pub _auctioneer: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _biddingToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _beneficiary: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _roundTimingInfo: <RoundTimingInfo as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub _minReservePrice: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _auctioneerAdmin: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _minReservePriceSetter: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _reservePriceSetter: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _reservePriceSetterAdmin: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _beneficiarySetter: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _roundTimingSetter: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _masterAdmin: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            RoundTimingInfo,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            <RoundTimingInfo as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InitArgs> for UnderlyingRustTuple<'_> {
            fn from(value: InitArgs) -> Self {
                (
                    value._auctioneer,
                    value._biddingToken,
                    value._beneficiary,
                    value._roundTimingInfo,
                    value._minReservePrice,
                    value._auctioneerAdmin,
                    value._minReservePriceSetter,
                    value._reservePriceSetter,
                    value._reservePriceSetterAdmin,
                    value._beneficiarySetter,
                    value._roundTimingSetter,
                    value._masterAdmin,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InitArgs {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    _auctioneer: tuple.0,
                    _biddingToken: tuple.1,
                    _beneficiary: tuple.2,
                    _roundTimingInfo: tuple.3,
                    _minReservePrice: tuple.4,
                    _auctioneerAdmin: tuple.5,
                    _minReservePriceSetter: tuple.6,
                    _reservePriceSetter: tuple.7,
                    _reservePriceSetterAdmin: tuple.8,
                    _beneficiarySetter: tuple.9,
                    _roundTimingSetter: tuple.10,
                    _masterAdmin: tuple.11,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for InitArgs {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for InitArgs {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._auctioneer,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._biddingToken,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._beneficiary,
                    ),
                    <RoundTimingInfo as alloy_sol_types::SolType>::tokenize(
                        &self._roundTimingInfo,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._minReservePrice),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._auctioneerAdmin,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._minReservePriceSetter,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._reservePriceSetter,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._reservePriceSetterAdmin,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._beneficiarySetter,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._roundTimingSetter,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._masterAdmin,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for InitArgs {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for InitArgs {
            const NAME: &'static str = "InitArgs";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "InitArgs(address _auctioneer,address _biddingToken,address _beneficiary,RoundTimingInfo _roundTimingInfo,uint256 _minReservePrice,address _auctioneerAdmin,address _minReservePriceSetter,address _reservePriceSetter,address _reservePriceSetterAdmin,address _beneficiarySetter,address _roundTimingSetter,address _masterAdmin)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <RoundTimingInfo as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <RoundTimingInfo as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self._auctioneer,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self._biddingToken,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self._beneficiary,
                        )
                        .0,
                    <RoundTimingInfo as alloy_sol_types::SolType>::eip712_data_word(
                            &self._roundTimingInfo,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self._minReservePrice,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self._auctioneerAdmin,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self._minReservePriceSetter,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self._reservePriceSetter,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self._reservePriceSetterAdmin,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self._beneficiarySetter,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self._roundTimingSetter,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self._masterAdmin,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for InitArgs {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust._auctioneer,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust._biddingToken,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust._beneficiary,
                    )
                    + <RoundTimingInfo as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust._roundTimingInfo,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust._minReservePrice,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust._auctioneerAdmin,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust._minReservePriceSetter,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust._reservePriceSetter,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust._reservePriceSetterAdmin,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust._beneficiarySetter,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust._roundTimingSetter,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust._masterAdmin,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust._auctioneer,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust._biddingToken,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust._beneficiary,
                    out,
                );
                <RoundTimingInfo as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust._roundTimingInfo,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust._minReservePrice,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust._auctioneerAdmin,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust._minReservePriceSetter,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust._reservePriceSetter,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust._reservePriceSetterAdmin,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust._beneficiarySetter,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust._roundTimingSetter,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust._masterAdmin,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct RoundTimingInfo { int64 offsetTimestamp; uint64 roundDurationSeconds; uint64 auctionClosingSeconds; uint64 reserveSubmissionSeconds; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RoundTimingInfo {
        #[allow(missing_docs)]
        pub offsetTimestamp: i64,
        #[allow(missing_docs)]
        pub roundDurationSeconds: u64,
        #[allow(missing_docs)]
        pub auctionClosingSeconds: u64,
        #[allow(missing_docs)]
        pub reserveSubmissionSeconds: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Int<64>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (i64, u64, u64, u64);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<RoundTimingInfo> for UnderlyingRustTuple<'_> {
            fn from(value: RoundTimingInfo) -> Self {
                (
                    value.offsetTimestamp,
                    value.roundDurationSeconds,
                    value.auctionClosingSeconds,
                    value.reserveSubmissionSeconds,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for RoundTimingInfo {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    offsetTimestamp: tuple.0,
                    roundDurationSeconds: tuple.1,
                    auctionClosingSeconds: tuple.2,
                    reserveSubmissionSeconds: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for RoundTimingInfo {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for RoundTimingInfo {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.offsetTimestamp),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.roundDurationSeconds),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.auctionClosingSeconds,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.reserveSubmissionSeconds,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for RoundTimingInfo {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for RoundTimingInfo {
            const NAME: &'static str = "RoundTimingInfo";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "RoundTimingInfo(int64 offsetTimestamp,uint64 roundDurationSeconds,uint64 auctionClosingSeconds,uint64 reserveSubmissionSeconds)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Int<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.offsetTimestamp,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.roundDurationSeconds,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.auctionClosingSeconds,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.reserveSubmissionSeconds,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for RoundTimingInfo {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Int<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.offsetTimestamp,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.roundDurationSeconds,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.auctionClosingSeconds,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.reserveSubmissionSeconds,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Int<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.offsetTimestamp,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.roundDurationSeconds,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.auctionClosingSeconds,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.reserveSubmissionSeconds,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct Transferor { address addr; uint64 fixedUntilRound; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Transferor {
        #[allow(missing_docs)]
        pub addr: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub fixedUntilRound: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, u64);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Transferor> for UnderlyingRustTuple<'_> {
            fn from(value: Transferor) -> Self {
                (value.addr, value.fixedUntilRound)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Transferor {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    addr: tuple.0,
                    fixedUntilRound: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Transferor {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Transferor {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.addr,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.fixedUntilRound),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Transferor {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Transferor {
            const NAME: &'static str = "Transferor";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Transferor(address addr,uint64 fixedUntilRound)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.addr,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.fixedUntilRound,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Transferor {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.addr,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.fixedUntilRound,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.addr,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.fixedUntilRound,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Custom error with signature `AuctionNotClosed()` and selector `0xb9adeefd`.
```solidity
error AuctionNotClosed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AuctionNotClosed {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AuctionNotClosed> for UnderlyingRustTuple<'_> {
            fn from(value: AuctionNotClosed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AuctionNotClosed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AuctionNotClosed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AuctionNotClosed()";
            const SELECTOR: [u8; 4] = [185u8, 173u8, 238u8, 253u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `BidsWrongOrder()` and selector `0xa234cb19`.
```solidity
error BidsWrongOrder();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BidsWrongOrder {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BidsWrongOrder> for UnderlyingRustTuple<'_> {
            fn from(value: BidsWrongOrder) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BidsWrongOrder {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BidsWrongOrder {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BidsWrongOrder()";
            const SELECTOR: [u8; 4] = [162u8, 52u8, 203u8, 25u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `FixedTransferor(uint64)` and selector `0x75d899f2`.
```solidity
error FixedTransferor(uint64 fixedUntilRound);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FixedTransferor {
        #[allow(missing_docs)]
        pub fixedUntilRound: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FixedTransferor> for UnderlyingRustTuple<'_> {
            fn from(value: FixedTransferor) -> Self {
                (value.fixedUntilRound,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FixedTransferor {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { fixedUntilRound: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FixedTransferor {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FixedTransferor(uint64)";
            const SELECTOR: [u8; 4] = [117u8, 216u8, 153u8, 242u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.fixedUntilRound),
                )
            }
        }
    };
    /**Custom error with signature `InsufficientBalance(uint256,uint256)` and selector `0xcf479181`.
```solidity
error InsufficientBalance(uint256 amountRequested, uint256 balance);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientBalance {
        #[allow(missing_docs)]
        pub amountRequested: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub balance: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientBalance> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientBalance) -> Self {
                (value.amountRequested, value.balance)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientBalance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    amountRequested: tuple.0,
                    balance: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientBalance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientBalance(uint256,uint256)";
            const SELECTOR: [u8; 4] = [207u8, 71u8, 145u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amountRequested),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.balance),
                )
            }
        }
    };
    /**Custom error with signature `InsufficientBalanceAcc(address,uint256,uint256)` and selector `0x36b24c14`.
```solidity
error InsufficientBalanceAcc(address account, uint256 amountRequested, uint256 balance);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientBalanceAcc {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amountRequested: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub balance: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientBalanceAcc> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientBalanceAcc) -> Self {
                (value.account, value.amountRequested, value.balance)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientBalanceAcc {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    amountRequested: tuple.1,
                    balance: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientBalanceAcc {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientBalanceAcc(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [54u8, 178u8, 76u8, 20u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amountRequested),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.balance),
                )
            }
        }
    };
    /**Custom error with signature `InvalidNewRound(uint64,uint64)` and selector `0x68c18ca9`.
```solidity
error InvalidNewRound(uint64 currentRound, uint64 newRound);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidNewRound {
        #[allow(missing_docs)]
        pub currentRound: u64,
        #[allow(missing_docs)]
        pub newRound: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64, u64);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidNewRound> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidNewRound) -> Self {
                (value.currentRound, value.newRound)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidNewRound {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    currentRound: tuple.0,
                    newRound: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidNewRound {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidNewRound(uint64,uint64)";
            const SELECTOR: [u8; 4] = [104u8, 193u8, 140u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.currentRound),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.newRound),
                )
            }
        }
    };
    /**Custom error with signature `InvalidNewStart(uint64,uint64)` and selector `0xa0e269d8`.
```solidity
error InvalidNewStart(uint64 currentStart, uint64 newStart);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidNewStart {
        #[allow(missing_docs)]
        pub currentStart: u64,
        #[allow(missing_docs)]
        pub newStart: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64, u64);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidNewStart> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidNewStart) -> Self {
                (value.currentStart, value.newStart)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidNewStart {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    currentStart: tuple.0,
                    newStart: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidNewStart {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidNewStart(uint64,uint64)";
            const SELECTOR: [u8; 4] = [160u8, 226u8, 105u8, 216u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.currentStart),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.newStart),
                )
            }
        }
    };
    /**Custom error with signature `NegativeOffset()` and selector `0x16f46dfe`.
```solidity
error NegativeOffset();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NegativeOffset {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NegativeOffset> for UnderlyingRustTuple<'_> {
            fn from(value: NegativeOffset) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NegativeOffset {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NegativeOffset {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NegativeOffset()";
            const SELECTOR: [u8; 4] = [22u8, 244u8, 109u8, 254u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `NegativeRoundStart(int64)` and selector `0xf160ad79`.
```solidity
error NegativeRoundStart(int64 roundStart);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NegativeRoundStart {
        #[allow(missing_docs)]
        pub roundStart: i64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Int<64>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (i64,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NegativeRoundStart> for UnderlyingRustTuple<'_> {
            fn from(value: NegativeRoundStart) -> Self {
                (value.roundStart,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NegativeRoundStart {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { roundStart: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NegativeRoundStart {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NegativeRoundStart(int64)";
            const SELECTOR: [u8; 4] = [241u8, 96u8, 173u8, 121u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.roundStart),
                )
            }
        }
    };
    /**Custom error with signature `NotExpressLaneController(uint64,address,address)` and selector `0x660af6d2`.
```solidity
error NotExpressLaneController(uint64 round, address controller, address sender);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotExpressLaneController {
        #[allow(missing_docs)]
        pub round: u64,
        #[allow(missing_docs)]
        pub controller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            u64,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotExpressLaneController>
        for UnderlyingRustTuple<'_> {
            fn from(value: NotExpressLaneController) -> Self {
                (value.round, value.controller, value.sender)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for NotExpressLaneController {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    round: tuple.0,
                    controller: tuple.1,
                    sender: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotExpressLaneController {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotExpressLaneController(uint64,address,address)";
            const SELECTOR: [u8; 4] = [102u8, 10u8, 246u8, 210u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.round),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.controller,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `NotTransferor(uint64,address,address)` and selector `0x7621d94a`.
```solidity
error NotTransferor(uint64 round, address expectedTransferor, address msgSender);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotTransferor {
        #[allow(missing_docs)]
        pub round: u64,
        #[allow(missing_docs)]
        pub expectedTransferor: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub msgSender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            u64,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotTransferor> for UnderlyingRustTuple<'_> {
            fn from(value: NotTransferor) -> Self {
                (value.round, value.expectedTransferor, value.msgSender)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotTransferor {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    round: tuple.0,
                    expectedTransferor: tuple.1,
                    msgSender: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotTransferor {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotTransferor(uint64,address,address)";
            const SELECTOR: [u8; 4] = [118u8, 33u8, 217u8, 74u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.round),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.expectedTransferor,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.msgSender,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `NothingToWithdraw()` and selector `0xd0d04f60`.
```solidity
error NothingToWithdraw();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NothingToWithdraw {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NothingToWithdraw> for UnderlyingRustTuple<'_> {
            fn from(value: NothingToWithdraw) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NothingToWithdraw {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NothingToWithdraw {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NothingToWithdraw()";
            const SELECTOR: [u8; 4] = [208u8, 208u8, 79u8, 96u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ReserveBlackout()` and selector `0x4f006978`.
```solidity
error ReserveBlackout();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ReserveBlackout {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ReserveBlackout> for UnderlyingRustTuple<'_> {
            fn from(value: ReserveBlackout) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ReserveBlackout {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ReserveBlackout {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ReserveBlackout()";
            const SELECTOR: [u8; 4] = [79u8, 0u8, 105u8, 120u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ReservePriceNotMet(uint256,uint256)` and selector `0x56f9b75a`.
```solidity
error ReservePriceNotMet(uint256 bidAmount, uint256 reservePrice);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ReservePriceNotMet {
        #[allow(missing_docs)]
        pub bidAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub reservePrice: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ReservePriceNotMet> for UnderlyingRustTuple<'_> {
            fn from(value: ReservePriceNotMet) -> Self {
                (value.bidAmount, value.reservePrice)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ReservePriceNotMet {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    bidAmount: tuple.0,
                    reservePrice: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ReservePriceNotMet {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ReservePriceNotMet(uint256,uint256)";
            const SELECTOR: [u8; 4] = [86u8, 249u8, 183u8, 90u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.bidAmount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.reservePrice),
                )
            }
        }
    };
    /**Custom error with signature `ReservePriceTooLow(uint256,uint256)` and selector `0xda4f272e`.
```solidity
error ReservePriceTooLow(uint256 reservePrice, uint256 minReservePrice);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ReservePriceTooLow {
        #[allow(missing_docs)]
        pub reservePrice: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub minReservePrice: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ReservePriceTooLow> for UnderlyingRustTuple<'_> {
            fn from(value: ReservePriceTooLow) -> Self {
                (value.reservePrice, value.minReservePrice)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ReservePriceTooLow {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    reservePrice: tuple.0,
                    minReservePrice: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ReservePriceTooLow {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ReservePriceTooLow(uint256,uint256)";
            const SELECTOR: [u8; 4] = [218u8, 79u8, 39u8, 46u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.reservePrice),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.minReservePrice),
                )
            }
        }
    };
    /**Custom error with signature `RoundAlreadyResolved(uint64)` and selector `0x451f8734`.
```solidity
error RoundAlreadyResolved(uint64 round);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RoundAlreadyResolved {
        #[allow(missing_docs)]
        pub round: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<RoundAlreadyResolved> for UnderlyingRustTuple<'_> {
            fn from(value: RoundAlreadyResolved) -> Self {
                (value.round,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for RoundAlreadyResolved {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { round: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for RoundAlreadyResolved {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "RoundAlreadyResolved(uint64)";
            const SELECTOR: [u8; 4] = [69u8, 31u8, 135u8, 52u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.round),
                )
            }
        }
    };
    /**Custom error with signature `RoundDurationTooShort()` and selector `0x326de360`.
```solidity
error RoundDurationTooShort();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RoundDurationTooShort {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<RoundDurationTooShort> for UnderlyingRustTuple<'_> {
            fn from(value: RoundDurationTooShort) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for RoundDurationTooShort {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for RoundDurationTooShort {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "RoundDurationTooShort()";
            const SELECTOR: [u8; 4] = [50u8, 109u8, 227u8, 96u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `RoundNotResolved(uint64)` and selector `0xfbb052d8`.
```solidity
error RoundNotResolved(uint64 round);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RoundNotResolved {
        #[allow(missing_docs)]
        pub round: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<RoundNotResolved> for UnderlyingRustTuple<'_> {
            fn from(value: RoundNotResolved) -> Self {
                (value.round,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for RoundNotResolved {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { round: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for RoundNotResolved {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "RoundNotResolved(uint64)";
            const SELECTOR: [u8; 4] = [251u8, 176u8, 82u8, 216u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.round),
                )
            }
        }
    };
    /**Custom error with signature `RoundTooLong(uint64)` and selector `0xc34a76cf`.
```solidity
error RoundTooLong(uint64 roundDurationSeconds);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RoundTooLong {
        #[allow(missing_docs)]
        pub roundDurationSeconds: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<RoundTooLong> for UnderlyingRustTuple<'_> {
            fn from(value: RoundTooLong) -> Self {
                (value.roundDurationSeconds,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for RoundTooLong {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    roundDurationSeconds: tuple.0,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for RoundTooLong {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "RoundTooLong(uint64)";
            const SELECTOR: [u8; 4] = [195u8, 74u8, 118u8, 207u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.roundDurationSeconds),
                )
            }
        }
    };
    /**Custom error with signature `RoundTooOld(uint64,uint64)` and selector `0x395f4fd6`.
```solidity
error RoundTooOld(uint64 round, uint64 currentRound);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RoundTooOld {
        #[allow(missing_docs)]
        pub round: u64,
        #[allow(missing_docs)]
        pub currentRound: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64, u64);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<RoundTooOld> for UnderlyingRustTuple<'_> {
            fn from(value: RoundTooOld) -> Self {
                (value.round, value.currentRound)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for RoundTooOld {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    round: tuple.0,
                    currentRound: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for RoundTooOld {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "RoundTooOld(uint64,uint64)";
            const SELECTOR: [u8; 4] = [57u8, 95u8, 79u8, 214u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.round),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.currentRound),
                )
            }
        }
    };
    /**Custom error with signature `SameBidder()` and selector `0xf4a3e485`.
```solidity
error SameBidder();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SameBidder {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SameBidder> for UnderlyingRustTuple<'_> {
            fn from(value: SameBidder) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SameBidder {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SameBidder {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SameBidder()";
            const SELECTOR: [u8; 4] = [244u8, 163u8, 228u8, 133u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `TieBidsWrongOrder()` and selector `0x9185a0ae`.
```solidity
error TieBidsWrongOrder();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TieBidsWrongOrder {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TieBidsWrongOrder> for UnderlyingRustTuple<'_> {
            fn from(value: TieBidsWrongOrder) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TieBidsWrongOrder {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TieBidsWrongOrder {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TieBidsWrongOrder()";
            const SELECTOR: [u8; 4] = [145u8, 133u8, 160u8, 174u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `WithdrawalInProgress()` and selector `0x04eb6b3f`.
```solidity
error WithdrawalInProgress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct WithdrawalInProgress {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<WithdrawalInProgress> for UnderlyingRustTuple<'_> {
            fn from(value: WithdrawalInProgress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for WithdrawalInProgress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for WithdrawalInProgress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "WithdrawalInProgress()";
            const SELECTOR: [u8; 4] = [4u8, 235u8, 107u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `WithdrawalMaxRound()` and selector `0x3d89ddde`.
```solidity
error WithdrawalMaxRound();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct WithdrawalMaxRound {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<WithdrawalMaxRound> for UnderlyingRustTuple<'_> {
            fn from(value: WithdrawalMaxRound) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for WithdrawalMaxRound {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for WithdrawalMaxRound {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "WithdrawalMaxRound()";
            const SELECTOR: [u8; 4] = [61u8, 137u8, 221u8, 222u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ZeroAmount()` and selector `0x1f2a2005`.
```solidity
error ZeroAmount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAmount {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAmount> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAmount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAmount()";
            const SELECTOR: [u8; 4] = [31u8, 42u8, 32u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ZeroAuctionClosingSeconds()` and selector `0x047bad52`.
```solidity
error ZeroAuctionClosingSeconds();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAuctionClosingSeconds {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAuctionClosingSeconds>
        for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAuctionClosingSeconds) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ZeroAuctionClosingSeconds {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAuctionClosingSeconds {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAuctionClosingSeconds()";
            const SELECTOR: [u8; 4] = [4u8, 123u8, 173u8, 82u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ZeroBiddingToken()` and selector `0x3fb3c7af`.
```solidity
error ZeroBiddingToken();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroBiddingToken {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroBiddingToken> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroBiddingToken) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroBiddingToken {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroBiddingToken {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroBiddingToken()";
            const SELECTOR: [u8; 4] = [63u8, 179u8, 199u8, 175u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Event with signature `AuctionResolved(bool,uint64,address,address,uint256,uint256,uint64,uint64)` and selector `0x7f5bdabbd27a8fc572781b177055488d7c6729a2bade4f57da9d200f31c15d47`.
```solidity
event AuctionResolved(bool indexed isMultiBidAuction, uint64 round, address indexed firstPriceBidder, address indexed firstPriceExpressLaneController, uint256 firstPriceAmount, uint256 price, uint64 roundStartTimestamp, uint64 roundEndTimestamp);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct AuctionResolved {
        #[allow(missing_docs)]
        pub isMultiBidAuction: bool,
        #[allow(missing_docs)]
        pub round: u64,
        #[allow(missing_docs)]
        pub firstPriceBidder: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub firstPriceExpressLaneController: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub firstPriceAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub price: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub roundStartTimestamp: u64,
        #[allow(missing_docs)]
        pub roundEndTimestamp: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for AuctionResolved {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "AuctionResolved(bool,uint64,address,address,uint256,uint256,uint64,uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                127u8,
                91u8,
                218u8,
                187u8,
                210u8,
                122u8,
                143u8,
                197u8,
                114u8,
                120u8,
                27u8,
                23u8,
                112u8,
                85u8,
                72u8,
                141u8,
                124u8,
                103u8,
                41u8,
                162u8,
                186u8,
                222u8,
                79u8,
                87u8,
                218u8,
                157u8,
                32u8,
                15u8,
                49u8,
                193u8,
                93u8,
                71u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    isMultiBidAuction: topics.1,
                    round: data.0,
                    firstPriceBidder: topics.2,
                    firstPriceExpressLaneController: topics.3,
                    firstPriceAmount: data.1,
                    price: data.2,
                    roundStartTimestamp: data.3,
                    roundEndTimestamp: data.4,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.round),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.firstPriceAmount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.price),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.roundStartTimestamp),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.roundEndTimestamp),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.isMultiBidAuction.clone(),
                    self.firstPriceBidder.clone(),
                    self.firstPriceExpressLaneController.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic(
                    &self.isMultiBidAuction,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.firstPriceBidder,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.firstPriceExpressLaneController,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for AuctionResolved {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&AuctionResolved> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &AuctionResolved) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Deposit(address,uint256)` and selector `0xe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c`.
```solidity
event Deposit(address indexed account, uint256 amount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Deposit {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Deposit {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Deposit(address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                225u8,
                255u8,
                252u8,
                196u8,
                146u8,
                61u8,
                4u8,
                181u8,
                89u8,
                244u8,
                210u8,
                154u8,
                139u8,
                252u8,
                108u8,
                218u8,
                4u8,
                235u8,
                91u8,
                13u8,
                60u8,
                70u8,
                7u8,
                81u8,
                194u8,
                64u8,
                44u8,
                92u8,
                92u8,
                201u8,
                16u8,
                156u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    account: topics.1,
                    amount: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.account.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Deposit {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Deposit> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Deposit) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Initialized(uint8)` and selector `0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498`.
```solidity
event Initialized(uint8 version);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Initialized {
        #[allow(missing_docs)]
        pub version: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialized {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialized(uint8)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                127u8,
                38u8,
                184u8,
                63u8,
                249u8,
                110u8,
                31u8,
                43u8,
                106u8,
                104u8,
                47u8,
                19u8,
                56u8,
                82u8,
                246u8,
                121u8,
                138u8,
                9u8,
                196u8,
                101u8,
                218u8,
                149u8,
                146u8,
                20u8,
                96u8,
                206u8,
                251u8,
                56u8,
                71u8,
                64u8,
                36u8,
                152u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { version: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.version),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleAdminChanged(bytes32,bytes32,bytes32)` and selector `0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff`.
```solidity
event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleAdminChanged {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub previousAdminRole: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newAdminRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleAdminChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "RoleAdminChanged(bytes32,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    previousAdminRole: topics.2,
                    newAdminRole: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.previousAdminRole.clone(),
                    self.newAdminRole.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.previousAdminRole);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newAdminRole);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleAdminChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleAdminChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleAdminChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleGranted(bytes32,address,address)` and selector `0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d`.
```solidity
event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleGranted {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleGranted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleGranted(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleGranted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleGranted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleGranted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleRevoked(bytes32,address,address)` and selector `0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b`.
```solidity
event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleRevoked {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleRevoked(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `SetBeneficiary(address,address)` and selector `0x8a0149b2f3ddf2c9ee85738165131d82babbb938f749321d59f75750afa7f4e6`.
```solidity
event SetBeneficiary(address oldBeneficiary, address newBeneficiary);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SetBeneficiary {
        #[allow(missing_docs)]
        pub oldBeneficiary: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newBeneficiary: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SetBeneficiary {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "SetBeneficiary(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                138u8,
                1u8,
                73u8,
                178u8,
                243u8,
                221u8,
                242u8,
                201u8,
                238u8,
                133u8,
                115u8,
                129u8,
                101u8,
                19u8,
                29u8,
                130u8,
                186u8,
                187u8,
                185u8,
                56u8,
                247u8,
                73u8,
                50u8,
                29u8,
                89u8,
                247u8,
                87u8,
                80u8,
                175u8,
                167u8,
                244u8,
                230u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldBeneficiary: data.0,
                    newBeneficiary: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.oldBeneficiary,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newBeneficiary,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SetBeneficiary {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SetBeneficiary> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &SetBeneficiary) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `SetExpressLaneController(uint64,address,address,address,uint64,uint64)` and selector `0xb59adc820ca642dad493a0a6e0bdf979dcae037dea114b70d5c66b1c0b791c4b`.
```solidity
event SetExpressLaneController(uint64 round, address indexed previousExpressLaneController, address indexed newExpressLaneController, address indexed transferor, uint64 startTimestamp, uint64 endTimestamp);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SetExpressLaneController {
        #[allow(missing_docs)]
        pub round: u64,
        #[allow(missing_docs)]
        pub previousExpressLaneController: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newExpressLaneController: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub transferor: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub startTimestamp: u64,
        #[allow(missing_docs)]
        pub endTimestamp: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SetExpressLaneController {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "SetExpressLaneController(uint64,address,address,address,uint64,uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                181u8,
                154u8,
                220u8,
                130u8,
                12u8,
                166u8,
                66u8,
                218u8,
                212u8,
                147u8,
                160u8,
                166u8,
                224u8,
                189u8,
                249u8,
                121u8,
                220u8,
                174u8,
                3u8,
                125u8,
                234u8,
                17u8,
                75u8,
                112u8,
                213u8,
                198u8,
                107u8,
                28u8,
                11u8,
                121u8,
                28u8,
                75u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    round: data.0,
                    previousExpressLaneController: topics.1,
                    newExpressLaneController: topics.2,
                    transferor: topics.3,
                    startTimestamp: data.1,
                    endTimestamp: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.round),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.startTimestamp),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.endTimestamp),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousExpressLaneController.clone(),
                    self.newExpressLaneController.clone(),
                    self.transferor.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.previousExpressLaneController,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newExpressLaneController,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.transferor,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SetExpressLaneController {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SetExpressLaneController> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &SetExpressLaneController,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `SetMinReservePrice(uint256,uint256)` and selector `0x5848068f11aa3ba9fe3fc33c5f9f2a3cd1aed67986b85b5e0cedc67dbe96f0f0`.
```solidity
event SetMinReservePrice(uint256 oldPrice, uint256 newPrice);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SetMinReservePrice {
        #[allow(missing_docs)]
        pub oldPrice: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub newPrice: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SetMinReservePrice {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "SetMinReservePrice(uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                88u8,
                72u8,
                6u8,
                143u8,
                17u8,
                170u8,
                59u8,
                169u8,
                254u8,
                63u8,
                195u8,
                60u8,
                95u8,
                159u8,
                42u8,
                60u8,
                209u8,
                174u8,
                214u8,
                121u8,
                134u8,
                184u8,
                91u8,
                94u8,
                12u8,
                237u8,
                198u8,
                125u8,
                190u8,
                150u8,
                240u8,
                240u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldPrice: data.0,
                    newPrice: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.oldPrice),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newPrice),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SetMinReservePrice {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SetMinReservePrice> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &SetMinReservePrice) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `SetReservePrice(uint256,uint256)` and selector `0x9725e37e079c5bda6009a8f54d86265849f30acf61c630f9e1ac91e67de98794`.
```solidity
event SetReservePrice(uint256 oldReservePrice, uint256 newReservePrice);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SetReservePrice {
        #[allow(missing_docs)]
        pub oldReservePrice: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub newReservePrice: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SetReservePrice {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "SetReservePrice(uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                151u8,
                37u8,
                227u8,
                126u8,
                7u8,
                156u8,
                91u8,
                218u8,
                96u8,
                9u8,
                168u8,
                245u8,
                77u8,
                134u8,
                38u8,
                88u8,
                73u8,
                243u8,
                10u8,
                207u8,
                97u8,
                198u8,
                48u8,
                249u8,
                225u8,
                172u8,
                145u8,
                230u8,
                125u8,
                233u8,
                135u8,
                148u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldReservePrice: data.0,
                    newReservePrice: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.oldReservePrice),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newReservePrice),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SetReservePrice {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SetReservePrice> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &SetReservePrice) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `SetRoundTimingInfo(uint64,int64,uint64,uint64,uint64)` and selector `0x982cfb73783b8c64455c76cdeb1351467c4f1e6b3615fec07df232c1b46ffd47`.
```solidity
event SetRoundTimingInfo(uint64 currentRound, int64 offsetTimestamp, uint64 roundDurationSeconds, uint64 auctionClosingSeconds, uint64 reserveSubmissionSeconds);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SetRoundTimingInfo {
        #[allow(missing_docs)]
        pub currentRound: u64,
        #[allow(missing_docs)]
        pub offsetTimestamp: i64,
        #[allow(missing_docs)]
        pub roundDurationSeconds: u64,
        #[allow(missing_docs)]
        pub auctionClosingSeconds: u64,
        #[allow(missing_docs)]
        pub reserveSubmissionSeconds: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SetRoundTimingInfo {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Int<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "SetRoundTimingInfo(uint64,int64,uint64,uint64,uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                152u8,
                44u8,
                251u8,
                115u8,
                120u8,
                59u8,
                140u8,
                100u8,
                69u8,
                92u8,
                118u8,
                205u8,
                235u8,
                19u8,
                81u8,
                70u8,
                124u8,
                79u8,
                30u8,
                107u8,
                54u8,
                21u8,
                254u8,
                192u8,
                125u8,
                242u8,
                50u8,
                193u8,
                180u8,
                111u8,
                253u8,
                71u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    currentRound: data.0,
                    offsetTimestamp: data.1,
                    roundDurationSeconds: data.2,
                    auctionClosingSeconds: data.3,
                    reserveSubmissionSeconds: data.4,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.currentRound),
                    <alloy::sol_types::sol_data::Int<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.offsetTimestamp),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.roundDurationSeconds),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.auctionClosingSeconds,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.reserveSubmissionSeconds,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SetRoundTimingInfo {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SetRoundTimingInfo> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &SetRoundTimingInfo) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `SetTransferor(address,address,uint64)` and selector `0xf6d28df235d9fa45a42d45dbb7c4f4ac76edb51e528f09f25a0650d32b8b33c0`.
```solidity
event SetTransferor(address indexed expressLaneController, address indexed transferor, uint64 fixedUntilRound);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SetTransferor {
        #[allow(missing_docs)]
        pub expressLaneController: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub transferor: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub fixedUntilRound: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SetTransferor {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "SetTransferor(address,address,uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                246u8,
                210u8,
                141u8,
                242u8,
                53u8,
                217u8,
                250u8,
                69u8,
                164u8,
                45u8,
                69u8,
                219u8,
                183u8,
                196u8,
                244u8,
                172u8,
                118u8,
                237u8,
                181u8,
                30u8,
                82u8,
                143u8,
                9u8,
                242u8,
                90u8,
                6u8,
                80u8,
                211u8,
                43u8,
                139u8,
                51u8,
                192u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    expressLaneController: topics.1,
                    transferor: topics.2,
                    fixedUntilRound: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.fixedUntilRound),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.expressLaneController.clone(),
                    self.transferor.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.expressLaneController,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.transferor,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SetTransferor {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SetTransferor> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &SetTransferor) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `WithdrawalFinalized(address,uint256)` and selector `0x9e5c4f9f4e46b8629d3dda85f43a69194f50254404a72dc62b9e932d9c94eda8`.
```solidity
event WithdrawalFinalized(address indexed account, uint256 withdrawalAmount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct WithdrawalFinalized {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub withdrawalAmount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for WithdrawalFinalized {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "WithdrawalFinalized(address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                158u8,
                92u8,
                79u8,
                159u8,
                78u8,
                70u8,
                184u8,
                98u8,
                157u8,
                61u8,
                218u8,
                133u8,
                244u8,
                58u8,
                105u8,
                25u8,
                79u8,
                80u8,
                37u8,
                68u8,
                4u8,
                167u8,
                45u8,
                198u8,
                43u8,
                158u8,
                147u8,
                45u8,
                156u8,
                148u8,
                237u8,
                168u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    account: topics.1,
                    withdrawalAmount: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.withdrawalAmount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.account.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for WithdrawalFinalized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&WithdrawalFinalized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &WithdrawalFinalized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `WithdrawalInitiated(address,uint256,uint256)` and selector `0x31f69201fab7912e3ec9850e3ab705964bf46d9d4276bdcbb6d05e965e5f5401`.
```solidity
event WithdrawalInitiated(address indexed account, uint256 withdrawalAmount, uint256 roundWithdrawable);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct WithdrawalInitiated {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub withdrawalAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub roundWithdrawable: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for WithdrawalInitiated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "WithdrawalInitiated(address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                49u8,
                246u8,
                146u8,
                1u8,
                250u8,
                183u8,
                145u8,
                46u8,
                62u8,
                201u8,
                133u8,
                14u8,
                58u8,
                183u8,
                5u8,
                150u8,
                75u8,
                244u8,
                109u8,
                157u8,
                66u8,
                118u8,
                189u8,
                203u8,
                182u8,
                208u8,
                94u8,
                150u8,
                94u8,
                95u8,
                84u8,
                1u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    account: topics.1,
                    withdrawalAmount: data.0,
                    roundWithdrawable: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.withdrawalAmount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.roundWithdrawable),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.account.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for WithdrawalInitiated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&WithdrawalInitiated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &WithdrawalInitiated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Function with signature `AUCTIONEER_ADMIN_ROLE()` and selector `0x14d96316`.
```solidity
function AUCTIONEER_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AUCTIONEER_ADMIN_ROLECall {}
    ///Container type for the return parameters of the [`AUCTIONEER_ADMIN_ROLE()`](AUCTIONEER_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AUCTIONEER_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<AUCTIONEER_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: AUCTIONEER_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for AUCTIONEER_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<AUCTIONEER_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: AUCTIONEER_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for AUCTIONEER_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for AUCTIONEER_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = AUCTIONEER_ADMIN_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AUCTIONEER_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [20u8, 217u8, 99u8, 22u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `AUCTIONEER_ROLE()` and selector `0xcfe9232b`.
```solidity
function AUCTIONEER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AUCTIONEER_ROLECall {}
    ///Container type for the return parameters of the [`AUCTIONEER_ROLE()`](AUCTIONEER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AUCTIONEER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<AUCTIONEER_ROLECall> for UnderlyingRustTuple<'_> {
                fn from(value: AUCTIONEER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for AUCTIONEER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<AUCTIONEER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: AUCTIONEER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for AUCTIONEER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for AUCTIONEER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = AUCTIONEER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AUCTIONEER_ROLE()";
            const SELECTOR: [u8; 4] = [207u8, 233u8, 35u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `BENEFICIARY_SETTER_ROLE()` and selector `0x336a5b5e`.
```solidity
function BENEFICIARY_SETTER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BENEFICIARY_SETTER_ROLECall {}
    ///Container type for the return parameters of the [`BENEFICIARY_SETTER_ROLE()`](BENEFICIARY_SETTER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BENEFICIARY_SETTER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BENEFICIARY_SETTER_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: BENEFICIARY_SETTER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BENEFICIARY_SETTER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BENEFICIARY_SETTER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: BENEFICIARY_SETTER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BENEFICIARY_SETTER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for BENEFICIARY_SETTER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = BENEFICIARY_SETTER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BENEFICIARY_SETTER_ROLE()";
            const SELECTOR: [u8; 4] = [51u8, 106u8, 91u8, 94u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `DEFAULT_ADMIN_ROLE()` and selector `0xa217fddf`.
```solidity
function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLECall {}
    ///Container type for the return parameters of the [`DEFAULT_ADMIN_ROLE()`](DEFAULT_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEFAULT_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DEFAULT_ADMIN_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEFAULT_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [162u8, 23u8, 253u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `MIN_RESERVE_SETTER_ROLE()` and selector `0x8948cc4e`.
```solidity
function MIN_RESERVE_SETTER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MIN_RESERVE_SETTER_ROLECall {}
    ///Container type for the return parameters of the [`MIN_RESERVE_SETTER_ROLE()`](MIN_RESERVE_SETTER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MIN_RESERVE_SETTER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MIN_RESERVE_SETTER_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: MIN_RESERVE_SETTER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MIN_RESERVE_SETTER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MIN_RESERVE_SETTER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: MIN_RESERVE_SETTER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MIN_RESERVE_SETTER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for MIN_RESERVE_SETTER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = MIN_RESERVE_SETTER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MIN_RESERVE_SETTER_ROLE()";
            const SELECTOR: [u8; 4] = [137u8, 72u8, 204u8, 78u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `RESERVE_SETTER_ADMIN_ROLE()` and selector `0xe3f7bb55`.
```solidity
function RESERVE_SETTER_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RESERVE_SETTER_ADMIN_ROLECall {}
    ///Container type for the return parameters of the [`RESERVE_SETTER_ADMIN_ROLE()`](RESERVE_SETTER_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RESERVE_SETTER_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<RESERVE_SETTER_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: RESERVE_SETTER_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for RESERVE_SETTER_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<RESERVE_SETTER_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: RESERVE_SETTER_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for RESERVE_SETTER_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for RESERVE_SETTER_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = RESERVE_SETTER_ADMIN_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "RESERVE_SETTER_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [227u8, 247u8, 187u8, 85u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `RESERVE_SETTER_ROLE()` and selector `0xb3ee252f`.
```solidity
function RESERVE_SETTER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RESERVE_SETTER_ROLECall {}
    ///Container type for the return parameters of the [`RESERVE_SETTER_ROLE()`](RESERVE_SETTER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RESERVE_SETTER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<RESERVE_SETTER_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: RESERVE_SETTER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for RESERVE_SETTER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<RESERVE_SETTER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: RESERVE_SETTER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for RESERVE_SETTER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for RESERVE_SETTER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = RESERVE_SETTER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "RESERVE_SETTER_ROLE()";
            const SELECTOR: [u8; 4] = [179u8, 238u8, 37u8, 47u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `ROUND_TIMING_SETTER_ROLE()` and selector `0x1682e50b`.
```solidity
function ROUND_TIMING_SETTER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ROUND_TIMING_SETTER_ROLECall {}
    ///Container type for the return parameters of the [`ROUND_TIMING_SETTER_ROLE()`](ROUND_TIMING_SETTER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ROUND_TIMING_SETTER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ROUND_TIMING_SETTER_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: ROUND_TIMING_SETTER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ROUND_TIMING_SETTER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ROUND_TIMING_SETTER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: ROUND_TIMING_SETTER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ROUND_TIMING_SETTER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ROUND_TIMING_SETTER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ROUND_TIMING_SETTER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ROUND_TIMING_SETTER_ROLE()";
            const SELECTOR: [u8; 4] = [22u8, 130u8, 229u8, 11u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `balanceOf(address)` and selector `0x70a08231`.
```solidity
function balanceOf(address account) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`balanceOf(address)`](balanceOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfCall> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfReturn> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for balanceOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = balanceOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "balanceOf(address)";
            const SELECTOR: [u8; 4] = [112u8, 160u8, 130u8, 49u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `balanceOfAtRound(address,uint64)` and selector `0x5633c337`.
```solidity
function balanceOfAtRound(address account, uint64 round) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfAtRoundCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub round: u64,
    }
    ///Container type for the return parameters of the [`balanceOfAtRound(address,uint64)`](balanceOfAtRoundCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfAtRoundReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, u64);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfAtRoundCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfAtRoundCall) -> Self {
                    (value.account, value.round)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for balanceOfAtRoundCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        account: tuple.0,
                        round: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfAtRoundReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfAtRoundReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for balanceOfAtRoundReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for balanceOfAtRoundCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = balanceOfAtRoundReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "balanceOfAtRound(address,uint64)";
            const SELECTOR: [u8; 4] = [86u8, 51u8, 195u8, 55u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.round),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `beneficiary()` and selector `0x38af3eed`.
```solidity
function beneficiary() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct beneficiaryCall {}
    ///Container type for the return parameters of the [`beneficiary()`](beneficiaryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct beneficiaryReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<beneficiaryCall> for UnderlyingRustTuple<'_> {
                fn from(value: beneficiaryCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for beneficiaryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<beneficiaryReturn> for UnderlyingRustTuple<'_> {
                fn from(value: beneficiaryReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for beneficiaryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for beneficiaryCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = beneficiaryReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "beneficiary()";
            const SELECTOR: [u8; 4] = [56u8, 175u8, 62u8, 237u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `beneficiaryBalance()` and selector `0xe2fc6f68`.
```solidity
function beneficiaryBalance() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct beneficiaryBalanceCall {}
    ///Container type for the return parameters of the [`beneficiaryBalance()`](beneficiaryBalanceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct beneficiaryBalanceReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<beneficiaryBalanceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: beneficiaryBalanceCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for beneficiaryBalanceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<beneficiaryBalanceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: beneficiaryBalanceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for beneficiaryBalanceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for beneficiaryBalanceCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = beneficiaryBalanceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "beneficiaryBalance()";
            const SELECTOR: [u8; 4] = [226u8, 252u8, 111u8, 104u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `biddingToken()` and selector `0x639d7566`.
```solidity
function biddingToken() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct biddingTokenCall {}
    ///Container type for the return parameters of the [`biddingToken()`](biddingTokenCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct biddingTokenReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<biddingTokenCall> for UnderlyingRustTuple<'_> {
                fn from(value: biddingTokenCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for biddingTokenCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<biddingTokenReturn> for UnderlyingRustTuple<'_> {
                fn from(value: biddingTokenReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for biddingTokenReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for biddingTokenCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = biddingTokenReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "biddingToken()";
            const SELECTOR: [u8; 4] = [99u8, 157u8, 117u8, 102u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `currentRound()` and selector `0x8a19c8bc`.
```solidity
function currentRound() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct currentRoundCall {}
    ///Container type for the return parameters of the [`currentRound()`](currentRoundCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct currentRoundReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<currentRoundCall> for UnderlyingRustTuple<'_> {
                fn from(value: currentRoundCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for currentRoundCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<currentRoundReturn> for UnderlyingRustTuple<'_> {
                fn from(value: currentRoundReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for currentRoundReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for currentRoundCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = currentRoundReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "currentRound()";
            const SELECTOR: [u8; 4] = [138u8, 25u8, 200u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `deposit(uint256)` and selector `0xb6b55f25`.
```solidity
function deposit(uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositCall {
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`deposit(uint256)`](depositCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositCall> for UnderlyingRustTuple<'_> {
                fn from(value: depositCall) -> Self {
                    (value.amount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for depositCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { amount: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositReturn> for UnderlyingRustTuple<'_> {
                fn from(value: depositReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for depositReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for depositCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = depositReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "deposit(uint256)";
            const SELECTOR: [u8; 4] = [182u8, 181u8, 95u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `domainSeparator()` and selector `0xf698da25`.
```solidity
function domainSeparator() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct domainSeparatorCall {}
    ///Container type for the return parameters of the [`domainSeparator()`](domainSeparatorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct domainSeparatorReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<domainSeparatorCall> for UnderlyingRustTuple<'_> {
                fn from(value: domainSeparatorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for domainSeparatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<domainSeparatorReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: domainSeparatorReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for domainSeparatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for domainSeparatorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = domainSeparatorReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "domainSeparator()";
            const SELECTOR: [u8; 4] = [246u8, 152u8, 218u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `finalizeWithdrawal()` and selector `0xc5b6aa2f`.
```solidity
function finalizeWithdrawal() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeWithdrawalCall {}
    ///Container type for the return parameters of the [`finalizeWithdrawal()`](finalizeWithdrawalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct finalizeWithdrawalReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeWithdrawalCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizeWithdrawalCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizeWithdrawalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<finalizeWithdrawalReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: finalizeWithdrawalReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for finalizeWithdrawalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for finalizeWithdrawalCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = finalizeWithdrawalReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "finalizeWithdrawal()";
            const SELECTOR: [u8; 4] = [197u8, 182u8, 170u8, 47u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `flushBeneficiaryBalance()` and selector `0x6ad72517`.
```solidity
function flushBeneficiaryBalance() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct flushBeneficiaryBalanceCall {}
    ///Container type for the return parameters of the [`flushBeneficiaryBalance()`](flushBeneficiaryBalanceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct flushBeneficiaryBalanceReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<flushBeneficiaryBalanceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: flushBeneficiaryBalanceCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for flushBeneficiaryBalanceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<flushBeneficiaryBalanceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: flushBeneficiaryBalanceReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for flushBeneficiaryBalanceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for flushBeneficiaryBalanceCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = flushBeneficiaryBalanceReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "flushBeneficiaryBalance()";
            const SELECTOR: [u8; 4] = [106u8, 215u8, 37u8, 23u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBidHash(uint64,address,uint256)` and selector `0x04c584ad`.
```solidity
function getBidHash(uint64 round, address expressLaneController, uint256 amount) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBidHashCall {
        #[allow(missing_docs)]
        pub round: u64,
        #[allow(missing_docs)]
        pub expressLaneController: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getBidHash(uint64,address,uint256)`](getBidHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBidHashReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u64,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBidHashCall> for UnderlyingRustTuple<'_> {
                fn from(value: getBidHashCall) -> Self {
                    (value.round, value.expressLaneController, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBidHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        round: tuple.0,
                        expressLaneController: tuple.1,
                        amount: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBidHashReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getBidHashReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBidHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBidHashCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBidHashReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBidHash(uint64,address,uint256)";
            const SELECTOR: [u8; 4] = [4u8, 197u8, 132u8, 173u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.round),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.expressLaneController,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRoleAdmin(bytes32)` and selector `0x248a9ca3`.
```solidity
function getRoleAdmin(bytes32 role) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getRoleAdmin(bytes32)`](getRoleAdminCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleAdminCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRoleAdminReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleAdmin(bytes32)";
            const SELECTOR: [u8; 4] = [36u8, 138u8, 156u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRoleMember(bytes32,uint256)` and selector `0x9010d07c`.
```solidity
function getRoleMember(bytes32 role, uint256 index) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMemberCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getRoleMember(bytes32,uint256)`](getRoleMemberCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMemberReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMemberCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMemberCall) -> Self {
                    (value.role, value.index)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleMemberCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        index: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMemberReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMemberReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleMemberReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleMemberCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRoleMemberReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleMember(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [144u8, 16u8, 208u8, 124u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRoleMemberCount(bytes32)` and selector `0xca15c873`.
```solidity
function getRoleMemberCount(bytes32 role) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMemberCountCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getRoleMemberCount(bytes32)`](getRoleMemberCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleMemberCountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMemberCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMemberCountCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRoleMemberCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleMemberCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRoleMemberCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRoleMemberCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleMemberCountCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRoleMemberCountReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleMemberCount(bytes32)";
            const SELECTOR: [u8; 4] = [202u8, 21u8, 200u8, 115u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `grantRole(bytes32,address)` and selector `0x2f2ff15d`.
```solidity
function grantRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`grantRole(bytes32,address)`](grantRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for grantRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = grantRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "grantRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [47u8, 47u8, 241u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `hasRole(bytes32,address)` and selector `0x91d14854`.
```solidity
function hasRole(bytes32 role, address account) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`hasRole(bytes32,address)`](hasRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = hasRoleReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [145u8, 209u8, 72u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `initialize((address,address,address,(int64,uint64,uint64,uint64),uint256,address,address,address,address,address,address,address))` and selector `0x9a1fadd3`.
```solidity
function initialize(InitArgs memory args) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeCall {
        #[allow(missing_docs)]
        pub args: <InitArgs as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`initialize((address,address,address,(int64,uint64,uint64,uint64),uint256,address,address,address,address,address,address,address))`](initializeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (InitArgs,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <InitArgs as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeCall> for UnderlyingRustTuple<'_> {
                fn from(value: initializeCall) -> Self {
                    (value.args,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { args: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: initializeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeCall {
            type Parameters<'a> = (InitArgs,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initialize((address,address,address,(int64,uint64,uint64,uint64),uint256,address,address,address,address,address,address,address))";
            const SELECTOR: [u8; 4] = [154u8, 31u8, 173u8, 211u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<InitArgs as alloy_sol_types::SolType>::tokenize(&self.args),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `initiateWithdrawal()` and selector `0xb51d1d4f`.
```solidity
function initiateWithdrawal() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initiateWithdrawalCall {}
    ///Container type for the return parameters of the [`initiateWithdrawal()`](initiateWithdrawalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initiateWithdrawalReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initiateWithdrawalCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: initiateWithdrawalCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initiateWithdrawalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initiateWithdrawalReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: initiateWithdrawalReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for initiateWithdrawalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initiateWithdrawalCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initiateWithdrawalReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initiateWithdrawal()";
            const SELECTOR: [u8; 4] = [181u8, 29u8, 29u8, 79u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isAuctionRoundClosed()` and selector `0x2d668ce7`.
```solidity
function isAuctionRoundClosed() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isAuctionRoundClosedCall {}
    ///Container type for the return parameters of the [`isAuctionRoundClosed()`](isAuctionRoundClosedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isAuctionRoundClosedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isAuctionRoundClosedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isAuctionRoundClosedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isAuctionRoundClosedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isAuctionRoundClosedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isAuctionRoundClosedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isAuctionRoundClosedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isAuctionRoundClosedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isAuctionRoundClosedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isAuctionRoundClosed()";
            const SELECTOR: [u8; 4] = [45u8, 102u8, 140u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isReserveBlackout()` and selector `0xe460d2c5`.
```solidity
function isReserveBlackout() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isReserveBlackoutCall {}
    ///Container type for the return parameters of the [`isReserveBlackout()`](isReserveBlackoutCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isReserveBlackoutReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isReserveBlackoutCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isReserveBlackoutCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isReserveBlackoutCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isReserveBlackoutReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isReserveBlackoutReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isReserveBlackoutReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isReserveBlackoutCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isReserveBlackoutReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isReserveBlackout()";
            const SELECTOR: [u8; 4] = [228u8, 96u8, 210u8, 197u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `minReservePrice()` and selector `0x83af0a1f`.
```solidity
function minReservePrice() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct minReservePriceCall {}
    ///Container type for the return parameters of the [`minReservePrice()`](minReservePriceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct minReservePriceReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<minReservePriceCall> for UnderlyingRustTuple<'_> {
                fn from(value: minReservePriceCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for minReservePriceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<minReservePriceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: minReservePriceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for minReservePriceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for minReservePriceCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = minReservePriceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "minReservePrice()";
            const SELECTOR: [u8; 4] = [131u8, 175u8, 10u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `renounceRole(bytes32,address)` and selector `0x36568abe`.
```solidity
function renounceRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`renounceRole(bytes32,address)`](renounceRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [54u8, 86u8, 138u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `reservePrice()` and selector `0xdb2e1eed`.
```solidity
function reservePrice() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct reservePriceCall {}
    ///Container type for the return parameters of the [`reservePrice()`](reservePriceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct reservePriceReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<reservePriceCall> for UnderlyingRustTuple<'_> {
                fn from(value: reservePriceCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for reservePriceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<reservePriceReturn> for UnderlyingRustTuple<'_> {
                fn from(value: reservePriceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for reservePriceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for reservePriceCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = reservePriceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "reservePrice()";
            const SELECTOR: [u8; 4] = [219u8, 46u8, 30u8, 237u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `resolveMultiBidAuction((address,uint256,bytes),(address,uint256,bytes))` and selector `0x447a709e`.
```solidity
function resolveMultiBidAuction(Bid memory firstPriceBid, Bid memory secondPriceBid) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resolveMultiBidAuctionCall {
        #[allow(missing_docs)]
        pub firstPriceBid: <Bid as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub secondPriceBid: <Bid as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`resolveMultiBidAuction((address,uint256,bytes),(address,uint256,bytes))`](resolveMultiBidAuctionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resolveMultiBidAuctionReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Bid, Bid);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Bid as alloy::sol_types::SolType>::RustType,
                <Bid as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resolveMultiBidAuctionCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: resolveMultiBidAuctionCall) -> Self {
                    (value.firstPriceBid, value.secondPriceBid)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for resolveMultiBidAuctionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        firstPriceBid: tuple.0,
                        secondPriceBid: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resolveMultiBidAuctionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: resolveMultiBidAuctionReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for resolveMultiBidAuctionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for resolveMultiBidAuctionCall {
            type Parameters<'a> = (Bid, Bid);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = resolveMultiBidAuctionReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "resolveMultiBidAuction((address,uint256,bytes),(address,uint256,bytes))";
            const SELECTOR: [u8; 4] = [68u8, 122u8, 112u8, 158u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <Bid as alloy_sol_types::SolType>::tokenize(&self.firstPriceBid),
                    <Bid as alloy_sol_types::SolType>::tokenize(&self.secondPriceBid),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `resolveSingleBidAuction((address,uint256,bytes))` and selector `0x6dc4fc4e`.
```solidity
function resolveSingleBidAuction(Bid memory firstPriceBid) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resolveSingleBidAuctionCall {
        #[allow(missing_docs)]
        pub firstPriceBid: <Bid as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`resolveSingleBidAuction((address,uint256,bytes))`](resolveSingleBidAuctionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resolveSingleBidAuctionReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Bid,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Bid as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resolveSingleBidAuctionCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: resolveSingleBidAuctionCall) -> Self {
                    (value.firstPriceBid,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for resolveSingleBidAuctionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { firstPriceBid: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resolveSingleBidAuctionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: resolveSingleBidAuctionReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for resolveSingleBidAuctionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for resolveSingleBidAuctionCall {
            type Parameters<'a> = (Bid,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = resolveSingleBidAuctionReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "resolveSingleBidAuction((address,uint256,bytes))";
            const SELECTOR: [u8; 4] = [109u8, 196u8, 252u8, 78u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<Bid as alloy_sol_types::SolType>::tokenize(&self.firstPriceBid),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `resolvedRounds()` and selector `0x0d253fbe`.
```solidity
function resolvedRounds() external view returns (ELCRound memory, ELCRound memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resolvedRoundsCall {}
    ///Container type for the return parameters of the [`resolvedRounds()`](resolvedRoundsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resolvedRoundsReturn {
        #[allow(missing_docs)]
        pub _0: <ELCRound as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub _1: <ELCRound as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resolvedRoundsCall> for UnderlyingRustTuple<'_> {
                fn from(value: resolvedRoundsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for resolvedRoundsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ELCRound, ELCRound);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <ELCRound as alloy::sol_types::SolType>::RustType,
                <ELCRound as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resolvedRoundsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: resolvedRoundsReturn) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for resolvedRoundsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for resolvedRoundsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = resolvedRoundsReturn;
            type ReturnTuple<'a> = (ELCRound, ELCRound);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "resolvedRounds()";
            const SELECTOR: [u8; 4] = [13u8, 37u8, 63u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `revokeRole(bytes32,address)` and selector `0xd547741f`.
```solidity
function revokeRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeRole(bytes32,address)`](revokeRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [213u8, 71u8, 116u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `roundTimestamps(uint64)` and selector `0x7b617f94`.
```solidity
function roundTimestamps(uint64 round) external view returns (uint64, uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct roundTimestampsCall {
        #[allow(missing_docs)]
        pub round: u64,
    }
    ///Container type for the return parameters of the [`roundTimestamps(uint64)`](roundTimestampsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct roundTimestampsReturn {
        #[allow(missing_docs)]
        pub _0: u64,
        #[allow(missing_docs)]
        pub _1: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<roundTimestampsCall> for UnderlyingRustTuple<'_> {
                fn from(value: roundTimestampsCall) -> Self {
                    (value.round,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for roundTimestampsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { round: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, u64);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<roundTimestampsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: roundTimestampsReturn) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for roundTimestampsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for roundTimestampsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = roundTimestampsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "roundTimestamps(uint64)";
            const SELECTOR: [u8; 4] = [123u8, 97u8, 127u8, 148u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.round),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `roundTimingInfo()` and selector `0x0152682d`.
```solidity
function roundTimingInfo() external view returns (int64 offsetTimestamp, uint64 roundDurationSeconds, uint64 auctionClosingSeconds, uint64 reserveSubmissionSeconds);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct roundTimingInfoCall {}
    ///Container type for the return parameters of the [`roundTimingInfo()`](roundTimingInfoCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct roundTimingInfoReturn {
        #[allow(missing_docs)]
        pub offsetTimestamp: i64,
        #[allow(missing_docs)]
        pub roundDurationSeconds: u64,
        #[allow(missing_docs)]
        pub auctionClosingSeconds: u64,
        #[allow(missing_docs)]
        pub reserveSubmissionSeconds: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<roundTimingInfoCall> for UnderlyingRustTuple<'_> {
                fn from(value: roundTimingInfoCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for roundTimingInfoCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Int<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (i64, u64, u64, u64);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<roundTimingInfoReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: roundTimingInfoReturn) -> Self {
                    (
                        value.offsetTimestamp,
                        value.roundDurationSeconds,
                        value.auctionClosingSeconds,
                        value.reserveSubmissionSeconds,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for roundTimingInfoReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        offsetTimestamp: tuple.0,
                        roundDurationSeconds: tuple.1,
                        auctionClosingSeconds: tuple.2,
                        reserveSubmissionSeconds: tuple.3,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for roundTimingInfoCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = roundTimingInfoReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Int<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "roundTimingInfo()";
            const SELECTOR: [u8; 4] = [1u8, 82u8, 104u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setBeneficiary(address)` and selector `0x1c31f710`.
```solidity
function setBeneficiary(address newBeneficiary) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBeneficiaryCall {
        #[allow(missing_docs)]
        pub newBeneficiary: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setBeneficiary(address)`](setBeneficiaryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBeneficiaryReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBeneficiaryCall> for UnderlyingRustTuple<'_> {
                fn from(value: setBeneficiaryCall) -> Self {
                    (value.newBeneficiary,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBeneficiaryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newBeneficiary: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBeneficiaryReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setBeneficiaryReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setBeneficiaryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBeneficiaryCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBeneficiaryReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBeneficiary(address)";
            const SELECTOR: [u8; 4] = [28u8, 49u8, 247u8, 16u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newBeneficiary,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setMinReservePrice(uint256)` and selector `0xe4d20c1d`.
```solidity
function setMinReservePrice(uint256 newMinReservePrice) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setMinReservePriceCall {
        #[allow(missing_docs)]
        pub newMinReservePrice: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setMinReservePrice(uint256)`](setMinReservePriceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setMinReservePriceReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setMinReservePriceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setMinReservePriceCall) -> Self {
                    (value.newMinReservePrice,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setMinReservePriceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newMinReservePrice: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setMinReservePriceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setMinReservePriceReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setMinReservePriceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setMinReservePriceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setMinReservePriceReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setMinReservePrice(uint256)";
            const SELECTOR: [u8; 4] = [228u8, 210u8, 12u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newMinReservePrice),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setReservePrice(uint256)` and selector `0xce9c7c0d`.
```solidity
function setReservePrice(uint256 newReservePrice) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setReservePriceCall {
        #[allow(missing_docs)]
        pub newReservePrice: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setReservePrice(uint256)`](setReservePriceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setReservePriceReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setReservePriceCall> for UnderlyingRustTuple<'_> {
                fn from(value: setReservePriceCall) -> Self {
                    (value.newReservePrice,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setReservePriceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newReservePrice: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setReservePriceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setReservePriceReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setReservePriceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setReservePriceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setReservePriceReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setReservePrice(uint256)";
            const SELECTOR: [u8; 4] = [206u8, 156u8, 124u8, 13u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newReservePrice),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setRoundTimingInfo((int64,uint64,uint64,uint64))` and selector `0xfed87be8`.
```solidity
function setRoundTimingInfo(RoundTimingInfo memory newRoundTimingInfo) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setRoundTimingInfoCall {
        #[allow(missing_docs)]
        pub newRoundTimingInfo: <RoundTimingInfo as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`setRoundTimingInfo((int64,uint64,uint64,uint64))`](setRoundTimingInfoCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setRoundTimingInfoReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (RoundTimingInfo,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <RoundTimingInfo as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setRoundTimingInfoCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setRoundTimingInfoCall) -> Self {
                    (value.newRoundTimingInfo,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setRoundTimingInfoCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newRoundTimingInfo: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setRoundTimingInfoReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setRoundTimingInfoReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setRoundTimingInfoReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setRoundTimingInfoCall {
            type Parameters<'a> = (RoundTimingInfo,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setRoundTimingInfoReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setRoundTimingInfo((int64,uint64,uint64,uint64))";
            const SELECTOR: [u8; 4] = [254u8, 216u8, 123u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <RoundTimingInfo as alloy_sol_types::SolType>::tokenize(
                        &self.newRoundTimingInfo,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setTransferor((address,uint64))` and selector `0xbef0ec74`.
```solidity
function setTransferor(Transferor memory transferor) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setTransferorCall {
        #[allow(missing_docs)]
        pub transferor: <Transferor as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`setTransferor((address,uint64))`](setTransferorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setTransferorReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Transferor,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Transferor as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setTransferorCall> for UnderlyingRustTuple<'_> {
                fn from(value: setTransferorCall) -> Self {
                    (value.transferor,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setTransferorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { transferor: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setTransferorReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setTransferorReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setTransferorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setTransferorCall {
            type Parameters<'a> = (Transferor,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setTransferorReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setTransferor((address,uint64))";
            const SELECTOR: [u8; 4] = [190u8, 240u8, 236u8, 116u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<Transferor as alloy_sol_types::SolType>::tokenize(&self.transferor),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
```solidity
function supportsInterface(bytes4 interfaceId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceCall {
        #[allow(missing_docs)]
        pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
    }
    ///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceCall) -> Self {
                    (value.interfaceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { interfaceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportsInterfaceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = supportsInterfaceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportsInterface(bytes4)";
            const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.interfaceId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transferExpressLaneController(uint64,address)` and selector `0x007be2fe`.
```solidity
function transferExpressLaneController(uint64 round, address newExpressLaneController) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferExpressLaneControllerCall {
        #[allow(missing_docs)]
        pub round: u64,
        #[allow(missing_docs)]
        pub newExpressLaneController: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferExpressLaneController(uint64,address)`](transferExpressLaneControllerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferExpressLaneControllerReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::Address);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferExpressLaneControllerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferExpressLaneControllerCall) -> Self {
                    (value.round, value.newExpressLaneController)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferExpressLaneControllerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        round: tuple.0,
                        newExpressLaneController: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferExpressLaneControllerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferExpressLaneControllerReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferExpressLaneControllerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferExpressLaneControllerCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferExpressLaneControllerReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferExpressLaneController(uint64,address)";
            const SELECTOR: [u8; 4] = [0u8, 123u8, 226u8, 254u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.round),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newExpressLaneController,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transferorOf(address)` and selector `0x6a514beb`.
```solidity
function transferorOf(address) external view returns (address addr, uint64 fixedUntilRound);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferorOfCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferorOf(address)`](transferorOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferorOfReturn {
        #[allow(missing_docs)]
        pub addr: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub fixedUntilRound: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferorOfCall> for UnderlyingRustTuple<'_> {
                fn from(value: transferorOfCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferorOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, u64);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferorOfReturn> for UnderlyingRustTuple<'_> {
                fn from(value: transferorOfReturn) -> Self {
                    (value.addr, value.fixedUntilRound)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferorOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        addr: tuple.0,
                        fixedUntilRound: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferorOfCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferorOfReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferorOf(address)";
            const SELECTOR: [u8; 4] = [106u8, 81u8, 75u8, 235u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `withdrawableBalance(address)` and selector `0x02b62938`.
```solidity
function withdrawableBalance(address account) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawableBalanceCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`withdrawableBalance(address)`](withdrawableBalanceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawableBalanceReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawableBalanceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: withdrawableBalanceCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for withdrawableBalanceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawableBalanceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: withdrawableBalanceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for withdrawableBalanceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for withdrawableBalanceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = withdrawableBalanceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "withdrawableBalance(address)";
            const SELECTOR: [u8; 4] = [2u8, 182u8, 41u8, 56u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `withdrawableBalanceAtRound(address,uint64)` and selector `0x6e8cace5`.
```solidity
function withdrawableBalanceAtRound(address account, uint64 round) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawableBalanceAtRoundCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub round: u64,
    }
    ///Container type for the return parameters of the [`withdrawableBalanceAtRound(address,uint64)`](withdrawableBalanceAtRoundCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawableBalanceAtRoundReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, u64);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawableBalanceAtRoundCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: withdrawableBalanceAtRoundCall) -> Self {
                    (value.account, value.round)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for withdrawableBalanceAtRoundCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        account: tuple.0,
                        round: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawableBalanceAtRoundReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: withdrawableBalanceAtRoundReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for withdrawableBalanceAtRoundReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for withdrawableBalanceAtRoundCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = withdrawableBalanceAtRoundReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "withdrawableBalanceAtRound(address,uint64)";
            const SELECTOR: [u8; 4] = [110u8, 140u8, 172u8, 229u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.round),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`ExpressLaneAuction`](self) function calls.
    pub enum ExpressLaneAuctionCalls {
        #[allow(missing_docs)]
        AUCTIONEER_ADMIN_ROLE(AUCTIONEER_ADMIN_ROLECall),
        #[allow(missing_docs)]
        AUCTIONEER_ROLE(AUCTIONEER_ROLECall),
        #[allow(missing_docs)]
        BENEFICIARY_SETTER_ROLE(BENEFICIARY_SETTER_ROLECall),
        #[allow(missing_docs)]
        DEFAULT_ADMIN_ROLE(DEFAULT_ADMIN_ROLECall),
        #[allow(missing_docs)]
        MIN_RESERVE_SETTER_ROLE(MIN_RESERVE_SETTER_ROLECall),
        #[allow(missing_docs)]
        RESERVE_SETTER_ADMIN_ROLE(RESERVE_SETTER_ADMIN_ROLECall),
        #[allow(missing_docs)]
        RESERVE_SETTER_ROLE(RESERVE_SETTER_ROLECall),
        #[allow(missing_docs)]
        ROUND_TIMING_SETTER_ROLE(ROUND_TIMING_SETTER_ROLECall),
        #[allow(missing_docs)]
        balanceOf(balanceOfCall),
        #[allow(missing_docs)]
        balanceOfAtRound(balanceOfAtRoundCall),
        #[allow(missing_docs)]
        beneficiary(beneficiaryCall),
        #[allow(missing_docs)]
        beneficiaryBalance(beneficiaryBalanceCall),
        #[allow(missing_docs)]
        biddingToken(biddingTokenCall),
        #[allow(missing_docs)]
        currentRound(currentRoundCall),
        #[allow(missing_docs)]
        deposit(depositCall),
        #[allow(missing_docs)]
        domainSeparator(domainSeparatorCall),
        #[allow(missing_docs)]
        finalizeWithdrawal(finalizeWithdrawalCall),
        #[allow(missing_docs)]
        flushBeneficiaryBalance(flushBeneficiaryBalanceCall),
        #[allow(missing_docs)]
        getBidHash(getBidHashCall),
        #[allow(missing_docs)]
        getRoleAdmin(getRoleAdminCall),
        #[allow(missing_docs)]
        getRoleMember(getRoleMemberCall),
        #[allow(missing_docs)]
        getRoleMemberCount(getRoleMemberCountCall),
        #[allow(missing_docs)]
        grantRole(grantRoleCall),
        #[allow(missing_docs)]
        hasRole(hasRoleCall),
        #[allow(missing_docs)]
        initialize(initializeCall),
        #[allow(missing_docs)]
        initiateWithdrawal(initiateWithdrawalCall),
        #[allow(missing_docs)]
        isAuctionRoundClosed(isAuctionRoundClosedCall),
        #[allow(missing_docs)]
        isReserveBlackout(isReserveBlackoutCall),
        #[allow(missing_docs)]
        minReservePrice(minReservePriceCall),
        #[allow(missing_docs)]
        renounceRole(renounceRoleCall),
        #[allow(missing_docs)]
        reservePrice(reservePriceCall),
        #[allow(missing_docs)]
        resolveMultiBidAuction(resolveMultiBidAuctionCall),
        #[allow(missing_docs)]
        resolveSingleBidAuction(resolveSingleBidAuctionCall),
        #[allow(missing_docs)]
        resolvedRounds(resolvedRoundsCall),
        #[allow(missing_docs)]
        revokeRole(revokeRoleCall),
        #[allow(missing_docs)]
        roundTimestamps(roundTimestampsCall),
        #[allow(missing_docs)]
        roundTimingInfo(roundTimingInfoCall),
        #[allow(missing_docs)]
        setBeneficiary(setBeneficiaryCall),
        #[allow(missing_docs)]
        setMinReservePrice(setMinReservePriceCall),
        #[allow(missing_docs)]
        setReservePrice(setReservePriceCall),
        #[allow(missing_docs)]
        setRoundTimingInfo(setRoundTimingInfoCall),
        #[allow(missing_docs)]
        setTransferor(setTransferorCall),
        #[allow(missing_docs)]
        supportsInterface(supportsInterfaceCall),
        #[allow(missing_docs)]
        transferExpressLaneController(transferExpressLaneControllerCall),
        #[allow(missing_docs)]
        transferorOf(transferorOfCall),
        #[allow(missing_docs)]
        withdrawableBalance(withdrawableBalanceCall),
        #[allow(missing_docs)]
        withdrawableBalanceAtRound(withdrawableBalanceAtRoundCall),
    }
    #[automatically_derived]
    impl ExpressLaneAuctionCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [0u8, 123u8, 226u8, 254u8],
            [1u8, 82u8, 104u8, 45u8],
            [1u8, 255u8, 201u8, 167u8],
            [2u8, 182u8, 41u8, 56u8],
            [4u8, 197u8, 132u8, 173u8],
            [13u8, 37u8, 63u8, 190u8],
            [20u8, 217u8, 99u8, 22u8],
            [22u8, 130u8, 229u8, 11u8],
            [28u8, 49u8, 247u8, 16u8],
            [36u8, 138u8, 156u8, 163u8],
            [45u8, 102u8, 140u8, 231u8],
            [47u8, 47u8, 241u8, 93u8],
            [51u8, 106u8, 91u8, 94u8],
            [54u8, 86u8, 138u8, 190u8],
            [56u8, 175u8, 62u8, 237u8],
            [68u8, 122u8, 112u8, 158u8],
            [86u8, 51u8, 195u8, 55u8],
            [99u8, 157u8, 117u8, 102u8],
            [106u8, 81u8, 75u8, 235u8],
            [106u8, 215u8, 37u8, 23u8],
            [109u8, 196u8, 252u8, 78u8],
            [110u8, 140u8, 172u8, 229u8],
            [112u8, 160u8, 130u8, 49u8],
            [123u8, 97u8, 127u8, 148u8],
            [131u8, 175u8, 10u8, 31u8],
            [137u8, 72u8, 204u8, 78u8],
            [138u8, 25u8, 200u8, 188u8],
            [144u8, 16u8, 208u8, 124u8],
            [145u8, 209u8, 72u8, 84u8],
            [154u8, 31u8, 173u8, 211u8],
            [162u8, 23u8, 253u8, 223u8],
            [179u8, 238u8, 37u8, 47u8],
            [181u8, 29u8, 29u8, 79u8],
            [182u8, 181u8, 95u8, 37u8],
            [190u8, 240u8, 236u8, 116u8],
            [197u8, 182u8, 170u8, 47u8],
            [202u8, 21u8, 200u8, 115u8],
            [206u8, 156u8, 124u8, 13u8],
            [207u8, 233u8, 35u8, 43u8],
            [213u8, 71u8, 116u8, 31u8],
            [219u8, 46u8, 30u8, 237u8],
            [226u8, 252u8, 111u8, 104u8],
            [227u8, 247u8, 187u8, 85u8],
            [228u8, 96u8, 210u8, 197u8],
            [228u8, 210u8, 12u8, 29u8],
            [246u8, 152u8, 218u8, 37u8],
            [254u8, 216u8, 123u8, 232u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for ExpressLaneAuctionCalls {
        const NAME: &'static str = "ExpressLaneAuctionCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 47usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AUCTIONEER_ADMIN_ROLE(_) => {
                    <AUCTIONEER_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::AUCTIONEER_ROLE(_) => {
                    <AUCTIONEER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::BENEFICIARY_SETTER_ROLE(_) => {
                    <BENEFICIARY_SETTER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DEFAULT_ADMIN_ROLE(_) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::MIN_RESERVE_SETTER_ROLE(_) => {
                    <MIN_RESERVE_SETTER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::RESERVE_SETTER_ADMIN_ROLE(_) => {
                    <RESERVE_SETTER_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::RESERVE_SETTER_ROLE(_) => {
                    <RESERVE_SETTER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::ROUND_TIMING_SETTER_ROLE(_) => {
                    <ROUND_TIMING_SETTER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::balanceOf(_) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::balanceOfAtRound(_) => {
                    <balanceOfAtRoundCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::beneficiary(_) => {
                    <beneficiaryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::beneficiaryBalance(_) => {
                    <beneficiaryBalanceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::biddingToken(_) => {
                    <biddingTokenCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::currentRound(_) => {
                    <currentRoundCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::deposit(_) => <depositCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::domainSeparator(_) => {
                    <domainSeparatorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::finalizeWithdrawal(_) => {
                    <finalizeWithdrawalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::flushBeneficiaryBalance(_) => {
                    <flushBeneficiaryBalanceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBidHash(_) => {
                    <getBidHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleAdmin(_) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleMember(_) => {
                    <getRoleMemberCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleMemberCount(_) => {
                    <getRoleMemberCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::grantRole(_) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasRole(_) => <hasRoleCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::initialize(_) => {
                    <initializeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initiateWithdrawal(_) => {
                    <initiateWithdrawalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isAuctionRoundClosed(_) => {
                    <isAuctionRoundClosedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isReserveBlackout(_) => {
                    <isReserveBlackoutCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::minReservePrice(_) => {
                    <minReservePriceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceRole(_) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::reservePrice(_) => {
                    <reservePriceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::resolveMultiBidAuction(_) => {
                    <resolveMultiBidAuctionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::resolveSingleBidAuction(_) => {
                    <resolveSingleBidAuctionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::resolvedRounds(_) => {
                    <resolvedRoundsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeRole(_) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::roundTimestamps(_) => {
                    <roundTimestampsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::roundTimingInfo(_) => {
                    <roundTimingInfoCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBeneficiary(_) => {
                    <setBeneficiaryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setMinReservePrice(_) => {
                    <setMinReservePriceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setReservePrice(_) => {
                    <setReservePriceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setRoundTimingInfo(_) => {
                    <setRoundTimingInfoCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setTransferor(_) => {
                    <setTransferorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::supportsInterface(_) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferExpressLaneController(_) => {
                    <transferExpressLaneControllerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferorOf(_) => {
                    <transferorOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::withdrawableBalance(_) => {
                    <withdrawableBalanceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::withdrawableBalanceAtRound(_) => {
                    <withdrawableBalanceAtRoundCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls>] = &[
                {
                    fn transferExpressLaneController(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <transferExpressLaneControllerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::transferExpressLaneController)
                    }
                    transferExpressLaneController
                },
                {
                    fn roundTimingInfo(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <roundTimingInfoCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::roundTimingInfo)
                    }
                    roundTimingInfo
                },
                {
                    fn supportsInterface(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn withdrawableBalance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <withdrawableBalanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::withdrawableBalance)
                    }
                    withdrawableBalance
                },
                {
                    fn getBidHash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <getBidHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::getBidHash)
                    }
                    getBidHash
                },
                {
                    fn resolvedRounds(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <resolvedRoundsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::resolvedRounds)
                    }
                    resolvedRounds
                },
                {
                    fn AUCTIONEER_ADMIN_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <AUCTIONEER_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::AUCTIONEER_ADMIN_ROLE)
                    }
                    AUCTIONEER_ADMIN_ROLE
                },
                {
                    fn ROUND_TIMING_SETTER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <ROUND_TIMING_SETTER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::ROUND_TIMING_SETTER_ROLE)
                    }
                    ROUND_TIMING_SETTER_ROLE
                },
                {
                    fn setBeneficiary(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <setBeneficiaryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::setBeneficiary)
                    }
                    setBeneficiary
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn isAuctionRoundClosed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <isAuctionRoundClosedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::isAuctionRoundClosed)
                    }
                    isAuctionRoundClosed
                },
                {
                    fn grantRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn BENEFICIARY_SETTER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <BENEFICIARY_SETTER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::BENEFICIARY_SETTER_ROLE)
                    }
                    BENEFICIARY_SETTER_ROLE
                },
                {
                    fn renounceRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn beneficiary(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <beneficiaryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::beneficiary)
                    }
                    beneficiary
                },
                {
                    fn resolveMultiBidAuction(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <resolveMultiBidAuctionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::resolveMultiBidAuction)
                    }
                    resolveMultiBidAuction
                },
                {
                    fn balanceOfAtRound(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <balanceOfAtRoundCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::balanceOfAtRound)
                    }
                    balanceOfAtRound
                },
                {
                    fn biddingToken(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <biddingTokenCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::biddingToken)
                    }
                    biddingToken
                },
                {
                    fn transferorOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <transferorOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::transferorOf)
                    }
                    transferorOf
                },
                {
                    fn flushBeneficiaryBalance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <flushBeneficiaryBalanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::flushBeneficiaryBalance)
                    }
                    flushBeneficiaryBalance
                },
                {
                    fn resolveSingleBidAuction(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <resolveSingleBidAuctionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::resolveSingleBidAuction)
                    }
                    resolveSingleBidAuction
                },
                {
                    fn withdrawableBalanceAtRound(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <withdrawableBalanceAtRoundCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::withdrawableBalanceAtRound)
                    }
                    withdrawableBalanceAtRound
                },
                {
                    fn balanceOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <balanceOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::balanceOf)
                    }
                    balanceOf
                },
                {
                    fn roundTimestamps(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <roundTimestampsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::roundTimestamps)
                    }
                    roundTimestamps
                },
                {
                    fn minReservePrice(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <minReservePriceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::minReservePrice)
                    }
                    minReservePrice
                },
                {
                    fn MIN_RESERVE_SETTER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <MIN_RESERVE_SETTER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::MIN_RESERVE_SETTER_ROLE)
                    }
                    MIN_RESERVE_SETTER_ROLE
                },
                {
                    fn currentRound(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <currentRoundCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::currentRound)
                    }
                    currentRound
                },
                {
                    fn getRoleMember(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <getRoleMemberCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::getRoleMember)
                    }
                    getRoleMember
                },
                {
                    fn hasRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn initialize(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::initialize)
                    }
                    initialize
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn RESERVE_SETTER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <RESERVE_SETTER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::RESERVE_SETTER_ROLE)
                    }
                    RESERVE_SETTER_ROLE
                },
                {
                    fn initiateWithdrawal(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <initiateWithdrawalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::initiateWithdrawal)
                    }
                    initiateWithdrawal
                },
                {
                    fn deposit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <depositCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::deposit)
                    }
                    deposit
                },
                {
                    fn setTransferor(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <setTransferorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::setTransferor)
                    }
                    setTransferor
                },
                {
                    fn finalizeWithdrawal(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <finalizeWithdrawalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::finalizeWithdrawal)
                    }
                    finalizeWithdrawal
                },
                {
                    fn getRoleMemberCount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <getRoleMemberCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::getRoleMemberCount)
                    }
                    getRoleMemberCount
                },
                {
                    fn setReservePrice(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <setReservePriceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::setReservePrice)
                    }
                    setReservePrice
                },
                {
                    fn AUCTIONEER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <AUCTIONEER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::AUCTIONEER_ROLE)
                    }
                    AUCTIONEER_ROLE
                },
                {
                    fn revokeRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn reservePrice(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <reservePriceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::reservePrice)
                    }
                    reservePrice
                },
                {
                    fn beneficiaryBalance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <beneficiaryBalanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::beneficiaryBalance)
                    }
                    beneficiaryBalance
                },
                {
                    fn RESERVE_SETTER_ADMIN_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <RESERVE_SETTER_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::RESERVE_SETTER_ADMIN_ROLE)
                    }
                    RESERVE_SETTER_ADMIN_ROLE
                },
                {
                    fn isReserveBlackout(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <isReserveBlackoutCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::isReserveBlackout)
                    }
                    isReserveBlackout
                },
                {
                    fn setMinReservePrice(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <setMinReservePriceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::setMinReservePrice)
                    }
                    setMinReservePrice
                },
                {
                    fn domainSeparator(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <domainSeparatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::domainSeparator)
                    }
                    domainSeparator
                },
                {
                    fn setRoundTimingInfo(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionCalls> {
                        <setRoundTimingInfoCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionCalls::setRoundTimingInfo)
                    }
                    setRoundTimingInfo
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AUCTIONEER_ADMIN_ROLE(inner) => {
                    <AUCTIONEER_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AUCTIONEER_ROLE(inner) => {
                    <AUCTIONEER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BENEFICIARY_SETTER_ROLE(inner) => {
                    <BENEFICIARY_SETTER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MIN_RESERVE_SETTER_ROLE(inner) => {
                    <MIN_RESERVE_SETTER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::RESERVE_SETTER_ADMIN_ROLE(inner) => {
                    <RESERVE_SETTER_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::RESERVE_SETTER_ROLE(inner) => {
                    <RESERVE_SETTER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ROUND_TIMING_SETTER_ROLE(inner) => {
                    <ROUND_TIMING_SETTER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::balanceOfAtRound(inner) => {
                    <balanceOfAtRoundCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::beneficiary(inner) => {
                    <beneficiaryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::beneficiaryBalance(inner) => {
                    <beneficiaryBalanceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::biddingToken(inner) => {
                    <biddingTokenCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::currentRound(inner) => {
                    <currentRoundCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::deposit(inner) => {
                    <depositCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::domainSeparator(inner) => {
                    <domainSeparatorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::finalizeWithdrawal(inner) => {
                    <finalizeWithdrawalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::flushBeneficiaryBalance(inner) => {
                    <flushBeneficiaryBalanceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBidHash(inner) => {
                    <getBidHashCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleMember(inner) => {
                    <getRoleMemberCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleMemberCount(inner) => {
                    <getRoleMemberCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::initiateWithdrawal(inner) => {
                    <initiateWithdrawalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isAuctionRoundClosed(inner) => {
                    <isAuctionRoundClosedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isReserveBlackout(inner) => {
                    <isReserveBlackoutCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::minReservePrice(inner) => {
                    <minReservePriceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::reservePrice(inner) => {
                    <reservePriceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::resolveMultiBidAuction(inner) => {
                    <resolveMultiBidAuctionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::resolveSingleBidAuction(inner) => {
                    <resolveSingleBidAuctionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::resolvedRounds(inner) => {
                    <resolvedRoundsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::roundTimestamps(inner) => {
                    <roundTimestampsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::roundTimingInfo(inner) => {
                    <roundTimingInfoCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setBeneficiary(inner) => {
                    <setBeneficiaryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setMinReservePrice(inner) => {
                    <setMinReservePriceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setReservePrice(inner) => {
                    <setReservePriceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setRoundTimingInfo(inner) => {
                    <setRoundTimingInfoCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setTransferor(inner) => {
                    <setTransferorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transferExpressLaneController(inner) => {
                    <transferExpressLaneControllerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transferorOf(inner) => {
                    <transferorOfCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::withdrawableBalance(inner) => {
                    <withdrawableBalanceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::withdrawableBalanceAtRound(inner) => {
                    <withdrawableBalanceAtRoundCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AUCTIONEER_ADMIN_ROLE(inner) => {
                    <AUCTIONEER_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AUCTIONEER_ROLE(inner) => {
                    <AUCTIONEER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BENEFICIARY_SETTER_ROLE(inner) => {
                    <BENEFICIARY_SETTER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MIN_RESERVE_SETTER_ROLE(inner) => {
                    <MIN_RESERVE_SETTER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::RESERVE_SETTER_ADMIN_ROLE(inner) => {
                    <RESERVE_SETTER_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::RESERVE_SETTER_ROLE(inner) => {
                    <RESERVE_SETTER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ROUND_TIMING_SETTER_ROLE(inner) => {
                    <ROUND_TIMING_SETTER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::balanceOfAtRound(inner) => {
                    <balanceOfAtRoundCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::beneficiary(inner) => {
                    <beneficiaryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::beneficiaryBalance(inner) => {
                    <beneficiaryBalanceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::biddingToken(inner) => {
                    <biddingTokenCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::currentRound(inner) => {
                    <currentRoundCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::deposit(inner) => {
                    <depositCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::domainSeparator(inner) => {
                    <domainSeparatorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::finalizeWithdrawal(inner) => {
                    <finalizeWithdrawalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::flushBeneficiaryBalance(inner) => {
                    <flushBeneficiaryBalanceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBidHash(inner) => {
                    <getBidHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleMember(inner) => {
                    <getRoleMemberCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleMemberCount(inner) => {
                    <getRoleMemberCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initiateWithdrawal(inner) => {
                    <initiateWithdrawalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isAuctionRoundClosed(inner) => {
                    <isAuctionRoundClosedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isReserveBlackout(inner) => {
                    <isReserveBlackoutCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::minReservePrice(inner) => {
                    <minReservePriceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::reservePrice(inner) => {
                    <reservePriceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::resolveMultiBidAuction(inner) => {
                    <resolveMultiBidAuctionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::resolveSingleBidAuction(inner) => {
                    <resolveSingleBidAuctionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::resolvedRounds(inner) => {
                    <resolvedRoundsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::roundTimestamps(inner) => {
                    <roundTimestampsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::roundTimingInfo(inner) => {
                    <roundTimingInfoCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBeneficiary(inner) => {
                    <setBeneficiaryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setMinReservePrice(inner) => {
                    <setMinReservePriceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setReservePrice(inner) => {
                    <setReservePriceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setRoundTimingInfo(inner) => {
                    <setRoundTimingInfoCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setTransferor(inner) => {
                    <setTransferorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferExpressLaneController(inner) => {
                    <transferExpressLaneControllerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferorOf(inner) => {
                    <transferorOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::withdrawableBalance(inner) => {
                    <withdrawableBalanceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::withdrawableBalanceAtRound(inner) => {
                    <withdrawableBalanceAtRoundCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`ExpressLaneAuction`](self) custom errors.
    pub enum ExpressLaneAuctionErrors {
        #[allow(missing_docs)]
        AuctionNotClosed(AuctionNotClosed),
        #[allow(missing_docs)]
        BidsWrongOrder(BidsWrongOrder),
        #[allow(missing_docs)]
        FixedTransferor(FixedTransferor),
        #[allow(missing_docs)]
        InsufficientBalance(InsufficientBalance),
        #[allow(missing_docs)]
        InsufficientBalanceAcc(InsufficientBalanceAcc),
        #[allow(missing_docs)]
        InvalidNewRound(InvalidNewRound),
        #[allow(missing_docs)]
        InvalidNewStart(InvalidNewStart),
        #[allow(missing_docs)]
        NegativeOffset(NegativeOffset),
        #[allow(missing_docs)]
        NegativeRoundStart(NegativeRoundStart),
        #[allow(missing_docs)]
        NotExpressLaneController(NotExpressLaneController),
        #[allow(missing_docs)]
        NotTransferor(NotTransferor),
        #[allow(missing_docs)]
        NothingToWithdraw(NothingToWithdraw),
        #[allow(missing_docs)]
        ReserveBlackout(ReserveBlackout),
        #[allow(missing_docs)]
        ReservePriceNotMet(ReservePriceNotMet),
        #[allow(missing_docs)]
        ReservePriceTooLow(ReservePriceTooLow),
        #[allow(missing_docs)]
        RoundAlreadyResolved(RoundAlreadyResolved),
        #[allow(missing_docs)]
        RoundDurationTooShort(RoundDurationTooShort),
        #[allow(missing_docs)]
        RoundNotResolved(RoundNotResolved),
        #[allow(missing_docs)]
        RoundTooLong(RoundTooLong),
        #[allow(missing_docs)]
        RoundTooOld(RoundTooOld),
        #[allow(missing_docs)]
        SameBidder(SameBidder),
        #[allow(missing_docs)]
        TieBidsWrongOrder(TieBidsWrongOrder),
        #[allow(missing_docs)]
        WithdrawalInProgress(WithdrawalInProgress),
        #[allow(missing_docs)]
        WithdrawalMaxRound(WithdrawalMaxRound),
        #[allow(missing_docs)]
        ZeroAmount(ZeroAmount),
        #[allow(missing_docs)]
        ZeroAuctionClosingSeconds(ZeroAuctionClosingSeconds),
        #[allow(missing_docs)]
        ZeroBiddingToken(ZeroBiddingToken),
    }
    #[automatically_derived]
    impl ExpressLaneAuctionErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [4u8, 123u8, 173u8, 82u8],
            [4u8, 235u8, 107u8, 63u8],
            [22u8, 244u8, 109u8, 254u8],
            [31u8, 42u8, 32u8, 5u8],
            [50u8, 109u8, 227u8, 96u8],
            [54u8, 178u8, 76u8, 20u8],
            [57u8, 95u8, 79u8, 214u8],
            [61u8, 137u8, 221u8, 222u8],
            [63u8, 179u8, 199u8, 175u8],
            [69u8, 31u8, 135u8, 52u8],
            [79u8, 0u8, 105u8, 120u8],
            [86u8, 249u8, 183u8, 90u8],
            [102u8, 10u8, 246u8, 210u8],
            [104u8, 193u8, 140u8, 169u8],
            [117u8, 216u8, 153u8, 242u8],
            [118u8, 33u8, 217u8, 74u8],
            [145u8, 133u8, 160u8, 174u8],
            [160u8, 226u8, 105u8, 216u8],
            [162u8, 52u8, 203u8, 25u8],
            [185u8, 173u8, 238u8, 253u8],
            [195u8, 74u8, 118u8, 207u8],
            [207u8, 71u8, 145u8, 129u8],
            [208u8, 208u8, 79u8, 96u8],
            [218u8, 79u8, 39u8, 46u8],
            [241u8, 96u8, 173u8, 121u8],
            [244u8, 163u8, 228u8, 133u8],
            [251u8, 176u8, 82u8, 216u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for ExpressLaneAuctionErrors {
        const NAME: &'static str = "ExpressLaneAuctionErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 27usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AuctionNotClosed(_) => {
                    <AuctionNotClosed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BidsWrongOrder(_) => {
                    <BidsWrongOrder as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FixedTransferor(_) => {
                    <FixedTransferor as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientBalance(_) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientBalanceAcc(_) => {
                    <InsufficientBalanceAcc as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidNewRound(_) => {
                    <InvalidNewRound as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidNewStart(_) => {
                    <InvalidNewStart as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NegativeOffset(_) => {
                    <NegativeOffset as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NegativeRoundStart(_) => {
                    <NegativeRoundStart as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotExpressLaneController(_) => {
                    <NotExpressLaneController as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotTransferor(_) => {
                    <NotTransferor as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NothingToWithdraw(_) => {
                    <NothingToWithdraw as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ReserveBlackout(_) => {
                    <ReserveBlackout as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ReservePriceNotMet(_) => {
                    <ReservePriceNotMet as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ReservePriceTooLow(_) => {
                    <ReservePriceTooLow as alloy_sol_types::SolError>::SELECTOR
                }
                Self::RoundAlreadyResolved(_) => {
                    <RoundAlreadyResolved as alloy_sol_types::SolError>::SELECTOR
                }
                Self::RoundDurationTooShort(_) => {
                    <RoundDurationTooShort as alloy_sol_types::SolError>::SELECTOR
                }
                Self::RoundNotResolved(_) => {
                    <RoundNotResolved as alloy_sol_types::SolError>::SELECTOR
                }
                Self::RoundTooLong(_) => {
                    <RoundTooLong as alloy_sol_types::SolError>::SELECTOR
                }
                Self::RoundTooOld(_) => {
                    <RoundTooOld as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SameBidder(_) => {
                    <SameBidder as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TieBidsWrongOrder(_) => {
                    <TieBidsWrongOrder as alloy_sol_types::SolError>::SELECTOR
                }
                Self::WithdrawalInProgress(_) => {
                    <WithdrawalInProgress as alloy_sol_types::SolError>::SELECTOR
                }
                Self::WithdrawalMaxRound(_) => {
                    <WithdrawalMaxRound as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAmount(_) => {
                    <ZeroAmount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAuctionClosingSeconds(_) => {
                    <ZeroAuctionClosingSeconds as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroBiddingToken(_) => {
                    <ZeroBiddingToken as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors>] = &[
                {
                    fn ZeroAuctionClosingSeconds(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors> {
                        <ZeroAuctionClosingSeconds as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionErrors::ZeroAuctionClosingSeconds)
                    }
                    ZeroAuctionClosingSeconds
                },
                {
                    fn WithdrawalInProgress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors> {
                        <WithdrawalInProgress as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionErrors::WithdrawalInProgress)
                    }
                    WithdrawalInProgress
                },
                {
                    fn NegativeOffset(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors> {
                        <NegativeOffset as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionErrors::NegativeOffset)
                    }
                    NegativeOffset
                },
                {
                    fn ZeroAmount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors> {
                        <ZeroAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionErrors::ZeroAmount)
                    }
                    ZeroAmount
                },
                {
                    fn RoundDurationTooShort(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors> {
                        <RoundDurationTooShort as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionErrors::RoundDurationTooShort)
                    }
                    RoundDurationTooShort
                },
                {
                    fn InsufficientBalanceAcc(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors> {
                        <InsufficientBalanceAcc as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionErrors::InsufficientBalanceAcc)
                    }
                    InsufficientBalanceAcc
                },
                {
                    fn RoundTooOld(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors> {
                        <RoundTooOld as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionErrors::RoundTooOld)
                    }
                    RoundTooOld
                },
                {
                    fn WithdrawalMaxRound(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors> {
                        <WithdrawalMaxRound as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionErrors::WithdrawalMaxRound)
                    }
                    WithdrawalMaxRound
                },
                {
                    fn ZeroBiddingToken(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors> {
                        <ZeroBiddingToken as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionErrors::ZeroBiddingToken)
                    }
                    ZeroBiddingToken
                },
                {
                    fn RoundAlreadyResolved(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors> {
                        <RoundAlreadyResolved as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionErrors::RoundAlreadyResolved)
                    }
                    RoundAlreadyResolved
                },
                {
                    fn ReserveBlackout(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors> {
                        <ReserveBlackout as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionErrors::ReserveBlackout)
                    }
                    ReserveBlackout
                },
                {
                    fn ReservePriceNotMet(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors> {
                        <ReservePriceNotMet as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionErrors::ReservePriceNotMet)
                    }
                    ReservePriceNotMet
                },
                {
                    fn NotExpressLaneController(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors> {
                        <NotExpressLaneController as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionErrors::NotExpressLaneController)
                    }
                    NotExpressLaneController
                },
                {
                    fn InvalidNewRound(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors> {
                        <InvalidNewRound as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionErrors::InvalidNewRound)
                    }
                    InvalidNewRound
                },
                {
                    fn FixedTransferor(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors> {
                        <FixedTransferor as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionErrors::FixedTransferor)
                    }
                    FixedTransferor
                },
                {
                    fn NotTransferor(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors> {
                        <NotTransferor as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionErrors::NotTransferor)
                    }
                    NotTransferor
                },
                {
                    fn TieBidsWrongOrder(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors> {
                        <TieBidsWrongOrder as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionErrors::TieBidsWrongOrder)
                    }
                    TieBidsWrongOrder
                },
                {
                    fn InvalidNewStart(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors> {
                        <InvalidNewStart as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionErrors::InvalidNewStart)
                    }
                    InvalidNewStart
                },
                {
                    fn BidsWrongOrder(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors> {
                        <BidsWrongOrder as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionErrors::BidsWrongOrder)
                    }
                    BidsWrongOrder
                },
                {
                    fn AuctionNotClosed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors> {
                        <AuctionNotClosed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionErrors::AuctionNotClosed)
                    }
                    AuctionNotClosed
                },
                {
                    fn RoundTooLong(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors> {
                        <RoundTooLong as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionErrors::RoundTooLong)
                    }
                    RoundTooLong
                },
                {
                    fn InsufficientBalance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors> {
                        <InsufficientBalance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionErrors::InsufficientBalance)
                    }
                    InsufficientBalance
                },
                {
                    fn NothingToWithdraw(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors> {
                        <NothingToWithdraw as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionErrors::NothingToWithdraw)
                    }
                    NothingToWithdraw
                },
                {
                    fn ReservePriceTooLow(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors> {
                        <ReservePriceTooLow as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionErrors::ReservePriceTooLow)
                    }
                    ReservePriceTooLow
                },
                {
                    fn NegativeRoundStart(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors> {
                        <NegativeRoundStart as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionErrors::NegativeRoundStart)
                    }
                    NegativeRoundStart
                },
                {
                    fn SameBidder(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors> {
                        <SameBidder as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionErrors::SameBidder)
                    }
                    SameBidder
                },
                {
                    fn RoundNotResolved(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ExpressLaneAuctionErrors> {
                        <RoundNotResolved as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(ExpressLaneAuctionErrors::RoundNotResolved)
                    }
                    RoundNotResolved
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AuctionNotClosed(inner) => {
                    <AuctionNotClosed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BidsWrongOrder(inner) => {
                    <BidsWrongOrder as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::FixedTransferor(inner) => {
                    <FixedTransferor as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientBalance(inner) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientBalanceAcc(inner) => {
                    <InsufficientBalanceAcc as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidNewRound(inner) => {
                    <InvalidNewRound as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidNewStart(inner) => {
                    <InvalidNewStart as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NegativeOffset(inner) => {
                    <NegativeOffset as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NegativeRoundStart(inner) => {
                    <NegativeRoundStart as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotExpressLaneController(inner) => {
                    <NotExpressLaneController as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotTransferor(inner) => {
                    <NotTransferor as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NothingToWithdraw(inner) => {
                    <NothingToWithdraw as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ReserveBlackout(inner) => {
                    <ReserveBlackout as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ReservePriceNotMet(inner) => {
                    <ReservePriceNotMet as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ReservePriceTooLow(inner) => {
                    <ReservePriceTooLow as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::RoundAlreadyResolved(inner) => {
                    <RoundAlreadyResolved as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::RoundDurationTooShort(inner) => {
                    <RoundDurationTooShort as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::RoundNotResolved(inner) => {
                    <RoundNotResolved as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::RoundTooLong(inner) => {
                    <RoundTooLong as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::RoundTooOld(inner) => {
                    <RoundTooOld as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::SameBidder(inner) => {
                    <SameBidder as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::TieBidsWrongOrder(inner) => {
                    <TieBidsWrongOrder as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::WithdrawalInProgress(inner) => {
                    <WithdrawalInProgress as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::WithdrawalMaxRound(inner) => {
                    <WithdrawalMaxRound as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ZeroAmount(inner) => {
                    <ZeroAmount as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ZeroAuctionClosingSeconds(inner) => {
                    <ZeroAuctionClosingSeconds as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ZeroBiddingToken(inner) => {
                    <ZeroBiddingToken as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AuctionNotClosed(inner) => {
                    <AuctionNotClosed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BidsWrongOrder(inner) => {
                    <BidsWrongOrder as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FixedTransferor(inner) => {
                    <FixedTransferor as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientBalance(inner) => {
                    <InsufficientBalance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientBalanceAcc(inner) => {
                    <InsufficientBalanceAcc as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidNewRound(inner) => {
                    <InvalidNewRound as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidNewStart(inner) => {
                    <InvalidNewStart as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NegativeOffset(inner) => {
                    <NegativeOffset as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NegativeRoundStart(inner) => {
                    <NegativeRoundStart as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotExpressLaneController(inner) => {
                    <NotExpressLaneController as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotTransferor(inner) => {
                    <NotTransferor as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NothingToWithdraw(inner) => {
                    <NothingToWithdraw as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ReserveBlackout(inner) => {
                    <ReserveBlackout as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ReservePriceNotMet(inner) => {
                    <ReservePriceNotMet as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ReservePriceTooLow(inner) => {
                    <ReservePriceTooLow as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::RoundAlreadyResolved(inner) => {
                    <RoundAlreadyResolved as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::RoundDurationTooShort(inner) => {
                    <RoundDurationTooShort as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::RoundNotResolved(inner) => {
                    <RoundNotResolved as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::RoundTooLong(inner) => {
                    <RoundTooLong as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::RoundTooOld(inner) => {
                    <RoundTooOld as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SameBidder(inner) => {
                    <SameBidder as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::TieBidsWrongOrder(inner) => {
                    <TieBidsWrongOrder as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::WithdrawalInProgress(inner) => {
                    <WithdrawalInProgress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::WithdrawalMaxRound(inner) => {
                    <WithdrawalMaxRound as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAmount(inner) => {
                    <ZeroAmount as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::ZeroAuctionClosingSeconds(inner) => {
                    <ZeroAuctionClosingSeconds as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroBiddingToken(inner) => {
                    <ZeroBiddingToken as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`ExpressLaneAuction`](self) events.
    pub enum ExpressLaneAuctionEvents {
        #[allow(missing_docs)]
        AuctionResolved(AuctionResolved),
        #[allow(missing_docs)]
        Deposit(Deposit),
        #[allow(missing_docs)]
        Initialized(Initialized),
        #[allow(missing_docs)]
        RoleAdminChanged(RoleAdminChanged),
        #[allow(missing_docs)]
        RoleGranted(RoleGranted),
        #[allow(missing_docs)]
        RoleRevoked(RoleRevoked),
        #[allow(missing_docs)]
        SetBeneficiary(SetBeneficiary),
        #[allow(missing_docs)]
        SetExpressLaneController(SetExpressLaneController),
        #[allow(missing_docs)]
        SetMinReservePrice(SetMinReservePrice),
        #[allow(missing_docs)]
        SetReservePrice(SetReservePrice),
        #[allow(missing_docs)]
        SetRoundTimingInfo(SetRoundTimingInfo),
        #[allow(missing_docs)]
        SetTransferor(SetTransferor),
        #[allow(missing_docs)]
        WithdrawalFinalized(WithdrawalFinalized),
        #[allow(missing_docs)]
        WithdrawalInitiated(WithdrawalInitiated),
    }
    #[automatically_derived]
    impl ExpressLaneAuctionEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ],
            [
                49u8,
                246u8,
                146u8,
                1u8,
                250u8,
                183u8,
                145u8,
                46u8,
                62u8,
                201u8,
                133u8,
                14u8,
                58u8,
                183u8,
                5u8,
                150u8,
                75u8,
                244u8,
                109u8,
                157u8,
                66u8,
                118u8,
                189u8,
                203u8,
                182u8,
                208u8,
                94u8,
                150u8,
                94u8,
                95u8,
                84u8,
                1u8,
            ],
            [
                88u8,
                72u8,
                6u8,
                143u8,
                17u8,
                170u8,
                59u8,
                169u8,
                254u8,
                63u8,
                195u8,
                60u8,
                95u8,
                159u8,
                42u8,
                60u8,
                209u8,
                174u8,
                214u8,
                121u8,
                134u8,
                184u8,
                91u8,
                94u8,
                12u8,
                237u8,
                198u8,
                125u8,
                190u8,
                150u8,
                240u8,
                240u8,
            ],
            [
                127u8,
                38u8,
                184u8,
                63u8,
                249u8,
                110u8,
                31u8,
                43u8,
                106u8,
                104u8,
                47u8,
                19u8,
                56u8,
                82u8,
                246u8,
                121u8,
                138u8,
                9u8,
                196u8,
                101u8,
                218u8,
                149u8,
                146u8,
                20u8,
                96u8,
                206u8,
                251u8,
                56u8,
                71u8,
                64u8,
                36u8,
                152u8,
            ],
            [
                127u8,
                91u8,
                218u8,
                187u8,
                210u8,
                122u8,
                143u8,
                197u8,
                114u8,
                120u8,
                27u8,
                23u8,
                112u8,
                85u8,
                72u8,
                141u8,
                124u8,
                103u8,
                41u8,
                162u8,
                186u8,
                222u8,
                79u8,
                87u8,
                218u8,
                157u8,
                32u8,
                15u8,
                49u8,
                193u8,
                93u8,
                71u8,
            ],
            [
                138u8,
                1u8,
                73u8,
                178u8,
                243u8,
                221u8,
                242u8,
                201u8,
                238u8,
                133u8,
                115u8,
                129u8,
                101u8,
                19u8,
                29u8,
                130u8,
                186u8,
                187u8,
                185u8,
                56u8,
                247u8,
                73u8,
                50u8,
                29u8,
                89u8,
                247u8,
                87u8,
                80u8,
                175u8,
                167u8,
                244u8,
                230u8,
            ],
            [
                151u8,
                37u8,
                227u8,
                126u8,
                7u8,
                156u8,
                91u8,
                218u8,
                96u8,
                9u8,
                168u8,
                245u8,
                77u8,
                134u8,
                38u8,
                88u8,
                73u8,
                243u8,
                10u8,
                207u8,
                97u8,
                198u8,
                48u8,
                249u8,
                225u8,
                172u8,
                145u8,
                230u8,
                125u8,
                233u8,
                135u8,
                148u8,
            ],
            [
                152u8,
                44u8,
                251u8,
                115u8,
                120u8,
                59u8,
                140u8,
                100u8,
                69u8,
                92u8,
                118u8,
                205u8,
                235u8,
                19u8,
                81u8,
                70u8,
                124u8,
                79u8,
                30u8,
                107u8,
                54u8,
                21u8,
                254u8,
                192u8,
                125u8,
                242u8,
                50u8,
                193u8,
                180u8,
                111u8,
                253u8,
                71u8,
            ],
            [
                158u8,
                92u8,
                79u8,
                159u8,
                78u8,
                70u8,
                184u8,
                98u8,
                157u8,
                61u8,
                218u8,
                133u8,
                244u8,
                58u8,
                105u8,
                25u8,
                79u8,
                80u8,
                37u8,
                68u8,
                4u8,
                167u8,
                45u8,
                198u8,
                43u8,
                158u8,
                147u8,
                45u8,
                156u8,
                148u8,
                237u8,
                168u8,
            ],
            [
                181u8,
                154u8,
                220u8,
                130u8,
                12u8,
                166u8,
                66u8,
                218u8,
                212u8,
                147u8,
                160u8,
                166u8,
                224u8,
                189u8,
                249u8,
                121u8,
                220u8,
                174u8,
                3u8,
                125u8,
                234u8,
                17u8,
                75u8,
                112u8,
                213u8,
                198u8,
                107u8,
                28u8,
                11u8,
                121u8,
                28u8,
                75u8,
            ],
            [
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ],
            [
                225u8,
                255u8,
                252u8,
                196u8,
                146u8,
                61u8,
                4u8,
                181u8,
                89u8,
                244u8,
                210u8,
                154u8,
                139u8,
                252u8,
                108u8,
                218u8,
                4u8,
                235u8,
                91u8,
                13u8,
                60u8,
                70u8,
                7u8,
                81u8,
                194u8,
                64u8,
                44u8,
                92u8,
                92u8,
                201u8,
                16u8,
                156u8,
            ],
            [
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ],
            [
                246u8,
                210u8,
                141u8,
                242u8,
                53u8,
                217u8,
                250u8,
                69u8,
                164u8,
                45u8,
                69u8,
                219u8,
                183u8,
                196u8,
                244u8,
                172u8,
                118u8,
                237u8,
                181u8,
                30u8,
                82u8,
                143u8,
                9u8,
                242u8,
                90u8,
                6u8,
                80u8,
                211u8,
                43u8,
                139u8,
                51u8,
                192u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for ExpressLaneAuctionEvents {
        const NAME: &'static str = "ExpressLaneAuctionEvents";
        const COUNT: usize = 14usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<AuctionResolved as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <AuctionResolved as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::AuctionResolved)
                }
                Some(<Deposit as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Deposit as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Deposit)
                }
                Some(<Initialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Initialized)
                }
                Some(<RoleAdminChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleAdminChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleAdminChanged)
                }
                Some(<RoleGranted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleGranted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleGranted)
                }
                Some(<RoleRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleRevoked)
                }
                Some(<SetBeneficiary as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <SetBeneficiary as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::SetBeneficiary)
                }
                Some(
                    <SetExpressLaneController as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <SetExpressLaneController as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::SetExpressLaneController)
                }
                Some(
                    <SetMinReservePrice as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <SetMinReservePrice as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::SetMinReservePrice)
                }
                Some(<SetReservePrice as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <SetReservePrice as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::SetReservePrice)
                }
                Some(
                    <SetRoundTimingInfo as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <SetRoundTimingInfo as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::SetRoundTimingInfo)
                }
                Some(<SetTransferor as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <SetTransferor as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::SetTransferor)
                }
                Some(
                    <WithdrawalFinalized as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <WithdrawalFinalized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::WithdrawalFinalized)
                }
                Some(
                    <WithdrawalInitiated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <WithdrawalInitiated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::WithdrawalInitiated)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for ExpressLaneAuctionEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AuctionResolved(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Deposit(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SetBeneficiary(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SetExpressLaneController(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SetMinReservePrice(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SetReservePrice(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SetRoundTimingInfo(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SetTransferor(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::WithdrawalFinalized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::WithdrawalInitiated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AuctionResolved(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Deposit(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SetBeneficiary(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SetExpressLaneController(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SetMinReservePrice(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SetReservePrice(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SetRoundTimingInfo(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SetTransferor(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::WithdrawalFinalized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::WithdrawalInitiated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`ExpressLaneAuction`](self) contract instance.

See the [wrapper's documentation](`ExpressLaneAuctionInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> ExpressLaneAuctionInstance<T, P, N> {
        ExpressLaneAuctionInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<ExpressLaneAuctionInstance<T, P, N>>,
    > {
        ExpressLaneAuctionInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        ExpressLaneAuctionInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`ExpressLaneAuction`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`ExpressLaneAuction`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct ExpressLaneAuctionInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for ExpressLaneAuctionInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("ExpressLaneAuctionInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > ExpressLaneAuctionInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`ExpressLaneAuction`](self) contract instance.

See the [wrapper's documentation](`ExpressLaneAuctionInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<ExpressLaneAuctionInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> ExpressLaneAuctionInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> ExpressLaneAuctionInstance<T, P, N> {
            ExpressLaneAuctionInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > ExpressLaneAuctionInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`AUCTIONEER_ADMIN_ROLE`] function.
        pub fn AUCTIONEER_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, AUCTIONEER_ADMIN_ROLECall, N> {
            self.call_builder(&AUCTIONEER_ADMIN_ROLECall {})
        }
        ///Creates a new call builder for the [`AUCTIONEER_ROLE`] function.
        pub fn AUCTIONEER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, AUCTIONEER_ROLECall, N> {
            self.call_builder(&AUCTIONEER_ROLECall {})
        }
        ///Creates a new call builder for the [`BENEFICIARY_SETTER_ROLE`] function.
        pub fn BENEFICIARY_SETTER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, BENEFICIARY_SETTER_ROLECall, N> {
            self.call_builder(&BENEFICIARY_SETTER_ROLECall {})
        }
        ///Creates a new call builder for the [`DEFAULT_ADMIN_ROLE`] function.
        pub fn DEFAULT_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, DEFAULT_ADMIN_ROLECall, N> {
            self.call_builder(&DEFAULT_ADMIN_ROLECall {})
        }
        ///Creates a new call builder for the [`MIN_RESERVE_SETTER_ROLE`] function.
        pub fn MIN_RESERVE_SETTER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, MIN_RESERVE_SETTER_ROLECall, N> {
            self.call_builder(&MIN_RESERVE_SETTER_ROLECall {})
        }
        ///Creates a new call builder for the [`RESERVE_SETTER_ADMIN_ROLE`] function.
        pub fn RESERVE_SETTER_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, RESERVE_SETTER_ADMIN_ROLECall, N> {
            self.call_builder(&RESERVE_SETTER_ADMIN_ROLECall {})
        }
        ///Creates a new call builder for the [`RESERVE_SETTER_ROLE`] function.
        pub fn RESERVE_SETTER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, RESERVE_SETTER_ROLECall, N> {
            self.call_builder(&RESERVE_SETTER_ROLECall {})
        }
        ///Creates a new call builder for the [`ROUND_TIMING_SETTER_ROLE`] function.
        pub fn ROUND_TIMING_SETTER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, ROUND_TIMING_SETTER_ROLECall, N> {
            self.call_builder(&ROUND_TIMING_SETTER_ROLECall {})
        }
        ///Creates a new call builder for the [`balanceOf`] function.
        pub fn balanceOf(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, balanceOfCall, N> {
            self.call_builder(&balanceOfCall { account })
        }
        ///Creates a new call builder for the [`balanceOfAtRound`] function.
        pub fn balanceOfAtRound(
            &self,
            account: alloy::sol_types::private::Address,
            round: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, balanceOfAtRoundCall, N> {
            self.call_builder(
                &balanceOfAtRoundCall {
                    account,
                    round,
                },
            )
        }
        ///Creates a new call builder for the [`beneficiary`] function.
        pub fn beneficiary(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, beneficiaryCall, N> {
            self.call_builder(&beneficiaryCall {})
        }
        ///Creates a new call builder for the [`beneficiaryBalance`] function.
        pub fn beneficiaryBalance(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, beneficiaryBalanceCall, N> {
            self.call_builder(&beneficiaryBalanceCall {})
        }
        ///Creates a new call builder for the [`biddingToken`] function.
        pub fn biddingToken(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, biddingTokenCall, N> {
            self.call_builder(&biddingTokenCall {})
        }
        ///Creates a new call builder for the [`currentRound`] function.
        pub fn currentRound(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, currentRoundCall, N> {
            self.call_builder(&currentRoundCall {})
        }
        ///Creates a new call builder for the [`deposit`] function.
        pub fn deposit(
            &self,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, depositCall, N> {
            self.call_builder(&depositCall { amount })
        }
        ///Creates a new call builder for the [`domainSeparator`] function.
        pub fn domainSeparator(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, domainSeparatorCall, N> {
            self.call_builder(&domainSeparatorCall {})
        }
        ///Creates a new call builder for the [`finalizeWithdrawal`] function.
        pub fn finalizeWithdrawal(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, finalizeWithdrawalCall, N> {
            self.call_builder(&finalizeWithdrawalCall {})
        }
        ///Creates a new call builder for the [`flushBeneficiaryBalance`] function.
        pub fn flushBeneficiaryBalance(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, flushBeneficiaryBalanceCall, N> {
            self.call_builder(&flushBeneficiaryBalanceCall {})
        }
        ///Creates a new call builder for the [`getBidHash`] function.
        pub fn getBidHash(
            &self,
            round: u64,
            expressLaneController: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBidHashCall, N> {
            self.call_builder(
                &getBidHashCall {
                    round,
                    expressLaneController,
                    amount,
                },
            )
        }
        ///Creates a new call builder for the [`getRoleAdmin`] function.
        pub fn getRoleAdmin(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRoleAdminCall, N> {
            self.call_builder(&getRoleAdminCall { role })
        }
        ///Creates a new call builder for the [`getRoleMember`] function.
        pub fn getRoleMember(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            index: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRoleMemberCall, N> {
            self.call_builder(&getRoleMemberCall { role, index })
        }
        ///Creates a new call builder for the [`getRoleMemberCount`] function.
        pub fn getRoleMemberCount(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRoleMemberCountCall, N> {
            self.call_builder(&getRoleMemberCountCall { role })
        }
        ///Creates a new call builder for the [`grantRole`] function.
        pub fn grantRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, grantRoleCall, N> {
            self.call_builder(&grantRoleCall { role, account })
        }
        ///Creates a new call builder for the [`hasRole`] function.
        pub fn hasRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, hasRoleCall, N> {
            self.call_builder(&hasRoleCall { role, account })
        }
        ///Creates a new call builder for the [`initialize`] function.
        pub fn initialize(
            &self,
            args: <InitArgs as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, initializeCall, N> {
            self.call_builder(&initializeCall { args })
        }
        ///Creates a new call builder for the [`initiateWithdrawal`] function.
        pub fn initiateWithdrawal(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, initiateWithdrawalCall, N> {
            self.call_builder(&initiateWithdrawalCall {})
        }
        ///Creates a new call builder for the [`isAuctionRoundClosed`] function.
        pub fn isAuctionRoundClosed(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, isAuctionRoundClosedCall, N> {
            self.call_builder(&isAuctionRoundClosedCall {})
        }
        ///Creates a new call builder for the [`isReserveBlackout`] function.
        pub fn isReserveBlackout(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, isReserveBlackoutCall, N> {
            self.call_builder(&isReserveBlackoutCall {})
        }
        ///Creates a new call builder for the [`minReservePrice`] function.
        pub fn minReservePrice(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, minReservePriceCall, N> {
            self.call_builder(&minReservePriceCall {})
        }
        ///Creates a new call builder for the [`renounceRole`] function.
        pub fn renounceRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceRoleCall, N> {
            self.call_builder(&renounceRoleCall { role, account })
        }
        ///Creates a new call builder for the [`reservePrice`] function.
        pub fn reservePrice(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, reservePriceCall, N> {
            self.call_builder(&reservePriceCall {})
        }
        ///Creates a new call builder for the [`resolveMultiBidAuction`] function.
        pub fn resolveMultiBidAuction(
            &self,
            firstPriceBid: <Bid as alloy::sol_types::SolType>::RustType,
            secondPriceBid: <Bid as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, resolveMultiBidAuctionCall, N> {
            self.call_builder(
                &resolveMultiBidAuctionCall {
                    firstPriceBid,
                    secondPriceBid,
                },
            )
        }
        ///Creates a new call builder for the [`resolveSingleBidAuction`] function.
        pub fn resolveSingleBidAuction(
            &self,
            firstPriceBid: <Bid as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, resolveSingleBidAuctionCall, N> {
            self.call_builder(
                &resolveSingleBidAuctionCall {
                    firstPriceBid,
                },
            )
        }
        ///Creates a new call builder for the [`resolvedRounds`] function.
        pub fn resolvedRounds(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, resolvedRoundsCall, N> {
            self.call_builder(&resolvedRoundsCall {})
        }
        ///Creates a new call builder for the [`revokeRole`] function.
        pub fn revokeRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, revokeRoleCall, N> {
            self.call_builder(&revokeRoleCall { role, account })
        }
        ///Creates a new call builder for the [`roundTimestamps`] function.
        pub fn roundTimestamps(
            &self,
            round: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, roundTimestampsCall, N> {
            self.call_builder(&roundTimestampsCall { round })
        }
        ///Creates a new call builder for the [`roundTimingInfo`] function.
        pub fn roundTimingInfo(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, roundTimingInfoCall, N> {
            self.call_builder(&roundTimingInfoCall {})
        }
        ///Creates a new call builder for the [`setBeneficiary`] function.
        pub fn setBeneficiary(
            &self,
            newBeneficiary: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, setBeneficiaryCall, N> {
            self.call_builder(
                &setBeneficiaryCall {
                    newBeneficiary,
                },
            )
        }
        ///Creates a new call builder for the [`setMinReservePrice`] function.
        pub fn setMinReservePrice(
            &self,
            newMinReservePrice: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, setMinReservePriceCall, N> {
            self.call_builder(
                &setMinReservePriceCall {
                    newMinReservePrice,
                },
            )
        }
        ///Creates a new call builder for the [`setReservePrice`] function.
        pub fn setReservePrice(
            &self,
            newReservePrice: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, setReservePriceCall, N> {
            self.call_builder(
                &setReservePriceCall {
                    newReservePrice,
                },
            )
        }
        ///Creates a new call builder for the [`setRoundTimingInfo`] function.
        pub fn setRoundTimingInfo(
            &self,
            newRoundTimingInfo: <RoundTimingInfo as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, setRoundTimingInfoCall, N> {
            self.call_builder(
                &setRoundTimingInfoCall {
                    newRoundTimingInfo,
                },
            )
        }
        ///Creates a new call builder for the [`setTransferor`] function.
        pub fn setTransferor(
            &self,
            transferor: <Transferor as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, setTransferorCall, N> {
            self.call_builder(&setTransferorCall { transferor })
        }
        ///Creates a new call builder for the [`supportsInterface`] function.
        pub fn supportsInterface(
            &self,
            interfaceId: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<T, &P, supportsInterfaceCall, N> {
            self.call_builder(
                &supportsInterfaceCall {
                    interfaceId,
                },
            )
        }
        ///Creates a new call builder for the [`transferExpressLaneController`] function.
        pub fn transferExpressLaneController(
            &self,
            round: u64,
            newExpressLaneController: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            transferExpressLaneControllerCall,
            N,
        > {
            self.call_builder(
                &transferExpressLaneControllerCall {
                    round,
                    newExpressLaneController,
                },
            )
        }
        ///Creates a new call builder for the [`transferorOf`] function.
        pub fn transferorOf(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferorOfCall, N> {
            self.call_builder(&transferorOfCall { _0 })
        }
        ///Creates a new call builder for the [`withdrawableBalance`] function.
        pub fn withdrawableBalance(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, withdrawableBalanceCall, N> {
            self.call_builder(&withdrawableBalanceCall { account })
        }
        ///Creates a new call builder for the [`withdrawableBalanceAtRound`] function.
        pub fn withdrawableBalanceAtRound(
            &self,
            account: alloy::sol_types::private::Address,
            round: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, withdrawableBalanceAtRoundCall, N> {
            self.call_builder(
                &withdrawableBalanceAtRoundCall {
                    account,
                    round,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > ExpressLaneAuctionInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`AuctionResolved`] event.
        pub fn AuctionResolved_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, AuctionResolved, N> {
            self.event_filter::<AuctionResolved>()
        }
        ///Creates a new event filter for the [`Deposit`] event.
        pub fn Deposit_filter(&self) -> alloy_contract::Event<T, &P, Deposit, N> {
            self.event_filter::<Deposit>()
        }
        ///Creates a new event filter for the [`Initialized`] event.
        pub fn Initialized_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, Initialized, N> {
            self.event_filter::<Initialized>()
        }
        ///Creates a new event filter for the [`RoleAdminChanged`] event.
        pub fn RoleAdminChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleAdminChanged, N> {
            self.event_filter::<RoleAdminChanged>()
        }
        ///Creates a new event filter for the [`RoleGranted`] event.
        pub fn RoleGranted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleGranted, N> {
            self.event_filter::<RoleGranted>()
        }
        ///Creates a new event filter for the [`RoleRevoked`] event.
        pub fn RoleRevoked_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleRevoked, N> {
            self.event_filter::<RoleRevoked>()
        }
        ///Creates a new event filter for the [`SetBeneficiary`] event.
        pub fn SetBeneficiary_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, SetBeneficiary, N> {
            self.event_filter::<SetBeneficiary>()
        }
        ///Creates a new event filter for the [`SetExpressLaneController`] event.
        pub fn SetExpressLaneController_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, SetExpressLaneController, N> {
            self.event_filter::<SetExpressLaneController>()
        }
        ///Creates a new event filter for the [`SetMinReservePrice`] event.
        pub fn SetMinReservePrice_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, SetMinReservePrice, N> {
            self.event_filter::<SetMinReservePrice>()
        }
        ///Creates a new event filter for the [`SetReservePrice`] event.
        pub fn SetReservePrice_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, SetReservePrice, N> {
            self.event_filter::<SetReservePrice>()
        }
        ///Creates a new event filter for the [`SetRoundTimingInfo`] event.
        pub fn SetRoundTimingInfo_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, SetRoundTimingInfo, N> {
            self.event_filter::<SetRoundTimingInfo>()
        }
        ///Creates a new event filter for the [`SetTransferor`] event.
        pub fn SetTransferor_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, SetTransferor, N> {
            self.event_filter::<SetTransferor>()
        }
        ///Creates a new event filter for the [`WithdrawalFinalized`] event.
        pub fn WithdrawalFinalized_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, WithdrawalFinalized, N> {
            self.event_filter::<WithdrawalFinalized>()
        }
        ///Creates a new event filter for the [`WithdrawalInitiated`] event.
        pub fn WithdrawalInitiated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, WithdrawalInitiated, N> {
            self.event_filter::<WithdrawalInitiated>()
        }
    }
}
