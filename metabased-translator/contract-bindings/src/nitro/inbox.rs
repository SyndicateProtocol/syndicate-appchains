/**

Generated by the following Solidity interface...
```solidity
interface Inbox {
    error DataTooLarge(uint256 dataLength, uint256 maxDataLength);
    error GasLimitTooLarge();
    error InsufficientSubmissionCost(uint256 expected, uint256 actual);
    error InsufficientValue(uint256 expected, uint256 actual);
    error L1Forked();
    error NotAllowedOrigin(address origin);
    error NotCodelessOrigin();
    error NotForked();
    error NotOrigin();
    error NotOwner(address sender, address owner);
    error NotRollupOrOwner(address sender, address rollup, address owner);
    error RetryableData(address from, address to, uint256 l2CallValue, uint256 deposit, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, bytes data);

    event AllowListAddressSet(address indexed user, bool val);
    event AllowListEnabledUpdated(bool isEnabled);
    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);
    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);
    event Initialized(uint8 version);
    event Paused(address account);
    event Unpaused(address account);

    constructor(uint256 _maxDataSize);

    function allowListEnabled() external view returns (bool);
    function bridge() external view returns (address);
    function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee) external view returns (uint256);
    function createRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, bytes memory data) external payable returns (uint256);
    function createRetryableTicketNoRefundAliasRewrite(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, bytes memory data) external payable returns (uint256);
    function depositEth(uint256) external payable returns (uint256);
    function depositEth() external payable returns (uint256);
    function getProxyAdmin() external view returns (address);
    function initialize(address _bridge, address _sequencerInbox) external;
    function isAllowed(address) external view returns (bool);
    function maxDataSize() external view returns (uint256);
    function pause() external;
    function paused() external view returns (bool);
    function postUpgradeInit(address) external;
    function sendContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, uint256 value, bytes memory data) external returns (uint256);
    function sendL1FundedContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, bytes memory data) external payable returns (uint256);
    function sendL1FundedUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, bytes memory data) external payable returns (uint256);
    function sendL1FundedUnsignedTransactionToFork(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, bytes memory data) external payable returns (uint256);
    function sendL2Message(bytes memory messageData) external returns (uint256);
    function sendL2MessageFromOrigin(bytes memory messageData) external returns (uint256);
    function sendUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes memory data) external returns (uint256);
    function sendUnsignedTransactionToFork(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes memory data) external returns (uint256);
    function sendWithdrawEthToFork(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, uint256 value, address withdrawTo) external returns (uint256);
    function sequencerInbox() external view returns (address);
    function setAllowList(address[] memory user, bool[] memory val) external;
    function setAllowListEnabled(bool _allowListEnabled) external;
    function unpause() external;
    function unsafeCreateRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, bytes memory data) external payable returns (uint256);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "_maxDataSize",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "allowListEnabled",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridge",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IBridge"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "calculateRetryableSubmissionFee",
    "inputs": [
      {
        "name": "dataLength",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "baseFee",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "createRetryableTicket",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "l2CallValue",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxSubmissionCost",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "excessFeeRefundAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "callValueRefundAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "gasLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxFeePerGas",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "createRetryableTicketNoRefundAliasRewrite",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "l2CallValue",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxSubmissionCost",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "excessFeeRefundAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "callValueRefundAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "gasLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxFeePerGas",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "depositEth",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "depositEth",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "getProxyAdmin",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "initialize",
    "inputs": [
      {
        "name": "_bridge",
        "type": "address",
        "internalType": "contract IBridge"
      },
      {
        "name": "_sequencerInbox",
        "type": "address",
        "internalType": "contract ISequencerInbox"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "isAllowed",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "maxDataSize",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "paused",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "postUpgradeInit",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IBridge"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "sendContractTransaction",
    "inputs": [
      {
        "name": "gasLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxFeePerGas",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "sendL1FundedContractTransaction",
    "inputs": [
      {
        "name": "gasLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxFeePerGas",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "sendL1FundedUnsignedTransaction",
    "inputs": [
      {
        "name": "gasLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxFeePerGas",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nonce",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "sendL1FundedUnsignedTransactionToFork",
    "inputs": [
      {
        "name": "gasLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxFeePerGas",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nonce",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "sendL2Message",
    "inputs": [
      {
        "name": "messageData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "sendL2MessageFromOrigin",
    "inputs": [
      {
        "name": "messageData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "sendUnsignedTransaction",
    "inputs": [
      {
        "name": "gasLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxFeePerGas",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nonce",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "sendUnsignedTransactionToFork",
    "inputs": [
      {
        "name": "gasLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxFeePerGas",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nonce",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "sendWithdrawEthToFork",
    "inputs": [
      {
        "name": "gasLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxFeePerGas",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nonce",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "withdrawTo",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "sequencerInbox",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract ISequencerInbox"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setAllowList",
    "inputs": [
      {
        "name": "user",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "val",
        "type": "bool[]",
        "internalType": "bool[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setAllowListEnabled",
    "inputs": [
      {
        "name": "_allowListEnabled",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "unpause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "unsafeCreateRetryableTicket",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "l2CallValue",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxSubmissionCost",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "excessFeeRefundAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "callValueRefundAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "gasLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxFeePerGas",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "event",
    "name": "AllowListAddressSet",
    "inputs": [
      {
        "name": "user",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "val",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "AllowListEnabledUpdated",
    "inputs": [
      {
        "name": "isEnabled",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "InboxMessageDelivered",
    "inputs": [
      {
        "name": "messageNum",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "data",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "InboxMessageDeliveredFromOrigin",
    "inputs": [
      {
        "name": "messageNum",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialized",
    "inputs": [
      {
        "name": "version",
        "type": "uint8",
        "indexed": false,
        "internalType": "uint8"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Paused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Unpaused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "DataTooLarge",
    "inputs": [
      {
        "name": "dataLength",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxDataLength",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "GasLimitTooLarge",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientSubmissionCost",
    "inputs": [
      {
        "name": "expected",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "actual",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientValue",
    "inputs": [
      {
        "name": "expected",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "actual",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "L1Forked",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotAllowedOrigin",
    "inputs": [
      {
        "name": "origin",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotCodelessOrigin",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotForked",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotOrigin",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotOwner",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotRollupOrOwner",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "rollup",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "RetryableData",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "l2CallValue",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "deposit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxSubmissionCost",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "excessFeeRefundAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "callValueRefundAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "gasLimit",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxFeePerGas",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ]
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod Inbox {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60e0604052306080524660c052348015610017575f5ffd5b50604051612ad4380380612ad48339810160408190526100369161003e565b60a052610055565b5f6020828403121561004e575f5ffd5b5051919050565b60805160a05160c051612a166100be5f395f81816105600152818161077101528181610fd00152818161135e01526117ce01525f81816104a7015281816108070152818161085c01528181611ae80152611b4101525f8181610bc201526113ff0152612a165ff3fe6080604052600436106101ae575f3560e01c806370665f14116100e7578063c474d2c511610087578063e78cea9211610062578063e78cea9214610477578063e8eb1dc314610496578063ee35f327146104c9578063efeadb6d146104e8575f5ffd5b8063c474d2c514610426578063e3de72a514610445578063e6bd12cf14610464575f5ffd5b80638b3240a0116100c25780638b3240a01461036a578063a66b327d146103ba578063b75436bb146103d9578063babcc539146103f8575f5ffd5b806370665f14146103185780638456cb59146103375780638a631aa61461034b575f5ffd5b8063485cc955116101525780635e9167581161012d5780635e916758146102cc578063679b6ded146102df57806367ef3ab8146102f25780636e6e8a6a14610305575f5ffd5b8063485cc955146102775780635075788b146102965780635c975abb146102b5575f5ffd5b80631fe927cf1161018d5780631fe927cf1461020a57806322bd5c1c146102295780633f4ba83a14610259578063439370b11461026f575f5ffd5b8062f72382146101b25780630f4d14e9146101e45780631b871c8d146101f7575b5f5ffd5b3480156101bd575f5ffd5b506101d16101cc3660046121fb565b610507565b6040519081526020015b60405180910390f35b6101d16101f2366004612272565b61064c565b6101d1610205366004612289565b6106ad565b348015610215575f5ffd5b506101d1610224366004612327565b61071d565b348015610234575f5ffd5b5060665461024990600160a01b900460ff1681565b60405190151581526020016101db565b348015610264575f5ffd5b5061026d6108e3565b005b6101d1610a12565b348015610282575f5ffd5b5061026d610291366004612366565b610aee565b3480156102a1575f5ffd5b506101d16102b03660046121fb565b610caa565b3480156102c0575f5ffd5b5060335460ff16610249565b6101d16102da36600461239d565b610d52565b6101d16102ed366004612289565b610e03565b6101d1610300366004612402565b610e66565b6101d1610313366004612289565b610f19565b348015610323575f5ffd5b506101d1610332366004612470565b610f7c565b348015610342575f5ffd5b5061026d611100565b348015610356575f5ffd5b506101d16103653660046124b9565b61122c565b348015610375575f5ffd5b507fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103546001600160a01b03165b6040516001600160a01b0390911681526020016101db565b3480156103c5575f5ffd5b506101d16103d4366004612509565b6112d3565b3480156103e4575f5ffd5b506101d16103f3366004612327565b61130a565b348015610403575f5ffd5b50610249610412366004612529565b60676020525f908152604090205460ff1681565b348015610431575f5ffd5b5061026d610440366004612529565b6113f5565b348015610450575f5ffd5b5061026d61045f36600461262c565b611509565b6101d1610472366004612402565b61177a565b348015610482575f5ffd5b506065546103a2906001600160a01b031681565b3480156104a1575f5ffd5b506101d17f000000000000000000000000000000000000000000000000000000000000000081565b3480156104d4575f5ffd5b506066546103a2906001600160a01b031681565b3480156104f3575f5ffd5b5061026d6105023660046126f1565b611899565b5f610510611a90565b606654600160a01b900460ff1680156105385750325f9081526067602052604090205460ff16155b1561055d57604051630f51ed7160e41b81523260048201526024015b60405180910390fd5b467f00000000000000000000000000000000000000000000000000000000000000000361059d57604051635180dd8360e11b815260040160405180910390fd5b3332146105bd5760405163feb3d07160e01b815260040160405180910390fd5b67ffffffffffffffff8811156105e65760405163107c527b60e01b815260040160405180910390fd5b61064060037311110000000000000000000000000000000011101933015f8b8b8b8b6001600160a01b03168b8b8b60405160200161062b98979695949392919061270a565b6040516020818303038152906040525f611ae5565b98975050505050505050565b5f610655611a90565b606654600160a01b900460ff16801561067d5750325f9081526067602052604090205460ff16155b1561069d57604051630f51ed7160e41b8152326004820152602401610554565b6106a5610a12565b90505b919050565b5f6106b6611a90565b606654600160a01b900460ff1680156106de5750325f9081526067602052604090205460ff16155b156106fe57604051630f51ed7160e41b8152326004820152602401610554565b61070f8a8a8a8a8a8a8a8a8a610f19565b9a9950505050505050505050565b5f610726611a90565b606654600160a01b900460ff16801561074e5750325f9081526067602052604090205460ff16155b1561076e57604051630f51ed7160e41b8152326004820152602401610554565b467f0000000000000000000000000000000000000000000000000000000000000000146107c7576040517fc6ea680300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6107cf611bc4565b610805576040517fc8958ead00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7f0000000000000000000000000000000000000000000000000000000000000000821115610888576040517f4634691b000000000000000000000000000000000000000000000000000000008152600481018390527f00000000000000000000000000000000000000000000000000000000000000006024820152604401610554565b5f6108ad600333868660405161089f92919061276b565b60405180910390205f611bd8565b60405190915081907fab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c905f90a290505b92915050565b6065546040805163cb23bcb560e01b815290515f926001600160a01b03169163cb23bcb59160048083019260209291908290030181865afa15801561092a573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061094e919061277a565b9050336001600160a01b03821614610a07575f816001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561099d573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906109c1919061277a565b9050336001600160a01b03821614610a0557604051630739600760e01b81523360048201526001600160a01b03808416602483015282166044820152606401610554565b505b610a0f611c9c565b50565b5f610a1b611a90565b606654600160a01b900460ff168015610a435750325f9081526067602052604090205460ff16155b15610a6357604051630f51ed7160e41b8152326004820152602401610554565b33803b151580610a735750323314155b15610a91575033731111000000000000000000000000000000001111015b6040517fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606083901b166020820152346034820152610ae890600c9033906054015b60405160208183030381529060405234611ae5565b91505090565b5f54610100900460ff1615808015610b0c57505f54600160ff909116105b80610b255750303b158015610b2557505f5460ff166001145b610b975760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a65640000000000000000000000000000000000006064820152608401610554565b5f805460ff191660011790558015610bb8575f805461ff0019166101001790555b6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163003610c565760405162461bcd60e51b815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f64656c656761746563616c6c00000000000000000000000000000000000000006064820152608401610554565b610c608383611cee565b8015610ca5575f805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b505050565b5f610cb3611a90565b606654600160a01b900460ff168015610cdb5750325f9081526067602052604090205460ff16155b15610cfb57604051630f51ed7160e41b8152326004820152602401610554565b67ffffffffffffffff881115610d245760405163107c527b60e01b815260040160405180910390fd5b6106406003335f8b8b8b8b6001600160a01b03168b8b8b60405160200161062b98979695949392919061270a565b5f610d5b611a90565b606654600160a01b900460ff168015610d835750325f9081526067602052604090205460ff16155b15610da357604051630f51ed7160e41b8152326004820152602401610554565b67ffffffffffffffff861115610dcc5760405163107c527b60e01b815260040160405180910390fd5b610df960073360018989896001600160a01b0316348a8a604051602001610ad39796959493929190612795565b9695505050505050565b5f610e0c611a90565b606654600160a01b900460ff168015610e345750325f9081526067602052604090205460ff16155b15610e5457604051630f51ed7160e41b8152326004820152602401610554565b61070f8a8a8a8a8a8a8a348b8b611ddf565b5f610e6f611a90565b606654600160a01b900460ff168015610e975750325f9081526067602052604090205460ff16155b15610eb757604051630f51ed7160e41b8152326004820152602401610554565b67ffffffffffffffff871115610ee05760405163107c527b60e01b815260040160405180910390fd5b610f0e6007335f8a8a8a8a6001600160a01b0316348b8b604051602001610ad398979695949392919061270a565b979650505050505050565b5f610f22611a90565b606654600160a01b900460ff168015610f4a5750325f9081526067602052604090205460ff16155b15610f6a57604051630f51ed7160e41b8152326004820152602401610554565b61070f8a8a8a8a8a8a8a348b8b611ed7565b5f610f85611a90565b606654600160a01b900460ff168015610fad5750325f9081526067602052604090205460ff16155b15610fcd57604051630f51ed7160e41b8152326004820152602401610554565b467f00000000000000000000000000000000000000000000000000000000000000000361100d57604051635180dd8360e11b815260040160405180910390fd5b33321461102d5760405163feb3d07160e01b815260040160405180910390fd5b67ffffffffffffffff8611156110565760405163107c527b60e01b815260040160405180910390fd5b604080516001600160a01b0384166024808301919091528251808303909101815260449091018252602080820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f25e16063000000000000000000000000000000000000000000000000000000001790529151610df9926003923373111100000000000000000000000000000000111019019261062b925f928d928d928d926064928e92016127ef565b6065546040805163cb23bcb560e01b815290515f926001600160a01b03169163cb23bcb59160048083019260209291908290030181865afa158015611147573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061116b919061277a565b9050336001600160a01b03821614611224575f816001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156111ba573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906111de919061277a565b9050336001600160a01b0382161461122257604051630739600760e01b81523360048201526001600160a01b03808416602483015282166044820152606401610554565b505b610a0f61200c565b5f611235611a90565b606654600160a01b900460ff16801561125d5750325f9081526067602052604090205460ff16155b1561127d57604051630f51ed7160e41b8152326004820152602401610554565b67ffffffffffffffff8711156112a65760405163107c527b60e01b815260040160405180910390fd5b610f0e60033360018a8a8a6001600160a01b03168a8a8a60405160200161062b9796959493929190612795565b5f81156112e057816112e2565b485b6112ed84600661286b565b6112f990610578612882565b611303919061286b565b9392505050565b5f611313611a90565b606654600160a01b900460ff16801561133b5750325f9081526067602052604090205460ff16155b1561135b57604051630f51ed7160e41b8152326004820152602401610554565b467f0000000000000000000000000000000000000000000000000000000000000000146113b4576040517fc6ea680300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61130360033385858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201829052509250611ae5915050565b6001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001630036114935760405162461bcd60e51b815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f64656c656761746563616c6c00000000000000000000000000000000000000006064820152608401610554565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61038054336001600160a01b03821614610ca5576040517f23295f0e0000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b0382166024820152604401610554565b6065546040805163cb23bcb560e01b815290515f926001600160a01b03169163cb23bcb59160048083019260209291908290030181865afa158015611550573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611574919061277a565b9050336001600160a01b0382161461162d575f816001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156115c3573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906115e7919061277a565b9050336001600160a01b0382161461162b57604051630739600760e01b81523360048201526001600160a01b03808416602483015282166044820152606401610554565b505b815183511461167e5760405162461bcd60e51b815260206004820152600d60248201527f494e56414c49445f494e505554000000000000000000000000000000000000006044820152606401610554565b5f5b83518110156117745782818151811061169b5761169b612895565b602002602001015160675f8684815181106116b8576116b8612895565b60200260200101516001600160a01b03166001600160a01b031681526020019081526020015f205f6101000a81548160ff02191690831515021790555083818151811061170757611707612895565b60200260200101516001600160a01b03167fd9739f45a01ce092c5cdb3d68f63d63d21676b1c6c0b4f9cbc6be4cf5449595a84838151811061174b5761174b612895565b6020026020010151604051611764911515815260200190565b60405180910390a2600101611680565b50505050565b5f611783611a90565b606654600160a01b900460ff1680156117ab5750325f9081526067602052604090205460ff16155b156117cb57604051630f51ed7160e41b8152326004820152602401610554565b467f00000000000000000000000000000000000000000000000000000000000000000361180b57604051635180dd8360e11b815260040160405180910390fd5b33321461182b5760405163feb3d07160e01b815260040160405180910390fd5b67ffffffffffffffff8711156118545760405163107c527b60e01b815260040160405180910390fd5b610f0e60077311110000000000000000000000000000000011101933015f8a8a8a8a6001600160a01b0316348b8b604051602001610ad398979695949392919061270a565b6065546040805163cb23bcb560e01b815290515f926001600160a01b03169163cb23bcb59160048083019260209291908290030181865afa1580156118e0573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611904919061277a565b9050336001600160a01b038216146119bd575f816001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611953573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611977919061277a565b9050336001600160a01b038216146119bb57604051630739600760e01b81523360048201526001600160a01b03808416602483015282166044820152606401610554565b505b606654600160a01b900460ff16151582151503611a1c5760405162461bcd60e51b815260206004820152600b60248201527f414c52454144595f5345540000000000000000000000000000000000000000006044820152606401610554565b60668054831515600160a01b027fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff9091161790556040517f16435b45f7482047f839a6a19d291442627200f52cad2803c595150d0d440eb390611a8490841515815260200190565b60405180910390a15050565b60335460ff1615611ae35760405162461bcd60e51b815260206004820152601060248201527f5061757361626c653a20706175736564000000000000000000000000000000006044820152606401610554565b565b5f7f000000000000000000000000000000000000000000000000000000000000000083511115611b6d5782516040517f4634691b00000000000000000000000000000000000000000000000000000000815260048101919091527f00000000000000000000000000000000000000000000000000000000000000006024820152604401610554565b5f611b818686868051906020012086611bd8565b9050807fff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b85604051611bb391906128a9565b60405180910390a295945050505050565b5f3332148015611bd35750333b155b905090565b6065545f906001600160a01b0316638db5993b838773111100000000000000000000000000000000111188016040517fffffffff0000000000000000000000000000000000000000000000000000000060e086901b16815260ff90921660048301526001600160a01b031660248201526044810187905260640160206040518083038185885af1158015611c6e573d5f5f3e3d5ffd5b50505050506040513d601f19601f82011682018060405250810190611c9391906128de565b95945050505050565b611ca4612049565b6033805460ff191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b5f54610100900460ff16611d6a5760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e670000000000000000000000000000000000000000006064820152608401610554565b606580546001600160a01b038085167fffffffffffffffffffffffff000000000000000000000000000000000000000090921691909117909155606680547fffffffffffffffffffffff00000000000000000000000000000000000000000016918316919091179055611ddb61209b565b5050565b5f83611deb868861286b565b611df58c8c612882565b611dff9190612882565b811015611e6157611e10868861286b565b611e1a8c8c612882565b611e249190612882565b6040517f7040b58c000000000000000000000000000000000000000000000000000000008152600481019190915260248101829052604401610554565b6001600160a01b0389163b15611e8b57731111000000000000000000000000000000001111890198505b6001600160a01b0388163b15611eb557731111000000000000000000000000000000001111880197505b611ec78c8c8c8c8c8c8c8c8c8c611ed7565b9c9b505050505050505050505050565b5f8560011480611ee75750846001145b15611f3457338b8b868c8c8c8c8c8b8b6040517f07c266e30000000000000000000000000000000000000000000000000000000081526004016105549b9a999897969594939291906128f5565b67ffffffffffffffff861115611f5d5760405163107c527b60e01b815260040160405180910390fd5b5f611f6883486112d3565b9050808a1015611fae576040517ffadf238a00000000000000000000000000000000000000000000000000000000815260048101829052602481018b9052604401610554565b611ec76009336001600160a01b038f168e898f8f6001600160a01b03168f6001600160a01b03168f8f8e8e90508f8f604051602001611ff79b9a9998979695949392919061298c565b60405160208183030381529060405288611ae5565b612014611a90565b6033805460ff191660011790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258611cd13390565b60335460ff16611ae35760405162461bcd60e51b815260206004820152601460248201527f5061757361626c653a206e6f74207061757365640000000000000000000000006044820152606401610554565b5f54610100900460ff166121175760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e670000000000000000000000000000000000000000006064820152608401610554565b611ae35f54610100900460ff166121965760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e670000000000000000000000000000000000000000006064820152608401610554565b6033805460ff19169055565b6001600160a01b0381168114610a0f575f5ffd5b5f5f83601f8401126121c6575f5ffd5b50813567ffffffffffffffff8111156121dd575f5ffd5b6020830191508360208285010111156121f4575f5ffd5b9250929050565b5f5f5f5f5f5f5f60c0888a031215612211575f5ffd5b8735965060208801359550604088013594506060880135612231816121a2565b93506080880135925060a088013567ffffffffffffffff811115612253575f5ffd5b61225f8a828b016121b6565b989b979a50959850939692959293505050565b5f60208284031215612282575f5ffd5b5035919050565b5f5f5f5f5f5f5f5f5f6101008a8c0312156122a2575f5ffd5b89356122ad816121a2565b985060208a0135975060408a0135965060608a01356122cb816121a2565b955060808a01356122db816121a2565b945060a08a0135935060c08a0135925060e08a013567ffffffffffffffff811115612304575f5ffd5b6123108c828d016121b6565b915080935050809150509295985092959850929598565b5f5f60208385031215612338575f5ffd5b823567ffffffffffffffff81111561234e575f5ffd5b61235a858286016121b6565b90969095509350505050565b5f5f60408385031215612377575f5ffd5b8235612382816121a2565b91506020830135612392816121a2565b809150509250929050565b5f5f5f5f5f608086880312156123b1575f5ffd5b853594506020860135935060408601356123ca816121a2565b9250606086013567ffffffffffffffff8111156123e5575f5ffd5b6123f1888289016121b6565b969995985093965092949392505050565b5f5f5f5f5f5f60a08789031215612417575f5ffd5b8635955060208701359450604087013593506060870135612437816121a2565b9250608087013567ffffffffffffffff811115612452575f5ffd5b61245e89828a016121b6565b979a9699509497509295939492505050565b5f5f5f5f5f60a08688031215612484575f5ffd5b8535945060208601359350604086013592506060860135915060808601356124ab816121a2565b809150509295509295909350565b5f5f5f5f5f5f60a087890312156124ce575f5ffd5b863595506020870135945060408701356124e7816121a2565b935060608701359250608087013567ffffffffffffffff811115612452575f5ffd5b5f5f6040838503121561251a575f5ffd5b50508035926020909101359150565b5f60208284031215612539575f5ffd5b8135611303816121a2565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f1916810167ffffffffffffffff8111828210171561258157612581612544565b604052919050565b5f67ffffffffffffffff8211156125a2576125a2612544565b5060051b60200190565b803580151581146106a8575f5ffd5b5f82601f8301126125ca575f5ffd5b81356125dd6125d882612589565b612558565b8082825260208201915060208360051b8601019250858311156125fe575f5ffd5b602085015b8381101561262257612614816125ac565b835260209283019201612603565b5095945050505050565b5f5f6040838503121561263d575f5ffd5b823567ffffffffffffffff811115612653575f5ffd5b8301601f81018513612663575f5ffd5b80356126716125d882612589565b8082825260208201915060208360051b850101925087831115612692575f5ffd5b6020840193505b828410156126bd5783356126ac816121a2565b825260209384019390910190612699565b9450505050602083013567ffffffffffffffff8111156126db575f5ffd5b6126e7858286016125bb565b9150509250929050565b5f60208284031215612701575f5ffd5b611303826125ac565b7fff000000000000000000000000000000000000000000000000000000000000008960f81b168152876001820152866021820152856041820152846061820152836081820152818360a18301375f910160a101908152979650505050505050565b818382375f9101908152919050565b5f6020828403121561278a575f5ffd5b8151611303816121a2565b7fff000000000000000000000000000000000000000000000000000000000000008860f81b168152866001820152856021820152846041820152836061820152818360818301375f91016081019081529695505050505050565b7fff000000000000000000000000000000000000000000000000000000000000008860f81b1681528660018201528560218201528460418201528360618201528260818201525f8251806020850160a185015e5f920160a10191825250979650505050505050565b634e487b7160e01b5f52601160045260245ffd5b80820281158282048414176108dd576108dd612857565b808201808211156108dd576108dd612857565b634e487b7160e01b5f52603260045260245ffd5b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f83011684010191505092915050565b5f602082840312156128ee575f5ffd5b5051919050565b6001600160a01b038c1681526001600160a01b038b1660208201528960408201528860608201528760808201526001600160a01b03871660a08201526001600160a01b03861660c08201528460e0820152836101008201526101406101208201528161014082015281836101608301375f81830161016090810191909152601f909201601f191601019a9950505050505050505050565b8b81528a60208201528960408201528860608201528760808201528660a08201528560c08201528460e08201528361010082015281836101208301375f9101610120019081529a995050505050505050505056fea2646970667358221220ae2e9b8ab3513d7c2bce41d0cd7e738751340a043030ee880915bec6f3e5120764736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xE0`@R0`\x80RF`\xC0R4\x80\x15a\0\x17W__\xFD[P`@Qa*\xD48\x03\x80a*\xD4\x839\x81\x01`@\x81\x90Ra\x006\x91a\0>V[`\xA0Ra\0UV[_` \x82\x84\x03\x12\x15a\0NW__\xFD[PQ\x91\x90PV[`\x80Q`\xA0Q`\xC0Qa*\x16a\0\xBE_9_\x81\x81a\x05`\x01R\x81\x81a\x07q\x01R\x81\x81a\x0F\xD0\x01R\x81\x81a\x13^\x01Ra\x17\xCE\x01R_\x81\x81a\x04\xA7\x01R\x81\x81a\x08\x07\x01R\x81\x81a\x08\\\x01R\x81\x81a\x1A\xE8\x01Ra\x1BA\x01R_\x81\x81a\x0B\xC2\x01Ra\x13\xFF\x01Ra*\x16_\xF3\xFE`\x80`@R`\x046\x10a\x01\xAEW_5`\xE0\x1C\x80cpf_\x14\x11a\0\xE7W\x80c\xC4t\xD2\xC5\x11a\0\x87W\x80c\xE7\x8C\xEA\x92\x11a\0bW\x80c\xE7\x8C\xEA\x92\x14a\x04wW\x80c\xE8\xEB\x1D\xC3\x14a\x04\x96W\x80c\xEE5\xF3'\x14a\x04\xC9W\x80c\xEF\xEA\xDBm\x14a\x04\xE8W__\xFD[\x80c\xC4t\xD2\xC5\x14a\x04&W\x80c\xE3\xDEr\xA5\x14a\x04EW\x80c\xE6\xBD\x12\xCF\x14a\x04dW__\xFD[\x80c\x8B2@\xA0\x11a\0\xC2W\x80c\x8B2@\xA0\x14a\x03jW\x80c\xA6k2}\x14a\x03\xBAW\x80c\xB7T6\xBB\x14a\x03\xD9W\x80c\xBA\xBC\xC59\x14a\x03\xF8W__\xFD[\x80cpf_\x14\x14a\x03\x18W\x80c\x84V\xCBY\x14a\x037W\x80c\x8Ac\x1A\xA6\x14a\x03KW__\xFD[\x80cH\\\xC9U\x11a\x01RW\x80c^\x91gX\x11a\x01-W\x80c^\x91gX\x14a\x02\xCCW\x80cg\x9Bm\xED\x14a\x02\xDFW\x80cg\xEF:\xB8\x14a\x02\xF2W\x80cnn\x8Aj\x14a\x03\x05W__\xFD[\x80cH\\\xC9U\x14a\x02wW\x80cPux\x8B\x14a\x02\x96W\x80c\\\x97Z\xBB\x14a\x02\xB5W__\xFD[\x80c\x1F\xE9'\xCF\x11a\x01\x8DW\x80c\x1F\xE9'\xCF\x14a\x02\nW\x80c\"\xBD\\\x1C\x14a\x02)W\x80c?K\xA8:\x14a\x02YW\x80cC\x93p\xB1\x14a\x02oW__\xFD[\x80b\xF7#\x82\x14a\x01\xB2W\x80c\x0FM\x14\xE9\x14a\x01\xE4W\x80c\x1B\x87\x1C\x8D\x14a\x01\xF7W[__\xFD[4\x80\x15a\x01\xBDW__\xFD[Pa\x01\xD1a\x01\xCC6`\x04a!\xFBV[a\x05\x07V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x01\xD1a\x01\xF26`\x04a\"rV[a\x06LV[a\x01\xD1a\x02\x056`\x04a\"\x89V[a\x06\xADV[4\x80\x15a\x02\x15W__\xFD[Pa\x01\xD1a\x02$6`\x04a#'V[a\x07\x1DV[4\x80\x15a\x024W__\xFD[P`fTa\x02I\x90`\x01`\xA0\x1B\x90\x04`\xFF\x16\x81V[`@Q\x90\x15\x15\x81R` \x01a\x01\xDBV[4\x80\x15a\x02dW__\xFD[Pa\x02ma\x08\xE3V[\0[a\x01\xD1a\n\x12V[4\x80\x15a\x02\x82W__\xFD[Pa\x02ma\x02\x916`\x04a#fV[a\n\xEEV[4\x80\x15a\x02\xA1W__\xFD[Pa\x01\xD1a\x02\xB06`\x04a!\xFBV[a\x0C\xAAV[4\x80\x15a\x02\xC0W__\xFD[P`3T`\xFF\x16a\x02IV[a\x01\xD1a\x02\xDA6`\x04a#\x9DV[a\rRV[a\x01\xD1a\x02\xED6`\x04a\"\x89V[a\x0E\x03V[a\x01\xD1a\x03\x006`\x04a$\x02V[a\x0EfV[a\x01\xD1a\x03\x136`\x04a\"\x89V[a\x0F\x19V[4\x80\x15a\x03#W__\xFD[Pa\x01\xD1a\x0326`\x04a$pV[a\x0F|V[4\x80\x15a\x03BW__\xFD[Pa\x02ma\x11\0V[4\x80\x15a\x03VW__\xFD[Pa\x01\xD1a\x03e6`\x04a$\xB9V[a\x12,V[4\x80\x15a\x03uW__\xFD[P\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03T`\x01`\x01`\xA0\x1B\x03\x16[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x01\xDBV[4\x80\x15a\x03\xC5W__\xFD[Pa\x01\xD1a\x03\xD46`\x04a%\tV[a\x12\xD3V[4\x80\x15a\x03\xE4W__\xFD[Pa\x01\xD1a\x03\xF36`\x04a#'V[a\x13\nV[4\x80\x15a\x04\x03W__\xFD[Pa\x02Ia\x04\x126`\x04a%)V[`g` R_\x90\x81R`@\x90 T`\xFF\x16\x81V[4\x80\x15a\x041W__\xFD[Pa\x02ma\x04@6`\x04a%)V[a\x13\xF5V[4\x80\x15a\x04PW__\xFD[Pa\x02ma\x04_6`\x04a&,V[a\x15\tV[a\x01\xD1a\x04r6`\x04a$\x02V[a\x17zV[4\x80\x15a\x04\x82W__\xFD[P`eTa\x03\xA2\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[4\x80\x15a\x04\xA1W__\xFD[Pa\x01\xD1\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[4\x80\x15a\x04\xD4W__\xFD[P`fTa\x03\xA2\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[4\x80\x15a\x04\xF3W__\xFD[Pa\x02ma\x05\x026`\x04a&\xF1V[a\x18\x99V[_a\x05\x10a\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x058WP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x05]W`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01[`@Q\x80\x91\x03\x90\xFD[F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03a\x05\x9DW`@QcQ\x80\xDD\x83`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[32\x14a\x05\xBDW`@Qc\xFE\xB3\xD0q`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x88\x11\x15a\x05\xE6W`@Qc\x10|R{`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x06@`\x03s\x11\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x10\x193\x01_\x8B\x8B\x8B\x8B`\x01`\x01`\xA0\x1B\x03\x16\x8B\x8B\x8B`@Q` \x01a\x06+\x98\x97\x96\x95\x94\x93\x92\x91\x90a'\nV[`@Q` \x81\x83\x03\x03\x81R\x90`@R_a\x1A\xE5V[\x98\x97PPPPPPPPV[_a\x06Ua\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x06}WP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x06\x9DW`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x05TV[a\x06\xA5a\n\x12V[\x90P[\x91\x90PV[_a\x06\xB6a\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x06\xDEWP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x06\xFEW`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x05TV[a\x07\x0F\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8Aa\x0F\x19V[\x9A\x99PPPPPPPPPPV[_a\x07&a\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x07NWP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x07nW`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x05TV[F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x14a\x07\xC7W`@Q\x7F\xC6\xEAh\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x07\xCFa\x1B\xC4V[a\x08\x05W`@Q\x7F\xC8\x95\x8E\xAD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x11\x15a\x08\x88W`@Q\x7FF4i\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x83\x90R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`$\x82\x01R`D\x01a\x05TV[_a\x08\xAD`\x033\x86\x86`@Qa\x08\x9F\x92\x91\x90a'kV[`@Q\x80\x91\x03\x90 _a\x1B\xD8V[`@Q\x90\x91P\x81\x90\x7F\xABS#\x85\xBE\x8F\x10\x05\xA4\xB6\xBA\x8F\xA2\n\"E\xFA\xCB4a4\xACs\x9F\xE9\xA5\x19\x8D\xC1X\x0B\x9C\x90_\x90\xA2\x90P[\x92\x91PPV[`eT`@\x80Qc\xCB#\xBC\xB5`\xE0\x1B\x81R\x90Q_\x92`\x01`\x01`\xA0\x1B\x03\x16\x91c\xCB#\xBC\xB5\x91`\x04\x80\x83\x01\x92` \x92\x91\x90\x82\x90\x03\x01\x81\x86Z\xFA\x15\x80\x15a\t*W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\tN\x91\x90a'zV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\n\x07W_\x81`\x01`\x01`\xA0\x1B\x03\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\t\x9DW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\t\xC1\x91\x90a'zV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\n\x05W`@Qc\x079`\x07`\xE0\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x80\x84\x16`$\x83\x01R\x82\x16`D\x82\x01R`d\x01a\x05TV[P[a\n\x0Fa\x1C\x9CV[PV[_a\n\x1Ba\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\nCWP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\ncW`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x05TV[3\x80;\x15\x15\x80a\nsWP23\x14\x15[\x15a\n\x91WP3s\x11\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x11\x01[`@Q\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0``\x83\x90\x1B\x16` \x82\x01R4`4\x82\x01Ra\n\xE8\x90`\x0C\x903\x90`T\x01[`@Q` \x81\x83\x03\x03\x81R\x90`@R4a\x1A\xE5V[\x91PP\x90V[_Ta\x01\0\x90\x04`\xFF\x16\x15\x80\x80\x15a\x0B\x0CWP_T`\x01`\xFF\x90\x91\x16\x10[\x80a\x0B%WP0;\x15\x80\x15a\x0B%WP_T`\xFF\x16`\x01\x14[a\x0B\x97W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`.`$\x82\x01R\x7FInitializable: contract is alrea`D\x82\x01R\x7Fdy initialized\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x05TV[_\x80T`\xFF\x19\x16`\x01\x17\x90U\x80\x15a\x0B\xB8W_\x80Ta\xFF\0\x19\x16a\x01\0\x17\x90U[`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x160\x03a\x0CVW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`,`$\x82\x01R\x7FFunction must be called through `D\x82\x01R\x7Fdelegatecall\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x05TV[a\x0C`\x83\x83a\x1C\xEEV[\x80\x15a\x0C\xA5W_\x80Ta\xFF\0\x19\x16\x90U`@Q`\x01\x81R\x7F\x7F&\xB8?\xF9n\x1F+jh/\x138R\xF6y\x8A\t\xC4e\xDA\x95\x92\x14`\xCE\xFB8G@$\x98\x90` \x01`@Q\x80\x91\x03\x90\xA1[PPPV[_a\x0C\xB3a\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x0C\xDBWP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x0C\xFBW`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x05TV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x88\x11\x15a\r$W`@Qc\x10|R{`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x06@`\x033_\x8B\x8B\x8B\x8B`\x01`\x01`\xA0\x1B\x03\x16\x8B\x8B\x8B`@Q` \x01a\x06+\x98\x97\x96\x95\x94\x93\x92\x91\x90a'\nV[_a\r[a\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\r\x83WP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\r\xA3W`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x05TV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x86\x11\x15a\r\xCCW`@Qc\x10|R{`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\r\xF9`\x073`\x01\x89\x89\x89`\x01`\x01`\xA0\x1B\x03\x164\x8A\x8A`@Q` \x01a\n\xD3\x97\x96\x95\x94\x93\x92\x91\x90a'\x95V[\x96\x95PPPPPPV[_a\x0E\x0Ca\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x0E4WP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x0ETW`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x05TV[a\x07\x0F\x8A\x8A\x8A\x8A\x8A\x8A\x8A4\x8B\x8Ba\x1D\xDFV[_a\x0Eoa\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x0E\x97WP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x0E\xB7W`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x05TV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x87\x11\x15a\x0E\xE0W`@Qc\x10|R{`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x0F\x0E`\x073_\x8A\x8A\x8A\x8A`\x01`\x01`\xA0\x1B\x03\x164\x8B\x8B`@Q` \x01a\n\xD3\x98\x97\x96\x95\x94\x93\x92\x91\x90a'\nV[\x97\x96PPPPPPPV[_a\x0F\"a\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x0FJWP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x0FjW`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x05TV[a\x07\x0F\x8A\x8A\x8A\x8A\x8A\x8A\x8A4\x8B\x8Ba\x1E\xD7V[_a\x0F\x85a\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x0F\xADWP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x0F\xCDW`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x05TV[F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03a\x10\rW`@QcQ\x80\xDD\x83`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[32\x14a\x10-W`@Qc\xFE\xB3\xD0q`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x86\x11\x15a\x10VW`@Qc\x10|R{`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16`$\x80\x83\x01\x91\x90\x91R\x82Q\x80\x83\x03\x90\x91\x01\x81R`D\x90\x91\x01\x82R` \x80\x82\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F%\xE1`c\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x17\x90R\x91Qa\r\xF9\x92`\x03\x923s\x11\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x10\x19\x01\x92a\x06+\x92_\x92\x8D\x92\x8D\x92\x8D\x92`d\x92\x8E\x92\x01a'\xEFV[`eT`@\x80Qc\xCB#\xBC\xB5`\xE0\x1B\x81R\x90Q_\x92`\x01`\x01`\xA0\x1B\x03\x16\x91c\xCB#\xBC\xB5\x91`\x04\x80\x83\x01\x92` \x92\x91\x90\x82\x90\x03\x01\x81\x86Z\xFA\x15\x80\x15a\x11GW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x11k\x91\x90a'zV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x12$W_\x81`\x01`\x01`\xA0\x1B\x03\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x11\xBAW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x11\xDE\x91\x90a'zV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x12\"W`@Qc\x079`\x07`\xE0\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x80\x84\x16`$\x83\x01R\x82\x16`D\x82\x01R`d\x01a\x05TV[P[a\n\x0Fa \x0CV[_a\x125a\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x12]WP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x12}W`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x05TV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x87\x11\x15a\x12\xA6W`@Qc\x10|R{`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x0F\x0E`\x033`\x01\x8A\x8A\x8A`\x01`\x01`\xA0\x1B\x03\x16\x8A\x8A\x8A`@Q` \x01a\x06+\x97\x96\x95\x94\x93\x92\x91\x90a'\x95V[_\x81\x15a\x12\xE0W\x81a\x12\xE2V[H[a\x12\xED\x84`\x06a(kV[a\x12\xF9\x90a\x05xa(\x82V[a\x13\x03\x91\x90a(kV[\x93\x92PPPV[_a\x13\x13a\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x13;WP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x13[W`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x05TV[F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x14a\x13\xB4W`@Q\x7F\xC6\xEAh\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x13\x03`\x033\x85\x85\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x82\x90RP\x92Pa\x1A\xE5\x91PPV[`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x160\x03a\x14\x93W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`,`$\x82\x01R\x7FFunction must be called through `D\x82\x01R\x7Fdelegatecall\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x05TV[\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03\x80T3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x0C\xA5W`@Q\x7F#)_\x0E\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x82\x16`$\x82\x01R`D\x01a\x05TV[`eT`@\x80Qc\xCB#\xBC\xB5`\xE0\x1B\x81R\x90Q_\x92`\x01`\x01`\xA0\x1B\x03\x16\x91c\xCB#\xBC\xB5\x91`\x04\x80\x83\x01\x92` \x92\x91\x90\x82\x90\x03\x01\x81\x86Z\xFA\x15\x80\x15a\x15PW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x15t\x91\x90a'zV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x16-W_\x81`\x01`\x01`\xA0\x1B\x03\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x15\xC3W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x15\xE7\x91\x90a'zV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x16+W`@Qc\x079`\x07`\xE0\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x80\x84\x16`$\x83\x01R\x82\x16`D\x82\x01R`d\x01a\x05TV[P[\x81Q\x83Q\x14a\x16~W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\r`$\x82\x01R\x7FINVALID_INPUT\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x05TV[_[\x83Q\x81\x10\x15a\x17tW\x82\x81\x81Q\x81\x10a\x16\x9BWa\x16\x9Ba(\x95V[` \x02` \x01\x01Q`g_\x86\x84\x81Q\x81\x10a\x16\xB8Wa\x16\xB8a(\x95V[` \x02` \x01\x01Q`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x83\x81\x81Q\x81\x10a\x17\x07Wa\x17\x07a(\x95V[` \x02` \x01\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x7F\xD9s\x9FE\xA0\x1C\xE0\x92\xC5\xCD\xB3\xD6\x8Fc\xD6=!gk\x1Cl\x0BO\x9C\xBCk\xE4\xCFTIYZ\x84\x83\x81Q\x81\x10a\x17KWa\x17Ka(\x95V[` \x02` \x01\x01Q`@Qa\x17d\x91\x15\x15\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2`\x01\x01a\x16\x80V[PPPPV[_a\x17\x83a\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x17\xABWP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x17\xCBW`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x05TV[F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03a\x18\x0BW`@QcQ\x80\xDD\x83`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[32\x14a\x18+W`@Qc\xFE\xB3\xD0q`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x87\x11\x15a\x18TW`@Qc\x10|R{`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x0F\x0E`\x07s\x11\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x10\x193\x01_\x8A\x8A\x8A\x8A`\x01`\x01`\xA0\x1B\x03\x164\x8B\x8B`@Q` \x01a\n\xD3\x98\x97\x96\x95\x94\x93\x92\x91\x90a'\nV[`eT`@\x80Qc\xCB#\xBC\xB5`\xE0\x1B\x81R\x90Q_\x92`\x01`\x01`\xA0\x1B\x03\x16\x91c\xCB#\xBC\xB5\x91`\x04\x80\x83\x01\x92` \x92\x91\x90\x82\x90\x03\x01\x81\x86Z\xFA\x15\x80\x15a\x18\xE0W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x19\x04\x91\x90a'zV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x19\xBDW_\x81`\x01`\x01`\xA0\x1B\x03\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x19SW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x19w\x91\x90a'zV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x19\xBBW`@Qc\x079`\x07`\xE0\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x80\x84\x16`$\x83\x01R\x82\x16`D\x82\x01R`d\x01a\x05TV[P[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x15\x15\x82\x15\x15\x03a\x1A\x1CW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0B`$\x82\x01R\x7FALREADY_SET\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x05TV[`f\x80T\x83\x15\x15`\x01`\xA0\x1B\x02\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x17\x90U`@Q\x7F\x16C[E\xF7H G\xF89\xA6\xA1\x9D)\x14Bbr\0\xF5,\xAD(\x03\xC5\x95\x15\r\rD\x0E\xB3\x90a\x1A\x84\x90\x84\x15\x15\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA1PPV[`3T`\xFF\x16\x15a\x1A\xE3W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x10`$\x82\x01R\x7FPausable: paused\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x05TV[V[_\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83Q\x11\x15a\x1BmW\x82Q`@Q\x7FF4i\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x91\x90\x91R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`$\x82\x01R`D\x01a\x05TV[_a\x1B\x81\x86\x86\x86\x80Q\x90` \x01 \x86a\x1B\xD8V[\x90P\x80\x7F\xFFd\x90_s\xA6\x7F\xB5\x94\xE0\xF9@\xA8\x07Z\x86\r\xB4\x89\xAD\x99\x1E\x03/H\xC8\x11#\xEBR\xD6\x0B\x85`@Qa\x1B\xB3\x91\x90a(\xA9V[`@Q\x80\x91\x03\x90\xA2\x95\x94PPPPPV[_32\x14\x80\x15a\x1B\xD3WP3;\x15[\x90P\x90V[`eT_\x90`\x01`\x01`\xA0\x1B\x03\x16c\x8D\xB5\x99;\x83\x87s\x11\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x11\x88\x01`@Q\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\xE0\x86\x90\x1B\x16\x81R`\xFF\x90\x92\x16`\x04\x83\x01R`\x01`\x01`\xA0\x1B\x03\x16`$\x82\x01R`D\x81\x01\x87\x90R`d\x01` `@Q\x80\x83\x03\x81\x85\x88Z\xF1\x15\x80\x15a\x1CnW=__>=_\xFD[PPPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1C\x93\x91\x90a(\xDEV[\x95\x94PPPPPV[a\x1C\xA4a IV[`3\x80T`\xFF\x19\x16\x90U\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA3[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01`@Q\x80\x91\x03\x90\xA1V[_Ta\x01\0\x90\x04`\xFF\x16a\x1DjW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7FInitializable: contract is not i`D\x82\x01R\x7Fnitializing\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x05TV[`e\x80T`\x01`\x01`\xA0\x1B\x03\x80\x85\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x92\x16\x91\x90\x91\x17\x90\x91U`f\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x91\x83\x16\x91\x90\x91\x17\x90Ua\x1D\xDBa \x9BV[PPV[_\x83a\x1D\xEB\x86\x88a(kV[a\x1D\xF5\x8C\x8Ca(\x82V[a\x1D\xFF\x91\x90a(\x82V[\x81\x10\x15a\x1EaWa\x1E\x10\x86\x88a(kV[a\x1E\x1A\x8C\x8Ca(\x82V[a\x1E$\x91\x90a(\x82V[`@Q\x7Fp@\xB5\x8C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x91\x90\x91R`$\x81\x01\x82\x90R`D\x01a\x05TV[`\x01`\x01`\xA0\x1B\x03\x89\x16;\x15a\x1E\x8BWs\x11\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x11\x89\x01\x98P[`\x01`\x01`\xA0\x1B\x03\x88\x16;\x15a\x1E\xB5Ws\x11\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x11\x88\x01\x97P[a\x1E\xC7\x8C\x8C\x8C\x8C\x8C\x8C\x8C\x8C\x8C\x8Ca\x1E\xD7V[\x9C\x9BPPPPPPPPPPPPV[_\x85`\x01\x14\x80a\x1E\xE7WP\x84`\x01\x14[\x15a\x1F4W3\x8B\x8B\x86\x8C\x8C\x8C\x8C\x8C\x8B\x8B`@Q\x7F\x07\xC2f\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x05T\x9B\x9A\x99\x98\x97\x96\x95\x94\x93\x92\x91\x90a(\xF5V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x86\x11\x15a\x1F]W`@Qc\x10|R{`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a\x1Fh\x83Ha\x12\xD3V[\x90P\x80\x8A\x10\x15a\x1F\xAEW`@Q\x7F\xFA\xDF#\x8A\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x82\x90R`$\x81\x01\x8B\x90R`D\x01a\x05TV[a\x1E\xC7`\t3`\x01`\x01`\xA0\x1B\x03\x8F\x16\x8E\x89\x8F\x8F`\x01`\x01`\xA0\x1B\x03\x16\x8F`\x01`\x01`\xA0\x1B\x03\x16\x8F\x8F\x8E\x8E\x90P\x8F\x8F`@Q` \x01a\x1F\xF7\x9B\x9A\x99\x98\x97\x96\x95\x94\x93\x92\x91\x90a)\x8CV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x88a\x1A\xE5V[a \x14a\x1A\x90V[`3\x80T`\xFF\x19\x16`\x01\x17\x90U\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2Xa\x1C\xD13\x90V[`3T`\xFF\x16a\x1A\xE3W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x14`$\x82\x01R\x7FPausable: not paused\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x05TV[_Ta\x01\0\x90\x04`\xFF\x16a!\x17W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7FInitializable: contract is not i`D\x82\x01R\x7Fnitializing\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x05TV[a\x1A\xE3_Ta\x01\0\x90\x04`\xFF\x16a!\x96W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7FInitializable: contract is not i`D\x82\x01R\x7Fnitializing\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x05TV[`3\x80T`\xFF\x19\x16\x90UV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\n\x0FW__\xFD[__\x83`\x1F\x84\x01\x12a!\xC6W__\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a!\xDDW__\xFD[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15a!\xF4W__\xFD[\x92P\x92\x90PV[_______`\xC0\x88\x8A\x03\x12\x15a\"\x11W__\xFD[\x875\x96P` \x88\x015\x95P`@\x88\x015\x94P``\x88\x015a\"1\x81a!\xA2V[\x93P`\x80\x88\x015\x92P`\xA0\x88\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\"SW__\xFD[a\"_\x8A\x82\x8B\x01a!\xB6V[\x98\x9B\x97\x9AP\x95\x98P\x93\x96\x92\x95\x92\x93PPPV[_` \x82\x84\x03\x12\x15a\"\x82W__\xFD[P5\x91\x90PV[_________a\x01\0\x8A\x8C\x03\x12\x15a\"\xA2W__\xFD[\x895a\"\xAD\x81a!\xA2V[\x98P` \x8A\x015\x97P`@\x8A\x015\x96P``\x8A\x015a\"\xCB\x81a!\xA2V[\x95P`\x80\x8A\x015a\"\xDB\x81a!\xA2V[\x94P`\xA0\x8A\x015\x93P`\xC0\x8A\x015\x92P`\xE0\x8A\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a#\x04W__\xFD[a#\x10\x8C\x82\x8D\x01a!\xB6V[\x91P\x80\x93PP\x80\x91PP\x92\x95\x98P\x92\x95\x98P\x92\x95\x98V[__` \x83\x85\x03\x12\x15a#8W__\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a#NW__\xFD[a#Z\x85\x82\x86\x01a!\xB6V[\x90\x96\x90\x95P\x93PPPPV[__`@\x83\x85\x03\x12\x15a#wW__\xFD[\x825a#\x82\x81a!\xA2V[\x91P` \x83\x015a#\x92\x81a!\xA2V[\x80\x91PP\x92P\x92\x90PV[_____`\x80\x86\x88\x03\x12\x15a#\xB1W__\xFD[\x855\x94P` \x86\x015\x93P`@\x86\x015a#\xCA\x81a!\xA2V[\x92P``\x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a#\xE5W__\xFD[a#\xF1\x88\x82\x89\x01a!\xB6V[\x96\x99\x95\x98P\x93\x96P\x92\x94\x93\x92PPPV[______`\xA0\x87\x89\x03\x12\x15a$\x17W__\xFD[\x865\x95P` \x87\x015\x94P`@\x87\x015\x93P``\x87\x015a$7\x81a!\xA2V[\x92P`\x80\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a$RW__\xFD[a$^\x89\x82\x8A\x01a!\xB6V[\x97\x9A\x96\x99P\x94\x97P\x92\x95\x93\x94\x92PPPV[_____`\xA0\x86\x88\x03\x12\x15a$\x84W__\xFD[\x855\x94P` \x86\x015\x93P`@\x86\x015\x92P``\x86\x015\x91P`\x80\x86\x015a$\xAB\x81a!\xA2V[\x80\x91PP\x92\x95P\x92\x95\x90\x93PV[______`\xA0\x87\x89\x03\x12\x15a$\xCEW__\xFD[\x865\x95P` \x87\x015\x94P`@\x87\x015a$\xE7\x81a!\xA2V[\x93P``\x87\x015\x92P`\x80\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a$RW__\xFD[__`@\x83\x85\x03\x12\x15a%\x1AW__\xFD[PP\x805\x92` \x90\x91\x015\x91PV[_` \x82\x84\x03\x12\x15a%9W__\xFD[\x815a\x13\x03\x81a!\xA2V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a%\x81Wa%\x81a%DV[`@R\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a%\xA2Wa%\xA2a%DV[P`\x05\x1B` \x01\x90V[\x805\x80\x15\x15\x81\x14a\x06\xA8W__\xFD[_\x82`\x1F\x83\x01\x12a%\xCAW__\xFD[\x815a%\xDDa%\xD8\x82a%\x89V[a%XV[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x86\x01\x01\x92P\x85\x83\x11\x15a%\xFEW__\xFD[` \x85\x01[\x83\x81\x10\x15a&\"Wa&\x14\x81a%\xACV[\x83R` \x92\x83\x01\x92\x01a&\x03V[P\x95\x94PPPPPV[__`@\x83\x85\x03\x12\x15a&=W__\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a&SW__\xFD[\x83\x01`\x1F\x81\x01\x85\x13a&cW__\xFD[\x805a&qa%\xD8\x82a%\x89V[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x85\x01\x01\x92P\x87\x83\x11\x15a&\x92W__\xFD[` \x84\x01\x93P[\x82\x84\x10\x15a&\xBDW\x835a&\xAC\x81a!\xA2V[\x82R` \x93\x84\x01\x93\x90\x91\x01\x90a&\x99V[\x94PPPP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a&\xDBW__\xFD[a&\xE7\x85\x82\x86\x01a%\xBBV[\x91PP\x92P\x92\x90PV[_` \x82\x84\x03\x12\x15a'\x01W__\xFD[a\x13\x03\x82a%\xACV[\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x89`\xF8\x1B\x16\x81R\x87`\x01\x82\x01R\x86`!\x82\x01R\x85`A\x82\x01R\x84`a\x82\x01R\x83`\x81\x82\x01R\x81\x83`\xA1\x83\x017_\x91\x01`\xA1\x01\x90\x81R\x97\x96PPPPPPPV[\x81\x83\x827_\x91\x01\x90\x81R\x91\x90PV[_` \x82\x84\x03\x12\x15a'\x8AW__\xFD[\x81Qa\x13\x03\x81a!\xA2V[\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x88`\xF8\x1B\x16\x81R\x86`\x01\x82\x01R\x85`!\x82\x01R\x84`A\x82\x01R\x83`a\x82\x01R\x81\x83`\x81\x83\x017_\x91\x01`\x81\x01\x90\x81R\x96\x95PPPPPPV[\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x88`\xF8\x1B\x16\x81R\x86`\x01\x82\x01R\x85`!\x82\x01R\x84`A\x82\x01R\x83`a\x82\x01R\x82`\x81\x82\x01R_\x82Q\x80` \x85\x01`\xA1\x85\x01^_\x92\x01`\xA1\x01\x91\x82RP\x97\x96PPPPPPPV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x08\xDDWa\x08\xDDa(WV[\x80\x82\x01\x80\x82\x11\x15a\x08\xDDWa\x08\xDDa(WV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[` \x81R_\x82Q\x80` \x84\x01R\x80` \x85\x01`@\x85\x01^_`@\x82\x85\x01\x01R`@`\x1F\x19`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x92\x91PPV[_` \x82\x84\x03\x12\x15a(\xEEW__\xFD[PQ\x91\x90PV[`\x01`\x01`\xA0\x1B\x03\x8C\x16\x81R`\x01`\x01`\xA0\x1B\x03\x8B\x16` \x82\x01R\x89`@\x82\x01R\x88``\x82\x01R\x87`\x80\x82\x01R`\x01`\x01`\xA0\x1B\x03\x87\x16`\xA0\x82\x01R`\x01`\x01`\xA0\x1B\x03\x86\x16`\xC0\x82\x01R\x84`\xE0\x82\x01R\x83a\x01\0\x82\x01Ra\x01@a\x01 \x82\x01R\x81a\x01@\x82\x01R\x81\x83a\x01`\x83\x017_\x81\x83\x01a\x01`\x90\x81\x01\x91\x90\x91R`\x1F\x90\x92\x01`\x1F\x19\x16\x01\x01\x9A\x99PPPPPPPPPPV[\x8B\x81R\x8A` \x82\x01R\x89`@\x82\x01R\x88``\x82\x01R\x87`\x80\x82\x01R\x86`\xA0\x82\x01R\x85`\xC0\x82\x01R\x84`\xE0\x82\x01R\x83a\x01\0\x82\x01R\x81\x83a\x01 \x83\x017_\x91\x01a\x01 \x01\x90\x81R\x9A\x99PPPPPPPPPPV\xFE\xA2dipfsX\"\x12 \xAE.\x9B\x8A\xB3Q=|+\xCEA\xD0\xCD~s\x87Q4\n\x0400\xEE\x88\t\x15\xBE\xC6\xF3\xE5\x12\x07dsolcC\0\x08\x1C\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x6080604052600436106101ae575f3560e01c806370665f14116100e7578063c474d2c511610087578063e78cea9211610062578063e78cea9214610477578063e8eb1dc314610496578063ee35f327146104c9578063efeadb6d146104e8575f5ffd5b8063c474d2c514610426578063e3de72a514610445578063e6bd12cf14610464575f5ffd5b80638b3240a0116100c25780638b3240a01461036a578063a66b327d146103ba578063b75436bb146103d9578063babcc539146103f8575f5ffd5b806370665f14146103185780638456cb59146103375780638a631aa61461034b575f5ffd5b8063485cc955116101525780635e9167581161012d5780635e916758146102cc578063679b6ded146102df57806367ef3ab8146102f25780636e6e8a6a14610305575f5ffd5b8063485cc955146102775780635075788b146102965780635c975abb146102b5575f5ffd5b80631fe927cf1161018d5780631fe927cf1461020a57806322bd5c1c146102295780633f4ba83a14610259578063439370b11461026f575f5ffd5b8062f72382146101b25780630f4d14e9146101e45780631b871c8d146101f7575b5f5ffd5b3480156101bd575f5ffd5b506101d16101cc3660046121fb565b610507565b6040519081526020015b60405180910390f35b6101d16101f2366004612272565b61064c565b6101d1610205366004612289565b6106ad565b348015610215575f5ffd5b506101d1610224366004612327565b61071d565b348015610234575f5ffd5b5060665461024990600160a01b900460ff1681565b60405190151581526020016101db565b348015610264575f5ffd5b5061026d6108e3565b005b6101d1610a12565b348015610282575f5ffd5b5061026d610291366004612366565b610aee565b3480156102a1575f5ffd5b506101d16102b03660046121fb565b610caa565b3480156102c0575f5ffd5b5060335460ff16610249565b6101d16102da36600461239d565b610d52565b6101d16102ed366004612289565b610e03565b6101d1610300366004612402565b610e66565b6101d1610313366004612289565b610f19565b348015610323575f5ffd5b506101d1610332366004612470565b610f7c565b348015610342575f5ffd5b5061026d611100565b348015610356575f5ffd5b506101d16103653660046124b9565b61122c565b348015610375575f5ffd5b507fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103546001600160a01b03165b6040516001600160a01b0390911681526020016101db565b3480156103c5575f5ffd5b506101d16103d4366004612509565b6112d3565b3480156103e4575f5ffd5b506101d16103f3366004612327565b61130a565b348015610403575f5ffd5b50610249610412366004612529565b60676020525f908152604090205460ff1681565b348015610431575f5ffd5b5061026d610440366004612529565b6113f5565b348015610450575f5ffd5b5061026d61045f36600461262c565b611509565b6101d1610472366004612402565b61177a565b348015610482575f5ffd5b506065546103a2906001600160a01b031681565b3480156104a1575f5ffd5b506101d17f000000000000000000000000000000000000000000000000000000000000000081565b3480156104d4575f5ffd5b506066546103a2906001600160a01b031681565b3480156104f3575f5ffd5b5061026d6105023660046126f1565b611899565b5f610510611a90565b606654600160a01b900460ff1680156105385750325f9081526067602052604090205460ff16155b1561055d57604051630f51ed7160e41b81523260048201526024015b60405180910390fd5b467f00000000000000000000000000000000000000000000000000000000000000000361059d57604051635180dd8360e11b815260040160405180910390fd5b3332146105bd5760405163feb3d07160e01b815260040160405180910390fd5b67ffffffffffffffff8811156105e65760405163107c527b60e01b815260040160405180910390fd5b61064060037311110000000000000000000000000000000011101933015f8b8b8b8b6001600160a01b03168b8b8b60405160200161062b98979695949392919061270a565b6040516020818303038152906040525f611ae5565b98975050505050505050565b5f610655611a90565b606654600160a01b900460ff16801561067d5750325f9081526067602052604090205460ff16155b1561069d57604051630f51ed7160e41b8152326004820152602401610554565b6106a5610a12565b90505b919050565b5f6106b6611a90565b606654600160a01b900460ff1680156106de5750325f9081526067602052604090205460ff16155b156106fe57604051630f51ed7160e41b8152326004820152602401610554565b61070f8a8a8a8a8a8a8a8a8a610f19565b9a9950505050505050505050565b5f610726611a90565b606654600160a01b900460ff16801561074e5750325f9081526067602052604090205460ff16155b1561076e57604051630f51ed7160e41b8152326004820152602401610554565b467f0000000000000000000000000000000000000000000000000000000000000000146107c7576040517fc6ea680300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6107cf611bc4565b610805576040517fc8958ead00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7f0000000000000000000000000000000000000000000000000000000000000000821115610888576040517f4634691b000000000000000000000000000000000000000000000000000000008152600481018390527f00000000000000000000000000000000000000000000000000000000000000006024820152604401610554565b5f6108ad600333868660405161089f92919061276b565b60405180910390205f611bd8565b60405190915081907fab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c905f90a290505b92915050565b6065546040805163cb23bcb560e01b815290515f926001600160a01b03169163cb23bcb59160048083019260209291908290030181865afa15801561092a573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061094e919061277a565b9050336001600160a01b03821614610a07575f816001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561099d573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906109c1919061277a565b9050336001600160a01b03821614610a0557604051630739600760e01b81523360048201526001600160a01b03808416602483015282166044820152606401610554565b505b610a0f611c9c565b50565b5f610a1b611a90565b606654600160a01b900460ff168015610a435750325f9081526067602052604090205460ff16155b15610a6357604051630f51ed7160e41b8152326004820152602401610554565b33803b151580610a735750323314155b15610a91575033731111000000000000000000000000000000001111015b6040517fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606083901b166020820152346034820152610ae890600c9033906054015b60405160208183030381529060405234611ae5565b91505090565b5f54610100900460ff1615808015610b0c57505f54600160ff909116105b80610b255750303b158015610b2557505f5460ff166001145b610b975760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a65640000000000000000000000000000000000006064820152608401610554565b5f805460ff191660011790558015610bb8575f805461ff0019166101001790555b6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163003610c565760405162461bcd60e51b815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f64656c656761746563616c6c00000000000000000000000000000000000000006064820152608401610554565b610c608383611cee565b8015610ca5575f805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b505050565b5f610cb3611a90565b606654600160a01b900460ff168015610cdb5750325f9081526067602052604090205460ff16155b15610cfb57604051630f51ed7160e41b8152326004820152602401610554565b67ffffffffffffffff881115610d245760405163107c527b60e01b815260040160405180910390fd5b6106406003335f8b8b8b8b6001600160a01b03168b8b8b60405160200161062b98979695949392919061270a565b5f610d5b611a90565b606654600160a01b900460ff168015610d835750325f9081526067602052604090205460ff16155b15610da357604051630f51ed7160e41b8152326004820152602401610554565b67ffffffffffffffff861115610dcc5760405163107c527b60e01b815260040160405180910390fd5b610df960073360018989896001600160a01b0316348a8a604051602001610ad39796959493929190612795565b9695505050505050565b5f610e0c611a90565b606654600160a01b900460ff168015610e345750325f9081526067602052604090205460ff16155b15610e5457604051630f51ed7160e41b8152326004820152602401610554565b61070f8a8a8a8a8a8a8a348b8b611ddf565b5f610e6f611a90565b606654600160a01b900460ff168015610e975750325f9081526067602052604090205460ff16155b15610eb757604051630f51ed7160e41b8152326004820152602401610554565b67ffffffffffffffff871115610ee05760405163107c527b60e01b815260040160405180910390fd5b610f0e6007335f8a8a8a8a6001600160a01b0316348b8b604051602001610ad398979695949392919061270a565b979650505050505050565b5f610f22611a90565b606654600160a01b900460ff168015610f4a5750325f9081526067602052604090205460ff16155b15610f6a57604051630f51ed7160e41b8152326004820152602401610554565b61070f8a8a8a8a8a8a8a348b8b611ed7565b5f610f85611a90565b606654600160a01b900460ff168015610fad5750325f9081526067602052604090205460ff16155b15610fcd57604051630f51ed7160e41b8152326004820152602401610554565b467f00000000000000000000000000000000000000000000000000000000000000000361100d57604051635180dd8360e11b815260040160405180910390fd5b33321461102d5760405163feb3d07160e01b815260040160405180910390fd5b67ffffffffffffffff8611156110565760405163107c527b60e01b815260040160405180910390fd5b604080516001600160a01b0384166024808301919091528251808303909101815260449091018252602080820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f25e16063000000000000000000000000000000000000000000000000000000001790529151610df9926003923373111100000000000000000000000000000000111019019261062b925f928d928d928d926064928e92016127ef565b6065546040805163cb23bcb560e01b815290515f926001600160a01b03169163cb23bcb59160048083019260209291908290030181865afa158015611147573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061116b919061277a565b9050336001600160a01b03821614611224575f816001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156111ba573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906111de919061277a565b9050336001600160a01b0382161461122257604051630739600760e01b81523360048201526001600160a01b03808416602483015282166044820152606401610554565b505b610a0f61200c565b5f611235611a90565b606654600160a01b900460ff16801561125d5750325f9081526067602052604090205460ff16155b1561127d57604051630f51ed7160e41b8152326004820152602401610554565b67ffffffffffffffff8711156112a65760405163107c527b60e01b815260040160405180910390fd5b610f0e60033360018a8a8a6001600160a01b03168a8a8a60405160200161062b9796959493929190612795565b5f81156112e057816112e2565b485b6112ed84600661286b565b6112f990610578612882565b611303919061286b565b9392505050565b5f611313611a90565b606654600160a01b900460ff16801561133b5750325f9081526067602052604090205460ff16155b1561135b57604051630f51ed7160e41b8152326004820152602401610554565b467f0000000000000000000000000000000000000000000000000000000000000000146113b4576040517fc6ea680300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61130360033385858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201829052509250611ae5915050565b6001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001630036114935760405162461bcd60e51b815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f64656c656761746563616c6c00000000000000000000000000000000000000006064820152608401610554565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61038054336001600160a01b03821614610ca5576040517f23295f0e0000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b0382166024820152604401610554565b6065546040805163cb23bcb560e01b815290515f926001600160a01b03169163cb23bcb59160048083019260209291908290030181865afa158015611550573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611574919061277a565b9050336001600160a01b0382161461162d575f816001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156115c3573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906115e7919061277a565b9050336001600160a01b0382161461162b57604051630739600760e01b81523360048201526001600160a01b03808416602483015282166044820152606401610554565b505b815183511461167e5760405162461bcd60e51b815260206004820152600d60248201527f494e56414c49445f494e505554000000000000000000000000000000000000006044820152606401610554565b5f5b83518110156117745782818151811061169b5761169b612895565b602002602001015160675f8684815181106116b8576116b8612895565b60200260200101516001600160a01b03166001600160a01b031681526020019081526020015f205f6101000a81548160ff02191690831515021790555083818151811061170757611707612895565b60200260200101516001600160a01b03167fd9739f45a01ce092c5cdb3d68f63d63d21676b1c6c0b4f9cbc6be4cf5449595a84838151811061174b5761174b612895565b6020026020010151604051611764911515815260200190565b60405180910390a2600101611680565b50505050565b5f611783611a90565b606654600160a01b900460ff1680156117ab5750325f9081526067602052604090205460ff16155b156117cb57604051630f51ed7160e41b8152326004820152602401610554565b467f00000000000000000000000000000000000000000000000000000000000000000361180b57604051635180dd8360e11b815260040160405180910390fd5b33321461182b5760405163feb3d07160e01b815260040160405180910390fd5b67ffffffffffffffff8711156118545760405163107c527b60e01b815260040160405180910390fd5b610f0e60077311110000000000000000000000000000000011101933015f8a8a8a8a6001600160a01b0316348b8b604051602001610ad398979695949392919061270a565b6065546040805163cb23bcb560e01b815290515f926001600160a01b03169163cb23bcb59160048083019260209291908290030181865afa1580156118e0573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611904919061277a565b9050336001600160a01b038216146119bd575f816001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611953573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611977919061277a565b9050336001600160a01b038216146119bb57604051630739600760e01b81523360048201526001600160a01b03808416602483015282166044820152606401610554565b505b606654600160a01b900460ff16151582151503611a1c5760405162461bcd60e51b815260206004820152600b60248201527f414c52454144595f5345540000000000000000000000000000000000000000006044820152606401610554565b60668054831515600160a01b027fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff9091161790556040517f16435b45f7482047f839a6a19d291442627200f52cad2803c595150d0d440eb390611a8490841515815260200190565b60405180910390a15050565b60335460ff1615611ae35760405162461bcd60e51b815260206004820152601060248201527f5061757361626c653a20706175736564000000000000000000000000000000006044820152606401610554565b565b5f7f000000000000000000000000000000000000000000000000000000000000000083511115611b6d5782516040517f4634691b00000000000000000000000000000000000000000000000000000000815260048101919091527f00000000000000000000000000000000000000000000000000000000000000006024820152604401610554565b5f611b818686868051906020012086611bd8565b9050807fff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b85604051611bb391906128a9565b60405180910390a295945050505050565b5f3332148015611bd35750333b155b905090565b6065545f906001600160a01b0316638db5993b838773111100000000000000000000000000000000111188016040517fffffffff0000000000000000000000000000000000000000000000000000000060e086901b16815260ff90921660048301526001600160a01b031660248201526044810187905260640160206040518083038185885af1158015611c6e573d5f5f3e3d5ffd5b50505050506040513d601f19601f82011682018060405250810190611c9391906128de565b95945050505050565b611ca4612049565b6033805460ff191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b5f54610100900460ff16611d6a5760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e670000000000000000000000000000000000000000006064820152608401610554565b606580546001600160a01b038085167fffffffffffffffffffffffff000000000000000000000000000000000000000090921691909117909155606680547fffffffffffffffffffffff00000000000000000000000000000000000000000016918316919091179055611ddb61209b565b5050565b5f83611deb868861286b565b611df58c8c612882565b611dff9190612882565b811015611e6157611e10868861286b565b611e1a8c8c612882565b611e249190612882565b6040517f7040b58c000000000000000000000000000000000000000000000000000000008152600481019190915260248101829052604401610554565b6001600160a01b0389163b15611e8b57731111000000000000000000000000000000001111890198505b6001600160a01b0388163b15611eb557731111000000000000000000000000000000001111880197505b611ec78c8c8c8c8c8c8c8c8c8c611ed7565b9c9b505050505050505050505050565b5f8560011480611ee75750846001145b15611f3457338b8b868c8c8c8c8c8b8b6040517f07c266e30000000000000000000000000000000000000000000000000000000081526004016105549b9a999897969594939291906128f5565b67ffffffffffffffff861115611f5d5760405163107c527b60e01b815260040160405180910390fd5b5f611f6883486112d3565b9050808a1015611fae576040517ffadf238a00000000000000000000000000000000000000000000000000000000815260048101829052602481018b9052604401610554565b611ec76009336001600160a01b038f168e898f8f6001600160a01b03168f6001600160a01b03168f8f8e8e90508f8f604051602001611ff79b9a9998979695949392919061298c565b60405160208183030381529060405288611ae5565b612014611a90565b6033805460ff191660011790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258611cd13390565b60335460ff16611ae35760405162461bcd60e51b815260206004820152601460248201527f5061757361626c653a206e6f74207061757365640000000000000000000000006044820152606401610554565b5f54610100900460ff166121175760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e670000000000000000000000000000000000000000006064820152608401610554565b611ae35f54610100900460ff166121965760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e670000000000000000000000000000000000000000006064820152608401610554565b6033805460ff19169055565b6001600160a01b0381168114610a0f575f5ffd5b5f5f83601f8401126121c6575f5ffd5b50813567ffffffffffffffff8111156121dd575f5ffd5b6020830191508360208285010111156121f4575f5ffd5b9250929050565b5f5f5f5f5f5f5f60c0888a031215612211575f5ffd5b8735965060208801359550604088013594506060880135612231816121a2565b93506080880135925060a088013567ffffffffffffffff811115612253575f5ffd5b61225f8a828b016121b6565b989b979a50959850939692959293505050565b5f60208284031215612282575f5ffd5b5035919050565b5f5f5f5f5f5f5f5f5f6101008a8c0312156122a2575f5ffd5b89356122ad816121a2565b985060208a0135975060408a0135965060608a01356122cb816121a2565b955060808a01356122db816121a2565b945060a08a0135935060c08a0135925060e08a013567ffffffffffffffff811115612304575f5ffd5b6123108c828d016121b6565b915080935050809150509295985092959850929598565b5f5f60208385031215612338575f5ffd5b823567ffffffffffffffff81111561234e575f5ffd5b61235a858286016121b6565b90969095509350505050565b5f5f60408385031215612377575f5ffd5b8235612382816121a2565b91506020830135612392816121a2565b809150509250929050565b5f5f5f5f5f608086880312156123b1575f5ffd5b853594506020860135935060408601356123ca816121a2565b9250606086013567ffffffffffffffff8111156123e5575f5ffd5b6123f1888289016121b6565b969995985093965092949392505050565b5f5f5f5f5f5f60a08789031215612417575f5ffd5b8635955060208701359450604087013593506060870135612437816121a2565b9250608087013567ffffffffffffffff811115612452575f5ffd5b61245e89828a016121b6565b979a9699509497509295939492505050565b5f5f5f5f5f60a08688031215612484575f5ffd5b8535945060208601359350604086013592506060860135915060808601356124ab816121a2565b809150509295509295909350565b5f5f5f5f5f5f60a087890312156124ce575f5ffd5b863595506020870135945060408701356124e7816121a2565b935060608701359250608087013567ffffffffffffffff811115612452575f5ffd5b5f5f6040838503121561251a575f5ffd5b50508035926020909101359150565b5f60208284031215612539575f5ffd5b8135611303816121a2565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f1916810167ffffffffffffffff8111828210171561258157612581612544565b604052919050565b5f67ffffffffffffffff8211156125a2576125a2612544565b5060051b60200190565b803580151581146106a8575f5ffd5b5f82601f8301126125ca575f5ffd5b81356125dd6125d882612589565b612558565b8082825260208201915060208360051b8601019250858311156125fe575f5ffd5b602085015b8381101561262257612614816125ac565b835260209283019201612603565b5095945050505050565b5f5f6040838503121561263d575f5ffd5b823567ffffffffffffffff811115612653575f5ffd5b8301601f81018513612663575f5ffd5b80356126716125d882612589565b8082825260208201915060208360051b850101925087831115612692575f5ffd5b6020840193505b828410156126bd5783356126ac816121a2565b825260209384019390910190612699565b9450505050602083013567ffffffffffffffff8111156126db575f5ffd5b6126e7858286016125bb565b9150509250929050565b5f60208284031215612701575f5ffd5b611303826125ac565b7fff000000000000000000000000000000000000000000000000000000000000008960f81b168152876001820152866021820152856041820152846061820152836081820152818360a18301375f910160a101908152979650505050505050565b818382375f9101908152919050565b5f6020828403121561278a575f5ffd5b8151611303816121a2565b7fff000000000000000000000000000000000000000000000000000000000000008860f81b168152866001820152856021820152846041820152836061820152818360818301375f91016081019081529695505050505050565b7fff000000000000000000000000000000000000000000000000000000000000008860f81b1681528660018201528560218201528460418201528360618201528260818201525f8251806020850160a185015e5f920160a10191825250979650505050505050565b634e487b7160e01b5f52601160045260245ffd5b80820281158282048414176108dd576108dd612857565b808201808211156108dd576108dd612857565b634e487b7160e01b5f52603260045260245ffd5b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f83011684010191505092915050565b5f602082840312156128ee575f5ffd5b5051919050565b6001600160a01b038c1681526001600160a01b038b1660208201528960408201528860608201528760808201526001600160a01b03871660a08201526001600160a01b03861660c08201528460e0820152836101008201526101406101208201528161014082015281836101608301375f81830161016090810191909152601f909201601f191601019a9950505050505050505050565b8b81528a60208201528960408201528860608201528760808201528660a08201528560c08201528460e08201528361010082015281836101208301375f9101610120019081529a995050505050505050505056fea2646970667358221220ae2e9b8ab3513d7c2bce41d0cd7e738751340a043030ee880915bec6f3e5120764736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10a\x01\xAEW_5`\xE0\x1C\x80cpf_\x14\x11a\0\xE7W\x80c\xC4t\xD2\xC5\x11a\0\x87W\x80c\xE7\x8C\xEA\x92\x11a\0bW\x80c\xE7\x8C\xEA\x92\x14a\x04wW\x80c\xE8\xEB\x1D\xC3\x14a\x04\x96W\x80c\xEE5\xF3'\x14a\x04\xC9W\x80c\xEF\xEA\xDBm\x14a\x04\xE8W__\xFD[\x80c\xC4t\xD2\xC5\x14a\x04&W\x80c\xE3\xDEr\xA5\x14a\x04EW\x80c\xE6\xBD\x12\xCF\x14a\x04dW__\xFD[\x80c\x8B2@\xA0\x11a\0\xC2W\x80c\x8B2@\xA0\x14a\x03jW\x80c\xA6k2}\x14a\x03\xBAW\x80c\xB7T6\xBB\x14a\x03\xD9W\x80c\xBA\xBC\xC59\x14a\x03\xF8W__\xFD[\x80cpf_\x14\x14a\x03\x18W\x80c\x84V\xCBY\x14a\x037W\x80c\x8Ac\x1A\xA6\x14a\x03KW__\xFD[\x80cH\\\xC9U\x11a\x01RW\x80c^\x91gX\x11a\x01-W\x80c^\x91gX\x14a\x02\xCCW\x80cg\x9Bm\xED\x14a\x02\xDFW\x80cg\xEF:\xB8\x14a\x02\xF2W\x80cnn\x8Aj\x14a\x03\x05W__\xFD[\x80cH\\\xC9U\x14a\x02wW\x80cPux\x8B\x14a\x02\x96W\x80c\\\x97Z\xBB\x14a\x02\xB5W__\xFD[\x80c\x1F\xE9'\xCF\x11a\x01\x8DW\x80c\x1F\xE9'\xCF\x14a\x02\nW\x80c\"\xBD\\\x1C\x14a\x02)W\x80c?K\xA8:\x14a\x02YW\x80cC\x93p\xB1\x14a\x02oW__\xFD[\x80b\xF7#\x82\x14a\x01\xB2W\x80c\x0FM\x14\xE9\x14a\x01\xE4W\x80c\x1B\x87\x1C\x8D\x14a\x01\xF7W[__\xFD[4\x80\x15a\x01\xBDW__\xFD[Pa\x01\xD1a\x01\xCC6`\x04a!\xFBV[a\x05\x07V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x01\xD1a\x01\xF26`\x04a\"rV[a\x06LV[a\x01\xD1a\x02\x056`\x04a\"\x89V[a\x06\xADV[4\x80\x15a\x02\x15W__\xFD[Pa\x01\xD1a\x02$6`\x04a#'V[a\x07\x1DV[4\x80\x15a\x024W__\xFD[P`fTa\x02I\x90`\x01`\xA0\x1B\x90\x04`\xFF\x16\x81V[`@Q\x90\x15\x15\x81R` \x01a\x01\xDBV[4\x80\x15a\x02dW__\xFD[Pa\x02ma\x08\xE3V[\0[a\x01\xD1a\n\x12V[4\x80\x15a\x02\x82W__\xFD[Pa\x02ma\x02\x916`\x04a#fV[a\n\xEEV[4\x80\x15a\x02\xA1W__\xFD[Pa\x01\xD1a\x02\xB06`\x04a!\xFBV[a\x0C\xAAV[4\x80\x15a\x02\xC0W__\xFD[P`3T`\xFF\x16a\x02IV[a\x01\xD1a\x02\xDA6`\x04a#\x9DV[a\rRV[a\x01\xD1a\x02\xED6`\x04a\"\x89V[a\x0E\x03V[a\x01\xD1a\x03\x006`\x04a$\x02V[a\x0EfV[a\x01\xD1a\x03\x136`\x04a\"\x89V[a\x0F\x19V[4\x80\x15a\x03#W__\xFD[Pa\x01\xD1a\x0326`\x04a$pV[a\x0F|V[4\x80\x15a\x03BW__\xFD[Pa\x02ma\x11\0V[4\x80\x15a\x03VW__\xFD[Pa\x01\xD1a\x03e6`\x04a$\xB9V[a\x12,V[4\x80\x15a\x03uW__\xFD[P\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03T`\x01`\x01`\xA0\x1B\x03\x16[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x01\xDBV[4\x80\x15a\x03\xC5W__\xFD[Pa\x01\xD1a\x03\xD46`\x04a%\tV[a\x12\xD3V[4\x80\x15a\x03\xE4W__\xFD[Pa\x01\xD1a\x03\xF36`\x04a#'V[a\x13\nV[4\x80\x15a\x04\x03W__\xFD[Pa\x02Ia\x04\x126`\x04a%)V[`g` R_\x90\x81R`@\x90 T`\xFF\x16\x81V[4\x80\x15a\x041W__\xFD[Pa\x02ma\x04@6`\x04a%)V[a\x13\xF5V[4\x80\x15a\x04PW__\xFD[Pa\x02ma\x04_6`\x04a&,V[a\x15\tV[a\x01\xD1a\x04r6`\x04a$\x02V[a\x17zV[4\x80\x15a\x04\x82W__\xFD[P`eTa\x03\xA2\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[4\x80\x15a\x04\xA1W__\xFD[Pa\x01\xD1\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[4\x80\x15a\x04\xD4W__\xFD[P`fTa\x03\xA2\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[4\x80\x15a\x04\xF3W__\xFD[Pa\x02ma\x05\x026`\x04a&\xF1V[a\x18\x99V[_a\x05\x10a\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x058WP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x05]W`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01[`@Q\x80\x91\x03\x90\xFD[F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03a\x05\x9DW`@QcQ\x80\xDD\x83`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[32\x14a\x05\xBDW`@Qc\xFE\xB3\xD0q`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x88\x11\x15a\x05\xE6W`@Qc\x10|R{`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x06@`\x03s\x11\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x10\x193\x01_\x8B\x8B\x8B\x8B`\x01`\x01`\xA0\x1B\x03\x16\x8B\x8B\x8B`@Q` \x01a\x06+\x98\x97\x96\x95\x94\x93\x92\x91\x90a'\nV[`@Q` \x81\x83\x03\x03\x81R\x90`@R_a\x1A\xE5V[\x98\x97PPPPPPPPV[_a\x06Ua\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x06}WP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x06\x9DW`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x05TV[a\x06\xA5a\n\x12V[\x90P[\x91\x90PV[_a\x06\xB6a\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x06\xDEWP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x06\xFEW`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x05TV[a\x07\x0F\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8Aa\x0F\x19V[\x9A\x99PPPPPPPPPPV[_a\x07&a\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x07NWP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x07nW`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x05TV[F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x14a\x07\xC7W`@Q\x7F\xC6\xEAh\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x07\xCFa\x1B\xC4V[a\x08\x05W`@Q\x7F\xC8\x95\x8E\xAD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x11\x15a\x08\x88W`@Q\x7FF4i\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x83\x90R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`$\x82\x01R`D\x01a\x05TV[_a\x08\xAD`\x033\x86\x86`@Qa\x08\x9F\x92\x91\x90a'kV[`@Q\x80\x91\x03\x90 _a\x1B\xD8V[`@Q\x90\x91P\x81\x90\x7F\xABS#\x85\xBE\x8F\x10\x05\xA4\xB6\xBA\x8F\xA2\n\"E\xFA\xCB4a4\xACs\x9F\xE9\xA5\x19\x8D\xC1X\x0B\x9C\x90_\x90\xA2\x90P[\x92\x91PPV[`eT`@\x80Qc\xCB#\xBC\xB5`\xE0\x1B\x81R\x90Q_\x92`\x01`\x01`\xA0\x1B\x03\x16\x91c\xCB#\xBC\xB5\x91`\x04\x80\x83\x01\x92` \x92\x91\x90\x82\x90\x03\x01\x81\x86Z\xFA\x15\x80\x15a\t*W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\tN\x91\x90a'zV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\n\x07W_\x81`\x01`\x01`\xA0\x1B\x03\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\t\x9DW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\t\xC1\x91\x90a'zV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\n\x05W`@Qc\x079`\x07`\xE0\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x80\x84\x16`$\x83\x01R\x82\x16`D\x82\x01R`d\x01a\x05TV[P[a\n\x0Fa\x1C\x9CV[PV[_a\n\x1Ba\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\nCWP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\ncW`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x05TV[3\x80;\x15\x15\x80a\nsWP23\x14\x15[\x15a\n\x91WP3s\x11\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x11\x01[`@Q\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0``\x83\x90\x1B\x16` \x82\x01R4`4\x82\x01Ra\n\xE8\x90`\x0C\x903\x90`T\x01[`@Q` \x81\x83\x03\x03\x81R\x90`@R4a\x1A\xE5V[\x91PP\x90V[_Ta\x01\0\x90\x04`\xFF\x16\x15\x80\x80\x15a\x0B\x0CWP_T`\x01`\xFF\x90\x91\x16\x10[\x80a\x0B%WP0;\x15\x80\x15a\x0B%WP_T`\xFF\x16`\x01\x14[a\x0B\x97W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`.`$\x82\x01R\x7FInitializable: contract is alrea`D\x82\x01R\x7Fdy initialized\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x05TV[_\x80T`\xFF\x19\x16`\x01\x17\x90U\x80\x15a\x0B\xB8W_\x80Ta\xFF\0\x19\x16a\x01\0\x17\x90U[`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x160\x03a\x0CVW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`,`$\x82\x01R\x7FFunction must be called through `D\x82\x01R\x7Fdelegatecall\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x05TV[a\x0C`\x83\x83a\x1C\xEEV[\x80\x15a\x0C\xA5W_\x80Ta\xFF\0\x19\x16\x90U`@Q`\x01\x81R\x7F\x7F&\xB8?\xF9n\x1F+jh/\x138R\xF6y\x8A\t\xC4e\xDA\x95\x92\x14`\xCE\xFB8G@$\x98\x90` \x01`@Q\x80\x91\x03\x90\xA1[PPPV[_a\x0C\xB3a\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x0C\xDBWP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x0C\xFBW`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x05TV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x88\x11\x15a\r$W`@Qc\x10|R{`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x06@`\x033_\x8B\x8B\x8B\x8B`\x01`\x01`\xA0\x1B\x03\x16\x8B\x8B\x8B`@Q` \x01a\x06+\x98\x97\x96\x95\x94\x93\x92\x91\x90a'\nV[_a\r[a\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\r\x83WP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\r\xA3W`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x05TV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x86\x11\x15a\r\xCCW`@Qc\x10|R{`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\r\xF9`\x073`\x01\x89\x89\x89`\x01`\x01`\xA0\x1B\x03\x164\x8A\x8A`@Q` \x01a\n\xD3\x97\x96\x95\x94\x93\x92\x91\x90a'\x95V[\x96\x95PPPPPPV[_a\x0E\x0Ca\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x0E4WP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x0ETW`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x05TV[a\x07\x0F\x8A\x8A\x8A\x8A\x8A\x8A\x8A4\x8B\x8Ba\x1D\xDFV[_a\x0Eoa\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x0E\x97WP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x0E\xB7W`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x05TV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x87\x11\x15a\x0E\xE0W`@Qc\x10|R{`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x0F\x0E`\x073_\x8A\x8A\x8A\x8A`\x01`\x01`\xA0\x1B\x03\x164\x8B\x8B`@Q` \x01a\n\xD3\x98\x97\x96\x95\x94\x93\x92\x91\x90a'\nV[\x97\x96PPPPPPPV[_a\x0F\"a\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x0FJWP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x0FjW`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x05TV[a\x07\x0F\x8A\x8A\x8A\x8A\x8A\x8A\x8A4\x8B\x8Ba\x1E\xD7V[_a\x0F\x85a\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x0F\xADWP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x0F\xCDW`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x05TV[F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03a\x10\rW`@QcQ\x80\xDD\x83`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[32\x14a\x10-W`@Qc\xFE\xB3\xD0q`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x86\x11\x15a\x10VW`@Qc\x10|R{`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16`$\x80\x83\x01\x91\x90\x91R\x82Q\x80\x83\x03\x90\x91\x01\x81R`D\x90\x91\x01\x82R` \x80\x82\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F%\xE1`c\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x17\x90R\x91Qa\r\xF9\x92`\x03\x923s\x11\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x10\x19\x01\x92a\x06+\x92_\x92\x8D\x92\x8D\x92\x8D\x92`d\x92\x8E\x92\x01a'\xEFV[`eT`@\x80Qc\xCB#\xBC\xB5`\xE0\x1B\x81R\x90Q_\x92`\x01`\x01`\xA0\x1B\x03\x16\x91c\xCB#\xBC\xB5\x91`\x04\x80\x83\x01\x92` \x92\x91\x90\x82\x90\x03\x01\x81\x86Z\xFA\x15\x80\x15a\x11GW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x11k\x91\x90a'zV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x12$W_\x81`\x01`\x01`\xA0\x1B\x03\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x11\xBAW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x11\xDE\x91\x90a'zV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x12\"W`@Qc\x079`\x07`\xE0\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x80\x84\x16`$\x83\x01R\x82\x16`D\x82\x01R`d\x01a\x05TV[P[a\n\x0Fa \x0CV[_a\x125a\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x12]WP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x12}W`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x05TV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x87\x11\x15a\x12\xA6W`@Qc\x10|R{`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x0F\x0E`\x033`\x01\x8A\x8A\x8A`\x01`\x01`\xA0\x1B\x03\x16\x8A\x8A\x8A`@Q` \x01a\x06+\x97\x96\x95\x94\x93\x92\x91\x90a'\x95V[_\x81\x15a\x12\xE0W\x81a\x12\xE2V[H[a\x12\xED\x84`\x06a(kV[a\x12\xF9\x90a\x05xa(\x82V[a\x13\x03\x91\x90a(kV[\x93\x92PPPV[_a\x13\x13a\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x13;WP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x13[W`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x05TV[F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x14a\x13\xB4W`@Q\x7F\xC6\xEAh\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x13\x03`\x033\x85\x85\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x82\x90RP\x92Pa\x1A\xE5\x91PPV[`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x160\x03a\x14\x93W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`,`$\x82\x01R\x7FFunction must be called through `D\x82\x01R\x7Fdelegatecall\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x05TV[\x7F\xB51'hJV\x8B1s\xAE\x13\xB9\xF8\xA6\x01n$>c\xB6\xE8\xEE\x11x\xD6\xA7\x17\x85\x0B]a\x03\x80T3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x0C\xA5W`@Q\x7F#)_\x0E\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x82\x16`$\x82\x01R`D\x01a\x05TV[`eT`@\x80Qc\xCB#\xBC\xB5`\xE0\x1B\x81R\x90Q_\x92`\x01`\x01`\xA0\x1B\x03\x16\x91c\xCB#\xBC\xB5\x91`\x04\x80\x83\x01\x92` \x92\x91\x90\x82\x90\x03\x01\x81\x86Z\xFA\x15\x80\x15a\x15PW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x15t\x91\x90a'zV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x16-W_\x81`\x01`\x01`\xA0\x1B\x03\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x15\xC3W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x15\xE7\x91\x90a'zV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x16+W`@Qc\x079`\x07`\xE0\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x80\x84\x16`$\x83\x01R\x82\x16`D\x82\x01R`d\x01a\x05TV[P[\x81Q\x83Q\x14a\x16~W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\r`$\x82\x01R\x7FINVALID_INPUT\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x05TV[_[\x83Q\x81\x10\x15a\x17tW\x82\x81\x81Q\x81\x10a\x16\x9BWa\x16\x9Ba(\x95V[` \x02` \x01\x01Q`g_\x86\x84\x81Q\x81\x10a\x16\xB8Wa\x16\xB8a(\x95V[` \x02` \x01\x01Q`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP\x83\x81\x81Q\x81\x10a\x17\x07Wa\x17\x07a(\x95V[` \x02` \x01\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x7F\xD9s\x9FE\xA0\x1C\xE0\x92\xC5\xCD\xB3\xD6\x8Fc\xD6=!gk\x1Cl\x0BO\x9C\xBCk\xE4\xCFTIYZ\x84\x83\x81Q\x81\x10a\x17KWa\x17Ka(\x95V[` \x02` \x01\x01Q`@Qa\x17d\x91\x15\x15\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2`\x01\x01a\x16\x80V[PPPPV[_a\x17\x83a\x1A\x90V[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x80\x15a\x17\xABWP2_\x90\x81R`g` R`@\x90 T`\xFF\x16\x15[\x15a\x17\xCBW`@Qc\x0FQ\xEDq`\xE4\x1B\x81R2`\x04\x82\x01R`$\x01a\x05TV[F\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03a\x18\x0BW`@QcQ\x80\xDD\x83`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[32\x14a\x18+W`@Qc\xFE\xB3\xD0q`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x87\x11\x15a\x18TW`@Qc\x10|R{`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x0F\x0E`\x07s\x11\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x10\x193\x01_\x8A\x8A\x8A\x8A`\x01`\x01`\xA0\x1B\x03\x164\x8B\x8B`@Q` \x01a\n\xD3\x98\x97\x96\x95\x94\x93\x92\x91\x90a'\nV[`eT`@\x80Qc\xCB#\xBC\xB5`\xE0\x1B\x81R\x90Q_\x92`\x01`\x01`\xA0\x1B\x03\x16\x91c\xCB#\xBC\xB5\x91`\x04\x80\x83\x01\x92` \x92\x91\x90\x82\x90\x03\x01\x81\x86Z\xFA\x15\x80\x15a\x18\xE0W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x19\x04\x91\x90a'zV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x19\xBDW_\x81`\x01`\x01`\xA0\x1B\x03\x16c\x8D\xA5\xCB[`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x19SW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x19w\x91\x90a'zV[\x90P3`\x01`\x01`\xA0\x1B\x03\x82\x16\x14a\x19\xBBW`@Qc\x079`\x07`\xE0\x1B\x81R3`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x80\x84\x16`$\x83\x01R\x82\x16`D\x82\x01R`d\x01a\x05TV[P[`fT`\x01`\xA0\x1B\x90\x04`\xFF\x16\x15\x15\x82\x15\x15\x03a\x1A\x1CW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0B`$\x82\x01R\x7FALREADY_SET\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x05TV[`f\x80T\x83\x15\x15`\x01`\xA0\x1B\x02\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x17\x90U`@Q\x7F\x16C[E\xF7H G\xF89\xA6\xA1\x9D)\x14Bbr\0\xF5,\xAD(\x03\xC5\x95\x15\r\rD\x0E\xB3\x90a\x1A\x84\x90\x84\x15\x15\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA1PPV[`3T`\xFF\x16\x15a\x1A\xE3W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x10`$\x82\x01R\x7FPausable: paused\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x05TV[V[_\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83Q\x11\x15a\x1BmW\x82Q`@Q\x7FF4i\x1B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x91\x90\x91R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`$\x82\x01R`D\x01a\x05TV[_a\x1B\x81\x86\x86\x86\x80Q\x90` \x01 \x86a\x1B\xD8V[\x90P\x80\x7F\xFFd\x90_s\xA6\x7F\xB5\x94\xE0\xF9@\xA8\x07Z\x86\r\xB4\x89\xAD\x99\x1E\x03/H\xC8\x11#\xEBR\xD6\x0B\x85`@Qa\x1B\xB3\x91\x90a(\xA9V[`@Q\x80\x91\x03\x90\xA2\x95\x94PPPPPV[_32\x14\x80\x15a\x1B\xD3WP3;\x15[\x90P\x90V[`eT_\x90`\x01`\x01`\xA0\x1B\x03\x16c\x8D\xB5\x99;\x83\x87s\x11\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x11\x88\x01`@Q\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\xE0\x86\x90\x1B\x16\x81R`\xFF\x90\x92\x16`\x04\x83\x01R`\x01`\x01`\xA0\x1B\x03\x16`$\x82\x01R`D\x81\x01\x87\x90R`d\x01` `@Q\x80\x83\x03\x81\x85\x88Z\xF1\x15\x80\x15a\x1CnW=__>=_\xFD[PPPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1C\x93\x91\x90a(\xDEV[\x95\x94PPPPPV[a\x1C\xA4a IV[`3\x80T`\xFF\x19\x16\x90U\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA3[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01`@Q\x80\x91\x03\x90\xA1V[_Ta\x01\0\x90\x04`\xFF\x16a\x1DjW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7FInitializable: contract is not i`D\x82\x01R\x7Fnitializing\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x05TV[`e\x80T`\x01`\x01`\xA0\x1B\x03\x80\x85\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x92\x16\x91\x90\x91\x17\x90\x91U`f\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x91\x83\x16\x91\x90\x91\x17\x90Ua\x1D\xDBa \x9BV[PPV[_\x83a\x1D\xEB\x86\x88a(kV[a\x1D\xF5\x8C\x8Ca(\x82V[a\x1D\xFF\x91\x90a(\x82V[\x81\x10\x15a\x1EaWa\x1E\x10\x86\x88a(kV[a\x1E\x1A\x8C\x8Ca(\x82V[a\x1E$\x91\x90a(\x82V[`@Q\x7Fp@\xB5\x8C\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x91\x90\x91R`$\x81\x01\x82\x90R`D\x01a\x05TV[`\x01`\x01`\xA0\x1B\x03\x89\x16;\x15a\x1E\x8BWs\x11\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x11\x89\x01\x98P[`\x01`\x01`\xA0\x1B\x03\x88\x16;\x15a\x1E\xB5Ws\x11\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x11\x88\x01\x97P[a\x1E\xC7\x8C\x8C\x8C\x8C\x8C\x8C\x8C\x8C\x8C\x8Ca\x1E\xD7V[\x9C\x9BPPPPPPPPPPPPV[_\x85`\x01\x14\x80a\x1E\xE7WP\x84`\x01\x14[\x15a\x1F4W3\x8B\x8B\x86\x8C\x8C\x8C\x8C\x8C\x8B\x8B`@Q\x7F\x07\xC2f\xE3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\x05T\x9B\x9A\x99\x98\x97\x96\x95\x94\x93\x92\x91\x90a(\xF5V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x86\x11\x15a\x1F]W`@Qc\x10|R{`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a\x1Fh\x83Ha\x12\xD3V[\x90P\x80\x8A\x10\x15a\x1F\xAEW`@Q\x7F\xFA\xDF#\x8A\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x82\x90R`$\x81\x01\x8B\x90R`D\x01a\x05TV[a\x1E\xC7`\t3`\x01`\x01`\xA0\x1B\x03\x8F\x16\x8E\x89\x8F\x8F`\x01`\x01`\xA0\x1B\x03\x16\x8F`\x01`\x01`\xA0\x1B\x03\x16\x8F\x8F\x8E\x8E\x90P\x8F\x8F`@Q` \x01a\x1F\xF7\x9B\x9A\x99\x98\x97\x96\x95\x94\x93\x92\x91\x90a)\x8CV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x88a\x1A\xE5V[a \x14a\x1A\x90V[`3\x80T`\xFF\x19\x16`\x01\x17\x90U\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2Xa\x1C\xD13\x90V[`3T`\xFF\x16a\x1A\xE3W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x14`$\x82\x01R\x7FPausable: not paused\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x05TV[_Ta\x01\0\x90\x04`\xFF\x16a!\x17W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7FInitializable: contract is not i`D\x82\x01R\x7Fnitializing\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x05TV[a\x1A\xE3_Ta\x01\0\x90\x04`\xFF\x16a!\x96W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7FInitializable: contract is not i`D\x82\x01R\x7Fnitializing\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x05TV[`3\x80T`\xFF\x19\x16\x90UV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\n\x0FW__\xFD[__\x83`\x1F\x84\x01\x12a!\xC6W__\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a!\xDDW__\xFD[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15a!\xF4W__\xFD[\x92P\x92\x90PV[_______`\xC0\x88\x8A\x03\x12\x15a\"\x11W__\xFD[\x875\x96P` \x88\x015\x95P`@\x88\x015\x94P``\x88\x015a\"1\x81a!\xA2V[\x93P`\x80\x88\x015\x92P`\xA0\x88\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\"SW__\xFD[a\"_\x8A\x82\x8B\x01a!\xB6V[\x98\x9B\x97\x9AP\x95\x98P\x93\x96\x92\x95\x92\x93PPPV[_` \x82\x84\x03\x12\x15a\"\x82W__\xFD[P5\x91\x90PV[_________a\x01\0\x8A\x8C\x03\x12\x15a\"\xA2W__\xFD[\x895a\"\xAD\x81a!\xA2V[\x98P` \x8A\x015\x97P`@\x8A\x015\x96P``\x8A\x015a\"\xCB\x81a!\xA2V[\x95P`\x80\x8A\x015a\"\xDB\x81a!\xA2V[\x94P`\xA0\x8A\x015\x93P`\xC0\x8A\x015\x92P`\xE0\x8A\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a#\x04W__\xFD[a#\x10\x8C\x82\x8D\x01a!\xB6V[\x91P\x80\x93PP\x80\x91PP\x92\x95\x98P\x92\x95\x98P\x92\x95\x98V[__` \x83\x85\x03\x12\x15a#8W__\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a#NW__\xFD[a#Z\x85\x82\x86\x01a!\xB6V[\x90\x96\x90\x95P\x93PPPPV[__`@\x83\x85\x03\x12\x15a#wW__\xFD[\x825a#\x82\x81a!\xA2V[\x91P` \x83\x015a#\x92\x81a!\xA2V[\x80\x91PP\x92P\x92\x90PV[_____`\x80\x86\x88\x03\x12\x15a#\xB1W__\xFD[\x855\x94P` \x86\x015\x93P`@\x86\x015a#\xCA\x81a!\xA2V[\x92P``\x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a#\xE5W__\xFD[a#\xF1\x88\x82\x89\x01a!\xB6V[\x96\x99\x95\x98P\x93\x96P\x92\x94\x93\x92PPPV[______`\xA0\x87\x89\x03\x12\x15a$\x17W__\xFD[\x865\x95P` \x87\x015\x94P`@\x87\x015\x93P``\x87\x015a$7\x81a!\xA2V[\x92P`\x80\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a$RW__\xFD[a$^\x89\x82\x8A\x01a!\xB6V[\x97\x9A\x96\x99P\x94\x97P\x92\x95\x93\x94\x92PPPV[_____`\xA0\x86\x88\x03\x12\x15a$\x84W__\xFD[\x855\x94P` \x86\x015\x93P`@\x86\x015\x92P``\x86\x015\x91P`\x80\x86\x015a$\xAB\x81a!\xA2V[\x80\x91PP\x92\x95P\x92\x95\x90\x93PV[______`\xA0\x87\x89\x03\x12\x15a$\xCEW__\xFD[\x865\x95P` \x87\x015\x94P`@\x87\x015a$\xE7\x81a!\xA2V[\x93P``\x87\x015\x92P`\x80\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a$RW__\xFD[__`@\x83\x85\x03\x12\x15a%\x1AW__\xFD[PP\x805\x92` \x90\x91\x015\x91PV[_` \x82\x84\x03\x12\x15a%9W__\xFD[\x815a\x13\x03\x81a!\xA2V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x82\x82\x10\x17\x15a%\x81Wa%\x81a%DV[`@R\x91\x90PV[_g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a%\xA2Wa%\xA2a%DV[P`\x05\x1B` \x01\x90V[\x805\x80\x15\x15\x81\x14a\x06\xA8W__\xFD[_\x82`\x1F\x83\x01\x12a%\xCAW__\xFD[\x815a%\xDDa%\xD8\x82a%\x89V[a%XV[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x86\x01\x01\x92P\x85\x83\x11\x15a%\xFEW__\xFD[` \x85\x01[\x83\x81\x10\x15a&\"Wa&\x14\x81a%\xACV[\x83R` \x92\x83\x01\x92\x01a&\x03V[P\x95\x94PPPPPV[__`@\x83\x85\x03\x12\x15a&=W__\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a&SW__\xFD[\x83\x01`\x1F\x81\x01\x85\x13a&cW__\xFD[\x805a&qa%\xD8\x82a%\x89V[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x85\x01\x01\x92P\x87\x83\x11\x15a&\x92W__\xFD[` \x84\x01\x93P[\x82\x84\x10\x15a&\xBDW\x835a&\xAC\x81a!\xA2V[\x82R` \x93\x84\x01\x93\x90\x91\x01\x90a&\x99V[\x94PPPP` \x83\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a&\xDBW__\xFD[a&\xE7\x85\x82\x86\x01a%\xBBV[\x91PP\x92P\x92\x90PV[_` \x82\x84\x03\x12\x15a'\x01W__\xFD[a\x13\x03\x82a%\xACV[\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x89`\xF8\x1B\x16\x81R\x87`\x01\x82\x01R\x86`!\x82\x01R\x85`A\x82\x01R\x84`a\x82\x01R\x83`\x81\x82\x01R\x81\x83`\xA1\x83\x017_\x91\x01`\xA1\x01\x90\x81R\x97\x96PPPPPPPV[\x81\x83\x827_\x91\x01\x90\x81R\x91\x90PV[_` \x82\x84\x03\x12\x15a'\x8AW__\xFD[\x81Qa\x13\x03\x81a!\xA2V[\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x88`\xF8\x1B\x16\x81R\x86`\x01\x82\x01R\x85`!\x82\x01R\x84`A\x82\x01R\x83`a\x82\x01R\x81\x83`\x81\x83\x017_\x91\x01`\x81\x01\x90\x81R\x96\x95PPPPPPV[\x7F\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x88`\xF8\x1B\x16\x81R\x86`\x01\x82\x01R\x85`!\x82\x01R\x84`A\x82\x01R\x83`a\x82\x01R\x82`\x81\x82\x01R_\x82Q\x80` \x85\x01`\xA1\x85\x01^_\x92\x01`\xA1\x01\x91\x82RP\x97\x96PPPPPPPV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x08\xDDWa\x08\xDDa(WV[\x80\x82\x01\x80\x82\x11\x15a\x08\xDDWa\x08\xDDa(WV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[` \x81R_\x82Q\x80` \x84\x01R\x80` \x85\x01`@\x85\x01^_`@\x82\x85\x01\x01R`@`\x1F\x19`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x92\x91PPV[_` \x82\x84\x03\x12\x15a(\xEEW__\xFD[PQ\x91\x90PV[`\x01`\x01`\xA0\x1B\x03\x8C\x16\x81R`\x01`\x01`\xA0\x1B\x03\x8B\x16` \x82\x01R\x89`@\x82\x01R\x88``\x82\x01R\x87`\x80\x82\x01R`\x01`\x01`\xA0\x1B\x03\x87\x16`\xA0\x82\x01R`\x01`\x01`\xA0\x1B\x03\x86\x16`\xC0\x82\x01R\x84`\xE0\x82\x01R\x83a\x01\0\x82\x01Ra\x01@a\x01 \x82\x01R\x81a\x01@\x82\x01R\x81\x83a\x01`\x83\x017_\x81\x83\x01a\x01`\x90\x81\x01\x91\x90\x91R`\x1F\x90\x92\x01`\x1F\x19\x16\x01\x01\x9A\x99PPPPPPPPPPV[\x8B\x81R\x8A` \x82\x01R\x89`@\x82\x01R\x88``\x82\x01R\x87`\x80\x82\x01R\x86`\xA0\x82\x01R\x85`\xC0\x82\x01R\x84`\xE0\x82\x01R\x83a\x01\0\x82\x01R\x81\x83a\x01 \x83\x017_\x91\x01a\x01 \x01\x90\x81R\x9A\x99PPPPPPPPPPV\xFE\xA2dipfsX\"\x12 \xAE.\x9B\x8A\xB3Q=|+\xCEA\xD0\xCD~s\x87Q4\n\x0400\xEE\x88\t\x15\xBE\xC6\xF3\xE5\x12\x07dsolcC\0\x08\x1C\x003",
    );
    /**Custom error with signature `DataTooLarge(uint256,uint256)` and selector `0x4634691b`.
```solidity
error DataTooLarge(uint256 dataLength, uint256 maxDataLength);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DataTooLarge {
        #[allow(missing_docs)]
        pub dataLength: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxDataLength: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<DataTooLarge> for UnderlyingRustTuple<'_> {
            fn from(value: DataTooLarge) -> Self {
                (value.dataLength, value.maxDataLength)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for DataTooLarge {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    dataLength: tuple.0,
                    maxDataLength: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for DataTooLarge {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DataTooLarge(uint256,uint256)";
            const SELECTOR: [u8; 4] = [70u8, 52u8, 105u8, 27u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.dataLength),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxDataLength),
                )
            }
        }
    };
    /**Custom error with signature `GasLimitTooLarge()` and selector `0x107c527b`.
```solidity
error GasLimitTooLarge();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct GasLimitTooLarge {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<GasLimitTooLarge> for UnderlyingRustTuple<'_> {
            fn from(value: GasLimitTooLarge) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for GasLimitTooLarge {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for GasLimitTooLarge {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "GasLimitTooLarge()";
            const SELECTOR: [u8; 4] = [16u8, 124u8, 82u8, 123u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InsufficientSubmissionCost(uint256,uint256)` and selector `0xfadf238a`.
```solidity
error InsufficientSubmissionCost(uint256 expected, uint256 actual);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientSubmissionCost {
        #[allow(missing_docs)]
        pub expected: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub actual: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientSubmissionCost>
        for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientSubmissionCost) -> Self {
                (value.expected, value.actual)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InsufficientSubmissionCost {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    expected: tuple.0,
                    actual: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientSubmissionCost {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientSubmissionCost(uint256,uint256)";
            const SELECTOR: [u8; 4] = [250u8, 223u8, 35u8, 138u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expected),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.actual),
                )
            }
        }
    };
    /**Custom error with signature `InsufficientValue(uint256,uint256)` and selector `0x7040b58c`.
```solidity
error InsufficientValue(uint256 expected, uint256 actual);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientValue {
        #[allow(missing_docs)]
        pub expected: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub actual: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientValue> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientValue) -> Self {
                (value.expected, value.actual)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientValue {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    expected: tuple.0,
                    actual: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientValue {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientValue(uint256,uint256)";
            const SELECTOR: [u8; 4] = [112u8, 64u8, 181u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expected),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.actual),
                )
            }
        }
    };
    /**Custom error with signature `L1Forked()` and selector `0xc6ea6803`.
```solidity
error L1Forked();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct L1Forked {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<L1Forked> for UnderlyingRustTuple<'_> {
            fn from(value: L1Forked) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for L1Forked {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for L1Forked {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "L1Forked()";
            const SELECTOR: [u8; 4] = [198u8, 234u8, 104u8, 3u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `NotAllowedOrigin(address)` and selector `0xf51ed710`.
```solidity
error NotAllowedOrigin(address origin);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotAllowedOrigin {
        #[allow(missing_docs)]
        pub origin: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotAllowedOrigin> for UnderlyingRustTuple<'_> {
            fn from(value: NotAllowedOrigin) -> Self {
                (value.origin,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotAllowedOrigin {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { origin: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotAllowedOrigin {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotAllowedOrigin(address)";
            const SELECTOR: [u8; 4] = [245u8, 30u8, 215u8, 16u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.origin,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `NotCodelessOrigin()` and selector `0xc8958ead`.
```solidity
error NotCodelessOrigin();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotCodelessOrigin {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotCodelessOrigin> for UnderlyingRustTuple<'_> {
            fn from(value: NotCodelessOrigin) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotCodelessOrigin {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotCodelessOrigin {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotCodelessOrigin()";
            const SELECTOR: [u8; 4] = [200u8, 149u8, 142u8, 173u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `NotForked()` and selector `0xa301bb06`.
```solidity
error NotForked();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotForked {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotForked> for UnderlyingRustTuple<'_> {
            fn from(value: NotForked) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotForked {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotForked {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotForked()";
            const SELECTOR: [u8; 4] = [163u8, 1u8, 187u8, 6u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `NotOrigin()` and selector `0xfeb3d071`.
```solidity
error NotOrigin();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotOrigin {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotOrigin> for UnderlyingRustTuple<'_> {
            fn from(value: NotOrigin) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotOrigin {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotOrigin {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotOrigin()";
            const SELECTOR: [u8; 4] = [254u8, 179u8, 208u8, 113u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `NotOwner(address,address)` and selector `0x23295f0e`.
```solidity
error NotOwner(address sender, address owner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotOwner {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotOwner> for UnderlyingRustTuple<'_> {
            fn from(value: NotOwner) -> Self {
                (value.sender, value.owner)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    sender: tuple.0,
                    owner: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotOwner(address,address)";
            const SELECTOR: [u8; 4] = [35u8, 41u8, 95u8, 14u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `NotRollupOrOwner(address,address,address)` and selector `0x07396007`.
```solidity
error NotRollupOrOwner(address sender, address rollup, address owner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotRollupOrOwner {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub rollup: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotRollupOrOwner> for UnderlyingRustTuple<'_> {
            fn from(value: NotRollupOrOwner) -> Self {
                (value.sender, value.rollup, value.owner)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotRollupOrOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    sender: tuple.0,
                    rollup: tuple.1,
                    owner: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotRollupOrOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotRollupOrOwner(address,address,address)";
            const SELECTOR: [u8; 4] = [7u8, 57u8, 96u8, 7u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.rollup,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `RetryableData(address,address,uint256,uint256,uint256,address,address,uint256,uint256,bytes)` and selector `0x07c266e3`.
```solidity
error RetryableData(address from, address to, uint256 l2CallValue, uint256 deposit, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, bytes data);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RetryableData {
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub l2CallValue: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub deposit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxSubmissionCost: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub excessFeeRefundAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub callValueRefundAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub gasLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Bytes,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Bytes,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<RetryableData> for UnderlyingRustTuple<'_> {
            fn from(value: RetryableData) -> Self {
                (
                    value.from,
                    value.to,
                    value.l2CallValue,
                    value.deposit,
                    value.maxSubmissionCost,
                    value.excessFeeRefundAddress,
                    value.callValueRefundAddress,
                    value.gasLimit,
                    value.maxFeePerGas,
                    value.data,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for RetryableData {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    from: tuple.0,
                    to: tuple.1,
                    l2CallValue: tuple.2,
                    deposit: tuple.3,
                    maxSubmissionCost: tuple.4,
                    excessFeeRefundAddress: tuple.5,
                    callValueRefundAddress: tuple.6,
                    gasLimit: tuple.7,
                    maxFeePerGas: tuple.8,
                    data: tuple.9,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for RetryableData {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "RetryableData(address,address,uint256,uint256,uint256,address,address,uint256,uint256,bytes)";
            const SELECTOR: [u8; 4] = [7u8, 194u8, 102u8, 227u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.l2CallValue),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.deposit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxSubmissionCost),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.excessFeeRefundAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callValueRefundAddress,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.gasLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxFeePerGas),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
        }
    };
    /**Event with signature `AllowListAddressSet(address,bool)` and selector `0xd9739f45a01ce092c5cdb3d68f63d63d21676b1c6c0b4f9cbc6be4cf5449595a`.
```solidity
event AllowListAddressSet(address indexed user, bool val);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct AllowListAddressSet {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub val: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for AllowListAddressSet {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "AllowListAddressSet(address,bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                217u8,
                115u8,
                159u8,
                69u8,
                160u8,
                28u8,
                224u8,
                146u8,
                197u8,
                205u8,
                179u8,
                214u8,
                143u8,
                99u8,
                214u8,
                61u8,
                33u8,
                103u8,
                107u8,
                28u8,
                108u8,
                11u8,
                79u8,
                156u8,
                188u8,
                107u8,
                228u8,
                207u8,
                84u8,
                73u8,
                89u8,
                90u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    user: topics.1,
                    val: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.val,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.user.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.user,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for AllowListAddressSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&AllowListAddressSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &AllowListAddressSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `AllowListEnabledUpdated(bool)` and selector `0x16435b45f7482047f839a6a19d291442627200f52cad2803c595150d0d440eb3`.
```solidity
event AllowListEnabledUpdated(bool isEnabled);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct AllowListEnabledUpdated {
        #[allow(missing_docs)]
        pub isEnabled: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for AllowListEnabledUpdated {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "AllowListEnabledUpdated(bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                22u8,
                67u8,
                91u8,
                69u8,
                247u8,
                72u8,
                32u8,
                71u8,
                248u8,
                57u8,
                166u8,
                161u8,
                157u8,
                41u8,
                20u8,
                66u8,
                98u8,
                114u8,
                0u8,
                245u8,
                44u8,
                173u8,
                40u8,
                3u8,
                197u8,
                149u8,
                21u8,
                13u8,
                13u8,
                68u8,
                14u8,
                179u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { isEnabled: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.isEnabled,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for AllowListEnabledUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&AllowListEnabledUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &AllowListEnabledUpdated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `InboxMessageDelivered(uint256,bytes)` and selector `0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b`.
```solidity
event InboxMessageDelivered(uint256 indexed messageNum, bytes data);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct InboxMessageDelivered {
        #[allow(missing_docs)]
        pub messageNum: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for InboxMessageDelivered {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "InboxMessageDelivered(uint256,bytes)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                255u8,
                100u8,
                144u8,
                95u8,
                115u8,
                166u8,
                127u8,
                181u8,
                148u8,
                224u8,
                249u8,
                64u8,
                168u8,
                7u8,
                90u8,
                134u8,
                13u8,
                180u8,
                137u8,
                173u8,
                153u8,
                30u8,
                3u8,
                47u8,
                72u8,
                200u8,
                17u8,
                35u8,
                235u8,
                82u8,
                214u8,
                11u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    messageNum: topics.1,
                    data: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.messageNum.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.messageNum);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for InboxMessageDelivered {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&InboxMessageDelivered> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &InboxMessageDelivered) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `InboxMessageDeliveredFromOrigin(uint256)` and selector `0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c`.
```solidity
event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct InboxMessageDeliveredFromOrigin {
        #[allow(missing_docs)]
        pub messageNum: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for InboxMessageDeliveredFromOrigin {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "InboxMessageDeliveredFromOrigin(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                171u8,
                83u8,
                35u8,
                133u8,
                190u8,
                143u8,
                16u8,
                5u8,
                164u8,
                182u8,
                186u8,
                143u8,
                162u8,
                10u8,
                34u8,
                69u8,
                250u8,
                203u8,
                52u8,
                97u8,
                52u8,
                172u8,
                115u8,
                159u8,
                233u8,
                165u8,
                25u8,
                141u8,
                193u8,
                88u8,
                11u8,
                156u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { messageNum: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.messageNum.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.messageNum);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for InboxMessageDeliveredFromOrigin {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&InboxMessageDeliveredFromOrigin>
        for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &InboxMessageDeliveredFromOrigin,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Initialized(uint8)` and selector `0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498`.
```solidity
event Initialized(uint8 version);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Initialized {
        #[allow(missing_docs)]
        pub version: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialized {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialized(uint8)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                127u8,
                38u8,
                184u8,
                63u8,
                249u8,
                110u8,
                31u8,
                43u8,
                106u8,
                104u8,
                47u8,
                19u8,
                56u8,
                82u8,
                246u8,
                121u8,
                138u8,
                9u8,
                196u8,
                101u8,
                218u8,
                149u8,
                146u8,
                20u8,
                96u8,
                206u8,
                251u8,
                56u8,
                71u8,
                64u8,
                36u8,
                152u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { version: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.version),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Paused(address)` and selector `0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258`.
```solidity
event Paused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Paused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Paused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Paused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                98u8,
                231u8,
                140u8,
                234u8,
                1u8,
                190u8,
                227u8,
                32u8,
                205u8,
                78u8,
                66u8,
                2u8,
                112u8,
                181u8,
                234u8,
                116u8,
                0u8,
                13u8,
                17u8,
                176u8,
                201u8,
                247u8,
                71u8,
                84u8,
                235u8,
                219u8,
                252u8,
                84u8,
                75u8,
                5u8,
                162u8,
                88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Paused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Paused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Paused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Unpaused(address)` and selector `0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa`.
```solidity
event Unpaused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Unpaused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Unpaused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Unpaused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                93u8,
                185u8,
                238u8,
                10u8,
                73u8,
                91u8,
                242u8,
                230u8,
                255u8,
                156u8,
                145u8,
                167u8,
                131u8,
                76u8,
                27u8,
                164u8,
                253u8,
                210u8,
                68u8,
                165u8,
                232u8,
                170u8,
                78u8,
                83u8,
                123u8,
                211u8,
                138u8,
                234u8,
                228u8,
                176u8,
                115u8,
                170u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Unpaused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Unpaused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Unpaused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(uint256 _maxDataSize);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub _maxDataSize: alloy::sol_types::private::primitives::aliases::U256,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value._maxDataSize,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _maxDataSize: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._maxDataSize),
                )
            }
        }
    };
    /**Function with signature `allowListEnabled()` and selector `0x22bd5c1c`.
```solidity
function allowListEnabled() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allowListEnabledCall {}
    ///Container type for the return parameters of the [`allowListEnabled()`](allowListEnabledCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct allowListEnabledReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowListEnabledCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: allowListEnabledCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for allowListEnabledCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allowListEnabledReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: allowListEnabledReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for allowListEnabledReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for allowListEnabledCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = allowListEnabledReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "allowListEnabled()";
            const SELECTOR: [u8; 4] = [34u8, 189u8, 92u8, 28u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `bridge()` and selector `0xe78cea92`.
```solidity
function bridge() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeCall {}
    ///Container type for the return parameters of the [`bridge()`](bridgeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bridgeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridge()";
            const SELECTOR: [u8; 4] = [231u8, 140u8, 234u8, 146u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `calculateRetryableSubmissionFee(uint256,uint256)` and selector `0xa66b327d`.
```solidity
function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct calculateRetryableSubmissionFeeCall {
        #[allow(missing_docs)]
        pub dataLength: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub baseFee: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`calculateRetryableSubmissionFee(uint256,uint256)`](calculateRetryableSubmissionFeeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct calculateRetryableSubmissionFeeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calculateRetryableSubmissionFeeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: calculateRetryableSubmissionFeeCall) -> Self {
                    (value.dataLength, value.baseFee)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for calculateRetryableSubmissionFeeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        dataLength: tuple.0,
                        baseFee: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calculateRetryableSubmissionFeeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: calculateRetryableSubmissionFeeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for calculateRetryableSubmissionFeeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for calculateRetryableSubmissionFeeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = calculateRetryableSubmissionFeeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "calculateRetryableSubmissionFee(uint256,uint256)";
            const SELECTOR: [u8; 4] = [166u8, 107u8, 50u8, 125u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.dataLength),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.baseFee),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `createRetryableTicket(address,uint256,uint256,address,address,uint256,uint256,bytes)` and selector `0x679b6ded`.
```solidity
function createRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, bytes memory data) external payable returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createRetryableTicketCall {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub l2CallValue: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxSubmissionCost: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub excessFeeRefundAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub callValueRefundAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub gasLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`createRetryableTicket(address,uint256,uint256,address,address,uint256,uint256,bytes)`](createRetryableTicketCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createRetryableTicketReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createRetryableTicketCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: createRetryableTicketCall) -> Self {
                    (
                        value.to,
                        value.l2CallValue,
                        value.maxSubmissionCost,
                        value.excessFeeRefundAddress,
                        value.callValueRefundAddress,
                        value.gasLimit,
                        value.maxFeePerGas,
                        value.data,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createRetryableTicketCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        l2CallValue: tuple.1,
                        maxSubmissionCost: tuple.2,
                        excessFeeRefundAddress: tuple.3,
                        callValueRefundAddress: tuple.4,
                        gasLimit: tuple.5,
                        maxFeePerGas: tuple.6,
                        data: tuple.7,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createRetryableTicketReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: createRetryableTicketReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createRetryableTicketReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for createRetryableTicketCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = createRetryableTicketReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "createRetryableTicket(address,uint256,uint256,address,address,uint256,uint256,bytes)";
            const SELECTOR: [u8; 4] = [103u8, 155u8, 109u8, 237u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.l2CallValue),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxSubmissionCost),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.excessFeeRefundAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callValueRefundAddress,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.gasLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxFeePerGas),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `createRetryableTicketNoRefundAliasRewrite(address,uint256,uint256,address,address,uint256,uint256,bytes)` and selector `0x1b871c8d`.
```solidity
function createRetryableTicketNoRefundAliasRewrite(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, bytes memory data) external payable returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createRetryableTicketNoRefundAliasRewriteCall {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub l2CallValue: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxSubmissionCost: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub excessFeeRefundAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub callValueRefundAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub gasLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`createRetryableTicketNoRefundAliasRewrite(address,uint256,uint256,address,address,uint256,uint256,bytes)`](createRetryableTicketNoRefundAliasRewriteCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createRetryableTicketNoRefundAliasRewriteReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createRetryableTicketNoRefundAliasRewriteCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: createRetryableTicketNoRefundAliasRewriteCall) -> Self {
                    (
                        value.to,
                        value.l2CallValue,
                        value.maxSubmissionCost,
                        value.excessFeeRefundAddress,
                        value.callValueRefundAddress,
                        value.gasLimit,
                        value.maxFeePerGas,
                        value.data,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createRetryableTicketNoRefundAliasRewriteCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        l2CallValue: tuple.1,
                        maxSubmissionCost: tuple.2,
                        excessFeeRefundAddress: tuple.3,
                        callValueRefundAddress: tuple.4,
                        gasLimit: tuple.5,
                        maxFeePerGas: tuple.6,
                        data: tuple.7,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createRetryableTicketNoRefundAliasRewriteReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: createRetryableTicketNoRefundAliasRewriteReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createRetryableTicketNoRefundAliasRewriteReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for createRetryableTicketNoRefundAliasRewriteCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = createRetryableTicketNoRefundAliasRewriteReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "createRetryableTicketNoRefundAliasRewrite(address,uint256,uint256,address,address,uint256,uint256,bytes)";
            const SELECTOR: [u8; 4] = [27u8, 135u8, 28u8, 141u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.l2CallValue),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxSubmissionCost),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.excessFeeRefundAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callValueRefundAddress,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.gasLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxFeePerGas),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `depositEth(uint256)` and selector `0x0f4d14e9`.
```solidity
function depositEth(uint256) external payable returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositEth_0Call {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`depositEth(uint256)`](depositEth_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositEth_0Return {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositEth_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: depositEth_0Call) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for depositEth_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositEth_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: depositEth_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for depositEth_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for depositEth_0Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = depositEth_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "depositEth(uint256)";
            const SELECTOR: [u8; 4] = [15u8, 77u8, 20u8, 233u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `depositEth()` and selector `0x439370b1`.
```solidity
function depositEth() external payable returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositEth_1Call {}
    ///Container type for the return parameters of the [`depositEth()`](depositEth_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositEth_1Return {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositEth_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: depositEth_1Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for depositEth_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositEth_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: depositEth_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for depositEth_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for depositEth_1Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = depositEth_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "depositEth()";
            const SELECTOR: [u8; 4] = [67u8, 147u8, 112u8, 177u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getProxyAdmin()` and selector `0x8b3240a0`.
```solidity
function getProxyAdmin() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getProxyAdminCall {}
    ///Container type for the return parameters of the [`getProxyAdmin()`](getProxyAdminCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getProxyAdminReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getProxyAdminCall> for UnderlyingRustTuple<'_> {
                fn from(value: getProxyAdminCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getProxyAdminCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getProxyAdminReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getProxyAdminReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getProxyAdminReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getProxyAdminCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getProxyAdminReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getProxyAdmin()";
            const SELECTOR: [u8; 4] = [139u8, 50u8, 64u8, 160u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `initialize(address,address)` and selector `0x485cc955`.
```solidity
function initialize(address _bridge, address _sequencerInbox) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeCall {
        #[allow(missing_docs)]
        pub _bridge: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _sequencerInbox: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`initialize(address,address)`](initializeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeCall> for UnderlyingRustTuple<'_> {
                fn from(value: initializeCall) -> Self {
                    (value._bridge, value._sequencerInbox)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _bridge: tuple.0,
                        _sequencerInbox: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: initializeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initialize(address,address)";
            const SELECTOR: [u8; 4] = [72u8, 92u8, 201u8, 85u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._bridge,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._sequencerInbox,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isAllowed(address)` and selector `0xbabcc539`.
```solidity
function isAllowed(address) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isAllowedCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`isAllowed(address)`](isAllowedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isAllowedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isAllowedCall> for UnderlyingRustTuple<'_> {
                fn from(value: isAllowedCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isAllowedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isAllowedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isAllowedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isAllowedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isAllowedCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isAllowedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isAllowed(address)";
            const SELECTOR: [u8; 4] = [186u8, 188u8, 197u8, 57u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `maxDataSize()` and selector `0xe8eb1dc3`.
```solidity
function maxDataSize() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct maxDataSizeCall {}
    ///Container type for the return parameters of the [`maxDataSize()`](maxDataSizeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct maxDataSizeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<maxDataSizeCall> for UnderlyingRustTuple<'_> {
                fn from(value: maxDataSizeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for maxDataSizeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<maxDataSizeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: maxDataSizeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for maxDataSizeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for maxDataSizeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = maxDataSizeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "maxDataSize()";
            const SELECTOR: [u8; 4] = [232u8, 235u8, 29u8, 195u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `pause()` and selector `0x8456cb59`.
```solidity
function pause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseCall {}
    ///Container type for the return parameters of the [`pause()`](pauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pause()";
            const SELECTOR: [u8; 4] = [132u8, 86u8, 203u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `paused()` and selector `0x5c975abb`.
```solidity
function paused() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedCall {}
    ///Container type for the return parameters of the [`paused()`](pausedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedCall> for UnderlyingRustTuple<'_> {
                fn from(value: pausedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pausedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pausedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pausedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "paused()";
            const SELECTOR: [u8; 4] = [92u8, 151u8, 90u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `postUpgradeInit(address)` and selector `0xc474d2c5`.
```solidity
function postUpgradeInit(address) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct postUpgradeInitCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`postUpgradeInit(address)`](postUpgradeInitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct postUpgradeInitReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<postUpgradeInitCall> for UnderlyingRustTuple<'_> {
                fn from(value: postUpgradeInitCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for postUpgradeInitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<postUpgradeInitReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: postUpgradeInitReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for postUpgradeInitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for postUpgradeInitCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = postUpgradeInitReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "postUpgradeInit(address)";
            const SELECTOR: [u8; 4] = [196u8, 116u8, 210u8, 197u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `sendContractTransaction(uint256,uint256,address,uint256,bytes)` and selector `0x8a631aa6`.
```solidity
function sendContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, uint256 value, bytes memory data) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sendContractTransactionCall {
        #[allow(missing_docs)]
        pub gasLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`sendContractTransaction(uint256,uint256,address,uint256,bytes)`](sendContractTransactionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sendContractTransactionReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sendContractTransactionCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: sendContractTransactionCall) -> Self {
                    (
                        value.gasLimit,
                        value.maxFeePerGas,
                        value.to,
                        value.value,
                        value.data,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sendContractTransactionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        gasLimit: tuple.0,
                        maxFeePerGas: tuple.1,
                        to: tuple.2,
                        value: tuple.3,
                        data: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sendContractTransactionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: sendContractTransactionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sendContractTransactionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sendContractTransactionCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = sendContractTransactionReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sendContractTransaction(uint256,uint256,address,uint256,bytes)";
            const SELECTOR: [u8; 4] = [138u8, 99u8, 26u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.gasLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxFeePerGas),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `sendL1FundedContractTransaction(uint256,uint256,address,bytes)` and selector `0x5e916758`.
```solidity
function sendL1FundedContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, bytes memory data) external payable returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sendL1FundedContractTransactionCall {
        #[allow(missing_docs)]
        pub gasLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`sendL1FundedContractTransaction(uint256,uint256,address,bytes)`](sendL1FundedContractTransactionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sendL1FundedContractTransactionReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sendL1FundedContractTransactionCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: sendL1FundedContractTransactionCall) -> Self {
                    (value.gasLimit, value.maxFeePerGas, value.to, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sendL1FundedContractTransactionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        gasLimit: tuple.0,
                        maxFeePerGas: tuple.1,
                        to: tuple.2,
                        data: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sendL1FundedContractTransactionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: sendL1FundedContractTransactionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sendL1FundedContractTransactionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sendL1FundedContractTransactionCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = sendL1FundedContractTransactionReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sendL1FundedContractTransaction(uint256,uint256,address,bytes)";
            const SELECTOR: [u8; 4] = [94u8, 145u8, 103u8, 88u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.gasLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxFeePerGas),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `sendL1FundedUnsignedTransaction(uint256,uint256,uint256,address,bytes)` and selector `0x67ef3ab8`.
```solidity
function sendL1FundedUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, bytes memory data) external payable returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sendL1FundedUnsignedTransactionCall {
        #[allow(missing_docs)]
        pub gasLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`sendL1FundedUnsignedTransaction(uint256,uint256,uint256,address,bytes)`](sendL1FundedUnsignedTransactionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sendL1FundedUnsignedTransactionReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sendL1FundedUnsignedTransactionCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: sendL1FundedUnsignedTransactionCall) -> Self {
                    (
                        value.gasLimit,
                        value.maxFeePerGas,
                        value.nonce,
                        value.to,
                        value.data,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sendL1FundedUnsignedTransactionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        gasLimit: tuple.0,
                        maxFeePerGas: tuple.1,
                        nonce: tuple.2,
                        to: tuple.3,
                        data: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sendL1FundedUnsignedTransactionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: sendL1FundedUnsignedTransactionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sendL1FundedUnsignedTransactionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sendL1FundedUnsignedTransactionCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = sendL1FundedUnsignedTransactionReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sendL1FundedUnsignedTransaction(uint256,uint256,uint256,address,bytes)";
            const SELECTOR: [u8; 4] = [103u8, 239u8, 58u8, 184u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.gasLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxFeePerGas),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `sendL1FundedUnsignedTransactionToFork(uint256,uint256,uint256,address,bytes)` and selector `0xe6bd12cf`.
```solidity
function sendL1FundedUnsignedTransactionToFork(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, bytes memory data) external payable returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sendL1FundedUnsignedTransactionToForkCall {
        #[allow(missing_docs)]
        pub gasLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`sendL1FundedUnsignedTransactionToFork(uint256,uint256,uint256,address,bytes)`](sendL1FundedUnsignedTransactionToForkCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sendL1FundedUnsignedTransactionToForkReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sendL1FundedUnsignedTransactionToForkCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: sendL1FundedUnsignedTransactionToForkCall) -> Self {
                    (
                        value.gasLimit,
                        value.maxFeePerGas,
                        value.nonce,
                        value.to,
                        value.data,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sendL1FundedUnsignedTransactionToForkCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        gasLimit: tuple.0,
                        maxFeePerGas: tuple.1,
                        nonce: tuple.2,
                        to: tuple.3,
                        data: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sendL1FundedUnsignedTransactionToForkReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: sendL1FundedUnsignedTransactionToForkReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sendL1FundedUnsignedTransactionToForkReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sendL1FundedUnsignedTransactionToForkCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = sendL1FundedUnsignedTransactionToForkReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sendL1FundedUnsignedTransactionToFork(uint256,uint256,uint256,address,bytes)";
            const SELECTOR: [u8; 4] = [230u8, 189u8, 18u8, 207u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.gasLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxFeePerGas),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `sendL2Message(bytes)` and selector `0xb75436bb`.
```solidity
function sendL2Message(bytes memory messageData) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sendL2MessageCall {
        #[allow(missing_docs)]
        pub messageData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`sendL2Message(bytes)`](sendL2MessageCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sendL2MessageReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sendL2MessageCall> for UnderlyingRustTuple<'_> {
                fn from(value: sendL2MessageCall) -> Self {
                    (value.messageData,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sendL2MessageCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { messageData: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sendL2MessageReturn> for UnderlyingRustTuple<'_> {
                fn from(value: sendL2MessageReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sendL2MessageReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sendL2MessageCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = sendL2MessageReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sendL2Message(bytes)";
            const SELECTOR: [u8; 4] = [183u8, 84u8, 54u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.messageData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `sendL2MessageFromOrigin(bytes)` and selector `0x1fe927cf`.
```solidity
function sendL2MessageFromOrigin(bytes memory messageData) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sendL2MessageFromOriginCall {
        #[allow(missing_docs)]
        pub messageData: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`sendL2MessageFromOrigin(bytes)`](sendL2MessageFromOriginCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sendL2MessageFromOriginReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sendL2MessageFromOriginCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: sendL2MessageFromOriginCall) -> Self {
                    (value.messageData,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sendL2MessageFromOriginCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { messageData: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sendL2MessageFromOriginReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: sendL2MessageFromOriginReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sendL2MessageFromOriginReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sendL2MessageFromOriginCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = sendL2MessageFromOriginReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sendL2MessageFromOrigin(bytes)";
            const SELECTOR: [u8; 4] = [31u8, 233u8, 39u8, 207u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.messageData,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `sendUnsignedTransaction(uint256,uint256,uint256,address,uint256,bytes)` and selector `0x5075788b`.
```solidity
function sendUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes memory data) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sendUnsignedTransactionCall {
        #[allow(missing_docs)]
        pub gasLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`sendUnsignedTransaction(uint256,uint256,uint256,address,uint256,bytes)`](sendUnsignedTransactionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sendUnsignedTransactionReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sendUnsignedTransactionCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: sendUnsignedTransactionCall) -> Self {
                    (
                        value.gasLimit,
                        value.maxFeePerGas,
                        value.nonce,
                        value.to,
                        value.value,
                        value.data,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sendUnsignedTransactionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        gasLimit: tuple.0,
                        maxFeePerGas: tuple.1,
                        nonce: tuple.2,
                        to: tuple.3,
                        value: tuple.4,
                        data: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sendUnsignedTransactionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: sendUnsignedTransactionReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sendUnsignedTransactionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sendUnsignedTransactionCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = sendUnsignedTransactionReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sendUnsignedTransaction(uint256,uint256,uint256,address,uint256,bytes)";
            const SELECTOR: [u8; 4] = [80u8, 117u8, 120u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.gasLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxFeePerGas),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `sendUnsignedTransactionToFork(uint256,uint256,uint256,address,uint256,bytes)` and selector `0x00f72382`.
```solidity
function sendUnsignedTransactionToFork(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes memory data) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sendUnsignedTransactionToForkCall {
        #[allow(missing_docs)]
        pub gasLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`sendUnsignedTransactionToFork(uint256,uint256,uint256,address,uint256,bytes)`](sendUnsignedTransactionToForkCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sendUnsignedTransactionToForkReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sendUnsignedTransactionToForkCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: sendUnsignedTransactionToForkCall) -> Self {
                    (
                        value.gasLimit,
                        value.maxFeePerGas,
                        value.nonce,
                        value.to,
                        value.value,
                        value.data,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sendUnsignedTransactionToForkCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        gasLimit: tuple.0,
                        maxFeePerGas: tuple.1,
                        nonce: tuple.2,
                        to: tuple.3,
                        value: tuple.4,
                        data: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sendUnsignedTransactionToForkReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: sendUnsignedTransactionToForkReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sendUnsignedTransactionToForkReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sendUnsignedTransactionToForkCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = sendUnsignedTransactionToForkReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sendUnsignedTransactionToFork(uint256,uint256,uint256,address,uint256,bytes)";
            const SELECTOR: [u8; 4] = [0u8, 247u8, 35u8, 130u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.gasLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxFeePerGas),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `sendWithdrawEthToFork(uint256,uint256,uint256,uint256,address)` and selector `0x70665f14`.
```solidity
function sendWithdrawEthToFork(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, uint256 value, address withdrawTo) external returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sendWithdrawEthToForkCall {
        #[allow(missing_docs)]
        pub gasLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub withdrawTo: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`sendWithdrawEthToFork(uint256,uint256,uint256,uint256,address)`](sendWithdrawEthToForkCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sendWithdrawEthToForkReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sendWithdrawEthToForkCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: sendWithdrawEthToForkCall) -> Self {
                    (
                        value.gasLimit,
                        value.maxFeePerGas,
                        value.nonce,
                        value.value,
                        value.withdrawTo,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sendWithdrawEthToForkCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        gasLimit: tuple.0,
                        maxFeePerGas: tuple.1,
                        nonce: tuple.2,
                        value: tuple.3,
                        withdrawTo: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sendWithdrawEthToForkReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: sendWithdrawEthToForkReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sendWithdrawEthToForkReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sendWithdrawEthToForkCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = sendWithdrawEthToForkReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sendWithdrawEthToFork(uint256,uint256,uint256,uint256,address)";
            const SELECTOR: [u8; 4] = [112u8, 102u8, 95u8, 20u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.gasLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxFeePerGas),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.withdrawTo,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `sequencerInbox()` and selector `0xee35f327`.
```solidity
function sequencerInbox() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sequencerInboxCall {}
    ///Container type for the return parameters of the [`sequencerInbox()`](sequencerInboxCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sequencerInboxReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sequencerInboxCall> for UnderlyingRustTuple<'_> {
                fn from(value: sequencerInboxCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sequencerInboxCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sequencerInboxReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: sequencerInboxReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for sequencerInboxReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sequencerInboxCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = sequencerInboxReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sequencerInbox()";
            const SELECTOR: [u8; 4] = [238u8, 53u8, 243u8, 39u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setAllowList(address[],bool[])` and selector `0xe3de72a5`.
```solidity
function setAllowList(address[] memory user, bool[] memory val) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAllowListCall {
        #[allow(missing_docs)]
        pub user: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
        #[allow(missing_docs)]
        pub val: alloy::sol_types::private::Vec<bool>,
    }
    ///Container type for the return parameters of the [`setAllowList(address[],bool[])`](setAllowListCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAllowListReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
                alloy::sol_types::private::Vec<bool>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAllowListCall> for UnderlyingRustTuple<'_> {
                fn from(value: setAllowListCall) -> Self {
                    (value.user, value.val)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setAllowListCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        user: tuple.0,
                        val: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAllowListReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setAllowListReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setAllowListReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setAllowListCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setAllowListReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setAllowList(address[],bool[])";
            const SELECTOR: [u8; 4] = [227u8, 222u8, 114u8, 165u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.user),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bool,
                    > as alloy_sol_types::SolType>::tokenize(&self.val),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setAllowListEnabled(bool)` and selector `0xefeadb6d`.
```solidity
function setAllowListEnabled(bool _allowListEnabled) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAllowListEnabledCall {
        #[allow(missing_docs)]
        pub _allowListEnabled: bool,
    }
    ///Container type for the return parameters of the [`setAllowListEnabled(bool)`](setAllowListEnabledCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAllowListEnabledReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAllowListEnabledCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setAllowListEnabledCall) -> Self {
                    (value._allowListEnabled,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setAllowListEnabledCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _allowListEnabled: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAllowListEnabledReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setAllowListEnabledReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setAllowListEnabledReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setAllowListEnabledCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bool,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setAllowListEnabledReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setAllowListEnabled(bool)";
            const SELECTOR: [u8; 4] = [239u8, 234u8, 219u8, 109u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self._allowListEnabled,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `unpause()` and selector `0x3f4ba83a`.
```solidity
function unpause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseCall {}
    ///Container type for the return parameters of the [`unpause()`](unpauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unpauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = unpauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unpause()";
            const SELECTOR: [u8; 4] = [63u8, 75u8, 168u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `unsafeCreateRetryableTicket(address,uint256,uint256,address,address,uint256,uint256,bytes)` and selector `0x6e6e8a6a`.
```solidity
function unsafeCreateRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, bytes memory data) external payable returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unsafeCreateRetryableTicketCall {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub l2CallValue: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxSubmissionCost: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub excessFeeRefundAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub callValueRefundAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub gasLimit: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`unsafeCreateRetryableTicket(address,uint256,uint256,address,address,uint256,uint256,bytes)`](unsafeCreateRetryableTicketCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unsafeCreateRetryableTicketReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unsafeCreateRetryableTicketCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: unsafeCreateRetryableTicketCall) -> Self {
                    (
                        value.to,
                        value.l2CallValue,
                        value.maxSubmissionCost,
                        value.excessFeeRefundAddress,
                        value.callValueRefundAddress,
                        value.gasLimit,
                        value.maxFeePerGas,
                        value.data,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for unsafeCreateRetryableTicketCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        to: tuple.0,
                        l2CallValue: tuple.1,
                        maxSubmissionCost: tuple.2,
                        excessFeeRefundAddress: tuple.3,
                        callValueRefundAddress: tuple.4,
                        gasLimit: tuple.5,
                        maxFeePerGas: tuple.6,
                        data: tuple.7,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unsafeCreateRetryableTicketReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: unsafeCreateRetryableTicketReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for unsafeCreateRetryableTicketReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unsafeCreateRetryableTicketCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = unsafeCreateRetryableTicketReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unsafeCreateRetryableTicket(address,uint256,uint256,address,address,uint256,uint256,bytes)";
            const SELECTOR: [u8; 4] = [110u8, 110u8, 138u8, 106u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.l2CallValue),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxSubmissionCost),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.excessFeeRefundAddress,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callValueRefundAddress,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.gasLimit),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxFeePerGas),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`Inbox`](self) function calls.
    pub enum InboxCalls {
        #[allow(missing_docs)]
        allowListEnabled(allowListEnabledCall),
        #[allow(missing_docs)]
        bridge(bridgeCall),
        #[allow(missing_docs)]
        calculateRetryableSubmissionFee(calculateRetryableSubmissionFeeCall),
        #[allow(missing_docs)]
        createRetryableTicket(createRetryableTicketCall),
        #[allow(missing_docs)]
        createRetryableTicketNoRefundAliasRewrite(
            createRetryableTicketNoRefundAliasRewriteCall,
        ),
        #[allow(missing_docs)]
        depositEth_0(depositEth_0Call),
        #[allow(missing_docs)]
        depositEth_1(depositEth_1Call),
        #[allow(missing_docs)]
        getProxyAdmin(getProxyAdminCall),
        #[allow(missing_docs)]
        initialize(initializeCall),
        #[allow(missing_docs)]
        isAllowed(isAllowedCall),
        #[allow(missing_docs)]
        maxDataSize(maxDataSizeCall),
        #[allow(missing_docs)]
        pause(pauseCall),
        #[allow(missing_docs)]
        paused(pausedCall),
        #[allow(missing_docs)]
        postUpgradeInit(postUpgradeInitCall),
        #[allow(missing_docs)]
        sendContractTransaction(sendContractTransactionCall),
        #[allow(missing_docs)]
        sendL1FundedContractTransaction(sendL1FundedContractTransactionCall),
        #[allow(missing_docs)]
        sendL1FundedUnsignedTransaction(sendL1FundedUnsignedTransactionCall),
        #[allow(missing_docs)]
        sendL1FundedUnsignedTransactionToFork(sendL1FundedUnsignedTransactionToForkCall),
        #[allow(missing_docs)]
        sendL2Message(sendL2MessageCall),
        #[allow(missing_docs)]
        sendL2MessageFromOrigin(sendL2MessageFromOriginCall),
        #[allow(missing_docs)]
        sendUnsignedTransaction(sendUnsignedTransactionCall),
        #[allow(missing_docs)]
        sendUnsignedTransactionToFork(sendUnsignedTransactionToForkCall),
        #[allow(missing_docs)]
        sendWithdrawEthToFork(sendWithdrawEthToForkCall),
        #[allow(missing_docs)]
        sequencerInbox(sequencerInboxCall),
        #[allow(missing_docs)]
        setAllowList(setAllowListCall),
        #[allow(missing_docs)]
        setAllowListEnabled(setAllowListEnabledCall),
        #[allow(missing_docs)]
        unpause(unpauseCall),
        #[allow(missing_docs)]
        unsafeCreateRetryableTicket(unsafeCreateRetryableTicketCall),
    }
    #[automatically_derived]
    impl InboxCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [0u8, 247u8, 35u8, 130u8],
            [15u8, 77u8, 20u8, 233u8],
            [27u8, 135u8, 28u8, 141u8],
            [31u8, 233u8, 39u8, 207u8],
            [34u8, 189u8, 92u8, 28u8],
            [63u8, 75u8, 168u8, 58u8],
            [67u8, 147u8, 112u8, 177u8],
            [72u8, 92u8, 201u8, 85u8],
            [80u8, 117u8, 120u8, 139u8],
            [92u8, 151u8, 90u8, 187u8],
            [94u8, 145u8, 103u8, 88u8],
            [103u8, 155u8, 109u8, 237u8],
            [103u8, 239u8, 58u8, 184u8],
            [110u8, 110u8, 138u8, 106u8],
            [112u8, 102u8, 95u8, 20u8],
            [132u8, 86u8, 203u8, 89u8],
            [138u8, 99u8, 26u8, 166u8],
            [139u8, 50u8, 64u8, 160u8],
            [166u8, 107u8, 50u8, 125u8],
            [183u8, 84u8, 54u8, 187u8],
            [186u8, 188u8, 197u8, 57u8],
            [196u8, 116u8, 210u8, 197u8],
            [227u8, 222u8, 114u8, 165u8],
            [230u8, 189u8, 18u8, 207u8],
            [231u8, 140u8, 234u8, 146u8],
            [232u8, 235u8, 29u8, 195u8],
            [238u8, 53u8, 243u8, 39u8],
            [239u8, 234u8, 219u8, 109u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for InboxCalls {
        const NAME: &'static str = "InboxCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 28usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::allowListEnabled(_) => {
                    <allowListEnabledCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridge(_) => <bridgeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::calculateRetryableSubmissionFee(_) => {
                    <calculateRetryableSubmissionFeeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::createRetryableTicket(_) => {
                    <createRetryableTicketCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::createRetryableTicketNoRefundAliasRewrite(_) => {
                    <createRetryableTicketNoRefundAliasRewriteCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::depositEth_0(_) => {
                    <depositEth_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::depositEth_1(_) => {
                    <depositEth_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getProxyAdmin(_) => {
                    <getProxyAdminCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initialize(_) => {
                    <initializeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isAllowed(_) => {
                    <isAllowedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::maxDataSize(_) => {
                    <maxDataSizeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::pause(_) => <pauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::paused(_) => <pausedCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::postUpgradeInit(_) => {
                    <postUpgradeInitCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::sendContractTransaction(_) => {
                    <sendContractTransactionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::sendL1FundedContractTransaction(_) => {
                    <sendL1FundedContractTransactionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::sendL1FundedUnsignedTransaction(_) => {
                    <sendL1FundedUnsignedTransactionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::sendL1FundedUnsignedTransactionToFork(_) => {
                    <sendL1FundedUnsignedTransactionToForkCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::sendL2Message(_) => {
                    <sendL2MessageCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::sendL2MessageFromOrigin(_) => {
                    <sendL2MessageFromOriginCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::sendUnsignedTransaction(_) => {
                    <sendUnsignedTransactionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::sendUnsignedTransactionToFork(_) => {
                    <sendUnsignedTransactionToForkCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::sendWithdrawEthToFork(_) => {
                    <sendWithdrawEthToForkCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::sequencerInbox(_) => {
                    <sequencerInboxCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setAllowList(_) => {
                    <setAllowListCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setAllowListEnabled(_) => {
                    <setAllowListEnabledCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::unpause(_) => <unpauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::unsafeCreateRetryableTicket(_) => {
                    <unsafeCreateRetryableTicketCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<InboxCalls>] = &[
                {
                    fn sendUnsignedTransactionToFork(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <sendUnsignedTransactionToForkCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::sendUnsignedTransactionToFork)
                    }
                    sendUnsignedTransactionToFork
                },
                {
                    fn depositEth_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <depositEth_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::depositEth_0)
                    }
                    depositEth_0
                },
                {
                    fn createRetryableTicketNoRefundAliasRewrite(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <createRetryableTicketNoRefundAliasRewriteCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::createRetryableTicketNoRefundAliasRewrite)
                    }
                    createRetryableTicketNoRefundAliasRewrite
                },
                {
                    fn sendL2MessageFromOrigin(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <sendL2MessageFromOriginCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::sendL2MessageFromOrigin)
                    }
                    sendL2MessageFromOrigin
                },
                {
                    fn allowListEnabled(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <allowListEnabledCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::allowListEnabled)
                    }
                    allowListEnabled
                },
                {
                    fn unpause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <unpauseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::unpause)
                    }
                    unpause
                },
                {
                    fn depositEth_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <depositEth_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::depositEth_1)
                    }
                    depositEth_1
                },
                {
                    fn initialize(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::initialize)
                    }
                    initialize
                },
                {
                    fn sendUnsignedTransaction(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <sendUnsignedTransactionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::sendUnsignedTransaction)
                    }
                    sendUnsignedTransaction
                },
                {
                    fn paused(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <pausedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::paused)
                    }
                    paused
                },
                {
                    fn sendL1FundedContractTransaction(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <sendL1FundedContractTransactionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::sendL1FundedContractTransaction)
                    }
                    sendL1FundedContractTransaction
                },
                {
                    fn createRetryableTicket(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <createRetryableTicketCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::createRetryableTicket)
                    }
                    createRetryableTicket
                },
                {
                    fn sendL1FundedUnsignedTransaction(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <sendL1FundedUnsignedTransactionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::sendL1FundedUnsignedTransaction)
                    }
                    sendL1FundedUnsignedTransaction
                },
                {
                    fn unsafeCreateRetryableTicket(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <unsafeCreateRetryableTicketCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::unsafeCreateRetryableTicket)
                    }
                    unsafeCreateRetryableTicket
                },
                {
                    fn sendWithdrawEthToFork(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <sendWithdrawEthToForkCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::sendWithdrawEthToFork)
                    }
                    sendWithdrawEthToFork
                },
                {
                    fn pause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <pauseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::pause)
                    }
                    pause
                },
                {
                    fn sendContractTransaction(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <sendContractTransactionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::sendContractTransaction)
                    }
                    sendContractTransaction
                },
                {
                    fn getProxyAdmin(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <getProxyAdminCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::getProxyAdmin)
                    }
                    getProxyAdmin
                },
                {
                    fn calculateRetryableSubmissionFee(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <calculateRetryableSubmissionFeeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::calculateRetryableSubmissionFee)
                    }
                    calculateRetryableSubmissionFee
                },
                {
                    fn sendL2Message(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <sendL2MessageCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::sendL2Message)
                    }
                    sendL2Message
                },
                {
                    fn isAllowed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <isAllowedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::isAllowed)
                    }
                    isAllowed
                },
                {
                    fn postUpgradeInit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <postUpgradeInitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::postUpgradeInit)
                    }
                    postUpgradeInit
                },
                {
                    fn setAllowList(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <setAllowListCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::setAllowList)
                    }
                    setAllowList
                },
                {
                    fn sendL1FundedUnsignedTransactionToFork(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <sendL1FundedUnsignedTransactionToForkCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::sendL1FundedUnsignedTransactionToFork)
                    }
                    sendL1FundedUnsignedTransactionToFork
                },
                {
                    fn bridge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <bridgeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::bridge)
                    }
                    bridge
                },
                {
                    fn maxDataSize(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <maxDataSizeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::maxDataSize)
                    }
                    maxDataSize
                },
                {
                    fn sequencerInbox(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <sequencerInboxCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::sequencerInbox)
                    }
                    sequencerInbox
                },
                {
                    fn setAllowListEnabled(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxCalls> {
                        <setAllowListEnabledCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxCalls::setAllowListEnabled)
                    }
                    setAllowListEnabled
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::allowListEnabled(inner) => {
                    <allowListEnabledCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bridge(inner) => {
                    <bridgeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::calculateRetryableSubmissionFee(inner) => {
                    <calculateRetryableSubmissionFeeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::createRetryableTicket(inner) => {
                    <createRetryableTicketCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::createRetryableTicketNoRefundAliasRewrite(inner) => {
                    <createRetryableTicketNoRefundAliasRewriteCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::depositEth_0(inner) => {
                    <depositEth_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::depositEth_1(inner) => {
                    <depositEth_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getProxyAdmin(inner) => {
                    <getProxyAdminCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isAllowed(inner) => {
                    <isAllowedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::maxDataSize(inner) => {
                    <maxDataSizeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::postUpgradeInit(inner) => {
                    <postUpgradeInitCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::sendContractTransaction(inner) => {
                    <sendContractTransactionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::sendL1FundedContractTransaction(inner) => {
                    <sendL1FundedContractTransactionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::sendL1FundedUnsignedTransaction(inner) => {
                    <sendL1FundedUnsignedTransactionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::sendL1FundedUnsignedTransactionToFork(inner) => {
                    <sendL1FundedUnsignedTransactionToForkCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::sendL2Message(inner) => {
                    <sendL2MessageCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::sendL2MessageFromOrigin(inner) => {
                    <sendL2MessageFromOriginCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::sendUnsignedTransaction(inner) => {
                    <sendUnsignedTransactionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::sendUnsignedTransactionToFork(inner) => {
                    <sendUnsignedTransactionToForkCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::sendWithdrawEthToFork(inner) => {
                    <sendWithdrawEthToForkCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::sequencerInbox(inner) => {
                    <sequencerInboxCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setAllowList(inner) => {
                    <setAllowListCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setAllowListEnabled(inner) => {
                    <setAllowListEnabledCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::unsafeCreateRetryableTicket(inner) => {
                    <unsafeCreateRetryableTicketCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::allowListEnabled(inner) => {
                    <allowListEnabledCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridge(inner) => {
                    <bridgeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::calculateRetryableSubmissionFee(inner) => {
                    <calculateRetryableSubmissionFeeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::createRetryableTicket(inner) => {
                    <createRetryableTicketCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::createRetryableTicketNoRefundAliasRewrite(inner) => {
                    <createRetryableTicketNoRefundAliasRewriteCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::depositEth_0(inner) => {
                    <depositEth_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::depositEth_1(inner) => {
                    <depositEth_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getProxyAdmin(inner) => {
                    <getProxyAdminCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isAllowed(inner) => {
                    <isAllowedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::maxDataSize(inner) => {
                    <maxDataSizeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::postUpgradeInit(inner) => {
                    <postUpgradeInitCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::sendContractTransaction(inner) => {
                    <sendContractTransactionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::sendL1FundedContractTransaction(inner) => {
                    <sendL1FundedContractTransactionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::sendL1FundedUnsignedTransaction(inner) => {
                    <sendL1FundedUnsignedTransactionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::sendL1FundedUnsignedTransactionToFork(inner) => {
                    <sendL1FundedUnsignedTransactionToForkCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::sendL2Message(inner) => {
                    <sendL2MessageCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::sendL2MessageFromOrigin(inner) => {
                    <sendL2MessageFromOriginCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::sendUnsignedTransaction(inner) => {
                    <sendUnsignedTransactionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::sendUnsignedTransactionToFork(inner) => {
                    <sendUnsignedTransactionToForkCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::sendWithdrawEthToFork(inner) => {
                    <sendWithdrawEthToForkCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::sequencerInbox(inner) => {
                    <sequencerInboxCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setAllowList(inner) => {
                    <setAllowListCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setAllowListEnabled(inner) => {
                    <setAllowListEnabledCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::unsafeCreateRetryableTicket(inner) => {
                    <unsafeCreateRetryableTicketCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`Inbox`](self) custom errors.
    pub enum InboxErrors {
        #[allow(missing_docs)]
        DataTooLarge(DataTooLarge),
        #[allow(missing_docs)]
        GasLimitTooLarge(GasLimitTooLarge),
        #[allow(missing_docs)]
        InsufficientSubmissionCost(InsufficientSubmissionCost),
        #[allow(missing_docs)]
        InsufficientValue(InsufficientValue),
        #[allow(missing_docs)]
        L1Forked(L1Forked),
        #[allow(missing_docs)]
        NotAllowedOrigin(NotAllowedOrigin),
        #[allow(missing_docs)]
        NotCodelessOrigin(NotCodelessOrigin),
        #[allow(missing_docs)]
        NotForked(NotForked),
        #[allow(missing_docs)]
        NotOrigin(NotOrigin),
        #[allow(missing_docs)]
        NotOwner(NotOwner),
        #[allow(missing_docs)]
        NotRollupOrOwner(NotRollupOrOwner),
        #[allow(missing_docs)]
        RetryableData(RetryableData),
    }
    #[automatically_derived]
    impl InboxErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [7u8, 57u8, 96u8, 7u8],
            [7u8, 194u8, 102u8, 227u8],
            [16u8, 124u8, 82u8, 123u8],
            [35u8, 41u8, 95u8, 14u8],
            [70u8, 52u8, 105u8, 27u8],
            [112u8, 64u8, 181u8, 140u8],
            [163u8, 1u8, 187u8, 6u8],
            [198u8, 234u8, 104u8, 3u8],
            [200u8, 149u8, 142u8, 173u8],
            [245u8, 30u8, 215u8, 16u8],
            [250u8, 223u8, 35u8, 138u8],
            [254u8, 179u8, 208u8, 113u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for InboxErrors {
        const NAME: &'static str = "InboxErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 12usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::DataTooLarge(_) => {
                    <DataTooLarge as alloy_sol_types::SolError>::SELECTOR
                }
                Self::GasLimitTooLarge(_) => {
                    <GasLimitTooLarge as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientSubmissionCost(_) => {
                    <InsufficientSubmissionCost as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientValue(_) => {
                    <InsufficientValue as alloy_sol_types::SolError>::SELECTOR
                }
                Self::L1Forked(_) => <L1Forked as alloy_sol_types::SolError>::SELECTOR,
                Self::NotAllowedOrigin(_) => {
                    <NotAllowedOrigin as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotCodelessOrigin(_) => {
                    <NotCodelessOrigin as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotForked(_) => <NotForked as alloy_sol_types::SolError>::SELECTOR,
                Self::NotOrigin(_) => <NotOrigin as alloy_sol_types::SolError>::SELECTOR,
                Self::NotOwner(_) => <NotOwner as alloy_sol_types::SolError>::SELECTOR,
                Self::NotRollupOrOwner(_) => {
                    <NotRollupOrOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::RetryableData(_) => {
                    <RetryableData as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<InboxErrors>] = &[
                {
                    fn NotRollupOrOwner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxErrors> {
                        <NotRollupOrOwner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxErrors::NotRollupOrOwner)
                    }
                    NotRollupOrOwner
                },
                {
                    fn RetryableData(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxErrors> {
                        <RetryableData as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxErrors::RetryableData)
                    }
                    RetryableData
                },
                {
                    fn GasLimitTooLarge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxErrors> {
                        <GasLimitTooLarge as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxErrors::GasLimitTooLarge)
                    }
                    GasLimitTooLarge
                },
                {
                    fn NotOwner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxErrors> {
                        <NotOwner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxErrors::NotOwner)
                    }
                    NotOwner
                },
                {
                    fn DataTooLarge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxErrors> {
                        <DataTooLarge as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxErrors::DataTooLarge)
                    }
                    DataTooLarge
                },
                {
                    fn InsufficientValue(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxErrors> {
                        <InsufficientValue as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxErrors::InsufficientValue)
                    }
                    InsufficientValue
                },
                {
                    fn NotForked(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxErrors> {
                        <NotForked as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxErrors::NotForked)
                    }
                    NotForked
                },
                {
                    fn L1Forked(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxErrors> {
                        <L1Forked as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxErrors::L1Forked)
                    }
                    L1Forked
                },
                {
                    fn NotCodelessOrigin(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxErrors> {
                        <NotCodelessOrigin as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxErrors::NotCodelessOrigin)
                    }
                    NotCodelessOrigin
                },
                {
                    fn NotAllowedOrigin(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxErrors> {
                        <NotAllowedOrigin as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxErrors::NotAllowedOrigin)
                    }
                    NotAllowedOrigin
                },
                {
                    fn InsufficientSubmissionCost(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxErrors> {
                        <InsufficientSubmissionCost as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxErrors::InsufficientSubmissionCost)
                    }
                    InsufficientSubmissionCost
                },
                {
                    fn NotOrigin(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<InboxErrors> {
                        <NotOrigin as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(InboxErrors::NotOrigin)
                    }
                    NotOrigin
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::DataTooLarge(inner) => {
                    <DataTooLarge as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::GasLimitTooLarge(inner) => {
                    <GasLimitTooLarge as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientSubmissionCost(inner) => {
                    <InsufficientSubmissionCost as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientValue(inner) => {
                    <InsufficientValue as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::L1Forked(inner) => {
                    <L1Forked as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NotAllowedOrigin(inner) => {
                    <NotAllowedOrigin as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotCodelessOrigin(inner) => {
                    <NotCodelessOrigin as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotForked(inner) => {
                    <NotForked as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NotOrigin(inner) => {
                    <NotOrigin as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NotOwner(inner) => {
                    <NotOwner as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NotRollupOrOwner(inner) => {
                    <NotRollupOrOwner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::RetryableData(inner) => {
                    <RetryableData as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::DataTooLarge(inner) => {
                    <DataTooLarge as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::GasLimitTooLarge(inner) => {
                    <GasLimitTooLarge as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientSubmissionCost(inner) => {
                    <InsufficientSubmissionCost as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientValue(inner) => {
                    <InsufficientValue as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::L1Forked(inner) => {
                    <L1Forked as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::NotAllowedOrigin(inner) => {
                    <NotAllowedOrigin as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotCodelessOrigin(inner) => {
                    <NotCodelessOrigin as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotForked(inner) => {
                    <NotForked as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::NotOrigin(inner) => {
                    <NotOrigin as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::NotOwner(inner) => {
                    <NotOwner as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::NotRollupOrOwner(inner) => {
                    <NotRollupOrOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::RetryableData(inner) => {
                    <RetryableData as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`Inbox`](self) events.
    pub enum InboxEvents {
        #[allow(missing_docs)]
        AllowListAddressSet(AllowListAddressSet),
        #[allow(missing_docs)]
        AllowListEnabledUpdated(AllowListEnabledUpdated),
        #[allow(missing_docs)]
        InboxMessageDelivered(InboxMessageDelivered),
        #[allow(missing_docs)]
        InboxMessageDeliveredFromOrigin(InboxMessageDeliveredFromOrigin),
        #[allow(missing_docs)]
        Initialized(Initialized),
        #[allow(missing_docs)]
        Paused(Paused),
        #[allow(missing_docs)]
        Unpaused(Unpaused),
    }
    #[automatically_derived]
    impl InboxEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                22u8,
                67u8,
                91u8,
                69u8,
                247u8,
                72u8,
                32u8,
                71u8,
                248u8,
                57u8,
                166u8,
                161u8,
                157u8,
                41u8,
                20u8,
                66u8,
                98u8,
                114u8,
                0u8,
                245u8,
                44u8,
                173u8,
                40u8,
                3u8,
                197u8,
                149u8,
                21u8,
                13u8,
                13u8,
                68u8,
                14u8,
                179u8,
            ],
            [
                93u8,
                185u8,
                238u8,
                10u8,
                73u8,
                91u8,
                242u8,
                230u8,
                255u8,
                156u8,
                145u8,
                167u8,
                131u8,
                76u8,
                27u8,
                164u8,
                253u8,
                210u8,
                68u8,
                165u8,
                232u8,
                170u8,
                78u8,
                83u8,
                123u8,
                211u8,
                138u8,
                234u8,
                228u8,
                176u8,
                115u8,
                170u8,
            ],
            [
                98u8,
                231u8,
                140u8,
                234u8,
                1u8,
                190u8,
                227u8,
                32u8,
                205u8,
                78u8,
                66u8,
                2u8,
                112u8,
                181u8,
                234u8,
                116u8,
                0u8,
                13u8,
                17u8,
                176u8,
                201u8,
                247u8,
                71u8,
                84u8,
                235u8,
                219u8,
                252u8,
                84u8,
                75u8,
                5u8,
                162u8,
                88u8,
            ],
            [
                127u8,
                38u8,
                184u8,
                63u8,
                249u8,
                110u8,
                31u8,
                43u8,
                106u8,
                104u8,
                47u8,
                19u8,
                56u8,
                82u8,
                246u8,
                121u8,
                138u8,
                9u8,
                196u8,
                101u8,
                218u8,
                149u8,
                146u8,
                20u8,
                96u8,
                206u8,
                251u8,
                56u8,
                71u8,
                64u8,
                36u8,
                152u8,
            ],
            [
                171u8,
                83u8,
                35u8,
                133u8,
                190u8,
                143u8,
                16u8,
                5u8,
                164u8,
                182u8,
                186u8,
                143u8,
                162u8,
                10u8,
                34u8,
                69u8,
                250u8,
                203u8,
                52u8,
                97u8,
                52u8,
                172u8,
                115u8,
                159u8,
                233u8,
                165u8,
                25u8,
                141u8,
                193u8,
                88u8,
                11u8,
                156u8,
            ],
            [
                217u8,
                115u8,
                159u8,
                69u8,
                160u8,
                28u8,
                224u8,
                146u8,
                197u8,
                205u8,
                179u8,
                214u8,
                143u8,
                99u8,
                214u8,
                61u8,
                33u8,
                103u8,
                107u8,
                28u8,
                108u8,
                11u8,
                79u8,
                156u8,
                188u8,
                107u8,
                228u8,
                207u8,
                84u8,
                73u8,
                89u8,
                90u8,
            ],
            [
                255u8,
                100u8,
                144u8,
                95u8,
                115u8,
                166u8,
                127u8,
                181u8,
                148u8,
                224u8,
                249u8,
                64u8,
                168u8,
                7u8,
                90u8,
                134u8,
                13u8,
                180u8,
                137u8,
                173u8,
                153u8,
                30u8,
                3u8,
                47u8,
                72u8,
                200u8,
                17u8,
                35u8,
                235u8,
                82u8,
                214u8,
                11u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for InboxEvents {
        const NAME: &'static str = "InboxEvents";
        const COUNT: usize = 7usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <AllowListAddressSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <AllowListAddressSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::AllowListAddressSet)
                }
                Some(
                    <AllowListEnabledUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <AllowListEnabledUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::AllowListEnabledUpdated)
                }
                Some(
                    <InboxMessageDelivered as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <InboxMessageDelivered as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::InboxMessageDelivered)
                }
                Some(
                    <InboxMessageDeliveredFromOrigin as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <InboxMessageDeliveredFromOrigin as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::InboxMessageDeliveredFromOrigin)
                }
                Some(<Initialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Initialized)
                }
                Some(<Paused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Paused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Paused)
                }
                Some(<Unpaused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Unpaused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Unpaused)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for InboxEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AllowListAddressSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::AllowListEnabledUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::InboxMessageDelivered(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::InboxMessageDeliveredFromOrigin(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AllowListAddressSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::AllowListEnabledUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::InboxMessageDelivered(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::InboxMessageDeliveredFromOrigin(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`Inbox`](self) contract instance.

See the [wrapper's documentation](`InboxInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> InboxInstance<T, P, N> {
        InboxInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        _maxDataSize: alloy::sol_types::private::primitives::aliases::U256,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<InboxInstance<T, P, N>>,
    > {
        InboxInstance::<T, P, N>::deploy(provider, _maxDataSize)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        _maxDataSize: alloy::sol_types::private::primitives::aliases::U256,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        InboxInstance::<T, P, N>::deploy_builder(provider, _maxDataSize)
    }
    /**A [`Inbox`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`Inbox`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct InboxInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for InboxInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("InboxInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > InboxInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`Inbox`](self) contract instance.

See the [wrapper's documentation](`InboxInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            _maxDataSize: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::Result<InboxInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider, _maxDataSize);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            _maxDataSize: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall { _maxDataSize },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> InboxInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> InboxInstance<T, P, N> {
            InboxInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > InboxInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`allowListEnabled`] function.
        pub fn allowListEnabled(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, allowListEnabledCall, N> {
            self.call_builder(&allowListEnabledCall {})
        }
        ///Creates a new call builder for the [`bridge`] function.
        pub fn bridge(&self) -> alloy_contract::SolCallBuilder<T, &P, bridgeCall, N> {
            self.call_builder(&bridgeCall {})
        }
        ///Creates a new call builder for the [`calculateRetryableSubmissionFee`] function.
        pub fn calculateRetryableSubmissionFee(
            &self,
            dataLength: alloy::sol_types::private::primitives::aliases::U256,
            baseFee: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            calculateRetryableSubmissionFeeCall,
            N,
        > {
            self.call_builder(
                &calculateRetryableSubmissionFeeCall {
                    dataLength,
                    baseFee,
                },
            )
        }
        ///Creates a new call builder for the [`createRetryableTicket`] function.
        pub fn createRetryableTicket(
            &self,
            to: alloy::sol_types::private::Address,
            l2CallValue: alloy::sol_types::private::primitives::aliases::U256,
            maxSubmissionCost: alloy::sol_types::private::primitives::aliases::U256,
            excessFeeRefundAddress: alloy::sol_types::private::Address,
            callValueRefundAddress: alloy::sol_types::private::Address,
            gasLimit: alloy::sol_types::private::primitives::aliases::U256,
            maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, createRetryableTicketCall, N> {
            self.call_builder(
                &createRetryableTicketCall {
                    to,
                    l2CallValue,
                    maxSubmissionCost,
                    excessFeeRefundAddress,
                    callValueRefundAddress,
                    gasLimit,
                    maxFeePerGas,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`createRetryableTicketNoRefundAliasRewrite`] function.
        pub fn createRetryableTicketNoRefundAliasRewrite(
            &self,
            to: alloy::sol_types::private::Address,
            l2CallValue: alloy::sol_types::private::primitives::aliases::U256,
            maxSubmissionCost: alloy::sol_types::private::primitives::aliases::U256,
            excessFeeRefundAddress: alloy::sol_types::private::Address,
            callValueRefundAddress: alloy::sol_types::private::Address,
            gasLimit: alloy::sol_types::private::primitives::aliases::U256,
            maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            createRetryableTicketNoRefundAliasRewriteCall,
            N,
        > {
            self.call_builder(
                &createRetryableTicketNoRefundAliasRewriteCall {
                    to,
                    l2CallValue,
                    maxSubmissionCost,
                    excessFeeRefundAddress,
                    callValueRefundAddress,
                    gasLimit,
                    maxFeePerGas,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`depositEth_0`] function.
        pub fn depositEth_0(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, depositEth_0Call, N> {
            self.call_builder(&depositEth_0Call { _0 })
        }
        ///Creates a new call builder for the [`depositEth_1`] function.
        pub fn depositEth_1(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, depositEth_1Call, N> {
            self.call_builder(&depositEth_1Call {})
        }
        ///Creates a new call builder for the [`getProxyAdmin`] function.
        pub fn getProxyAdmin(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getProxyAdminCall, N> {
            self.call_builder(&getProxyAdminCall {})
        }
        ///Creates a new call builder for the [`initialize`] function.
        pub fn initialize(
            &self,
            _bridge: alloy::sol_types::private::Address,
            _sequencerInbox: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, initializeCall, N> {
            self.call_builder(
                &initializeCall {
                    _bridge,
                    _sequencerInbox,
                },
            )
        }
        ///Creates a new call builder for the [`isAllowed`] function.
        pub fn isAllowed(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, isAllowedCall, N> {
            self.call_builder(&isAllowedCall { _0 })
        }
        ///Creates a new call builder for the [`maxDataSize`] function.
        pub fn maxDataSize(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, maxDataSizeCall, N> {
            self.call_builder(&maxDataSizeCall {})
        }
        ///Creates a new call builder for the [`pause`] function.
        pub fn pause(&self) -> alloy_contract::SolCallBuilder<T, &P, pauseCall, N> {
            self.call_builder(&pauseCall {})
        }
        ///Creates a new call builder for the [`paused`] function.
        pub fn paused(&self) -> alloy_contract::SolCallBuilder<T, &P, pausedCall, N> {
            self.call_builder(&pausedCall {})
        }
        ///Creates a new call builder for the [`postUpgradeInit`] function.
        pub fn postUpgradeInit(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, postUpgradeInitCall, N> {
            self.call_builder(&postUpgradeInitCall { _0 })
        }
        ///Creates a new call builder for the [`sendContractTransaction`] function.
        pub fn sendContractTransaction(
            &self,
            gasLimit: alloy::sol_types::private::primitives::aliases::U256,
            maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
            to: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, sendContractTransactionCall, N> {
            self.call_builder(
                &sendContractTransactionCall {
                    gasLimit,
                    maxFeePerGas,
                    to,
                    value,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`sendL1FundedContractTransaction`] function.
        pub fn sendL1FundedContractTransaction(
            &self,
            gasLimit: alloy::sol_types::private::primitives::aliases::U256,
            maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
            to: alloy::sol_types::private::Address,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            sendL1FundedContractTransactionCall,
            N,
        > {
            self.call_builder(
                &sendL1FundedContractTransactionCall {
                    gasLimit,
                    maxFeePerGas,
                    to,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`sendL1FundedUnsignedTransaction`] function.
        pub fn sendL1FundedUnsignedTransaction(
            &self,
            gasLimit: alloy::sol_types::private::primitives::aliases::U256,
            maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
            nonce: alloy::sol_types::private::primitives::aliases::U256,
            to: alloy::sol_types::private::Address,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            sendL1FundedUnsignedTransactionCall,
            N,
        > {
            self.call_builder(
                &sendL1FundedUnsignedTransactionCall {
                    gasLimit,
                    maxFeePerGas,
                    nonce,
                    to,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`sendL1FundedUnsignedTransactionToFork`] function.
        pub fn sendL1FundedUnsignedTransactionToFork(
            &self,
            gasLimit: alloy::sol_types::private::primitives::aliases::U256,
            maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
            nonce: alloy::sol_types::private::primitives::aliases::U256,
            to: alloy::sol_types::private::Address,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            sendL1FundedUnsignedTransactionToForkCall,
            N,
        > {
            self.call_builder(
                &sendL1FundedUnsignedTransactionToForkCall {
                    gasLimit,
                    maxFeePerGas,
                    nonce,
                    to,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`sendL2Message`] function.
        pub fn sendL2Message(
            &self,
            messageData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, sendL2MessageCall, N> {
            self.call_builder(&sendL2MessageCall { messageData })
        }
        ///Creates a new call builder for the [`sendL2MessageFromOrigin`] function.
        pub fn sendL2MessageFromOrigin(
            &self,
            messageData: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, sendL2MessageFromOriginCall, N> {
            self.call_builder(
                &sendL2MessageFromOriginCall {
                    messageData,
                },
            )
        }
        ///Creates a new call builder for the [`sendUnsignedTransaction`] function.
        pub fn sendUnsignedTransaction(
            &self,
            gasLimit: alloy::sol_types::private::primitives::aliases::U256,
            maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
            nonce: alloy::sol_types::private::primitives::aliases::U256,
            to: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, sendUnsignedTransactionCall, N> {
            self.call_builder(
                &sendUnsignedTransactionCall {
                    gasLimit,
                    maxFeePerGas,
                    nonce,
                    to,
                    value,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`sendUnsignedTransactionToFork`] function.
        pub fn sendUnsignedTransactionToFork(
            &self,
            gasLimit: alloy::sol_types::private::primitives::aliases::U256,
            maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
            nonce: alloy::sol_types::private::primitives::aliases::U256,
            to: alloy::sol_types::private::Address,
            value: alloy::sol_types::private::primitives::aliases::U256,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            sendUnsignedTransactionToForkCall,
            N,
        > {
            self.call_builder(
                &sendUnsignedTransactionToForkCall {
                    gasLimit,
                    maxFeePerGas,
                    nonce,
                    to,
                    value,
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`sendWithdrawEthToFork`] function.
        pub fn sendWithdrawEthToFork(
            &self,
            gasLimit: alloy::sol_types::private::primitives::aliases::U256,
            maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
            nonce: alloy::sol_types::private::primitives::aliases::U256,
            value: alloy::sol_types::private::primitives::aliases::U256,
            withdrawTo: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, sendWithdrawEthToForkCall, N> {
            self.call_builder(
                &sendWithdrawEthToForkCall {
                    gasLimit,
                    maxFeePerGas,
                    nonce,
                    value,
                    withdrawTo,
                },
            )
        }
        ///Creates a new call builder for the [`sequencerInbox`] function.
        pub fn sequencerInbox(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, sequencerInboxCall, N> {
            self.call_builder(&sequencerInboxCall {})
        }
        ///Creates a new call builder for the [`setAllowList`] function.
        pub fn setAllowList(
            &self,
            user: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            val: alloy::sol_types::private::Vec<bool>,
        ) -> alloy_contract::SolCallBuilder<T, &P, setAllowListCall, N> {
            self.call_builder(&setAllowListCall { user, val })
        }
        ///Creates a new call builder for the [`setAllowListEnabled`] function.
        pub fn setAllowListEnabled(
            &self,
            _allowListEnabled: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, setAllowListEnabledCall, N> {
            self.call_builder(
                &setAllowListEnabledCall {
                    _allowListEnabled,
                },
            )
        }
        ///Creates a new call builder for the [`unpause`] function.
        pub fn unpause(&self) -> alloy_contract::SolCallBuilder<T, &P, unpauseCall, N> {
            self.call_builder(&unpauseCall {})
        }
        ///Creates a new call builder for the [`unsafeCreateRetryableTicket`] function.
        pub fn unsafeCreateRetryableTicket(
            &self,
            to: alloy::sol_types::private::Address,
            l2CallValue: alloy::sol_types::private::primitives::aliases::U256,
            maxSubmissionCost: alloy::sol_types::private::primitives::aliases::U256,
            excessFeeRefundAddress: alloy::sol_types::private::Address,
            callValueRefundAddress: alloy::sol_types::private::Address,
            gasLimit: alloy::sol_types::private::primitives::aliases::U256,
            maxFeePerGas: alloy::sol_types::private::primitives::aliases::U256,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, unsafeCreateRetryableTicketCall, N> {
            self.call_builder(
                &unsafeCreateRetryableTicketCall {
                    to,
                    l2CallValue,
                    maxSubmissionCost,
                    excessFeeRefundAddress,
                    callValueRefundAddress,
                    gasLimit,
                    maxFeePerGas,
                    data,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > InboxInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`AllowListAddressSet`] event.
        pub fn AllowListAddressSet_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, AllowListAddressSet, N> {
            self.event_filter::<AllowListAddressSet>()
        }
        ///Creates a new event filter for the [`AllowListEnabledUpdated`] event.
        pub fn AllowListEnabledUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, AllowListEnabledUpdated, N> {
            self.event_filter::<AllowListEnabledUpdated>()
        }
        ///Creates a new event filter for the [`InboxMessageDelivered`] event.
        pub fn InboxMessageDelivered_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, InboxMessageDelivered, N> {
            self.event_filter::<InboxMessageDelivered>()
        }
        ///Creates a new event filter for the [`InboxMessageDeliveredFromOrigin`] event.
        pub fn InboxMessageDeliveredFromOrigin_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, InboxMessageDeliveredFromOrigin, N> {
            self.event_filter::<InboxMessageDeliveredFromOrigin>()
        }
        ///Creates a new event filter for the [`Initialized`] event.
        pub fn Initialized_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, Initialized, N> {
            self.event_filter::<Initialized>()
        }
        ///Creates a new event filter for the [`Paused`] event.
        pub fn Paused_filter(&self) -> alloy_contract::Event<T, &P, Paused, N> {
            self.event_filter::<Paused>()
        }
        ///Creates a new event filter for the [`Unpaused`] event.
        pub fn Unpaused_filter(&self) -> alloy_contract::Event<T, &P, Unpaused, N> {
            self.event_filter::<Unpaused>()
        }
    }
}
