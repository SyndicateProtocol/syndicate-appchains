/**

Generated by the following Solidity interface...
```solidity
interface MerkleTreeAccess {
    error MerkleProofTooLong(uint256 actualLength, uint256 maxProofLength);

    function appendCompleteSubTree(bytes32[] memory me, uint256 level, bytes32 subtreeRoot) external pure returns (bytes32[] memory);
    function appendLeaf(bytes32[] memory me, bytes32 leaf) external pure returns (bytes32[] memory);
    function leastSignificantBit(uint256 x) external pure returns (uint256);
    function maximumAppendBetween(uint256 startSize, uint256 endSize) external pure returns (uint256);
    function mostSignificantBit(uint256 x) external pure returns (uint256);
    function root(bytes32[] memory me) external pure returns (bytes32);
    function verifyInclusionProof(bytes32 rootHash, bytes32 leaf, uint256 index, bytes32[] memory proof) external pure;
    function verifyPrefixProof(bytes32 preRoot, uint256 preSize, bytes32 postRoot, uint256 postSize, bytes32[] memory preExpansion, bytes32[] memory proof) external pure;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "function",
    "name": "appendCompleteSubTree",
    "inputs": [
      {
        "name": "me",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      },
      {
        "name": "level",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "subtreeRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "appendLeaf",
    "inputs": [
      {
        "name": "me",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      },
      {
        "name": "leaf",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "leastSignificantBit",
    "inputs": [
      {
        "name": "x",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "maximumAppendBetween",
    "inputs": [
      {
        "name": "startSize",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "endSize",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "mostSignificantBit",
    "inputs": [
      {
        "name": "x",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "root",
    "inputs": [
      {
        "name": "me",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "verifyInclusionProof",
    "inputs": [
      {
        "name": "rootHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "leaf",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "proof",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "verifyPrefixProof",
    "inputs": [
      {
        "name": "preRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "preSize",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "postRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "postSize",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "preExpansion",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      },
      {
        "name": "proof",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "error",
    "name": "MerkleProofTooLong",
    "inputs": [
      {
        "name": "actualLength",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxProofLength",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod MerkleTreeAccess {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6080604052348015600e575f5ffd5b506116408061001c5f395ff3fe608060405234801561000f575f5ffd5b5060043610610085575f3560e01c8063c22c47a411610058578063c22c47a4146100fb578063ca1132531461010e578063d230d23f14610121578063e6bcbc6514610134575f5ffd5b80635fb9c3d41461008957806367905a7e1461009e5780636bd58993146100c7578063bc2f0640146100da575b5f5ffd5b61009c610097366004611285565b610147565b005b6100b16100ac36600461130d565b61015d565b6040516100be9190611357565b60405180910390f35b61009c6100d5366004611399565b610174565b6100ed6100e83660046113ef565b610186565b6040519081526020016100be565b6100b161010936600461140f565b61019a565b6100ed61011c366004611451565b6101a6565b6100ed61012f36600461148b565b6101b0565b6100ed61014236600461148b565b6101ba565b6101558686868686866101c4565b505050505050565b606061016a8484846104ea565b90505b9392505050565b61018084848484610a5d565b50505050565b5f6101918383610ae9565b90505b92915050565b60606101918383610bdb565b5f61019482610c10565b5f61019482610da0565b5f61019482610e07565b5f85116102185760405162461bcd60e51b815260206004820152601460248201527f5072652d73697a652063616e6e6f74206265203000000000000000000000000060448201526064015b60405180910390fd5b8561022283610c10565b1461026f5760405162461bcd60e51b815260206004820152601b60248201527f50726520657870616e73696f6e20726f6f74206d69736d617463680000000000604482015260640161020f565b8461027983610f4b565b146102ec5760405162461bcd60e51b815260206004820152602160248201527f5072652073697a6520646f6573206e6f74206d6174636820657870616e73696f60448201527f6e00000000000000000000000000000000000000000000000000000000000000606482015260840161020f565b82851061033b5760405162461bcd60e51b815260206004820181905260248201527f5072652073697a65206e6f74206c657373207468616e20706f73742073697a65604482015260640161020f565b5f8590505f5f90505f610350855f8751610f9a565b90505b85831015610412575f6103668488610ae9565b9050845183106103b85760405162461bcd60e51b815260206004820152601260248201527f496e646578206f7574206f662072616e67650000000000000000000000000000604482015260640161020f565b6103dc82828786815181106103cf576103cf6114a2565b60200260200101516104ea565b91506001811b6103ec81866114ca565b9450878511156103fe576103fe6114dd565b83610408816114f1565b9450505050610353565b8661041c82610c10565b1461048f5760405162461bcd60e51b815260206004820152602260248201527f506f737420657870616e73696f6e20726f6f74206e6f7420657175616c20706f60448201527f7374000000000000000000000000000000000000000000000000000000000000606482015260840161020f565b835182146104df5760405162461bcd60e51b815260206004820152601660248201527f496e636f6d706c6574652070726f6f6620757361676500000000000000000000604482015260640161020f565b505050505050505050565b60606040831061053c5760405162461bcd60e51b815260206004820152600e60248201527f4c6576656c20746f6f2068696768000000000000000000000000000000000000604482015260640161020f565b5f82900361058c5760405162461bcd60e51b815260206004820152601b60248201527f43616e6e6f7420617070656e6420656d70747920737562747265650000000000604482015260640161020f565b6040845111156105de5760405162461bcd60e51b815260206004820152601a60248201527f4d65726b6c6520657870616e73696f6e20746f6f206c61726765000000000000604482015260640161020f565b83515f0361065b575f6105f28460016114ca565b67ffffffffffffffff81111561060a5761060a6111c1565b604051908082528060200260200182016040528015610633578160200160208202803683370190505b50905082818581518110610649576106496114a2565b6020908102919091010152905061016d565b835183106106d15760405162461bcd60e51b815260206004820152603560248201527f4c6576656c2067726561746572207468616e2068696768657374206c6576656c60448201527f206f662063757272656e7420657870616e73696f6e0000000000000000000000606482015260840161020f565b815f6106dc86610f4b565b90505f6106ea8660026115ec565b6106f490836114ca565b90505f61070083610e07565b61070983610e07565b1161075757875167ffffffffffffffff811115610728576107286111c1565b604051908082528060200260200182016040528015610751578160200160208202803683370190505b506107a7565b87516107649060016114ca565b67ffffffffffffffff81111561077c5761077c6111c1565b6040519080825280602002602001820160405280156107a5578160200160208202803683370190505b505b90506040815111156107fb5760405162461bcd60e51b815260206004820152601c60248201527f417070656e642063726561746573206f76657273697a65207472656500000000604482015260640161020f565b5f5b88518110156109a757878110156108a357888181518110610820576108206114a2565b60200260200101515f5f1b1461089e5760405162461bcd60e51b815260206004820152602260248201527f417070656e642061626f7665206c65617374207369676e69666963616e74206260448201527f6974000000000000000000000000000000000000000000000000000000000000606482015260840161020f565b61099f565b5f8590036108e8578881815181106108bd576108bd6114a2565b60200260200101518282815181106108d7576108d76114a2565b60200260200101818152505061099f565b8881815181106108fa576108fa6114a2565b60200260200101515f5f1b03610930578482828151811061091d5761091d6114a2565b60209081029190910101525f945061099f565b5f5f1b828281518110610945576109456114a2565b602002602001018181525050888181518110610963576109636114a2565b602002602001015185604051602001610986929190918252602082015260400190565b6040516020818303038152906040528051906020012094505b6001016107fd565b5083156109db578381600183516109be91906115f7565b815181106109ce576109ce6114a2565b6020026020010181815250505b80600182516109ea91906115f7565b815181106109fa576109fa6114a2565b60200260200101515f5f1b03610a525760405162461bcd60e51b815260206004820152600f60248201527f4c61737420656e747279207a65726f0000000000000000000000000000000000604482015260640161020f565b979650505050505050565b5f610a91828486604051602001610a7691815260200190565b6040516020818303038152906040528051906020012061110e565b9050808514610ae25760405162461bcd60e51b815260206004820152601760248201527f496e76616c696420696e636c7573696f6e2070726f6f66000000000000000000604482015260640161020f565b5050505050565b5f818310610b395760405162461bcd60e51b815260206004820152601760248201527f5374617274206e6f74206c657373207468616e20656e64000000000000000000604482015260640161020f565b5f610b45838518610e07565b90505f6001610b5483826114ca565b6001901b610b6291906115f7565b90508481168482168115610b8457610b7982610da0565b945050505050610194565b8015610b9357610b7981610e07565b60405162461bcd60e51b815260206004820152601b60248201527f426f7468207920616e64207a2063616e6e6f74206265207a65726f0000000000604482015260640161020f565b6060610191835f84604051602001610bf591815260200190565b604051602081830303815290604052805190602001206104ea565b5f5f825111610c615760405162461bcd60e51b815260206004820152601660248201527f456d707479206d65726b6c6520657870616e73696f6e00000000000000000000604482015260640161020f565b604082511115610cb35760405162461bcd60e51b815260206004820152601a60248201527f4d65726b6c6520657870616e73696f6e20746f6f206c61726765000000000000604482015260640161020f565b5f805b8351811015610d99575f848281518110610cd257610cd26114a2565b60200260200101519050825f5f1b03610d3c578015610d375780925060018551610cfc91906115f7565b8214610d3757604051610d1e9084905f90602001918252602082015260400190565b6040516020818303038152906040528051906020012092505b610d90565b8015610d5b576040805160208101839052908101849052606001610d1e565b604051610d779084905f90602001918252602082015260400190565b6040516020818303038152906040528051906020012092505b50600101610cb6565b5092915050565b5f5f8211610df05760405162461bcd60e51b815260206004820152601c60248201527f5a65726f20686173206e6f207369676e69666963616e74206269747300000000604482015260640161020f565b5f8280610dfe6001826115f7565b1618905061016d815b5f815f03610e575760405162461bcd60e51b815260206004820152601c60248201527f5a65726f20686173206e6f207369676e69666963616e74206269747300000000604482015260640161020f565b7001000000000000000000000000000000008210610e8257608091821c91610e7f90826114ca565b90505b680100000000000000008210610ea557604091821c91610ea290826114ca565b90505b6401000000008210610ec457602091821c91610ec190826114ca565b90505b620100008210610ee157601091821c91610ede90826114ca565b90505b6101008210610efd57600891821c91610efa90826114ca565b90505b60108210610f1857600491821c91610f1590826114ca565b90505b60048210610f3357600291821c91610f3090826114ca565b90505b60028210610f46576101946001826114ca565b919050565b5f80805b8351811015610d9957838181518110610f6a57610f6a6114a2565b60200260200101515f5f1b14610f9257610f858160026115ec565b610f8f90836114ca565b91505b600101610f4f565b6060818310610feb5760405162461bcd60e51b815260206004820152601760248201527f5374617274206e6f74206c657373207468616e20656e64000000000000000000604482015260640161020f565b83518211156110625760405162461bcd60e51b815260206004820152602160248201527f456e64206e6f74206c657373206f7220657175616c207468616e206c656e677460448201527f6800000000000000000000000000000000000000000000000000000000000000606482015260840161020f565b5f61106d84846115f7565b67ffffffffffffffff811115611085576110856111c1565b6040519080825280602002602001820160405280156110ae578160200160208202803683370190505b509050835b83811015611105578581815181106110cd576110cd6114a2565b60200260200101518286836110e291906115f7565b815181106110f2576110f26114a2565b60209081029190910101526001016110b3565b50949350505050565b82515f90610100811115611159576040517ffdac331e00000000000000000000000000000000000000000000000000000000815260048101829052610100602482015260440161020f565b825f5b828110156111b7575f878281518110611177576111776114a2565b60200260200101519050816001901b87165f036111a057825f528060205260405f2092506111ae565b805f528260205260405f2092505b5060010161115c565b5095945050505050565b634e487b7160e01b5f52604160045260245ffd5b5f82601f8301126111e4575f5ffd5b813567ffffffffffffffff8111156111fe576111fe6111c1565b8060051b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f830116810181811067ffffffffffffffff82111715611249576112496111c1565b604052918252602081850181019290810186841115611266575f5ffd5b6020860192505b838310156111b757823581526020928301920161126d565b5f5f5f5f5f5f60c0878903121561129a575f5ffd5b86359550602087013594506040870135935060608701359250608087013567ffffffffffffffff8111156112cc575f5ffd5b6112d889828a016111d5565b92505060a087013567ffffffffffffffff8111156112f4575f5ffd5b61130089828a016111d5565b9150509295509295509295565b5f5f5f6060848603121561131f575f5ffd5b833567ffffffffffffffff811115611335575f5ffd5b611341868287016111d5565b9660208601359650604090950135949350505050565b602080825282518282018190525f918401906040840190835b8181101561138e578351835260209384019390920191600101611370565b509095945050505050565b5f5f5f5f608085870312156113ac575f5ffd5b843593506020850135925060408501359150606085013567ffffffffffffffff8111156113d7575f5ffd5b6113e3878288016111d5565b91505092959194509250565b5f5f60408385031215611400575f5ffd5b50508035926020909101359150565b5f5f60408385031215611420575f5ffd5b823567ffffffffffffffff811115611436575f5ffd5b611442858286016111d5565b95602094909401359450505050565b5f60208284031215611461575f5ffd5b813567ffffffffffffffff811115611477575f5ffd5b611483848285016111d5565b949350505050565b5f6020828403121561149b575f5ffd5b5035919050565b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b80820180821115610194576101946114b6565b634e487b7160e01b5f52600160045260245ffd5b5f60018201611502576115026114b6565b5060010190565b6001815b600184111561154457808504811115611528576115286114b6565b600184161561153657908102905b60019390931c92800261150d565b935093915050565b5f8261155a57506001610194565b8161156657505f610194565b816001811461157c5760028114611586576115a2565b6001915050610194565b60ff841115611597576115976114b6565b50506001821b610194565b5060208310610133831016604e8410600b84101617156115c5575081810a610194565b6115d15f198484611509565b805f19048211156115e4576115e46114b6565b029392505050565b5f610191838361154c565b81810381811115610194576101946114b656fea2646970667358221220b50250972ffd3053756eda7e60ef6d8bb1b579f8eb9552f52f5382594fc3553264736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15`\x0EW__\xFD[Pa\x16@\x80a\0\x1C_9_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\0\x85W_5`\xE0\x1C\x80c\xC2,G\xA4\x11a\0XW\x80c\xC2,G\xA4\x14a\0\xFBW\x80c\xCA\x112S\x14a\x01\x0EW\x80c\xD20\xD2?\x14a\x01!W\x80c\xE6\xBC\xBCe\x14a\x014W__\xFD[\x80c_\xB9\xC3\xD4\x14a\0\x89W\x80cg\x90Z~\x14a\0\x9EW\x80ck\xD5\x89\x93\x14a\0\xC7W\x80c\xBC/\x06@\x14a\0\xDAW[__\xFD[a\0\x9Ca\0\x976`\x04a\x12\x85V[a\x01GV[\0[a\0\xB1a\0\xAC6`\x04a\x13\rV[a\x01]V[`@Qa\0\xBE\x91\x90a\x13WV[`@Q\x80\x91\x03\x90\xF3[a\0\x9Ca\0\xD56`\x04a\x13\x99V[a\x01tV[a\0\xEDa\0\xE86`\x04a\x13\xEFV[a\x01\x86V[`@Q\x90\x81R` \x01a\0\xBEV[a\0\xB1a\x01\t6`\x04a\x14\x0FV[a\x01\x9AV[a\0\xEDa\x01\x1C6`\x04a\x14QV[a\x01\xA6V[a\0\xEDa\x01/6`\x04a\x14\x8BV[a\x01\xB0V[a\0\xEDa\x01B6`\x04a\x14\x8BV[a\x01\xBAV[a\x01U\x86\x86\x86\x86\x86\x86a\x01\xC4V[PPPPPPV[``a\x01j\x84\x84\x84a\x04\xEAV[\x90P[\x93\x92PPPV[a\x01\x80\x84\x84\x84\x84a\n]V[PPPPV[_a\x01\x91\x83\x83a\n\xE9V[\x90P[\x92\x91PPV[``a\x01\x91\x83\x83a\x0B\xDBV[_a\x01\x94\x82a\x0C\x10V[_a\x01\x94\x82a\r\xA0V[_a\x01\x94\x82a\x0E\x07V[_\x85\x11a\x02\x18W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x14`$\x82\x01R\x7FPre-size cannot be 0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[\x85a\x02\"\x83a\x0C\x10V[\x14a\x02oW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FPre expansion root mismatch\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[\x84a\x02y\x83a\x0FKV[\x14a\x02\xECW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7FPre size does not match expansio`D\x82\x01R\x7Fn\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x0FV[\x82\x85\x10a\x03;W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FPre size not less than post size`D\x82\x01R`d\x01a\x02\x0FV[_\x85\x90P__\x90P_a\x03P\x85_\x87Qa\x0F\x9AV[\x90P[\x85\x83\x10\x15a\x04\x12W_a\x03f\x84\x88a\n\xE9V[\x90P\x84Q\x83\x10a\x03\xB8W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x12`$\x82\x01R\x7FIndex out of range\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[a\x03\xDC\x82\x82\x87\x86\x81Q\x81\x10a\x03\xCFWa\x03\xCFa\x14\xA2V[` \x02` \x01\x01Qa\x04\xEAV[\x91P`\x01\x81\x1Ba\x03\xEC\x81\x86a\x14\xCAV[\x94P\x87\x85\x11\x15a\x03\xFEWa\x03\xFEa\x14\xDDV[\x83a\x04\x08\x81a\x14\xF1V[\x94PPPPa\x03SV[\x86a\x04\x1C\x82a\x0C\x10V[\x14a\x04\x8FW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7FPost expansion root not equal po`D\x82\x01R\x7Fst\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x0FV[\x83Q\x82\x14a\x04\xDFW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FIncomplete proof usage\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[PPPPPPPPPV[```@\x83\x10a\x05<W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0E`$\x82\x01R\x7FLevel too high\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[_\x82\x90\x03a\x05\x8CW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FCannot append empty subtree\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[`@\x84Q\x11\x15a\x05\xDEW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FMerkle expansion too large\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[\x83Q_\x03a\x06[W_a\x05\xF2\x84`\x01a\x14\xCAV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x06\nWa\x06\na\x11\xC1V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x063W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P\x82\x81\x85\x81Q\x81\x10a\x06IWa\x06Ia\x14\xA2V[` \x90\x81\x02\x91\x90\x91\x01\x01R\x90Pa\x01mV[\x83Q\x83\x10a\x06\xD1W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`5`$\x82\x01R\x7FLevel greater than highest level`D\x82\x01R\x7F of current expansion\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x0FV[\x81_a\x06\xDC\x86a\x0FKV[\x90P_a\x06\xEA\x86`\x02a\x15\xECV[a\x06\xF4\x90\x83a\x14\xCAV[\x90P_a\x07\0\x83a\x0E\x07V[a\x07\t\x83a\x0E\x07V[\x11a\x07WW\x87Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x07(Wa\x07(a\x11\xC1V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x07QW\x81` \x01` \x82\x02\x806\x837\x01\x90P[Pa\x07\xA7V[\x87Qa\x07d\x90`\x01a\x14\xCAV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x07|Wa\x07|a\x11\xC1V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x07\xA5W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P[\x90P`@\x81Q\x11\x15a\x07\xFBW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FAppend creates oversize tree\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[_[\x88Q\x81\x10\x15a\t\xA7W\x87\x81\x10\x15a\x08\xA3W\x88\x81\x81Q\x81\x10a\x08 Wa\x08 a\x14\xA2V[` \x02` \x01\x01Q__\x1B\x14a\x08\x9EW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7FAppend above least significant b`D\x82\x01R\x7Fit\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x0FV[a\t\x9FV[_\x85\x90\x03a\x08\xE8W\x88\x81\x81Q\x81\x10a\x08\xBDWa\x08\xBDa\x14\xA2V[` \x02` \x01\x01Q\x82\x82\x81Q\x81\x10a\x08\xD7Wa\x08\xD7a\x14\xA2V[` \x02` \x01\x01\x81\x81RPPa\t\x9FV[\x88\x81\x81Q\x81\x10a\x08\xFAWa\x08\xFAa\x14\xA2V[` \x02` \x01\x01Q__\x1B\x03a\t0W\x84\x82\x82\x81Q\x81\x10a\t\x1DWa\t\x1Da\x14\xA2V[` \x90\x81\x02\x91\x90\x91\x01\x01R_\x94Pa\t\x9FV[__\x1B\x82\x82\x81Q\x81\x10a\tEWa\tEa\x14\xA2V[` \x02` \x01\x01\x81\x81RPP\x88\x81\x81Q\x81\x10a\tcWa\tca\x14\xA2V[` \x02` \x01\x01Q\x85`@Q` \x01a\t\x86\x92\x91\x90\x91\x82R` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x94P[`\x01\x01a\x07\xFDV[P\x83\x15a\t\xDBW\x83\x81`\x01\x83Qa\t\xBE\x91\x90a\x15\xF7V[\x81Q\x81\x10a\t\xCEWa\t\xCEa\x14\xA2V[` \x02` \x01\x01\x81\x81RPP[\x80`\x01\x82Qa\t\xEA\x91\x90a\x15\xF7V[\x81Q\x81\x10a\t\xFAWa\t\xFAa\x14\xA2V[` \x02` \x01\x01Q__\x1B\x03a\nRW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0F`$\x82\x01R\x7FLast entry zero\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[\x97\x96PPPPPPPV[_a\n\x91\x82\x84\x86`@Q` \x01a\nv\x91\x81R` \x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 a\x11\x0EV[\x90P\x80\x85\x14a\n\xE2W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FInvalid inclusion proof\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[PPPPPV[_\x81\x83\x10a\x0B9W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FStart not less than end\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[_a\x0BE\x83\x85\x18a\x0E\x07V[\x90P_`\x01a\x0BT\x83\x82a\x14\xCAV[`\x01\x90\x1Ba\x0Bb\x91\x90a\x15\xF7V[\x90P\x84\x81\x16\x84\x82\x16\x81\x15a\x0B\x84Wa\x0By\x82a\r\xA0V[\x94PPPPPa\x01\x94V[\x80\x15a\x0B\x93Wa\x0By\x81a\x0E\x07V[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FBoth y and z cannot be zero\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[``a\x01\x91\x83_\x84`@Q` \x01a\x0B\xF5\x91\x81R` \x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 a\x04\xEAV[__\x82Q\x11a\x0CaW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FEmpty merkle expansion\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[`@\x82Q\x11\x15a\x0C\xB3W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FMerkle expansion too large\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[_\x80[\x83Q\x81\x10\x15a\r\x99W_\x84\x82\x81Q\x81\x10a\x0C\xD2Wa\x0C\xD2a\x14\xA2V[` \x02` \x01\x01Q\x90P\x82__\x1B\x03a\r<W\x80\x15a\r7W\x80\x92P`\x01\x85Qa\x0C\xFC\x91\x90a\x15\xF7V[\x82\x14a\r7W`@Qa\r\x1E\x90\x84\x90_\x90` \x01\x91\x82R` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x92P[a\r\x90V[\x80\x15a\r[W`@\x80Q` \x81\x01\x83\x90R\x90\x81\x01\x84\x90R``\x01a\r\x1EV[`@Qa\rw\x90\x84\x90_\x90` \x01\x91\x82R` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x92P[P`\x01\x01a\x0C\xB6V[P\x92\x91PPV[__\x82\x11a\r\xF0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FZero has no significant bits\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[_\x82\x80a\r\xFE`\x01\x82a\x15\xF7V[\x16\x18\x90Pa\x01m\x81[_\x81_\x03a\x0EWW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FZero has no significant bits\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[p\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x10a\x0E\x82W`\x80\x91\x82\x1C\x91a\x0E\x7F\x90\x82a\x14\xCAV[\x90P[h\x01\0\0\0\0\0\0\0\0\x82\x10a\x0E\xA5W`@\x91\x82\x1C\x91a\x0E\xA2\x90\x82a\x14\xCAV[\x90P[d\x01\0\0\0\0\x82\x10a\x0E\xC4W` \x91\x82\x1C\x91a\x0E\xC1\x90\x82a\x14\xCAV[\x90P[b\x01\0\0\x82\x10a\x0E\xE1W`\x10\x91\x82\x1C\x91a\x0E\xDE\x90\x82a\x14\xCAV[\x90P[a\x01\0\x82\x10a\x0E\xFDW`\x08\x91\x82\x1C\x91a\x0E\xFA\x90\x82a\x14\xCAV[\x90P[`\x10\x82\x10a\x0F\x18W`\x04\x91\x82\x1C\x91a\x0F\x15\x90\x82a\x14\xCAV[\x90P[`\x04\x82\x10a\x0F3W`\x02\x91\x82\x1C\x91a\x0F0\x90\x82a\x14\xCAV[\x90P[`\x02\x82\x10a\x0FFWa\x01\x94`\x01\x82a\x14\xCAV[\x91\x90PV[_\x80\x80[\x83Q\x81\x10\x15a\r\x99W\x83\x81\x81Q\x81\x10a\x0FjWa\x0Fja\x14\xA2V[` \x02` \x01\x01Q__\x1B\x14a\x0F\x92Wa\x0F\x85\x81`\x02a\x15\xECV[a\x0F\x8F\x90\x83a\x14\xCAV[\x91P[`\x01\x01a\x0FOV[``\x81\x83\x10a\x0F\xEBW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FStart not less than end\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[\x83Q\x82\x11\x15a\x10bW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7FEnd not less or equal than lengt`D\x82\x01R\x7Fh\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x0FV[_a\x10m\x84\x84a\x15\xF7V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x10\x85Wa\x10\x85a\x11\xC1V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x10\xAEW\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P\x83[\x83\x81\x10\x15a\x11\x05W\x85\x81\x81Q\x81\x10a\x10\xCDWa\x10\xCDa\x14\xA2V[` \x02` \x01\x01Q\x82\x86\x83a\x10\xE2\x91\x90a\x15\xF7V[\x81Q\x81\x10a\x10\xF2Wa\x10\xF2a\x14\xA2V[` \x90\x81\x02\x91\x90\x91\x01\x01R`\x01\x01a\x10\xB3V[P\x94\x93PPPPV[\x82Q_\x90a\x01\0\x81\x11\x15a\x11YW`@Q\x7F\xFD\xAC3\x1E\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x82\x90Ra\x01\0`$\x82\x01R`D\x01a\x02\x0FV[\x82_[\x82\x81\x10\x15a\x11\xB7W_\x87\x82\x81Q\x81\x10a\x11wWa\x11wa\x14\xA2V[` \x02` \x01\x01Q\x90P\x81`\x01\x90\x1B\x87\x16_\x03a\x11\xA0W\x82_R\x80` R`@_ \x92Pa\x11\xAEV[\x80_R\x82` R`@_ \x92P[P`\x01\x01a\x11\\V[P\x95\x94PPPPPV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[_\x82`\x1F\x83\x01\x12a\x11\xE4W__\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x11\xFEWa\x11\xFEa\x11\xC1V[\x80`\x05\x1B`@Q\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`?\x83\x01\x16\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a\x12IWa\x12Ia\x11\xC1V[`@R\x91\x82R` \x81\x85\x01\x81\x01\x92\x90\x81\x01\x86\x84\x11\x15a\x12fW__\xFD[` \x86\x01\x92P[\x83\x83\x10\x15a\x11\xB7W\x825\x81R` \x92\x83\x01\x92\x01a\x12mV[______`\xC0\x87\x89\x03\x12\x15a\x12\x9AW__\xFD[\x865\x95P` \x87\x015\x94P`@\x87\x015\x93P``\x87\x015\x92P`\x80\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x12\xCCW__\xFD[a\x12\xD8\x89\x82\x8A\x01a\x11\xD5V[\x92PP`\xA0\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x12\xF4W__\xFD[a\x13\0\x89\x82\x8A\x01a\x11\xD5V[\x91PP\x92\x95P\x92\x95P\x92\x95V[___``\x84\x86\x03\x12\x15a\x13\x1FW__\xFD[\x835g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x135W__\xFD[a\x13A\x86\x82\x87\x01a\x11\xD5V[\x96` \x86\x015\x96P`@\x90\x95\x015\x94\x93PPPPV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R_\x91\x84\x01\x90`@\x84\x01\x90\x83[\x81\x81\x10\x15a\x13\x8EW\x83Q\x83R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a\x13pV[P\x90\x95\x94PPPPPV[____`\x80\x85\x87\x03\x12\x15a\x13\xACW__\xFD[\x845\x93P` \x85\x015\x92P`@\x85\x015\x91P``\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x13\xD7W__\xFD[a\x13\xE3\x87\x82\x88\x01a\x11\xD5V[\x91PP\x92\x95\x91\x94P\x92PV[__`@\x83\x85\x03\x12\x15a\x14\0W__\xFD[PP\x805\x92` \x90\x91\x015\x91PV[__`@\x83\x85\x03\x12\x15a\x14 W__\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x146W__\xFD[a\x14B\x85\x82\x86\x01a\x11\xD5V[\x95` \x94\x90\x94\x015\x94PPPPV[_` \x82\x84\x03\x12\x15a\x14aW__\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x14wW__\xFD[a\x14\x83\x84\x82\x85\x01a\x11\xD5V[\x94\x93PPPPV[_` \x82\x84\x03\x12\x15a\x14\x9BW__\xFD[P5\x91\x90PV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x80\x82\x01\x80\x82\x11\x15a\x01\x94Wa\x01\x94a\x14\xB6V[cNH{q`\xE0\x1B_R`\x01`\x04R`$_\xFD[_`\x01\x82\x01a\x15\x02Wa\x15\x02a\x14\xB6V[P`\x01\x01\x90V[`\x01\x81[`\x01\x84\x11\x15a\x15DW\x80\x85\x04\x81\x11\x15a\x15(Wa\x15(a\x14\xB6V[`\x01\x84\x16\x15a\x156W\x90\x81\x02\x90[`\x01\x93\x90\x93\x1C\x92\x80\x02a\x15\rV[\x93P\x93\x91PPV[_\x82a\x15ZWP`\x01a\x01\x94V[\x81a\x15fWP_a\x01\x94V[\x81`\x01\x81\x14a\x15|W`\x02\x81\x14a\x15\x86Wa\x15\xA2V[`\x01\x91PPa\x01\x94V[`\xFF\x84\x11\x15a\x15\x97Wa\x15\x97a\x14\xB6V[PP`\x01\x82\x1Ba\x01\x94V[P` \x83\x10a\x013\x83\x10\x16`N\x84\x10`\x0B\x84\x10\x16\x17\x15a\x15\xC5WP\x81\x81\na\x01\x94V[a\x15\xD1_\x19\x84\x84a\x15\tV[\x80_\x19\x04\x82\x11\x15a\x15\xE4Wa\x15\xE4a\x14\xB6V[\x02\x93\x92PPPV[_a\x01\x91\x83\x83a\x15LV[\x81\x81\x03\x81\x81\x11\x15a\x01\x94Wa\x01\x94a\x14\xB6V\xFE\xA2dipfsX\"\x12 \xB5\x02P\x97/\xFD0Sun\xDA~`\xEFm\x8B\xB1\xB5y\xF8\xEB\x95R\xF5/S\x82YO\xC3U2dsolcC\0\x08\x1C\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f5ffd5b5060043610610085575f3560e01c8063c22c47a411610058578063c22c47a4146100fb578063ca1132531461010e578063d230d23f14610121578063e6bcbc6514610134575f5ffd5b80635fb9c3d41461008957806367905a7e1461009e5780636bd58993146100c7578063bc2f0640146100da575b5f5ffd5b61009c610097366004611285565b610147565b005b6100b16100ac36600461130d565b61015d565b6040516100be9190611357565b60405180910390f35b61009c6100d5366004611399565b610174565b6100ed6100e83660046113ef565b610186565b6040519081526020016100be565b6100b161010936600461140f565b61019a565b6100ed61011c366004611451565b6101a6565b6100ed61012f36600461148b565b6101b0565b6100ed61014236600461148b565b6101ba565b6101558686868686866101c4565b505050505050565b606061016a8484846104ea565b90505b9392505050565b61018084848484610a5d565b50505050565b5f6101918383610ae9565b90505b92915050565b60606101918383610bdb565b5f61019482610c10565b5f61019482610da0565b5f61019482610e07565b5f85116102185760405162461bcd60e51b815260206004820152601460248201527f5072652d73697a652063616e6e6f74206265203000000000000000000000000060448201526064015b60405180910390fd5b8561022283610c10565b1461026f5760405162461bcd60e51b815260206004820152601b60248201527f50726520657870616e73696f6e20726f6f74206d69736d617463680000000000604482015260640161020f565b8461027983610f4b565b146102ec5760405162461bcd60e51b815260206004820152602160248201527f5072652073697a6520646f6573206e6f74206d6174636820657870616e73696f60448201527f6e00000000000000000000000000000000000000000000000000000000000000606482015260840161020f565b82851061033b5760405162461bcd60e51b815260206004820181905260248201527f5072652073697a65206e6f74206c657373207468616e20706f73742073697a65604482015260640161020f565b5f8590505f5f90505f610350855f8751610f9a565b90505b85831015610412575f6103668488610ae9565b9050845183106103b85760405162461bcd60e51b815260206004820152601260248201527f496e646578206f7574206f662072616e67650000000000000000000000000000604482015260640161020f565b6103dc82828786815181106103cf576103cf6114a2565b60200260200101516104ea565b91506001811b6103ec81866114ca565b9450878511156103fe576103fe6114dd565b83610408816114f1565b9450505050610353565b8661041c82610c10565b1461048f5760405162461bcd60e51b815260206004820152602260248201527f506f737420657870616e73696f6e20726f6f74206e6f7420657175616c20706f60448201527f7374000000000000000000000000000000000000000000000000000000000000606482015260840161020f565b835182146104df5760405162461bcd60e51b815260206004820152601660248201527f496e636f6d706c6574652070726f6f6620757361676500000000000000000000604482015260640161020f565b505050505050505050565b60606040831061053c5760405162461bcd60e51b815260206004820152600e60248201527f4c6576656c20746f6f2068696768000000000000000000000000000000000000604482015260640161020f565b5f82900361058c5760405162461bcd60e51b815260206004820152601b60248201527f43616e6e6f7420617070656e6420656d70747920737562747265650000000000604482015260640161020f565b6040845111156105de5760405162461bcd60e51b815260206004820152601a60248201527f4d65726b6c6520657870616e73696f6e20746f6f206c61726765000000000000604482015260640161020f565b83515f0361065b575f6105f28460016114ca565b67ffffffffffffffff81111561060a5761060a6111c1565b604051908082528060200260200182016040528015610633578160200160208202803683370190505b50905082818581518110610649576106496114a2565b6020908102919091010152905061016d565b835183106106d15760405162461bcd60e51b815260206004820152603560248201527f4c6576656c2067726561746572207468616e2068696768657374206c6576656c60448201527f206f662063757272656e7420657870616e73696f6e0000000000000000000000606482015260840161020f565b815f6106dc86610f4b565b90505f6106ea8660026115ec565b6106f490836114ca565b90505f61070083610e07565b61070983610e07565b1161075757875167ffffffffffffffff811115610728576107286111c1565b604051908082528060200260200182016040528015610751578160200160208202803683370190505b506107a7565b87516107649060016114ca565b67ffffffffffffffff81111561077c5761077c6111c1565b6040519080825280602002602001820160405280156107a5578160200160208202803683370190505b505b90506040815111156107fb5760405162461bcd60e51b815260206004820152601c60248201527f417070656e642063726561746573206f76657273697a65207472656500000000604482015260640161020f565b5f5b88518110156109a757878110156108a357888181518110610820576108206114a2565b60200260200101515f5f1b1461089e5760405162461bcd60e51b815260206004820152602260248201527f417070656e642061626f7665206c65617374207369676e69666963616e74206260448201527f6974000000000000000000000000000000000000000000000000000000000000606482015260840161020f565b61099f565b5f8590036108e8578881815181106108bd576108bd6114a2565b60200260200101518282815181106108d7576108d76114a2565b60200260200101818152505061099f565b8881815181106108fa576108fa6114a2565b60200260200101515f5f1b03610930578482828151811061091d5761091d6114a2565b60209081029190910101525f945061099f565b5f5f1b828281518110610945576109456114a2565b602002602001018181525050888181518110610963576109636114a2565b602002602001015185604051602001610986929190918252602082015260400190565b6040516020818303038152906040528051906020012094505b6001016107fd565b5083156109db578381600183516109be91906115f7565b815181106109ce576109ce6114a2565b6020026020010181815250505b80600182516109ea91906115f7565b815181106109fa576109fa6114a2565b60200260200101515f5f1b03610a525760405162461bcd60e51b815260206004820152600f60248201527f4c61737420656e747279207a65726f0000000000000000000000000000000000604482015260640161020f565b979650505050505050565b5f610a91828486604051602001610a7691815260200190565b6040516020818303038152906040528051906020012061110e565b9050808514610ae25760405162461bcd60e51b815260206004820152601760248201527f496e76616c696420696e636c7573696f6e2070726f6f66000000000000000000604482015260640161020f565b5050505050565b5f818310610b395760405162461bcd60e51b815260206004820152601760248201527f5374617274206e6f74206c657373207468616e20656e64000000000000000000604482015260640161020f565b5f610b45838518610e07565b90505f6001610b5483826114ca565b6001901b610b6291906115f7565b90508481168482168115610b8457610b7982610da0565b945050505050610194565b8015610b9357610b7981610e07565b60405162461bcd60e51b815260206004820152601b60248201527f426f7468207920616e64207a2063616e6e6f74206265207a65726f0000000000604482015260640161020f565b6060610191835f84604051602001610bf591815260200190565b604051602081830303815290604052805190602001206104ea565b5f5f825111610c615760405162461bcd60e51b815260206004820152601660248201527f456d707479206d65726b6c6520657870616e73696f6e00000000000000000000604482015260640161020f565b604082511115610cb35760405162461bcd60e51b815260206004820152601a60248201527f4d65726b6c6520657870616e73696f6e20746f6f206c61726765000000000000604482015260640161020f565b5f805b8351811015610d99575f848281518110610cd257610cd26114a2565b60200260200101519050825f5f1b03610d3c578015610d375780925060018551610cfc91906115f7565b8214610d3757604051610d1e9084905f90602001918252602082015260400190565b6040516020818303038152906040528051906020012092505b610d90565b8015610d5b576040805160208101839052908101849052606001610d1e565b604051610d779084905f90602001918252602082015260400190565b6040516020818303038152906040528051906020012092505b50600101610cb6565b5092915050565b5f5f8211610df05760405162461bcd60e51b815260206004820152601c60248201527f5a65726f20686173206e6f207369676e69666963616e74206269747300000000604482015260640161020f565b5f8280610dfe6001826115f7565b1618905061016d815b5f815f03610e575760405162461bcd60e51b815260206004820152601c60248201527f5a65726f20686173206e6f207369676e69666963616e74206269747300000000604482015260640161020f565b7001000000000000000000000000000000008210610e8257608091821c91610e7f90826114ca565b90505b680100000000000000008210610ea557604091821c91610ea290826114ca565b90505b6401000000008210610ec457602091821c91610ec190826114ca565b90505b620100008210610ee157601091821c91610ede90826114ca565b90505b6101008210610efd57600891821c91610efa90826114ca565b90505b60108210610f1857600491821c91610f1590826114ca565b90505b60048210610f3357600291821c91610f3090826114ca565b90505b60028210610f46576101946001826114ca565b919050565b5f80805b8351811015610d9957838181518110610f6a57610f6a6114a2565b60200260200101515f5f1b14610f9257610f858160026115ec565b610f8f90836114ca565b91505b600101610f4f565b6060818310610feb5760405162461bcd60e51b815260206004820152601760248201527f5374617274206e6f74206c657373207468616e20656e64000000000000000000604482015260640161020f565b83518211156110625760405162461bcd60e51b815260206004820152602160248201527f456e64206e6f74206c657373206f7220657175616c207468616e206c656e677460448201527f6800000000000000000000000000000000000000000000000000000000000000606482015260840161020f565b5f61106d84846115f7565b67ffffffffffffffff811115611085576110856111c1565b6040519080825280602002602001820160405280156110ae578160200160208202803683370190505b509050835b83811015611105578581815181106110cd576110cd6114a2565b60200260200101518286836110e291906115f7565b815181106110f2576110f26114a2565b60209081029190910101526001016110b3565b50949350505050565b82515f90610100811115611159576040517ffdac331e00000000000000000000000000000000000000000000000000000000815260048101829052610100602482015260440161020f565b825f5b828110156111b7575f878281518110611177576111776114a2565b60200260200101519050816001901b87165f036111a057825f528060205260405f2092506111ae565b805f528260205260405f2092505b5060010161115c565b5095945050505050565b634e487b7160e01b5f52604160045260245ffd5b5f82601f8301126111e4575f5ffd5b813567ffffffffffffffff8111156111fe576111fe6111c1565b8060051b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f830116810181811067ffffffffffffffff82111715611249576112496111c1565b604052918252602081850181019290810186841115611266575f5ffd5b6020860192505b838310156111b757823581526020928301920161126d565b5f5f5f5f5f5f60c0878903121561129a575f5ffd5b86359550602087013594506040870135935060608701359250608087013567ffffffffffffffff8111156112cc575f5ffd5b6112d889828a016111d5565b92505060a087013567ffffffffffffffff8111156112f4575f5ffd5b61130089828a016111d5565b9150509295509295509295565b5f5f5f6060848603121561131f575f5ffd5b833567ffffffffffffffff811115611335575f5ffd5b611341868287016111d5565b9660208601359650604090950135949350505050565b602080825282518282018190525f918401906040840190835b8181101561138e578351835260209384019390920191600101611370565b509095945050505050565b5f5f5f5f608085870312156113ac575f5ffd5b843593506020850135925060408501359150606085013567ffffffffffffffff8111156113d7575f5ffd5b6113e3878288016111d5565b91505092959194509250565b5f5f60408385031215611400575f5ffd5b50508035926020909101359150565b5f5f60408385031215611420575f5ffd5b823567ffffffffffffffff811115611436575f5ffd5b611442858286016111d5565b95602094909401359450505050565b5f60208284031215611461575f5ffd5b813567ffffffffffffffff811115611477575f5ffd5b611483848285016111d5565b949350505050565b5f6020828403121561149b575f5ffd5b5035919050565b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b80820180821115610194576101946114b6565b634e487b7160e01b5f52600160045260245ffd5b5f60018201611502576115026114b6565b5060010190565b6001815b600184111561154457808504811115611528576115286114b6565b600184161561153657908102905b60019390931c92800261150d565b935093915050565b5f8261155a57506001610194565b8161156657505f610194565b816001811461157c5760028114611586576115a2565b6001915050610194565b60ff841115611597576115976114b6565b50506001821b610194565b5060208310610133831016604e8410600b84101617156115c5575081810a610194565b6115d15f198484611509565b805f19048211156115e4576115e46114b6565b029392505050565b5f610191838361154c565b81810381811115610194576101946114b656fea2646970667358221220b50250972ffd3053756eda7e60ef6d8bb1b579f8eb9552f52f5382594fc3553264736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\0\x85W_5`\xE0\x1C\x80c\xC2,G\xA4\x11a\0XW\x80c\xC2,G\xA4\x14a\0\xFBW\x80c\xCA\x112S\x14a\x01\x0EW\x80c\xD20\xD2?\x14a\x01!W\x80c\xE6\xBC\xBCe\x14a\x014W__\xFD[\x80c_\xB9\xC3\xD4\x14a\0\x89W\x80cg\x90Z~\x14a\0\x9EW\x80ck\xD5\x89\x93\x14a\0\xC7W\x80c\xBC/\x06@\x14a\0\xDAW[__\xFD[a\0\x9Ca\0\x976`\x04a\x12\x85V[a\x01GV[\0[a\0\xB1a\0\xAC6`\x04a\x13\rV[a\x01]V[`@Qa\0\xBE\x91\x90a\x13WV[`@Q\x80\x91\x03\x90\xF3[a\0\x9Ca\0\xD56`\x04a\x13\x99V[a\x01tV[a\0\xEDa\0\xE86`\x04a\x13\xEFV[a\x01\x86V[`@Q\x90\x81R` \x01a\0\xBEV[a\0\xB1a\x01\t6`\x04a\x14\x0FV[a\x01\x9AV[a\0\xEDa\x01\x1C6`\x04a\x14QV[a\x01\xA6V[a\0\xEDa\x01/6`\x04a\x14\x8BV[a\x01\xB0V[a\0\xEDa\x01B6`\x04a\x14\x8BV[a\x01\xBAV[a\x01U\x86\x86\x86\x86\x86\x86a\x01\xC4V[PPPPPPV[``a\x01j\x84\x84\x84a\x04\xEAV[\x90P[\x93\x92PPPV[a\x01\x80\x84\x84\x84\x84a\n]V[PPPPV[_a\x01\x91\x83\x83a\n\xE9V[\x90P[\x92\x91PPV[``a\x01\x91\x83\x83a\x0B\xDBV[_a\x01\x94\x82a\x0C\x10V[_a\x01\x94\x82a\r\xA0V[_a\x01\x94\x82a\x0E\x07V[_\x85\x11a\x02\x18W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x14`$\x82\x01R\x7FPre-size cannot be 0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[\x85a\x02\"\x83a\x0C\x10V[\x14a\x02oW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FPre expansion root mismatch\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[\x84a\x02y\x83a\x0FKV[\x14a\x02\xECW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7FPre size does not match expansio`D\x82\x01R\x7Fn\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x0FV[\x82\x85\x10a\x03;W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FPre size not less than post size`D\x82\x01R`d\x01a\x02\x0FV[_\x85\x90P__\x90P_a\x03P\x85_\x87Qa\x0F\x9AV[\x90P[\x85\x83\x10\x15a\x04\x12W_a\x03f\x84\x88a\n\xE9V[\x90P\x84Q\x83\x10a\x03\xB8W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x12`$\x82\x01R\x7FIndex out of range\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[a\x03\xDC\x82\x82\x87\x86\x81Q\x81\x10a\x03\xCFWa\x03\xCFa\x14\xA2V[` \x02` \x01\x01Qa\x04\xEAV[\x91P`\x01\x81\x1Ba\x03\xEC\x81\x86a\x14\xCAV[\x94P\x87\x85\x11\x15a\x03\xFEWa\x03\xFEa\x14\xDDV[\x83a\x04\x08\x81a\x14\xF1V[\x94PPPPa\x03SV[\x86a\x04\x1C\x82a\x0C\x10V[\x14a\x04\x8FW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7FPost expansion root not equal po`D\x82\x01R\x7Fst\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x0FV[\x83Q\x82\x14a\x04\xDFW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FIncomplete proof usage\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[PPPPPPPPPV[```@\x83\x10a\x05<W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0E`$\x82\x01R\x7FLevel too high\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[_\x82\x90\x03a\x05\x8CW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FCannot append empty subtree\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[`@\x84Q\x11\x15a\x05\xDEW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FMerkle expansion too large\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[\x83Q_\x03a\x06[W_a\x05\xF2\x84`\x01a\x14\xCAV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x06\nWa\x06\na\x11\xC1V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x063W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P\x82\x81\x85\x81Q\x81\x10a\x06IWa\x06Ia\x14\xA2V[` \x90\x81\x02\x91\x90\x91\x01\x01R\x90Pa\x01mV[\x83Q\x83\x10a\x06\xD1W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`5`$\x82\x01R\x7FLevel greater than highest level`D\x82\x01R\x7F of current expansion\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x0FV[\x81_a\x06\xDC\x86a\x0FKV[\x90P_a\x06\xEA\x86`\x02a\x15\xECV[a\x06\xF4\x90\x83a\x14\xCAV[\x90P_a\x07\0\x83a\x0E\x07V[a\x07\t\x83a\x0E\x07V[\x11a\x07WW\x87Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x07(Wa\x07(a\x11\xC1V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x07QW\x81` \x01` \x82\x02\x806\x837\x01\x90P[Pa\x07\xA7V[\x87Qa\x07d\x90`\x01a\x14\xCAV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x07|Wa\x07|a\x11\xC1V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x07\xA5W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P[\x90P`@\x81Q\x11\x15a\x07\xFBW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FAppend creates oversize tree\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[_[\x88Q\x81\x10\x15a\t\xA7W\x87\x81\x10\x15a\x08\xA3W\x88\x81\x81Q\x81\x10a\x08 Wa\x08 a\x14\xA2V[` \x02` \x01\x01Q__\x1B\x14a\x08\x9EW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7FAppend above least significant b`D\x82\x01R\x7Fit\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x0FV[a\t\x9FV[_\x85\x90\x03a\x08\xE8W\x88\x81\x81Q\x81\x10a\x08\xBDWa\x08\xBDa\x14\xA2V[` \x02` \x01\x01Q\x82\x82\x81Q\x81\x10a\x08\xD7Wa\x08\xD7a\x14\xA2V[` \x02` \x01\x01\x81\x81RPPa\t\x9FV[\x88\x81\x81Q\x81\x10a\x08\xFAWa\x08\xFAa\x14\xA2V[` \x02` \x01\x01Q__\x1B\x03a\t0W\x84\x82\x82\x81Q\x81\x10a\t\x1DWa\t\x1Da\x14\xA2V[` \x90\x81\x02\x91\x90\x91\x01\x01R_\x94Pa\t\x9FV[__\x1B\x82\x82\x81Q\x81\x10a\tEWa\tEa\x14\xA2V[` \x02` \x01\x01\x81\x81RPP\x88\x81\x81Q\x81\x10a\tcWa\tca\x14\xA2V[` \x02` \x01\x01Q\x85`@Q` \x01a\t\x86\x92\x91\x90\x91\x82R` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x94P[`\x01\x01a\x07\xFDV[P\x83\x15a\t\xDBW\x83\x81`\x01\x83Qa\t\xBE\x91\x90a\x15\xF7V[\x81Q\x81\x10a\t\xCEWa\t\xCEa\x14\xA2V[` \x02` \x01\x01\x81\x81RPP[\x80`\x01\x82Qa\t\xEA\x91\x90a\x15\xF7V[\x81Q\x81\x10a\t\xFAWa\t\xFAa\x14\xA2V[` \x02` \x01\x01Q__\x1B\x03a\nRW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0F`$\x82\x01R\x7FLast entry zero\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[\x97\x96PPPPPPPV[_a\n\x91\x82\x84\x86`@Q` \x01a\nv\x91\x81R` \x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 a\x11\x0EV[\x90P\x80\x85\x14a\n\xE2W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FInvalid inclusion proof\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[PPPPPV[_\x81\x83\x10a\x0B9W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FStart not less than end\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[_a\x0BE\x83\x85\x18a\x0E\x07V[\x90P_`\x01a\x0BT\x83\x82a\x14\xCAV[`\x01\x90\x1Ba\x0Bb\x91\x90a\x15\xF7V[\x90P\x84\x81\x16\x84\x82\x16\x81\x15a\x0B\x84Wa\x0By\x82a\r\xA0V[\x94PPPPPa\x01\x94V[\x80\x15a\x0B\x93Wa\x0By\x81a\x0E\x07V[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FBoth y and z cannot be zero\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[``a\x01\x91\x83_\x84`@Q` \x01a\x0B\xF5\x91\x81R` \x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 a\x04\xEAV[__\x82Q\x11a\x0CaW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FEmpty merkle expansion\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[`@\x82Q\x11\x15a\x0C\xB3W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FMerkle expansion too large\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[_\x80[\x83Q\x81\x10\x15a\r\x99W_\x84\x82\x81Q\x81\x10a\x0C\xD2Wa\x0C\xD2a\x14\xA2V[` \x02` \x01\x01Q\x90P\x82__\x1B\x03a\r<W\x80\x15a\r7W\x80\x92P`\x01\x85Qa\x0C\xFC\x91\x90a\x15\xF7V[\x82\x14a\r7W`@Qa\r\x1E\x90\x84\x90_\x90` \x01\x91\x82R` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x92P[a\r\x90V[\x80\x15a\r[W`@\x80Q` \x81\x01\x83\x90R\x90\x81\x01\x84\x90R``\x01a\r\x1EV[`@Qa\rw\x90\x84\x90_\x90` \x01\x91\x82R` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x92P[P`\x01\x01a\x0C\xB6V[P\x92\x91PPV[__\x82\x11a\r\xF0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FZero has no significant bits\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[_\x82\x80a\r\xFE`\x01\x82a\x15\xF7V[\x16\x18\x90Pa\x01m\x81[_\x81_\x03a\x0EWW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FZero has no significant bits\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[p\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x10a\x0E\x82W`\x80\x91\x82\x1C\x91a\x0E\x7F\x90\x82a\x14\xCAV[\x90P[h\x01\0\0\0\0\0\0\0\0\x82\x10a\x0E\xA5W`@\x91\x82\x1C\x91a\x0E\xA2\x90\x82a\x14\xCAV[\x90P[d\x01\0\0\0\0\x82\x10a\x0E\xC4W` \x91\x82\x1C\x91a\x0E\xC1\x90\x82a\x14\xCAV[\x90P[b\x01\0\0\x82\x10a\x0E\xE1W`\x10\x91\x82\x1C\x91a\x0E\xDE\x90\x82a\x14\xCAV[\x90P[a\x01\0\x82\x10a\x0E\xFDW`\x08\x91\x82\x1C\x91a\x0E\xFA\x90\x82a\x14\xCAV[\x90P[`\x10\x82\x10a\x0F\x18W`\x04\x91\x82\x1C\x91a\x0F\x15\x90\x82a\x14\xCAV[\x90P[`\x04\x82\x10a\x0F3W`\x02\x91\x82\x1C\x91a\x0F0\x90\x82a\x14\xCAV[\x90P[`\x02\x82\x10a\x0FFWa\x01\x94`\x01\x82a\x14\xCAV[\x91\x90PV[_\x80\x80[\x83Q\x81\x10\x15a\r\x99W\x83\x81\x81Q\x81\x10a\x0FjWa\x0Fja\x14\xA2V[` \x02` \x01\x01Q__\x1B\x14a\x0F\x92Wa\x0F\x85\x81`\x02a\x15\xECV[a\x0F\x8F\x90\x83a\x14\xCAV[\x91P[`\x01\x01a\x0FOV[``\x81\x83\x10a\x0F\xEBW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FStart not less than end\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[\x83Q\x82\x11\x15a\x10bW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7FEnd not less or equal than lengt`D\x82\x01R\x7Fh\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x0FV[_a\x10m\x84\x84a\x15\xF7V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x10\x85Wa\x10\x85a\x11\xC1V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x10\xAEW\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P\x83[\x83\x81\x10\x15a\x11\x05W\x85\x81\x81Q\x81\x10a\x10\xCDWa\x10\xCDa\x14\xA2V[` \x02` \x01\x01Q\x82\x86\x83a\x10\xE2\x91\x90a\x15\xF7V[\x81Q\x81\x10a\x10\xF2Wa\x10\xF2a\x14\xA2V[` \x90\x81\x02\x91\x90\x91\x01\x01R`\x01\x01a\x10\xB3V[P\x94\x93PPPPV[\x82Q_\x90a\x01\0\x81\x11\x15a\x11YW`@Q\x7F\xFD\xAC3\x1E\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x82\x90Ra\x01\0`$\x82\x01R`D\x01a\x02\x0FV[\x82_[\x82\x81\x10\x15a\x11\xB7W_\x87\x82\x81Q\x81\x10a\x11wWa\x11wa\x14\xA2V[` \x02` \x01\x01Q\x90P\x81`\x01\x90\x1B\x87\x16_\x03a\x11\xA0W\x82_R\x80` R`@_ \x92Pa\x11\xAEV[\x80_R\x82` R`@_ \x92P[P`\x01\x01a\x11\\V[P\x95\x94PPPPPV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[_\x82`\x1F\x83\x01\x12a\x11\xE4W__\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x11\xFEWa\x11\xFEa\x11\xC1V[\x80`\x05\x1B`@Q\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`?\x83\x01\x16\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a\x12IWa\x12Ia\x11\xC1V[`@R\x91\x82R` \x81\x85\x01\x81\x01\x92\x90\x81\x01\x86\x84\x11\x15a\x12fW__\xFD[` \x86\x01\x92P[\x83\x83\x10\x15a\x11\xB7W\x825\x81R` \x92\x83\x01\x92\x01a\x12mV[______`\xC0\x87\x89\x03\x12\x15a\x12\x9AW__\xFD[\x865\x95P` \x87\x015\x94P`@\x87\x015\x93P``\x87\x015\x92P`\x80\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x12\xCCW__\xFD[a\x12\xD8\x89\x82\x8A\x01a\x11\xD5V[\x92PP`\xA0\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x12\xF4W__\xFD[a\x13\0\x89\x82\x8A\x01a\x11\xD5V[\x91PP\x92\x95P\x92\x95P\x92\x95V[___``\x84\x86\x03\x12\x15a\x13\x1FW__\xFD[\x835g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x135W__\xFD[a\x13A\x86\x82\x87\x01a\x11\xD5V[\x96` \x86\x015\x96P`@\x90\x95\x015\x94\x93PPPPV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R_\x91\x84\x01\x90`@\x84\x01\x90\x83[\x81\x81\x10\x15a\x13\x8EW\x83Q\x83R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a\x13pV[P\x90\x95\x94PPPPPV[____`\x80\x85\x87\x03\x12\x15a\x13\xACW__\xFD[\x845\x93P` \x85\x015\x92P`@\x85\x015\x91P``\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x13\xD7W__\xFD[a\x13\xE3\x87\x82\x88\x01a\x11\xD5V[\x91PP\x92\x95\x91\x94P\x92PV[__`@\x83\x85\x03\x12\x15a\x14\0W__\xFD[PP\x805\x92` \x90\x91\x015\x91PV[__`@\x83\x85\x03\x12\x15a\x14 W__\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x146W__\xFD[a\x14B\x85\x82\x86\x01a\x11\xD5V[\x95` \x94\x90\x94\x015\x94PPPPV[_` \x82\x84\x03\x12\x15a\x14aW__\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x14wW__\xFD[a\x14\x83\x84\x82\x85\x01a\x11\xD5V[\x94\x93PPPPV[_` \x82\x84\x03\x12\x15a\x14\x9BW__\xFD[P5\x91\x90PV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x80\x82\x01\x80\x82\x11\x15a\x01\x94Wa\x01\x94a\x14\xB6V[cNH{q`\xE0\x1B_R`\x01`\x04R`$_\xFD[_`\x01\x82\x01a\x15\x02Wa\x15\x02a\x14\xB6V[P`\x01\x01\x90V[`\x01\x81[`\x01\x84\x11\x15a\x15DW\x80\x85\x04\x81\x11\x15a\x15(Wa\x15(a\x14\xB6V[`\x01\x84\x16\x15a\x156W\x90\x81\x02\x90[`\x01\x93\x90\x93\x1C\x92\x80\x02a\x15\rV[\x93P\x93\x91PPV[_\x82a\x15ZWP`\x01a\x01\x94V[\x81a\x15fWP_a\x01\x94V[\x81`\x01\x81\x14a\x15|W`\x02\x81\x14a\x15\x86Wa\x15\xA2V[`\x01\x91PPa\x01\x94V[`\xFF\x84\x11\x15a\x15\x97Wa\x15\x97a\x14\xB6V[PP`\x01\x82\x1Ba\x01\x94V[P` \x83\x10a\x013\x83\x10\x16`N\x84\x10`\x0B\x84\x10\x16\x17\x15a\x15\xC5WP\x81\x81\na\x01\x94V[a\x15\xD1_\x19\x84\x84a\x15\tV[\x80_\x19\x04\x82\x11\x15a\x15\xE4Wa\x15\xE4a\x14\xB6V[\x02\x93\x92PPPV[_a\x01\x91\x83\x83a\x15LV[\x81\x81\x03\x81\x81\x11\x15a\x01\x94Wa\x01\x94a\x14\xB6V\xFE\xA2dipfsX\"\x12 \xB5\x02P\x97/\xFD0Sun\xDA~`\xEFm\x8B\xB1\xB5y\xF8\xEB\x95R\xF5/S\x82YO\xC3U2dsolcC\0\x08\x1C\x003",
    );
    /**Custom error with signature `MerkleProofTooLong(uint256,uint256)` and selector `0xfdac331e`.
```solidity
error MerkleProofTooLong(uint256 actualLength, uint256 maxProofLength);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MerkleProofTooLong {
        #[allow(missing_docs)]
        pub actualLength: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub maxProofLength: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<MerkleProofTooLong> for UnderlyingRustTuple<'_> {
            fn from(value: MerkleProofTooLong) -> Self {
                (value.actualLength, value.maxProofLength)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for MerkleProofTooLong {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    actualLength: tuple.0,
                    maxProofLength: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for MerkleProofTooLong {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MerkleProofTooLong(uint256,uint256)";
            const SELECTOR: [u8; 4] = [253u8, 172u8, 51u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.actualLength),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxProofLength),
                )
            }
        }
    };
    /**Function with signature `appendCompleteSubTree(bytes32[],uint256,bytes32)` and selector `0x67905a7e`.
```solidity
function appendCompleteSubTree(bytes32[] memory me, uint256 level, bytes32 subtreeRoot) external pure returns (bytes32[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct appendCompleteSubTreeCall {
        #[allow(missing_docs)]
        pub me: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        #[allow(missing_docs)]
        pub level: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub subtreeRoot: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`appendCompleteSubTree(bytes32[],uint256,bytes32)`](appendCompleteSubTreeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct appendCompleteSubTreeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<appendCompleteSubTreeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: appendCompleteSubTreeCall) -> Self {
                    (value.me, value.level, value.subtreeRoot)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for appendCompleteSubTreeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        me: tuple.0,
                        level: tuple.1,
                        subtreeRoot: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<appendCompleteSubTreeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: appendCompleteSubTreeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for appendCompleteSubTreeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for appendCompleteSubTreeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = appendCompleteSubTreeReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "appendCompleteSubTree(bytes32[],uint256,bytes32)";
            const SELECTOR: [u8; 4] = [103u8, 144u8, 90u8, 126u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.me),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.level),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.subtreeRoot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `appendLeaf(bytes32[],bytes32)` and selector `0xc22c47a4`.
```solidity
function appendLeaf(bytes32[] memory me, bytes32 leaf) external pure returns (bytes32[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct appendLeafCall {
        #[allow(missing_docs)]
        pub me: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        #[allow(missing_docs)]
        pub leaf: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`appendLeaf(bytes32[],bytes32)`](appendLeafCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct appendLeafReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<appendLeafCall> for UnderlyingRustTuple<'_> {
                fn from(value: appendLeafCall) -> Self {
                    (value.me, value.leaf)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for appendLeafCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { me: tuple.0, leaf: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<appendLeafReturn> for UnderlyingRustTuple<'_> {
                fn from(value: appendLeafReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for appendLeafReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for appendLeafCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = appendLeafReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "appendLeaf(bytes32[],bytes32)";
            const SELECTOR: [u8; 4] = [194u8, 44u8, 71u8, 164u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.me),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.leaf),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `leastSignificantBit(uint256)` and selector `0xd230d23f`.
```solidity
function leastSignificantBit(uint256 x) external pure returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct leastSignificantBitCall {
        #[allow(missing_docs)]
        pub x: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`leastSignificantBit(uint256)`](leastSignificantBitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct leastSignificantBitReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<leastSignificantBitCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: leastSignificantBitCall) -> Self {
                    (value.x,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for leastSignificantBitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { x: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<leastSignificantBitReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: leastSignificantBitReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for leastSignificantBitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for leastSignificantBitCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = leastSignificantBitReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "leastSignificantBit(uint256)";
            const SELECTOR: [u8; 4] = [210u8, 48u8, 210u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.x),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `maximumAppendBetween(uint256,uint256)` and selector `0xbc2f0640`.
```solidity
function maximumAppendBetween(uint256 startSize, uint256 endSize) external pure returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct maximumAppendBetweenCall {
        #[allow(missing_docs)]
        pub startSize: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub endSize: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`maximumAppendBetween(uint256,uint256)`](maximumAppendBetweenCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct maximumAppendBetweenReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<maximumAppendBetweenCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: maximumAppendBetweenCall) -> Self {
                    (value.startSize, value.endSize)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for maximumAppendBetweenCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        startSize: tuple.0,
                        endSize: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<maximumAppendBetweenReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: maximumAppendBetweenReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for maximumAppendBetweenReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for maximumAppendBetweenCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = maximumAppendBetweenReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "maximumAppendBetween(uint256,uint256)";
            const SELECTOR: [u8; 4] = [188u8, 47u8, 6u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.startSize),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.endSize),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `mostSignificantBit(uint256)` and selector `0xe6bcbc65`.
```solidity
function mostSignificantBit(uint256 x) external pure returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mostSignificantBitCall {
        #[allow(missing_docs)]
        pub x: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`mostSignificantBit(uint256)`](mostSignificantBitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mostSignificantBitReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mostSignificantBitCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: mostSignificantBitCall) -> Self {
                    (value.x,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for mostSignificantBitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { x: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mostSignificantBitReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: mostSignificantBitReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for mostSignificantBitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mostSignificantBitCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mostSignificantBitReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mostSignificantBit(uint256)";
            const SELECTOR: [u8; 4] = [230u8, 188u8, 188u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.x),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `root(bytes32[])` and selector `0xca113253`.
```solidity
function root(bytes32[] memory me) external pure returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rootCall {
        #[allow(missing_docs)]
        pub me: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
    }
    ///Container type for the return parameters of the [`root(bytes32[])`](rootCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rootReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rootCall> for UnderlyingRustTuple<'_> {
                fn from(value: rootCall) -> Self {
                    (value.me,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rootCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { me: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rootReturn> for UnderlyingRustTuple<'_> {
                fn from(value: rootReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rootReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for rootCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = rootReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "root(bytes32[])";
            const SELECTOR: [u8; 4] = [202u8, 17u8, 50u8, 83u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.me),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `verifyInclusionProof(bytes32,bytes32,uint256,bytes32[])` and selector `0x6bd58993`.
```solidity
function verifyInclusionProof(bytes32 rootHash, bytes32 leaf, uint256 index, bytes32[] memory proof) external pure;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct verifyInclusionProofCall {
        #[allow(missing_docs)]
        pub rootHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub leaf: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub proof: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
    }
    ///Container type for the return parameters of the [`verifyInclusionProof(bytes32,bytes32,uint256,bytes32[])`](verifyInclusionProofCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct verifyInclusionProofReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<verifyInclusionProofCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: verifyInclusionProofCall) -> Self {
                    (value.rootHash, value.leaf, value.index, value.proof)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for verifyInclusionProofCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        rootHash: tuple.0,
                        leaf: tuple.1,
                        index: tuple.2,
                        proof: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<verifyInclusionProofReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: verifyInclusionProofReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for verifyInclusionProofReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for verifyInclusionProofCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = verifyInclusionProofReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "verifyInclusionProof(bytes32,bytes32,uint256,bytes32[])";
            const SELECTOR: [u8; 4] = [107u8, 213u8, 137u8, 147u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rootHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.leaf),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.proof),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `verifyPrefixProof(bytes32,uint256,bytes32,uint256,bytes32[],bytes32[])` and selector `0x5fb9c3d4`.
```solidity
function verifyPrefixProof(bytes32 preRoot, uint256 preSize, bytes32 postRoot, uint256 postSize, bytes32[] memory preExpansion, bytes32[] memory proof) external pure;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct verifyPrefixProofCall {
        #[allow(missing_docs)]
        pub preRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub preSize: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub postRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub postSize: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub preExpansion: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        #[allow(missing_docs)]
        pub proof: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
    }
    ///Container type for the return parameters of the [`verifyPrefixProof(bytes32,uint256,bytes32,uint256,bytes32[],bytes32[])`](verifyPrefixProofCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct verifyPrefixProofReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
                alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<verifyPrefixProofCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: verifyPrefixProofCall) -> Self {
                    (
                        value.preRoot,
                        value.preSize,
                        value.postRoot,
                        value.postSize,
                        value.preExpansion,
                        value.proof,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for verifyPrefixProofCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        preRoot: tuple.0,
                        preSize: tuple.1,
                        postRoot: tuple.2,
                        postSize: tuple.3,
                        preExpansion: tuple.4,
                        proof: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<verifyPrefixProofReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: verifyPrefixProofReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for verifyPrefixProofReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for verifyPrefixProofCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = verifyPrefixProofReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "verifyPrefixProof(bytes32,uint256,bytes32,uint256,bytes32[],bytes32[])";
            const SELECTOR: [u8; 4] = [95u8, 185u8, 195u8, 212u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.preRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.preSize),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.postRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.postSize),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.preExpansion),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.proof),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`MerkleTreeAccess`](self) function calls.
    pub enum MerkleTreeAccessCalls {
        #[allow(missing_docs)]
        appendCompleteSubTree(appendCompleteSubTreeCall),
        #[allow(missing_docs)]
        appendLeaf(appendLeafCall),
        #[allow(missing_docs)]
        leastSignificantBit(leastSignificantBitCall),
        #[allow(missing_docs)]
        maximumAppendBetween(maximumAppendBetweenCall),
        #[allow(missing_docs)]
        mostSignificantBit(mostSignificantBitCall),
        #[allow(missing_docs)]
        root(rootCall),
        #[allow(missing_docs)]
        verifyInclusionProof(verifyInclusionProofCall),
        #[allow(missing_docs)]
        verifyPrefixProof(verifyPrefixProofCall),
    }
    #[automatically_derived]
    impl MerkleTreeAccessCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [95u8, 185u8, 195u8, 212u8],
            [103u8, 144u8, 90u8, 126u8],
            [107u8, 213u8, 137u8, 147u8],
            [188u8, 47u8, 6u8, 64u8],
            [194u8, 44u8, 71u8, 164u8],
            [202u8, 17u8, 50u8, 83u8],
            [210u8, 48u8, 210u8, 63u8],
            [230u8, 188u8, 188u8, 101u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for MerkleTreeAccessCalls {
        const NAME: &'static str = "MerkleTreeAccessCalls";
        const MIN_DATA_LENGTH: usize = 32usize;
        const COUNT: usize = 8usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::appendCompleteSubTree(_) => {
                    <appendCompleteSubTreeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::appendLeaf(_) => {
                    <appendLeafCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::leastSignificantBit(_) => {
                    <leastSignificantBitCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::maximumAppendBetween(_) => {
                    <maximumAppendBetweenCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::mostSignificantBit(_) => {
                    <mostSignificantBitCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::root(_) => <rootCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::verifyInclusionProof(_) => {
                    <verifyInclusionProofCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::verifyPrefixProof(_) => {
                    <verifyPrefixProofCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<MerkleTreeAccessCalls>] = &[
                {
                    fn verifyPrefixProof(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MerkleTreeAccessCalls> {
                        <verifyPrefixProofCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MerkleTreeAccessCalls::verifyPrefixProof)
                    }
                    verifyPrefixProof
                },
                {
                    fn appendCompleteSubTree(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MerkleTreeAccessCalls> {
                        <appendCompleteSubTreeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MerkleTreeAccessCalls::appendCompleteSubTree)
                    }
                    appendCompleteSubTree
                },
                {
                    fn verifyInclusionProof(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MerkleTreeAccessCalls> {
                        <verifyInclusionProofCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MerkleTreeAccessCalls::verifyInclusionProof)
                    }
                    verifyInclusionProof
                },
                {
                    fn maximumAppendBetween(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MerkleTreeAccessCalls> {
                        <maximumAppendBetweenCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MerkleTreeAccessCalls::maximumAppendBetween)
                    }
                    maximumAppendBetween
                },
                {
                    fn appendLeaf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MerkleTreeAccessCalls> {
                        <appendLeafCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MerkleTreeAccessCalls::appendLeaf)
                    }
                    appendLeaf
                },
                {
                    fn root(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MerkleTreeAccessCalls> {
                        <rootCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MerkleTreeAccessCalls::root)
                    }
                    root
                },
                {
                    fn leastSignificantBit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MerkleTreeAccessCalls> {
                        <leastSignificantBitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MerkleTreeAccessCalls::leastSignificantBit)
                    }
                    leastSignificantBit
                },
                {
                    fn mostSignificantBit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MerkleTreeAccessCalls> {
                        <mostSignificantBitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MerkleTreeAccessCalls::mostSignificantBit)
                    }
                    mostSignificantBit
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::appendCompleteSubTree(inner) => {
                    <appendCompleteSubTreeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::appendLeaf(inner) => {
                    <appendLeafCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::leastSignificantBit(inner) => {
                    <leastSignificantBitCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::maximumAppendBetween(inner) => {
                    <maximumAppendBetweenCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::mostSignificantBit(inner) => {
                    <mostSignificantBitCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::root(inner) => {
                    <rootCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::verifyInclusionProof(inner) => {
                    <verifyInclusionProofCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::verifyPrefixProof(inner) => {
                    <verifyPrefixProofCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::appendCompleteSubTree(inner) => {
                    <appendCompleteSubTreeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::appendLeaf(inner) => {
                    <appendLeafCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::leastSignificantBit(inner) => {
                    <leastSignificantBitCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::maximumAppendBetween(inner) => {
                    <maximumAppendBetweenCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::mostSignificantBit(inner) => {
                    <mostSignificantBitCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::root(inner) => {
                    <rootCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::verifyInclusionProof(inner) => {
                    <verifyInclusionProofCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::verifyPrefixProof(inner) => {
                    <verifyPrefixProofCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`MerkleTreeAccess`](self) custom errors.
    pub enum MerkleTreeAccessErrors {
        #[allow(missing_docs)]
        MerkleProofTooLong(MerkleProofTooLong),
    }
    #[automatically_derived]
    impl MerkleTreeAccessErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[[253u8, 172u8, 51u8, 30u8]];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for MerkleTreeAccessErrors {
        const NAME: &'static str = "MerkleTreeAccessErrors";
        const MIN_DATA_LENGTH: usize = 64usize;
        const COUNT: usize = 1usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::MerkleProofTooLong(_) => {
                    <MerkleProofTooLong as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<MerkleTreeAccessErrors>] = &[
                {
                    fn MerkleProofTooLong(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MerkleTreeAccessErrors> {
                        <MerkleProofTooLong as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MerkleTreeAccessErrors::MerkleProofTooLong)
                    }
                    MerkleProofTooLong
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::MerkleProofTooLong(inner) => {
                    <MerkleProofTooLong as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::MerkleProofTooLong(inner) => {
                    <MerkleProofTooLong as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`MerkleTreeAccess`](self) contract instance.

See the [wrapper's documentation](`MerkleTreeAccessInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> MerkleTreeAccessInstance<T, P, N> {
        MerkleTreeAccessInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<MerkleTreeAccessInstance<T, P, N>>,
    > {
        MerkleTreeAccessInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        MerkleTreeAccessInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`MerkleTreeAccess`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`MerkleTreeAccess`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct MerkleTreeAccessInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for MerkleTreeAccessInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("MerkleTreeAccessInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MerkleTreeAccessInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`MerkleTreeAccess`](self) contract instance.

See the [wrapper's documentation](`MerkleTreeAccessInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<MerkleTreeAccessInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> MerkleTreeAccessInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> MerkleTreeAccessInstance<T, P, N> {
            MerkleTreeAccessInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MerkleTreeAccessInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`appendCompleteSubTree`] function.
        pub fn appendCompleteSubTree(
            &self,
            me: alloy::sol_types::private::Vec<
                alloy::sol_types::private::FixedBytes<32>,
            >,
            level: alloy::sol_types::private::primitives::aliases::U256,
            subtreeRoot: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, appendCompleteSubTreeCall, N> {
            self.call_builder(
                &appendCompleteSubTreeCall {
                    me,
                    level,
                    subtreeRoot,
                },
            )
        }
        ///Creates a new call builder for the [`appendLeaf`] function.
        pub fn appendLeaf(
            &self,
            me: alloy::sol_types::private::Vec<
                alloy::sol_types::private::FixedBytes<32>,
            >,
            leaf: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, appendLeafCall, N> {
            self.call_builder(&appendLeafCall { me, leaf })
        }
        ///Creates a new call builder for the [`leastSignificantBit`] function.
        pub fn leastSignificantBit(
            &self,
            x: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, leastSignificantBitCall, N> {
            self.call_builder(&leastSignificantBitCall { x })
        }
        ///Creates a new call builder for the [`maximumAppendBetween`] function.
        pub fn maximumAppendBetween(
            &self,
            startSize: alloy::sol_types::private::primitives::aliases::U256,
            endSize: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, maximumAppendBetweenCall, N> {
            self.call_builder(
                &maximumAppendBetweenCall {
                    startSize,
                    endSize,
                },
            )
        }
        ///Creates a new call builder for the [`mostSignificantBit`] function.
        pub fn mostSignificantBit(
            &self,
            x: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, mostSignificantBitCall, N> {
            self.call_builder(&mostSignificantBitCall { x })
        }
        ///Creates a new call builder for the [`root`] function.
        pub fn root(
            &self,
            me: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
        ) -> alloy_contract::SolCallBuilder<T, &P, rootCall, N> {
            self.call_builder(&rootCall { me })
        }
        ///Creates a new call builder for the [`verifyInclusionProof`] function.
        pub fn verifyInclusionProof(
            &self,
            rootHash: alloy::sol_types::private::FixedBytes<32>,
            leaf: alloy::sol_types::private::FixedBytes<32>,
            index: alloy::sol_types::private::primitives::aliases::U256,
            proof: alloy::sol_types::private::Vec<
                alloy::sol_types::private::FixedBytes<32>,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, verifyInclusionProofCall, N> {
            self.call_builder(
                &verifyInclusionProofCall {
                    rootHash,
                    leaf,
                    index,
                    proof,
                },
            )
        }
        ///Creates a new call builder for the [`verifyPrefixProof`] function.
        pub fn verifyPrefixProof(
            &self,
            preRoot: alloy::sol_types::private::FixedBytes<32>,
            preSize: alloy::sol_types::private::primitives::aliases::U256,
            postRoot: alloy::sol_types::private::FixedBytes<32>,
            postSize: alloy::sol_types::private::primitives::aliases::U256,
            preExpansion: alloy::sol_types::private::Vec<
                alloy::sol_types::private::FixedBytes<32>,
            >,
            proof: alloy::sol_types::private::Vec<
                alloy::sol_types::private::FixedBytes<32>,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, verifyPrefixProofCall, N> {
            self.call_builder(
                &verifyPrefixProofCall {
                    preRoot,
                    preSize,
                    postRoot,
                    postSize,
                    preExpansion,
                    proof,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MerkleTreeAccessInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
