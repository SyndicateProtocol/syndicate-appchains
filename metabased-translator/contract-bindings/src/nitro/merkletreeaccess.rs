/**

Generated by the following Solidity interface...
```solidity
interface MerkleTreeAccess {
    error MerkleProofTooLong(uint256 actualLength, uint256 maxProofLength);

    function appendCompleteSubTree(bytes32[] memory me, uint256 level, bytes32 subtreeRoot) external pure returns (bytes32[] memory);
    function appendLeaf(bytes32[] memory me, bytes32 leaf) external pure returns (bytes32[] memory);
    function leastSignificantBit(uint256 x) external pure returns (uint256);
    function maximumAppendBetween(uint256 startSize, uint256 endSize) external pure returns (uint256);
    function mostSignificantBit(uint256 x) external pure returns (uint256);
    function root(bytes32[] memory me) external pure returns (bytes32);
    function verifyInclusionProof(bytes32 rootHash, bytes32 leaf, uint256 index, bytes32[] memory proof) external pure;
    function verifyPrefixProof(bytes32 preRoot, uint256 preSize, bytes32 postRoot, uint256 postSize, bytes32[] memory preExpansion, bytes32[] memory proof) external pure;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "function",
    "name": "appendCompleteSubTree",
    "inputs": [
      {
        "name": "me",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      },
      {
        "name": "level",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "subtreeRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "appendLeaf",
    "inputs": [
      {
        "name": "me",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      },
      {
        "name": "leaf",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "leastSignificantBit",
    "inputs": [
      {
        "name": "x",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "maximumAppendBetween",
    "inputs": [
      {
        "name": "startSize",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "endSize",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "mostSignificantBit",
    "inputs": [
      {
        "name": "x",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "root",
    "inputs": [
      {
        "name": "me",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "verifyInclusionProof",
    "inputs": [
      {
        "name": "rootHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "leaf",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "proof",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "verifyPrefixProof",
    "inputs": [
      {
        "name": "preRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "preSize",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "postRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "postSize",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "preExpansion",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      },
      {
        "name": "proof",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "error",
    "name": "MerkleProofTooLong",
    "inputs": [
      {
        "name": "actualLength",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxProofLength",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod MerkleTreeAccess {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6080604052348015600e575f80fd5b506116348061001c5f395ff3fe608060405234801561000f575f80fd5b5060043610610085575f3560e01c8063c22c47a411610058578063c22c47a4146100fb578063ca1132531461010e578063d230d23f14610121578063e6bcbc6514610134575f80fd5b80635fb9c3d41461008957806367905a7e1461009e5780636bd58993146100c7578063bc2f0640146100da575b5f80fd5b61009c610097366004611280565b610147565b005b6100b16100ac366004611303565b61015d565b6040516100be919061134d565b60405180910390f35b61009c6100d5366004611390565b610174565b6100ed6100e83660046113e6565b610186565b6040519081526020016100be565b6100b1610109366004611406565b61019a565b6100ed61011c366004611448565b6101a6565b6100ed61012f366004611482565b6101b0565b6100ed610142366004611482565b6101ba565b6101558686868686866101c4565b505050505050565b606061016a8484846104e7565b90505b9392505050565b61018084848484610a5a565b50505050565b5f6101918383610ae6565b90505b92915050565b60606101918383610bd8565b5f61019482610c0d565b5f61019482610d9d565b5f61019482610e04565b5f85116102185760405162461bcd60e51b815260206004820152601460248201527f5072652d73697a652063616e6e6f74206265203000000000000000000000000060448201526064015b60405180910390fd5b8561022283610c0d565b1461026f5760405162461bcd60e51b815260206004820152601b60248201527f50726520657870616e73696f6e20726f6f74206d69736d617463680000000000604482015260640161020f565b8461027983610f48565b146102ec5760405162461bcd60e51b815260206004820152602160248201527f5072652073697a6520646f6573206e6f74206d6174636820657870616e73696f60448201527f6e00000000000000000000000000000000000000000000000000000000000000606482015260840161020f565b82851061033b5760405162461bcd60e51b815260206004820181905260248201527f5072652073697a65206e6f74206c657373207468616e20706f73742073697a65604482015260640161020f565b5f8590505f8061034d855f8751610f97565b90505b8583101561040f575f6103638488610ae6565b9050845183106103b55760405162461bcd60e51b815260206004820152601260248201527f496e646578206f7574206f662072616e67650000000000000000000000000000604482015260640161020f565b6103d982828786815181106103cc576103cc611499565b60200260200101516104e7565b91506001811b6103e981866114c1565b9450878511156103fb576103fb6114d4565b83610405816114e8565b9450505050610350565b8661041982610c0d565b1461048c5760405162461bcd60e51b815260206004820152602260248201527f506f737420657870616e73696f6e20726f6f74206e6f7420657175616c20706f60448201527f7374000000000000000000000000000000000000000000000000000000000000606482015260840161020f565b835182146104dc5760405162461bcd60e51b815260206004820152601660248201527f496e636f6d706c6574652070726f6f6620757361676500000000000000000000604482015260640161020f565b505050505050505050565b6060604083106105395760405162461bcd60e51b815260206004820152600e60248201527f4c6576656c20746f6f2068696768000000000000000000000000000000000000604482015260640161020f565b5f8290036105895760405162461bcd60e51b815260206004820152601b60248201527f43616e6e6f7420617070656e6420656d70747920737562747265650000000000604482015260640161020f565b6040845111156105db5760405162461bcd60e51b815260206004820152601a60248201527f4d65726b6c6520657870616e73696f6e20746f6f206c61726765000000000000604482015260640161020f565b83515f03610658575f6105ef8460016114c1565b67ffffffffffffffff811115610607576106076111be565b604051908082528060200260200182016040528015610630578160200160208202803683370190505b5090508281858151811061064657610646611499565b6020908102919091010152905061016d565b835183106106ce5760405162461bcd60e51b815260206004820152603560248201527f4c6576656c2067726561746572207468616e2068696768657374206c6576656c60448201527f206f662063757272656e7420657870616e73696f6e0000000000000000000000606482015260840161020f565b815f6106d986610f48565b90505f6106e78660026115e0565b6106f190836114c1565b90505f6106fd83610e04565b61070683610e04565b1161075457875167ffffffffffffffff811115610725576107256111be565b60405190808252806020026020018201604052801561074e578160200160208202803683370190505b506107a4565b87516107619060016114c1565b67ffffffffffffffff811115610779576107796111be565b6040519080825280602002602001820160405280156107a2578160200160208202803683370190505b505b90506040815111156107f85760405162461bcd60e51b815260206004820152601c60248201527f417070656e642063726561746573206f76657273697a65207472656500000000604482015260640161020f565b5f5b88518110156109a457878110156108a05788818151811061081d5761081d611499565b60200260200101515f801b1461089b5760405162461bcd60e51b815260206004820152602260248201527f417070656e642061626f7665206c65617374207369676e69666963616e74206260448201527f6974000000000000000000000000000000000000000000000000000000000000606482015260840161020f565b61099c565b5f8590036108e5578881815181106108ba576108ba611499565b60200260200101518282815181106108d4576108d4611499565b60200260200101818152505061099c565b8881815181106108f7576108f7611499565b60200260200101515f801b0361092d578482828151811061091a5761091a611499565b60209081029190910101525f945061099c565b5f801b82828151811061094257610942611499565b60200260200101818152505088818151811061096057610960611499565b602002602001015185604051602001610983929190918252602082015260400190565b6040516020818303038152906040528051906020012094505b6001016107fa565b5083156109d8578381600183516109bb91906115eb565b815181106109cb576109cb611499565b6020026020010181815250505b80600182516109e791906115eb565b815181106109f7576109f7611499565b60200260200101515f801b03610a4f5760405162461bcd60e51b815260206004820152600f60248201527f4c61737420656e747279207a65726f0000000000000000000000000000000000604482015260640161020f565b979650505050505050565b5f610a8e828486604051602001610a7391815260200190565b6040516020818303038152906040528051906020012061110b565b9050808514610adf5760405162461bcd60e51b815260206004820152601760248201527f496e76616c696420696e636c7573696f6e2070726f6f66000000000000000000604482015260640161020f565b5050505050565b5f818310610b365760405162461bcd60e51b815260206004820152601760248201527f5374617274206e6f74206c657373207468616e20656e64000000000000000000604482015260640161020f565b5f610b42838518610e04565b90505f6001610b5183826114c1565b6001901b610b5f91906115eb565b90508481168482168115610b8157610b7682610d9d565b945050505050610194565b8015610b9057610b7681610e04565b60405162461bcd60e51b815260206004820152601b60248201527f426f7468207920616e64207a2063616e6e6f74206265207a65726f0000000000604482015260640161020f565b6060610191835f84604051602001610bf291815260200190565b604051602081830303815290604052805190602001206104e7565b5f80825111610c5e5760405162461bcd60e51b815260206004820152601660248201527f456d707479206d65726b6c6520657870616e73696f6e00000000000000000000604482015260640161020f565b604082511115610cb05760405162461bcd60e51b815260206004820152601a60248201527f4d65726b6c6520657870616e73696f6e20746f6f206c61726765000000000000604482015260640161020f565b5f805b8351811015610d96575f848281518110610ccf57610ccf611499565b60200260200101519050825f801b03610d39578015610d345780925060018551610cf991906115eb565b8214610d3457604051610d1b9084905f90602001918252602082015260400190565b6040516020818303038152906040528051906020012092505b610d8d565b8015610d58576040805160208101839052908101849052606001610d1b565b604051610d749084905f90602001918252602082015260400190565b6040516020818303038152906040528051906020012092505b50600101610cb3565b5092915050565b5f808211610ded5760405162461bcd60e51b815260206004820152601c60248201527f5a65726f20686173206e6f207369676e69666963616e74206269747300000000604482015260640161020f565b5f8280610dfb6001826115eb565b1618905061016d815b5f815f03610e545760405162461bcd60e51b815260206004820152601c60248201527f5a65726f20686173206e6f207369676e69666963616e74206269747300000000604482015260640161020f565b7001000000000000000000000000000000008210610e7f57608091821c91610e7c90826114c1565b90505b680100000000000000008210610ea257604091821c91610e9f90826114c1565b90505b6401000000008210610ec157602091821c91610ebe90826114c1565b90505b620100008210610ede57601091821c91610edb90826114c1565b90505b6101008210610efa57600891821c91610ef790826114c1565b90505b60108210610f1557600491821c91610f1290826114c1565b90505b60048210610f3057600291821c91610f2d90826114c1565b90505b60028210610f43576101946001826114c1565b919050565b5f80805b8351811015610d9657838181518110610f6757610f67611499565b60200260200101515f801b14610f8f57610f828160026115e0565b610f8c90836114c1565b91505b600101610f4c565b6060818310610fe85760405162461bcd60e51b815260206004820152601760248201527f5374617274206e6f74206c657373207468616e20656e64000000000000000000604482015260640161020f565b835182111561105f5760405162461bcd60e51b815260206004820152602160248201527f456e64206e6f74206c657373206f7220657175616c207468616e206c656e677460448201527f6800000000000000000000000000000000000000000000000000000000000000606482015260840161020f565b5f61106a84846115eb565b67ffffffffffffffff811115611082576110826111be565b6040519080825280602002602001820160405280156110ab578160200160208202803683370190505b509050835b83811015611102578581815181106110ca576110ca611499565b60200260200101518286836110df91906115eb565b815181106110ef576110ef611499565b60209081029190910101526001016110b0565b50949350505050565b82515f90610100811115611156576040517ffdac331e00000000000000000000000000000000000000000000000000000000815260048101829052610100602482015260440161020f565b825f5b828110156111b4575f87828151811061117457611174611499565b60200260200101519050816001901b87165f0361119d57825f528060205260405f2092506111ab565b805f528260205260405f2092505b50600101611159565b5095945050505050565b634e487b7160e01b5f52604160045260245ffd5b5f82601f8301126111e1575f80fd5b8135602067ffffffffffffffff808311156111fe576111fe6111be565b8260051b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f83011681018181108482111715611241576112416111be565b6040529384526020818701810194908101925087851115611260575f80fd5b6020870191505b84821015610a4f57813583529183019190830190611267565b5f805f805f8060c08789031215611295575f80fd5b86359550602087013594506040870135935060608701359250608087013567ffffffffffffffff808211156112c8575f80fd5b6112d48a838b016111d2565b935060a08901359150808211156112e9575f80fd5b506112f689828a016111d2565b9150509295509295509295565b5f805f60608486031215611315575f80fd5b833567ffffffffffffffff81111561132b575f80fd5b611337868287016111d2565b9660208601359650604090950135949350505050565b602080825282518282018190525f9190848201906040850190845b8181101561138457835183529284019291840191600101611368565b50909695505050505050565b5f805f80608085870312156113a3575f80fd5b843593506020850135925060408501359150606085013567ffffffffffffffff8111156113ce575f80fd5b6113da878288016111d2565b91505092959194509250565b5f80604083850312156113f7575f80fd5b50508035926020909101359150565b5f8060408385031215611417575f80fd5b823567ffffffffffffffff81111561142d575f80fd5b611439858286016111d2565b95602094909401359450505050565b5f60208284031215611458575f80fd5b813567ffffffffffffffff81111561146e575f80fd5b61147a848285016111d2565b949350505050565b5f60208284031215611492575f80fd5b5035919050565b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b80820180821115610194576101946114ad565b634e487b7160e01b5f52600160045260245ffd5b5f5f1982036114f9576114f96114ad565b5060010190565b600181815b8085111561153a57815f1904821115611520576115206114ad565b8085161561152d57918102915b93841c9390800290611505565b509250929050565b5f8261155057506001610194565b8161155c57505f610194565b8160018114611572576002811461157c57611598565b6001915050610194565b60ff84111561158d5761158d6114ad565b50506001821b610194565b5060208310610133831016604e8410600b84101617156115bb575081810a610194565b6115c58383611500565b805f19048211156115d8576115d86114ad565b029392505050565b5f6101918383611542565b81810381811115610194576101946114ad56fea2646970667358221220f0c383f436f8bb74409d92389c6159440a92e44496c27e0c2bbf4c3fd4bf0fdb64736f6c63430008190033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15`\x0EW_\x80\xFD[Pa\x164\x80a\0\x1C_9_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW_\x80\xFD[P`\x046\x10a\0\x85W_5`\xE0\x1C\x80c\xC2,G\xA4\x11a\0XW\x80c\xC2,G\xA4\x14a\0\xFBW\x80c\xCA\x112S\x14a\x01\x0EW\x80c\xD20\xD2?\x14a\x01!W\x80c\xE6\xBC\xBCe\x14a\x014W_\x80\xFD[\x80c_\xB9\xC3\xD4\x14a\0\x89W\x80cg\x90Z~\x14a\0\x9EW\x80ck\xD5\x89\x93\x14a\0\xC7W\x80c\xBC/\x06@\x14a\0\xDAW[_\x80\xFD[a\0\x9Ca\0\x976`\x04a\x12\x80V[a\x01GV[\0[a\0\xB1a\0\xAC6`\x04a\x13\x03V[a\x01]V[`@Qa\0\xBE\x91\x90a\x13MV[`@Q\x80\x91\x03\x90\xF3[a\0\x9Ca\0\xD56`\x04a\x13\x90V[a\x01tV[a\0\xEDa\0\xE86`\x04a\x13\xE6V[a\x01\x86V[`@Q\x90\x81R` \x01a\0\xBEV[a\0\xB1a\x01\t6`\x04a\x14\x06V[a\x01\x9AV[a\0\xEDa\x01\x1C6`\x04a\x14HV[a\x01\xA6V[a\0\xEDa\x01/6`\x04a\x14\x82V[a\x01\xB0V[a\0\xEDa\x01B6`\x04a\x14\x82V[a\x01\xBAV[a\x01U\x86\x86\x86\x86\x86\x86a\x01\xC4V[PPPPPPV[``a\x01j\x84\x84\x84a\x04\xE7V[\x90P[\x93\x92PPPV[a\x01\x80\x84\x84\x84\x84a\nZV[PPPPV[_a\x01\x91\x83\x83a\n\xE6V[\x90P[\x92\x91PPV[``a\x01\x91\x83\x83a\x0B\xD8V[_a\x01\x94\x82a\x0C\rV[_a\x01\x94\x82a\r\x9DV[_a\x01\x94\x82a\x0E\x04V[_\x85\x11a\x02\x18W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x14`$\x82\x01R\x7FPre-size cannot be 0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[\x85a\x02\"\x83a\x0C\rV[\x14a\x02oW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FPre expansion root mismatch\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[\x84a\x02y\x83a\x0FHV[\x14a\x02\xECW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7FPre size does not match expansio`D\x82\x01R\x7Fn\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x0FV[\x82\x85\x10a\x03;W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FPre size not less than post size`D\x82\x01R`d\x01a\x02\x0FV[_\x85\x90P_\x80a\x03M\x85_\x87Qa\x0F\x97V[\x90P[\x85\x83\x10\x15a\x04\x0FW_a\x03c\x84\x88a\n\xE6V[\x90P\x84Q\x83\x10a\x03\xB5W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x12`$\x82\x01R\x7FIndex out of range\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[a\x03\xD9\x82\x82\x87\x86\x81Q\x81\x10a\x03\xCCWa\x03\xCCa\x14\x99V[` \x02` \x01\x01Qa\x04\xE7V[\x91P`\x01\x81\x1Ba\x03\xE9\x81\x86a\x14\xC1V[\x94P\x87\x85\x11\x15a\x03\xFBWa\x03\xFBa\x14\xD4V[\x83a\x04\x05\x81a\x14\xE8V[\x94PPPPa\x03PV[\x86a\x04\x19\x82a\x0C\rV[\x14a\x04\x8CW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7FPost expansion root not equal po`D\x82\x01R\x7Fst\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x0FV[\x83Q\x82\x14a\x04\xDCW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FIncomplete proof usage\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[PPPPPPPPPV[```@\x83\x10a\x059W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0E`$\x82\x01R\x7FLevel too high\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[_\x82\x90\x03a\x05\x89W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FCannot append empty subtree\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[`@\x84Q\x11\x15a\x05\xDBW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FMerkle expansion too large\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[\x83Q_\x03a\x06XW_a\x05\xEF\x84`\x01a\x14\xC1V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x06\x07Wa\x06\x07a\x11\xBEV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x060W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P\x82\x81\x85\x81Q\x81\x10a\x06FWa\x06Fa\x14\x99V[` \x90\x81\x02\x91\x90\x91\x01\x01R\x90Pa\x01mV[\x83Q\x83\x10a\x06\xCEW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`5`$\x82\x01R\x7FLevel greater than highest level`D\x82\x01R\x7F of current expansion\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x0FV[\x81_a\x06\xD9\x86a\x0FHV[\x90P_a\x06\xE7\x86`\x02a\x15\xE0V[a\x06\xF1\x90\x83a\x14\xC1V[\x90P_a\x06\xFD\x83a\x0E\x04V[a\x07\x06\x83a\x0E\x04V[\x11a\x07TW\x87Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x07%Wa\x07%a\x11\xBEV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x07NW\x81` \x01` \x82\x02\x806\x837\x01\x90P[Pa\x07\xA4V[\x87Qa\x07a\x90`\x01a\x14\xC1V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x07yWa\x07ya\x11\xBEV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x07\xA2W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P[\x90P`@\x81Q\x11\x15a\x07\xF8W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FAppend creates oversize tree\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[_[\x88Q\x81\x10\x15a\t\xA4W\x87\x81\x10\x15a\x08\xA0W\x88\x81\x81Q\x81\x10a\x08\x1DWa\x08\x1Da\x14\x99V[` \x02` \x01\x01Q_\x80\x1B\x14a\x08\x9BW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7FAppend above least significant b`D\x82\x01R\x7Fit\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x0FV[a\t\x9CV[_\x85\x90\x03a\x08\xE5W\x88\x81\x81Q\x81\x10a\x08\xBAWa\x08\xBAa\x14\x99V[` \x02` \x01\x01Q\x82\x82\x81Q\x81\x10a\x08\xD4Wa\x08\xD4a\x14\x99V[` \x02` \x01\x01\x81\x81RPPa\t\x9CV[\x88\x81\x81Q\x81\x10a\x08\xF7Wa\x08\xF7a\x14\x99V[` \x02` \x01\x01Q_\x80\x1B\x03a\t-W\x84\x82\x82\x81Q\x81\x10a\t\x1AWa\t\x1Aa\x14\x99V[` \x90\x81\x02\x91\x90\x91\x01\x01R_\x94Pa\t\x9CV[_\x80\x1B\x82\x82\x81Q\x81\x10a\tBWa\tBa\x14\x99V[` \x02` \x01\x01\x81\x81RPP\x88\x81\x81Q\x81\x10a\t`Wa\t`a\x14\x99V[` \x02` \x01\x01Q\x85`@Q` \x01a\t\x83\x92\x91\x90\x91\x82R` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x94P[`\x01\x01a\x07\xFAV[P\x83\x15a\t\xD8W\x83\x81`\x01\x83Qa\t\xBB\x91\x90a\x15\xEBV[\x81Q\x81\x10a\t\xCBWa\t\xCBa\x14\x99V[` \x02` \x01\x01\x81\x81RPP[\x80`\x01\x82Qa\t\xE7\x91\x90a\x15\xEBV[\x81Q\x81\x10a\t\xF7Wa\t\xF7a\x14\x99V[` \x02` \x01\x01Q_\x80\x1B\x03a\nOW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0F`$\x82\x01R\x7FLast entry zero\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[\x97\x96PPPPPPPV[_a\n\x8E\x82\x84\x86`@Q` \x01a\ns\x91\x81R` \x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 a\x11\x0BV[\x90P\x80\x85\x14a\n\xDFW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FInvalid inclusion proof\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[PPPPPV[_\x81\x83\x10a\x0B6W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FStart not less than end\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[_a\x0BB\x83\x85\x18a\x0E\x04V[\x90P_`\x01a\x0BQ\x83\x82a\x14\xC1V[`\x01\x90\x1Ba\x0B_\x91\x90a\x15\xEBV[\x90P\x84\x81\x16\x84\x82\x16\x81\x15a\x0B\x81Wa\x0Bv\x82a\r\x9DV[\x94PPPPPa\x01\x94V[\x80\x15a\x0B\x90Wa\x0Bv\x81a\x0E\x04V[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FBoth y and z cannot be zero\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[``a\x01\x91\x83_\x84`@Q` \x01a\x0B\xF2\x91\x81R` \x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 a\x04\xE7V[_\x80\x82Q\x11a\x0C^W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FEmpty merkle expansion\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[`@\x82Q\x11\x15a\x0C\xB0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FMerkle expansion too large\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[_\x80[\x83Q\x81\x10\x15a\r\x96W_\x84\x82\x81Q\x81\x10a\x0C\xCFWa\x0C\xCFa\x14\x99V[` \x02` \x01\x01Q\x90P\x82_\x80\x1B\x03a\r9W\x80\x15a\r4W\x80\x92P`\x01\x85Qa\x0C\xF9\x91\x90a\x15\xEBV[\x82\x14a\r4W`@Qa\r\x1B\x90\x84\x90_\x90` \x01\x91\x82R` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x92P[a\r\x8DV[\x80\x15a\rXW`@\x80Q` \x81\x01\x83\x90R\x90\x81\x01\x84\x90R``\x01a\r\x1BV[`@Qa\rt\x90\x84\x90_\x90` \x01\x91\x82R` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x92P[P`\x01\x01a\x0C\xB3V[P\x92\x91PPV[_\x80\x82\x11a\r\xEDW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FZero has no significant bits\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[_\x82\x80a\r\xFB`\x01\x82a\x15\xEBV[\x16\x18\x90Pa\x01m\x81[_\x81_\x03a\x0ETW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FZero has no significant bits\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[p\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x10a\x0E\x7FW`\x80\x91\x82\x1C\x91a\x0E|\x90\x82a\x14\xC1V[\x90P[h\x01\0\0\0\0\0\0\0\0\x82\x10a\x0E\xA2W`@\x91\x82\x1C\x91a\x0E\x9F\x90\x82a\x14\xC1V[\x90P[d\x01\0\0\0\0\x82\x10a\x0E\xC1W` \x91\x82\x1C\x91a\x0E\xBE\x90\x82a\x14\xC1V[\x90P[b\x01\0\0\x82\x10a\x0E\xDEW`\x10\x91\x82\x1C\x91a\x0E\xDB\x90\x82a\x14\xC1V[\x90P[a\x01\0\x82\x10a\x0E\xFAW`\x08\x91\x82\x1C\x91a\x0E\xF7\x90\x82a\x14\xC1V[\x90P[`\x10\x82\x10a\x0F\x15W`\x04\x91\x82\x1C\x91a\x0F\x12\x90\x82a\x14\xC1V[\x90P[`\x04\x82\x10a\x0F0W`\x02\x91\x82\x1C\x91a\x0F-\x90\x82a\x14\xC1V[\x90P[`\x02\x82\x10a\x0FCWa\x01\x94`\x01\x82a\x14\xC1V[\x91\x90PV[_\x80\x80[\x83Q\x81\x10\x15a\r\x96W\x83\x81\x81Q\x81\x10a\x0FgWa\x0Fga\x14\x99V[` \x02` \x01\x01Q_\x80\x1B\x14a\x0F\x8FWa\x0F\x82\x81`\x02a\x15\xE0V[a\x0F\x8C\x90\x83a\x14\xC1V[\x91P[`\x01\x01a\x0FLV[``\x81\x83\x10a\x0F\xE8W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FStart not less than end\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[\x83Q\x82\x11\x15a\x10_W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7FEnd not less or equal than lengt`D\x82\x01R\x7Fh\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x0FV[_a\x10j\x84\x84a\x15\xEBV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x10\x82Wa\x10\x82a\x11\xBEV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x10\xABW\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P\x83[\x83\x81\x10\x15a\x11\x02W\x85\x81\x81Q\x81\x10a\x10\xCAWa\x10\xCAa\x14\x99V[` \x02` \x01\x01Q\x82\x86\x83a\x10\xDF\x91\x90a\x15\xEBV[\x81Q\x81\x10a\x10\xEFWa\x10\xEFa\x14\x99V[` \x90\x81\x02\x91\x90\x91\x01\x01R`\x01\x01a\x10\xB0V[P\x94\x93PPPPV[\x82Q_\x90a\x01\0\x81\x11\x15a\x11VW`@Q\x7F\xFD\xAC3\x1E\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x82\x90Ra\x01\0`$\x82\x01R`D\x01a\x02\x0FV[\x82_[\x82\x81\x10\x15a\x11\xB4W_\x87\x82\x81Q\x81\x10a\x11tWa\x11ta\x14\x99V[` \x02` \x01\x01Q\x90P\x81`\x01\x90\x1B\x87\x16_\x03a\x11\x9DW\x82_R\x80` R`@_ \x92Pa\x11\xABV[\x80_R\x82` R`@_ \x92P[P`\x01\x01a\x11YV[P\x95\x94PPPPPV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[_\x82`\x1F\x83\x01\x12a\x11\xE1W_\x80\xFD[\x815` g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x83\x11\x15a\x11\xFEWa\x11\xFEa\x11\xBEV[\x82`\x05\x1B`@Q\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`?\x83\x01\x16\x81\x01\x81\x81\x10\x84\x82\x11\x17\x15a\x12AWa\x12Aa\x11\xBEV[`@R\x93\x84R` \x81\x87\x01\x81\x01\x94\x90\x81\x01\x92P\x87\x85\x11\x15a\x12`W_\x80\xFD[` \x87\x01\x91P[\x84\x82\x10\x15a\nOW\x815\x83R\x91\x83\x01\x91\x90\x83\x01\x90a\x12gV[_\x80_\x80_\x80`\xC0\x87\x89\x03\x12\x15a\x12\x95W_\x80\xFD[\x865\x95P` \x87\x015\x94P`@\x87\x015\x93P``\x87\x015\x92P`\x80\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\x12\xC8W_\x80\xFD[a\x12\xD4\x8A\x83\x8B\x01a\x11\xD2V[\x93P`\xA0\x89\x015\x91P\x80\x82\x11\x15a\x12\xE9W_\x80\xFD[Pa\x12\xF6\x89\x82\x8A\x01a\x11\xD2V[\x91PP\x92\x95P\x92\x95P\x92\x95V[_\x80_``\x84\x86\x03\x12\x15a\x13\x15W_\x80\xFD[\x835g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x13+W_\x80\xFD[a\x137\x86\x82\x87\x01a\x11\xD2V[\x96` \x86\x015\x96P`@\x90\x95\x015\x94\x93PPPPV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R_\x91\x90\x84\x82\x01\x90`@\x85\x01\x90\x84[\x81\x81\x10\x15a\x13\x84W\x83Q\x83R\x92\x84\x01\x92\x91\x84\x01\x91`\x01\x01a\x13hV[P\x90\x96\x95PPPPPPV[_\x80_\x80`\x80\x85\x87\x03\x12\x15a\x13\xA3W_\x80\xFD[\x845\x93P` \x85\x015\x92P`@\x85\x015\x91P``\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x13\xCEW_\x80\xFD[a\x13\xDA\x87\x82\x88\x01a\x11\xD2V[\x91PP\x92\x95\x91\x94P\x92PV[_\x80`@\x83\x85\x03\x12\x15a\x13\xF7W_\x80\xFD[PP\x805\x92` \x90\x91\x015\x91PV[_\x80`@\x83\x85\x03\x12\x15a\x14\x17W_\x80\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x14-W_\x80\xFD[a\x149\x85\x82\x86\x01a\x11\xD2V[\x95` \x94\x90\x94\x015\x94PPPPV[_` \x82\x84\x03\x12\x15a\x14XW_\x80\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x14nW_\x80\xFD[a\x14z\x84\x82\x85\x01a\x11\xD2V[\x94\x93PPPPV[_` \x82\x84\x03\x12\x15a\x14\x92W_\x80\xFD[P5\x91\x90PV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x80\x82\x01\x80\x82\x11\x15a\x01\x94Wa\x01\x94a\x14\xADV[cNH{q`\xE0\x1B_R`\x01`\x04R`$_\xFD[__\x19\x82\x03a\x14\xF9Wa\x14\xF9a\x14\xADV[P`\x01\x01\x90V[`\x01\x81\x81[\x80\x85\x11\x15a\x15:W\x81_\x19\x04\x82\x11\x15a\x15 Wa\x15 a\x14\xADV[\x80\x85\x16\x15a\x15-W\x91\x81\x02\x91[\x93\x84\x1C\x93\x90\x80\x02\x90a\x15\x05V[P\x92P\x92\x90PV[_\x82a\x15PWP`\x01a\x01\x94V[\x81a\x15\\WP_a\x01\x94V[\x81`\x01\x81\x14a\x15rW`\x02\x81\x14a\x15|Wa\x15\x98V[`\x01\x91PPa\x01\x94V[`\xFF\x84\x11\x15a\x15\x8DWa\x15\x8Da\x14\xADV[PP`\x01\x82\x1Ba\x01\x94V[P` \x83\x10a\x013\x83\x10\x16`N\x84\x10`\x0B\x84\x10\x16\x17\x15a\x15\xBBWP\x81\x81\na\x01\x94V[a\x15\xC5\x83\x83a\x15\0V[\x80_\x19\x04\x82\x11\x15a\x15\xD8Wa\x15\xD8a\x14\xADV[\x02\x93\x92PPPV[_a\x01\x91\x83\x83a\x15BV[\x81\x81\x03\x81\x81\x11\x15a\x01\x94Wa\x01\x94a\x14\xADV\xFE\xA2dipfsX\"\x12 \xF0\xC3\x83\xF46\xF8\xBBt@\x9D\x928\x9CaYD\n\x92\xE4D\x96\xC2~\x0C+\xBFL?\xD4\xBF\x0F\xDBdsolcC\0\x08\x19\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f80fd5b5060043610610085575f3560e01c8063c22c47a411610058578063c22c47a4146100fb578063ca1132531461010e578063d230d23f14610121578063e6bcbc6514610134575f80fd5b80635fb9c3d41461008957806367905a7e1461009e5780636bd58993146100c7578063bc2f0640146100da575b5f80fd5b61009c610097366004611280565b610147565b005b6100b16100ac366004611303565b61015d565b6040516100be919061134d565b60405180910390f35b61009c6100d5366004611390565b610174565b6100ed6100e83660046113e6565b610186565b6040519081526020016100be565b6100b1610109366004611406565b61019a565b6100ed61011c366004611448565b6101a6565b6100ed61012f366004611482565b6101b0565b6100ed610142366004611482565b6101ba565b6101558686868686866101c4565b505050505050565b606061016a8484846104e7565b90505b9392505050565b61018084848484610a5a565b50505050565b5f6101918383610ae6565b90505b92915050565b60606101918383610bd8565b5f61019482610c0d565b5f61019482610d9d565b5f61019482610e04565b5f85116102185760405162461bcd60e51b815260206004820152601460248201527f5072652d73697a652063616e6e6f74206265203000000000000000000000000060448201526064015b60405180910390fd5b8561022283610c0d565b1461026f5760405162461bcd60e51b815260206004820152601b60248201527f50726520657870616e73696f6e20726f6f74206d69736d617463680000000000604482015260640161020f565b8461027983610f48565b146102ec5760405162461bcd60e51b815260206004820152602160248201527f5072652073697a6520646f6573206e6f74206d6174636820657870616e73696f60448201527f6e00000000000000000000000000000000000000000000000000000000000000606482015260840161020f565b82851061033b5760405162461bcd60e51b815260206004820181905260248201527f5072652073697a65206e6f74206c657373207468616e20706f73742073697a65604482015260640161020f565b5f8590505f8061034d855f8751610f97565b90505b8583101561040f575f6103638488610ae6565b9050845183106103b55760405162461bcd60e51b815260206004820152601260248201527f496e646578206f7574206f662072616e67650000000000000000000000000000604482015260640161020f565b6103d982828786815181106103cc576103cc611499565b60200260200101516104e7565b91506001811b6103e981866114c1565b9450878511156103fb576103fb6114d4565b83610405816114e8565b9450505050610350565b8661041982610c0d565b1461048c5760405162461bcd60e51b815260206004820152602260248201527f506f737420657870616e73696f6e20726f6f74206e6f7420657175616c20706f60448201527f7374000000000000000000000000000000000000000000000000000000000000606482015260840161020f565b835182146104dc5760405162461bcd60e51b815260206004820152601660248201527f496e636f6d706c6574652070726f6f6620757361676500000000000000000000604482015260640161020f565b505050505050505050565b6060604083106105395760405162461bcd60e51b815260206004820152600e60248201527f4c6576656c20746f6f2068696768000000000000000000000000000000000000604482015260640161020f565b5f8290036105895760405162461bcd60e51b815260206004820152601b60248201527f43616e6e6f7420617070656e6420656d70747920737562747265650000000000604482015260640161020f565b6040845111156105db5760405162461bcd60e51b815260206004820152601a60248201527f4d65726b6c6520657870616e73696f6e20746f6f206c61726765000000000000604482015260640161020f565b83515f03610658575f6105ef8460016114c1565b67ffffffffffffffff811115610607576106076111be565b604051908082528060200260200182016040528015610630578160200160208202803683370190505b5090508281858151811061064657610646611499565b6020908102919091010152905061016d565b835183106106ce5760405162461bcd60e51b815260206004820152603560248201527f4c6576656c2067726561746572207468616e2068696768657374206c6576656c60448201527f206f662063757272656e7420657870616e73696f6e0000000000000000000000606482015260840161020f565b815f6106d986610f48565b90505f6106e78660026115e0565b6106f190836114c1565b90505f6106fd83610e04565b61070683610e04565b1161075457875167ffffffffffffffff811115610725576107256111be565b60405190808252806020026020018201604052801561074e578160200160208202803683370190505b506107a4565b87516107619060016114c1565b67ffffffffffffffff811115610779576107796111be565b6040519080825280602002602001820160405280156107a2578160200160208202803683370190505b505b90506040815111156107f85760405162461bcd60e51b815260206004820152601c60248201527f417070656e642063726561746573206f76657273697a65207472656500000000604482015260640161020f565b5f5b88518110156109a457878110156108a05788818151811061081d5761081d611499565b60200260200101515f801b1461089b5760405162461bcd60e51b815260206004820152602260248201527f417070656e642061626f7665206c65617374207369676e69666963616e74206260448201527f6974000000000000000000000000000000000000000000000000000000000000606482015260840161020f565b61099c565b5f8590036108e5578881815181106108ba576108ba611499565b60200260200101518282815181106108d4576108d4611499565b60200260200101818152505061099c565b8881815181106108f7576108f7611499565b60200260200101515f801b0361092d578482828151811061091a5761091a611499565b60209081029190910101525f945061099c565b5f801b82828151811061094257610942611499565b60200260200101818152505088818151811061096057610960611499565b602002602001015185604051602001610983929190918252602082015260400190565b6040516020818303038152906040528051906020012094505b6001016107fa565b5083156109d8578381600183516109bb91906115eb565b815181106109cb576109cb611499565b6020026020010181815250505b80600182516109e791906115eb565b815181106109f7576109f7611499565b60200260200101515f801b03610a4f5760405162461bcd60e51b815260206004820152600f60248201527f4c61737420656e747279207a65726f0000000000000000000000000000000000604482015260640161020f565b979650505050505050565b5f610a8e828486604051602001610a7391815260200190565b6040516020818303038152906040528051906020012061110b565b9050808514610adf5760405162461bcd60e51b815260206004820152601760248201527f496e76616c696420696e636c7573696f6e2070726f6f66000000000000000000604482015260640161020f565b5050505050565b5f818310610b365760405162461bcd60e51b815260206004820152601760248201527f5374617274206e6f74206c657373207468616e20656e64000000000000000000604482015260640161020f565b5f610b42838518610e04565b90505f6001610b5183826114c1565b6001901b610b5f91906115eb565b90508481168482168115610b8157610b7682610d9d565b945050505050610194565b8015610b9057610b7681610e04565b60405162461bcd60e51b815260206004820152601b60248201527f426f7468207920616e64207a2063616e6e6f74206265207a65726f0000000000604482015260640161020f565b6060610191835f84604051602001610bf291815260200190565b604051602081830303815290604052805190602001206104e7565b5f80825111610c5e5760405162461bcd60e51b815260206004820152601660248201527f456d707479206d65726b6c6520657870616e73696f6e00000000000000000000604482015260640161020f565b604082511115610cb05760405162461bcd60e51b815260206004820152601a60248201527f4d65726b6c6520657870616e73696f6e20746f6f206c61726765000000000000604482015260640161020f565b5f805b8351811015610d96575f848281518110610ccf57610ccf611499565b60200260200101519050825f801b03610d39578015610d345780925060018551610cf991906115eb565b8214610d3457604051610d1b9084905f90602001918252602082015260400190565b6040516020818303038152906040528051906020012092505b610d8d565b8015610d58576040805160208101839052908101849052606001610d1b565b604051610d749084905f90602001918252602082015260400190565b6040516020818303038152906040528051906020012092505b50600101610cb3565b5092915050565b5f808211610ded5760405162461bcd60e51b815260206004820152601c60248201527f5a65726f20686173206e6f207369676e69666963616e74206269747300000000604482015260640161020f565b5f8280610dfb6001826115eb565b1618905061016d815b5f815f03610e545760405162461bcd60e51b815260206004820152601c60248201527f5a65726f20686173206e6f207369676e69666963616e74206269747300000000604482015260640161020f565b7001000000000000000000000000000000008210610e7f57608091821c91610e7c90826114c1565b90505b680100000000000000008210610ea257604091821c91610e9f90826114c1565b90505b6401000000008210610ec157602091821c91610ebe90826114c1565b90505b620100008210610ede57601091821c91610edb90826114c1565b90505b6101008210610efa57600891821c91610ef790826114c1565b90505b60108210610f1557600491821c91610f1290826114c1565b90505b60048210610f3057600291821c91610f2d90826114c1565b90505b60028210610f43576101946001826114c1565b919050565b5f80805b8351811015610d9657838181518110610f6757610f67611499565b60200260200101515f801b14610f8f57610f828160026115e0565b610f8c90836114c1565b91505b600101610f4c565b6060818310610fe85760405162461bcd60e51b815260206004820152601760248201527f5374617274206e6f74206c657373207468616e20656e64000000000000000000604482015260640161020f565b835182111561105f5760405162461bcd60e51b815260206004820152602160248201527f456e64206e6f74206c657373206f7220657175616c207468616e206c656e677460448201527f6800000000000000000000000000000000000000000000000000000000000000606482015260840161020f565b5f61106a84846115eb565b67ffffffffffffffff811115611082576110826111be565b6040519080825280602002602001820160405280156110ab578160200160208202803683370190505b509050835b83811015611102578581815181106110ca576110ca611499565b60200260200101518286836110df91906115eb565b815181106110ef576110ef611499565b60209081029190910101526001016110b0565b50949350505050565b82515f90610100811115611156576040517ffdac331e00000000000000000000000000000000000000000000000000000000815260048101829052610100602482015260440161020f565b825f5b828110156111b4575f87828151811061117457611174611499565b60200260200101519050816001901b87165f0361119d57825f528060205260405f2092506111ab565b805f528260205260405f2092505b50600101611159565b5095945050505050565b634e487b7160e01b5f52604160045260245ffd5b5f82601f8301126111e1575f80fd5b8135602067ffffffffffffffff808311156111fe576111fe6111be565b8260051b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f83011681018181108482111715611241576112416111be565b6040529384526020818701810194908101925087851115611260575f80fd5b6020870191505b84821015610a4f57813583529183019190830190611267565b5f805f805f8060c08789031215611295575f80fd5b86359550602087013594506040870135935060608701359250608087013567ffffffffffffffff808211156112c8575f80fd5b6112d48a838b016111d2565b935060a08901359150808211156112e9575f80fd5b506112f689828a016111d2565b9150509295509295509295565b5f805f60608486031215611315575f80fd5b833567ffffffffffffffff81111561132b575f80fd5b611337868287016111d2565b9660208601359650604090950135949350505050565b602080825282518282018190525f9190848201906040850190845b8181101561138457835183529284019291840191600101611368565b50909695505050505050565b5f805f80608085870312156113a3575f80fd5b843593506020850135925060408501359150606085013567ffffffffffffffff8111156113ce575f80fd5b6113da878288016111d2565b91505092959194509250565b5f80604083850312156113f7575f80fd5b50508035926020909101359150565b5f8060408385031215611417575f80fd5b823567ffffffffffffffff81111561142d575f80fd5b611439858286016111d2565b95602094909401359450505050565b5f60208284031215611458575f80fd5b813567ffffffffffffffff81111561146e575f80fd5b61147a848285016111d2565b949350505050565b5f60208284031215611492575f80fd5b5035919050565b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b80820180821115610194576101946114ad565b634e487b7160e01b5f52600160045260245ffd5b5f5f1982036114f9576114f96114ad565b5060010190565b600181815b8085111561153a57815f1904821115611520576115206114ad565b8085161561152d57918102915b93841c9390800290611505565b509250929050565b5f8261155057506001610194565b8161155c57505f610194565b8160018114611572576002811461157c57611598565b6001915050610194565b60ff84111561158d5761158d6114ad565b50506001821b610194565b5060208310610133831016604e8410600b84101617156115bb575081810a610194565b6115c58383611500565b805f19048211156115d8576115d86114ad565b029392505050565b5f6101918383611542565b81810381811115610194576101946114ad56fea2646970667358221220f0c383f436f8bb74409d92389c6159440a92e44496c27e0c2bbf4c3fd4bf0fdb64736f6c63430008190033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW_\x80\xFD[P`\x046\x10a\0\x85W_5`\xE0\x1C\x80c\xC2,G\xA4\x11a\0XW\x80c\xC2,G\xA4\x14a\0\xFBW\x80c\xCA\x112S\x14a\x01\x0EW\x80c\xD20\xD2?\x14a\x01!W\x80c\xE6\xBC\xBCe\x14a\x014W_\x80\xFD[\x80c_\xB9\xC3\xD4\x14a\0\x89W\x80cg\x90Z~\x14a\0\x9EW\x80ck\xD5\x89\x93\x14a\0\xC7W\x80c\xBC/\x06@\x14a\0\xDAW[_\x80\xFD[a\0\x9Ca\0\x976`\x04a\x12\x80V[a\x01GV[\0[a\0\xB1a\0\xAC6`\x04a\x13\x03V[a\x01]V[`@Qa\0\xBE\x91\x90a\x13MV[`@Q\x80\x91\x03\x90\xF3[a\0\x9Ca\0\xD56`\x04a\x13\x90V[a\x01tV[a\0\xEDa\0\xE86`\x04a\x13\xE6V[a\x01\x86V[`@Q\x90\x81R` \x01a\0\xBEV[a\0\xB1a\x01\t6`\x04a\x14\x06V[a\x01\x9AV[a\0\xEDa\x01\x1C6`\x04a\x14HV[a\x01\xA6V[a\0\xEDa\x01/6`\x04a\x14\x82V[a\x01\xB0V[a\0\xEDa\x01B6`\x04a\x14\x82V[a\x01\xBAV[a\x01U\x86\x86\x86\x86\x86\x86a\x01\xC4V[PPPPPPV[``a\x01j\x84\x84\x84a\x04\xE7V[\x90P[\x93\x92PPPV[a\x01\x80\x84\x84\x84\x84a\nZV[PPPPV[_a\x01\x91\x83\x83a\n\xE6V[\x90P[\x92\x91PPV[``a\x01\x91\x83\x83a\x0B\xD8V[_a\x01\x94\x82a\x0C\rV[_a\x01\x94\x82a\r\x9DV[_a\x01\x94\x82a\x0E\x04V[_\x85\x11a\x02\x18W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x14`$\x82\x01R\x7FPre-size cannot be 0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[\x85a\x02\"\x83a\x0C\rV[\x14a\x02oW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FPre expansion root mismatch\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[\x84a\x02y\x83a\x0FHV[\x14a\x02\xECW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7FPre size does not match expansio`D\x82\x01R\x7Fn\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x0FV[\x82\x85\x10a\x03;W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FPre size not less than post size`D\x82\x01R`d\x01a\x02\x0FV[_\x85\x90P_\x80a\x03M\x85_\x87Qa\x0F\x97V[\x90P[\x85\x83\x10\x15a\x04\x0FW_a\x03c\x84\x88a\n\xE6V[\x90P\x84Q\x83\x10a\x03\xB5W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x12`$\x82\x01R\x7FIndex out of range\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[a\x03\xD9\x82\x82\x87\x86\x81Q\x81\x10a\x03\xCCWa\x03\xCCa\x14\x99V[` \x02` \x01\x01Qa\x04\xE7V[\x91P`\x01\x81\x1Ba\x03\xE9\x81\x86a\x14\xC1V[\x94P\x87\x85\x11\x15a\x03\xFBWa\x03\xFBa\x14\xD4V[\x83a\x04\x05\x81a\x14\xE8V[\x94PPPPa\x03PV[\x86a\x04\x19\x82a\x0C\rV[\x14a\x04\x8CW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7FPost expansion root not equal po`D\x82\x01R\x7Fst\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x0FV[\x83Q\x82\x14a\x04\xDCW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FIncomplete proof usage\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[PPPPPPPPPV[```@\x83\x10a\x059W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0E`$\x82\x01R\x7FLevel too high\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[_\x82\x90\x03a\x05\x89W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FCannot append empty subtree\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[`@\x84Q\x11\x15a\x05\xDBW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FMerkle expansion too large\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[\x83Q_\x03a\x06XW_a\x05\xEF\x84`\x01a\x14\xC1V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x06\x07Wa\x06\x07a\x11\xBEV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x060W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P\x82\x81\x85\x81Q\x81\x10a\x06FWa\x06Fa\x14\x99V[` \x90\x81\x02\x91\x90\x91\x01\x01R\x90Pa\x01mV[\x83Q\x83\x10a\x06\xCEW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`5`$\x82\x01R\x7FLevel greater than highest level`D\x82\x01R\x7F of current expansion\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x0FV[\x81_a\x06\xD9\x86a\x0FHV[\x90P_a\x06\xE7\x86`\x02a\x15\xE0V[a\x06\xF1\x90\x83a\x14\xC1V[\x90P_a\x06\xFD\x83a\x0E\x04V[a\x07\x06\x83a\x0E\x04V[\x11a\x07TW\x87Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x07%Wa\x07%a\x11\xBEV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x07NW\x81` \x01` \x82\x02\x806\x837\x01\x90P[Pa\x07\xA4V[\x87Qa\x07a\x90`\x01a\x14\xC1V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x07yWa\x07ya\x11\xBEV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x07\xA2W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P[\x90P`@\x81Q\x11\x15a\x07\xF8W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FAppend creates oversize tree\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[_[\x88Q\x81\x10\x15a\t\xA4W\x87\x81\x10\x15a\x08\xA0W\x88\x81\x81Q\x81\x10a\x08\x1DWa\x08\x1Da\x14\x99V[` \x02` \x01\x01Q_\x80\x1B\x14a\x08\x9BW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7FAppend above least significant b`D\x82\x01R\x7Fit\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x0FV[a\t\x9CV[_\x85\x90\x03a\x08\xE5W\x88\x81\x81Q\x81\x10a\x08\xBAWa\x08\xBAa\x14\x99V[` \x02` \x01\x01Q\x82\x82\x81Q\x81\x10a\x08\xD4Wa\x08\xD4a\x14\x99V[` \x02` \x01\x01\x81\x81RPPa\t\x9CV[\x88\x81\x81Q\x81\x10a\x08\xF7Wa\x08\xF7a\x14\x99V[` \x02` \x01\x01Q_\x80\x1B\x03a\t-W\x84\x82\x82\x81Q\x81\x10a\t\x1AWa\t\x1Aa\x14\x99V[` \x90\x81\x02\x91\x90\x91\x01\x01R_\x94Pa\t\x9CV[_\x80\x1B\x82\x82\x81Q\x81\x10a\tBWa\tBa\x14\x99V[` \x02` \x01\x01\x81\x81RPP\x88\x81\x81Q\x81\x10a\t`Wa\t`a\x14\x99V[` \x02` \x01\x01Q\x85`@Q` \x01a\t\x83\x92\x91\x90\x91\x82R` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x94P[`\x01\x01a\x07\xFAV[P\x83\x15a\t\xD8W\x83\x81`\x01\x83Qa\t\xBB\x91\x90a\x15\xEBV[\x81Q\x81\x10a\t\xCBWa\t\xCBa\x14\x99V[` \x02` \x01\x01\x81\x81RPP[\x80`\x01\x82Qa\t\xE7\x91\x90a\x15\xEBV[\x81Q\x81\x10a\t\xF7Wa\t\xF7a\x14\x99V[` \x02` \x01\x01Q_\x80\x1B\x03a\nOW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0F`$\x82\x01R\x7FLast entry zero\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[\x97\x96PPPPPPPV[_a\n\x8E\x82\x84\x86`@Q` \x01a\ns\x91\x81R` \x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 a\x11\x0BV[\x90P\x80\x85\x14a\n\xDFW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FInvalid inclusion proof\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[PPPPPV[_\x81\x83\x10a\x0B6W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FStart not less than end\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[_a\x0BB\x83\x85\x18a\x0E\x04V[\x90P_`\x01a\x0BQ\x83\x82a\x14\xC1V[`\x01\x90\x1Ba\x0B_\x91\x90a\x15\xEBV[\x90P\x84\x81\x16\x84\x82\x16\x81\x15a\x0B\x81Wa\x0Bv\x82a\r\x9DV[\x94PPPPPa\x01\x94V[\x80\x15a\x0B\x90Wa\x0Bv\x81a\x0E\x04V[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FBoth y and z cannot be zero\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[``a\x01\x91\x83_\x84`@Q` \x01a\x0B\xF2\x91\x81R` \x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 a\x04\xE7V[_\x80\x82Q\x11a\x0C^W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FEmpty merkle expansion\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[`@\x82Q\x11\x15a\x0C\xB0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FMerkle expansion too large\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[_\x80[\x83Q\x81\x10\x15a\r\x96W_\x84\x82\x81Q\x81\x10a\x0C\xCFWa\x0C\xCFa\x14\x99V[` \x02` \x01\x01Q\x90P\x82_\x80\x1B\x03a\r9W\x80\x15a\r4W\x80\x92P`\x01\x85Qa\x0C\xF9\x91\x90a\x15\xEBV[\x82\x14a\r4W`@Qa\r\x1B\x90\x84\x90_\x90` \x01\x91\x82R` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x92P[a\r\x8DV[\x80\x15a\rXW`@\x80Q` \x81\x01\x83\x90R\x90\x81\x01\x84\x90R``\x01a\r\x1BV[`@Qa\rt\x90\x84\x90_\x90` \x01\x91\x82R` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x92P[P`\x01\x01a\x0C\xB3V[P\x92\x91PPV[_\x80\x82\x11a\r\xEDW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FZero has no significant bits\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[_\x82\x80a\r\xFB`\x01\x82a\x15\xEBV[\x16\x18\x90Pa\x01m\x81[_\x81_\x03a\x0ETW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FZero has no significant bits\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[p\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x10a\x0E\x7FW`\x80\x91\x82\x1C\x91a\x0E|\x90\x82a\x14\xC1V[\x90P[h\x01\0\0\0\0\0\0\0\0\x82\x10a\x0E\xA2W`@\x91\x82\x1C\x91a\x0E\x9F\x90\x82a\x14\xC1V[\x90P[d\x01\0\0\0\0\x82\x10a\x0E\xC1W` \x91\x82\x1C\x91a\x0E\xBE\x90\x82a\x14\xC1V[\x90P[b\x01\0\0\x82\x10a\x0E\xDEW`\x10\x91\x82\x1C\x91a\x0E\xDB\x90\x82a\x14\xC1V[\x90P[a\x01\0\x82\x10a\x0E\xFAW`\x08\x91\x82\x1C\x91a\x0E\xF7\x90\x82a\x14\xC1V[\x90P[`\x10\x82\x10a\x0F\x15W`\x04\x91\x82\x1C\x91a\x0F\x12\x90\x82a\x14\xC1V[\x90P[`\x04\x82\x10a\x0F0W`\x02\x91\x82\x1C\x91a\x0F-\x90\x82a\x14\xC1V[\x90P[`\x02\x82\x10a\x0FCWa\x01\x94`\x01\x82a\x14\xC1V[\x91\x90PV[_\x80\x80[\x83Q\x81\x10\x15a\r\x96W\x83\x81\x81Q\x81\x10a\x0FgWa\x0Fga\x14\x99V[` \x02` \x01\x01Q_\x80\x1B\x14a\x0F\x8FWa\x0F\x82\x81`\x02a\x15\xE0V[a\x0F\x8C\x90\x83a\x14\xC1V[\x91P[`\x01\x01a\x0FLV[``\x81\x83\x10a\x0F\xE8W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x17`$\x82\x01R\x7FStart not less than end\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x02\x0FV[\x83Q\x82\x11\x15a\x10_W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7FEnd not less or equal than lengt`D\x82\x01R\x7Fh\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x02\x0FV[_a\x10j\x84\x84a\x15\xEBV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x10\x82Wa\x10\x82a\x11\xBEV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x10\xABW\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P\x83[\x83\x81\x10\x15a\x11\x02W\x85\x81\x81Q\x81\x10a\x10\xCAWa\x10\xCAa\x14\x99V[` \x02` \x01\x01Q\x82\x86\x83a\x10\xDF\x91\x90a\x15\xEBV[\x81Q\x81\x10a\x10\xEFWa\x10\xEFa\x14\x99V[` \x90\x81\x02\x91\x90\x91\x01\x01R`\x01\x01a\x10\xB0V[P\x94\x93PPPPV[\x82Q_\x90a\x01\0\x81\x11\x15a\x11VW`@Q\x7F\xFD\xAC3\x1E\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x81\x01\x82\x90Ra\x01\0`$\x82\x01R`D\x01a\x02\x0FV[\x82_[\x82\x81\x10\x15a\x11\xB4W_\x87\x82\x81Q\x81\x10a\x11tWa\x11ta\x14\x99V[` \x02` \x01\x01Q\x90P\x81`\x01\x90\x1B\x87\x16_\x03a\x11\x9DW\x82_R\x80` R`@_ \x92Pa\x11\xABV[\x80_R\x82` R`@_ \x92P[P`\x01\x01a\x11YV[P\x95\x94PPPPPV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[_\x82`\x1F\x83\x01\x12a\x11\xE1W_\x80\xFD[\x815` g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x83\x11\x15a\x11\xFEWa\x11\xFEa\x11\xBEV[\x82`\x05\x1B`@Q\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`?\x83\x01\x16\x81\x01\x81\x81\x10\x84\x82\x11\x17\x15a\x12AWa\x12Aa\x11\xBEV[`@R\x93\x84R` \x81\x87\x01\x81\x01\x94\x90\x81\x01\x92P\x87\x85\x11\x15a\x12`W_\x80\xFD[` \x87\x01\x91P[\x84\x82\x10\x15a\nOW\x815\x83R\x91\x83\x01\x91\x90\x83\x01\x90a\x12gV[_\x80_\x80_\x80`\xC0\x87\x89\x03\x12\x15a\x12\x95W_\x80\xFD[\x865\x95P` \x87\x015\x94P`@\x87\x015\x93P``\x87\x015\x92P`\x80\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x82\x11\x15a\x12\xC8W_\x80\xFD[a\x12\xD4\x8A\x83\x8B\x01a\x11\xD2V[\x93P`\xA0\x89\x015\x91P\x80\x82\x11\x15a\x12\xE9W_\x80\xFD[Pa\x12\xF6\x89\x82\x8A\x01a\x11\xD2V[\x91PP\x92\x95P\x92\x95P\x92\x95V[_\x80_``\x84\x86\x03\x12\x15a\x13\x15W_\x80\xFD[\x835g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x13+W_\x80\xFD[a\x137\x86\x82\x87\x01a\x11\xD2V[\x96` \x86\x015\x96P`@\x90\x95\x015\x94\x93PPPPV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R_\x91\x90\x84\x82\x01\x90`@\x85\x01\x90\x84[\x81\x81\x10\x15a\x13\x84W\x83Q\x83R\x92\x84\x01\x92\x91\x84\x01\x91`\x01\x01a\x13hV[P\x90\x96\x95PPPPPPV[_\x80_\x80`\x80\x85\x87\x03\x12\x15a\x13\xA3W_\x80\xFD[\x845\x93P` \x85\x015\x92P`@\x85\x015\x91P``\x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x13\xCEW_\x80\xFD[a\x13\xDA\x87\x82\x88\x01a\x11\xD2V[\x91PP\x92\x95\x91\x94P\x92PV[_\x80`@\x83\x85\x03\x12\x15a\x13\xF7W_\x80\xFD[PP\x805\x92` \x90\x91\x015\x91PV[_\x80`@\x83\x85\x03\x12\x15a\x14\x17W_\x80\xFD[\x825g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x14-W_\x80\xFD[a\x149\x85\x82\x86\x01a\x11\xD2V[\x95` \x94\x90\x94\x015\x94PPPPV[_` \x82\x84\x03\x12\x15a\x14XW_\x80\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x14nW_\x80\xFD[a\x14z\x84\x82\x85\x01a\x11\xD2V[\x94\x93PPPPV[_` \x82\x84\x03\x12\x15a\x14\x92W_\x80\xFD[P5\x91\x90PV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x80\x82\x01\x80\x82\x11\x15a\x01\x94Wa\x01\x94a\x14\xADV[cNH{q`\xE0\x1B_R`\x01`\x04R`$_\xFD[__\x19\x82\x03a\x14\xF9Wa\x14\xF9a\x14\xADV[P`\x01\x01\x90V[`\x01\x81\x81[\x80\x85\x11\x15a\x15:W\x81_\x19\x04\x82\x11\x15a\x15 Wa\x15 a\x14\xADV[\x80\x85\x16\x15a\x15-W\x91\x81\x02\x91[\x93\x84\x1C\x93\x90\x80\x02\x90a\x15\x05V[P\x92P\x92\x90PV[_\x82a\x15PWP`\x01a\x01\x94V[\x81a\x15\\WP_a\x01\x94V[\x81`\x01\x81\x14a\x15rW`\x02\x81\x14a\x15|Wa\x15\x98V[`\x01\x91PPa\x01\x94V[`\xFF\x84\x11\x15a\x15\x8DWa\x15\x8Da\x14\xADV[PP`\x01\x82\x1Ba\x01\x94V[P` \x83\x10a\x013\x83\x10\x16`N\x84\x10`\x0B\x84\x10\x16\x17\x15a\x15\xBBWP\x81\x81\na\x01\x94V[a\x15\xC5\x83\x83a\x15\0V[\x80_\x19\x04\x82\x11\x15a\x15\xD8Wa\x15\xD8a\x14\xADV[\x02\x93\x92PPPV[_a\x01\x91\x83\x83a\x15BV[\x81\x81\x03\x81\x81\x11\x15a\x01\x94Wa\x01\x94a\x14\xADV\xFE\xA2dipfsX\"\x12 \xF0\xC3\x83\xF46\xF8\xBBt@\x9D\x928\x9CaYD\n\x92\xE4D\x96\xC2~\x0C+\xBFL?\xD4\xBF\x0F\xDBdsolcC\0\x08\x19\x003",
    );
    /**Custom error with signature `MerkleProofTooLong(uint256,uint256)` and selector `0xfdac331e`.
```solidity
error MerkleProofTooLong(uint256 actualLength, uint256 maxProofLength);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MerkleProofTooLong {
        pub actualLength: alloy::sol_types::private::primitives::aliases::U256,
        pub maxProofLength: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<MerkleProofTooLong> for UnderlyingRustTuple<'_> {
            fn from(value: MerkleProofTooLong) -> Self {
                (value.actualLength, value.maxProofLength)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for MerkleProofTooLong {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    actualLength: tuple.0,
                    maxProofLength: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for MerkleProofTooLong {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MerkleProofTooLong(uint256,uint256)";
            const SELECTOR: [u8; 4] = [253u8, 172u8, 51u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.actualLength),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxProofLength),
                )
            }
        }
    };
    /**Function with signature `appendCompleteSubTree(bytes32[],uint256,bytes32)` and selector `0x67905a7e`.
```solidity
function appendCompleteSubTree(bytes32[] memory me, uint256 level, bytes32 subtreeRoot) external pure returns (bytes32[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct appendCompleteSubTreeCall {
        pub me: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub level: alloy::sol_types::private::primitives::aliases::U256,
        pub subtreeRoot: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`appendCompleteSubTree(bytes32[],uint256,bytes32)`](appendCompleteSubTreeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct appendCompleteSubTreeReturn {
        pub _0: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<appendCompleteSubTreeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: appendCompleteSubTreeCall) -> Self {
                    (value.me, value.level, value.subtreeRoot)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for appendCompleteSubTreeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        me: tuple.0,
                        level: tuple.1,
                        subtreeRoot: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<appendCompleteSubTreeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: appendCompleteSubTreeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for appendCompleteSubTreeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for appendCompleteSubTreeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = appendCompleteSubTreeReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "appendCompleteSubTree(bytes32[],uint256,bytes32)";
            const SELECTOR: [u8; 4] = [103u8, 144u8, 90u8, 126u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.me),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.level),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.subtreeRoot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `appendLeaf(bytes32[],bytes32)` and selector `0xc22c47a4`.
```solidity
function appendLeaf(bytes32[] memory me, bytes32 leaf) external pure returns (bytes32[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct appendLeafCall {
        pub me: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub leaf: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`appendLeaf(bytes32[],bytes32)`](appendLeafCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct appendLeafReturn {
        pub _0: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<appendLeafCall> for UnderlyingRustTuple<'_> {
                fn from(value: appendLeafCall) -> Self {
                    (value.me, value.leaf)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for appendLeafCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { me: tuple.0, leaf: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<appendLeafReturn> for UnderlyingRustTuple<'_> {
                fn from(value: appendLeafReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for appendLeafReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for appendLeafCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = appendLeafReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "appendLeaf(bytes32[],bytes32)";
            const SELECTOR: [u8; 4] = [194u8, 44u8, 71u8, 164u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.me),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.leaf),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `leastSignificantBit(uint256)` and selector `0xd230d23f`.
```solidity
function leastSignificantBit(uint256 x) external pure returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct leastSignificantBitCall {
        pub x: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`leastSignificantBit(uint256)`](leastSignificantBitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct leastSignificantBitReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<leastSignificantBitCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: leastSignificantBitCall) -> Self {
                    (value.x,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for leastSignificantBitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { x: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<leastSignificantBitReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: leastSignificantBitReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for leastSignificantBitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for leastSignificantBitCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = leastSignificantBitReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "leastSignificantBit(uint256)";
            const SELECTOR: [u8; 4] = [210u8, 48u8, 210u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.x),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `maximumAppendBetween(uint256,uint256)` and selector `0xbc2f0640`.
```solidity
function maximumAppendBetween(uint256 startSize, uint256 endSize) external pure returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct maximumAppendBetweenCall {
        pub startSize: alloy::sol_types::private::primitives::aliases::U256,
        pub endSize: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`maximumAppendBetween(uint256,uint256)`](maximumAppendBetweenCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct maximumAppendBetweenReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<maximumAppendBetweenCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: maximumAppendBetweenCall) -> Self {
                    (value.startSize, value.endSize)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for maximumAppendBetweenCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        startSize: tuple.0,
                        endSize: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<maximumAppendBetweenReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: maximumAppendBetweenReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for maximumAppendBetweenReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for maximumAppendBetweenCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = maximumAppendBetweenReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "maximumAppendBetween(uint256,uint256)";
            const SELECTOR: [u8; 4] = [188u8, 47u8, 6u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.startSize),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.endSize),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `mostSignificantBit(uint256)` and selector `0xe6bcbc65`.
```solidity
function mostSignificantBit(uint256 x) external pure returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mostSignificantBitCall {
        pub x: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`mostSignificantBit(uint256)`](mostSignificantBitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mostSignificantBitReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mostSignificantBitCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: mostSignificantBitCall) -> Self {
                    (value.x,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for mostSignificantBitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { x: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mostSignificantBitReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: mostSignificantBitReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for mostSignificantBitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mostSignificantBitCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = mostSignificantBitReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "mostSignificantBit(uint256)";
            const SELECTOR: [u8; 4] = [230u8, 188u8, 188u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.x),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `root(bytes32[])` and selector `0xca113253`.
```solidity
function root(bytes32[] memory me) external pure returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rootCall {
        pub me: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
    }
    ///Container type for the return parameters of the [`root(bytes32[])`](rootCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rootReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rootCall> for UnderlyingRustTuple<'_> {
                fn from(value: rootCall) -> Self {
                    (value.me,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rootCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { me: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rootReturn> for UnderlyingRustTuple<'_> {
                fn from(value: rootReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rootReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for rootCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = rootReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "root(bytes32[])";
            const SELECTOR: [u8; 4] = [202u8, 17u8, 50u8, 83u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.me),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `verifyInclusionProof(bytes32,bytes32,uint256,bytes32[])` and selector `0x6bd58993`.
```solidity
function verifyInclusionProof(bytes32 rootHash, bytes32 leaf, uint256 index, bytes32[] memory proof) external pure;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct verifyInclusionProofCall {
        pub rootHash: alloy::sol_types::private::FixedBytes<32>,
        pub leaf: alloy::sol_types::private::FixedBytes<32>,
        pub index: alloy::sol_types::private::primitives::aliases::U256,
        pub proof: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
    }
    ///Container type for the return parameters of the [`verifyInclusionProof(bytes32,bytes32,uint256,bytes32[])`](verifyInclusionProofCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct verifyInclusionProofReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<verifyInclusionProofCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: verifyInclusionProofCall) -> Self {
                    (value.rootHash, value.leaf, value.index, value.proof)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for verifyInclusionProofCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        rootHash: tuple.0,
                        leaf: tuple.1,
                        index: tuple.2,
                        proof: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<verifyInclusionProofReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: verifyInclusionProofReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for verifyInclusionProofReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for verifyInclusionProofCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = verifyInclusionProofReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "verifyInclusionProof(bytes32,bytes32,uint256,bytes32[])";
            const SELECTOR: [u8; 4] = [107u8, 213u8, 137u8, 147u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.rootHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.leaf),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.proof),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `verifyPrefixProof(bytes32,uint256,bytes32,uint256,bytes32[],bytes32[])` and selector `0x5fb9c3d4`.
```solidity
function verifyPrefixProof(bytes32 preRoot, uint256 preSize, bytes32 postRoot, uint256 postSize, bytes32[] memory preExpansion, bytes32[] memory proof) external pure;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct verifyPrefixProofCall {
        pub preRoot: alloy::sol_types::private::FixedBytes<32>,
        pub preSize: alloy::sol_types::private::primitives::aliases::U256,
        pub postRoot: alloy::sol_types::private::FixedBytes<32>,
        pub postSize: alloy::sol_types::private::primitives::aliases::U256,
        pub preExpansion: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub proof: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
    }
    ///Container type for the return parameters of the [`verifyPrefixProof(bytes32,uint256,bytes32,uint256,bytes32[],bytes32[])`](verifyPrefixProofCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct verifyPrefixProofReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
                alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<verifyPrefixProofCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: verifyPrefixProofCall) -> Self {
                    (
                        value.preRoot,
                        value.preSize,
                        value.postRoot,
                        value.postSize,
                        value.preExpansion,
                        value.proof,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for verifyPrefixProofCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        preRoot: tuple.0,
                        preSize: tuple.1,
                        postRoot: tuple.2,
                        postSize: tuple.3,
                        preExpansion: tuple.4,
                        proof: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<verifyPrefixProofReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: verifyPrefixProofReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for verifyPrefixProofReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for verifyPrefixProofCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = verifyPrefixProofReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "verifyPrefixProof(bytes32,uint256,bytes32,uint256,bytes32[],bytes32[])";
            const SELECTOR: [u8; 4] = [95u8, 185u8, 195u8, 212u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.preRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.preSize),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.postRoot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.postSize),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.preExpansion),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.proof),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`MerkleTreeAccess`](self) function calls.
    pub enum MerkleTreeAccessCalls {
        appendCompleteSubTree(appendCompleteSubTreeCall),
        appendLeaf(appendLeafCall),
        leastSignificantBit(leastSignificantBitCall),
        maximumAppendBetween(maximumAppendBetweenCall),
        mostSignificantBit(mostSignificantBitCall),
        root(rootCall),
        verifyInclusionProof(verifyInclusionProofCall),
        verifyPrefixProof(verifyPrefixProofCall),
    }
    #[automatically_derived]
    impl MerkleTreeAccessCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [95u8, 185u8, 195u8, 212u8],
            [103u8, 144u8, 90u8, 126u8],
            [107u8, 213u8, 137u8, 147u8],
            [188u8, 47u8, 6u8, 64u8],
            [194u8, 44u8, 71u8, 164u8],
            [202u8, 17u8, 50u8, 83u8],
            [210u8, 48u8, 210u8, 63u8],
            [230u8, 188u8, 188u8, 101u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for MerkleTreeAccessCalls {
        const NAME: &'static str = "MerkleTreeAccessCalls";
        const MIN_DATA_LENGTH: usize = 32usize;
        const COUNT: usize = 8usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::appendCompleteSubTree(_) => {
                    <appendCompleteSubTreeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::appendLeaf(_) => {
                    <appendLeafCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::leastSignificantBit(_) => {
                    <leastSignificantBitCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::maximumAppendBetween(_) => {
                    <maximumAppendBetweenCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::mostSignificantBit(_) => {
                    <mostSignificantBitCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::root(_) => <rootCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::verifyInclusionProof(_) => {
                    <verifyInclusionProofCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::verifyPrefixProof(_) => {
                    <verifyPrefixProofCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<MerkleTreeAccessCalls>] = &[
                {
                    fn verifyPrefixProof(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MerkleTreeAccessCalls> {
                        <verifyPrefixProofCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MerkleTreeAccessCalls::verifyPrefixProof)
                    }
                    verifyPrefixProof
                },
                {
                    fn appendCompleteSubTree(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MerkleTreeAccessCalls> {
                        <appendCompleteSubTreeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MerkleTreeAccessCalls::appendCompleteSubTree)
                    }
                    appendCompleteSubTree
                },
                {
                    fn verifyInclusionProof(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MerkleTreeAccessCalls> {
                        <verifyInclusionProofCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MerkleTreeAccessCalls::verifyInclusionProof)
                    }
                    verifyInclusionProof
                },
                {
                    fn maximumAppendBetween(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MerkleTreeAccessCalls> {
                        <maximumAppendBetweenCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MerkleTreeAccessCalls::maximumAppendBetween)
                    }
                    maximumAppendBetween
                },
                {
                    fn appendLeaf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MerkleTreeAccessCalls> {
                        <appendLeafCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MerkleTreeAccessCalls::appendLeaf)
                    }
                    appendLeaf
                },
                {
                    fn root(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MerkleTreeAccessCalls> {
                        <rootCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MerkleTreeAccessCalls::root)
                    }
                    root
                },
                {
                    fn leastSignificantBit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MerkleTreeAccessCalls> {
                        <leastSignificantBitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MerkleTreeAccessCalls::leastSignificantBit)
                    }
                    leastSignificantBit
                },
                {
                    fn mostSignificantBit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MerkleTreeAccessCalls> {
                        <mostSignificantBitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MerkleTreeAccessCalls::mostSignificantBit)
                    }
                    mostSignificantBit
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::appendCompleteSubTree(inner) => {
                    <appendCompleteSubTreeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::appendLeaf(inner) => {
                    <appendLeafCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::leastSignificantBit(inner) => {
                    <leastSignificantBitCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::maximumAppendBetween(inner) => {
                    <maximumAppendBetweenCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::mostSignificantBit(inner) => {
                    <mostSignificantBitCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::root(inner) => {
                    <rootCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::verifyInclusionProof(inner) => {
                    <verifyInclusionProofCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::verifyPrefixProof(inner) => {
                    <verifyPrefixProofCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::appendCompleteSubTree(inner) => {
                    <appendCompleteSubTreeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::appendLeaf(inner) => {
                    <appendLeafCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::leastSignificantBit(inner) => {
                    <leastSignificantBitCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::maximumAppendBetween(inner) => {
                    <maximumAppendBetweenCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::mostSignificantBit(inner) => {
                    <mostSignificantBitCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::root(inner) => {
                    <rootCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::verifyInclusionProof(inner) => {
                    <verifyInclusionProofCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::verifyPrefixProof(inner) => {
                    <verifyPrefixProofCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`MerkleTreeAccess`](self) custom errors.
    pub enum MerkleTreeAccessErrors {
        MerkleProofTooLong(MerkleProofTooLong),
    }
    #[automatically_derived]
    impl MerkleTreeAccessErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[[253u8, 172u8, 51u8, 30u8]];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for MerkleTreeAccessErrors {
        const NAME: &'static str = "MerkleTreeAccessErrors";
        const MIN_DATA_LENGTH: usize = 64usize;
        const COUNT: usize = 1usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::MerkleProofTooLong(_) => {
                    <MerkleProofTooLong as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<MerkleTreeAccessErrors>] = &[
                {
                    fn MerkleProofTooLong(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<MerkleTreeAccessErrors> {
                        <MerkleProofTooLong as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(MerkleTreeAccessErrors::MerkleProofTooLong)
                    }
                    MerkleProofTooLong
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::MerkleProofTooLong(inner) => {
                    <MerkleProofTooLong as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::MerkleProofTooLong(inner) => {
                    <MerkleProofTooLong as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`MerkleTreeAccess`](self) contract instance.

See the [wrapper's documentation](`MerkleTreeAccessInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> MerkleTreeAccessInstance<T, P, N> {
        MerkleTreeAccessInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<MerkleTreeAccessInstance<T, P, N>>,
    > {
        MerkleTreeAccessInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        MerkleTreeAccessInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`MerkleTreeAccess`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`MerkleTreeAccess`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct MerkleTreeAccessInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for MerkleTreeAccessInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("MerkleTreeAccessInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MerkleTreeAccessInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`MerkleTreeAccess`](self) contract instance.

See the [wrapper's documentation](`MerkleTreeAccessInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<MerkleTreeAccessInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> MerkleTreeAccessInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> MerkleTreeAccessInstance<T, P, N> {
            MerkleTreeAccessInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MerkleTreeAccessInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`appendCompleteSubTree`] function.
        pub fn appendCompleteSubTree(
            &self,
            me: alloy::sol_types::private::Vec<
                alloy::sol_types::private::FixedBytes<32>,
            >,
            level: alloy::sol_types::private::primitives::aliases::U256,
            subtreeRoot: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, appendCompleteSubTreeCall, N> {
            self.call_builder(
                &appendCompleteSubTreeCall {
                    me,
                    level,
                    subtreeRoot,
                },
            )
        }
        ///Creates a new call builder for the [`appendLeaf`] function.
        pub fn appendLeaf(
            &self,
            me: alloy::sol_types::private::Vec<
                alloy::sol_types::private::FixedBytes<32>,
            >,
            leaf: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, appendLeafCall, N> {
            self.call_builder(&appendLeafCall { me, leaf })
        }
        ///Creates a new call builder for the [`leastSignificantBit`] function.
        pub fn leastSignificantBit(
            &self,
            x: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, leastSignificantBitCall, N> {
            self.call_builder(&leastSignificantBitCall { x })
        }
        ///Creates a new call builder for the [`maximumAppendBetween`] function.
        pub fn maximumAppendBetween(
            &self,
            startSize: alloy::sol_types::private::primitives::aliases::U256,
            endSize: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, maximumAppendBetweenCall, N> {
            self.call_builder(
                &maximumAppendBetweenCall {
                    startSize,
                    endSize,
                },
            )
        }
        ///Creates a new call builder for the [`mostSignificantBit`] function.
        pub fn mostSignificantBit(
            &self,
            x: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, mostSignificantBitCall, N> {
            self.call_builder(&mostSignificantBitCall { x })
        }
        ///Creates a new call builder for the [`root`] function.
        pub fn root(
            &self,
            me: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
        ) -> alloy_contract::SolCallBuilder<T, &P, rootCall, N> {
            self.call_builder(&rootCall { me })
        }
        ///Creates a new call builder for the [`verifyInclusionProof`] function.
        pub fn verifyInclusionProof(
            &self,
            rootHash: alloy::sol_types::private::FixedBytes<32>,
            leaf: alloy::sol_types::private::FixedBytes<32>,
            index: alloy::sol_types::private::primitives::aliases::U256,
            proof: alloy::sol_types::private::Vec<
                alloy::sol_types::private::FixedBytes<32>,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, verifyInclusionProofCall, N> {
            self.call_builder(
                &verifyInclusionProofCall {
                    rootHash,
                    leaf,
                    index,
                    proof,
                },
            )
        }
        ///Creates a new call builder for the [`verifyPrefixProof`] function.
        pub fn verifyPrefixProof(
            &self,
            preRoot: alloy::sol_types::private::FixedBytes<32>,
            preSize: alloy::sol_types::private::primitives::aliases::U256,
            postRoot: alloy::sol_types::private::FixedBytes<32>,
            postSize: alloy::sol_types::private::primitives::aliases::U256,
            preExpansion: alloy::sol_types::private::Vec<
                alloy::sol_types::private::FixedBytes<32>,
            >,
            proof: alloy::sol_types::private::Vec<
                alloy::sol_types::private::FixedBytes<32>,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, verifyPrefixProofCall, N> {
            self.call_builder(
                &verifyPrefixProofCall {
                    preRoot,
                    preSize,
                    postRoot,
                    postSize,
                    preExpansion,
                    proof,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > MerkleTreeAccessInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
